{"task_id": "Mbpp/2", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n\"\"\"\nWrite a function to find the shared elements from the given two lists.\n\"\"\"", "entry_point": "similar_elements", "canonical_solution": "def similar_elements(test_tup1, test_tup2):\n  return tuple(set(test_tup1) & set(test_tup2))", "input_output_examples": "[[[[3, 4, 5, 6], [5, 7, 4, 10]]], [[(4, 5)]]]", "starter_code": "from typing import List\nfrom typing import Tuple\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:", "llm_generated_inputs": "[[[1, 2, 3, 4], [3, 4, 5, 6]], [[7, 8, 9], [10, 11, 12]], [[1, 1, 2, 2], [2, 2, 3, 3]], [[], [1, 2, 3]], [[1, 2, 3], []], [[], []], [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1]]]", "clusters": {"cluster_list": [{"programs_str": ["def similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1).intersection(set(test_tup2)))", "def similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))", "def similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1).intersection(set(test_tup2)))", "def similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1).intersection(set(test_tup2)))", "def similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))", "def similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1).intersection(set(test_tup2)))", "def similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))"], "outputs": "[['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError']]", "probability": 0.35, "is_align_req": false, "test_consistency": 0.0, "failed_input_output_examples": "[[[[3, 4, 5, 6], [5, 7, 4, 10]], ['NameError'], [(4, 5)]]]"}, {"programs_str": ["from typing import List\nfrom typing import Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))", "from typing import List\nfrom typing import Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))", "from typing import List, Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1).intersection(set(test_tup2)))", "from typing import List, Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))", "from typing import List\nfrom typing import Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1).intersection(set(test_tup2)))", "from typing import List, Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1).intersection(set(test_tup2)))", "from typing import List, Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))", "from typing import List\nfrom typing import Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1).intersection(set(test_tup2)))", "from typing import List, Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))", "from typing import List, Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))", "from typing import List\nfrom typing import Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))", "from typing import List, Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))", "from typing import List\nfrom typing import Tuple\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n    return tuple(set(test_tup1) & set(test_tup2))"], "outputs": "[[(3, 4)], [()], [(2,)], [()], [()], [()], [(1, 2, 3, 4, 5)]]", "probability": 0.65, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0.9340680553754911, "llm_generated_inputs": "[[[1, 2, 3, 4], [3, 4, 5, 6]], [[7, 8, 9], [10, 11, 12]], [[1, 1, 2, 2], [2, 2, 3, 3]], [[], [1, 2, 3]], [[1, 2, 3], []], [[], []], [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1]]]", "input_output_examples": "[[[[3, 4, 5, 6], [5, 7, 4, 10]]], [[(4, 5)]]]", "weighted_test_consistency": 0.65, "at_least_one_align": true, "ambiguity": 0.6420340276877455}}
{"task_id": "Mbpp/3", "requirement": "def is_not_prime(n: int) -> bool:\n\"\"\"\nWrite a python function to identify non-prime numbers.\n\"\"\"", "entry_point": "is_not_prime", "canonical_solution": "import math\ndef is_not_prime(n):\n    if n == 1:\n        return True\n    for i in range(2, int(math.sqrt(n))+1):\n        if n % i == 0:\n            return True\n    return False", "input_output_examples": "[[[2]], [[False]]]", "starter_code": "def is_not_prime(n: int) -> bool:", "llm_generated_inputs": "[[2], [3], [4], [5], [9], [10], [11], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [-1], [0], [1]]", "clusters": {"cluster_list": [{"programs_str": ["def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "def is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False"], "outputs": "[[False], [False], [True], [False], [True], [True], [False], [True], [True], [False], [True], [False], [True], [True], [True], [False], [True], [True], [True], [True], [True], [False], [True], [True], [True], [True]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[2], [3], [4], [5], [9], [10], [11], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [-1], [0], [1]]", "input_output_examples": "[[[2]], [[False]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/4", "requirement": "def heap_queue_largest(nums: list, n: int) -> list:\n\"\"\"\nWrite a function to find the n largest integers from a given list of numbers, returned in descending order.\n\n\n\"\"\"", "entry_point": "heap_queue_largest", "canonical_solution": "import heapq as hq\ndef heap_queue_largest(nums: list,n: int) -> list:\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "input_output_examples": "[[[[25, 35, 22, 85, 14, 65, 75, 22, 58], 3]], [[[85, 75, 65]]]]", "starter_code": "def heap_queue_largest(nums: list, n: int) -> list:", "llm_generated_inputs": "[[[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3], [[10, 20, 30, 40, 50], 2], [[1, 2, 3], 5], [[], 1], [[5, 5, 5, 5], 2], [[7], 1], [[7, 7, 7, 7], 4], [[100, 200, 300, 400, 500], 0], [[100, 200, 300, 400, 500], -1]]", "clusters": {"cluster_list": [{"programs_str": ["from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)[::-1]"], "outputs": "[[[5, 6, 9]], [[40, 50]], [[1, 2, 3]], [[]], [[5, 5]], [[7]], [[7, 7, 7, 7]], [[]], [[]]]", "probability": 0.75, "is_align_req": false, "test_consistency": 0.0, "failed_input_output_examples": "[[[[25, 35, 22, 85, 14, 65, 75, 22, 58], 3], [[65, 75, 85]], [[85, 75, 65]]]]"}, {"programs_str": ["import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)"], "outputs": "[[[9, 6, 5]], [[50, 40]], [[3, 2, 1]], [[]], [[5, 5]], [[7]], [[7, 7, 7, 7]], [[]], [[]]]", "probability": 0.25, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0.8112781244591328, "llm_generated_inputs": "[[[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3], [[10, 20, 30, 40, 50], 2], [[1, 2, 3], 5], [[], 1], [[5, 5, 5, 5], 2], [[7], 1], [[7, 7, 7, 7], 4], [[100, 200, 300, 400, 500], 0], [[100, 200, 300, 400, 500], -1]]", "input_output_examples": "[[[[25, 35, 22, 85, 14, 65, 75, 22, 58], 3]], [[[85, 75, 65]]]]", "weighted_test_consistency": 0.25, "at_least_one_align": true, "ambiguity": 0.7806390622295665}}
{"task_id": "Mbpp/6", "requirement": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n\"\"\"\nWrite a python function to check whether the two numbers differ at one bit position only or not.\n\"\"\"", "entry_point": "differ_At_One_Bit_Pos", "canonical_solution": "def is_Power_Of_Two(x: int): \n    return x > 0 and (x & (x - 1)) == 0\ndef differ_At_One_Bit_Pos(a: int,b: int):\n    return is_Power_Of_Two(a ^ b)", "input_output_examples": "[[[13, 9]], [[True]]]", "starter_code": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:", "llm_generated_inputs": "[[0, 1], [1, 0], [2, 3], [4, 5], [8, 9], [16, 17], [32, 33], [64, 65], [1, 2], [3, 1], [0, 0], [1, 1], [255, 254], [255, 253], [128, 0], [128, 129], [1024, 1025], [1024, 1026], [2048, 2049], [2048, 2050]]", "clusters": {"cluster_list": [{"programs_str": ["def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b) & (a ^ b) - 1 == 0 and a != b", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0 and xor_result != 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0 and xor_result != 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0 and xor_result != 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0 and xor_result != 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0 and xor_result != 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    return (a ^ b).bit_count() == 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0 and xor_result != 0"], "outputs": "[[True], [True], [True], [True], [True], [True], [True], [True], [False], [True], [False], [False], [True], [True], [True], [True], [True], [True], [True], [True]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[0, 1], [1, 0], [2, 3], [4, 5], [8, 9], [16, 17], [32, 33], [64, 65], [1, 2], [3, 1], [0, 0], [1, 1], [255, 254], [255, 253], [128, 0], [128, 129], [1024, 1025], [1024, 1026], [2048, 2049], [2048, 2050]]", "input_output_examples": "[[[13, 9]], [[True]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/7", "requirement": "from typing import List\n\n\ndef find_char_long(text: str) -> List[str]:\n\"\"\"\nWrite a function to find all words which are at least 4 characters long in a string.\n\"\"\"", "entry_point": "find_char_long", "canonical_solution": "import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))", "input_output_examples": "[[['Please move back to stream']], [[['Please', 'move', 'back', 'stream']]]]", "starter_code": "from typing import List\ndef find_char_long(text: str) -> List[str]:", "llm_generated_inputs": "[['this is a test'], ['one two three four five'], ['a'], ['abc'], ['abcd'], ['word'], ['verylongword'], ['short longword'], ['multiple words here'], ['single'], [' '], ['']]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]", "from typing import List\n\ndef find_char_long(text: str) -> List[str]:\n    return [word for word in text.split() if len(word) >= 4]"], "outputs": "[[['this', 'test']], [['three', 'four', 'five']], [[]], [[]], [['abcd']], [['word']], [['verylongword']], [['short', 'longword']], [['multiple', 'words', 'here']], [['single']], [[]], [[]]]", "probability": 0.9, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}, {"programs_str": ["", ""], "outputs": "[['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError']]", "probability": 0.1, "is_align_req": false, "test_consistency": 0.0, "failed_input_output_examples": "[[['Please move back to stream'], ['EmptyCodeError'], [['Please', 'move', 'back', 'stream']]]]"}], "entropy": 0.46899559358928117, "llm_generated_inputs": "[['this is a test'], ['one two three four five'], ['a'], ['abc'], ['abcd'], ['word'], ['verylongword'], ['short longword'], ['multiple words here'], ['single'], [' '], ['']]", "input_output_examples": "[[['Please move back to stream']], [[['Please', 'move', 'back', 'stream']]]]", "weighted_test_consistency": 0.9, "at_least_one_align": true, "ambiguity": 0.2844977967946406}}
{"task_id": "Mbpp/8", "requirement": "from typing import List\n\n\ndef square_nums(nums: List[int]) -> List[int]:\n\"\"\"\nWrite a function to find squares of individual elements in a list.\n\"\"\"", "entry_point": "square_nums", "canonical_solution": "def square_nums(nums):\n return [i**2 for i in nums]", "input_output_examples": "[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]], [[[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]]]]", "starter_code": "from typing import List\ndef square_nums(nums: List[int]) -> List[int]:", "llm_generated_inputs": "[[[1, 2, 3, 4]], [[-1, -2, -3, -4]], [[0, 0, 0, 0]], [[5]], [[]], [[10, -10, 0]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [num ** 2 for num in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [num ** 2 for num in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [num ** 2 for num in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [num ** 2 for num in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [num ** 2 for num in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [num ** 2 for num in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [num ** 2 for num in nums]", "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    return [x ** 2 for x in nums]"], "outputs": "[[[1, 4, 9, 16]], [[1, 4, 9, 16]], [[0, 0, 0, 0]], [[25]], [[]], [[100, 100, 0]]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[1, 2, 3, 4]], [[-1, -2, -3, -4]], [[0, 0, 0, 0]], [[5]], [[]], [[10, -10, 0]]]", "input_output_examples": "[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]], [[[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/9", "requirement": "def find_Rotations(s: str) -> int:\n\"\"\"\nWrite a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\"\"\"", "entry_point": "find_Rotations", "canonical_solution": "def find_Rotations(s): \n    n = len(s)\n    s += s\n    for i in range(1, n + 1):\n        if s[i: i + n] == s[0: n]:\n            return i\n    return n", "input_output_examples": "[[['aaaa']], [[1]]]", "starter_code": "def find_Rotations(s: str) -> int:", "llm_generated_inputs": "[['abcde'], ['abacaba'], ['aaaaa'], ['abcdabcd'], ['a'], ['abababab'], ['rotation'], ['zzzzzzzzz']]", "clusters": {"cluster_list": [{"programs_str": ["def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n    return n"], "outputs": "[[5], [7], [1], [4], [1], [2], [8], [1]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[['abcde'], ['abacaba'], ['aaaaa'], ['abcdabcd'], ['a'], ['abababab'], ['rotation'], ['zzzzzzzzz']]", "input_output_examples": "[[['aaaa']], [[1]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/11", "requirement": "def remove_Occ(s: str, ch: str) -> str:\n\"\"\"\nWrite a python function to remove first and last occurrence of a given character from the string.\n\n\n\"\"\"", "entry_point": "remove_Occ", "canonical_solution": "def remove_Occ(s,ch): \n    s = s.replace(ch, '', 1)\n    s = s[::-1].replace(ch, '', 1)[::-1]\n    return s", "input_output_examples": "[[['hello', 'l']], [['heo']]]", "starter_code": "def remove_Occ(s: str, ch: str) -> str:", "llm_generated_inputs": "[['hello', 'l'], ['balloon', 'o'], ['programming', 'm'], ['abcde', 'a'], ['abcde', 'e'], ['abcde', 'f'], ['aaaaa', 'a'], ['', 'a'], ['abcde', ''], ['a', 'a']]", "clusters": {"cluster_list": [{"programs_str": ["def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or ch not in s:\n        return s\n    first_occ = s.index(ch)\n    last_occ = s.rindex(ch)\n    if first_occ == last_occ:\n        return s[:first_occ] + s[first_occ + 1:]\n    return s[:first_occ] + s[first_occ + 1:last_occ] + s[last_occ + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or ch not in s:\n        return s\n    first_occurrence = s.find(ch)\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or ch not in s:\n        return s\n    first_occ = s.find(ch)\n    last_occ = s.rfind(ch)\n    if first_occ == last_occ:\n        return s[:first_occ] + s[first_occ + 1:]\n    return s[:first_occ] + s[first_occ + 1:last_occ] + s[last_occ + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if ch in s:\n        s = s[:s.index(ch)] + s[s.index(ch) + 1:]\n    if ch in s:\n        s = s[:s.rindex(ch)] + s[s.rindex(ch) + 1:]\n    return s", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or ch not in s:\n        return s\n    first_occ = s.find(ch)\n    last_occ = s.rfind(ch)\n    if first_occ == last_occ:\n        return s[:first_occ] + s[first_occ + 1:]\n    return s[:first_occ] + s[first_occ + 1:last_occ] + s[last_occ + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if ch in s:\n        s = s[:s.index(ch)] + s[s.index(ch) + 1:]\n    if ch in s:\n        s = s[:s.rindex(ch)] + s[s.rindex(ch) + 1:]\n    return s", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or ch not in s:\n        return s\n    first_occurrence = s.find(ch)\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or ch not in s:\n        return s\n    first_occ = s.find(ch)\n    last_occ = s.rfind(ch)\n    if first_occ == last_occ:\n        return s[:first_occ] + s[first_occ + 1:]\n    return s[:first_occ] + s[first_occ + 1:last_occ] + s[last_occ + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or ch not in s:\n        return s\n    first_occ = s.find(ch)\n    last_occ = s.rfind(ch)\n    if first_occ == last_occ:\n        return s[:first_occ] + s[first_occ + 1:]\n    return s[:first_occ] + s[first_occ + 1:last_occ] + s[last_occ + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]"], "outputs": "[['heo'], ['balln'], ['prograing'], ['bcde'], ['abcd'], ['abcde'], ['aaa'], [''], ['bcde'], ['']]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[['hello', 'l'], ['balloon', 'o'], ['programming', 'm'], ['abcde', 'a'], ['abcde', 'e'], ['abcde', 'f'], ['aaaaa', 'a'], ['', 'a'], ['abcde', ''], ['a', 'a']]", "input_output_examples": "[[['hello', 'l']], [['heo']]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/12", "requirement": "from typing import List\n\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n\"\"\"\nWrite a function to sort a given matrix in ascending order according to the sum of its rows.\n\"\"\"", "entry_point": "sort_matrix", "canonical_solution": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result", "input_output_examples": "[[[[[1, 2, 3], [2, 4, 5], [1, 1, 1]]]], [[[[1, 1, 1], [1, 2, 3], [2, 4, 5]]]]]", "starter_code": "from typing import List\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:", "llm_generated_inputs": "[[[[3, 2, 1], [1, 2, 3], [4, 5, 6]]], [[[9, 8, 7], [6, 5, 4], [3, 2, 1]]], [[[1, 1, 1], [2, 2, 2], [3, 3, 3]]], [[[0, 0, 0], [0, 0, 0], [0, 0, 0]]], [[[10], [5], [15]]], [[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]], [[[100, 200], [50, 75], [25, 125]]], [[]], [[[]]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)", "from typing import List\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    return sorted(matrix, key=sum)"], "outputs": "[[[[3, 2, 1], [1, 2, 3], [4, 5, 6]]], [[[3, 2, 1], [6, 5, 4], [9, 8, 7]]], [[[1, 1, 1], [2, 2, 2], [3, 3, 3]]], [[[0, 0, 0], [0, 0, 0], [0, 0, 0]]], [[[5], [10], [15]]], [[[-7, -8, -9], [-4, -5, -6], [-1, -2, -3]]], [[[50, 75], [25, 125], [100, 200]]], [[]], [[[]]]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[[3, 2, 1], [1, 2, 3], [4, 5, 6]]], [[[9, 8, 7], [6, 5, 4], [3, 2, 1]]], [[[1, 1, 1], [2, 2, 2], [3, 3, 3]]], [[[0, 0, 0], [0, 0, 0], [0, 0, 0]]], [[[10], [5], [15]]], [[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]], [[[100, 200], [50, 75], [25, 125]]], [[]], [[[]]]]", "input_output_examples": "[[[[[1, 2, 3], [2, 4, 5], [1, 1, 1]]]], [[[[1, 1, 1], [1, 2, 3], [2, 4, 5]]]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/14", "requirement": "def find_Volume(l: float, b: float, h: float) -> float:\n\"\"\"\nWrite a python function to find the volume of a triangular prism.\n\"\"\"", "entry_point": "find_Volume", "canonical_solution": "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2)", "input_output_examples": "[[[10, 8, 6]], [[240]]]", "starter_code": "def find_Volume(l: float, b: float, h: float) -> float:", "llm_generated_inputs": "[[3.0, 4.0, 5.0], [0.0, 4.0, 5.0], [3.0, 0.0, 5.0], [3.0, 4.0, 0.0], [-3.0, 4.0, 5.0], [3.0, -4.0, 5.0], [3.0, 4.0, -5.0], [1.5, 2.5, 3.5], [100.0, 200.0, 300.0]]", "clusters": {"cluster_list": [{"programs_str": ["def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2", "def find_Volume(l: float, b: float, h: float) -> float:\n    import math\n    return l * b * h / 2"], "outputs": "[[30.0], [0.0], [0.0], [0.0], [-30.0], [-30.0], [-30.0], [6.5625], [3000000.0]]", "probability": 0.95, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}, {"programs_str": ["def find_Volume(l: float, b: float, h: float) -> float:\n    from math import sqrt\n    base_area = b * sqrt(3) / 4 * l\n    return base_area * h"], "outputs": "[[25.98076211353316], [0.0], [0.0], [0.0], [-25.98076211353316], [-25.98076211353316], [-25.98076211353316], [5.683291712335378], [2598076.211353316]]", "probability": 0.05, "is_align_req": false, "test_consistency": 0.0, "failed_input_output_examples": "[[[10, 8, 6], [207.84609690826525], [240]]]"}], "entropy": 0.2863969571159562, "llm_generated_inputs": "[[3.0, 4.0, 5.0], [0.0, 4.0, 5.0], [3.0, 0.0, 5.0], [3.0, 4.0, 0.0], [-3.0, 4.0, 5.0], [3.0, -4.0, 5.0], [3.0, 4.0, -5.0], [1.5, 2.5, 3.5], [100.0, 200.0, 300.0]]", "input_output_examples": "[[[10, 8, 6]], [[240]]]", "weighted_test_consistency": 0.95, "at_least_one_align": true, "ambiguity": 0.16819847855797812}}
{"task_id": "Mbpp/16", "requirement": "def text_lowercase_underscore(text: str) -> bool:\n\"\"\"\nWrite a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n\"\"\"", "entry_point": "text_lowercase_underscore", "canonical_solution": "import re\ndef text_lowercase_underscore(text):\n        return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "input_output_examples": "[[['aab_cbbbc']], [[True]]]", "starter_code": "def text_lowercase_underscore(text: str) -> bool:", "llm_generated_inputs": "[['hello_world'], ['HELLO_WORLD'], ['hello_World'], ['hello_world_123'], ['hello__world'], ['hello_world_'], ['_hello_world'], ['helloworld'], ['hello_world!'], [''], ['_'], ['a_b_c_d_e'], ['single']]", "clusters": {"cluster_list": [{"programs_str": ["import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.fullmatch('[a-z]+(_[a-z]+)*', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.fullmatch('[a-z]+(_[a-z]+)*', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.fullmatch('[a-z]+(_[a-z]+)*', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.fullmatch('[a-z]+(_[a-z]+)*', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.fullmatch('[a-z]+(_[a-z]+)*', text))"], "outputs": "[[True], [False], [False], [False], [False], [False], [False], [True], [False], [False], [False], [True], [True]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[['hello_world'], ['HELLO_WORLD'], ['hello_World'], ['hello_world_123'], ['hello__world'], ['hello_world_'], ['_hello_world'], ['helloworld'], ['hello_world!'], [''], ['_'], ['a_b_c_d_e'], ['single']]", "input_output_examples": "[[['aab_cbbbc']], [[True]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/17", "requirement": "def square_perimeter(a: int) -> int:\n\"\"\"\nWrite a function that returns the perimeter of a square given its side length as input.\n\"\"\"", "entry_point": "square_perimeter", "canonical_solution": "def square_perimeter(a):\n  return 4*a", "input_output_examples": "[[[10]], [[40]]]", "starter_code": "def square_perimeter(a: int) -> int:", "llm_generated_inputs": "[[1], [0], [-1], [10], [100]]", "clusters": {"cluster_list": [{"programs_str": ["def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a", "def square_perimeter(a: int) -> int:\n    return 4 * a"], "outputs": "[[4], [0], [-4], [40], [400]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[1], [0], [-1], [10], [100]]", "input_output_examples": "[[[10]], [[40]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/18", "requirement": "def remove_dirty_chars(string: str, second_string: str) -> str:\n\"\"\"\nWrite a function to remove characters from the first string which are present in the second string.\n\n\n\"\"\"", "entry_point": "remove_dirty_chars", "canonical_solution": "def remove_dirty_chars(string, second_string): \n\tfor char in second_string:\n\t\tstring = string.replace(char, '')\n\treturn string", "input_output_examples": "[[['probasscurve', 'pros']], [['bacuve']]]", "starter_code": "def remove_dirty_chars(string: str, second_string: str) -> str:", "llm_generated_inputs": "[['hello', 'eo'], ['world', 'rld'], ['python', ''], ['', 'abc'], ['abcdef', 'xyz'], ['aabbcc', 'abc'], ['12345', '54321'], ['!@#$%', '%$#@!'], ['same', 'same'], ['different', 'overlap']]", "clusters": {"cluster_list": [{"programs_str": ["def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))", "def remove_dirty_chars(string: str, second_string: str) -> str:\n    return ''.join((char for char in string if char not in second_string))"], "outputs": "[['hll'], ['wo'], ['python'], [''], ['abcdef'], [''], [''], [''], [''], ['diffnt']]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[['hello', 'eo'], ['world', 'rld'], ['python', ''], ['', 'abc'], ['abcdef', 'xyz'], ['aabbcc', 'abc'], ['12345', '54321'], ['!@#$%', '%$#@!'], ['same', 'same'], ['different', 'overlap']]", "input_output_examples": "[[['probasscurve', 'pros']], [['bacuve']]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/19", "requirement": "from typing import List\n\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n\"\"\"\nWrite a function to find whether a given array of integers contains any duplicate element.\n\"\"\"", "entry_point": "test_duplicate", "canonical_solution": "def test_duplicate(arraynums):\n    return len(arraynums) != len(set(arraynums))", "input_output_examples": "[[[[1, 2, 3, 4, 5]]], [[False]]]", "starter_code": "from typing import List\ndef test_duplicate(arraynums: List[int]) -> bool:", "llm_generated_inputs": "[[[1, 2, 3, 4, 5]], [[1, 2, 2, 3, 4]], [[]], [[10]], [[1, 1, 1, 1, 1]], [[1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10]], [[100, 200, 300, 400, 500, 100]], [[-1, -2, -3, -1]], [[0, 0, 0, 0]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    return len(arraynums) != len(set(arraynums))", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    return len(arraynums) != len(set(arraynums))", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    return len(arraynums) != len(set(arraynums))", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    return len(arraynums) != len(set(arraynums))", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    return len(arraynums) != len(set(arraynums))", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False"], "outputs": "[[False], [True], [False], [False], [True], [True], [True], [True], [True]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[1, 2, 3, 4, 5]], [[1, 2, 2, 3, 4]], [[]], [[10]], [[1, 1, 1, 1, 1]], [[1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10]], [[100, 200, 300, 400, 500, 100]], [[-1, -2, -3, -1]], [[0, 0, 0, 0]]]", "input_output_examples": "[[[[1, 2, 3, 4, 5]]], [[False]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/20", "requirement": "def is_woodall(num: int) -> bool:\n\"\"\"\nWrite a function to check if the given number is woodall or not.\n\"\"\"", "entry_point": "is_woodall", "canonical_solution": "def is_woodall(x): \n\tif not isinstance(x, int):\n\t\treturn False\n\tif x <= 0 or x % 2 == 0:\n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx += 1 \n\ti = 0\n\twhile (x % 2 == 0): \n\t\tx /= 2\n\t\ti += 1\n\t\tif (i == x): \n\t\t\treturn True\n\treturn False", "input_output_examples": "[[[383]], [[True]]]", "starter_code": "def is_woodall(num: int) -> bool:", "llm_generated_inputs": "[[0], [1], [2], [7], [23], [47], [95], [191], [383], [767], [1535], [-1], [-5], [100], [1023]]", "clusters": {"cluster_list": [{"programs_str": ["def is_woodall(num: int) -> bool:\n    n = 1\n    while n * (2 ** n - 1) <= num:\n        if n * (2 ** n - 1) == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * (2 ** n - 1) <= num:\n        if n * (2 ** n - 1) == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * (2 ** n - 1) <= num:\n        if n * (2 ** n - 1) == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 1\n    while n * (2 ** n - 1) <= num:\n        if n * (2 ** n - 1) == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 1\n    while n * (2 ** n - 1) <= num:\n        if n * (2 ** n - 1) == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 1\n    while n * (2 ** n - 1) <= num:\n        if n * (2 ** n - 1) == num:\n            return True\n        n += 1\n    return False"], "outputs": "[[False], [True], [False], [False], [False], [False], [False], [False], [False], [False], [False], [False], [False], [False], [False]]", "probability": 0.3, "is_align_req": false, "test_consistency": 0.0, "failed_input_output_examples": "[[[383], [False], [True]]]"}, {"programs_str": ["def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False", "def is_woodall(num: int) -> bool:\n    n = 1\n    while n * 2 ** n - 1 <= num:\n        if n * 2 ** n - 1 == num:\n            return True\n        n += 1\n    return False"], "outputs": "[[False], [True], [False], [True], [True], [False], [False], [False], [True], [False], [False], [False], [False], [False], [False]]", "probability": 0.7, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0.8812908992306927, "llm_generated_inputs": "[[0], [1], [2], [7], [23], [47], [95], [191], [383], [767], [1535], [-1], [-5], [100], [1023]]", "input_output_examples": "[[[383]], [[True]]]", "weighted_test_consistency": 0.7, "at_least_one_align": true, "ambiguity": 0.5906454496153464}}
{"task_id": "Mbpp/56", "requirement": "def check(n: int) -> bool:\n\"\"\"\nWrite a python function to check if a given number is one less than twice its reverse.\n\"\"\"", "entry_point": "check", "canonical_solution": "def check(n):    \n    return n == 2 * int(str(n)[::-1]) - 1", "input_output_examples": "[[[70]], [[False]]]", "starter_code": "def check(n: int) -> bool:", "llm_generated_inputs": "[[9], [21], [0], [-1], [10], [100], [123], [241], [999]]", "clusters": {"cluster_list": [{"programs_str": ["def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1", "def check(n: int) -> bool:\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1"], "outputs": "[[False], [False], [False], ['ValueError'], [False], [False], [False], [False], [False]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[9], [21], [0], [-1], [10], [100], [123], [241], [999]]", "input_output_examples": "[[[70]], [[False]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/57", "requirement": "from typing import List\n\n\ndef find_Max_Num(arr: List[int]) -> int:\n\"\"\"\nWrite a python function to find the largest number that can be formed with the given list of digits.\n\"\"\"", "entry_point": "find_Max_Num", "canonical_solution": "def find_Max_Num(arr) : \n    arr.sort(reverse = True)\n    return int(\"\".join(map(str,arr)))", "input_output_examples": "[[[[1, 2, 3]]], [[321]]]", "starter_code": "from typing import List\ndef find_Max_Num(arr: List[int]) -> int:", "llm_generated_inputs": "[[[3, 30, 34, 5, 9]], [[10, 2]], [[1, 20, 3, 30]], [[0, 0, 0, 0]], [[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]], [[1]], [[9, 99, 999, 9999]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num", "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num"], "outputs": "[[3430953], [102], [302031], [0], [9876543210], [1], [9999999999]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[34, 30, 9, 5, 3]], [[10, 2]], [[30, 20, 3, 1]], [[0, 0, 0, 0]], [[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]], [[1]], [[9999, 999, 99, 9]]]", "input_output_examples": "[[[[3, 2, 1]]], [[321]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/58", "requirement": "def opposite_Signs(x: int, y: int) -> bool:\n\"\"\"\nWrite a python function to check whether the given two integers have opposite sign or not.\n\"\"\"", "entry_point": "opposite_Signs", "canonical_solution": "def opposite_Signs(x,y): \n    return ((x ^ y) < 0)", "input_output_examples": "[[[1, -2]], [[True]]]", "starter_code": "def opposite_Signs(x: int, y: int) -> bool:", "llm_generated_inputs": "[[10, -5], [-7, 3], [0, 5], [0, -1], [1, 1], [-1, -1], [1000000, -1000000], [-1000000, 1000000]]", "clusters": {"cluster_list": [{"programs_str": ["def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & amp\n    2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & amp\n    2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & amp\n    2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & amp\n    2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & amp\n    2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & amp\n    2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & amp\n    2147483648 != 0"], "outputs": "[['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError']]", "probability": 0.35, "is_align_req": false, "test_consistency": 0.0, "failed_input_output_examples": "[[[1, -2], ['NameError'], [True]]]"}, {"programs_str": ["def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) & 2147483648 != 0"], "outputs": "[[True], [True], [False], [True], [False], [False], [True], [True]]", "probability": 0.65, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0.9340680553754911, "llm_generated_inputs": "[[10, -5], [-7, 3], [0, 5], [0, -1], [1, 1], [-1, -1], [1000000, -1000000], [-1000000, 1000000]]", "input_output_examples": "[[[1, -2]], [[True]]]", "weighted_test_consistency": 0.65, "at_least_one_align": true, "ambiguity": 0.6420340276877455}}
{"task_id": "Mbpp/59", "requirement": "def is_octagonal(n: int) -> int:\n\"\"\"\nWrite a function to find the nth octagonal number.\n\"\"\"", "entry_point": "is_octagonal", "canonical_solution": "def is_octagonal(n): \n\treturn 3 * n * n - 2 * n", "input_output_examples": "[[[5]], [[65]]]", "starter_code": "def is_octagonal(n: int) -> int:", "llm_generated_inputs": "[[1], [2], [3], [4], [5], [10], [0], [-1], [-5]]", "clusters": {"cluster_list": [{"programs_str": ["def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)", "def is_octagonal(n: int) -> int:\n    return n * (3 * n - 2)"], "outputs": "[[1], [8], [21], [40], [65], [280], [0], [5], [85]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[1], [2], [3], [4], [5], [10], [0], [-1], [-5]]", "input_output_examples": "[[[5]], [[65]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/61", "requirement": "def count_Substrings(s: str) -> int:\n\"\"\"\nWrite a python function to count the number of substrings with the sum of digits equal to their length.\n\"\"\"", "entry_point": "count_Substrings", "canonical_solution": "from collections import defaultdict\ndef count_Substrings(s):\n    n, count, sum = len(s), 0, 0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - i - 1]\n        mp[sum - i - 1] += 1\n    return count", "input_output_examples": "[[['112112']], [[6]]]", "starter_code": "def count_Substrings(s: str) -> int:", "llm_generated_inputs": "[['123'], ['000'], ['111'], ['101010'], ['121212'], ['987654321'], ['55555'], ['1'], [''], ['0'], ['10'], ['11']]", "clusters": {"cluster_list": [{"programs_str": ["def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count"], "outputs": "[[1], [0], [6], [3], [3], [1], [0], [1], [0], [0], [1], [3]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[['123'], ['000'], ['111'], ['101010'], ['121212'], ['987654321'], ['55555'], ['1'], [''], ['0'], ['10'], ['11']]", "input_output_examples": "[[['112112']], [[6]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/62", "requirement": "from typing import List\n\n\ndef smallest_num(xs: List[int]) -> int:\n\"\"\"\nWrite a python function to find smallest number in a list.\n\"\"\"", "entry_point": "smallest_num", "canonical_solution": "def smallest_num(xs):\n  assert len(xs) > 0, \"invalid inputs\"\n  return min(xs)", "input_output_examples": "[[[[10, 20, 1, 45, 99]]], [[1]]]", "starter_code": "from typing import List\ndef smallest_num(xs: List[int]) -> int:", "llm_generated_inputs": "[[[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]], [[10, 20, 30, 40, 50]], [[-1, -2, -3, -4, -5]], [[100]], [[0, 0, 0, 0]], [[1]], [[]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    if not xs:\n        raise ValueError('The list is empty')\n    smallest = xs[0]\n    for num in xs:\n        if num < smallest:\n            smallest = num\n    return smallest", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)", "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    return min(xs)"], "outputs": "[[1], [10], [-5], [100], [0], [1], ['ValueError']]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]], [[10, 20, 30, 40, 50]], [[-1, -2, -3, -4, -5]], [[100]], [[0, 0, 0, 0]], [[1]], [[]]]", "input_output_examples": "[[[[10, 20, 1, 45, 99]]], [[1]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/63", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n\"\"\"\nWrite a function to find the maximum difference between available pairs in the given tuple list.\n\"\"\"", "entry_point": "max_difference", "canonical_solution": "def max_difference(test_list):\n  return max(abs(a - b) for a, b in test_list)", "input_output_examples": "[[[[(3, 5), (1, 7), (10, 3), (1, 2)]]], [[7]]]", "starter_code": "from typing import List\nfrom typing import Tuple\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:", "llm_generated_inputs": "[[[(1, 5), (3, 8), (10, 15)]], [[(2, 2), (4, 4), (6, 6)]], [[(-1, -5), (-3, -8), (-10, -15)]], [[(100, 200), (50, 150), (75, 225)]], [[(0, 0)]], [[]], [[(1, 1000000), (1000000, 1)]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))"], "outputs": "[[5], [0], [5], [150], [0], ['ValueError'], [999999]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[(1, 5), (3, 8), (10, 15)]], [[(2, 2), (4, 4), (6, 6)]], [[(-1, -5), (-3, -8), (-10, -15)]], [[(100, 200), (50, 150), (75, 225)]], [[(0, 0)]], [[]], [[(1, 1000000), (1000000, 1)]]]", "input_output_examples": "[[[[(3, 5), (1, 7), (10, 3), (1, 2)]]], [[7]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/64", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n\"\"\"\nWrite a function to sort a list of tuples using the second value of each tuple.\n\"\"\"", "entry_point": "subject_marks", "canonical_solution": "def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks", "input_output_examples": "[[[[('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]]], [[[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]]]]", "starter_code": "from typing import List\nfrom typing import Tuple\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:", "llm_generated_inputs": "[[[('Math', 88), ('Science', 95), ('English', 70)]], [[('History', 60), ('Geography', 60), ('Biology', 60)]], [[('Physics', 92)]], [[]], [[('Chemistry', 100), ('Arts', 0)]], [[('Economics', 85), ('Literature', 78), ('Philosophy', 90), ('Sociology', 85)]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])", "from typing import List\nfrom typing import Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    return sorted(subjectmarks, key=lambda x: x[1])"], "outputs": "[[[('English', 70), ('Math', 88), ('Science', 95)]], [[('History', 60), ('Geography', 60), ('Biology', 60)]], [[('Physics', 92)]], [[]], [[('Arts', 0), ('Chemistry', 100)]], [[('Literature', 78), ('Economics', 85), ('Sociology', 85), ('Philosophy', 90)]]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[('Math', 88), ('Science', 95), ('English', 70)]], [[('History', 60), ('Geography', 60), ('Biology', 60)]], [[('Physics', 92)]], [[]], [[('Chemistry', 100), ('Arts', 0)]], [[('Economics', 85), ('Literature', 78), ('Philosophy', 90), ('Sociology', 85)]]]", "input_output_examples": "[[[[('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]]], [[[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/65", "requirement": "from typing import List\nfrom typing import Union\n\n\ndef recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n\"\"\"\nWrite a function to flatten a list and sum all of its elements.\n\"\"\"", "entry_point": "recursive_list_sum", "canonical_solution": "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total", "input_output_examples": "[[[[1, 2, [3, 4], [5, 6]]]], [[21]]]", "starter_code": "from typing import List\nfrom typing import Union\ndef recursive_list_sum(data_list: List[Union[int, List]]) -> int:", "llm_generated_inputs": "[[[1, 2, [3, 4], [5, 6]]], [[1, [2, [3, [4, [5]]]]]], [[1, 2, 3, 4, 5]], [[]], [[[], [], []]], [[0, 0, [0, [0, 0]]]], [[1, [-1, 2, [-2, 3, [-3]]]]], [[100, [200, [300]], [400, 500]]]]", "clusters": {"cluster_list": [{"programs_str": ["def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "def recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total"], "outputs": "[['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError']]", "probability": 0.85, "is_align_req": false, "test_consistency": 0.0, "failed_input_output_examples": "[[[[1, 2, [3, 4], [5, 6]]], ['NameError'], [21]]]"}, {"programs_str": ["from typing import List\nfrom typing import Union\n\ndef recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "from typing import List\nfrom typing import Union\n\ndef recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "from typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total"], "outputs": "[[21], [15], [15], [0], [0], [0], [0], [1500]]", "probability": 0.15, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0.6098403047164005, "llm_generated_inputs": "[[[1, 2, [3, 4], [5, 6]]], [[1, [2, [3, [4, [5]]]]]], [[1, 2, 3, 4, 5]], [[]], [[[], [], []]], [[0, 0, [0, [0, 0]]]], [[1, [-1, 2, [-2, 3, [-3]]]]], [[100, [200, [300]], [400, 500]]]]", "input_output_examples": "[[[[1, 2, [3, 4], [5, 6]]]], [[21]]]", "weighted_test_consistency": 0.15, "at_least_one_align": true, "ambiguity": 0.7299201523582002}}
{"task_id": "Mbpp/66", "requirement": "from typing import List\n\n\ndef pos_count(l: List[int]) -> int:\n\"\"\"\nWrite a python function to count the number of positive numbers in a list.\n\"\"\"", "entry_point": "pos_count", "canonical_solution": "def pos_count(l):\n  return len([x for x in l if x > 0])", "input_output_examples": "[[[[1, -2, 3, -4]]], [[2]]]", "starter_code": "from typing import List\ndef pos_count(l: List[int]) -> int:", "llm_generated_inputs": "[[[1, -2, 3, 4, -5]], [[-1, -2, -3, -4, -5]], [[1, 2, 3, 4, 5]], [[]], [[0, 0, 0, 0]], [[1]], [[-1]], [[0]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for num in l if num > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for num in l if num > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for num in l if num > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))", "from typing import List\n\ndef pos_count(l: List[int]) -> int:\n    return sum((1 for x in l if x > 0))"], "outputs": "[[3], [0], [5], [0], [0], [1], [0], [0]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[1, -2, 3, 4, -5]], [[-1, -2, -3, -4, -5]], [[1, 2, 3, 4, 5]], [[]], [[0, 0, 0, 0]], [[1]], [[-1]], [[0]]]", "input_output_examples": "[[[[1, -2, 3, -4]]], [[2]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/67", "requirement": "def bell_number(n: int) -> int:\n\"\"\"\nWrite a function to find the number of ways to partition a set of Bell numbers.\n\"\"\"", "entry_point": "bell_number", "canonical_solution": "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0]", "input_output_examples": "[[[2]], [[2]]]", "starter_code": "def bell_number(n: int) -> int:", "llm_generated_inputs": "[[0], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [-1], [15], [20]]", "clusters": {"cluster_list": [{"programs_str": ["def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]"], "outputs": "[[1], [1], [2], [5], [15], [52], [203], [877], [4140], [21147], [115975], ['IndexError'], [1382958545], [51724158235372]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[0], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [-1], [15], [20]]", "input_output_examples": "[[[2]], [[2]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/68", "requirement": "from typing import List\n\n\ndef is_Monotonic(arr: List[int]) -> bool:\n\"\"\"\nWrite a python function to check whether the given array is monotonic or not.\n\"\"\"", "entry_point": "is_Monotonic", "canonical_solution": "def is_Monotonic(A): \n    return all(a <= b for a, b in zip(A, A[1:])) or all(a >= b for a, b in zip(A, A[1:]))", "input_output_examples": "[[[[6, 5, 4, 4]]], [[True]]]", "starter_code": "from typing import List\ndef is_Monotonic(arr: List[int]) -> bool:", "llm_generated_inputs": "[[[1, 2, 2, 3]], [[6, 5, 4, 4]], [[1, 3, 2]], [[1]], [[]], [[5, 5, 5, 5]], [[10, 9, 8, 8, 7, 6]], [[1, 2, 3, 4, 5, 6, 7]], [[7, 7, 7, 7, 7, 7, 7]], [[1, 2, 3, 2, 1]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing", "from typing import List\n\ndef is_Monotonic(arr: List[int]) -> bool:\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing"], "outputs": "[[True], [True], [False], [True], [True], [True], [True], [True], [True], [False]]", "probability": 0.95, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}, {"programs_str": [""], "outputs": "[['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError'], ['EmptyCodeError']]", "probability": 0.05, "is_align_req": false, "test_consistency": 0.0, "failed_input_output_examples": "[[[[6, 5, 4, 4]], ['EmptyCodeError'], [True]]]"}], "entropy": 0.2863969571159562, "llm_generated_inputs": "[[[1, 2, 2, 3]], [[6, 5, 4, 4]], [[1, 3, 2]], [[1]], [[]], [[5, 5, 5, 5]], [[10, 9, 8, 8, 7, 6]], [[1, 2, 3, 4, 5, 6, 7]], [[7, 7, 7, 7, 7, 7, 7]], [[1, 2, 3, 2, 1]]]", "input_output_examples": "[[[[6, 5, 4, 4]]], [[True]]]", "weighted_test_consistency": 0.95, "at_least_one_align": true, "ambiguity": 0.16819847855797812}}
{"task_id": "Mbpp/69", "requirement": "from typing import List\n\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n\"\"\"\nWrite a function to check whether a list contains the given sublist or not.\n\"\"\"", "entry_point": "is_sublist", "canonical_solution": "def is_sublist(l, s):\n\tif len(l) < len(s):\n\t\treturn False\n\treturn any(l[i:i+len(s)] == s for i in range(len(l)-len(s)+1))", "input_output_examples": "[[[[2, 4, 3, 5, 7], [3, 7]]], [[False]]]", "starter_code": "from typing import List\ndef is_sublist(l: List[int], s: List[int]) -> bool:", "llm_generated_inputs": "[[[1, 2, 3, 4, 5], [2, 3]], [[1, 2, 3, 4, 5], [3, 4, 5]], [[1, 2, 3, 4, 5], [5]], [[1, 2, 3, 4, 5], [6]], [[1, 2, 3, 4, 5], []], [[], []], [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]], [[1, 2, 2, 3, 4], [2, 2]], [[1, 2, 3, 4, 5], [2, 4]], [[1, 2, 3, 4, 5], [5, 4]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False", "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n    return False"], "outputs": "[[True], [True], [True], [False], [True], [True], [True], [True], [False], [False]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[1, 2, 3, 4, 5], [2, 3]], [[1, 2, 3, 4, 5], [3, 4, 5]], [[1, 2, 3, 4, 5], [5]], [[1, 2, 3, 4, 5], [6]], [[1, 2, 3, 4, 5], []], [[], []], [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]], [[1, 2, 2, 3, 4], [2, 2]], [[1, 2, 3, 4, 5], [2, 4]], [[1, 2, 3, 4, 5], [5, 4]]]", "input_output_examples": "[[[[2, 4, 3, 5, 7], [3, 7]]], [[False]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/70", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef get_equal(Input: List[Tuple]) -> bool:\n\"\"\"\nWrite a function to find whether all the given tuples have equal length or not.\n\"\"\"", "entry_point": "get_equal", "canonical_solution": "def get_equal(Input):\n  return len(set(len(item) for item in Input)) == 1", "input_output_examples": "[[[[(11, 22, 33), (44, 55, 66)]]], [[True]]]", "starter_code": "from typing import List\nfrom typing import Tuple\ndef get_equal(Input: List[Tuple]) -> bool:", "llm_generated_inputs": "[[[(1, 2), (3, 4)]], [[(1, 2, 3), (4, 5, 6)]], [[(1,), (2,), (3,)]], [[(1, 2), (3, 4, 5)]], [[]], [[(1, 2, 3), (4, 5), (6, 7, 8)]], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)]], [[(1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12)]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for item in Input:\n        if len(item) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for item in Input:\n        if len(item) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for item in Input:\n        if len(item) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for item in Input:\n        if len(item) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for t in Input:\n        if len(t) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for item in Input:\n        if len(item) != first_length:\n            return False\n    return True", "from typing import List, Tuple\n\ndef get_equal(Input: List[Tuple]) -> bool:\n    if not Input:\n        return True\n    first_length = len(Input[0])\n    for item in Input:\n        if len(item) != first_length:\n            return False\n    return True"], "outputs": "[[True], [True], [True], [False], [True], [False], [True], [True]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[(1, 2), (3, 4)]], [[(1, 2, 3), (4, 5, 6)]], [[(1,), (2,), (3,)]], [[(1, 2), (3, 4, 5)]], [[]], [[(1, 2, 3), (4, 5), (6, 7, 8)]], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)]], [[(1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12)]]]", "input_output_examples": "[[[[(11, 22, 33), (44, 55, 66)]]], [[True]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/71", "requirement": "from typing import List\n\n\ndef comb_sort(nums: List[int]) -> List[int]:\n\"\"\"\nWrite a function to sort a list of elements.\n\"\"\"", "entry_point": "comb_sort", "canonical_solution": "def comb_sort(nums):\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums", "input_output_examples": "[[[[5, 15, 37, 25, 79]]], [[[5, 15, 25, 37, 79]]]]", "starter_code": "from typing import List\ndef comb_sort(nums: List[int]) -> List[int]:", "llm_generated_inputs": "[[[5, 3, 4, 2, 1]], [[1, 2, 3, 4, 5]], [[5, 4, 3, 2, 1]], [[10, -1, 2, 5, 0]], [[]], [[42]], [[1, 1, 1, 1, 1]], [[100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]], [[1000, 900, 800, 700, 600, 500, 400, 300, 200, 100]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n\n    def get_next_gap(gap: int) -> int:\n        gap = gap * 10 // 13\n        return max(1, gap)\n    n = len(nums)\n    gap = n\n    swapped = True\n    while gap != 1 or swapped:\n        gap = get_next_gap(gap)\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                swapped = True\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n            i += 1\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n            i += 1\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n            i += 1\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n            i += 1\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n            i += 1\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n            i += 1\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n            i += 1\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n            i += 1\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink_factor = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums"], "outputs": "[[[1, 2, 3, 4, 5]], [[1, 2, 3, 4, 5]], [[1, 2, 3, 4, 5]], [[-1, 0, 2, 5, 10]], [[]], [[42]], [[1, 1, 1, 1, 1]], [[100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]], [[100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[1, 2, 3, 4, 5]], [[1, 2, 3, 4, 5]], [[1, 2, 3, 4, 5]], [[-1, 0, 2, 5, 10]], [[]], [[42]], [[1, 1, 1, 1, 1]], [[100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]], [[100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]]]", "input_output_examples": "[[[[5, 15, 25, 37, 79]]], [[[5, 15, 25, 37, 79]]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/72", "requirement": "def dif_Square(n: int) -> bool:\n\"\"\"\nWrite a python function to check whether the given number can be represented as the difference of two squares or not.\n\"\"\"", "entry_point": "dif_Square", "canonical_solution": "def dif_Square(n): \n    # see https://www.quora.com/Which-numbers-can-be-expressed-as-the-difference-of-two-squares\n    return n % 4 != 2", "input_output_examples": "[[[5]], [[True]]]", "starter_code": "def dif_Square(n: int) -> bool:", "llm_generated_inputs": "[[0], [1], [2], [3], [4], [5], [9], [16], [25], [27], [100], [-1], [-4], [-9], [-16]]", "clusters": {"cluster_list": [{"programs_str": ["def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1"], "outputs": "[[True], [True], [True], [False], [True], [True], [True], [True], [True], [False], [True], [False], [True], [False], [True]]", "probability": 0.75, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}, {"programs_str": ["def dif_Square(n: int) -> bool:\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    return n % 4 != 2"], "outputs": "[[True], [True], [False], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True]]", "probability": 0.25, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0.8112781244591328, "llm_generated_inputs": "[[0], [1], [2], [3], [4], [5], [9], [16], [25], [27], [100], [-1], [-4], [-9], [-16]]", "input_output_examples": "[[[5]], [[True]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.4056390622295664}}
{"task_id": "Mbpp/74", "requirement": "from typing import List\n\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n\"\"\"\nWrite a function to check whether it follows the sequence given in the patterns array.\n\"\"\"", "entry_point": "is_samepatterns", "canonical_solution": "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    pattern_color_dict = {pattern: set() for pattern in patterns}\n    for color, pattern in zip(colors, patterns):\n        pattern_color_dict[pattern].add(color)\n    return all(len(pattern_color_dict[pattern]) == 1 for pattern in patterns)", "input_output_examples": "[[[['red', 'green', 'green'], ['a', 'b', 'b']]], [[True]]]", "starter_code": "from typing import List\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:", "llm_generated_inputs": "[[['red', 'blue', 'red'], ['a', 'b', 'a']], [['red', 'blue', 'green'], ['a', 'b', 'c']], [['red', 'red', 'red'], ['a', 'a', 'a']], [[], []], [['red'], ['a']], [['red', 'blue'], ['a', 'a']], [['red', 'blue', 'red'], ['a', 'b', 'c']], [['red', 'blue', 'blue', 'red'], ['a', 'b', 'b', 'a']], [['red', 'blue', 'green', 'blue'], ['a', 'b', 'c', 'b']]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True", "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color not in color_to_pattern:\n            color_to_pattern[color] = pattern\n        if pattern not in pattern_to_color:\n            pattern_to_color[pattern] = color\n        if color_to_pattern[color] != pattern or pattern_to_color[pattern] != color:\n            return False\n    return True"], "outputs": "[[True], [True], [True], [True], [True], [False], [False], [True], [True]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[['red', 'blue', 'red'], ['a', 'b', 'a']], [['red', 'blue', 'green'], ['a', 'b', 'c']], [['red', 'red', 'red'], ['a', 'a', 'a']], [[], []], [['red'], ['a']], [['red', 'blue'], ['a', 'a']], [['red', 'blue', 'red'], ['a', 'b', 'c']], [['red', 'blue', 'blue', 'red'], ['a', 'b', 'b', 'a']], [['red', 'blue', 'green', 'blue'], ['a', 'b', 'c', 'b']]]", "input_output_examples": "[[[['red', 'green', 'green'], ['a', 'b', 'b']]], [[True]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/75", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n\"\"\"\nWrite a function to find tuples which have all elements divisible by k from the given list of tuples.\n\"\"\"", "entry_point": "find_tuples", "canonical_solution": "def find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res", "input_output_examples": "[[[[(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6]], [[[(6, 24, 12)]]]]", "starter_code": "from typing import List\nfrom typing import Tuple\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:", "llm_generated_inputs": "[[[(10, 20, 30), (45, 90, 135), (12, 24, 36)], 10], [[(15, 25, 35), (40, 80, 120), (21, 42, 63)], 5], [[(7, 14, 21), (28, 56, 84), (35, 70, 105)], 7], [[(8, 16, 24), (32, 64, 96), (40, 80, 120)], 8], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)], 1], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)], 2], [[], 3], [[(9, 18, 27), (36, 72, 108), (45, 90, 135)], 0], [[(100, 200, 300), (400, 800, 1200), (500, 1000, 1500)], 100]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "from typing import List\nfrom typing import Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [t for t in test_list if all((x % K == 0 for x in t))]", "from typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [t for t in test_list if all((x % K == 0 for x in t))]", "from typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "from typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "from typing import List\nfrom typing import Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "from typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "from typing import List\nfrom typing import Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "from typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [t for t in test_list if all((x % K == 0 for x in t))]", "from typing import List\nfrom typing import Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [t for t in test_list if all((x % K == 0 for x in t))]", "from typing import List\nfrom typing import Tuple\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]"], "outputs": "[[[(10, 20, 30)]], [[(15, 25, 35), (40, 80, 120)]], [[(7, 14, 21), (28, 56, 84), (35, 70, 105)]], [[(8, 16, 24), (32, 64, 96), (40, 80, 120)]], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)]], [[]], [[]], ['ZeroDivisionError'], [[(100, 200, 300), (400, 800, 1200), (500, 1000, 1500)]]]", "probability": 0.55, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}, {"programs_str": ["def find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "def find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "def find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [t for t in test_list if all((x % K == 0 for x in t))]", "def find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "def find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "def find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "def find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "def find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]", "def find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    return [tup for tup in test_list if all((element % K == 0 for element in tup))]"], "outputs": "[['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError']]", "probability": 0.45, "is_align_req": false, "test_consistency": 0.0, "failed_input_output_examples": "[[[[(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6], ['NameError'], [[(6, 24, 12)]]]]"}], "entropy": 0.9927744539878083, "llm_generated_inputs": "[[[(10, 20, 30), (45, 90, 135), (12, 24, 36)], 10], [[(15, 25, 35), (40, 80, 120), (21, 42, 63)], 5], [[(7, 14, 21), (28, 56, 84), (35, 70, 105)], 7], [[(8, 16, 24), (32, 64, 96), (40, 80, 120)], 8], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)], 1], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)], 2], [[], 3], [[(9, 18, 27), (36, 72, 108), (45, 90, 135)], 0], [[(100, 200, 300), (400, 800, 1200), (500, 1000, 1500)], 100]]", "input_output_examples": "[[[[(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6]], [[[(6, 24, 12)]]]]", "weighted_test_consistency": 0.55, "at_least_one_align": true, "ambiguity": 0.7213872269939041}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n\"\"\"\nWrite a python function to find whether a number is divisible by 11.\n\"\"\"", "entry_point": "is_Diff", "canonical_solution": "def is_Diff(n): \n    return n % 11 == 0", "input_output_examples": "[[[12345]], [[False]]]", "starter_code": "def is_Diff(n: int) -> bool:", "llm_generated_inputs": "[[0], [11], [22], [-11], [-22], [10], [21], [121], [132], [9], [1001], [1000], [110], [220], [330], [440], [550], [660], [770], [880], [990]]", "clusters": {"cluster_list": [{"programs_str": ["def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0"], "outputs": "[[True], [True], [True], [True], [True], [False], [False], [True], [True], [False], [True], [False], [True], [True], [True], [True], [True], [True], [True], [True], [True]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[0], [11], [22], [-11], [-22], [10], [21], [121], [132], [9], [1001], [1000], [110], [220], [330], [440], [550], [660], [770], [880], [990]]", "input_output_examples": "[[[12345]], [[False]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/79", "requirement": "def word_len(s: str) -> bool:\n\"\"\"\nWrite a python function to check whether the length of the word is odd or not.\n\"\"\"", "entry_point": "word_len", "canonical_solution": "def word_len(s): \n    return len(s) % 2 == 1", "input_output_examples": "[[['Hadoop']], [[False]]]", "starter_code": "def word_len(s: str) -> bool:", "llm_generated_inputs": "[['hello'], ['worlds'], ['a'], [''], ['Python'], [' '], ['oddlengthword'], ['evenlength']]", "clusters": {"cluster_list": [{"programs_str": ["def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0", "def word_len(s: str) -> bool:\n    return len(s) % 2 != 0"], "outputs": "[[True], [False], [True], [False], [False], [True], [True], [False]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[['hello'], ['worlds'], ['a'], [''], ['Python'], [' '], ['oddlengthword'], ['evenlength']]", "input_output_examples": "[[['Hadoop']], [[False]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/80", "requirement": "def tetrahedral_number(n: int) -> float:\n\"\"\"\nWrite a function to find the nth tetrahedral number.\n\"\"\"", "entry_point": "tetrahedral_number", "canonical_solution": "def tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6", "input_output_examples": "[[[5]], [[35]]]", "starter_code": "def tetrahedral_number(n: int) -> float:", "llm_generated_inputs": "[[0], [1], [2], [3], [4], [5], [10], [20], [-1], [-5]]", "clusters": {"cluster_list": [{"programs_str": ["def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6", "def tetrahedral_number(n: int) -> float:\n    return n * (n + 1) * (n + 2) / 6"], "outputs": "[[0.0], [1.0], [4.0], [10.0], [20.0], [35.0], [220.0], [1540.0], [0.0], [-10.0]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[0], [1], [2], [3], [4], [5], [10], [20], [-1], [-5]]", "input_output_examples": "[[[5]], [[35]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/82", "requirement": "def volume_sphere(r: float) -> float:\n\"\"\"\nWrite a function to find the volume of a sphere.\n\"\"\"", "entry_point": "volume_sphere", "canonical_solution": "import math\ndef volume_sphere(r):\n  return (4./3.) * math.pi * (r**3)", "input_output_examples": "[[[10]], [[4188.790204786391]]]", "starter_code": "def volume_sphere(r: float) -> float:", "llm_generated_inputs": "[[1.0], [0.0], [3.5], [10.0], [-1.0], [100.0], [2.71828]]", "clusters": {"cluster_list": [{"programs_str": ["import math\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * math.pi * r ** 3", "from math import pi\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * pi * r ** 3", "from math import pi\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * pi * r ** 3", "from math import pi\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * pi * r ** 3", "from math import pi\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * pi * r ** 3", "from math import pi\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * pi * r ** 3", "import math\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * math.pi * r ** 3", "def volume_sphere(r: float) -> float:\n    import math\n    return 4 / 3 * math.pi * r ** 3", "def volume_sphere(r: float) -> float:\n    import math\n    return 4 / 3 * math.pi * r ** 3", "def volume_sphere(r: float) -> float:\n    import math\n    return 4 / 3 * math.pi * r ** 3", "import math\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * math.pi * r ** 3", "def volume_sphere(r: float) -> float:\n    import math\n    return 4 / 3 * math.pi * r ** 3", "def volume_sphere(r: float) -> float:\n    from math import pi\n    return 4 / 3 * pi * r ** 3", "def volume_sphere(r: float) -> float:\n    import math\n    return 4 / 3 * math.pi * r ** 3", "import math\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * math.pi * r ** 3", "def volume_sphere(r: float) -> float:\n    import math\n    return 4 / 3 * math.pi * r ** 3", "def volume_sphere(r: float) -> float:\n    import math\n    return 4 / 3 * math.pi * r ** 3", "import math\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * math.pi * r ** 3", "def volume_sphere(r: float) -> float:\n    import math\n    return 4 / 3 * math.pi * r ** 3", "import math\n\ndef volume_sphere(r: float) -> float:\n    return 4 / 3 * math.pi * r ** 3"], "outputs": "[[4.1887902047863905], [0.0], [179.59438003021648], [4188.790204786391], [-4.1887902047863905], [4188790.2047863905], [84.13393054280141]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[1.0], [0.0], [3.5], [10.0], [-1.0], [100.0], [2.71828]]", "input_output_examples": "[[[10]], [[4188.790204786391]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/84", "requirement": "def sequence(n: int) -> int:\n\"\"\"\nWrite a function to find the nth number in the newman conway sequence.\n\"\"\"", "entry_point": "sequence", "canonical_solution": "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\tseq = [0] * (n + 1)\n\tseq[1] = seq[2] = 1\n\tfor i in range(3, n + 1):\n\t\tseq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n\treturn seq[n]", "input_output_examples": "[[[10]], [[6]]]", "starter_code": "def sequence(n: int) -> int:", "llm_generated_inputs": "[[1], [2], [3], [4], [5], [10], [15], [20], [0], [-5], [100]]", "clusters": {"cluster_list": [{"programs_str": ["def sequence(n: int) -> int:\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]"], "outputs": "[[1], [1], [2], [2], [3], [6], [8], [12], [1], ['IndexError'], [57]]", "probability": 0.05, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}, {"programs_str": ["def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]"], "outputs": "[[1], [1], [2], [2], [3], [6], [8], [12], ['IndexError'], ['IndexError'], [57]]", "probability": 0.6, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}, {"programs_str": ["def sequence(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        seq = [0] * (n + 1)\n        seq[1] = 1\n        for i in range(2, n + 1):\n            seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n        return seq[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    for i in range(2, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    for i in range(2, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        seq = [0] * (n + 1)\n        seq[1] = 1\n        for i in range(2, n + 1):\n            seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n        return seq[n]"], "outputs": "[[1], [2], [3], [4], [5], [10], [15], [20], [0], ['IndexError'], [100]]", "probability": 0.35, "is_align_req": false, "test_consistency": 0.0, "failed_input_output_examples": "[[[10], [10], [6]]]"}], "entropy": 0.7497820113685953, "llm_generated_inputs": "[[1], [2], [3], [4], [5], [10], [15], [20], [0], [-5], [100]]", "input_output_examples": "[[[10]], [[6]]]", "weighted_test_consistency": 0.65, "at_least_one_align": true, "ambiguity": 0.5498910056842976}}
{"task_id": "Mbpp/85", "requirement": "def surfacearea_sphere(r: float) -> float:\n\"\"\"\nWrite a function to find the surface area of a sphere.\n\"\"\"", "entry_point": "surfacearea_sphere", "canonical_solution": "import math\ndef surfacearea_sphere(r):\n  return 4 * math.pi * (r**2)", "input_output_examples": "[[[10]], [[1256.6370614359173]]]", "starter_code": "def surfacearea_sphere(r: float) -> float:", "llm_generated_inputs": "[[3.0], [0.0], [1.5], [100.0], [1e-06], [1000000.0], [-1.0], [-100.0]]", "clusters": {"cluster_list": [{"programs_str": ["def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "import math\n\ndef surfacearea_sphere(r: float) -> float:\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "import math\n\ndef surfacearea_sphere(r: float) -> float:\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "import math\n\ndef surfacearea_sphere(r: float) -> float:\n    return 4 * math.pi * r ** 2", "import math\n\ndef surfacearea_sphere(r: float) -> float:\n    return 4 * math.pi * r ** 2", "import math\n\ndef surfacearea_sphere(r: float) -> float:\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "import math\n\ndef surfacearea_sphere(r: float) -> float:\n    return 4 * math.pi * r ** 2", "import math\n\ndef surfacearea_sphere(r: float) -> float:\n    return 4 * math.pi * r ** 2", "import math\n\ndef surfacearea_sphere(r: float) -> float:\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2", "def surfacearea_sphere(r: float) -> float:\n    import math\n    return 4 * math.pi * r ** 2"], "outputs": "[[113.09733552923255], [0.0], [28.274333882308138], [125663.70614359173], [1.2566370614359172e-11], [12566370614359.172], [12.566370614359172], [125663.70614359173]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[3.0], [0.0], [1.5], [100.0], [1e-06], [1000000.0], [-1.0], [-100.0]]", "input_output_examples": "[[[10]], [[1256.6370614359173]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/86", "requirement": "def centered_hexagonal_number(n: int) -> int:\n\"\"\"\nWrite a function to find nth centered hexagonal number.\n\"\"\"", "entry_point": "centered_hexagonal_number", "canonical_solution": "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1", "input_output_examples": "[[[10]], [[271]]]", "starter_code": "def centered_hexagonal_number(n: int) -> int:", "llm_generated_inputs": "[[1], [2], [3], [4], [5], [10], [20], [0], [-1], [-5]]", "clusters": {"cluster_list": [{"programs_str": ["def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1", "def centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1"], "outputs": "[[1], [7], [19], [37], [61], [271], [1141], [1], [7], [91]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[1], [2], [3], [4], [5], [10], [20], [0], [-1], [-5]]", "input_output_examples": "[[[10]], [[271]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/87", "requirement": "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n\"\"\"\nWrite a function to merge three dictionaries into a single dictionary.\n\"\"\"", "entry_point": "merge_dictionaries_three", "canonical_solution": "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict", "input_output_examples": "[[[{'R': 'Red', 'B': 'Black', 'P': 'Pink'}, {'G': 'Green', 'W': 'White'}, {'O': 'Orange', 'W': 'White', 'B': 'Black'}]], [[{'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}]]]", "starter_code": "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:", "llm_generated_inputs": "[[{'a': 1}, {'b': 2}, {'c': 3}], [{'x': 10, 'y': 20}, {'y': 30, 'z': 40}, {'w': 50}], [{}, {}, {}], [{'key1': 'value1'}, {'key1': 'override1'}, {'key1': 'override2'}], [{1: 'one'}, {2: 'two'}, {3: 'three'}], [{'same': 'value'}, {'same': 'value'}, {'same': 'value'}], [{'a': 1, 'b': 2}, {'b': 3, 'c': 4}, {'c': 5, 'd': 6}], [{'nested': {'a': 1}}, {'nested': {'b': 2}}, {'nested': {'c': 3}}]]", "clusters": {"cluster_list": [{"programs_str": ["def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict", "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    return {**dict1, **dict2, **dict3}"], "outputs": "[[{'a': 1, 'b': 2, 'c': 3}], [{'x': 10, 'y': 30, 'z': 40, 'w': 50}], [{}], [{'key1': 'override2'}], [{1: 'one', 2: 'two', 3: 'three'}], [{'same': 'value'}], [{'a': 1, 'b': 3, 'c': 5, 'd': 6}], [{'nested': {'c': 3}}]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[{'a': 1}, {'b': 2}, {'c': 3}], [{'x': 10, 'y': 20}, {'y': 30, 'z': 40}, {'w': 50}], [{}, {}, {}], [{'key1': 'value1'}, {'key1': 'override1'}, {'key1': 'override2'}], [{1: 'one'}, {2: 'two'}, {3: 'three'}], [{'same': 'value'}, {'same': 'value'}, {'same': 'value'}], [{'a': 1, 'b': 2}, {'b': 3, 'c': 4}, {'c': 5, 'd': 6}], [{'nested': {'a': 1}}, {'nested': {'b': 2}}, {'nested': {'c': 3}}]]", "input_output_examples": "[[[{'R': 'Red', 'B': 'Black', 'P': 'Pink'}, {'G': 'Green', 'W': 'White'}, {'O': 'Orange', 'W': 'White', 'B': 'Black'}]], [[{'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/88", "requirement": "from typing import List\nfrom typing import Dict\n\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n\"\"\"\nWrite a function to get the frequency of all the elements in a list, returned as a dictionary.\n\"\"\"", "entry_point": "freq_count", "canonical_solution": "import collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count", "input_output_examples": "[[[[10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]]], [[{10: 4, 20: 4, 40: 2, 50: 2, 30: 1}]]]", "starter_code": "from typing import List\nfrom typing import Dict\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:", "llm_generated_inputs": "[[[1, 2, 2, 3, 3, 3]], [['apple', 'banana', 'apple', 'orange', 'banana', 'banana']], [[True, False, True, True, False]], [[]], [[42]], [[None, None, 'value', 0, 0]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import Any, List, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Dict, Any\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import Any, List, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "from typing import List, Any, Dict\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency"], "outputs": "[[{1: 1, 2: 2, 3: 3}], [{'apple': 2, 'banana': 3, 'orange': 1}], [{True: 3, False: 2}], [{}], [{42: 1}], [{None: 2, 'value': 1, 0: 2}]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[1, 2, 2, 3, 3, 3]], [['apple', 'banana', 'apple', 'orange', 'banana', 'banana']], [[True, False, True, True, False]], [[]], [[42]], [[None, None, 'value', 0, 0]]]", "input_output_examples": "[[[[10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]]], [[{10: 4, 20: 4, 40: 2, 50: 2, 30: 1}]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/89", "requirement": "def closest_num(N: int) -> int:\n\"\"\"\nWrite a function to find the closest smaller number than n.\n\"\"\"", "entry_point": "closest_num", "canonical_solution": "def closest_num(N):\n  return (N - 1)", "input_output_examples": "[[[11]], [[10]]]", "starter_code": "def closest_num(N: int) -> int:", "llm_generated_inputs": "[[5], [10], [1], [-3], [0], [100], [-1]]", "clusters": {"cluster_list": [{"programs_str": ["def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1"], "outputs": "[[4], [9], [0], [-4], [-1], [99], [-2]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[5], [10], [1], [-3], [0], [100], [-1]]", "input_output_examples": "[[[11]], [[10]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/90", "requirement": "from typing import List\n\n\ndef len_log(list1: List[str]) -> int:\n\"\"\"\nWrite a python function to find the length of the longest word.\n\"\"\"", "entry_point": "len_log", "canonical_solution": "def len_log(list1):\n    return max(len(x) for x in list1)", "input_output_examples": "[[[['python', 'PHP', 'bigdata']]], [[7]]]", "starter_code": "from typing import List\ndef len_log(list1: List[str]) -> int:", "llm_generated_inputs": "[[[]], [['a']], [['abc', 'abcd', 'abcde']], [['short', 'longer', 'longestword']], [['one', 'two', 'three', 'four', 'five']], [['equal', 'equal', 'equal']], [['a', 'ab', 'abc', 'abcd', 'abcde']], [['singleword']], [['multiple', 'words', 'of', 'different', 'lengths']]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    return max((len(word) for word in list1))"], "outputs": "[['ValueError'], [1], [5], [11], [5], [5], [5], [10], [9]]", "probability": 0.85, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}, {"programs_str": ["from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    if not list1:\n        return 0\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    if not list1:\n        return 0\n    return max((len(word) for word in list1))", "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    if not list1:\n        return 0\n    return max((len(word) for word in list1))"], "outputs": "[[0], [1], [5], [11], [5], [5], [5], [10], [9]]", "probability": 0.15, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0.6098403047164005, "llm_generated_inputs": "[[[]], [['a']], [['abc', 'abcd', 'abcde']], [['short', 'longer', 'longestword']], [['one', 'two', 'three', 'four', 'five']], [['equal', 'equal', 'equal']], [['a', 'ab', 'abc', 'abcd', 'abcde']], [['singleword']], [['multiple', 'words', 'of', 'different', 'lengths']]]", "input_output_examples": "[[[['python', 'PHP', 'bigdata']]], [[7]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.30492015235820025}}
{"task_id": "Mbpp/91", "requirement": "from typing import List\n\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n\"\"\"\nWrite a function to check if a string is present as a substring in a given list of string values.\n\"\"\"", "entry_point": "find_substring", "canonical_solution": "def find_substring(str1, sub_str):\n   return any(sub_str in s for s in str1)", "input_output_examples": "[[[['red', 'black', 'white', 'green', 'orange'], 'ack']], [[True]]]", "starter_code": "from typing import List\ndef find_substring(str1: List[str], sub_str: str) -> bool:", "llm_generated_inputs": "[[['hello', 'world'], 'hello'], [['apple', 'banana', 'cherry'], 'berry'], [['python', 'java', 'c++'], 'ruby'], [['test', 'testing', 'tested'], 'test'], [[], 'empty'], [['single'], 'single'], [['multiple', 'words', 'in', 'list'], ''], [['case', 'sensitive'], 'CASE'], [['special', 'characters', '!', '@', '#'], '@']]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False", "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False"], "outputs": "[[True], [False], [False], [True], [False], [True], [True], [False], [True]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[['hello', 'world'], 'hello'], [['apple', 'banana', 'cherry'], 'berry'], [['python', 'java', 'c++'], 'ruby'], [['test', 'testing', 'tested'], 'test'], [[], 'empty'], [['single'], 'single'], [['multiple', 'words', 'in', 'list'], ''], [['case', 'sensitive'], 'CASE'], [['special', 'characters', '!', '@', '#'], '@']]", "input_output_examples": "[[[['red', 'black', 'white', 'green', 'orange'], 'ack']], [[True]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/92", "requirement": "def is_undulating(n: int) -> bool:\n\"\"\"\nWrite a function to check whether the given number is undulating or not.\n\"\"\"", "entry_point": "is_undulating", "canonical_solution": "def is_undulating(n): \n\tdigits = [int(digit) for digit in str(n)]\n\tif len(set(digits)) != 2:\n\t\treturn False\n\treturn all(a != b for a, b in zip(digits, digits[1:]))", "input_output_examples": "[[[1212121]], [[True]]]", "starter_code": "def is_undulating(n: int) -> bool:", "llm_generated_inputs": "[[1212], [787878], [45654], [12321], [11], [9], [101010], [123456], [1001], [111], [0]]", "clusters": {"cluster_list": [{"programs_str": ["def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s[::2])) != 1 or len(set(s[1::2])) != 1:\n        return False\n    return s[0] != s[1]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s[::2])) != 1 or len(set(s[1::2])) != 1:\n        return False\n    return s[0] != s[1]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    for i in range(1, len(s) - 1):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s[::2])) != 1 or len(set(s[1::2])) != 1:\n        return False\n    return s[0] != s[1]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i - 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s[::2])) != 1 or len(set(s[1::2])) != 1:\n        return False\n    return s[0] != s[1]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i - 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    pattern = s[0] + s[1]\n    return s == pattern * (len(s) // 2) or s == pattern * (len(s) // 2) + s[0]"], "outputs": "[[True], [True], [False], [False], [False], [False], [True], [False], [False], [False], [False]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[1212], [787878], [45654], [12321], [11], [9], [101010], [123456], [1001], [111], [0]]", "input_output_examples": "[[[1212121]], [[True]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/93", "requirement": "def power(a: int, b: int) -> int:\n\"\"\"\nWrite a function to calculate the value of 'a' to the power 'b'.\n\"\"\"", "entry_point": "power", "canonical_solution": "def power(a, b):\n\treturn a ** b", "input_output_examples": "[[[3, 4]], [[81]]]", "starter_code": "def power(a: int, b: int) -> int:", "llm_generated_inputs": "[[2, 3], [5, 0], [0, 5], [0, 0], [-2, 3], [-2, 4], [2, -3], [-2, -3], [10, 1], [1, 10]]", "clusters": {"cluster_list": [{"programs_str": ["def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b", "def power(a: int, b: int) -> int:\n    return a ** b"], "outputs": "[[8], [1], [0], [1], [-8], [16], [0.125], [-0.125], [10], [1]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[2, 3], [5, 0], [0, 5], [0, 0], [-2, 3], [-2, 4], [2, -3], [-2, -3], [10, 1], [1, 10]]", "input_output_examples": "[[[3, 4]], [[81]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/94", "requirement": "from typing import List\n\n\ndef index_minimum(test_list: List[tuple]) -> any:\n\"\"\"\nGiven a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n\"\"\"", "entry_point": "index_minimum", "canonical_solution": "from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res)", "input_output_examples": "[[[[('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]]], [['Varsha']]]", "starter_code": "from typing import List\ndef index_minimum(test_list: List[tuple]) -> any:", "llm_generated_inputs": "[[[(1, 3), (4, 2), (5, 1)]], [[(10, 10), (20, 20), (30, 30)]], [[(-1, -3), (-4, -2), (-5, -1)]], [[(0, 100), (0, 50), (0, 25)]], [[(1, 1)]], [[]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List\n\ndef index_minimum(test_list: List[tuple]) -> any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List\n\ndef index_minimum(test_list: List[tuple]) -> any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List\n\ndef index_minimum(test_list: List[tuple]) -> any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List\n\ndef index_minimum(test_list: List[tuple]) -> any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List\n\ndef index_minimum(test_list: List[tuple]) -> any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List\n\ndef index_minimum(test_list: List[tuple]) -> any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List\n\ndef index_minimum(test_list: List[tuple]) -> any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List\n\ndef index_minimum(test_list: List[tuple]) -> any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]", "from typing import List, Tuple, Any\n\ndef index_minimum(test_list: List[Tuple[Any, Any]]) -> Any:\n    return min(test_list, key=lambda x: x[1])[0]"], "outputs": "[[5], [10], [-1], [0], [1], ['ValueError']]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[(1, 3), (4, 2), (5, 1)]], [[(10, 10), (20, 20), (30, 30)]], [[(-1, -3), (-4, -2), (-5, -1)]], [[(0, 100), (0, 50), (0, 25)]], [[(1, 1)]], [[]]]", "input_output_examples": "[[[[('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]]], [['Varsha']]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/95", "requirement": "from typing import List\n\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n\"\"\"\nWrite a python function to find the length of the smallest list in a list of lists.\n\"\"\"", "entry_point": "Find_Min_Length", "canonical_solution": "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength", "input_output_examples": "[[[[[1], [1, 2]]]], [[1]]]", "starter_code": "from typing import List\ndef Find_Min_Length(lst: List[List[Any]]) -> int:", "llm_generated_inputs": "[[[[1, 2, 3], [4, 5], [6]]], [[[], [1], [1, 2]]], [[[1, 2], [3, 4], [5, 6]]], [[[1]]], [[]], [[[1, 2, 3, 4, 5], [6, 7, 8], [9, 10, 11, 12, 13, 14]]]]", "clusters": {"cluster_list": [{"programs_str": ["from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    return min((len(sublist) for sublist in lst))"], "outputs": "[[1], [0], [2], [1], ['ValueError'], [3]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[[1, 2, 3], [4, 5], [6]]], [[[], [1], [1, 2]]], [[[1, 2], [3, 4], [5, 6]]], [[[1]]], [[]], [[[1, 2, 3, 4, 5], [6, 7, 8], [9, 10, 11, 12, 13, 14]]]]", "input_output_examples": "[[[[[1], [1, 2]]]], [[1]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n\"\"\"\nWrite a python function to find the number of divisors of a given integer.\n\"\"\"", "entry_point": "divisor", "canonical_solution": "def divisor(n):\n  return sum(1 for i in range(1, n + 1) if n % i == 0)", "input_output_examples": "[[[15]], [[4]]]", "starter_code": "def divisor(n: int) -> int:", "llm_generated_inputs": "[[1], [2], [3], [4], [5], [6], [10], [13], [16], [17], [18], [25], [29], [30], [36], [49], [50], [60], [100], [121], [125], [144], [169], [196], [225], [243], [256], [289], [324], [361], [400], [441], [484], [529], [576], [625], [676], [729], [784], [841], [900], [961], [1024], [-1], [-4], [-9], [-16], [0]]", "clusters": {"cluster_list": [{"programs_str": ["def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count"], "outputs": "[[1], [2], [2], [3], [2], [4], [4], [2], [5], [2], [6], [3], [2], [8], [9], [3], [6], [12], [9], [3], [4], [15], [3], [9], [9], [6], [9], [3], [15], [3], [15], [9], [9], [3], [21], [5], [9], [7], [15], [3], [27], [3], [11], ['TypeError'], ['TypeError'], ['TypeError'], ['TypeError'], [0]]", "probability": 1.0, "is_align_req": true, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[1], [2], [3], [4], [5], [6], [10], [13], [16], [17], [18], [25], [29], [30], [36], [49], [50], [60], [100], [121], [125], [144], [169], [196], [225], [243], [256], [289], [324], [361], [400], [441], [484], [529], [576], [625], [676], [729], [784], [841], [900], [961], [1024], [-1], [-4], [-9], [-16], [0]]", "input_output_examples": "[[[15]], [[4]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true, "ambiguity": 0.0}}

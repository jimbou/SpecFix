{"task_id": "TACO_lite/0", "requirement": "def is_anagram(test: str, original: str) -> bool:\n\"\"\"An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n**Note:** anagrams are case insensitive\n\nComplete the function to return `true` if the two arguments given are anagrams of each other; return `false` otherwise.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other (case insensitive).\"\"\"\n    return Counter(test.lower()) == Counter(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    return sorted(test.lower()) == sorted(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    return sorted(test.lower()) == sorted(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    return sorted(test.lower()) == sorted(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams, ignoring case.\"\"\"\n    return Counter(test.lower()) == Counter(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    return sorted(test.lower()) == sorted(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    return sorted(test.lower()) == sorted(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other (case insensitive).\"\"\"\n    return sorted(test.lower()) == sorted(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other (case insensitive).\"\"\"\n    return Counter(test.lower()) == Counter(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other (case insensitive).\"\"\"\n    return Counter(test.lower()) == Counter(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = ''.join(sorted(test.lower()))\n    sorted_original = ''.join(sorted(original.lower()))\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other (case insensitive).\"\"\"\n    return Counter(test.lower()) == Counter(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams (case insensitive).\"\"\"\n    return Counter(test.lower()) == Counter(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    \"\"\"An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n    **Note:** anagrams are case insensitive\n\n    Complete the function to return `true` if the two arguments given are anagrams of each other; return `false` otherwise.\n    \"\"\"\n    return sorted(test.lower()) == sorted(original.lower())", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams, ignoring case.\"\"\"\n    return Counter(test.lower()) == Counter(original.lower())", "def is_anagram(test: str, original: str) -> bool:\n    \"\"\"An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n    **Note:** anagrams are case insensitive\n\n    Complete the function to return `true` if the two arguments given are anagrams of each other; return `false` otherwise.\n    \"\"\"\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original", "def is_anagram(test: str, original: str) -> bool:\n    \"\"\"An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n    **Note:** anagrams are case insensitive\n\n    Complete the function to return `true` if the two arguments given are anagrams of each other; return `false` otherwise.\n    \"\"\"\n    sorted_test = sorted(test.lower())\n    sorted_original = sorted(original.lower())\n    return sorted_test == sorted_original"], "requirement": [], "outputs": "[[True], [True], [True], [False], [True], [True], [False], [True], [True], [True], [True], [False], [True], [False], [True], [False], [False], [False], [True], [False], [False], [False], [True], [True], [False], [False], [False]]", "probability": 0.68, "is_align_req": false, "DRS": null}, {"programs_str": ["def is_anagram(test: str, original: str) -> bool:\n    normalized_test = ''.join(sorted(test.lower())).strip()\n    normalized_original = ''.join(sorted(original.lower())).strip()\n    return normalized_test == normalized_original", "def is_anagram(test: str, original: str) -> bool:\n    test = test.replace(' ', '').lower()\n    original = original.replace(' ', '').lower()\n    return sorted(test) == sorted(original)", "def is_anagram(test: str, original: str) -> bool:\n    test = test.replace(' ', '').lower()\n    original = original.replace(' ', '').lower()\n    return sorted(test) == sorted(original)", "def is_anagram(test: str, original: str) -> bool:\n    test = ''.join(filter(str.isalnum, test.lower()))\n    original = ''.join(filter(str.isalnum, original.lower()))\n    return sorted(test) == sorted(original)", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams, ignoring case.\"\"\"\n    test = test.replace(' ', '').lower()\n    original = original.replace(' ', '').lower()\n    return Counter(test) == Counter(original)", "def is_anagram(test: str, original: str) -> bool:\n    test = test.replace(' ', '').lower()\n    original = original.replace(' ', '').lower()\n    return sorted(test) == sorted(original)", "def is_anagram(test: str, original: str) -> bool:\n    test_clean = ''.join(filter(str.isalpha, test.lower()))\n    original_clean = ''.join(filter(str.isalpha, original.lower()))\n    return sorted(test_clean) == sorted(original_clean)", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other (case insensitive).\"\"\"\n    test_clean = test.replace(' ', '').lower()\n    original_clean = original.replace(' ', '').lower()\n    return Counter(test_clean) == Counter(original_clean)", "def is_anagram(test: str, original: str) -> bool:\n    test_cleaned = ''.join(filter(str.isalpha, test.lower()))\n    original_cleaned = ''.join(filter(str.isalpha, original.lower()))\n    return sorted(test_cleaned) == sorted(original_cleaned)", "def is_anagram(test: str, original: str) -> bool:\n    test_cleaned = ''.join(filter(str.isalpha, test.lower()))\n    original_cleaned = ''.join(filter(str.isalpha, original.lower()))\n    return sorted(test_cleaned) == sorted(original_cleaned)", "def is_anagram(test: str, original: str) -> bool:\n    filtered_test = ''.join(filter(str.isalpha, test.lower()))\n    filtered_original = ''.join(filter(str.isalpha, original.lower()))\n    return sorted(filtered_test) == sorted(filtered_original)", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"Check if two strings are anagrams, ignoring case.\"\"\"\n    test_clean = ''.join(filter(str.isalpha, test.lower()))\n    original_clean = ''.join(filter(str.isalpha, original.lower()))\n    return Counter(test_clean) == Counter(original_clean)", "def is_anagram(test: str, original: str) -> bool:\n    test = ''.join(filter(str.isalnum, test.lower()))\n    original = ''.join(filter(str.isalnum, original.lower()))\n    return sorted(test) == sorted(original)", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n    **Note:** anagrams are case insensitive\n\n    Complete the function to return `True` if the two arguments given are anagrams of each other; return `False` otherwise.\n    \"\"\"\n    test_cleaned = test.lower().replace(' ', '')\n    original_cleaned = original.lower().replace(' ', '')\n    return Counter(test_cleaned) == Counter(original_cleaned)", "from collections import Counter\n\ndef is_anagram(test: str, original: str) -> bool:\n    \"\"\"An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n    **Note:** anagrams are case insensitive\n\n    Complete the function to return `true` if the two arguments given are anagrams of each other; return `false` otherwise.\n    \"\"\"\n    test = test.replace(' ', '').lower()\n    original = original.replace(' ', '').lower()\n    return Counter(test) == Counter(original)", "def is_anagram(test: str, original: str) -> bool:\n    \"\"\"An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n    **Note:** anagrams are case insensitive\n\n    Complete the function to return `true` if the two arguments given are anagrams of each other; return `false` otherwise.\n    \"\"\"\n    test_clean = ''.join(test.lower().split())\n    original_clean = ''.join(original.lower().split())\n    return sorted(test_clean) == sorted(original_clean)"], "requirement": [], "outputs": "[[True], [True], [True], [True], [True], [True], [False], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [True], [False]]", "probability": 0.32, "is_align_req": false, "DRS": null}], "entropy": 0.6268694575724263, "llm_generated_inputs": "[['listen', 'silent'], ['hello', 'llohe'], ['LISTEN', 'SILENT'], ['dormitory', 'dirty room'], ['school master', 'the classroom'], ['', ''], ['a', 'b'], ['iceman', 'cinema'], ['State', 'Taste'], ['This is a test', 'is a test This'], ['Listen', 'Silent'], ['Funeral', 'Real Fun'], ['restful', 'fluster'], ['Conversation', 'Voices Rant On'], ['The Eyes', 'They See'], ['Astronomer', 'Moon starer'], ['Dormitory', 'Dirty Room'], ['Slot machines', 'Cash lost in me'], ['Eleven plus two', 'Twelve plus one'], ['Fourth of July', 'joyful Fourth'], ['desperation', 'a rope ends it'], ['Tom Marvolo Riddle', 'I am Lord Voldemort'], ['The Morse Code', 'Here come dots'], ['A gentleman', 'Elegant man'], ['The public art galleries', 'Large picture halls I bet'], ['George Bush', 'He bugs Gore'], ['Western Union', 'Nuden Weseto']]", "input_output_examples": "[[['foefet', 'toffee'], ['Buckethead', 'DeathCubeK']], [[True], [True]]]", "at_least_one_align": false}, "entry_point": "is_anagram", "ground_truth": -1}
{"task_id": "TACO_lite/1", "requirement": "def make_acronym(phrase: str) -> str:\n\"\"\"Implement a function called makeAcronym that returns the first letters of each word in a passed in string.\n\nMake sure the letters returned are uppercase.\n\nIf the value passed in is not a string return 'Not a string'.\n\nIf the value passed in is a string which contains characters other than spaces and alphabet letters, return 'Not letters'.\n\nIf the string is empty, just return the string itself: \"\".\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((char.isalpha() or char.isspace() for char in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    phrase = phrase.strip()\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((ch.isalpha() or ch.isspace() for ch in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    phrase = phrase.strip()\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "import string\n\ndef make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    phrase = phrase.strip()\n    if any((ch for ch in phrase if ch not in string.ascii_letters + ' ')):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if not phrase:\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "import string\n\ndef make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    phrase = phrase.strip()\n    if any((ch for ch in phrase if ch not in string.ascii_letters + ' ')):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    phrase = phrase.strip()\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    acronym = ''.join((word[0].upper() for word in phrase.split()))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    phrase = phrase.strip()\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym", "def make_acronym(phrase: str) -> str:\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    if phrase == '':\n        return ''\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    words = phrase.split()\n    acronym = ''.join((word[0].upper() for word in words))\n    return acronym"], "requirement": [], "outputs": "[['IBM'], ['PNG'], ['Not letters'], ['ASAP'], ['Not a string'], ['Not a string'], ['Not letters'], ['Not letters'], [''], [''], ['Not letters'], ['HW']]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[['International Business Machines'], ['Portable Network Graphics'], ['First In, First Out'], ['As Soon As Possible'], [12345], [None], ['!@#$%^&*()'], ['Hello 123 World'], [''], ['   '], ['Hello World!'], ['hello world']]", "input_output_examples": "[[['Hello codewarrior'], ['a42'], [42], [[2, 12]], [{'name': 'Abraham'}]], [['HC'], ['Not letters'], ['Not a string'], ['Not a string'], ['Not a string']]]", "at_least_one_align": false}, "entry_point": "make_acronym", "ground_truth": 0}
{"task_id": "TACO_lite/2", "requirement": "def solve_for_x(equation: str) -> int:\n\"\"\"# Solve For X\n\nYou will be given an equation as a string and you will need to [solve for X](https://www.mathplacementreview.com/algebra/basic-algebra.php#solve-for-a-variable) and return x's value.\n\nNOTES:\n * All numbers will be whole numbers\n * Don't forget about the [order of operations](https://www.mathplacementreview.com/algebra/basic-algebra.php#order-of-operations).\n * If the random tests don't pass the first time, just run them again.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_obj = Eq(*[eval(part.strip(), {'x': x}) for part in equation.split('=')])\n    solution = solve(equation_obj, x)\n    return int(solution[0]) if solution else None", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solve the given equation for x and return its value.\n    \n    Parameters:\n        equation (str): A string representation of the equation to solve.\n        \n    Returns:\n        int: The value of x.\n    \"\"\"\n    x = symbols('x')\n    equation = Eq(*[eval(part.strip()) for part in equation.split('=')])\n    solution = solve(equation, x)\n    return int(solution[0]) if solution else None", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation = equation.replace('=', '==')\n    eq = Eq(eval(equation.split('==')[0]), eval(equation.split('==')[1]))\n    solution = solve(eq, x)\n    return int(solution[0]) if solution else None", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_obj = Eq(*[eval(part.strip()) for part in equation.split('=')])\n    solution = solve(equation_obj, x)\n    return int(solution[0]) if solution else None", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation = Eq(eval(equation.split('=')[0]), eval(equation.split('=')[1]))\n    solution = solve(equation, x)\n    return int(solution[0]) if solution else None", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_obj = Eq(eval(equation.split('=')[0].strip()), eval(equation.split('=')[1].strip()))\n    solution = solve(equation_obj, x)\n    return int(solution[0]) if solution else None"], "requirement": [], "outputs": "[[3], [13], [5], [15], [5], [6], [3], [5], [5], [5], [10], [7], [None], [1], [0], [None], [5], [5], [3], [2]]", "probability": 0.12, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation = equation.replace('=', '==')\n    lhs, rhs = equation.split('==')\n    eq = Eq(eval(lhs), eval(rhs))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    eq = Eq(eval(equation.split('=')[0]), eval(equation.split('=')[1]))\n    sol = solve(eq, x)\n    return int(sol[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_object = Eq(eval(equation.split('=')[0].strip()), eval(equation.split('=')[1].strip()))\n    solution = solve(equation_object, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    eq = Eq(eval(equation.split('=')[0].strip()), eval(equation.split('=')[1].strip()))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns the value of x.\n    \n    :param equation: A string representing the equation to solve.\n    :return: Integer value of x that solves the equation.\n    \"\"\"\n    x = symbols('x')\n    equation_parsed = Eq(*[eval(part, {'x': x}) for part in equation.split('=')])\n    solution = solve(equation_parsed, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns the value of x.\n    \n    Parameters:\n        equation (str): The equation to solve for x.\n        \n    Returns:\n        int: The value of x.\n    \"\"\"\n    x = symbols('x')\n    equation_obj = Eq(*map(lambda side: eval(side.strip(), {'x': x}), equation.split('=')))\n    solution = solve(equation_obj, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_obj = Eq(eval(equation.split('=')[0].strip()), eval(equation.split('=')[1].strip()))\n    sol = solve(equation_obj)\n    return int(sol[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    eq = Eq(*map(lambda side: eval(side.strip(), {'x': x}), equation.split('=')))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    eq = Eq(*map(lambda side: eval(side.strip(), {'x': x}), equation.split('=')))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    eq = Eq(*[eval(part.strip()) for part in equation.split('=')])\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_obj = Eq(eval(equation.split('=')[0].strip()), eval(equation.split('=')[1].strip()))\n    sol = solve(equation_obj, x)\n    return int(sol[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_obj = Eq(*[eval(part.strip()) for part in equation.split('=')])\n    solution = solve(equation_obj, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation = Eq(eval(equation.split('=')[0].strip()), eval(equation.split('=')[1].strip()))\n    solution = solve(equation, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    eq = Eq(eval(equation.split('=')[0].strip()), eval(equation.split('=')[1].strip()))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    eq = Eq(eval(equation.split('=')[0], {'x': x}), eval(equation.split('=')[1], {'x': x}))\n    solution = solve(eq, x)\n    return int(solution[0])", "import re\nfrom sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation = equation.replace('=', '==')\n    left_side, right_side = equation.split('==')\n    eq = Eq(eval(left_side), eval(right_side))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_parts = equation.split('=')\n    left_side = equation_parts[0].strip()\n    right_side = equation_parts[1].strip()\n    eq = Eq(eval(left_side), eval(right_side))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    eq = Eq(eval(equation.split('=')[0]), eval(equation.split('=')[1]))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_obj = Eq(*[eval(part.strip()) for part in equation.split('=')])\n    solution = solve(equation_obj, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation = Eq(eval(equation.split('=')[0].strip()), eval(equation.split('=')[1].strip()))\n    sol = solve(equation, x)\n    return int(sol[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation = equation.replace('=', '==')\n    lhs, rhs = equation.split('==')\n    eq = Eq(eval(lhs), eval(rhs))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns its value.\n    \n    Parameters:\n    equation (str): The equation to solve in string format.\n    \n    Returns:\n    int: The value of x.\n    \"\"\"\n    x = symbols('x')\n    equation_obj = Eq(eval(equation.split('=')[0].strip()), eval(equation.split('=')[1].strip()))\n    solution = solve(equation_obj, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    eq = Eq(*map(lambda side: eval(side.strip(), {'x': x}), equation.split('=')))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_object = Eq(eval(equation.split('=')[0].strip()), eval(equation.split('=')[1].strip()))\n    solution = solve(equation_object, x)\n    return int(solution[0])", "import re\nfrom sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation = equation.replace('=', '-(') + ')'\n    equation = re.sub('([0-9])([a-zA-Z])', '\\\\1*\\\\2', equation)\n    expr = eval(equation)\n    equation = Eq(expr, 0)\n    solution = solve(equation, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solve the given equation for x and return the value of x.\n    \n    Parameters:\n    equation (str): A string representing a mathematical equation involving 'x'.\n    \n    Returns:\n    int: The integer solution for x.\n    \"\"\"\n    x = symbols('x')\n    equation = Eq(*[eval(part.strip()) for part in equation.split('=')])\n    solution = solve(equation, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    eq = Eq(eval(equation.split('=')[0]), eval(equation.split('=')[1]))\n    solution = solve(eq, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation_parsed = Eq(*map(eval, equation.replace('=', ', ').split(', ')))\n    solution = solve(equation_parsed, x)\n    return int(solution[0])"], "requirement": [], "outputs": "[[3], [13], [5], [15], [5], [6], [3], [5], [5], [5], [10], [7], ['IndexError'], [1], [0], ['IndexError'], [5], [5], [3], [2]]", "probability": 0.56, "is_align_req": false, "DRS": null}, {"programs_str": ["import sympy\n\ndef solve_for_x(equation: str) -> int:\n    x = sympy.symbols('x')\n    equation_parsed = sympy.sympify(equation)\n    solution = sympy.solve(equation_parsed, x)\n    return int(solution[0])", "import sympy as sp\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns its value as an integer.\n    \n    Args:\n        equation (str): The equation to solve for x.\n        \n    Returns:\n        int: The value of x.\n    \"\"\"\n    x = sp.symbols('x')\n    solution = sp.solve(equation, x)\n    return int(solution[0])", "import sympy\n\ndef solve_for_x(equation: str) -> int:\n    x = sympy.symbols('x')\n    equation_parsed = sympy.sympify(equation)\n    solution = sympy.solve(equation_parsed, x)\n    return int(solution[0])", "import sympy\n\ndef solve_for_x(equation: str) -> int:\n    x = sympy.symbols('x')\n    solution = sympy.solve(equation, x)\n    return int(solution[0])", "import sympy\n\ndef solve_for_x(equation: str) -> int:\n    x = sympy.symbols('x')\n    equation = sympy.sympify(equation)\n    solution = sympy.solve(equation, x)\n    return int(solution[0])", "import sympy\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns its value.\n    \n    Parameters:\n        equation (str): A string representation of the equation.\n        \n    Returns:\n        int: The integer value of x that satisfies the equation.\n    \"\"\"\n    x = sympy.symbols('x')\n    equation_parsed = sympy.sympify(equation)\n    solution = sympy.solve(equation_parsed, x)\n    return int(solution[0])"], "requirement": [], "outputs": "[['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError'], ['SympifyError']]", "probability": 0.12, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns the value of x.\n    \n    Parameters:\n    equation (str): A string representing an equation to solve.\n    \n    Returns:\n    int: The value of x.\n    \"\"\"\n    x = symbols('x')\n    equation_parsed = Eq(*map(lambda part: eval(part.strip()), equation.split('=')))\n    solution = solve(equation_parsed, x)\n    if solution:\n        return int(solution[0])\n    else:\n        raise ValueError('No solution found for the given equation.')", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solve the given equation for x and return its value.\n    \n    :param equation: A string representing the equation to solve.\n    :return: The integer value of x.\n    \"\"\"\n    x = symbols('x')\n    equation_obj = Eq(*map(lambda side: eval(side.strip(), {x: x}), equation.split('=')))\n    solution = solve(equation_obj, x)\n    if len(solution) != 1 or not solution[0].is_integer:\n        raise ValueError('Equation does not have a unique integer solution.')\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns the value of x.\n    \n    :param equation: A string representing the equation to solve for x.\n    :return: The integer value of x.\n    \"\"\"\n    x = symbols('x')\n    equation_parsed = Eq(*map(lambda s: eval(s.strip(), {x: x}), equation.split('=')))\n    solution = solve(equation_parsed, x)\n    return int(solution[0]) if solution else None", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns its value.\n    \n    Parameters:\n    equation (str): The equation to solve, where 'x' is the variable.\n    \n    Returns:\n    int: The value of x.\n    \"\"\"\n    x = symbols('x')\n    equation_obj = Eq(eval(equation.split('=')[0].strip(), {x: x}), eval(equation.split('=')[1].strip(), {x: x}))\n    solution = solve(equation_obj, x)\n    if solution and solution[0].is_integer:\n        return int(solution[0])\n    else:\n        raise ValueError('Solution is not an integer or equation has no solution.')", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns its value.\n    \n    Parameters:\n        equation (str): A string representing the equation to be solved.\n        \n    Returns:\n        int: The solution for x as an integer.\n    \"\"\"\n    x = symbols('x')\n    equation_obj = Eq(*map(lambda side: eval(side.strip(), {x: x}), equation.split('=')))\n    solution = solve(equation_obj, x)\n    return int(solution[0])", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns the value of x.\n    \n    :param equation: A string representing the equation to solve for x.\n    :return: The integer value of x that satisfies the equation.\n    \"\"\"\n    x = symbols('x')\n    equation_object = Eq(*map(lambda side: eval(side.strip(), {x: x}), equation.split('=')))\n    solution = solve(equation_object, x)\n    return int(solution[0])"], "requirement": [], "outputs": "[['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError'], ['NameError']]", "probability": 0.12, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\nimport sympy\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    This function takes an equation string and solves for x.\n    \n    Parameters:\n    equation (str): The equation to solve for x.\n    \n    Returns:\n    int: The value of x that satisfies the equation.\n    \"\"\"\n    x = sympy.symbols('x')\n    eq = sympy.Eq(*map(sympy.sympify, equation.split('=')))\n    solution = sympy.solve(eq, x)\n    if len(solution) != 1:\n        raise ValueError('Equation does not have exactly one solution.')\n    return round(float(solution[0]))", "from sympy import symbols, Eq, solve\n\ndef solve_for_x(equation: str) -> int:\n    x = symbols('x')\n    equation = Eq(*map(lambda side: eval(side, {'x': x}), equation.split('=')))\n    solution = solve(equation, x)\n    if solution and solution[0].is_integer:\n        return int(solution[0])\n    else:\n        raise ValueError('No integer solution found')"], "requirement": [], "outputs": "[[3], [13], [5], [15], [5], [6], [3], [5], [5], [5], [10], [7], ['ValueError'], [1], [0], ['ValueError'], [5], [5], [3], [2]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["import sympy\n\ndef solve_for_x(equation: str) -> int:\n    \"\"\"\n    Solves the given equation for x and returns its value as an integer.\n    \n    Args:\n        equation (str): The equation to solve, represented as a string.\n        \n    Returns:\n        int: The value of x after solving the equation.\n    \"\"\"\n    x = sympy.symbols('x')\n    equation_parsed = sympy.parse_expr(equation)\n    solution = sympy.solve(equation_parsed, x)\n    if solution:\n        return int(solution[0])\n    else:\n        raise ValueError('No solution found for the given equation')"], "requirement": [], "outputs": "[['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError'], ['SyntaxError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import re\n\ndef solve_for_x(equation: str) -> int:\n    equation = equation.replace(' ', '')\n    left_side, right_side = equation.split('=')\n    if 'x' in left_side:\n        terms = re.split('(\\\\+|-)', left_side)\n        terms = [term for term in terms if term != '']\n        constant_part_left = 0\n        for i in range(0, len(terms), 2):\n            if 'x' not in terms[i]:\n                constant_part_left += int(terms[i]) if i == 0 or terms[i - 1] == '+' else -int(terms[i])\n        right_side_value = eval(right_side) - constant_part_left\n        x_index = terms.index('x')\n        if x_index > 0 and terms[x_index - 1] in ('+', '-'):\n            coefficient = 1 if terms[x_index - 1] == '+' else -1\n        else:\n            coefficient = 1\n        return right_side_value // coefficient\n    elif 'x' in right_side:\n        terms = re.split('(\\\\+|-)', right_side)\n        terms = [term for term in terms if term != '']\n        constant_part_right = 0\n        for i in range(0, len(terms), 2):\n            if 'x' not in terms[i]:\n                constant_part_right += int(terms[i]) if i == 0 or terms[i - 1] == '+' else -int(terms[i])\n        left_side_value = eval(left_side) - constant_part_right\n        x_index = terms.index('x')\n        if x_index > 0 and terms[x_index - 1] in ('+', '-'):\n            coefficient = 1 if terms[x_index - 1] == '+' else -1\n        else:\n            coefficient = 1\n        return left_side_value // coefficient"], "requirement": [], "outputs": "[[3], [13], ['ValueError'], ['ValueError'], [5], ['ValueError'], [3], [5], [5], ['ValueError'], [10], [7], ['ValueError'], ['ValueError'], [0], [0], [10], [-5], ['ValueError'], [2]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.3732291835855341, "llm_generated_inputs": "[['2 + x = 5'], ['x - 3 = 10'], ['4 * x = 20'], ['x / 5 = 3'], ['x + 8 - 3 = 10'], ['2 * x + 3 = 15'], ['3 + x + 6 = 12'], ['7 - x = 2'], ['x - 9 + 4 = 0'], ['15 / x = 3'], ['x = 10'], ['x + 0 = 7'], ['0 * x + 5 = 5'], ['5 / x = 5'], ['0 + x = 0'], ['x - x = 0'], ['x + x = 10'], ['2 * x - x = 5'], ['-x + 5 = 2'], ['x - 5 = -3']]", "input_output_examples": "[[['x - 5 = 20'], ['20 = 5 * x - 5'], ['5 * x = x + 8'], ['(5 - 3) * x = x + 2']], [[25], [5], [2], [2]]]", "at_least_one_align": false}, "entry_point": "solve_for_x", "ground_truth": -1}
{"task_id": "TACO_lite/3", "requirement": "from typing import List\ndef total(arr: List[int]) -> int:\n\"\"\"Write a function that takes an array/list of numbers and returns a number such that \n\n**Note:** each array/list will have at least an element and all elements will be valid numbers.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Returns the sum of all elements in the list.\"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of the elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"\n    Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"\n    Write a function that takes an array/list of numbers and returns the sum of the elements.\n\n    :param arr: List of integers\n    :return: Sum of the elements in the list\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of the elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of the elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of the elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Returns the sum of all elements in the list.\"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of the elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of the elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"\n    Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"\n    This function takes an array/list of numbers and returns the sum of all elements.\n\n    :param arr: List[int] - A list of integers.\n    :return: int - The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of the elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of the elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of the elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of the elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"\n    This function takes an array/list of numbers and returns the sum of all elements.\n    \n    :param arr: List of integers\n    :return: Sum of all integers in the list\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least one element, and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Args:\n        arr (List[int]): List of integers.\n\n    Returns:\n        int: Sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of the elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"\n    Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    :param arr: List of integers.\n    :return: Sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns their sum.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of the elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Note: Each array/list will have at least an element and all elements will be valid numbers.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of the elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of the elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"\n    This function takes an array/list of numbers and returns the sum of all elements.\n\n    :param arr: List[int] - A list of integers.\n    :return: int - The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"\n    Returns the sum of all elements in the given list of numbers.\n    \n    :param arr: List of integers\n    :return: Sum of the elements in the list\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"\n    This function takes an array/list of numbers and returns the sum of all elements.\n    \n    Args:\n    arr (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of the elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of the elements in the list.\n    \"\"\"\n    return sum(arr)", "from typing import List\n\ndef total(arr: List[int]) -> int:\n    \"\"\"Write a function that takes an array/list of numbers and returns the sum of all elements.\n\n    Args:\n        arr (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    return sum(arr)"], "requirement": [], "outputs": "[[15], [-15], [0], [1500], [-1], [17.5], [-30], [10], [-10], [0]]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[[1, 2, 3, 4, 5]], [[-1, -2, -3, -4, -5]], [[0, 0, 0, 0, 0]], [[100, 200, 300, 400, 500]], [[1, 2, -3, 4, -5]], [[1.5, 2.5, 3.5, 4.5, 5.5]], [[-10, 20, -30, 40, -50]], [[10]], [[-10]], [[0]]]", "input_output_examples": "[[[[-1, -1, -1]], [[1, 2, 3, 4]]], [[-4], [20]]]", "at_least_one_align": false}, "entry_point": "total", "ground_truth": 0}
{"task_id": "TACO_lite/4", "requirement": "def faro_cycles(n: int) -> int:\n\"\"\"A faro shuffle of a deck of playing cards is a shuffle in which the deck is split exactly in half and then the cards in the two halves are perfectly interwoven, such that the original bottom card is still on the bottom and the original top card is still on top.\n\nWrite a function that inputs an integer n and returns an integer representing the number of faro shuffles it takes to restore a deck of n cards to its original order.\n\nAssume n is an even number between 2 and 2000.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    if n <= 2:\n        return 1\n    position = 1\n    cycle_count = 0\n    while True:\n        position = 2 * position % (n - 1)\n        cycle_count += 1\n        if position == 1:\n            break\n    return cycle_count", "def faro_cycles(n: int) -> int:\n    if n <= 2:\n        return 1\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        new_deck = []\n        half = n // 2\n        for i in range(half):\n            new_deck.append(deck[i])\n            new_deck.append(deck[i + half])\n        deck = new_deck\n        shuffle_count += 1\n        if deck == original_deck:\n            break\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    if n <= 2:\n        return 1\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        deck = shuffled_deck\n        shuffle_count += 1\n        if deck == original_deck:\n            break\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    if n <= 2:\n        return 1\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        deck = shuffled_deck\n        shuffle_count += 1\n        if deck == original_deck:\n            break\n    return shuffle_count", "from typing import List\n\ndef faro_cycles(n: int) -> int:\n    if n <= 2:\n        return 1\n    deck = list(range(n))\n    original_deck = deck.copy()\n    cycles = 0\n    while True:\n        new_deck = []\n        half = n // 2\n        for i in range(half):\n            new_deck.append(deck[i])\n            new_deck.append(deck[i + half])\n        cycles += 1\n        deck = new_deck\n        if deck == original_deck:\n            break\n    return cycles", "def faro_cycles(n: int) -> int:\n    if n <= 2:\n        return 1\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == original_deck:\n            break\n    return shuffle_count", "from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    if n <= 2:\n        return 1\n    pos = 1\n    shuffle_count = 0\n    while True:\n        pos = 2 * pos % (n - 1)\n        shuffle_count += 1\n        if pos == 1:\n            break\n    return shuffle_count", "import math\n\ndef faro_cycles(n: int) -> int:\n    \"\"\"Determine the number of faro shuffles required to restore a deck of n cards to its original order.\"\"\"\n    if n <= 2:\n        return 1\n    position = 1\n    cycle_count = 0\n    while True:\n        position = 2 * position % (n - 1)\n        cycle_count += 1\n        if position == 1:\n            break\n    return cycle_count", "def faro_cycles(n: int) -> int:\n    if n <= 2:\n        return 1\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        if n > 2:\n            shuffled_deck[0], shuffled_deck[-1] = (deck[0], deck[-1])\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == original_deck:\n            break\n    return shuffle_count"], "requirement": [], "outputs": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [333], [8], [30], [1], [1], [1], 'Timeout', 'Timeout', [1]]", "probability": 0.18, "is_align_req": false, "DRS": null}, {"programs_str": ["def faro_cycles(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        for i in range(n // 2):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[n // 2 + i])\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == original_deck:\n            break\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    deck = list(range(n))\n    original_deck = deck[:]\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        for i in range(n // 2):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[i + n // 2])\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == original_deck:\n            break\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    from copy import deepcopy\n    if not (2 <= n <= 2000 and n % 2 == 0):\n        raise ValueError('n must be an even integer between 2 and 2000')\n    deck = list(range(n))\n    initial_deck = deepcopy(deck)\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[i + half])\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == initial_deck:\n            return shuffle_count", "def faro_cycles(n: int) -> int:\n    import math\n    if n % 2 != 0 or n < 2 or n > 2000:\n        raise ValueError('n must be an even number between 2 and 2000')\n\n    def faro_shuffle(deck):\n        half = len(deck) // 2\n        return [deck[i // 2] if i % 2 == 0 else deck[half + (i - 1) // 2] for i in range(len(deck))]\n    original_deck = list(range(n))\n    shuffled_deck = faro_shuffle(original_deck[:])\n    cycles = 1\n    while shuffled_deck != original_deck:\n        shuffled_deck = faro_shuffle(shuffled_deck)\n        cycles += 1\n    return cycles", "def faro_cycles(n: int) -> int:\n    from copy import deepcopy\n    if n < 2 or n > 2000 or n % 2 != 0:\n        raise ValueError('Input must be an even number between 2 and 2000.')\n    deck = list(range(n))\n    original_deck = deepcopy(deck)\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        mid = n // 2\n        for i in range(mid):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[mid + i])\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == original_deck:\n            break\n    return shuffle_count", "from typing import List\n\ndef faro_cycles(n: int) -> int:\n    if n % 2 != 0 or n < 2 or n > 2000:\n        raise ValueError('Number of cards must be an even number between 2 and 2000.')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        deck = shuffled_deck\n        shuffle_count += 1\n        if deck == original_deck:\n            break\n    return shuffle_count", "from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    if n < 2 or n > 2000 or n % 2 != 0:\n        raise ValueError('n must be an even number between 2 and 2000')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    half_n = n // 2\n    while True:\n        shuffled_deck = []\n        for i in range(half_n):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half_n + i])\n        shuffle_count += 1\n        if shuffled_deck == original_deck:\n            break\n        deck = shuffled_deck\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    import math\n    if n % 2 != 0 or not 2 <= n <= 2000:\n        raise ValueError('n must be an even number between 2 and 2000')\n    original_deck = list(range(n))\n    deck = original_deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffle_count += 1\n        new_deck = []\n        half = n // 2\n        for i in range(half):\n            new_deck.append(deck[i])\n            new_deck.append(deck[half + i])\n        deck = new_deck\n        if deck == original_deck:\n            return shuffle_count", "def faro_cycles(n: int) -> int:\n    if n % 2 != 0 or not 2 <= n <= 2000:\n        raise ValueError('n must be an even number between 2 and 2000')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        for i in range(n // 2):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[i + n // 2])\n        deck = shuffled_deck\n        shuffle_count += 1\n        if deck == original_deck:\n            break\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        for i in range(n // 2):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[i + n // 2])\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == original_deck:\n            return shuffle_count", "def faro_cycles(n: int) -> int:\n    from copy import deepcopy\n    if n < 2 or n > 2000 or n % 2 != 0:\n        raise ValueError('n must be an even number between 2 and 2000')\n    original_deck = list(range(n))\n    shuffled_deck = deepcopy(original_deck)\n    cycles = 0\n    while True:\n        new_deck = []\n        half = n // 2\n        for i in range(half):\n            new_deck.append(shuffled_deck[i])\n            new_deck.append(shuffled_deck[i + half])\n        shuffled_deck = new_deck\n        cycles += 1\n        if shuffled_deck == original_deck:\n            break\n    return cycles", "def faro_cycles(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        for i in range(n // 2):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[i + n // 2])\n        shuffle_count += 1\n        if shuffled_deck == original_deck:\n            break\n        deck = shuffled_deck\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    from copy import deepcopy\n    if n < 2 or n > 2000 or n % 2 != 0:\n        raise ValueError('n must be an even number between 2 and 2000')\n    original_deck = list(range(n))\n    shuffled_deck = deepcopy(original_deck)\n    shuffle_count = 0\n    while True:\n        shuffled_deck = [shuffled_deck[i // 2] if i % 2 == 0 else shuffled_deck[n // 2 + (i - 1) // 2] for i in range(n)]\n        shuffle_count += 1\n        if shuffled_deck == original_deck:\n            break\n    return shuffle_count", "from typing import List\n\ndef faro_cycles(n: int) -> int:\n    if n % 2 != 0 or not 2 <= n <= 2000:\n        raise ValueError('n must be an even number between 2 and 2000.')\n\n    def faro_shuffle(deck: List[int]) -> List[int]:\n        \"\"\"Performs a single faro shuffle on the deck.\"\"\"\n        half = len(deck) // 2\n        shuffled_deck = []\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        return shuffled_deck\n    original_deck = list(range(n))\n    current_deck = original_deck.copy()\n    shuffle_count = 0\n    while True:\n        current_deck = faro_shuffle(current_deck)\n        shuffle_count += 1\n        if current_deck == original_deck:\n            break\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    from copy import deepcopy\n    if not (2 <= n <= 2000 and n % 2 == 0):\n        raise ValueError('n must be an even number between 2 and 2000')\n\n    def faro_shuffle(deck):\n        half = len(deck) // 2\n        shuffled_deck = []\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        return shuffled_deck\n    original_deck = list(range(n))\n    current_deck = deepcopy(original_deck)\n    cycles = 0\n    while True:\n        current_deck = faro_shuffle(current_deck)\n        cycles += 1\n        if current_deck == original_deck:\n            break\n    return cycles", "def faro_cycles(n: int) -> int:\n    from typing import List\n    if n % 2 != 0 or n < 2 or n > 2000:\n        raise ValueError('n must be an even number between 2 and 2000.')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        for i in range(n // 2):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[i + n // 2])\n        deck = shuffled_deck\n        shuffle_count += 1\n        if deck == original_deck:\n            break\n    return shuffle_count", "from typing import List\n\ndef faro_cycles(n: int) -> int:\n    if n % 2 != 0 or n < 2 or n > 2000:\n        raise ValueError('n must be an even number between 2 and 2000')\n    deck = list(range(n))\n    original_deck = deck[:]\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        mid = n // 2\n        for i in range(mid):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[mid + i])\n        shuffle_count += 1\n        if shuffled_deck == original_deck:\n            break\n        deck = shuffled_deck\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number between 2 and 2000.')\n    original_deck = list(range(n))\n    shuffled_deck = list(original_deck)\n    cycles = 0\n    while True:\n        new_deck = [0] * n\n        for i in range(n // 2):\n            new_deck[2 * i] = shuffled_deck[i]\n            new_deck[2 * i + 1] = shuffled_deck[n // 2 + i]\n        cycles += 1\n        shuffled_deck = new_deck\n        if shuffled_deck == original_deck:\n            break\n    return cycles", "def faro_cycles(n: int) -> int:\n    if n < 2 or n > 2000 or n % 2 != 0:\n        raise ValueError('n must be an even number between 2 and 2000')\n    deck = list(range(n))\n    current_deck = deck[:]\n    shuffle_count = 0\n    while True:\n        new_deck = []\n        half = n // 2\n        for i in range(half):\n            new_deck.append(current_deck[i])\n            new_deck.append(current_deck[i + half])\n        shuffle_count += 1\n        current_deck = new_deck\n        if current_deck == deck:\n            break\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    if n < 2 or n > 2000 or n % 2 != 0:\n        raise ValueError('n must be an even number between 2 and 2000')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        shuffled_deck[0], shuffled_deck[-1] = (deck[0], deck[-1])\n        deck = shuffled_deck\n        shuffle_count += 1\n        if deck == original_deck:\n            return shuffle_count", "def faro_cycles(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number between 2 and 2000')\n    original_deck = list(range(n))\n    shuffled_deck = list(original_deck)\n    temp_deck = list(original_deck)\n    cycles = 0\n    while True:\n        for i in range(n // 2):\n            shuffled_deck[2 * i] = temp_deck[i]\n            shuffled_deck[2 * i + 1] = temp_deck[n // 2 + i]\n        cycles += 1\n        if shuffled_deck == original_deck:\n            break\n        temp_deck = list(shuffled_deck)\n    return cycles", "def faro_cycles(n: int) -> int:\n    from copy import deepcopy\n    if n < 2 or n > 2000 or n % 2 != 0:\n        raise ValueError('n must be an even number between 2 and 2000')\n    original_deck = list(range(n))\n    working_deck = deepcopy(original_deck)\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        for i in range(n // 2):\n            shuffled_deck.append(working_deck[i])\n            shuffled_deck.append(working_deck[n // 2 + i])\n        shuffle_count += 1\n        working_deck = shuffled_deck\n        if working_deck == original_deck:\n            break\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    import math\n    if n % 2 != 0 or not 2 <= n <= 2000:\n        raise ValueError('n must be an even number between 2 and 2000')\n    deck = list(range(n))\n    original_deck = deck[:]\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == original_deck:\n            break\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    from copy import deepcopy\n    if not (2 <= n <= 2000 and n % 2 == 0):\n        raise ValueError('Input must be an even number between 2 and 2000.')\n    original_deck = list(range(n))\n    current_deck = deepcopy(original_deck)\n    shuffled_deck = [0] * n\n    cycles = 0\n    while True:\n        for i in range(n // 2):\n            shuffled_deck[2 * i] = current_deck[i]\n            shuffled_deck[2 * i + 1] = current_deck[n // 2 + i]\n        cycles += 1\n        current_deck = deepcopy(shuffled_deck)\n        if current_deck == original_deck:\n            break\n    return cycles", "from typing import List\n\ndef faro_cycles(n: int) -> int:\n    if n % 2 != 0 or not 2 <= n <= 2000:\n        raise ValueError('n must be an even number between 2 and 2000.')\n\n    def faro_shuffle(deck: List[int]) -> List[int]:\n        \"\"\"Performs a single faro shuffle on the deck.\"\"\"\n        half = len(deck) // 2\n        shuffled_deck = []\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        return shuffled_deck\n    original_deck = list(range(n))\n    current_deck = original_deck.copy()\n    cycle_count = 0\n    while True:\n        current_deck = faro_shuffle(current_deck)\n        cycle_count += 1\n        if current_deck == original_deck:\n            break\n    return cycle_count", "def faro_cycles(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffled_deck = deck.copy()\n    count = 0\n    while True:\n        shuffled_deck = [deck[i // 2] if i % 2 == 0 else deck[n // 2 + (i - 1) // 2] for i in range(n)]\n        count += 1\n        if shuffled_deck == original_deck:\n            break\n        deck = shuffled_deck.copy()\n    return count"], "requirement": [], "outputs": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [333], [8], [30], [1], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.52, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef faro_cycles(n: int) -> int:\n    if n <= 2 or n % 2 != 0:\n        return 0\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == original_deck:\n            return shuffle_count", "from typing import List\n\ndef faro_cycles(n: int) -> int:\n    if n <= 2 or n % 2 != 0:\n        return 0\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        deck = shuffled_deck\n        shuffle_count += 1\n        if deck == original_deck:\n            break\n    return shuffle_count", "from typing import List\n\ndef faro_cycles(n: int) -> int:\n    if n <= 2 or n % 2 != 0:\n        return 0\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == original_deck:\n            break\n    return shuffle_count"], "requirement": [], "outputs": "[[0], [2], [3], [4], [5], [6], [7], [8], [9], [10], [333], [8], [30], [0], [0], [0], [0], [0], [0]]", "probability": 0.06, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    shuffle_count = 0\n    position = 1\n    while True:\n        shuffle_count += 1\n        position = 2 * position % (n - 1)\n        if position == 1:\n            break\n    return shuffle_count", "from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    shuffle_count = 0\n    position = 1\n    while True:\n        shuffle_count += 1\n        position = 2 * position % (n - 1)\n        if position == 1:\n            break\n    return shuffle_count", "from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    if n % 2 != 0 or not 2 <= n <= 2000:\n        raise ValueError('n must be an even number between 2 and 2000')\n    m = n // 2\n    cycles = 0\n    position = 1\n    while True:\n        cycles += 1\n        position = 2 * position % (n - 1)\n        if position == 1:\n            break\n    return cycles", "from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    \"\"\"Determine the number of faro shuffles needed to restore a deck of n cards to its original order.\"\"\"\n    if not 2 <= n <= 2000 or n % 2 != 0:\n        raise ValueError('n must be an even number between 2 and 2000.')\n    shuffle_count = 0\n    position = 1\n    while True:\n        shuffle_count += 1\n        position = 2 * position % (n - 1)\n        if position == 1:\n            break\n    return shuffle_count", "from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    \"\"\"A faro shuffle of a deck of playing cards is a shuffle in which the deck is split exactly in half and then the cards in the two halves are perfectly interwoven, such that the original bottom card is still on the bottom and the original top card is still on top.\n    \n    This function inputs an integer n and returns an integer representing the number of faro shuffles it takes to restore a deck of n cards to its original order.\n    \n    Assume n is an even number between 2 and 2000.\n    \"\"\"\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    position = 1\n    cycle_count = 0\n    while True:\n        position = 2 * position % (n - 1)\n        cycle_count += 1\n        if position == 1:\n            break\n    return cycle_count", "from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    \"\"\"A faro shuffle of a deck of playing cards is a shuffle in which the deck is split exactly in half and then the cards in the two halves are perfectly interwoven, such that the original bottom card is still on the bottom and the original top card is still on top.\n\n    Write a function that inputs an integer n and returns an integer representing the number of faro shuffles it takes to restore a deck of n cards to its original order.\n\n    Assume n is an even number between 2 and 2000.\n    \"\"\"\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    k = 1\n    while pow(2, k, n - 1) != 1:\n        k += 1\n    return k"], "requirement": [], "outputs": "['Timeout', [2], [3], [4], [5], [6], [7], [8], [9], [10], [333], [8], [30], 'Timeout', ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.12, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    if n <= 2 or n % 2 != 0:\n        return 1\n    cycle_count = 0\n    position = 1\n    original_position = 1\n    while True:\n        if position < n // 2:\n            position = 2 * position\n        else:\n            position = 2 * position - n + 1\n        cycle_count += 1\n        if position == original_position:\n            break\n    return cycle_count"], "requirement": [], "outputs": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [333], [8], [30], [1], [1], [1], [1], [1], [1]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def faro_cycles(n: int) -> int:\n    import math\n    if n % 2 != 0:\n        raise ValueError('The number of cards must be even.')\n    original_order = list(range(n))\n    current_order = list(range(n))\n    shuffle_count = 0\n    while True:\n        new_order = []\n        half = n // 2\n        for i in range(half):\n            new_order.append(current_order[i])\n            new_order.append(current_order[half + i])\n        current_order = new_order\n        shuffle_count += 1\n        if current_order == original_order:\n            break\n    return shuffle_count", "def faro_cycles(n: int) -> int:\n    from copy import deepcopy\n    if n % 2 != 0:\n        raise ValueError('n must be an even number')\n    original_deck = list(range(n))\n    working_deck = list(range(n))\n\n    def faro_shuffle(deck):\n        half = len(deck) // 2\n        shuffled_deck = []\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        return shuffled_deck\n    cycles = 0\n    while True:\n        working_deck = faro_shuffle(working_deck)\n        cycles += 1\n        if working_deck == original_deck:\n            break\n    return cycles"], "requirement": [], "outputs": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [333], [8], [30], [1], [1], [1], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef faro_cycles(n: int) -> int:\n    if n % 2 != 0 or not 2 <= n <= 2000:\n        raise ValueError('n must be an even number between 2 and 2000')\n    cycle = 1\n    shuffle_state = 1\n    deck_size_half = n // 2\n    while True:\n        shuffle_state = 2 * shuffle_state % (n - 1)\n        cycle += 1\n        if shuffle_state == 1:\n            break\n    return cycle"], "requirement": [], "outputs": "['Timeout', [3], [4], [5], [6], [7], [8], [9], [10], [11], [334], [9], [31], 'Timeout', ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef faro_cycles(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled = []\n        half = n // 2\n        for i in range(half):\n            shuffled.append(deck[i])\n            shuffled.append(deck[half + i])\n        if n > 2:\n            shuffled[0], shuffled[1] = (shuffled[1], shuffled[0])\n            shuffled[-1], shuffled[-2] = (shuffled[-2], shuffled[-1])\n        deck = shuffled\n        shuffle_count += 1\n        if deck == original_deck:\n            break\n    return shuffle_count\n\ndef faro_cycles_optimized(n: int) -> int:\n    if n <= 0 or n % 2 != 0:\n        raise ValueError('n must be an even number greater than 0')\n    shuffle_count = 0\n    position_of_card_one = 1\n    while position_of_card_one != 1 or shuffle_count == 0:\n        position_of_card_one = 2 * position_of_card_one % (n - 1)\n        shuffle_count += 1\n    return shuffle_count"], "requirement": [], "outputs": "[[1], [4], [4], [20], [30], [42], [56], [72], [90], [110], 'Timeout', [72], [480], [1], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def faro_cycles(n: int) -> int:\n    if n < 2 or n > 2000 or n % 2 != 0:\n        raise ValueError('n must be an even number between 2 and 2000')\n    deck = list(range(n))\n    original_deck = deck.copy()\n    shuffle_count = 0\n    while True:\n        shuffled_deck = []\n        half = n // 2\n        for i in range(half):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[half + i])\n        shuffled_deck[0], shuffled_deck[-1] = (deck[0], deck[-1])\n        if n % 2 == 0:\n            shuffled_deck.pop()\n        shuffle_count += 1\n        deck = shuffled_deck\n        if deck == original_deck:\n            break\n    return shuffle_count"], "requirement": [], "outputs": "[['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.5136586208866047, "llm_generated_inputs": "[[2], [4], [8], [16], [32], [64], [128], [256], [512], [1024], [2000], [52], [100], [2], [0], [-4], [3], [2001], [1]]", "input_output_examples": "[[[6]], [[8]]]", "at_least_one_align": false}, "entry_point": "faro_cycles", "ground_truth": -1}
{"task_id": "TACO_lite/5", "requirement": "from typing import List\ndef word_search(query: str, seq: List[str]) -> List[str]:\n\"\"\"Write a method that will search an array of strings for all strings that contain another string, ignoring capitalization. Then return an array of the found strings. \n\nThe method takes two parameters, the query string and the array of strings to search, and returns an array. \n\nIf the string isn't contained in any of the strings in the array, the method returns an array containing a single string: \"Empty\" (or `Nothing` in Haskell, or \"None\" in Python and C)\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    matching_words = [word for word in seq if lower_query in word.lower()]\n    return matching_words if matching_words else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found = [s for s in seq if query_lower in s.lower()]\n    return ['None'] if not found else found", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    found = [s for s in seq if lower_query in s.lower()]\n    if not found:\n        return ['None']\n    return found", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    found = [s for s in seq if lower_query in s.lower()]\n    return found if found else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found = [s for s in seq if query_lower in s.lower()]\n    if not found:\n        return ['None']\n    return found", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = [s for s in seq if query_lower in s.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found = [s for s in seq if query_lower in s.lower()]\n    return found if found else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    found_strings = [s for s in seq if lower_query in s.lower()]\n    return found_strings if found_strings else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    result = [word for word in seq if lower_query in word.lower()]\n    return result if result else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    found_strings = [word for word in seq if lower_query in word.lower()]\n    return found_strings if found_strings else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query = query.lower()\n    matches = [word for word in seq if query in word.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = [s for s in seq if query_lower in s.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = [s for s in seq if query_lower in s.lower()]\n    if not matches:\n        return ['None']\n    return matches", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    found_words = [word for word in seq if lower_query in word.lower()]\n    return found_words if found_words else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = [word for word in seq if query_lower in word.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    result = [s for s in seq if query_lower in s.lower()]\n    return ['None'] if not result else result", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    matches = [s for s in seq if lower_query in s.lower()]\n    if not matches:\n        return ['None']\n    return matches", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    matches = [word for word in seq if lower_query in word.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    found_strings = [word for word in seq if lower_query in word.lower()]\n    if not found_strings:\n        return ['None']\n    return found_strings", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found_strings = [s for s in seq if query_lower in s.lower()]\n    return found_strings if found_strings else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    matches = [s for s in seq if lower_query in s.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    matching_words = [word for word in seq if lower_query in word.lower()]\n    return matching_words if matching_words else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = [word for word in seq if query_lower in word.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    found_words = [word for word in seq if lower_query in word.lower()]\n    if not found_words:\n        return ['None']\n    return found_words", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = [s for s in seq if query_lower in s.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matching_words = [word for word in seq if query_lower in word.lower()]\n    return matching_words if matching_words else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matched_strings = [s for s in seq if query_lower in s.lower()]\n    if not matched_strings:\n        return ['None']\n    return matched_strings", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found_words = [word for word in seq if query_lower in word.lower()]\n    return found_words if found_words else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    results = [word for word in seq if lower_query in word.lower()]\n    return results if results else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    matching_strings = []\n    for string in seq:\n        if lower_query in string.lower():\n            matching_strings.append(string)\n    return matching_strings if matching_strings else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = []\n    for s in seq:\n        if query_lower in s.lower():\n            matches.append(s)\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    results = [s for s in seq if query_lower in s.lower()]\n    return results if results else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found_strings = [s for s in seq if query_lower in s.lower()]\n    return found_strings if found_strings else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    matches = [word for word in seq if lower_query in word.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found = [s for s in seq if query_lower in s.lower()]\n    return found if found else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    results = [word for word in seq if lower_query in word.lower()]\n    return results if results else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    found = [s for s in seq if lower_query in s.lower()]\n    return found if found else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = [s for s in seq if query_lower in s.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found = [word for word in seq if query_lower in word.lower()]\n    return found if found else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = [s for s in seq if query_lower in s.lower()]\n    return matches if matches else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found = [s for s in seq if query_lower in s.lower()]\n    return found if found else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    matching_strings = []\n    for string in seq:\n        if lower_query in string.lower():\n            matching_strings.append(string)\n    if not matching_strings:\n        return ['None']\n    return matching_strings", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found = [s for s in seq if query_lower in s.lower()]\n    return found if found else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = [word for word in seq if query_lower in word.lower()]\n    if not matches:\n        return ['None']\n    return matches", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found = [s for s in seq if query_lower in s.lower()]\n    return found if found else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found = [s for s in seq if query_lower in s.lower()]\n    return found if found else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matches = []\n    for word in seq:\n        if query_lower in word.lower():\n            matches.append(word)\n    if not matches:\n        return ['None']\n    return matches", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    found = [s for s in seq if query_lower in s.lower()]\n    return found if found else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    query_lower = query.lower()\n    matched_strings = [s for s in seq if query_lower in s.lower()]\n    return matched_strings if matched_strings else ['None']", "from typing import List\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n    lower_query = query.lower()\n    matching_strings = [s for s in seq if lower_query in s.lower()]\n    if not matching_strings:\n        return ['None']\n    return matching_strings"], "requirement": [], "outputs": "[[['foo', 'foobar', 'barfoo', ' FoO ', 'FOOBAR', 'fOoBaZ']], [['Hello', 'hElLo', 'HELLO']], [['None']], [['None']], [['testing', 'Test', 'TeStInG', 'this is a TEST case']], [['A', 'aa', 'Aa', 'aA', 'ab', 'ac', 'ad', 'ae', 'af']], [['None']], [['queryispartofthisstringlongquerystring']], [['CASE', 'case', 'CaSe', 'CAse', 'cAsE', 'casexxx']], [['None']], [['nonempty', 'strings', 'here']], [['FindMe', 'FINDME', 'findme', 'hiddenfindmeinside']], [['None']], [['None']]]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[['foo', ['foo', 'bar', 'baz', 'foobar', 'barfoo', ' FoO ', 'FOOBAR', 'fOoBaZ']], ['hello', ['Hello', 'hElLo', 'WORLD', 'wOrld', 'HELLO']], ['apple', []], ['xyz', ['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu', 'vwx', 'yz']], ['test', ['testing', 'Test', 'TeStInG', 'this is a TEST case']], ['a', ['A', 'aa', 'Aa', 'aA', 'ab', 'ac', 'ad', 'ae', 'af']], ['a', ['b', 'c', 'd', 'e', 'f']], ['longquerystring', ['short', 'mediumsizedstring', 'averylongstringthatdoesnotmatch', 'queryispartofthisstringlongquerystring']], ['case', ['CASE', 'case', 'CaSe', 'CAse', 'cAsE', 'casexxx']], ['none', ['one', 'two', 'three', 'four', 'five']], ['', ['nonempty', 'strings', 'here']], ['findme', ['FindMe', 'FINDME', 'findme', 'hiddenfindmeinside', 'withspaces find me']], ['spaces', [' leadingSpace', 'trailingSpace ', 'middle space here', 'nospace']], ['multi word query', ['singleword', 'multi     word', 'queryinsidestring', 'somemultimultiwordsquery', 'MultiWordQuery']]]", "input_output_examples": "[[['me', ['home', 'milk', 'Mercury', 'fish']]], [[['home', 'Mercury']]]]", "at_least_one_align": false}, "entry_point": "word_search", "ground_truth": 0}
{"task_id": "TACO_lite/6", "requirement": "from typing import List\ndef calculate_grade(scores: List[int]) -> str:\n\"\"\"You're a statistics professor and the deadline for submitting your students' grades is tonight at midnight. Each student's grade is determined by their mean score across all of the tests they took this semester.\n\nYou've decided to automate grade calculation by writing a function `calculate_grade()` that takes a list of test scores as an argument and returns a one character string representing the student's grade calculated as follows:\n\n * 90% <= mean score <= 100%: `\"A\"`,\n * 80% <= mean score < 90%: `\"B\"`,\n * 70% <= mean score < 80%: `\"C\"`,\n * 60% <= mean score < 70%: `\"D\"`,\n * mean score < 60%: `\"F\"`\n\nYour function should handle an input list of any length greater than zero.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if mean_score >= 90:\n        return 'A'\n    elif mean_score >= 80:\n        return 'B'\n    elif mean_score >= 70:\n        return 'C'\n    elif mean_score >= 60:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if mean_score >= 90:\n        return 'A'\n    elif mean_score >= 80:\n        return 'B'\n    elif mean_score >= 70:\n        return 'C'\n    elif mean_score >= 60:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if mean_score >= 90:\n        return 'A'\n    elif mean_score >= 80:\n        return 'B'\n    elif mean_score >= 70:\n        return 'C'\n    elif mean_score >= 60:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if mean_score >= 90:\n        return 'A'\n    elif mean_score >= 80:\n        return 'B'\n    elif mean_score >= 70:\n        return 'C'\n    elif mean_score >= 60:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if mean_score >= 90:\n        return 'A'\n    elif mean_score >= 80:\n        return 'B'\n    elif mean_score >= 70:\n        return 'C'\n    elif mean_score >= 60:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "from typing import List\n\ndef calculate_grade(scores: List[int]) -> str:\n    mean_score = sum(scores) / len(scores)\n    if mean_score >= 90:\n        return 'A'\n    elif mean_score >= 80:\n        return 'B'\n    elif mean_score >= 70:\n        return 'C'\n    elif mean_score >= 60:\n        return 'D'\n    else:\n        return 'F'"], "requirement": [], "outputs": "[['A'], ['B'], ['C'], ['D'], ['F'], ['A'], ['B'], ['C'], ['D'], ['F'], ['A'], ['B'], ['C'], ['D'], ['F'], ['C'], ['B'], ['B'], ['F'], ['A'], ['ZeroDivisionError']]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[[95, 92, 98]], [[86, 83, 89, 87]], [[74, 78, 76, 72]], [[65, 68, 70]], [[50, 55, 59]], [[100, 90, 80, 95]], [[89, 88, 91, 87, 86]], [[75, 72, 68, 69, 71]], [[67, 66, 65, 64, 62]], [[45, 50, 55, 60]], [[93, 94, 95, 96, 97, 98]], [[82, 84, 86]], [[71, 69, 73]], [[62, 63, 64]], [[59]], [[89, 79, 69, 59]], [[60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]], [[80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90]], [[0]], [[100]], [[]]]", "input_output_examples": "[[[[92, 94, 99]], [[50, 60, 70, 80, 90]]], [['A'], ['C']]]", "at_least_one_align": false}, "entry_point": "calculate_grade", "ground_truth": 0}
{"task_id": "TACO_lite/7", "requirement": "def trump_detector(ts: str) -> float:\n\"\"\"We all love the future president (or Führer or duce or sōtō as he could find them more fitting) donald trump, but we might fear that some of his many fans like John Miller or John Barron are not making him justice, sounding too much like their (and our as well, of course!) hero and thus risking to compromise him.\n\nFor this reason we need to create a function to detect the original and unique rythm of our beloved leader, typically having a lot of extra vowels, all ready to fight the estabilishment.\n\nThe index is calculated based on how many vowels are repeated more than once in a row and dividing them by the total number of vowels a petty enemy of America would use.\n\n**Notes:** vowels are only the ones in the patriotic group of \"aeiou\": \"y\" should go back to Greece if she thinks she can have the same rights of true American vowels; there is always going to be at least a vowel, as silence is the option of coward Kenyan/terrorist presidents and their friends.\n\nRound each result by two decimal digits: there is no place for small fry in Trump's America.\n\n*Special thanks for [Izabela](https://www.codewars.com/users/ijelonek) for support and proof-reading.*\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    ts = ts.lower()\n    total_vowels = len([char for char in ts if char in 'aeiou'])\n    consecutive_vowel_groups = re.findall('([aeiou])\\\\1+', ts)\n    extra_vowels = sum((len(group) for group in consecutive_vowel_groups))\n    trump_index = round(extra_vowels / total_vowels, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    ts_lower = ts.lower()\n    total_vowels = len(re.findall('[aeiou]', ts_lower))\n    duplicate_vowel_groups = re.findall('(.)\\\\1+', ts_lower)\n    extra_vowels_count = sum((1 for group in duplicate_vowel_groups if group[0] in 'aeiou'))\n    trump_index = round(extra_vowels_count / total_vowels, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    ts = ts.lower()\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts)\n    num_repeated_vowels = len(repeated_vowels)\n    total_vowels = sum((1 for char in ts if char in vowels))\n    trump_index = round(num_repeated_vowels / total_vowels, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    ts = ts.lower()\n    vowels = 'aeiou'\n    total_vowels = sum((ts.count(vowel) for vowel in vowels))\n    consecutive_duplicates = re.findall('([aeiou])\\\\1+', ts)\n    extra_vowels = sum((len(dup) for dup in consecutive_duplicates))\n    trump_index = round(extra_vowels / total_vowels, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    vowels = 'aeiou'\n    ts_lower = ts.lower()\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts_lower)\n    extra_vowel_count = len(repeated_vowels)\n    total_vowel_count = sum((1 for char in ts_lower if char in vowels))\n    trumpiness_index = round(extra_vowel_count / total_vowel_count, 2)\n    return trumpiness_index"], "requirement": [], "outputs": "[[0.44], [0.5], [0.19], [0.0], [0.0], [0.25], [0.0], [0.03], [0.0], [0.0], [0.0], ['ZeroDivisionError'], [0.0], [0.25], [0.0], [0.21], [0.0], [0.0], [0.0]]", "probability": 0.1, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    vowels = 'aeiou'\n    total_vowels = sum((1 for char in ts.lower() if char in vowels))\n    repeated_vowels_count = len(re.findall('([aeiou])\\\\1+', ts.lower()))\n    try:\n        trumpiness_index = round(repeated_vowels_count / total_vowels, 2)\n    except ZeroDivisionError:\n        return 0.0\n    return trumpiness_index", "import re\nfrom math import ceil\n\ndef trump_detector(ts: str) -> float:\n    ts = ts.lower()\n    vowels = 'aeiou'\n    total_vowels = sum((1 for char in ts if char in vowels))\n    repeated_vowels = len(re.findall('([aeiou])\\\\1+', ts))\n    trump_index = round(repeated_vowels / total_vowels, 2) if total_vowels > 0 else 0.0\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('(?:([aeiou])\\\\1+)|([aeiou])', ts.lower())\n    extra_vowel_count = sum((1 for match in repeated_vowels if len(match[0]) > 0))\n    total_vowel_count = sum((1 for char in ts.lower() if char in vowels))\n    trump_index = round(extra_vowel_count / total_vowel_count, 2) if total_vowel_count > 0 else 0.0\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts = ts.lower()\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts)\n    extra_vowels = sum((len(match) for match in repeated_vowels))\n    total_vowels = len(re.findall('[aeiou]', ts))\n    if total_vowels == 0:\n        return 0.0\n    trump_index = round(extra_vowels / total_vowels, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    ts_lower = ts.lower()\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts_lower)\n    repeated_count = sum((len(match) for match in repeated_vowels))\n    total_vowels = len(re.findall('[aeiou]', ts_lower))\n    if total_vowels == 0:\n        return 0.0\n    trump_index = round(repeated_count / total_vowels, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    vowels = 'aeiou'\n    total_vowels = sum((1 for char in ts.lower() if char in vowels))\n    repeated_vowels_count = len(re.findall('([aeiou])\\\\1+', ts.lower()))\n    try:\n        trumpiness_index = round(repeated_vowels_count / total_vowels, 2)\n    except ZeroDivisionError:\n        return 0.0\n    return trumpiness_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts_lower = ts.lower()\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts_lower)\n    repeated_vowel_count = sum((1 for _ in repeated_vowels))\n    total_vowel_count = sum((1 for char in ts_lower if char in vowels))\n    trump_index = round(repeated_vowel_count / total_vowel_count * 100) / 100 if total_vowel_count > 0 else 0.0\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts.lower())\n    total_vowels = sum((1 for char in ts.lower() if char in vowels))\n    trump_index = len(repeated_vowels) / total_vowels if total_vowels > 0 else 0\n    return round(trump_index, 2)", "def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts = ts.lower()\n    matches = re.findall('([aeiou])\\\\1+', ts)\n    repeated_vowels_count = sum((len(match) for match in matches))\n    total_vowels_count = len(re.findall('[aeiou]', ts))\n    if total_vowels_count == 0:\n        return 0.0\n    trump_index = round(repeated_vowels_count / total_vowels_count, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    ts = ts.lower()\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts)\n    total_vowels = sum((1 for char in ts if char in vowels))\n    extra_vowels = len(repeated_vowels)\n    if total_vowels == 0:\n        return 0.0\n    trumpiness_index = round(extra_vowels / total_vowels, 2)\n    return trumpiness_index", "def trump_detector(ts: str) -> float:\n    import re\n    ts_lower = ts.lower()\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts_lower)\n    num_repeated_vowels = sum((len(match) for match in repeated_vowels))\n    total_vowels = len(re.findall('[aeiou]', ts_lower))\n    trump_index = round(num_repeated_vowels / total_vowels, 2) if total_vowels != 0 else 0.0\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts = ts.lower()\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts)\n    num_repeated_vowels = len(repeated_vowels)\n    total_vowels = sum((1 for char in ts if char in vowels))\n    if total_vowels == 0:\n        return 0.0\n    trump_index = num_repeated_vowels / total_vowels\n    trump_index_rounded = round(trump_index, 2)\n    return trump_index_rounded", "def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    ts = ts.lower()\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts)\n    repeated_count = sum((len(match) for match in repeated_vowels))\n    total_vowels = len(re.findall('[aeiou]', ts))\n    if total_vowels == 0:\n        return 0.0\n    trump_index = round(repeated_count / total_vowels, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    ts = ts.lower()\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts)\n    num_repeated_vowels = len(repeated_vowels)\n    total_vowels = sum((1 for char in ts if char in vowels))\n    if total_vowels == 0:\n        return 0.0\n    trumpiness_index = round(num_repeated_vowels / total_vowels, 2)\n    return trumpiness_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts = ts.lower()\n    repeated_vowels_pattern = '([aeiou])\\\\1+'\n    repeated_vowels = re.findall(repeated_vowels_pattern, ts)\n    num_repeated_vowels = len(repeated_vowels)\n    total_vowels = sum((1 for char in ts if char in 'aeiou'))\n    if total_vowels == 0:\n        return 0.0\n    trump_index = round(num_repeated_vowels / total_vowels * 100) / 100\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    vowels = 'aeiou'\n    consecutive_vowel_pattern = '([aeiou])\\\\1+'\n    ts_lower = ts.lower()\n    consecutive_vowels = re.findall(consecutive_vowel_pattern, ts_lower)\n    total_vowels = sum((1 for char in ts_lower if char in vowels))\n    repeated_vowels_count = len(consecutive_vowels)\n    if total_vowels == 0:\n        return 0.0\n    trump_index = round(repeated_vowels_count / total_vowels, 2)\n    return trump_index"], "requirement": [], "outputs": "[[0.44], [0.5], [0.19], [0.0], [0.0], [0.25], [0.0], [0.03], [0.0], [0.0], [0.0], [0.0], [0.0], [0.25], [0.0], [0.21], [0.0], [0.0], [0.0]]", "probability": 0.32, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts = ts.lower()\n    pattern = '([aeiou])\\\\1*'\n    matches = re.findall(pattern, ts)\n    repeated_vowels = sum((len(m) - 1 for m in re.findall(pattern, ts) if len(m) > 1))\n    total_vowels = sum((len(m) for m in matches))\n    trump_index = round(repeated_vowels / total_vowels * 100) / 100 if total_vowels > 0 else 0.0\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    ts = ts.lower()\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts)\n    count_repeated_vowels = sum((len(v) - 1 for v in repeated_vowels))\n    count_total_vowels = len(re.findall('[aeiou]', ts))\n    if count_total_vowels == 0:\n        return round(0.0, 2)\n    trumpiness_index = round(count_repeated_vowels / count_total_vowels, 2)\n    return trumpiness_index", "def trump_detector(ts: str) -> float:\n    import re\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts.lower())\n    num_repeated_vowels = sum((len(match) - 1 for match in repeated_vowels))\n    total_vowels = len(re.findall('[aeiou]', ts.lower()))\n    trump_index = round(num_repeated_vowels / total_vowels, 2) if total_vowels > 0 else 0.0\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    vowels = 'aeiou'\n    ts_lower = ts.lower()\n    consecutive_vowels = re.findall('([aeiou])\\\\1+', ts_lower)\n    extra_vowels_count = sum((len(match) - 1 for match in consecutive_vowels))\n    total_vowels_count = len(re.findall('[aeiou]', ts_lower))\n    trump_index = round(extra_vowels_count / total_vowels_count, 2) if total_vowels_count > 0 else 0.0\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    ts_lower = ts.lower()\n    vowels = 'aeiou'\n    total_vowels = sum((1 for char in ts_lower if char in vowels))\n    consecutive_vowel_pattern = '([aeiou])\\\\1+'\n    matches = re.findall(consecutive_vowel_pattern, ts_lower)\n    extra_vowels = sum((len(match) - 1 for match in matches))\n    trump_index = round(extra_vowels / total_vowels, 2) if total_vowels > 0 else 0.0\n    return trump_index", "import re\nfrom math import ceil\n\ndef trump_detector(ts: str) -> float:\n    ts_lower = ts.lower()\n    vowels = 'aeiou'\n    total_vowels = sum((ts_lower.count(vowel) for vowel in vowels))\n    consecutive_duplicates = re.findall('([aeiou])\\\\1+', ts_lower)\n    extra_vowels = sum((len(dup) - 1 for dup in consecutive_duplicates))\n    trump_index = extra_vowels / total_vowels if total_vowels > 0 else 0\n    return round(trump_index, 2)", "def trump_detector(ts: str) -> float:\n    import re\n    ts = ts.lower()\n    consecutive_vowels = re.findall('([aeiou])\\\\1+', ts)\n    extra_vowels_count = sum((len(vowel_group) - 1 for vowel_group in consecutive_vowels))\n    total_vowels_count = len(re.findall('[aeiou]', ts))\n    if total_vowels_count == 0:\n        return 0.0\n    trump_index = round(extra_vowels_count / total_vowels_count, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from collections import Counter\n    ts = ts.lower()\n    vowels = re.findall('[aeiou]', ts)\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts)\n    repeated_count = sum((len(match) - 1 for match in repeated_vowels))\n    total_vowels = len(vowels)\n    if total_vowels == 0:\n        return 0.0\n    trump_index = round(repeated_count / total_vowels, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    ts = ts.lower()\n    vowels = 'aeiou'\n    total_vowels = sum((1 for char in ts if char in vowels))\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts)\n    extra_vowels = sum((len(match) - 1 for match in repeated_vowels))\n    trumpiness_index = round(extra_vowels / total_vowels, 2) if total_vowels else 0.0\n    return trumpiness_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts = ts.lower()\n    vowels = 'aeiou'\n    total_vowels = sum((1 for char in ts if char in vowels))\n    consecutive_duplicates = re.findall('([aeiou])\\\\1+', ts)\n    extra_vowels = sum((len(dup) - 1 for dup in consecutive_duplicates))\n    trump_index = round(extra_vowels / total_vowels, 2) if total_vowels > 0 else 0.0\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    vowels = 'aeiou'\n    total_vowels = 0\n    extra_vowels = 0\n    ts_lower = ts.lower()\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts_lower)\n    for vowel in vowels:\n        total_vowels += ts_lower.count(vowel)\n    for match in repeated_vowels:\n        extra_vowels += len(match) - 1\n    if total_vowels == 0:\n        return 0.0\n    trump_index = round(extra_vowels / total_vowels, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts_lower = ts.lower()\n    vowels = 'aeiou'\n    total_vowels = 0\n    extra_vowels = 0\n    for vowel in vowels:\n        total_vowels += ts_lower.count(vowel)\n    matches = re.findall('(.)\\\\1+', ts_lower)\n    for match in matches:\n        if match[0] in vowels:\n            extra_vowels += len(match) - 1\n    if total_vowels == 0:\n        return 0.0\n    else:\n        trump_index = extra_vowels / total_vowels\n    return round(trump_index, 2)", "def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts = ts.lower()\n    vowels = 'aeiou'\n    total_vowels = 0\n    repeated_vowels = 0\n    pattern = '(.)\\\\1*'\n    for char in ts:\n        if char in vowels:\n            total_vowels += 1\n    matches = re.findall(pattern, ts)\n    for match in matches:\n        if len(match) > 1 and match[0] in vowels:\n            repeated_vowels += len(match) - 1\n    if total_vowels == 0:\n        return 0.0\n    trump_index = round(repeated_vowels / total_vowels, 2)\n    return trump_index"], "requirement": [], "outputs": "[[0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0]]", "probability": 0.26, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts = ts.lower()\n    repeated_vowels = re.findall('[aeiou]{2,}', ts)\n    extra_vowels_count = sum((len(vowel_group) - 1 for vowel_group in repeated_vowels))\n    total_vowels_count = len(re.findall('[aeiou]', ts))\n    trump_index = round(extra_vowels_count / total_vowels_count * 100) / 100 if total_vowels_count != 0 else 0\n    return trump_index"], "requirement": [], "outputs": "[[0.89], [0.5], [0.96], [0.0], [0.8], [0.94], [0.25], [0.97], [0.0], [0.0], [0.0], [0], [0.09], [0.98], [0.18], [0.79], [0.0], [0.0], [0.12]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    ts = ts.lower()\n    vowels = ''.join(re.findall('[aeiou]+', ts))\n    total_vowels = len(vowels)\n    repeated_vowels = sum((len(match.group(0)) - 1 for match in re.finditer('(.)\\\\1+', vowels)))\n    trump_index = round(repeated_vowels / total_vowels * 100, 2) if total_vowels != 0 else 0.0\n    return trump_index"], "requirement": [], "outputs": "[[55.56], [50.0], [80.77], [0.0], [0.0], [75.0], [0.0], [67.74], [25.0], [33.33], [0.0], [0.0], [18.18], [75.0], [18.18], [75.0], [0.0], [0.0], [0.0]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    vowels = 'aeiou'\n    ts_lower = ts.lower()\n    total_vowels = sum((1 for char in ts_lower if char in vowels))\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts_lower)\n    repeated_vowel_count = len(repeated_vowels)\n    if total_vowels == 0:\n        raise ValueError('Input string should contain at least one vowel.')\n    trump_index = round(repeated_vowel_count / total_vowels, 2)\n    return trump_index"], "requirement": [], "outputs": "[[0.44], [0.5], [0.19], [0.0], [0.0], [0.25], [0.0], [0.03], [0.0], [0.0], [0.0], ['ValueError'], [0.0], [0.25], [0.0], [0.21], [0.0], [0.0], [0.0]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    ts_lower = ts.lower()\n    total_vowels = len(re.findall('[aeiou]', ts_lower))\n    dup_vowels = re.findall('(aa+|ee+|ii+|oo+|uu+)', ts_lower)\n    extra_vowels_count = sum((len(match) - 1 for match in dup_vowels))\n    trump_index = round(extra_vowels_count / total_vowels, 2) if total_vowels > 0 else 0.0\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('([aeiou])\\\\1+', ts.lower())\n    repeated_vowel_count = sum((len(m.group(0)) - 1 for m in re.finditer('([aeiou])\\\\1+', ts.lower())))\n    total_vowel_count = len(re.findall('[aeiou]', ts.lower()))\n    if total_vowel_count == 0:\n        return 0.0\n    trump_index = round(repeated_vowel_count / total_vowel_count, 2)\n    return trump_index", "import re\nfrom math import ceil\n\ndef trump_detector(ts: str) -> float:\n    ts = re.sub('[^a-z]', '', ts.lower())\n    vowel_counts = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}\n    repeated_vowels_count = 0\n    total_vowel_count = 0\n    previous_char = ''\n    for char in ts:\n        if char in vowel_counts:\n            total_vowel_count += 1\n            if char == previous_char:\n                repeated_vowels_count += 1\n            vowel_counts[char] += 1\n        previous_char = char\n    if total_vowel_count == 0:\n        return 0.0\n    trump_index = round(repeated_vowels_count / total_vowel_count, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from collections import Counter\n    ts_lower = ts.lower()\n    vowels = 'aeiou'\n    repeated_vowels = re.findall('(a{2,}|e{2,}|i{2,}|o{2,}|u{2,})', ts_lower)\n    extra_vowels_count = sum((len(match) - 1 for match in repeated_vowels))\n    total_vowels_count = sum((ts_lower.count(vowel) for vowel in vowels))\n    if total_vowels_count == 0:\n        return 0.0\n    trump_index = round(extra_vowels_count / total_vowels_count, 2)\n    return trump_index", "def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    ts = ts.lower()\n    repeated_vowels = re.findall('(a{2,}|e{2,}|i{2,}|o{2,}|u{2,})', ts)\n    extra_vowels_count = sum((len(match) - 1 for match in repeated_vowels))\n    total_vowels_count = len(re.findall('[aeiou]', ts))\n    if total_vowels_count == 0:\n        return 0.0\n    trumpiness_index = extra_vowels_count / total_vowels_count\n    return float(f'{trumpiness_index:.2f}')"], "requirement": [], "outputs": "[[0.56], [0.5], [0.81], [0.0], [0.0], [0.75], [0.0], [0.68], [0.0], [0.0], [0.0], [0.0], [0.0], [0.75], [0.0], [0.71], [0.0], [0.0], [0.0]]", "probability": 0.1, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    ts = ts.lower()\n    total_vowels = sum((1 for char in ts if char in 'aeiou'))\n    consecutive_vowels = re.findall('(a{2,}|e{2,}|i{2,}|o{2,}|u{2,})', ts)\n    extra_vowel_count = sum((len(v) - 1 for v in consecutive_vowels))\n    trump_index = round(extra_vowel_count / total_vowels, 2)\n    return trump_index"], "requirement": [], "outputs": "[[0.56], [0.5], [0.81], [0.0], [0.0], [0.75], [0.0], [0.68], [0.0], [0.0], [0.0], ['ZeroDivisionError'], [0.0], [0.75], [0.0], [0.71], [0.0], [0.0], [0.0]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    ts_lower = ts.lower()\n    vowels = 'aeiou'\n    vowel_matches = [match.group() for match in re.finditer(f'[{vowels}]', ts_lower)]\n    total_vowels = len(vowel_matches)\n    repeated_vowel_pattern = f'([{vowels})]\\\\1+)'\n    repeated_vowel_matches = re.findall(repeated_vowel_pattern, ts_lower)\n    extra_vowels = sum((len(match) - 1 for match in repeated_vowel_matches))\n    try:\n        trump_index = round(extra_vowels / total_vowels, 2)\n    except ZeroDivisionError:\n        return 0.0\n    return trump_index"], "requirement": [], "outputs": "[['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error'], ['error']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    from math import ceil\n    ts = re.sub('[^a-z]', '', ts.lower())\n    total_vowels = sum((1 for char in ts if char in 'aeiou'))\n    consecutive_duplicates = re.findall('(.)\\\\1+', ts)\n    extra_vowels = sum((1 for dup in consecutive_duplicates if dup[0] in 'aeiou'))\n    trump_index = round(extra_vowels / total_vowels, 2)\n    return max(trump_index, 0.01)"], "requirement": [], "outputs": "[[0.44], [0.5], [0.19], [0.01], [0.01], [0.25], [0.01], [0.03], [0.01], [0.01], [0.01], ['ZeroDivisionError'], [0.01], [0.25], [0.01], [0.21], [0.01], [0.01], [0.01]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    from collections import Counter\n    import re\n    clean_ts = re.sub('[^a-z]', '', ts.lower())\n    vowels = 'aeiou'\n    vowel_str = ''.join([char for char in clean_ts if char in vowels])\n    repeated_vowels = 0\n    prev_char = None\n    for char in vowel_str:\n        if char == prev_char:\n            repeated_vowels += 1\n            prev_char = None\n        else:\n            prev_char = char\n    total_vowels = len(vowel_str)\n    if total_vowels <= 0:\n        return round(0.0, 2)\n    trumpiness_index = repeated_vowels / (total_vowels - repeated_vowels)\n    return round(trumpiness_index, 2)"], "requirement": [], "outputs": "[[0.8], [1.0], [0.73], [0.0], [0.0], [1.0], [0.0], [0.55], [0.33], [0.5], [0.0], [0.0], [0.22], [1.0], [0.1], [0.65], [0.0], [0.0], [0.0]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    vowels = 'aeiou'\n    ts = ts.lower()\n    matches = re.findall('([aeiou])\\\\1+', ts)\n    extra_vowels = sum((len(match) - 1 for match in matches))\n    total_vowels = len(re.findall('[aeiou]', ts))\n    trump_index = round(extra_vowels / total_vowels, 2)\n    return min(trump_index, 1.0)"], "requirement": [], "outputs": "[[0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], ['ZeroDivisionError'], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import re\nfrom math import ceil\n\ndef trump_detector(ts: str) -> float:\n    ts = re.sub('[^a-z]', '', ts.lower())\n    vowel_counts = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}\n    repeated_vowels = 0\n    total_vowels = 0\n    i = 0\n    while i < len(ts):\n        if ts[i] in vowel_counts:\n            total_vowels += 1\n            count = 1\n            while i + 1 < len(ts) and ts[i] == ts[i + 1]:\n                count += 1\n                i += 1\n            if count > 1:\n                repeated_vowels += count - 1\n        i += 1\n    if total_vowels == 0:\n        return 0.0\n    trump_index = round(repeated_vowels / total_vowels * 100) / 100\n    return trump_index"], "requirement": [], "outputs": "[[1.25], [1.0], [4.2], [0.0], [0.0], [3.0], [0.0], [2.1], [0.0], [0.0], [0.0], [0.0], [0.0], [3.0], [0.0], [2.5], [0.0], [0.0], [0.0]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def trump_detector(ts: str) -> float:\n    import re\n    from math import floor\n    vowels = 'aeiou'\n    ts_lower = ts.lower()\n    consecutive_vowels = re.findall('([aeiou])\\\\1+', ts_lower)\n    extra_vowels = sum((len(m.group(0)) - 1 for m in consecutive_vowels))\n    total_vowels = sum((1 for char in ts_lower if char in vowels))\n    if total_vowels == 0:\n        return 0.0\n    trump_index = extra_vowels / total_vowels\n    return round(trump_index, 2)"], "requirement": [], "outputs": "[['AttributeError'], ['AttributeError'], ['AttributeError'], [0.0], [0.0], ['AttributeError'], [0.0], ['AttributeError'], [0.0], [0.0], [0.0], [0.0], [0.0], ['AttributeError'], [0.0], ['AttributeError'], [0.0], [0.0], [0.0]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import re\n\ndef trump_detector(ts: str) -> float:\n    ts = ts.lower()\n    vowels = 'aeiou'\n    vowel_string = ''.join([char for char in ts if char in vowels])\n    matches = re.finditer('(.)\\\\1*', vowel_string)\n    extra_vowels = sum((len(m.group(0)) - 1 for m in matches if len(m.group(0)) > 1))\n    total_vowels = len(vowel_string)\n    if total_vowels == 0:\n        return 0.0\n    trump_index = round(extra_vowels / total_vowels, 2)\n    return trump_index"], "requirement": [], "outputs": "[[0.56], [0.5], [0.81], [0.0], [0.0], [0.75], [0.0], [0.68], [0.25], [0.33], [0.0], [0.0], [0.18], [0.75], [0.18], [0.75], [0.0], [0.0], [0.0]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 2.0360201988845965, "llm_generated_inputs": "[['aaeeiiuuu'], ['aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz'], ['aaaaaeeeeiiiiiooooouuuuuuu'], ['I am the chosen one'], ['Aeiou'], ['AAEEIIUuUUUUUUUU'], ['trumP is grEAt'], ['aeiouAEIOUuuUUUUUUuuuuuUUUUUuuU'], ['ThIs iS a TeSt'], ['hello world'], ['America first.'], ['yYyYyYyY'], ['The quick brown fox jumps over the lazy dog.'], ['AaaaEeeeIiiiOoooUuuuAaaaEeeeIiiiOoooUuuu'], ['Make America Great Again!'], ['Truuuuuuuuuumppppp uuunnniiqueeeee Voooiceeesss..!'], ['Donald Trump'], ['Vowels are important.'], ['One nation under God.']]", "input_output_examples": "[[['I will build a huge wall'], ['HUUUUUGEEEE WAAAAAALL'], ['listen migrants: IIII KIIIDD YOOOUUU NOOOOOOTTT']], [[0.0], [4.0], [1.56]]]", "at_least_one_align": false}, "entry_point": "trump_detector", "ground_truth": -1}
{"task_id": "TACO_lite/8", "requirement": "from typing import List\ndef likes(names: List[str]) -> str:\n\"\"\"You probably know the \"like\" system from Facebook and other pages. People can \"like\" blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.\n\nImplement a function `likes :: [String] -> String`, which must take in input array, containing the names of people who like an item. It must return the display text as shown in the examples:\n\nFor 4 or more names, the number in `and 2 others` simply increases.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef likes(names: List[str]) -> str:\n    length = len(names)\n    if length == 0:\n        return 'no one likes this'\n    elif length == 1:\n        return f'{names[0]} likes this'\n    elif length == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif length == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {length - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    match len(names):\n        case 0:\n            return 'no one likes this'\n        case 1:\n            return f'{names[0]} likes this'\n        case 2:\n            return f'{names[0]} and {names[1]} like this'\n        case 3:\n            return f'{names[0]}, {names[1]} and {names[2]} like this'\n        case _:\n            return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    match len(names):\n        case 0:\n            return 'no one likes this'\n        case 1:\n            return f'{names[0]} likes this'\n        case 2:\n            return f'{names[0]} and {names[1]} like this'\n        case 3:\n            return f'{names[0]}, {names[1]} and {names[2]} like this'\n        case _:\n            return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    length = len(names)\n    if length == 0:\n        return 'no one likes this'\n    elif length == 1:\n        return f'{names[0]} likes this'\n    elif length == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif length == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {length - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    count = len(names)\n    if count == 1:\n        return f'{names[0]} likes this'\n    elif count == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif count == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {count - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    match len(names):\n        case 0:\n            return 'no one likes this'\n        case 1:\n            return f'{names[0]} likes this'\n        case 2:\n            return f'{names[0]} and {names[1]} like this'\n        case 3:\n            return f'{names[0]}, {names[1]} and {names[2]} like this'\n        case _:\n            return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    length = len(names)\n    if length == 0:\n        return 'no one likes this'\n    elif length == 1:\n        return f'{names[0]} likes this'\n    elif length == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif length == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {length - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    length = len(names)\n    if length == 0:\n        return 'no one likes this'\n    elif length == 1:\n        return f'{names[0]} likes this'\n    elif length == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif length == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {length - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    count = len(names)\n    if count == 1:\n        return f'{names[0]} likes this'\n    elif count == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif count == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {count - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    if len(names) == 1:\n        return f'{names[0]} likes this'\n    if len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    if len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    return f'{names[0]}, {names[1]} and {len(names) - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    n = len(names)\n    if n == 1:\n        return f'{names[0]} likes this'\n    elif n == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif n == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        return f'{names[0]}, {names[1]} and {n - 2} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return f'{names[0]} likes this'\n    elif len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    elif len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    else:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'", "from typing import List\n\ndef likes(names: List[str]) -> str:\n    if not names:\n        return 'no one likes this'\n    if len(names) == 1:\n        return f'{names[0]} likes this'\n    if len(names) == 2:\n        return f'{names[0]} and {names[1]} like this'\n    if len(names) == 3:\n        return f'{names[0]}, {names[1]} and {names[2]} like this'\n    if len(names) > 3:\n        others = len(names) - 2\n        return f'{names[0]}, {names[1]} and {others} others like this'"], "requirement": [], "outputs": "[['no one likes this'], ['Peter likes this'], ['Jacob and Alex like this'], ['Max, John and Mark like this'], ['Alex, Jacob and 2 others like this'], ['Alice, Bob and 4 others like this'], ['John, Jane and 5 others like this'], ['John, Jane and None like this'], ['John, 123 and Jane like this'], ['John,  and Jane like this']]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[[]], [['Peter']], [['Jacob', 'Alex']], [['Max', 'John', 'Mark']], [['Alex', 'Jacob', 'Mark', 'Max']], [['Alice', 'Bob', 'Charlie', 'David', 'Erin', 'Frank']], [['John', 'Jane', 'Joe', 'Jill', 'Jack', 'Jenny', 'Jim']], [['John', 'Jane', None]], [['John', 123, 'Jane']], [['John', '', 'Jane']]]", "input_output_examples": "[[[[]], [['Peter']], [['Jacob', 'Alex']], [['Max', 'John', 'Mark']], [['Alex', 'Jacob', 'Mark', 'Max']]], [['no one likes this'], ['Peter likes this'], ['Jacob and Alex like this'], ['Max, John and Mark like this'], ['Alex, Jacob and 2 others like this']]]", "at_least_one_align": false}, "entry_point": "likes", "ground_truth": 0}
{"task_id": "TACO_lite/9", "requirement": "def solve(p: int) -> str:\n\"\"\"Consider the following well known rules:\n\n- A number is divisible by 3 if the sum of its digits is divisible by 3. Let's call '3' a \"1-sum\" prime\n- For 37, we take numbers in groups of threes from the right and check if the sum of these groups is divisible by 37. Let's call this a \"3-sum\" prime because we use groups of 3.\n- For 41, we take numbers in groups of fives from the right and check if the sum of these groups is divisible by 41. This is a \"5-sum\" prime.\n- Other primes exist that are \"7-sum\" primes (groups of 7), while some are \"99-sum\" primes (groups of 99).\n\nLet's look at another type of prime:\n- For 11, we need to add all digits by alternating their signs from the right. Let's call this a \"1-altsum\" prime\n- For 7, we need to group the digits into threes from the right and add all groups by alternating their signs. 7 is a \"3-altsum\" prime because we use groups of threes. 47 is a \"23-altsum\" (groups of 23), while 73 is a \"4-altsum\" prime (groups of 4).\n\n\nYou will be given a prime number `p` and your task is to find the smallest positive integer `n` such that `p’s` divisibility testing is `n-sum` or `n-altsum`.\n\nPrimes will not exceed `50,000,000`. \n\nYou can get some insight from [Fermat's little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem). \n\nGood luck!\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n\n    def is_n_sum_prime(n, p):\n        power = pow(10, n, p)\n        return (power - 1) % p == 0 or (power + 1) % p == 0\n\n    def is_n_altsum_prime(n, p):\n        power = pow(10, n, p)\n        return (power + 1) % p == 0\n\n    def find_smallest_n(p):\n        n = 1\n        while True:\n            if is_n_sum_prime(n, p):\n                return f'{n}-sum'\n            if is_n_altsum_prime(n, p):\n                return f'{n}-altsum'\n            n += 1\n    if p == 2 or p == 5:\n        return '1-sum'\n    return find_smallest_n(p)"], "requirement": [], "outputs": "[['1-sum'], ['3-sum'], ['1-sum'], ['3-sum'], ['5-sum'], ['23-sum'], ['4-sum'], ['1-sum'], ['1-sum'], ['3-sum'], ['8-sum'], ['9-sum'], ['11-sum'], ['14-sum'], ['15-sum'], ['21-sum'], ['22-sum'], ['48-sum'], ['2-sum'], ['16-sum'], ['83-sum'], ['2501-sum'], ['357-sum'], 'Timeout', 'Timeout', ['1-sum'], ['ValueError'], ['1-sum'], 'Timeout', ['437634-sum'], 'Timeout']", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import Tuple\n\ndef get_sum_or_altsum(p: int) -> Tuple[int, str]:\n    \"\"\"\n    Determines whether the prime number p is an n-sum or n-altsum prime,\n    and returns the smallest positive integer n for its divisibility test.\n    \"\"\"\n    if p == 2 or p == 5:\n        return (1, 'sum')\n    for n in range(1, 100):\n        if pow(10, n, p) == 1:\n            return (n, 'sum')\n        if pow(10, n, p + 1) == 1:\n            return (n, 'altsum')\n    return (None, '')\n\ndef solve(p: int) -> str:\n    n, kind = get_sum_or_altsum(p)\n    if n is None:\n        return f'No known {p}-sum or {p}-altsum pattern found.'\n    else:\n        return f'{p} is a {n}-{kind} prime.'"], "requirement": [], "outputs": "[['3 is a 1-sum prime.'], ['7 is a 6-sum prime.'], ['11 is a 2-sum prime.'], ['37 is a 3-sum prime.'], ['41 is a 5-sum prime.'], ['47 is a 46-sum prime.'], ['73 is a 8-sum prime.'], ['2 is a 1-sum prime.'], ['5 is a 1-sum prime.'], ['13 is a 6-sum prime.'], ['17 is a 16-sum prime.'], ['19 is a 18-sum prime.'], ['23 is a 22-sum prime.'], ['29 is a 28-sum prime.'], ['31 is a 15-sum prime.'], ['43 is a 21-sum prime.'], ['89 is a 44-sum prime.'], ['97 is a 96-sum prime.'], ['101 is a 4-sum prime.'], ['449 is a 32-sum prime.'], ['No known 997-sum or 997-altsum pattern found.'], ['No known 5003-sum or 5003-altsum pattern found.'], ['No known 4999-sum or 4999-altsum pattern found.'], ['No known 444444444444444444444444444444444444444444444444423-sum or 444444444444444444444444444444444444444444444444423-altsum pattern found.'], ['No known 4444444444444444444444444444444444444444444444444444444444444444444447-sum or 4444444444444444444444444444444444444444444444444444444444444444444447-altsum pattern found.'], ['No known -3-sum or -3-altsum pattern found.'], ['ValueError'], ['No known 1-sum or 1-altsum pattern found.'], ['No known 4-sum or 4-altsum pattern found.'], ['No known 50000001-sum or 50000001-altsum pattern found.'], ['No known 50000000-sum or 50000000-altsum pattern found.']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef smallest_n_for_prime(p: int) -> str:\n    \"\"\"\n    Determine the smallest positive integer n such that p's divisibility testing is n-sum or n-altsum.\n    \n    Args:\n    p (int): A prime number\n    \n    Returns:\n    str: The format \"n-sum\" or \"n-altsum\"\n    \"\"\"\n\n    def is_n_sum_prime(n, p):\n        power = 10 ** n % p\n        sum_of_powers = (power - 1) % p\n        return sum_of_powers == 0 and power != 1\n\n    def is_n_altsum_prime(n, p):\n        power = pow(10, n, p)\n        altsum = (1 - power) % p\n        return altsum == 0 and power != 1\n    for n in range(1, p + 1):\n        if is_n_sum_prime(n, p):\n            return f'{n}-sum'\n        if is_n_altsum_prime(n, p):\n            return f'{n}-altsum'\n    return 'Not Found'\n\ndef solve(p: int) -> str:\n    return smallest_n_for_prime(p)"], "requirement": [], "outputs": "[['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], ['Not Found'], 'Timeout', 'Timeout', ['Not Found'], ['Not Found'], ['1-sum'], ['Not Found'], 'Timeout', 'Timeout']", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import sympy\n\ndef solve(p: int) -> str:\n    \"\"\"\n    This function determines the smallest positive integer `n` such that \n    the prime number `p`'s divisibility test can be done using an `n-sum` \n    or `n-altsum` method.\n    \"\"\"\n\n    def find_n_sum_or_altsum(p):\n        if p == 3:\n            return '1-sum'\n        if p == 11:\n            return '1-altsum'\n        known_primes = {37: '3-sum', 41: '5-sum', 7: '3-altsum', 47: '23-altsum', 73: '4-altsum'}\n        if p in known_primes:\n            return known_primes[p]\n        for n in range(1, 100):\n            if sympy.isprime(p) and pow(10, n, p * 9) == 1:\n                return f'{n}-altsum'\n            if sympy.isprime(p) and pow(10, n, p * 99) == 1:\n                return f'{n}-sum'\n        return None\n    result = find_n_sum_or_altsum(p)\n    if result is None:\n        raise ValueError('The given prime does not match any known pattern')\n    return result"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['4-altsum'], ['ValueError'], ['ValueError'], ['6-altsum'], ['16-altsum'], ['18-altsum'], ['22-altsum'], ['28-altsum'], ['15-altsum'], ['21-altsum'], ['44-altsum'], ['96-altsum'], ['4-altsum'], ['32-altsum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    if p == 2 or p == 5:\n        return '1-sum'\n\n    def is_n_sum_prime(n, p):\n        \"\"\"Check if p is an n-sum prime.\"\"\"\n        return pow(10, n, p) == 1\n\n    def is_n_altsum_prime(n, p):\n        \"\"\"Check if p is an n-altsum prime.\"\"\"\n        return pow(10, n, p) == p - 1\n    for n in range(1, 100):\n        if is_n_sum_prime(n, p):\n            return f'{n}-sum'\n        if is_n_altsum_prime(n, p):\n            return f'{n}-altsum'\n    return 'No specific sum or altsum found'"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['4-altsum'], ['1-sum'], ['1-sum'], ['3-altsum'], ['8-altsum'], ['9-altsum'], ['11-altsum'], ['14-altsum'], ['15-sum'], ['21-sum'], ['22-altsum'], ['48-altsum'], ['2-altsum'], ['16-altsum'], ['83-altsum'], ['No specific sum or altsum found'], ['No specific sum or altsum found'], ['No specific sum or altsum found'], ['No specific sum or altsum found'], ['No specific sum or altsum found'], ['ValueError'], ['1-altsum'], ['No specific sum or altsum found'], ['No specific sum or altsum found'], ['No specific sum or altsum found']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef find_smallest_n(p: int) -> str:\n    if not isprime(p):\n        return 'Input must be a prime number'\n    for n in range(1, p + 1):\n        if check_sum_rule(p, n) or check_altsum_rule(p, n):\n            return f'{n}-sum' if check_sum_rule(p, n) else f'{n}-altsum'\n    return 'Not found'\n\ndef check_sum_rule(p: int, n: int) -> bool:\n    return pow(10, n, p) == 1\n\ndef check_altsum_rule(p: int, n: int) -> bool:\n    return (pow(10, n, p) + 1) % p == 0\n\ndef solve(p: int) -> str:\n    return find_smallest_n(p)"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['4-altsum'], ['Not found'], ['Not found'], ['3-altsum'], ['8-altsum'], ['9-altsum'], ['11-altsum'], ['14-altsum'], ['15-sum'], ['21-sum'], ['22-altsum'], ['48-altsum'], ['2-altsum'], ['16-altsum'], ['83-altsum'], ['2501-sum'], ['357-sum'], ['Input must be a prime number'], ['Input must be a prime number'], ['Input must be a prime number'], ['Input must be a prime number'], ['Input must be a prime number'], ['Input must be a prime number'], ['Input must be a prime number'], ['Input must be a prime number']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n\n    def is_n_sum_prime(n, p):\n        power = pow(10, n, p)\n        return (p - 1) % (n * (power - 1)) == 0 if power != 1 else p != 1\n\n    def is_n_altsum_prime(n, p):\n        power = pow(10, n, p * p)\n        return (p * (power + 1) - 1) % (p * p) == 0\n    if p == 2 or p == 5:\n        return '1-sum'\n    for n in range(1, 100):\n        if is_n_sum_prime(n, p):\n            return f'{n}-sum'\n        if is_n_altsum_prime(n, p):\n            return f'{n}-altsum'\n    return 'No simple divisibility rule found within the checked range.'"], "requirement": [], "outputs": "[['1-sum'], ['1-sum'], ['2-sum'], ['1-sum'], ['5-sum'], ['46-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['6-sum'], ['16-sum'], ['1-sum'], ['22-sum'], ['28-sum'], ['6-sum'], ['21-sum'], ['44-sum'], ['2-sum'], ['4-sum'], ['32-sum'], ['3-sum'], ['No simple divisibility rule found within the checked range.'], ['No simple divisibility rule found within the checked range.'], ['No simple divisibility rule found within the checked range.'], ['No simple divisibility rule found within the checked range.'], ['No simple divisibility rule found within the checked range.'], ['ValueError'], ['1-sum'], ['1-sum'], ['No simple divisibility rule found within the checked range.'], ['23-sum']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    \"\"\"Finds the smallest positive integer `n` such that `p’s` divisibility testing is `n-sum` or `n-altsum`.\"\"\"\n\n    def get_smallest_n_sum_prime(p):\n        if p == 3:\n            return 1\n        elif p == 37:\n            return 3\n        elif p == 41:\n            return 5\n        for n in range(1, 100):\n            if pow(10, n, p * 9) == 1:\n                return n\n        return None\n\n    def get_smallest_n_altsum_prime(p):\n        if p == 11:\n            return 1\n        elif p == 7:\n            return 3\n        for n in range(1, 24):\n            if pow(10, n, p * 11) == 1:\n                return n\n        return None\n    n = get_smallest_n_sum_prime(p)\n    if n is not None:\n        return f'{n}-sum'\n    n = get_smallest_n_altsum_prime(p)\n    if n is not None:\n        return f'{n}-altsum'\n    return 'Not found'"], "requirement": [], "outputs": "[['1-sum'], ['6-sum'], ['2-sum'], ['3-sum'], ['5-sum'], ['46-sum'], ['8-sum'], ['Not found'], ['Not found'], ['6-sum'], ['16-sum'], ['18-sum'], ['22-sum'], ['28-sum'], ['15-sum'], ['21-sum'], ['44-sum'], ['96-sum'], ['4-sum'], ['32-sum'], ['Not found'], ['Not found'], ['Not found'], ['Not found'], ['Not found'], ['Not found'], ['ValueError'], ['1-sum'], ['Not found'], ['Not found'], ['Not found']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p):\n        raise ValueError('Input must be a prime number.')\n\n    def check_n_sum_prime(n, p):\n        \"\"\"Check if p can be tested for divisibility using n-sum method.\"\"\"\n        power = 10 ** n\n        sum_of_groups = 0\n        temp = p\n        while temp > 0:\n            group = temp % power\n            sum_of_groups += group\n            temp //= power\n        return sum_of_groups % p == 0\n\n    def check_n_altsum_prime(n, p):\n        \"\"\"Check if p can be tested for divisibility using n-altsum method.\"\"\"\n        power = 10 ** n\n        alt_sum = 0\n        sign = 1\n        temp = p\n        while temp > 0:\n            group = temp % power\n            alt_sum += group * sign\n            sign *= -1\n            temp //= power\n        return abs(alt_sum) % p == 0\n    if p == 3 and check_n_sum_prime(1, p):\n        return '1-sum'\n    for n in range(1, 100):\n        if check_n_sum_prime(n, p):\n            return f'{n}-sum'\n        if check_n_altsum_prime(n, p):\n            return f'{n}-altsum'\n    raise ValueError(f'No valid n found for p={p} within checked range.')"], "requirement": [], "outputs": "[['1-sum'], ['1-sum'], ['1-altsum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['1-sum'], ['1-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-altsum'], ['3-sum'], ['3-sum'], ['4-sum'], ['4-sum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_smallest_n_sum(p):\n        n = 1\n        while True:\n            if pow(10, n, p) == 1:\n                return f'{n}-sum'\n            n += 1\n\n    def find_smallest_n_altsum(p):\n        n = 1\n        while True:\n            if pow(10, n, p) == p - 1:\n                return f'{n}-altsum'\n            n += 1\n    if not is_prime(p):\n        raise ValueError('Input must be a prime number.')\n    result = find_smallest_n_sum(p)\n    if 'sum' in result:\n        return result\n    return find_smallest_n_altsum(p)"], "requirement": [], "outputs": "[['1-sum'], ['6-sum'], ['2-sum'], ['3-sum'], ['5-sum'], ['46-sum'], ['8-sum'], 'Timeout', 'Timeout', ['6-sum'], ['16-sum'], ['18-sum'], ['22-sum'], ['28-sum'], ['15-sum'], ['21-sum'], ['44-sum'], ['96-sum'], ['4-sum'], ['32-sum'], ['166-sum'], ['2501-sum'], ['357-sum'], ['ValueError'], 'Timeout', ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p):\n        raise ValueError('Input must be a prime number')\n\n    def find_sum_type(p):\n        for n in range(1, 100):\n            if all((sum((int(digit) for digit in str(i).zfill(n))) % p == 0 for i in range(0, 10 ** n, p))):\n                return f'{n}-sum'\n        return None\n\n    def find_altsum_type(p):\n        for n in range(1, 100):\n            if all((sum(((-1) ** i * int(str(num).zfill(n)[i * n:(i + 1) * n]) for i in range((n - 1 + len(str(num))) // n))) % p == 0 for num in range(0, 10 ** n, p))):\n                return f'{n}-altsum'\n        return None\n    sum_type = find_sum_type(p)\n    if sum_type:\n        return sum_type\n    altsum_type = find_altsum_type(p)\n    if altsum_type:\n        return altsum_type\n    raise Exception(f'No n-sum or n-altsum divisibility test found for {p}')"], "requirement": [], "outputs": "[['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def solve(p: int) -> str:\n    from math import gcd\n\n    def is_altsum_prime(p, n):\n        power = 10 ** n\n        alt_sum = 0\n        multiplier = 1\n        temp_p = p\n        while temp_p > 0:\n            group = temp_p % power\n            alt_sum += group * multiplier\n            multiplier *= -1\n            temp_p //= power\n        return alt_sum % p == 0\n\n    def is_sum_prime(p, n):\n        power = 10 ** n\n        total_sum = 0\n        temp_p = p\n        while temp_p > 0:\n            group = temp_p % power\n            total_sum += group\n            temp_p //= power\n        return total_sum % p == 0\n    if p < 2:\n        return 'Invalid prime number'\n    for n in range(1, 99 + 1):\n        if is_altsum_prime(p, n):\n            return f'{n}-altsum'\n        if is_sum_prime(p, n):\n            return f'{n}-sum'\n    return 'No solution found within the given constraints'"], "requirement": [], "outputs": "[['1-altsum'], ['1-altsum'], ['1-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['1-altsum'], ['1-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['3-altsum'], ['3-altsum'], ['4-altsum'], ['4-altsum'], ['51-altsum'], ['70-altsum'], ['Invalid prime number'], ['Invalid prime number'], ['Invalid prime number'], ['1-altsum'], ['8-altsum'], ['8-altsum']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Determines the smallest positive integer n such that the prime number p's \n    divisibility testing is n-sum or n-altsum.\n    \"\"\"\n    if not isprime(p):\n        raise ValueError('Input must be a prime number.')\n\n    def check_n_sum(n: int, rule_type: str='sum') -> bool:\n        \"\"\"\n        Checks if there exists an n for which p can be tested for divisibility \n        using n-sum or n-altsum rules.\n        \"\"\"\n        if rule_type == 'altsum':\n            test_value = sum(((-1) ** i * int(str(p)[::-1][i:i + n][::-1]) if str(p)[::-1][i:i + n] else 0 for i in range(0, len(str(p)), n)))\n        else:\n            test_value = sum((int(str(p)[i:i + n]) if str(p)[i:i + n] else 0 for i in range(0, len(str(p)), n)))\n        return test_value % p == 0\n    known_rules = {3: (1, 'sum'), 11: (1, 'altsum'), 37: (3, 'sum'), 41: (5, 'sum'), 7: (3, 'altsum'), 47: (23, 'altsum'), 73: (4, 'altsum')}\n    if p in known_rules:\n        n, rule_type = known_rules[p]\n        return f'{n}-{rule_type}'\n    for n in range(1, p):\n        if check_n_sum(n, 'sum'):\n            return f'{n}-sum'\n        if check_n_sum(n, 'altsum'):\n            return f'{n}-altsum'\n    return 'No solution found.'"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['4-altsum'], ['1-sum'], ['1-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['4-sum'], ['4-sum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    if not is_prime(p):\n        return 'Input number is not a prime.'\n    if p == 2 or p == 5:\n        return '1-sum'\n    for n in range(1, 100):\n        found = False\n        if pow(10, n, p) == 1:\n            if (10 ** n - 1) % p == 0:\n                return f'{n}-sum'\n            else:\n                continue\n        for alt_n in range(1, 100):\n            if pow(11, alt_n, p) == 1 and (11 ** alt_n - 1) % p == 0:\n                found = True\n                return f'{alt_n}-altsum'\n        if found:\n            break\n    return 'Not found'"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['2-sum'], ['6-altsum'], ['40-altsum'], ['46-altsum'], ['72-altsum'], ['1-sum'], ['1-sum'], ['12-altsum'], ['16-altsum'], ['3-altsum'], ['22-altsum'], ['28-altsum'], ['30-altsum'], ['7-altsum'], ['22-altsum'], ['48-altsum'], ['4-sum'], ['56-altsum'], ['Not found'], ['Not found'], ['Not found'], ['Input number is not a prime.'], 'Timeout', ['Input number is not a prime.'], ['Input number is not a prime.'], ['Input number is not a prime.'], ['Input number is not a prime.'], ['Input number is not a prime.'], ['Input number is not a prime.']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p) or p <= 1:\n        raise ValueError('Input must be a prime number greater than 1')\n\n    def n_sum_test(n, p):\n        for i in range(1, 10 ** (n + 1)):\n            s = sum((int(str(i)[j:j + n]) for j in range(0, len(str(i)), n)))\n            if s % p == 0 and i % p == 0:\n                return True\n        return False\n\n    def n_altsum_test(n, p):\n        for i in range(1, 10 ** (n + 1)):\n            altsum = sum(((-1) ** (j // n) * int(str(i)[j:j + n]) for j in range(0, len(str(i)), n)))\n            if altsum % p == 0 and i % p == 0:\n                return True\n        return False\n    for n in range(1, 100):\n        if n_sum_test(n, p):\n            return f'{p} is an {n}-sum prime'\n        if n_altsum_test(n, p):\n            return f'{p} is an {n}-altsum prime'\n    return 'No suitable n found'"], "requirement": [], "outputs": "[['3 is an 1-sum prime'], ['7 is an 1-sum prime'], ['11 is an 1-altsum prime'], ['37 is an 2-sum prime'], ['41 is an 2-sum prime'], ['47 is an 2-sum prime'], ['73 is an 2-sum prime'], ['2 is an 1-sum prime'], ['5 is an 1-sum prime'], ['13 is an 2-sum prime'], ['17 is an 2-sum prime'], ['19 is an 2-sum prime'], ['23 is an 2-sum prime'], ['29 is an 2-sum prime'], ['31 is an 2-sum prime'], ['43 is an 2-sum prime'], ['89 is an 2-sum prime'], ['97 is an 2-sum prime'], ['101 is an 3-sum prime'], ['449 is an 3-sum prime'], ['997 is an 3-sum prime'], ['5003 is an 4-sum prime'], ['4999 is an 4-sum prime'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Determine the smallest positive integer n such that p's divisibility testing is n-sum or n-altsum.\n    \"\"\"\n\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    if not is_prime(p):\n        raise ValueError(f'The provided number {p} is not a prime.')\n    if p == 3:\n        return '1-sum'\n    if p == 11:\n        return '1-altsum'\n    for n in range(1, 100):\n        if pow(10, n, p * 9) == 1:\n            return f'{n}-sum'\n        if sum([(-1) ** i * (10 ** (n * i) % p) for i in range(n)]) % p == 0:\n            return f'{n}-altsum'\n    raise Exception('No valid n found within the specified bounds.')"], "requirement": [], "outputs": "[['1-sum'], ['6-sum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['46-sum'], ['8-sum'], ['Exception'], ['Exception'], ['6-sum'], ['4-altsum'], ['3-altsum'], ['22-sum'], ['28-sum'], ['15-sum'], ['21-sum'], ['44-sum'], ['24-altsum'], ['4-sum'], ['8-altsum'], ['Exception'], ['Exception'], ['Exception'], ['ValueError'], 'Timeout', ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n\n    def altsum_test(n, prime, group_size):\n        s = 0\n        sign = 1\n        num_str = str(n)[::-1]\n        for i in range(0, len(num_str), group_size):\n            group = num_str[i:i + group_size][::-1]\n            s += sign * int(group or '0')\n            sign *= -1\n        return s % prime == 0\n\n    def sum_test(n, prime, group_size):\n        s = sum((int(str(n)[i:i + group_size]) for i in range(0, len(str(n)), group_size)))\n        return s % prime == 0\n    for n in range(1, 100):\n        if all((sum_test(i * p, p, n) for i in range(1, 20))):\n            return f'{p} is a {n}-sum prime'\n    for n in range(1, 100):\n        if all((altsum_test(i * p, p, n) for i in range(1, 20))):\n            return f'{p} is a {n}-altsum prime'\n    return f'Could not find n for {p} within the tested limits'"], "requirement": [], "outputs": "[['3 is a 1-sum prime'], ['7 is a 3-sum prime'], ['11 is a 3-sum prime'], ['37 is a 3-sum prime'], ['41 is a 3-sum prime'], ['47 is a 3-sum prime'], ['73 is a 4-sum prime'], ['2 is a 2-sum prime'], ['5 is a 2-sum prime'], ['13 is a 3-sum prime'], ['17 is a 3-sum prime'], ['19 is a 3-sum prime'], ['23 is a 3-sum prime'], ['29 is a 3-sum prime'], ['31 is a 3-sum prime'], ['43 is a 3-sum prime'], ['89 is a 4-sum prime'], ['97 is a 4-sum prime'], ['101 is a 4-sum prime'], ['449 is a 4-sum prime'], ['997 is a 5-sum prime'], ['5003 is a 5-sum prime'], ['4999 is a 5-sum prime'], ['444444444444444444444444444444444444444444444444423 is a 52-sum prime'], ['4444444444444444444444444444444444444444444444444444444444444444444447 is a 71-sum prime'], ['ValueError'], ['ZeroDivisionError'], ['1 is a 1-sum prime'], ['4 is a 2-sum prime'], ['50000001 is a 9-sum prime'], ['50000000 is a 9-sum prime']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p):\n        raise ValueError('Input must be a prime number')\n\n    def sum_groups(n, group_size):\n        return sum((int(str(n)[i:i + group_size]) if i <= len(str(n)) - group_size else int(str(n)[i:]) for i in range(0, len(str(n)), group_size)))\n\n    def altsum_groups(n, group_size):\n        return sum(((-1) ** i * (int(str(n)[i:i + group_size]) if i <= len(str(n)) - group_size else int(str(n)[i:])) for i in range(0, len(str(n)), group_size)))\n    for n in range(1, 100):\n        if all((sum_groups(x, n) % p == x % p for x in range(1, 1000))):\n            return f'{n}-sum'\n        if all((altsum_groups(x, n) % p == x % p for x in range(1, 1000))):\n            return f'{n}-altsum'\n    raise Exception('Could not find suitable n within tested bounds')"], "requirement": [], "outputs": "[['1-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    \"\"\"Finds the smallest positive integer `n` such that `p`'s divisibility testing is `n-sum` or `n-altsum`.\n    \n    Args:\n        p (int): The prime number to check.\n\n    Returns:\n        str: A string representing the `n-sum` or `n-altsum` rule for the prime `p`.\n    \"\"\"\n\n    def find_smallest_n_sum_prime():\n        n = 1\n        while True:\n            if pow(10, n, p) == 1:\n                return f'{n}-sum'\n            n += 1\n\n    def find_smallest_n_altsum_prime():\n        n = 1\n        while True:\n            if pow(10, 2 * n, p) == 1 and pow(10, n, p) == p - 1:\n                return f'{n}-altsum'\n            n += 1\n    if p in [2, 5]:\n        return '1-sum'\n    altsum_result = find_smallest_n_altsum_prime()\n    if altsum_result:\n        return altsum_result\n    return find_smallest_n_sum_prime()"], "requirement": [], "outputs": "['Timeout', ['3-altsum'], ['1-altsum'], 'Timeout', 'Timeout', ['23-altsum'], ['4-altsum'], ['1-sum'], ['1-sum'], ['3-altsum'], ['8-altsum'], ['9-altsum'], ['11-altsum'], ['14-altsum'], 'Timeout', 'Timeout', ['22-altsum'], ['48-altsum'], ['2-altsum'], ['16-altsum'], ['83-altsum'], 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', ['ValueError'], 'Timeout', 'Timeout', 'Timeout', 'Timeout']", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n\n    def altsum_divisibility_checker(prime, group_size):\n\n        def check(n):\n            s = str(n)[::-1]\n            groups = [s[i:i + group_size] for i in range(0, len(s), group_size)]\n            alt_sum = sum((int(g, 10) if i % 2 == 0 else -int(g, 10) for i, g in enumerate(groups)))\n            return alt_sum % prime == 0\n        return check\n\n    def sum_divisibility_checker(prime, group_size):\n\n        def check(n):\n            s = str(n)[::-1]\n            groups = [s[i:i + group_size] for i in range(0, len(s), group_size)]\n            total_sum = sum((int(g, 10) for g in groups))\n            return total_sum % prime == 0\n        return check\n    if not isprime(p):\n        raise ValueError('p must be a prime number')\n    for n in range(1, p):\n        checker_sum = sum_divisibility_checker(p, n)\n        checker_altsum = altsum_divisibility_checker(p, n)\n        if all((checker_sum(i * p) for i in range(1, 10))):\n            return f'{n}-sum'\n        if all((checker_altsum(i * p) for i in range(1, 10))):\n            return f'{n}-altsum'\n    return 'No valid n found'"], "requirement": [], "outputs": "[['1-sum'], ['No valid n found'], ['1-altsum'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['3-sum'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['No valid n found'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p):\n        raise ValueError(f'{p} is not a prime number.')\n    if p == 3:\n        return '1-sum'\n\n    def check_n_sum(n, prime):\n\n        def sum_in_groups(x, group_size):\n            s = str(x)\n            return sum((int(s[i:i + group_size]) for i in range(0, len(s), group_size)))\n        for k in range(1, 100):\n            if sum_in_groups(prime * k, n) % prime == 0:\n                return True\n        return False\n\n    def check_n_altsum(n, prime):\n\n        def altsum_in_groups(x, group_size):\n            s = str(x)[::-1]\n            result = 0\n            sign = 1\n            for i in range(0, len(s), group_size):\n                result += sign * int(s[i:i + group_size][::-1] or '0')\n                sign *= -1\n            return result\n        for k in range(1, 100):\n            if altsum_in_groups(prime * k, n) % prime == 0:\n                return True\n        return False\n    specific_cases = {7: '3-altsum', 11: '1-altsum', 37: '3-sum', 41: '5-sum', 47: '23-altsum', 73: '4-altsum'}\n    if p in specific_cases:\n        return specific_cases[p]\n    n = 1\n    while True:\n        if check_n_sum(n, p):\n            return f'{n}-sum'\n        if check_n_altsum(n, p):\n            return f'{n}-altsum'\n        n += 1"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['4-altsum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['3-sum'], ['1-altsum'], ['1-altsum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p):\n        raise ValueError('Input must be a prime number')\n\n    def find_n_sum_or_altsum(prime: int) -> str:\n        if prime == 3:\n            return '1-sum'\n        if prime == 11:\n            return '1-altsum'\n        for n in range(2, 100):\n            if str(prime).endswith('7') and n % 2 == 0:\n                continue\n            test_value = sum((int(str(prime)[i:i + n]) for i in range(0, len(str(prime)), n)))\n            if test_value % prime == 0:\n                return f'{n}-sum'\n            alt_test_value = sum(((1 if i % 2 == 0 else -1) * int(str(prime)[i:i + n]) for i in range(0, len(str(prime)), n)))\n            if alt_test_value % prime == 0:\n                return f'{n}-altsum'\n        return 'Unknown pattern'\n    return find_n_sum_or_altsum(p)"], "requirement": [], "outputs": "[['1-sum'], ['3-sum'], ['1-altsum'], ['3-sum'], ['2-sum'], ['3-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['3-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['4-sum'], ['4-sum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef find_smallest_n(p: int) -> str:\n\n    def altsum(divisor, n):\n        num_str = str(n)\n        groups = [int(num_str[i:i + divisor]) for i in range(0, len(num_str), divisor)]\n        alt_sum = sum(((-1) ** i * groups[i] for i in range(len(groups))))\n        return n if alt_sum % p == 0 else None\n\n    def normal_sum(divisor, n):\n        num_str = str(n).zfill(divisor)\n        group_sum = sum((int(num_str[i:i + divisor]) for i in range(0, len(num_str), divisor)))\n        return n if group_sum % p == 0 else None\n    if p == 2 or p == 5:\n        return '1-sum'\n    if any((altsum(1, n) for n in range(1, p * 10))):\n        return '1-altsum'\n    for divisor in range(1, 100):\n        found = False\n        for kind in ('altsum', 'normal_sum'):\n            check_function = locals()[kind]\n            if any((check_function(divisor, n) for n in range(1, p * 10))):\n                found = True\n                break\n        if found:\n            return f'{divisor}-{kind.split('sum')[0]}sum'\n    return 'Not Found'\n\ndef solve(p: int) -> str:\n    result = find_smallest_n(p)\n    return result"], "requirement": [], "outputs": "[['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-sum'], ['1-sum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['Not Found'], ['Not Found'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Given a prime number p, this function finds the smallest positive integer n \n    such that p’s divisibility testing is n-sum or n-altsum.\n    \"\"\"\n\n    def is_sum_type_prime(p):\n        for n in range(1, 100):\n            rep_unit = int('1' * n)\n            if rep_unit % p == 0:\n                return f'{n}-sum'\n        return None\n\n    def is_altsum_type_prime(p):\n        for n in range(1, 100):\n            alternating_sum = sum(((-1) ** i * int(digit) for i, digit in enumerate(f'{(10 ** n - 1) // 9:0{n}d}')))\n            if alternating_sum % p == 0:\n                return f'{n}-altsum'\n        return None\n    result = is_sum_type_prime(p)\n    if result:\n        return result\n    result = is_altsum_type_prime(p)\n    if result:\n        return result\n    return 'Unknown'"], "requirement": [], "outputs": "[['3-sum'], ['6-sum'], ['2-sum'], ['3-sum'], ['5-sum'], ['46-sum'], ['8-sum'], ['2-altsum'], ['2-altsum'], ['6-sum'], ['16-sum'], ['18-sum'], ['22-sum'], ['28-sum'], ['15-sum'], ['21-sum'], ['44-sum'], ['96-sum'], ['4-sum'], ['32-sum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['3-sum'], ['ZeroDivisionError'], ['1-sum'], ['2-altsum'], ['2-altsum'], ['2-altsum']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Finds the smallest positive integer n such that p's divisibility testing is n-sum or n-altsum.\n    \"\"\"\n\n    def find_sum_divisibility(p):\n        n = 1\n        while True:\n            test_num = int('1' * n)\n            if gcd(test_num, p) > 1:\n                return f'{n}-sum'\n            n += 1\n\n    def find_altsum_divisibility(p):\n        n = 1\n        while True:\n            if pow(10, n, p) == p - 1:\n                return f'{n}-altsum'\n            n += 1\n    if p == 2 or p == 5:\n        return '1-sum'\n    special_cases = {3: '1-sum', 11: '1-altsum', 37: '3-sum', 41: '5-sum', 7: '3-altsum', 47: '23-altsum', 73: '4-altsum'}\n    if p in special_cases:\n        return special_cases[p]\n    result = find_sum_divisibility(p)\n    if result:\n        return result\n    return find_altsum_divisibility(p)"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['4-altsum'], ['1-sum'], ['1-sum'], ['6-sum'], ['16-sum'], ['18-sum'], ['22-sum'], ['28-sum'], ['15-sum'], ['21-sum'], ['44-sum'], ['96-sum'], ['4-sum'], ['32-sum'], ['166-sum'], ['2501-sum'], ['357-sum'], ['3-sum'], 'Timeout', ['3-sum'], ['2-sum'], 'Timeout', 'Timeout', ['3-sum'], 'Timeout']", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p):\n        raise ValueError('Input must be a prime number.')\n\n    def check_n_sum(p, n):\n\n        def sum_groups(x, n):\n            return sum((int(x[i:i + n]) for i in range(0, len(x), n)))\n        for num in range(1, 10 ** 6):\n            str_num = f'{num:0>{n}}'\n            if sum_groups(str_num, n) % p == 0:\n                if num % p == 0:\n                    return True\n        return False\n\n    def check_n_altsum(p, n):\n\n        def altsum_groups(x, n):\n            total = 0\n            sign = 1\n            for i in range(len(x), 0, -n):\n                start = max(i - n, 0)\n                total += sign * int(x[start:i])\n                sign *= -1\n            return total\n        for num in range(1, 10 ** 6):\n            str_num = f'{num:0>{n}}'\n            if altsum_groups(str_num, n) % p == 0:\n                if num % p == 0:\n                    return True\n        return False\n    for n in range(1, 100):\n        if check_n_sum(p, n):\n            return f'{p} is an {n}-sum prime'\n        if check_n_altsum(p, n):\n            return f'{p} is an {n}-altsum prime'\n    return 'No solution found within the tested range'"], "requirement": [], "outputs": "[['3 is an 1-sum prime'], ['7 is an 1-sum prime'], ['11 is an 1-sum prime'], ['37 is an 1-sum prime'], ['41 is an 1-sum prime'], ['47 is an 1-sum prime'], ['73 is an 1-altsum prime'], ['2 is an 1-sum prime'], ['5 is an 1-sum prime'], ['13 is an 1-sum prime'], ['17 is an 1-sum prime'], ['19 is an 1-sum prime'], ['23 is an 1-sum prime'], ['29 is an 1-sum prime'], ['31 is an 1-sum prime'], ['43 is an 1-sum prime'], ['89 is an 1-altsum prime'], ['97 is an 1-altsum prime'], ['101 is an 1-altsum prime'], ['449 is an 1-altsum prime'], 'Timeout', 'Timeout', 'Timeout', ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p):\n        raise ValueError('Input must be a prime number.')\n\n    def find_n_sum_prime(p):\n        for n in range(1, 100):\n            groups = [10 ** (n * i) % p for i in range(1, 20)]\n            if all((g % p == 1 for g in groups)):\n                return f'{n}-sum'\n            if sum(groups) % p == 0:\n                return f'{n}-sum'\n        return None\n\n    def find_n_altsum_prime(p):\n        for n in range(1, 100):\n            groups = [(-1) ** i * (10 ** (n * i) % p) for i in range(1, 20)]\n            if sum(groups) % p == 0:\n                return f'{n}-altsum'\n        return None\n    result = find_n_sum_prime(p)\n    if result:\n        return result\n    result = find_n_altsum_prime(p)\n    if result:\n        return result\n    return 'Unknown'"], "requirement": [], "outputs": "[['1-sum'], ['6-sum'], ['2-sum'], ['3-sum'], ['5-sum'], ['46-sum'], ['8-sum'], ['1-sum'], ['1-sum'], ['6-sum'], ['16-sum'], ['18-sum'], ['22-sum'], ['28-sum'], ['15-sum'], ['21-sum'], ['44-sum'], ['96-sum'], ['4-sum'], ['32-sum'], ['Unknown'], ['Unknown'], ['Unknown'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    if p == 2 or p == 5:\n        return '1-sum'\n\n    def find_smallest_n_sum_prime(p):\n        if p == 3:\n            return '1-sum'\n        for n in [3, 5, 7, 99]:\n            if check_n_sum_divisibility(p, n):\n                return f'{n}-sum'\n        return None\n\n    def find_smallest_n_altsum_prime(p):\n        if p == 11:\n            return '1-altsum'\n        for n in [3, 4, 23]:\n            if check_n_altsum_divisibility(p, n):\n                return f'{n}-altsum'\n        return None\n\n    def check_n_sum_divisibility(p, n):\n        \"\"\"Check if p can be tested for divisibility using groups of n.\"\"\"\n        return False\n\n    def check_n_altsum_divisibility(p, n):\n        \"\"\"Check if p can be tested for divisibility using alternating sums of groups of n.\"\"\"\n        return False\n    result = find_smallest_n_sum_prime(p)\n    if result:\n        return result\n    result = find_smallest_n_altsum_prime(p)\n    if result:\n        return result\n    return 'No known divisibility rule found'"], "requirement": [], "outputs": "[['1-sum'], ['No known divisibility rule found'], ['1-altsum'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['1-sum'], ['1-sum'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found'], ['No known divisibility rule found']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    \"\"\"Finds the smallest positive integer `n` such that `p’s` divisibility testing is `n-sum` or `n-altsum`.\"\"\"\n\n    def find_n_sum(p):\n        if p == 3:\n            return '1-sum'\n        elif p == 37:\n            return '3-sum'\n        elif p == 41:\n            return '5-sum'\n        for n in [7, 99]:\n            if all((sum((int(str(i).zfill(n)[k:k + n]) for k in range(0, len(str(i)), n))) % p == 0 for i in range(1, 1000))):\n                return f'{n}-sum'\n        return None\n\n    def find_n_altsum(p):\n        if p == 11:\n            return '1-altsum'\n        elif p == 7:\n            return '3-altsum'\n        for n in [4, 23]:\n            if all((sum(((-1) ** (i // n) * int(str(num)[i:i + n]) for i in range(0, len(str(num)), n))) % p == 0 for num in range(1, 1000))):\n                return f'{n}-altsum'\n        return None\n    n_sum_result = find_n_sum(p)\n    if n_sum_result:\n        return n_sum_result\n    n_altsum_result = find_n_altsum(p)\n    if n_altsum_result:\n        return n_altsum_result\n    return 'Unknown'"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['ZeroDivisionError'], ['7-sum'], ['Unknown'], ['Unknown'], ['Unknown']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Determines the smallest positive integer `n` such that the prime number `p`\n    can be tested for divisibility using an `n-sum` or `n-altsum` rule.\n    \n    Args:\n    p (int): A prime number to determine the divisibility rule for.\n    \n    Returns:\n    str: A string indicating the type of divisibility rule and the corresponding n value.\n    \"\"\"\n    if not isprime(p):\n        raise ValueError('Input must be a prime number')\n\n    def find_n_sum(p):\n        for n in range(1, 100):\n            test_number = int('1' * (n * p))\n            if test_number % p == 0:\n                return f'{n}-sum'\n\n    def find_n_altsum(p):\n        for n in range(1, 50):\n            pattern = [1 if i % 2 == 0 else -1 for i in range(n)]\n            sum_alt = sum([pow(10, i * n, p) * pattern[i % n] for i in range(p)])\n            if sum_alt % p == 0:\n                return f'{n}-altsum'\n    n_sum_result = find_n_sum(p)\n    if n_sum_result:\n        return n_sum_result\n    n_altsum_result = find_n_altsum(p)\n    if n_altsum_result:\n        return n_altsum_result\n    return 'No simple divisibility rule found within checked parameters.'"], "requirement": [], "outputs": "[['1-sum'], ['6-sum'], ['2-sum'], ['3-sum'], ['5-sum'], ['46-sum'], ['8-sum'], ['No simple divisibility rule found within checked parameters.'], ['No simple divisibility rule found within checked parameters.'], ['6-sum'], ['16-sum'], ['18-sum'], ['22-sum'], ['28-sum'], ['15-sum'], ['21-sum'], ['44-sum'], ['96-sum'], ['4-sum'], ['32-sum'], ['No simple divisibility rule found within checked parameters.'], 'Timeout', 'Timeout', ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    \"\"\"Finds the smallest positive integer `n` such that `p’s` divisibility testing is `n-sum` or `n-altsum`.\n\n    Args:\n        p (int): A prime number.\n\n    Returns:\n        str: A string indicating the smallest positive integer `n` in the format \"n-sum\" or \"n-altsum\".\n    \"\"\"\n    if not isprime(p):\n        raise ValueError('The given number is not a prime.')\n\n    def find_sum_prime():\n        n = 1\n        while True:\n            test_val = int('1' * n)\n            if test_val % p == 0:\n                return f'{n}-sum'\n            n += 1\n\n    def find_altsum_prime():\n        n = 1\n        while True:\n            test_val = int('1' * n)\n            alt_sum = sum([(-1) ** i * int(digit) for i, digit in enumerate(str(test_val)[::-1])])\n            if alt_sum % p == 0:\n                return f'{n}-altsum'\n            n += 1\n    result_sum = find_sum_prime()\n    result_altsum = find_altsum_prime()\n    if int(result_sum.split('-')[0]) < int(result_altsum.split('-')[0]):\n        return result_sum\n    else:\n        return result_altsum"], "requirement": [], "outputs": "[['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], 'Timeout', 'Timeout', ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    if not is_prime(p):\n        return 'Invalid input, p must be a prime number'\n\n    def find_sum_type(p):\n        n = 1\n        while True:\n            if pow(10, n, p) == 1 and (p - 1) % n == 0:\n                return f'{n}-sum'\n            n += 1\n\n    def find_altsum_type(p):\n        n = 1\n        while True:\n            if pow(10, n, 2 * p) == 1 and (2 * p - 1) % (2 * n) == 0:\n                return f'{n}-altsum'\n            n += 1\n    sum_type = find_sum_type(p)\n    altsum_type = find_altsum_type(p)\n    return min(sum_type, altsum_type, key=lambda x: int(x.split('-')[0]))"], "requirement": [], "outputs": "['Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', 'Timeout', ['Invalid input, p must be a prime number'], 'Timeout', ['Invalid input, p must be a prime number'], ['Invalid input, p must be a prime number'], ['Invalid input, p must be a prime number'], ['Invalid input, p must be a prime number'], ['Invalid input, p must be a prime number'], ['Invalid input, p must be a prime number']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Finds the smallest positive integer n such that p’s divisibility testing is n-sum or n-altsum.\n    \"\"\"\n\n    def find_smallest_n_sum_prime(p):\n        if p == 3:\n            return '1-sum'\n        for k in [3, 5, 7, 99]:\n            if all(((int(str(i)[::-1][j:j + k][::-1]) if str(i)[::-1][j:j + k] else 0) % p == 0 for i in range(p * p, p * p * 2, p) for j in range(0, len(str(i)), k))):\n                return f'{k}-sum'\n        return None\n\n    def find_smallest_n_altsum_prime(p):\n        if p == 11:\n            return '1-altsum'\n        for k in [3, 4, 23]:\n            if all((sum(((-1) ** i * (int(str(num)[j:j + k]) if str(num)[j:j + k] else 0) for i, j in enumerate(range(0, len(str(num)), k)))) % p == 0 for num in range(p * p, p * p * 2, p))):\n                return f'{k}-altsum'\n        return None\n    n_sum_result = find_smallest_n_sum_prime(p)\n    if n_sum_result:\n        return n_sum_result\n    n_altsum_result = find_smallest_n_altsum_prime(p)\n    if n_altsum_result:\n        return n_altsum_result\n    for n in range(1, 100):\n        if pow(10, n, p - 1) == 1:\n            return f'{n}-sum' if n % 2 == 1 else f'{n}-altsum'\n    return 'unknown'"], "requirement": [], "outputs": "[['1-sum'], ['3-sum'], ['3-sum'], ['5-sum'], ['5-sum'], ['5-sum'], ['5-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['5-sum'], ['5-sum'], ['5-sum'], ['5-sum'], ['5-sum'], ['5-sum'], ['5-sum'], ['7-sum'], ['7-sum'], ['99-sum'], ['99-sum'], ['unknown'], ['unknown'], ['3-sum'], ['ValueError'], ['3-sum'], ['3-sum'], 'Timeout', 'Timeout']", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    \"\"\"Finds the smallest positive integer n such that p’s divisibility testing is n-sum or n-altsum.\"\"\"\n\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    if not is_prime(p):\n        raise ValueError('Input must be a prime number.')\n    known_primes = {3: '1-sum', 37: '3-sum', 41: '5-sum', 11: '1-altsum', 7: '3-altsum', 47: '23-altsum', 73: '4-altsum'}\n    if p in known_primes:\n        return known_primes[p]\n    for n in range(1, 100):\n        if pow(10, n, p - 1) == 1 and (p - 1) % n == 0:\n            return f'{n}-sum'\n    for n in range(1, 100):\n        test_value = 0\n        multiplier = 1\n        for group in range(0, len(str(p)), n):\n            try:\n                test_value += int(str(p)[-group - n:-group or None]) * multiplier\n                multiplier *= -1\n            except IndexError:\n                break\n        if test_value % p == 0:\n            return f'{n}-altsum'\n    raise Exception(f'No simple {p}-divisibility rule found within expected patterns.')"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['4-altsum'], ['1-altsum'], ['1-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['2-altsum'], ['3-altsum'], ['3-altsum'], ['4-altsum'], ['4-altsum'], ['ValueError'], 'Timeout', ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef solve(p: int) -> str:\n    if p == 2 or p == 5:\n        return '1-sum'\n\n    def is_n_sum_prime(n, p):\n        power = 10 ** n % p\n        sum_of_powers = (power - 1 + p) % p\n        return sum_of_powers == 0 and power != 1\n\n    def is_n_altsum_prime(n, p):\n        power = 10 ** n % (p * p)\n        altsum_factor = (power + 1) % p\n        return altsum_factor == 0\n    for n in range(1, 100):\n        if is_n_sum_prime(n, p):\n            return f'{n}-sum'\n        if is_n_altsum_prime(n, p):\n            return f'{n}-altsum'\n    return 'Unknown'"], "requirement": [], "outputs": "[['Unknown'], ['3-altsum'], ['1-altsum'], ['Unknown'], ['Unknown'], ['23-altsum'], ['4-altsum'], ['1-sum'], ['1-sum'], ['3-altsum'], ['8-altsum'], ['9-altsum'], ['11-altsum'], ['14-altsum'], ['Unknown'], ['Unknown'], ['22-altsum'], ['48-altsum'], ['2-altsum'], ['16-altsum'], ['83-altsum'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['1-sum'], ['ZeroDivisionError'], ['1-sum'], ['Unknown'], ['Unknown'], ['Unknown']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p):\n        raise ValueError(f'{p} is not a prime number')\n    special_cases = {3: '1-sum', 11: '1-altsum', 7: '3-altsum', 37: '3-sum', 41: '5-sum'}\n    if p in special_cases:\n        return special_cases[p]\n\n    def find_n_for_sum_prime():\n        n = 2\n        while True:\n            for m in range(1, n + 1):\n                test_number = int('1' * m + '0' * (n - m))\n                if test_number % p == 0:\n                    return f'{n}-sum'\n            n += 1\n\n    def find_n_for_altsum_prime():\n        n = 2\n        while True:\n            altsum_test = lambda seq: sum(((-1) ** i * int(seq[i:i + n]) for i in range(0, len(str(p)), n)))\n            test_str = '1' * (n * ((len(str(p)) + n - 1) // n))\n            if altsum_test(test_str) % p == 0:\n                return f'{n}-altsum'\n            n += 1\n    if p <= 10 ** 6:\n        result = find_n_for_sum_prime()\n        if result:\n            return result\n    else:\n        result = find_n_for_altsum_prime()\n        if result:\n            return result\n    for method in [find_n_for_sum_prime, find_n_for_altsum_prime]:\n        result = method()\n        if result:\n            return result"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['46-sum'], ['8-sum'], ['2-sum'], ['2-sum'], ['6-sum'], ['16-sum'], ['18-sum'], ['22-sum'], ['28-sum'], ['15-sum'], ['21-sum'], ['44-sum'], ['96-sum'], ['4-sum'], ['32-sum'], ['166-sum'], 'Timeout', ['357-sum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Finds the smallest positive integer n such that p's divisibility testing is n-sum or n-altsum.\n    \"\"\"\n\n    def find_n_sum_prime(p):\n        if p == 3:\n            return '1-sum'\n        for n in [3, 5, 7, 99]:\n            test_number = int('1' * n)\n            if test_number % p == 0:\n                return f'{n}-sum'\n        return None\n\n    def find_n_altsum_prime(p):\n        if p == 11:\n            return '1-altsum'\n        for n in [3, 4, 23]:\n            test_number = int('1' * n)\n            alt_sum = sum([int(d) * (1 if i % 2 == 0 else -1) for i, d in enumerate(str(test_number))])\n            if alt_sum % p == 0:\n                return f'{n}-altsum'\n        return None\n    result = find_n_sum_prime(p)\n    if result:\n        return result\n    result = find_n_altsum_prime(p)\n    if result:\n        return result\n    for n in range(1, p + 1):\n        if pow(10, n, p) == 1:\n            return f'{n}-sum'\n    return 'No known pattern'"], "requirement": [], "outputs": "[['1-sum'], ['4-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['3-sum'], ['ZeroDivisionError'], ['3-sum'], ['4-altsum'], ['4-altsum'], ['4-altsum']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Finds the smallest positive integer n such that p’s divisibility testing is n-sum or n-altsum.\n    \"\"\"\n\n    def is_altsum_prime(p, group_size):\n        for num in range(10 ** (group_size - 1), 10 ** group_size):\n            s = 0\n            neg = False\n            for i in [int(x) for x in str(num)][::-1]:\n                s += -i if neg else i\n                neg = not neg\n            if abs(s) >= p:\n                return False\n            if s % p == 0 and num % p == 0:\n                return True\n        return False\n\n    def is_sum_prime(p, group_size):\n        limit = 10 ** group_size - 1\n        for num in range(1, limit + 1):\n            if num % p == 0:\n                digit_sum = sum((int(digit) for digit in str(num)))\n                if digit_sum >= p:\n                    return False\n                if digit_sum % p == 0:\n                    return True\n        return False\n    for n in range(1, 101):\n        if is_altsum_prime(p, n):\n            return f'{n}-altsum'\n        if is_sum_prime(p, n):\n            return f'{n}-sum'\n    raise ValueError('Prime number exceeds expected pattern.')"], "requirement": [], "outputs": "[['ValueError'], ['4-altsum'], ['2-altsum'], ['4-altsum'], ['3-altsum'], ['4-altsum'], ['4-altsum'], ['ValueError'], ['ValueError'], ['3-altsum'], ['3-altsum'], ['4-altsum'], ['3-altsum'], ['4-altsum'], ['3-altsum'], ['3-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['4-altsum'], ['6-altsum'], ['5-altsum'], ['6-altsum'], 'Timeout', 'Timeout', ['ValueError'], ['ZeroDivisionError'], ['ValueError'], ['ValueError'], 'Timeout', 'Timeout']", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import Tuple\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Finds the smallest positive integer `n` such that `p`'s divisibility testing is `n-sum` or `n-altsum`.\n    \n    Args:\n    p (int): A prime number.\n    \n    Returns:\n    str: The type of divisibility rule for the given prime number.\n    \"\"\"\n\n    def sum_based_divisibility_test(p: int) -> Tuple[bool, int]:\n        n = 1\n        while True:\n            if all((int(f'{i:0{n}d}') % p == 0 for i in range(0, 10 ** n, p))):\n                return (True, n)\n            n += 1\n\n    def altsum_based_divisibility_test(p: int) -> Tuple[bool, int]:\n        n = 1\n        while True:\n            valid = True\n            for base in range(p):\n                num_str = ''\n                for exp in range(n):\n                    num_str = f'{base % 10}{num_str}'\n                    base //= 10\n                num_sum = sum([(-1) ** i * int(num_str[i:i + n]) for i in range(0, len(num_str), n)])\n                if num_sum % p != 0:\n                    valid = False\n                    break\n            if valid:\n                return (True, n)\n            n += 1\n    known_sum_primes = {3: 1, 37: 3, 41: 5, 7: 3, 11: 1, 47: 23, 73: 4}\n    if p in known_sum_primes:\n        return f\"{p} is a '{known_sum_primes[p]}-sum' prime\"\n    is_sum, n_sum = sum_based_divisibility_test(p)\n    if is_sum:\n        return f\"{p} is a '{n_sum}-sum' prime\"\n    is_altsum, n_altsum = altsum_based_divisibility_test(p)\n    if is_altsum:\n        return f\"{p} is a '{n_altsum}-altsum' prime\"\n    raise Exception('No divisibility rule found for this prime')"], "requirement": [], "outputs": "[[\"3 is a '1-sum' prime\"], [\"7 is a '3-sum' prime\"], [\"11 is a '1-sum' prime\"], [\"37 is a '3-sum' prime\"], [\"41 is a '5-sum' prime\"], [\"47 is a '23-sum' prime\"], [\"73 is a '4-sum' prime\"], [\"2 is a '1-sum' prime\"], [\"5 is a '1-sum' prime\"], [\"13 is a '1-sum' prime\"], [\"17 is a '1-sum' prime\"], [\"19 is a '1-sum' prime\"], [\"23 is a '1-sum' prime\"], [\"29 is a '1-sum' prime\"], [\"31 is a '1-sum' prime\"], [\"43 is a '1-sum' prime\"], [\"89 is a '1-sum' prime\"], [\"97 is a '1-sum' prime\"], [\"101 is a '1-sum' prime\"], [\"449 is a '1-sum' prime\"], [\"997 is a '1-sum' prime\"], [\"5003 is a '1-sum' prime\"], [\"4999 is a '1-sum' prime\"], [\"444444444444444444444444444444444444444444444444423 is a '1-sum' prime\"], [\"4444444444444444444444444444444444444444444444444444444444444444444447 is a '1-sum' prime\"], [\"-3 is a '1-sum' prime\"], ['ValueError'], [\"1 is a '1-sum' prime\"], [\"4 is a '1-sum' prime\"], [\"50000001 is a '1-sum' prime\"], [\"50000000 is a '1-sum' prime\"]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def smallest_n_for_prime(p: int) -> str:\n    \"\"\"\n    Find the smallest positive integer n such that p’s divisibility testing is n-sum or n-altsum.\n    \n    Args:\n    p (int): A prime number.\n    \n    Returns:\n    str: The smallest positive integer n in the format \"n-sum\" or \"n-altsum\".\n    \"\"\"\n\n    def is_n_sum_prime(k, prime):\n        for multiple in range(prime, 10 ** 7, prime):\n            str_multiple = str(multiple)\n            grouped_sum = sum((sum(map(int, str_multiple[i:i + k])) for i in range(0, len(str_multiple), k)))\n            if grouped_sum % prime == 0:\n                return True\n        return False\n\n    def is_n_altsum_prime(k, prime):\n        for multiple in range(prime, 10 ** 7, prime):\n            str_multiple = str(multiple)\n            alt_sum = sum(((-1) ** i * sum(map(int, str_multiple[j:j + k])) for i, j in enumerate(range(0, len(str_multiple), k))))\n            if alt_sum % prime == 0:\n                return True\n        return False\n    for n in range(1, 100):\n        if is_n_sum_prime(n, p):\n            return f'{n}-sum'\n        if is_n_altsum_prime(n, p):\n            return f'{n}-altsum'\n    return 'Unknown'"], "requirement": [], "outputs": "[['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-altsum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['Unknown'], ['Unknown'], ['Unknown'], ['ValueError'], ['1-sum'], ['1-sum'], ['Unknown'], ['Unknown']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def smallest_n_for_prime(p: int) -> str:\n    \"\"\"\n    Find the smallest positive integer n such that p’s divisibility testing is n-sum or n-altsum.\n    \n    Args:\n    p (int): A prime number.\n    \n    Returns:\n    str: The smallest positive integer n in the format \"n-sum\" or \"n-altsum\".\n    \"\"\"\n\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num == 2 or num == 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    if not is_prime(p):\n        raise ValueError('Input must be a prime number.')\n    special_cases = {3: '1-sum', 11: '1-altsum', 37: '3-sum', 41: '5-sum', 7: '3-altsum', 47: '23-altsum', 73: '4-altsum'}\n    if p in special_cases:\n        return special_cases[p]\n\n    def find_smallest_n(p, altsum=False):\n        n = 1\n        while True:\n            if altsum:\n                test_value = sum((int(str(p)[i:i + n]) * (-1) ** i for i in range(0, len(str(p)), n)))\n            else:\n                test_value = sum((int(str(p)[i:i + n]) for i in range(0, len(str(p)), n)))\n            if test_value % p == 0:\n                return f'{n}-{('altsum' if altsum else 'sum')}'\n            n += 1\n    result = find_smallest_n(p, altsum=False)\n    if result is None:\n        result = find_smallest_n(p, altsum=True)\n    return result"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['4-altsum'], ['1-sum'], ['1-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['4-sum'], ['4-sum'], ['ValueError'], 'Timeout', ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    if not is_prime(p):\n        raise ValueError('Input must be a prime number.')\n\n    def find_smallest_n(p):\n        for n in range(1, p + 1):\n            if pow(10, n, p) == 1:\n                return n\n        return p\n    if p == 3:\n        return '1-sum'\n    elif p == 11:\n        return '1-altsum'\n    elif p == 7 or p == 13 or p == 37:\n        return '3-altsum' if p == 7 else '3-sum'\n    n = find_smallest_n(p)\n    if n % 2 == 0:\n        return f'{n // 2}-altsum'\n    else:\n        return f'{n}-sum'"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['4-altsum'], ['1-altsum'], ['5-sum'], ['3-sum'], ['8-altsum'], ['9-altsum'], ['11-altsum'], ['14-altsum'], ['15-sum'], ['21-sum'], ['22-altsum'], ['48-altsum'], ['2-altsum'], ['16-altsum'], ['83-altsum'], ['2501-sum'], ['357-sum'], ['ValueError'], 'Timeout', ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import sympy\n\ndef solve(p: int) -> str:\n    \"\"\"\n    This function determines the smallest positive integer `n` such that \n    the prime number `p`'s divisibility test can be done with an `n-sum` \n    or `n-altsum` method.\n    \"\"\"\n\n    def find_sum_type_prime(p):\n        if p == 3:\n            return '1-sum'\n        for group_size in range(1, 100):\n            if all((sum((int(f'{k:0{group_size * (i + 1)}d}'[-j * group_size:(j + 1) * group_size]) for j in range(i + 1))) % p == 0 for i, k in enumerate(range(p, p * 2, p)))):\n                return f'{group_size}-sum'\n        return None\n\n    def find_altsum_type_prime(p):\n        if p == 11:\n            return '1-altsum'\n        for group_size in range(1, 100):\n            if all((sum(((-1) ** j * int(f'{k:0{group_size * (i + 1)}d}'[-j * group_size:(j + 1) * group_size]) for j in range(i + 1))) % p == 0 for i, k in enumerate(range(p, p * 2, p)))):\n                return f'{group_size}-altsum'\n        return None\n    if sympy.isprime(p):\n        result = find_sum_type_prime(p)\n        if result:\n            return result\n        else:\n            result = find_altsum_type_prime(p)\n            if result:\n                return result\n            else:\n                return 'No known n-sum or n-altsum rule found.'\n    else:\n        return 'Input is not a prime number.'"], "requirement": [], "outputs": "[['1-sum'], ['1-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['1-sum'], ['1-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['4-sum'], ['4-sum'], ['Input is not a prime number.'], ['Input is not a prime number.'], ['Input is not a prime number.'], ['Input is not a prime number.'], ['Input is not a prime number.'], ['Input is not a prime number.'], ['Input is not a prime number.'], ['Input is not a prime number.']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Determines the smallest positive integer n such that p's divisibility testing is n-sum or n-altsum.\n    \n    Args:\n    p (int): A prime number for which we need to find the n-sum or n-altsum property.\n    \n    Returns:\n    str: The n-sum or n-altsum property of the prime number.\n    \"\"\"\n\n    def find_sum_n(p):\n        for n in range(1, math.floor(math.log10(p)) + 2):\n            if check_n_sum(p, n):\n                return f'{n}-sum'\n        return None\n\n    def find_altsum_n(p):\n        for n in range(1, math.floor(math.log10(p)) + 2):\n            if check_n_altsum(p, n):\n                return f'{n}-altsum'\n        return None\n\n    def check_n_sum(p, n):\n        str_p = str(p)\n        total = 0\n        while len(str_p) > 0:\n            group = str_p[-n:] if len(str_p) >= n else str_p\n            total += int(group)\n            str_p = str_p[:-n]\n        return total % p == 0\n\n    def check_n_altsum(p, n):\n        str_p = str(p)\n        total = 0\n        sign = 1\n        while len(str_p) > 0:\n            group = str_p[-n:] if len(str_p) >= n else str_p\n            total += int(group) * sign\n            sign *= -1\n            str_p = str_p[:-n]\n        return abs(total) % p == 0\n    n_sum_result = find_sum_n(p)\n    if n_sum_result:\n        return n_sum_result\n    n_altsum_result = find_altsum_n(p)\n    if n_altsum_result:\n        return n_altsum_result\n    return f'{p}-sum'"], "requirement": [], "outputs": "[['1-sum'], ['1-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['1-sum'], ['1-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['2-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['4-sum'], ['4-sum'], ['51-sum'], ['70-sum'], ['ValueError'], ['ValueError'], ['1-sum'], ['1-sum'], ['8-sum'], ['8-sum']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p):\n        raise ValueError(f'{p} is not a prime number.')\n    if p == 3:\n        return '1-sum'\n\n    def check_n_sum(n, p):\n\n        def sum_in_groups(x, k):\n            return sum((int(str(x)[i:i + k]) for i in range(0, len(str(x)), k) if str(x)[i:i + k]))\n        for x in range(p, 50000000 + 1, p):\n            if sum_in_groups(x, n) % p == 0:\n                return True\n        return False\n\n    def check_n_altsum(n, p):\n\n        def altsum_in_groups(x, k):\n            alt_sum = 0\n            for i in range(0, len(str(x)), k):\n                group = str(x)[i:i + k]\n                if group:\n                    alt_sum += (-1) ** (i // k) * int(group)\n            return alt_sum\n        for x in range(p, 50000000 + 1, p):\n            if abs(altsum_in_groups(x, n)) % p == 0:\n                return True\n        return False\n    checks = [('1-altsum', lambda p: check_n_altsum(1, p)), ('3-sum', lambda p: check_n_sum(3, p)), ('3-altsum', lambda p: check_n_altsum(3, p)), ('5-sum', lambda p: check_n_sum(5, p)), ('4-altsum', lambda p: check_n_altsum(4, p)), ('23-altsum', lambda p: check_n_altsum(23, p)), ('99-sum', lambda p: check_n_sum(99, p))]\n    for name, check_func in checks:\n        if check_func(p):\n            return name\n    return f'Unknown divisibility rule for {p}'"], "requirement": [], "outputs": "[['1-sum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['1-altsum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from sympy import isprime\n\ndef solve(p: int) -> str:\n    if not isprime(p):\n        raise ValueError('p must be a prime number')\n    div_rules = {3: '1-sum', 7: '3-altsum', 11: '1-altsum', 37: '3-sum', 41: '5-sum'}\n    if p in div_rules:\n        return div_rules[p]\n\n    def test_sum_divisibility(prime, group_size):\n        n = 1\n        while True:\n            num = int('1' * (n * group_size))\n            if num % prime == 0:\n                return f'{group_size}-sum'\n            n += 1\n\n    def test_altsum_divisibility(prime, group_size):\n        n = 1\n        while True:\n            pattern = '1' * group_size + '0' * group_size\n            num_str = pattern * n\n            num = sum((int(num_str[i:i + group_size]) * (-1) ** i for i in range(0, len(num_str), group_size)))\n            if num % prime == 0:\n                return f'{group_size}-altsum'\n            n += 1\n    for group_size in range(1, 100):\n        result = test_sum_divisibility(p, group_size)\n        if result:\n            return result\n    for group_size in range(1, 100):\n        result = test_altsum_divisibility(p, group_size)\n        if result:\n            return result\n    return 'No simple divisibility rule found'"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['1-sum'], ['1-sum'], 'Timeout', 'Timeout', ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['1-sum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def solve(p: int) -> str:\n    import math\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2 or n == 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        for i in range(5, int(math.sqrt(n)) + 1, 6):\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n        return True\n\n    def find_smallest_n(p):\n        if p == 2:\n            return '1-sum'\n        elif p == 3:\n            return '1-sum'\n        elif p == 5:\n            return '1-sum'\n        elif p == 7:\n            return '3-altsum'\n        elif p == 11:\n            return '1-altsum'\n        elif p == 13:\n            return '3-sum'\n        elif p == 17:\n            return '8-altsum'\n        elif p == 19:\n            return '18-altsum'\n        elif p == 23:\n            return '7-altsum'\n        elif p == 29:\n            return '28-altsum'\n        elif p == 31:\n            return '30-altsum'\n        elif p == 37:\n            return '3-sum'\n        elif p == 41:\n            return '5-sum'\n        elif p == 43:\n            return '42-altsum'\n        elif p == 47:\n            return '23-altsum'\n        if p % 2 == 0 or not is_prime(p):\n            return 'Invalid prime'\n        for n in range(1, 100):\n            if all((sum((int(digit) for digit in str(k).zfill(n))) % p == 0 for k in range(p, 10 * p, p))):\n                return f'{n}-sum'\n        for n in range(1, 100):\n            if all((sum(((-1) ** i * int(''.join(str(k).zfill(n * (i + 1))[-n * i - 1:-n * i] or '0')) for i in range(len(str(k)) // n + 1))) % p == 0 for k in range(p, 10 * p, p))):\n                return f'{n}-altsum'\n        return 'Unknown'\n    if not is_prime(p):\n        return 'Invalid prime'\n    return find_smallest_n(p)"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['3-altsum'], ['1-sum'], ['1-sum'], ['3-sum'], ['8-altsum'], ['18-altsum'], ['7-altsum'], ['28-altsum'], ['30-altsum'], ['42-altsum'], ['3-altsum'], ['3-altsum'], ['3-altsum'], ['4-altsum'], ['4-altsum'], ['5-altsum'], ['5-altsum'], ['Invalid prime'], 'Timeout', ['Invalid prime'], ['Invalid prime'], ['Invalid prime'], ['Invalid prime'], ['Invalid prime'], ['Invalid prime']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import gcd\n\ndef solve(p: int) -> str:\n    \"\"\"\n    Finds the smallest positive integer n such that p’s divisibility testing is n-sum or n-altsum.\n    \"\"\"\n\n    def find_smallest_n_sum_prime(p):\n        if p == 3:\n            return '1-sum'\n        for k in [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 99]:\n            for i in range(1, 100):\n                num_str = str(i * p)\n                groups = [num_str[j:j + k] for j in range(0, len(num_str), k)]\n                sum_of_groups_ints = sum((int(group) for group in groups if group))\n                if sum_of_groups_ints % p == 0:\n                    return f'{k}-sum'\n        return None\n\n    def find_smallest_n_altsum_prime(p):\n        if p == 11:\n            return '1-altsum'\n        for k in [3, 4, 23, 7, 15]:\n            for i in range(1, 100):\n                num_str = str(i * p)\n                groups = [num_str[j:j + k] for j in range(0, len(num_str), k)]\n                altsum = sum(((-1) ** idx * int(group) for idx, group in enumerate(groups) if group))\n                if altsum % p == 0:\n                    return f'{k}-altsum'\n        return None\n    result = find_smallest_n_sum_prime(p)\n    if not result:\n        result = find_smallest_n_altsum_prime(p)\n    return result if result else 'Not Found'"], "requirement": [], "outputs": "[['1-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['3-sum'], ['5-sum'], ['5-sum'], ['99-sum'], ['99-sum'], ['3-sum'], ['ZeroDivisionError'], ['3-sum'], ['3-sum'], ['9-sum'], ['9-sum']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import Tuple\n\ndef get_sum_type(p: int) -> Tuple[int, str]:\n    if is_altsum_prime(p):\n        return find_smallest_altsum_group(p)\n    else:\n        return find_smallest_sum_group(p)\n\ndef solve(p: int) -> str:\n    n, typ = get_sum_type(p)\n    return f'{n}-{typ}'\n\ndef is_altsum_prime(p: int) -> bool:\n    for i in [1, 3, 23, 4]:\n        if check_altsum_group(p, i):\n            return True\n    return False\n\ndef check_altsum_group(p: int, group_size: int) -> bool:\n    for num in range(1, 10 ** 6):\n        if p == 11 and group_size == 1:\n            if sum((int(d) * (-1) ** i for i, d in enumerate(str(num)[::-1]))) % p == 0:\n                return True\n        elif p == 7 and group_size == 3:\n            groups = [str(num)[i:i + group_size] for i in range(0, len(str(num)), group_size)]\n            if sum((int(g) * (-1) ** i for i, g in enumerate(groups))) % p == 0:\n                return True\n        elif p == 47 and group_size == 23:\n            groups = [str(num)[i:i + group_size] for i in range(0, len(str(num)), group_size)]\n            if sum((int(g) * (-1) ** i for i, g in enumerate(groups))) % p == 0:\n                return True\n        elif p == 73 and group_size == 4:\n            groups = [str(num)[i:i + group_size] for i in range(0, len(str(num)), group_size)]\n            if sum((int(g) * (-1) ** i for i, g in enumerate(groups))) % p == 0:\n                return True\n    return False\n\ndef find_smallest_altsum_group(p: int) -> Tuple[int, str]:\n    for group_size in [1, 3, 23, 4]:\n        if check_altsum_group(p, group_size):\n            return (group_size, 'altsum')\n    return (-1, 'unknown')\n\ndef find_smallest_sum_group(p: int) -> Tuple[int, str]:\n    for group_size in [1, 3, 5, 7, 99]:\n        if check_sum_group(p, group_size):\n            return (group_size, 'sum')\n    return (-1, 'unknown')\n\ndef check_sum_group(p: int, group_size: int) -> bool:\n    for num in range(1, 10 ** 6):\n        if p == 3 and group_size == 1:\n            if sum((int(d) for d in str(num))) % p == 0:\n                return True\n        elif p == 37 and group_size == 3:\n            groups = [str(num)[i:i + group_size] for i in range(0, len(str(num)), group_size)]\n            if sum((int(g) for g in groups)) % p == 0:\n                return True\n        elif p == 41 and group_size == 5:\n            groups = [str(num)[i:i + group_size] for i in range(0, len(str(num)), group_size)]\n            if sum((int(g) for g in groups)) % p == 0:\n                return True\n        elif p == 7 and group_size == 7:\n            groups = [str(num)[i:i + group_size] for i in range(0, len(str(num)), group_size)]\n            if sum((int(g) for g in groups)) % p == 0:\n                return True\n        elif p == 99 and group_size == 99:\n            groups = [str(num)[i:i + group_size] for i in range(0, len(str(num)), group_size)]\n            if sum((int(g) for g in groups)) % p == 0:\n                return True\n    return False"], "requirement": [], "outputs": "[['1-sum'], ['3-altsum'], ['1-altsum'], ['3-sum'], ['5-sum'], ['23-altsum'], ['4-altsum'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown'], ['-1-unknown']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from itertools import chain\n\ndef solve(p: int) -> str:\n\n    def is_n_sum_prime(n, p):\n        \"\"\"Check if p can be tested for divisibility by summing groups of n digits.\"\"\"\n        if n == 1:\n            return all((sum((int(digit) for digit in str(q))) % p == 0 for q in range(0, p * 2, p)))\n        else:\n            for k in range(1, 10 ** n):\n                s = sum((int(str(k).zfill(n)[i:i + n]) for i in range(0, len(str(k)), n)))\n                if s % p != 0 and (k + p - k % p) % p == 0:\n                    return False\n            return True\n\n    def is_n_altsum_prime(n, p):\n        \"\"\"Check if p can be tested for divisibility by alternately summing/subtracting groups of n digits.\"\"\"\n        for k in range(1, 10 ** n):\n            alt_sum = sum(((-1) ** i * int(str(k).zfill(n)[i:i + n]) for i in range(0, len(str(k)), n)))\n            if alt_sum % p != 0 and (k + p - k % p) % p == 0:\n                return False\n        return True\n    if p == 2 or p == 5:\n        return '1-sum'\n    for n in chain([1], range(2, 100)):\n        if is_n_sum_prime(n, p):\n            return f'{n}-sum'\n    for n in chain([1], range(2, 100)):\n        if is_n_altsum_prime(n, p):\n            return f'{n}-altsum'\n    raise ValueError('No suitable n found for given prime number.')"], "requirement": [], "outputs": "[['1-sum'], ['1-sum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['1-sum'], ['1-sum'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['1-sum'], ['1-sum'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 3.912023005428146, "llm_generated_inputs": "[[3], [7], [11], [37], [41], [47], [73], [2], [5], [13], [17], [19], [23], [29], [31], [43], [89], [97], [101], [449], [997], [5003], [4999], [444444444444444444444444444444444444444444444444423], [4444444444444444444444444444444444444444444444444444444444444444444447], [-3], [0], [1], [4], [50000001], [50000000]]", "input_output_examples": "[[[3], [7]], [['1-sum'], ['3-altsum']]]", "at_least_one_align": false}, "entry_point": "solve", "ground_truth": -1}
{"task_id": "TACO_lite/10", "requirement": "from typing import List\ndef beggars(values: List[int], n: int) -> List[int]:\n\"\"\"Born a misinterpretation of [this kata](https://www.codewars.com/kata/simple-fun-number-334-two-beggars-and-gold/), your task here is pretty simple: given an array of values and an amount of beggars, you are supposed to return an array with the sum of what each beggar brings home, assuming they all take regular turns, from the first to the last.\n\nThe same array with different numbers of beggars would have in turn have produced different outcomes, as they will respectively take different elements from the array.\n\nAlso note that not all beggars have to take the same amount of \"offers\", meaning that the length of the array is not necessarily a multiple of `n`; length can be even shorter, in which case the last beggars will of course take nothing (`0`).\n\n***Note:*** in case you don't get why this kata is about *English* beggars, then you are not familiar on how religiously queues are taken in the kingdom ;)\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        result[i % n] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i in range(len(values)):\n        beggar_index = i % n\n        result[beggar_index] += values[i]\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    beggar_sums = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        beggar_sums[beggar_index] += value\n    return beggar_sums", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    beggar_sums = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        beggar_sums[beggar_index] += value\n    return beggar_sums", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n == 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result"], "requirement": [], "outputs": "[[[15]], [[9, 6]], [[5, 7, 3]], [[1, 2, 3, 4, 5, 0]], [[0, 0, 0]], [[50, 70, 90]], [[5, 1, 2, 7, 4, 0, 0, 0, 0, 0]], [[9, 8, 5, 3]], [[]], ['IndexError']]", "probability": 0.96, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n <= 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result", "from typing import List\n\ndef beggars(values: List[int], n: int) -> List[int]:\n    if n <= 0:\n        return []\n    result = [0] * n\n    for i, value in enumerate(values):\n        beggar_index = i % n\n        result[beggar_index] += value\n    return result"], "requirement": [], "outputs": "[[[15]], [[9, 6]], [[5, 7, 3]], [[1, 2, 3, 4, 5, 0]], [[0, 0, 0]], [[50, 70, 90]], [[5, 1, 2, 7, 4, 0, 0, 0, 0, 0]], [[9, 8, 5, 3]], [[]], [[]]]", "probability": 0.04, "is_align_req": false, "DRS": null}], "entropy": 0.167944147734173, "llm_generated_inputs": "[[[1, 2, 3, 4, 5], 1], [[1, 2, 3, 4, 5], 2], [[1, 2, 3, 4, 5], 3], [[1, 2, 3, 4, 5], 6], [[], 3], [[10, 20, 30, 40, 50, 60], 3], [[5, 1, 2, 7, 4], 10], [[7, 0, 5, 3, 2, 8], 4], [[1, 2, 3], 0], [[1, 2, 3], -1]]", "input_output_examples": "[[[[1, 2, 3, 4, 5], 2], [[1, 2, 3, 4, 5], 3]], [[[9, 6]], [[5, 7, 3]]]]", "at_least_one_align": false}, "entry_point": "beggars", "ground_truth": -1}
{"task_id": "TACO_lite/11", "requirement": "def fizz_buzz_cuckoo_clock(t: str) -> str:\n\"\"\"## Your story\nYou've always loved both Fizz Buzz katas and cuckoo clocks, and when you walked by a garage sale and saw an ornate cuckoo clock with a missing pendulum, and a \"Beyond-Ultimate Raspberry Pi Starter Kit\" filled with all sorts of sensors and motors and other components, it's like you were suddenly hit by a beam of light and knew that it was your mission to combine the two to create a computerized Fizz Buzz cuckoo clock!\n\nYou took them home and set up shop on the kitchen table, getting more and more excited as you got everything working together just perfectly. Soon the only task remaining was to write a function to select from the sounds you had recorded depending on what time it was:\n\n## Your plan\n* When a minute is evenly divisible by three, the clock will say the word \"Fizz\".\n* When a minute is evenly divisible by five, the clock will say the word \"Buzz\".\n* When a minute is evenly divisible by both, the clock will say \"Fizz Buzz\", with two exceptions:\n  1. On the hour, instead of \"Fizz Buzz\", the clock door will open, and the cuckoo bird will come out and \"Cuckoo\" between one and twelve times depending on the hour.\n  2. On the half hour, instead of \"Fizz Buzz\", the clock door will open, and the cuckoo will come out and \"Cuckoo\" just once. \n* With minutes that are not evenly divisible by either three or five, at first you had intended to have the clock just say the numbers ala Fizz Buzz, but then you decided at least for version 1.0 to just have the clock make a quiet, subtle \"tick\" sound for a little more clock nature and a little less noise.\n\nYour input will be a string containing hour and minute values in 24-hour time, separated by a colon, and with leading zeros. \n\nYour return value will be a string containing the combination of Fizz, Buzz, Cuckoo, and/or tick sounds that the clock needs to make at that time, separated by spaces. Note that although the input is in 24-hour time, cuckoo clocks' cuckoos are in 12-hour time. \n\nHave fun!\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12h = (hour - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12h)\n    elif minute == 30:\n        return 'Cuckoo'\n    else:\n        result = ''\n        if minute % 3 == 0:\n            result += 'Fizz'\n        if minute % 5 == 0:\n            result += ' Buzz' if result else 'Buzz'\n        return result.strip() or 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour = time_obj.hour % 12\n    minute = time_obj.minute\n    if minute == 0:\n        return ' '.join(['Cuckoo' for _ in range(hour if hour != 0 else 12)])\n    elif minute == 30:\n        return 'Cuckoo'\n    result = []\n    if minute % 3 == 0:\n        result.append('Fizz')\n    if minute % 5 == 0:\n        result.append('Buzz')\n    return ' '.join(result) if result else 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12h = (hour - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12h)\n    elif minute == 30:\n        return 'Cuckoo'\n    if minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    hour, minute = map(int, t.split(':'))\n    hour_12hr = (hour - 1) % 12 + 1\n    output = ''\n    if minute == 0:\n        output = ' '.join(['Cuckoo'] * hour_12hr)\n    elif minute == 30:\n        output = 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        output = 'Fizz Buzz'\n    elif minute % 3 == 0:\n        output = 'Fizz'\n    elif minute % 5 == 0:\n        output = 'Buzz'\n    else:\n        output = 'tick'\n    return output", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour_24 = time_obj.hour\n    minute = time_obj.minute\n    hour_12 = hour_24 % 12\n    if hour_12 == 0:\n        hour_12 = 12\n    result = []\n    if minute == 0:\n        result.append(' '.join(['Cuckoo'] * hour_12))\n    elif minute == 30:\n        result.append('Cuckoo')\n    elif minute % 3 == 0 and minute % 5 == 0:\n        result.append('Fizz Buzz')\n    elif minute % 3 == 0:\n        result.append('Fizz')\n    elif minute % 5 == 0:\n        result.append('Buzz')\n    else:\n        result.append('tick')\n    return ' '.join(result)", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour_24 = time_obj.hour\n    minute = time_obj.minute\n    hour_12 = hour_24 % 12 if hour_24 % 12 != 0 else 12\n    output_sound = ''\n    if minute == 30:\n        output_sound = 'Cuckoo'\n    elif minute == 0:\n        output_sound = ' '.join(['Cuckoo'] * hour_12)\n    elif minute % 3 == 0 and minute % 5 == 0:\n        output_sound = 'Fizz Buzz'\n    elif minute % 3 == 0:\n        output_sound = 'Fizz'\n    elif minute % 5 == 0:\n        output_sound = 'Buzz'\n    else:\n        output_sound = 'tick'\n    return output_sound", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    hour, minute = map(int, t.split(':'))\n    hr_12 = (hour - 1) % 12 + 1 if hour != 12 else 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hr_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    if minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour = (time.hour - 1) % 12 + 1\n    minute = time.minute\n    output = ''\n    if minute == 0:\n        output = ' '.join(['Cuckoo'] * hour)\n    elif minute == 30:\n        output = 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        output = 'Fizz Buzz'\n    elif minute % 3 == 0:\n        output = 'Fizz'\n    elif minute % 5 == 0:\n        output = 'Buzz'\n    else:\n        output = 'tick'\n    return output", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12h = (hour - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12h)\n    elif minute == 30:\n        return 'Cuckoo'\n    result = []\n    if minute % 3 == 0:\n        result.append('Fizz')\n    if minute % 5 == 0:\n        result.append('Buzz')\n    if not result:\n        return 'tick'\n    return ' '.join(result)", "from datetime import datetime\n\ndef fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hr_12h_format = hour % 12\n    if hr_12h_format == 0:\n        hr_12h_format = 12\n    result = ''\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hr_12h_format)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        result = 'Fizz Buzz'\n    elif minute % 3 == 0:\n        result = 'Fizz'\n    elif minute % 5 == 0:\n        result = 'Buzz'\n    else:\n        result = 'tick'\n    return result", "from datetime import datetime\n\ndef fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hr_12h = (hour - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hr_12h)\n    elif minute == 30:\n        return 'Cuckoo'\n    else:\n        result = []\n        if minute % 3 == 0:\n            result.append('Fizz')\n        if minute % 5 == 0:\n            result.append('Buzz')\n        return ' '.join(result) if result else 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour = time_obj.hour % 12\n    minute = time_obj.minute\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * (hour if hour != 0 else 12))\n    elif minute == 30:\n        return 'Cuckoo'\n    result = []\n    if minute % 3 == 0:\n        result.append('Fizz')\n    if minute % 5 == 0:\n        result.append('Buzz')\n    return ' '.join(result) if result else 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12hr = (hour - 1) % 12 + 1\n    if minute == 30:\n        return 'Cuckoo'\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12hr)\n    if minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour_24 = time.hour\n    minute = time.minute\n    hour_12 = (hour_24 - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour_24 = time.hour\n    minute = time.minute\n    hour_12 = (hour_24 - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from math import floor\n\n    def cuckoo_sound(hour):\n        if hour == 0:\n            return 'Cuckoo'\n        else:\n            return ' '.join(['Cuckoo'] * (hour % 12 if hour % 12 != 0 else 12))\n    hours, minutes = map(int, t.split(':'))\n    clock_hours = (hours - 1) % 12 + 1 if hours != 0 else 12\n    if minutes == 0:\n        return cuckoo_sound(clock_hours)\n    elif minutes == 30:\n        return 'Cuckoo'\n    elif minutes % 3 == 0 and minutes % 5 == 0:\n        return 'Fizz Buzz'\n    elif minutes % 3 == 0:\n        return 'Fizz'\n    elif minutes % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour_24 = time.hour\n    minute = time.minute\n    hour_12 = hour_24 % 12\n    if hour_12 == 0:\n        hour_12 = 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    else:\n        output = []\n        if minute % 3 == 0:\n            output.append('Fizz')\n        if minute % 5 == 0:\n            output.append('Buzz')\n        if not output:\n            output.append('tick')\n        return ' '.join(output)", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour_24 = time.hour\n    minute = time.minute\n    hour_12 = (hour_24 - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour = time_obj.hour\n    minute = time_obj.minute\n    hour_12hr = (hour - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12hr)\n    elif minute == 30:\n        return 'Cuckoo'\n    else:\n        result = []\n        if minute % 3 == 0:\n            result.append('Fizz')\n        if minute % 5 == 0:\n            result.append('Buzz')\n        if not result:\n            result.append('tick')\n        return ' '.join(result)", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour = time.hour % 12\n    minute = time.minute\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * (hour if hour != 0 else 12))\n    elif minute == 30:\n        return 'Cuckoo'\n    sounds = []\n    if minute % 3 == 0:\n        sounds.append('Fizz')\n    if minute % 5 == 0:\n        sounds.append('Buzz')\n    return ' '.join(sounds) if sounds else 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12 = (hour - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    else:\n        result = []\n        if minute % 3 == 0:\n            result.append('Fizz')\n        if minute % 5 == 0:\n            result.append('Buzz')\n        if not result:\n            result.append('tick')\n        return ' '.join(result)", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour_24 = time.hour\n    minute = time.minute\n    hour_12 = (hour_24 - 1) % 12 + 1\n\n    def get_sound():\n        if minute == 0:\n            return ' '.join(['Cuckoo'] * hour_12)\n        elif minute == 30:\n            return 'Cuckoo'\n        elif minute % 3 == 0 and minute % 5 == 0:\n            return 'Fizz Buzz'\n        elif minute % 3 == 0:\n            return 'Fizz'\n        elif minute % 5 == 0:\n            return 'Buzz'\n        else:\n            return 'tick'\n    return get_sound()", "from datetime import datetime\n\ndef fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12hr = hour % 12 if hour != 12 and hour != 0 else 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12hr)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    hour, minute = map(int, t.split(':'))\n    hour_12hr = hour % 12 if hour % 12 != 0 else 12\n    result = []\n    if minute == 30:\n        result.append('Cuckoo')\n    elif minute == 0:\n        result.extend(['Cuckoo'] * hour_12hr)\n    elif minute % 3 == 0 and minute % 5 == 0:\n        result.append('Fizz Buzz')\n    elif minute % 3 == 0:\n        result.append('Fizz')\n    elif minute % 5 == 0:\n        result.append('Buzz')\n    else:\n        result.append('tick')\n    return ' '.join(result)", "from datetime import datetime\n\ndef fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12h = (hour - 1) % 12 + 1\n    sounds = []\n    if minute == 30:\n        sounds.append('Cuckoo')\n    elif minute == 0:\n        sounds.extend(['Cuckoo'] * hour_12h)\n    elif minute % 3 == 0 and minute % 5 == 0:\n        sounds.append('Fizz Buzz')\n    elif minute % 3 == 0:\n        sounds.append('Fizz')\n    elif minute % 5 == 0:\n        sounds.append('Buzz')\n    else:\n        sounds.append('tick')\n    return ' '.join(sounds)", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour_24 = time_obj.hour\n    minute = time_obj.minute\n    hour_12 = hour_24 % 12 if hour_24 % 12 != 0 else 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 15 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "from datetime import datetime\n\ndef fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hr_12hr_format = hour % 12 or 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hr_12hr_format)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "from datetime import datetime\n\ndef fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12 = (hour - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    result = []\n    if minute % 3 == 0:\n        result.append('Fizz')\n    if minute % 5 == 0:\n        result.append('Buzz')\n    return ' '.join(result) if result else 'tick'", "from datetime import datetime\n\ndef fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12h = (hour - 1) % 12 + 1\n    sounds = []\n    if minute == 30:\n        return 'Cuckoo'\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12h)\n    if minute % 3 == 0 and minute % 5 == 0:\n        sounds.append('Fizz Buzz')\n    elif minute % 3 == 0:\n        sounds.append('Fizz')\n    elif minute % 5 == 0:\n        sounds.append('Buzz')\n    else:\n        sounds.append('tick')\n    return ' '.join(sounds)", "from datetime import datetime\n\ndef fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12h = (hour - 1) % 12 + 1\n    sounds = []\n    if minute == 30:\n        return 'Cuckoo'\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12h)\n    if minute % 3 == 0 and minute % 5 == 0:\n        sounds.append('Fizz Buzz')\n    elif minute % 3 == 0:\n        sounds.append('Fizz')\n    elif minute % 5 == 0:\n        sounds.append('Buzz')\n    else:\n        sounds.append('tick')\n    return ' '.join(sounds)", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    hour, minute = map(int, t.split(':'))\n    hour_12h = (hour - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12h)\n    elif minute == 30:\n        return 'Cuckoo'\n    result = []\n    if minute % 3 == 0:\n        result.append('Fizz')\n    if minute % 5 == 0:\n        result.append('Buzz')\n    if not result:\n        result.append('tick')\n    return ' '.join(result)", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12 = hour % 12 if hour % 12 != 0 else 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour_24 = time.hour\n    minute = time.minute\n    hour_12 = (hour_24 - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour_24 = time_obj.hour\n    minute = time_obj.minute\n    hour_12 = (hour_24 - 1) % 12 + 1\n    result = ''\n    if minute == 0:\n        result = ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        result = 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        result = 'Fizz Buzz'\n    elif minute % 3 == 0:\n        result = 'Fizz'\n    elif minute % 5 == 0:\n        result = 'Buzz'\n    else:\n        result = 'tick'\n    return result"], "requirement": [], "outputs": "[['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['tick'], ['tick'], ['Fizz'], ['Buzz'], ['Fizz Buzz'], ['Cuckoo'], ['Fizz Buzz'], ['Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['tick'], ['Fizz'], ['Buzz'], ['Fizz'], ['tick'], ['tick']]", "probability": 0.68, "is_align_req": false, "DRS": null}, {"programs_str": ["def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour_24 = time_obj.hour\n    minute = time_obj.minute\n    hour_12 = hour_24 % 12 if hour_24 != 0 else 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    result = []\n    if minute % 3 == 0:\n        result.append('Fizz')\n    if minute % 5 == 0:\n        result.append('Buzz')\n    return ' '.join(result) if result else 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour = time.hour % 12 if time.hour != 0 else 12\n    minute = time.minute\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour)\n    elif minute == 30:\n        return 'Cuckoo'\n    output = []\n    if minute % 3 == 0:\n        output.append('Fizz')\n    if minute % 5 == 0:\n        output.append('Buzz')\n    return ' '.join(output) if output else 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour = time_obj.hour % 12 if time_obj.hour != 0 else 12\n    minute = time_obj.minute\n    result = []\n    if minute == 0:\n        result.append(' '.join(['Cuckoo'] * hour))\n    elif minute == 30:\n        result.append('Cuckoo')\n    elif minute % 3 == 0 and minute % 5 == 0:\n        result.append('Fizz Buzz')\n    elif minute % 3 == 0:\n        result.append('Fizz')\n    elif minute % 5 == 0:\n        result.append('Buzz')\n    else:\n        result.append('tick')\n    return ' '.join(result)", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour_24 = time.hour\n    minute = time.minute\n    hour_12 = hour_24 % 12 if hour_24 != 0 else 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    clock_hour = hour % 12 if hour != 0 else 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * clock_hour)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 15 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour_24 = time_obj.hour\n    minute = time_obj.minute\n    hour_12 = hour_24 % 12 if hour_24 != 0 else 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    fizz = minute % 3 == 0\n    buzz = minute % 5 == 0\n    if fizz and buzz:\n        return 'Fizz Buzz'\n    elif fizz:\n        return 'Fizz'\n    elif buzz:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour = time.hour % 12 if time.hour != 0 else 12\n    minute = time.minute\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour)\n    elif minute == 30:\n        return 'Cuckoo'\n    result = []\n    if minute % 3 == 0:\n        result.append('Fizz')\n    if minute % 5 == 0:\n        result.append('Buzz')\n    return ' '.join(result) if result else 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12hr = hour % 12 if hour != 0 else 12\n    result = ''\n    if minute == 0:\n        result = ' '.join(['Cuckoo'] * hour_12hr)\n    elif minute == 30:\n        result = 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        result = 'Fizz Buzz'\n    elif minute % 3 == 0:\n        result = 'Fizz'\n    elif minute % 5 == 0:\n        result = 'Buzz'\n    else:\n        result = 'tick'\n    return result", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour = time.hour % 12 if time.hour != 0 else 12\n    minute = time.minute\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour)\n    elif minute == 30:\n        return 'Cuckoo'\n    if minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time = datetime.strptime(t, '%H:%M')\n    hour = time.hour % 12 if time.hour != 0 else 12\n    minute = time.minute\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour)\n    elif minute == 30:\n        return 'Cuckoo'\n    result = []\n    if minute % 3 == 0:\n        result.append('Fizz')\n    if minute % 5 == 0:\n        result.append('Buzz')\n    if not result:\n        return 'tick'\n    return ' '.join(result)", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour_24 = time_obj.hour\n    minute = time_obj.minute\n    hour_12 = hour_24 % 12 if hour_24 != 0 else 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    if minute % 15 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'"], "requirement": [], "outputs": "[['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['tick'], ['tick'], ['Fizz'], ['Buzz'], ['Fizz Buzz'], ['Cuckoo'], ['Fizz Buzz'], ['Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], [''], ['Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['tick'], ['Fizz'], ['Buzz'], ['Fizz'], ['tick'], ['tick']]", "probability": 0.22, "is_align_req": false, "DRS": null}, {"programs_str": ["def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from math import floor\n    hours, minutes = map(int, t.split(':'))\n    clock_hour = hours % 12 if hours % 12 != 0 else 12\n    if minutes == 0:\n        return ' '.join(['Cuckoo'] * clock_hour)\n    elif minutes == 30:\n        return 'Cuckoo'\n    else:\n        result = ''\n        if minutes % 3 == 0:\n            result += 'Fizz'\n        if minutes % 5 == 0:\n            result += 'Buzz'\n        if not result:\n            result = 'tick'\n        return result", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    time_obj = datetime.strptime(t, '%H:%M')\n    hour_24 = time_obj.hour\n    minute = time_obj.minute\n    hour_12 = (hour_24 - 1) % 12 + 1\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12)\n    elif minute == 30:\n        return 'Cuckoo'\n    output = ''\n    if minute % 3 == 0:\n        output += 'Fizz'\n    if minute % 5 == 0:\n        output += 'Buzz'\n    return output if output else 'tick'"], "requirement": [], "outputs": "[['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['tick'], ['tick'], ['Fizz'], ['Buzz'], ['FizzBuzz'], ['Cuckoo'], ['FizzBuzz'], ['Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['tick'], ['Fizz'], ['Buzz'], ['Fizz'], ['tick'], ['tick']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["def fizz_buzz_cuckoo_clock(t: str) -> str:\n    hour, minute = map(int, t.split(':'))\n    hour_12hr = hour % 12 if hour != 12 else 12\n\n    def fizz_buzz(minute):\n        if minute % 15 == 0:\n            return 'Fizz Buzz'\n        elif minute % 3 == 0:\n            return 'Fizz'\n        elif minute % 5 == 0:\n            return 'Buzz'\n        else:\n            return 'tick'\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * hour_12hr)\n    elif minute == 30:\n        return 'Cuckoo'\n    else:\n        return fizz_buzz(minute)", "def fizz_buzz_cuckoo_clock(t: str) -> str:\n    from datetime import datetime\n    hour, minute = map(int, t.split(':'))\n    clock_hour = hour % 12 if hour != 12 else 12\n    if minute == 0:\n        return ' '.join(['Cuckoo'] * clock_hour)\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 15 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'"], "requirement": [], "outputs": "[[''], ['tick'], ['tick'], ['Fizz'], ['Buzz'], ['Fizz Buzz'], ['Cuckoo'], ['Fizz Buzz'], ['Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['tick'], ['Fizz'], ['Buzz'], ['Fizz'], ['tick'], ['tick']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["def fizz_buzz_cuckoo_clock(t: str) -> str:\n    import math\n    hour, minute = map(int, t.split(':'))\n    clock_hour = hour % 12 if hour % 12 != 0 else 12\n    if minute == 0:\n        return 'Cuckoo ' * clock_hour.strip()\n    elif minute == 30:\n        return 'Cuckoo'\n    elif minute % 3 == 0 and minute % 5 == 0:\n        return 'Fizz Buzz'\n    elif minute % 3 == 0:\n        return 'Fizz'\n    elif minute % 5 == 0:\n        return 'Buzz'\n    else:\n        return 'tick'"], "requirement": [], "outputs": "[['AttributeError'], ['tick'], ['tick'], ['Fizz'], ['Buzz'], ['Fizz Buzz'], ['Cuckoo'], ['Fizz Buzz'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['tick'], ['Fizz'], ['Buzz'], ['Fizz'], ['tick'], ['tick']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 0.9311091142287191, "llm_generated_inputs": "[['00:00'], ['00:01'], ['00:02'], ['00:03'], ['00:05'], ['00:15'], ['00:30'], ['00:45'], ['01:00'], ['06:00'], ['12:00'], ['13:00'], ['18:00'], ['23:59'], ['14:03'], ['14:05'], ['23:57'], ['23:58'], ['23:59']]", "input_output_examples": "[[['13:34'], ['21:00'], ['11:15'], ['03:03'], ['14:30'], ['08:55'], ['00:00'], ['12:00']], [['tick'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['Fizz Buzz'], ['Fizz'], ['Cuckoo'], ['Buzz'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo']]]", "at_least_one_align": false}, "entry_point": "fizz_buzz_cuckoo_clock", "ground_truth": -1}
{"task_id": "TACO_lite/12", "requirement": "from typing import Tuple\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n\"\"\"A [Power Law](https://en.wikipedia.org/wiki/Power_law) distribution occurs whenever \"a relative change in one quantity results in a proportional relative change in the other quantity.\"\n\nTherefore, if I give you any pair of co-ordinates (x1,y1) and (x2,y2) in a power law distribution, you can plot the entire rest of the distribution and tell me the value of *y* for any other value of *x*. \n\nGiven a pair of co-ordinates (x1,y1) and (x2,y2) and another x co-ordinate *x3*, return the value of *y3*\n\n(x1,y1) and (x2,y2) will be given as arrays. Answer should be to the nearest integer, but random tests will give you leeway of 1% of the reference solution to account for possible discrepancies from different methods.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = round(y1 * (x3 / x1) ** alpha)\n    return y3", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = y1 * (x3 / x1) ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = y1 * (x3 / x1) ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = round(y1 * (x3 / x1) ** alpha)\n    return y3", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = y1 * (x3 / x1) ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    C = y1 / x1 ** alpha\n    y3 = C * x3 ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    C = y1 / x1 ** alpha\n    y3 = C * x3 ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    exponent = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = y1 * (x3 / x1) ** exponent\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = y1 * (x3 / x1) ** alpha\n    return round(y3)", "import math\nfrom typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        raise ValueError('x1 and x2 cannot be equal')\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = y1 * (x3 / x1) ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "import math\nfrom typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = y1 * (x3 / x1) ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    (x1, y1), (x2, y2) = (p1, p2)\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    C = y1 / x1 ** alpha\n    y3 = C * x3 ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = y1 * (x3 / x1) ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = y1 * (x3 / x1) ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "import math\nfrom typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        raise ValueError('x1 and x2 cannot be the same')\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    y3 = y1 * (x3 / x1) ** a\n    return round(y3)", "import math\nfrom typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    log_y1_y2 = math.log(y1 / y2)\n    log_x1_x2 = math.log(x1 / x2)\n    a = log_y1_y2 / log_x1_x2\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    y3_rounded = round(y3)\n    return y3_rounded", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "import math\nfrom typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        raise ValueError('x1 and x2 must be different for a valid power law.')\n    a = math.log(y1 / y2) / math.log(x1 / x2)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "import math\nfrom typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = math.log(y2 / y1) / math.log(x2 / x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    b = math.log(y2 / y1) / math.log(x2 / x1)\n    a = y1 / x1 ** b\n    y3 = a * x3 ** b\n    return round(y3)"], "requirement": [], "outputs": "[[6], [72], [4], [0], [17], [64], [0], [729], [10], [-216], [0]]", "probability": 0.72, "is_align_req": false, "DRS": null}, {"programs_str": ["import numpy as np\nfrom typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = (np.log(y2) - np.log(y1)) / (np.log(x2) - np.log(x1))\n    b = y1 / x1 ** a\n    y3 = b * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    log_y1 = math.log(y1)\n    log_y2 = math.log(y2)\n    log_x1 = math.log(x1)\n    log_x2 = math.log(x2)\n    a = (log_y2 - log_y1) / (log_x2 - log_x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    exponent = (math.log(y2) - math.log(y1)) / (math.log(x2) - math.log(x1))\n    constant = y1 / x1 ** exponent\n    y3 = constant * x3 ** exponent\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = (math.log(y2) - math.log(y1)) / (math.log(x2) - math.log(x1))\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == 0 or x2 == 0 or y1 == 0 or (y2 == 0):\n        raise ValueError('Coordinates cannot contain zero as it leads to undefined behavior in log.')\n    log_x1, log_x2 = (math.log(x1), math.log(x2))\n    log_y1, log_y2 = (math.log(y1), math.log(y2))\n    a = (log_y2 - log_y1) / (log_x2 - log_x1)\n    C = y1 / x1 ** a\n    y3 = C * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = (math.log(y2) - math.log(y1)) / (math.log(x2) - math.log(x1))\n    k = y1 / x1 ** alpha\n    y3 = k * x3 ** alpha\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2 or y1 <= 0 or y2 <= 0 or (x1 <= 0) or (x3 <= 0):\n        raise ValueError('Invalid coordinates for power law calculation.')\n    k = math.log(y2 / y1) / math.log(x2 / x1)\n    C = y1 / x1 ** k\n    y3 = C * x3 ** k\n    return round(y3)", "import math\nfrom typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    log_y1 = math.log(y1)\n    log_y2 = math.log(y2)\n    log_x1 = math.log(x1)\n    log_x2 = math.log(x2)\n    a = (log_y2 - log_y1) / (log_x2 - log_x1)\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\nimport math\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    \"\"\"\n    Calculate y3 for a given x3 in a power law distribution defined by two points.\n\n    Args:\n        p1 (Tuple[float, float]): First point (x1, y1)\n        p2 (Tuple[float, float]): Second point (x2, y2)\n        x3 (float): The x-coordinate for which to find the corresponding y-coordinate\n\n    Returns:\n        int: The nearest integer value of y3 for the given x3\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    log_y1 = math.log(y1)\n    log_y2 = math.log(y2)\n    log_x1 = math.log(x1)\n    log_x2 = math.log(x2)\n    if log_x2 == log_x1:\n        raise ValueError('The x-coordinates of p1 and p2 must be different.')\n    alpha = (log_y2 - log_y1) / (log_x2 - log_x1)\n    k = y1 / x1 ** alpha\n    y3 = k * x3 ** alpha\n    return round(y3)"], "requirement": [], "outputs": "[[6], [72], [4], [0], [17], [64], [0], [729], [10], ['ValueError'], [0]]", "probability": 0.18, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    a = (y2 / y1) ** (1 / (x2 / x1 - 1))\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)", "from typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        raise ValueError('x-coordinates of the given points cannot be the same.')\n    a = (y2 / y1) ** (1 / (x2 / x1 - 1))\n    k = y1 / x1 ** a\n    y3 = k * x3 ** a\n    return round(y3)"], "requirement": [], "outputs": "[[18], [648], [16], [354], [81], [1215], [0], [6561], [2], [-52488], [0]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    \"\"\"\n    Given two points (x1, y1) and (x2, y2) in a power law distribution, \n    this function calculates the value of y3 for a given x3.\n\n    Args:\n        p1 (Tuple[float, float]): The first point (x1, y1).\n        p2 (Tuple[float, float]): The second point (x2, y2).\n        x3 (float): The x-coordinate for which to find the corresponding y-coordinate.\n\n    Returns:\n        int: The nearest integer value of y3.\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = y2 / y1 / (x2 / x1)\n    if x1 == 0 or x2 == 0:\n        raise ValueError('x values cannot be zero.')\n    y3 = y1 * (x3 / x1) ** alpha\n    return round(y3)", "from typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    x1, y1 = p1\n    x2, y2 = p2\n    k = y2 / y1 / (x2 / x1)\n    if x1 == 0:\n        raise ValueError('x1 cannot be zero for a power law calculation.')\n    C = y1 / x1 ** k\n    y3 = C * x3 ** k\n    return round(y3)"], "requirement": [], "outputs": "[[6], [72], [4], [10], [16], [78], [0], [6561], [100000000000000000], [-648], [0]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import Tuple\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n    \"\"\"\n    Calculate the value of y3 for a given x3 in a power law distribution \n    defined by two points (x1, y1) and (x2, y2).\n\n    Args:\n    p1: A tuple containing the coordinates (x1, y1).\n    p2: A tuple containing the coordinates (x2, y2).\n    x3: The x-coordinate for which we need to find the corresponding y-coordinate.\n\n    Returns:\n    An integer representing the nearest integer value of y3.\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    alpha = (y2 / y1) ** (1 / (x2 - x1))\n    k = y1 / x1 ** alpha\n    y3 = k * x3 ** alpha\n    return round(y3)"], "requirement": [], "outputs": "[[18], [72], [256], [354], [29], [40], [0], [214], ['OverflowError'], ['TypeError'], [0]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 0.8809371713744317, "llm_generated_inputs": "[[(1.0, 2.0), (2.0, 4.0), 3.0], [(2.0, 8.0), (4.0, 32.0), 6.0], [(0.5, 1.0), (1.0, 2.0), 2.0], [(1.0, 10.0), (10.0, 1.0), 100.0], [(1.5, 3.0), (3.0, 9.0), 4.5], [(2.5, 5.0), (5.0, 25.0), 7.5], [(1.0, 1.0), (2.0, 2.0), 0.5], [(3.0, 9.0), (9.0, 81.0), 27.0], [(0.1, 0.001), (1.0, 0.1), 10.0], [(-2.0, -8.0), (-4.0, -64.0), -6.0], [(2.0, 0.25), (4.0, 0.0625), 8.0]]", "input_output_examples": "[[[[1, 120], [2, 60], 4]], [[30]]]", "at_least_one_align": false}, "entry_point": "power_law", "ground_truth": -1}
{"task_id": "TACO_lite/13", "requirement": "from typing import List\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n\"\"\"# Kata Task\n\nI have a cat and a dog.\n\nI got them at the same time as kitten/puppy. That was `humanYears` years ago.\n\nReturn their respective ages now as [`humanYears`,`catYears`,`dogYears`]\n\nNOTES:\n* humanYears >= 1\n* humanYears are whole numbers only\n\n## Cat Years\n\n* `15` cat years for first year\n* `+9` cat years for second year\n* `+4` cat years for each year after that\n\n## Dog Years\n\n* `15` dog years for first year\n* `+9` dog years for second year\n* `+5` dog years for each year after that\n\n\n\n**References**\n\n* http://www.catster.com/cats-101/calculate-cat-age-in-cat-years\n* http://www.slate.com/articles/news_and_politics/explainer/2009/05/a_dogs_life.html\n\n\n\nIf you liked this Kata there is another related one here\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        cat_years += (x - 2) * 4\n        dog_years += (x - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        additional_years = human_years - 2\n        cat_years += additional_years * 4\n        dog_years += additional_years * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        cat_years += (x - 2) * 4\n        dog_years += (x - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n    if x >= 2:\n        cat_years += 9\n        for year in range(2, x):\n            cat_years += 4\n    if x >= 1:\n        dog_years += 15\n    if x >= 2:\n        dog_years += 9\n        for year in range(2, x):\n            dog_years += 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        cat_years += (x - 2) * 4\n        dog_years += (x - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        cat_years += (x - 2) * 4\n        dog_years += (x - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        additional_years = x - 2\n        cat_years += additional_years * 4\n        dog_years += additional_years * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        cat_years += (x - 2) * 4\n        dog_years += (x - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(humanYears: int) -> List[int]:\n    catYears = 0\n    dogYears = 0\n    if humanYears >= 1:\n        catYears += 15\n        dogYears += 15\n    if humanYears >= 2:\n        catYears += 9\n        dogYears += 9\n    if humanYears > 2:\n        catYears += (humanYears - 2) * 4\n        dogYears += (humanYears - 2) * 5\n    return [humanYears, catYears, dogYears]"], "requirement": [], "outputs": "[[[1, 15, 15]], [[2, 24, 24]], [[5, 36, 39]], [[10, 56, 64]], [[12, 64, 74]], [[15, 76, 89]], [[20, 96, 114]], [[0, 0, 0]], [[-3, 0, 0]], [[1.5, 15, 15]]]", "probability": 0.24, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        return [0, 0, 0]\n    human_years = x\n    cat_years = 15 + (9 if x > 1 else 0) + 4 * max(0, x - 2)\n    dog_years = 15 + (9 if x > 1 else 0) + 5 * max(0, x - 2)\n    return [human_years, cat_years, dog_years]"], "requirement": [], "outputs": "[[[1, 15, 15]], [[2, 24, 24]], [[5, 36, 39]], [[10, 56, 64]], [[12, 64, 74]], [[15, 76, 89]], [[20, 96, 114]], [[0, 0, 0]], [[0, 0, 0]], [[1.5, 24, 24]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        raise ValueError('humanYears must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        additional_years = x - 2\n        cat_years += additional_years * 4\n        dog_years += additional_years * 5\n    return [x, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        raise ValueError('humanYears must be at least 1')\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        cat_years += (x - 2) * 4\n        dog_years += (x - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        catYears_after_two = (human_years - 2) * 4\n        dogYears_after_two = (human_years - 2) * 5\n        cat_years += catYears_after_two\n        dog_years += dogYears_after_two\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('humanYears must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n    if human_years >= 2:\n        cat_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n    if human_years >= 1:\n        dog_years += 15\n    if human_years >= 2:\n        dog_years += 9\n    if human_years > 2:\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(humanYears: int) -> List[int]:\n    if humanYears < 1:\n        raise ValueError('humanYears must be at least 1')\n    catYears = 0\n    dogYears = 0\n    if humanYears >= 1:\n        catYears += 15\n        dogYears += 15\n    if humanYears >= 2:\n        catYears += 9\n        dogYears += 9\n    if humanYears > 2:\n        catYears += (humanYears - 2) * 4\n        dogYears += (humanYears - 2) * 5\n    return [humanYears, catYears, dogYears]", "from typing import List\n\ndef human_years_cat_years_dog_years(humanYears: int) -> List[int]:\n    if humanYears < 1:\n        raise ValueError('humanYears must be greater than or equal to 1')\n    catYears = 0\n    dogYears = 0\n    if humanYears >= 1:\n        catYears += 15\n        dogYears += 15\n    if humanYears >= 2:\n        catYears += 9\n        dogYears += 9\n    if humanYears > 2:\n        catYears += (humanYears - 2) * 4\n        dogYears += (humanYears - 2) * 5\n    return [humanYears, catYears, dogYears]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        additional_years = human_years - 2\n        cat_years += additional_years * 4\n        dog_years += additional_years * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(humanYears: int) -> List[int]:\n    if humanYears < 1:\n        raise ValueError('humanYears must be at least 1')\n    catYears = 0\n    dogYears = 0\n    if humanYears >= 1:\n        catYears += 15\n        dogYears += 15\n    if humanYears >= 2:\n        catYears += 9\n        dogYears += 9\n    if humanYears > 2:\n        catYears += (humanYears - 2) * 4\n        dogYears += (humanYears - 2) * 5\n    return [humanYears, catYears, dogYears]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        additional_years = human_years - 2\n        cat_years += additional_years * 4\n        dog_years += additional_years * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be greater than or equal to 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n    if human_years >= 2:\n        cat_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n    if human_years >= 1:\n        dog_years += 15\n    if human_years >= 2:\n        dog_years += 9\n    if human_years > 2:\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(humanYears: int) -> List[int]:\n    if humanYears < 1:\n        raise ValueError('humanYears must be at least 1')\n    catYears = 0\n    dogYears = 0\n    if humanYears >= 1:\n        catYears += 15\n    if humanYears >= 2:\n        catYears += 9\n    if humanYears > 2:\n        catYears += (humanYears - 2) * 4\n    if humanYears >= 1:\n        dogYears += 15\n    if humanYears >= 2:\n        dogYears += 9\n    if humanYears > 2:\n        dogYears += (humanYears - 2) * 5\n    return [humanYears, catYears, dogYears]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be greater than or equal to 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]"], "requirement": [], "outputs": "[[[1, 15, 15]], [[2, 24, 24]], [[5, 36, 39]], [[10, 56, 64]], [[12, 64, 74]], [[15, 76, 89]], [[20, 96, 114]], ['ValueError'], ['ValueError'], [[1.5, 15, 15]]]", "probability": 0.32, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        return [0, 0, 0]\n    humanYears = x\n    catYears = 15\n    dogYears = 15\n    if x >= 2:\n        catYears += 9\n        dogYears += 9\n    if x > 2:\n        catYears += (x - 2) * 4\n        dogYears += (x - 2) * 5\n    return [humanYears, catYears, dogYears]", "from typing import List\n\ndef human_years_cat_years_dog_years(humanYears: int) -> List[int]:\n    if humanYears < 1:\n        return [0, 0, 0]\n    catYears = 15\n    dogYears = 15\n    if humanYears >= 2:\n        catYears += 9\n        dogYears += 9\n    if humanYears > 2:\n        catYears += (humanYears - 2) * 4\n        dogYears += (humanYears - 2) * 5\n    return [humanYears, catYears, dogYears]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        return [0, 0, 0]\n    cat_years = 15\n    dog_years = 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        return [0, 0, 0]\n    cat_years = 15\n    dog_years = 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        return [0, 0, 0]\n    cat_years = 15\n    dog_years = 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        return [0, 0, 0]\n    cat_years = 15\n    dog_years = 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        return [0, 0, 0]\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        return [0, 0, 0]\n    cat_years = 15\n    dog_years = 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n    if human_years > 2:\n        cat_years += (human_years - 2) * 4\n        dog_years += (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        return [0, 0, 0]\n    human_years = x\n    cat_years = 15\n    dog_years = 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        cat_years += (x - 2) * 4\n        dog_years += (x - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        return [0, 0, 0]\n    cat_years = 15\n    dog_years = 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        cat_years += (x - 2) * 4\n        dog_years += (x - 2) * 5\n    return [x, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        return [0, 0, 0]\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n    if x > 2:\n        cat_years += (x - 2) * 4\n        dog_years += (x - 2) * 5\n    return [human_years, cat_years, dog_years]"], "requirement": [], "outputs": "[[[1, 15, 15]], [[2, 24, 24]], [[5, 36, 39]], [[10, 56, 64]], [[12, 64, 74]], [[15, 76, 89]], [[20, 96, 114]], [[0, 0, 0]], [[0, 0, 0]], [[1.5, 15, 15]]]", "probability": 0.22, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        raise ValueError('humanYears must be at least 1')\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n        x -= 2\n    cat_years += x * 4\n    dog_years += x * 5\n    return [human_years, cat_years, dog_years]"], "requirement": [], "outputs": "[[[1, 19, 20]], [[2, 24, 24]], [[5, 36, 39]], [[10, 56, 64]], [[12, 64, 74]], [[15, 76, 89]], [[20, 96, 114]], ['ValueError'], ['ValueError'], [[1.5, 21.0, 22.5]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x == 1:\n        cat_years = 15\n        dog_years = 15\n    elif x == 2:\n        cat_years = 15 + 9\n        dog_years = 15 + 9\n    elif x > 2:\n        cat_years = 15 + 9 + (x - 2) * 4\n        dog_years = 15 + 9 + (x - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x == 1:\n        cat_years = 15\n        dog_years = 15\n    elif x == 2:\n        cat_years = 24\n        dog_years = 24\n    elif x > 2:\n        cat_years = 24 + (x - 2) * 4\n        dog_years = 24 + (x - 2) * 5\n    return [human_years, cat_years, dog_years]"], "requirement": [], "outputs": "[[[1, 15, 15]], [[2, 24, 24]], [[5, 36, 39]], [[10, 56, 64]], [[12, 64, 74]], [[15, 76, 89]], [[20, 96, 114]], [[0, 0, 0]], [[-3, 0, 0]], [[1.5, 0, 0]]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x >= 1:\n        cat_years += 15\n        dog_years += 15\n    if x >= 2:\n        cat_years += 9\n        dog_years += 9\n        x -= 2\n    else:\n        x -= 1\n    cat_years += 4 * x\n    dog_years += 5 * x\n    return [human_years, cat_years, dog_years]"], "requirement": [], "outputs": "[[[1, 15, 15]], [[2, 24, 24]], [[5, 36, 39]], [[10, 56, 64]], [[12, 64, 74]], [[15, 76, 89]], [[20, 96, 114]], [[0, -4, -5]], [[-3, -16, -20]], [[1.5, 17.0, 17.5]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be greater than or equal to 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years == 1:\n        cat_years = 15\n        dog_years = 15\n    elif human_years == 2:\n        cat_years = 24\n        dog_years = 24\n    else:\n        cat_years = 24 + (human_years - 2) * 4\n        dog_years = 24 + (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years == 1:\n        cat_years = 15\n        dog_years = 15\n    elif human_years == 2:\n        cat_years = 15 + 9\n        dog_years = 15 + 9\n    else:\n        cat_years = 15 + 9 + (human_years - 2) * 4\n        dog_years = 15 + 9 + (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    if human_years < 1:\n        raise ValueError('human_years must be at least 1')\n    cat_years = 0\n    dog_years = 0\n    if human_years == 1:\n        cat_years = 15\n        dog_years = 15\n    elif human_years == 2:\n        cat_years = 15 + 9\n        dog_years = 15 + 9\n    else:\n        cat_years = 15 + 9 + (human_years - 2) * 4\n        dog_years = 15 + 9 + (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        raise ValueError('humanYears must be greater than or equal to 1')\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x == 1:\n        cat_years = 15\n    elif x == 2:\n        cat_years = 15 + 9\n    else:\n        cat_years = 15 + 9 + (x - 2) * 4\n    if x == 1:\n        dog_years = 15\n    elif x == 2:\n        dog_years = 15 + 9\n    else:\n        dog_years = 15 + 9 + (x - 2) * 5\n    return [human_years, cat_years, dog_years]", "from typing import List\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n    if x < 1:\n        raise ValueError('humanYears must be at least 1')\n    human_years = x\n    cat_years = 0\n    dog_years = 0\n    if x == 1:\n        cat_years = 15\n        dog_years = 15\n    elif x == 2:\n        cat_years = 15 + 9\n        dog_years = 15 + 9\n    else:\n        cat_years = 15 + 9 + (x - 2) * 4\n        dog_years = 15 + 9 + (x - 2) * 5\n    return [human_years, cat_years, dog_years]"], "requirement": [], "outputs": "[[[1, 15, 15]], [[2, 24, 24]], [[5, 36, 39]], [[10, 56, 64]], [[12, 64, 74]], [[15, 76, 89]], [[20, 96, 114]], ['ValueError'], ['ValueError'], [[1.5, 22.0, 21.5]]]", "probability": 0.1, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    cat_years = 0\n    dog_years = 0\n    if human_years >= 1:\n        cat_years += 15\n        dog_years += 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n        human_years -= 2\n    else:\n        human_years -= 1\n    cat_years += human_years * 4\n    dog_years += human_years * 5\n    return [human_years + 1, cat_years, dog_years]"], "requirement": [], "outputs": "[[[1, 15, 15]], [[1, 24, 24]], [[4, 36, 39]], [[9, 56, 64]], [[11, 64, 74]], [[14, 76, 89]], [[19, 96, 114]], [[0, -4, -5]], [[-3, -16, -20]], [[1.5, 17.0, 17.5]]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.7122103798808466, "llm_generated_inputs": "[[1], [2], [5], [10], [12], [15], [20], [0], [-3], [1.5]]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "human_years_cat_years_dog_years", "ground_truth": -1}
{"task_id": "TACO_lite/14", "requirement": "from typing import List\ndef solve(lst: List[int]) -> str:\n\"\"\"In this Kata, you will be given an array and your task will be to determine if an array is in ascending or descending order and if it is rotated or not. \n\nArrays will never be unsorted, except for those that are rotated as shown above. Arrays will always have an answer.\n\nGood luck!\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(lst):\n            return 'rotated ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(lst, reverse=True):\n            return 'rotated descending'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(rotated_lst):\n            return 'rotated ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(rotated_lst, reverse=True):\n            return 'rotated descending'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(rotated_lst):\n            return 'rotated ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(rotated_lst, reverse=True):\n            return 'rotated descending'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n\n    def is_sorted(arr, key=lambda x: x):\n        for i in range(len(arr) - 1):\n            if key(arr[i]) > key(arr[i + 1]):\n                return False\n        return True\n\n    def is_rotated(arr, asc=True):\n        if asc:\n            sorted_lst = sorted(arr)\n        else:\n            sorted_lst = sorted(arr, reverse=True)\n        n = len(arr)\n        for i in range(n):\n            rotated_lst = arr[i:] + arr[:i]\n            if rotated_lst == sorted_lst:\n                return True\n        return False\n    if is_sorted(lst):\n        return 'ascending'\n    elif is_sorted(lst, key=lambda x: -x):\n        return 'descending'\n    elif is_rotated(lst):\n        return 'rotated ascending'\n    elif is_rotated(lst, asc=False):\n        return 'rotated descending'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    for i in range(len(lst)):\n        rotated = lst[i:] + lst[:i]\n        if rotated == sorted(lst):\n            return 'rotated ascending'\n    for i in range(len(lst)):\n        rotated = lst[i:] + lst[:i]\n        if rotated == sorted(lst, reverse=True):\n            return 'rotated descending'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(lst):\n            return 'rotated ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(lst, reverse=True):\n            return 'rotated descending'"], "requirement": [], "outputs": "[['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], [None], ['rotated ascending'], ['rotated ascending'], ['ascending'], ['ascending'], ['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], [None], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending']]", "probability": 0.12, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    rotated_lst = lst * 2\n    for i in range(len(lst)):\n        if rotated_lst[i:i + len(lst)] == sorted(lst):\n            return 'rotated ascending'\n    for i in range(len(lst)):\n        if rotated_lst[i:i + len(lst)] == sorted(lst, reverse=True):\n            return 'rotated descending'\n    return 'unsorted'"], "requirement": [], "outputs": "[['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['unsorted'], ['rotated ascending'], ['rotated ascending'], ['ascending'], ['ascending'], ['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['unsorted'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    min_value_index = lst.index(min(lst))\n    rotated_lst = lst[min_value_index:] + lst[:min_value_index]\n    if rotated_lst == sorted(rotated_lst):\n        return 'rotated ascending'\n    max_value_index = lst.index(max(lst))\n    rotated_lst = lst[max_value_index:] + lst[:max_value_index]\n    if rotated_lst == sorted(rotated_lst, reverse=True):\n        return 'rotated descending'\n    raise ValueError('Array does not match any expected pattern')", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    n = len(lst)\n    min_index = lst.index(min(lst))\n    rotated_ascending = lst[min_index:] + lst[:min_index]\n    if rotated_ascending == sorted(lst):\n        return 'rotated ascending'\n    max_index = lst.index(max(lst))\n    rotated_descending = lst[max_index:] + lst[:max_index]\n    if rotated_descending == sorted(lst, reverse=True):\n        return 'rotated descending'\n    raise ValueError('The array does not match any of the expected patterns (this should not occur).')", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(rotated_lst):\n            return 'rotated ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(rotated_lst, reverse=True):\n            return 'rotated descending'\n    raise ValueError('Array does not match any expected pattern')", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1))):\n        return 'ascending'\n    if all((lst[i] >= lst[i + 1] for i in range(len(lst) - 1))):\n        return 'descending'\n    min_element_index = lst.index(min(lst))\n    part1 = lst[min_element_index:] + lst[:min_element_index]\n    if all((part1[i] <= part1[i + 1] for i in range(len(part1) - 1))):\n        return 'rotated ascending'\n    elif all((part1[i] >= part1[i + 1] for i in range(len(part1) - 1))):\n        return 'rotated descending'\n    raise ValueError('Invalid array configuration')", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    min_val = min(lst)\n    min_index = lst.index(min_val)\n    rotated_ascending = lst[min_index:] + lst[:min_index]\n    if rotated_ascending == sorted(lst):\n        return 'rotated ascending'\n    max_val = max(lst)\n    max_index = lst.index(max_val)\n    rotated_descending = lst[max_index:] + lst[:max_index]\n    if rotated_descending == sorted(lst, reverse=True):\n        return 'rotated descending'\n    raise ValueError('The input array does not match any defined order or rotation.')"], "requirement": [], "outputs": "[['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['ValueError'], ['rotated ascending'], ['rotated ascending'], ['ascending'], ['ascending'], ['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['ValueError'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending']]", "probability": 0.1, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(rotated_lst):\n            return 'rotated ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(rotated_lst, reverse=True):\n            return 'rotated descending'\n    return 'unsorted or invalid'"], "requirement": [], "outputs": "[['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['unsorted or invalid'], ['rotated ascending'], ['rotated ascending'], ['ascending'], ['ascending'], ['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['unsorted or invalid'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'Ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'Descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(rotated_lst):\n            return 'Rotated Ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(rotated_lst, reverse=True):\n            return 'Rotated Descending'\n    return 'Unknown'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'Ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'Descending'\n    min_val = min(lst)\n    min_idx = lst.index(min_val)\n    rotated_lst = lst[min_idx:] + lst[:min_idx]\n    if rotated_lst == sorted(rotated_lst):\n        return 'Rotated Ascending'\n    rotated_lst_desc = lst[min_idx:] + lst[:min_idx]\n    if rotated_lst_desc == sorted(rotated_lst_desc, reverse=True):\n        return 'Rotated Descending'\n    return 'Unknown'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    min_val_index = lst.index(min(lst))\n    rotated_lst = lst[min_val_index:] + lst[:min_val_index]\n    is_rotated_ascending = all((x <= y for x, y in zip(rotated_lst, rotated_lst[1:])))\n    max_val_index = lst.index(max(lst))\n    rotated_lst_desc = lst[max_val_index:] + lst[:max_val_index]\n    is_rotated_descending = all((x >= y for x, y in zip(rotated_lst_desc, rotated_lst_desc[1:])))\n    if is_ascending:\n        return 'Ascending'\n    elif is_descending:\n        return 'Descending'\n    elif is_rotated_ascending:\n        return 'Rotated Ascending'\n    elif is_rotated_descending:\n        return 'Rotated Descending'\n    else:\n        return 'Unknown'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    \"\"\"\n    Determines if an array is in ascending or descending order and if it is rotated.\n\n    Args:\n    lst (List[int]): The input list of integers.\n\n    Returns:\n    str: A string indicating the order and rotation status.\n    \"\"\"\n    if lst == sorted(lst):\n        return 'Ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'Descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(lst):\n            return 'Rotated Ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(lst, reverse=True):\n            return 'Rotated Descending'\n    return 'Unknown'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    \"\"\"\n    Determines if an array is in ascending or descending order and if it is rotated.\n    \n    Args:\n        lst (List[int]): The input list of integers.\n    \n    Returns:\n        str: A string indicating whether the list is \"Ascending\", \"Descending\", \n             \"Rotated Ascending\", or \"Rotated Descending\".\n    \"\"\"\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    if is_ascending:\n        return 'Ascending'\n    elif is_descending:\n        return 'Descending'\n    rotated_lst = lst + lst\n    n = len(lst)\n    for i in range(1, n):\n        if all((rotated_lst[i + j] <= rotated_lst[i + j + 1] for j in range(n - 1))):\n            return 'Rotated Ascending'\n    for i in range(1, n):\n        if all((rotated_lst[i + j] >= rotated_lst[i + j + 1] for j in range(n - 1))):\n            return 'Rotated Descending'\n    return 'Unknown'"], "requirement": [], "outputs": "[['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['Unknown'], ['Rotated Ascending'], ['Rotated Ascending'], ['Ascending'], ['Ascending'], ['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['Unknown'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending']]", "probability": 0.1, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    min_index = lst.index(min(lst)) if is_ascending else lst.index(max(lst))\n    rotated_lst = lst[min_index:] + lst[:min_index]\n    is_rotated_ascending = rotated_lst == sorted(lst)\n    is_rotated_descending = rotated_lst[::-1] == sorted(lst)\n    if is_ascending:\n        return 'Ascending'\n    elif is_descending:\n        return 'Descending'\n    elif is_rotated_ascending:\n        return 'Rotated Ascending'\n    elif is_rotated_descending:\n        return 'Rotated Descending'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    if is_ascending:\n        for i in range(len(lst) - 1):\n            if lst[i] > lst[i + 1]:\n                return 'Rotated Ascending'\n        return 'Ascending'\n    if is_descending:\n        for i in range(len(lst) - 1):\n            if lst[i] < lst[i + 1]:\n                return 'Rotated Descending'\n        return 'Descending'"], "requirement": [], "outputs": "[['Ascending'], [None], [None], ['Descending'], [None], [None], [None], ['Ascending'], ['Ascending'], ['Ascending'], [None], [None], ['Descending'], [None], [None], [None], [None], [None], [None], [None]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if len(lst) <= 1:\n        return 'Ascending'\n    sorted_lst = sorted(lst)\n    if lst == sorted_lst:\n        return 'Ascending'\n    if lst == sorted_lst[::-1]:\n        return 'Descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted_lst:\n            return 'Rotated Ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted_lst[::-1]:\n            return 'Rotated Descending'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    min_index = lst.index(min(lst))\n    rotated_ascending = all((x <= y for x, y in zip(lst[min_index:] + lst[:min_index], (lst[min_index:] + lst[:min_index])[1:]))) if not ascending else False\n    rotated_descending = all((x >= y for x, y in zip(lst[min_index:] + lst[:min_index], (lst[min_index:] + lst[:min_index])[1:]))) if not descending else False\n    if ascending:\n        return 'Ascending'\n    elif descending:\n        return 'Descending'\n    elif rotated_ascending:\n        return 'Rotated Ascending'\n    elif rotated_descending:\n        return 'Rotated Descending'"], "requirement": [], "outputs": "[['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], [None], ['Rotated Ascending'], ['Rotated Ascending'], ['Ascending'], ['Ascending'], ['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], [None], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n\n    def is_rotated_sorted(lst):\n        count = 0\n        n = len(lst)\n        for i in range(n):\n            if lst[i] > lst[(i + 1) % n]:\n                count += 1\n        return count <= 1\n    result = []\n    if is_ascending:\n        result.append('ascending')\n    elif is_descending:\n        result.append('descending')\n    if is_rotated_sorted(lst):\n        result.append('rotated')\n    return ' '.join(result) or 'sorted'"], "requirement": [], "outputs": "[['ascending rotated'], ['rotated'], ['rotated'], ['descending'], ['sorted'], ['rotated'], ['rotated'], ['ascending rotated'], ['ascending rotated'], ['ascending rotated'], ['rotated'], ['rotated'], ['descending'], ['sorted'], ['rotated'], ['rotated'], ['rotated'], ['rotated'], ['rotated'], ['rotated']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1))):\n        return 'Ascending'\n    if all((lst[i] >= lst[i + 1] for i in range(len(lst) - 1))):\n        return 'Descending'\n    min_val = min(lst)\n    min_index = lst.index(min_val)\n    rotated_ascending = lst[min_index:] + lst[:min_index]\n    if all((rotated_ascending[i] <= rotated_ascending[i + 1] for i in range(len(rotated_ascending) - 1))):\n        return 'Rotated Ascending'\n    max_val = max(lst)\n    max_index = lst.index(max_val)\n    rotated_descending = lst[max_index:] + lst[:max_index]\n    if all((rotated_descending[i] >= rotated_descending[i + 1] for i in range(len(rotated_descending) - 1))):\n        return 'Rotated Descending'\n    raise ValueError('Invalid input array configuration')", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'Ascending'\n    elif lst == sorted(lst, reverse=True):\n        return 'Descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(lst):\n            return 'Rotated Ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted(lst, reverse=True):\n            return 'Rotated Descending'\n    raise ValueError('Unexpected situation: Array does not match any pattern')", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    sorted_lst_asc = sorted(lst)\n    sorted_lst_desc = sorted(lst, reverse=True)\n    rotated_asc = any((lst[i:] + lst[:i] == sorted_lst_asc for i in range(len(lst))))\n    rotated_desc = any((lst[i:] + lst[:i] == sorted_lst_desc for i in range(len(lst))))\n    if is_ascending:\n        return 'Ascending'\n    elif is_descending:\n        return 'Descending'\n    elif rotated_asc:\n        return 'Rotated Ascending'\n    elif rotated_desc:\n        return 'Rotated Descending'\n    else:\n        raise ValueError('Array appears to be unsorted and not rotated.')", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    if is_ascending and lst == sorted(lst):\n        return 'Ascending'\n    elif is_descending and lst == sorted(lst, reverse=True):\n        return 'Descending'\n    sorted_lst = sorted(lst)\n    n = len(lst)\n    for i in range(n):\n        if lst == sorted_lst[i:] + sorted_lst[:i]:\n            return 'Rotated Ascending'\n    sorted_lst_desc = sorted(lst, reverse=True)\n    for i in range(n):\n        if lst == sorted_lst_desc[i:] + sorted_lst_desc[:i]:\n            return 'Rotated Descending'\n    raise ValueError('Unexpected condition encountered')"], "requirement": [], "outputs": "[['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['ValueError'], ['Rotated Ascending'], ['Rotated Ascending'], ['Ascending'], ['Ascending'], ['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['ValueError'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending']]", "probability": 0.08, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    if is_ascending:\n        for i in range(len(lst) - 1):\n            if lst[i] > lst[i + 1]:\n                return 'Rotated Ascending'\n        return 'Ascending'\n    if is_descending:\n        for i in range(len(lst) - 1):\n            if lst[i] < lst[i + 1]:\n                return 'Rotated Descending'\n        return 'Descending'\n    raise ValueError('Array is unsorted and not following any specified pattern')"], "requirement": [], "outputs": "[['Ascending'], ['ValueError'], ['ValueError'], ['Descending'], ['ValueError'], ['ValueError'], ['ValueError'], ['Ascending'], ['Ascending'], ['Ascending'], ['ValueError'], ['ValueError'], ['Descending'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    sorted_ascending = sorted(lst)\n    sorted_descending = sorted(lst, reverse=True)\n    if lst == sorted_ascending and is_ascending:\n        return 'Ascending'\n    elif lst == sorted_descending and is_descending:\n        return 'Descending'\n    elif lst in [sorted_ascending[i:] + sorted_ascending[:i] for i in range(len(lst))]:\n        return 'Rotated Ascending'\n    elif lst in [sorted_descending[i:] + sorted_descending[:i] for i in range(len(lst))]:\n        return 'Rotated Descending'\n    else:\n        return 'Unidentified Pattern'"], "requirement": [], "outputs": "[['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['Unidentified Pattern'], ['Rotated Ascending'], ['Rotated Ascending'], ['Ascending'], ['Ascending'], ['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['Unidentified Pattern'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1))):\n        return 'ascending'\n    if all((lst[i] >= lst[i + 1] for i in range(len(lst) - 1))):\n        return 'descending'\n    for i in range(1, len(lst)):\n        if lst[i - 1] > lst[i]:\n            first_half = lst[:i]\n            second_half = lst[i:]\n            if all((first_half[j] <= first_half[j + 1] for j in range(len(first_half) - 1))) and all((second_half[j] <= second_half[j + 1] for j in range(len(second_half) - 1))):\n                return 'rotated ascending'\n            if all((first_half[j] >= first_half[j + 1] for j in range(len(first_half) - 1))) and all((second_half[j] >= second_half[j + 1] for j in range(len(second_half) - 1))):\n                return 'rotated descending'\n    return 'error'"], "requirement": [], "outputs": "[['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['ascending'], ['ascending'], ['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if len(lst) <= 1:\n        return 'The list is too small to determine order or rotation.'\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    if is_ascending and (not is_descending):\n        return 'Ascending'\n    elif is_descending and (not is_ascending):\n        return 'Descending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if all((x <= y for x, y in zip(rotated_lst, rotated_lst[1:]))):\n            return 'Rotated Ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if all((x >= y for x, y in zip(rotated_lst, rotated_lst[1:]))):\n            return 'Rotated Descending'\n    return 'Unknown (This case should not occur)'"], "requirement": [], "outputs": "[['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['Unknown (This case should not occur)'], ['Rotated Ascending'], ['Rotated Ascending'], ['The list is too small to determine order or rotation.'], ['Rotated Ascending'], ['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['Unknown (This case should not occur)'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    sorted_lst = sorted(lst)\n    is_rotated_ascending = any((lst[i:] + lst[:i] == sorted_lst for i in range(len(lst))))\n    sorted_lst_desc = sorted(lst, reverse=True)\n    is_rotated_descending = any((lst[i:] + lst[:i] == sorted_lst_desc for i in range(len(lst))))\n    if is_ascending:\n        return 'Array is in ascending order.'\n    elif is_descending:\n        return 'Array is in descending order.'\n    elif is_rotated_ascending:\n        return 'Array is rotated and was originally in ascending order.'\n    elif is_rotated_descending:\n        return 'Array is rotated and was originally in descending order.'"], "requirement": [], "outputs": "[['Array is in ascending order.'], ['Array is rotated and was originally in ascending order.'], ['Array is rotated and was originally in ascending order.'], ['Array is in descending order.'], [None], ['Array is rotated and was originally in ascending order.'], ['Array is rotated and was originally in ascending order.'], ['Array is in ascending order.'], ['Array is in ascending order.'], ['Array is in ascending order.'], ['Array is rotated and was originally in ascending order.'], ['Array is rotated and was originally in ascending order.'], ['Array is in descending order.'], [None], ['Array is rotated and was originally in ascending order.'], ['Array is rotated and was originally in ascending order.'], ['Array is rotated and was originally in ascending order.'], ['Array is rotated and was originally in ascending order.'], ['Array is rotated and was originally in ascending order.'], ['Array is rotated and was originally in ascending order.']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    sorted_lst = sorted(lst)\n    reversed_lst = sorted(lst, reverse=True)\n    rotated_ascending = any((lst[i:] + lst[:i] == sorted_lst for i in range(len(lst))))\n    rotated_descending = any((lst[i:] + lst[:i] == reversed_lst for i in range(len(lst))))\n    if is_ascending:\n        return 'Sorted in ascending order'\n    elif is_descending:\n        return 'Sorted in descending order'\n    elif rotated_ascending:\n        return 'Rotated and sorted in ascending order'\n    elif rotated_descending:\n        return 'Rotated and sorted in descending order'\n    else:\n        raise ValueError('Unexpected unsorted array encountered')"], "requirement": [], "outputs": "[['Sorted in ascending order'], ['Rotated and sorted in ascending order'], ['Rotated and sorted in ascending order'], ['Sorted in descending order'], ['ValueError'], ['Rotated and sorted in ascending order'], ['Rotated and sorted in ascending order'], ['Sorted in ascending order'], ['Sorted in ascending order'], ['Sorted in ascending order'], ['Rotated and sorted in ascending order'], ['Rotated and sorted in ascending order'], ['Sorted in descending order'], ['ValueError'], ['Rotated and sorted in ascending order'], ['Rotated and sorted in ascending order'], ['Rotated and sorted in ascending order'], ['Rotated and sorted in ascending order'], ['Rotated and sorted in ascending order'], ['Rotated and sorted in ascending order']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    if is_ascending and (not is_descending):\n        sorted_lst = sorted(lst)\n        n = len(lst)\n        for i in range(n):\n            if lst == sorted_lst[i:] + sorted_lst[:i]:\n                return 'Rotated Ascending'\n        return 'Ascending'\n    elif is_descending and (not is_ascending):\n        sorted_lst = sorted(lst, reverse=True)\n        n = len(lst)\n        for i in range(n):\n            if lst == sorted_lst[i:] + sorted_lst[:i]:\n                return 'Rotated Descending'\n        return 'Descending'\n    elif is_ascending and is_descending:\n        return 'Ascending' if lst == sorted(lst) else 'Descending'"], "requirement": [], "outputs": "[['Rotated Ascending'], [None], [None], ['Rotated Descending'], [None], [None], [None], ['Ascending'], ['Ascending'], ['Rotated Ascending'], [None], [None], ['Rotated Descending'], [None], [None], [None], [None], [None], [None], [None]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1)))\n    is_descending = all((lst[i] >= lst[i + 1] for i in range(len(lst) - 1)))\n    if is_ascending or is_descending:\n        return 'Sorted'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if all((rotated_lst[j] <= rotated_lst[j + 1] for j in range(len(rotated_lst) - 1))):\n            return 'Rotated Ascending'\n    for i in range(len(lst)):\n        rotated_lst = lst[i:] + lst[:i]\n        if all((rotated_lst[j] >= rotated_lst[j + 1] for j in range(len(rotated_lst) - 1))):\n            return 'Rotated Descending'\n    return 'Error: No valid solution found'"], "requirement": [], "outputs": "[['Sorted'], ['Rotated Ascending'], ['Rotated Ascending'], ['Sorted'], ['Error: No valid solution found'], ['Rotated Ascending'], ['Rotated Ascending'], ['Sorted'], ['Sorted'], ['Sorted'], ['Rotated Ascending'], ['Rotated Ascending'], ['Sorted'], ['Error: No valid solution found'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    \"\"\"\n    Determines if an array is in ascending or descending order and if it is rotated.\n    \n    Args:\n        lst (List[int]): The input list of integers.\n    \n    Returns:\n        str: A string describing the order and rotation status of the list.\n    \"\"\"\n    if lst == sorted(lst):\n        return 'ascending'\n    elif lst == sorted(lst, reverse=True):\n        return 'descending'\n    n = len(lst)\n    sorted_lst = sorted(lst)\n    for i in range(n):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted_lst:\n            return 'ascending, rotated'\n        if rotated_lst == sorted(lst, reverse=True):\n            return 'descending, rotated'\n    return 'unsorted'"], "requirement": [], "outputs": "[['ascending'], ['ascending, rotated'], ['ascending, rotated'], ['descending'], ['unsorted'], ['ascending, rotated'], ['ascending, rotated'], ['ascending'], ['ascending'], ['ascending'], ['ascending, rotated'], ['ascending, rotated'], ['descending'], ['unsorted'], ['ascending, rotated'], ['ascending, rotated'], ['ascending, rotated'], ['ascending, rotated'], ['ascending, rotated'], ['ascending, rotated']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    n = len(lst)\n    for i in range(1, n):\n        rotated = lst[i:] + lst[:i]\n        if rotated == sorted(lst):\n            return 'rotated ascending'\n        if rotated == sorted(lst, reverse=True):\n            return 'rotated descending'\n    return 'unknown'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    sorted_lst = sorted(lst)\n    n = len(lst)\n    for i in range(n):\n        if lst == sorted_lst[i:] + sorted_lst[:i]:\n            return 'rotated ascending'\n    sorted_lst_desc = sorted(lst, reverse=True)\n    for i in range(n):\n        if lst == sorted_lst_desc[i:] + sorted_lst_desc[:i]:\n            return 'rotated descending'\n    return 'unknown'", "from typing import List\n\ndef solve(lst: List[int]) -> str:\n    \"\"\"\n    Determines if an array is in ascending or descending order and if it is rotated.\n    \n    Parameters:\n    lst (List[int]): The input list of integers.\n    \n    Returns:\n    str: A string indicating whether the list is 'ascending', 'descending', \n         'rotated ascending', 'rotated descending', or 'unknown'.\n    \"\"\"\n    if lst == sorted(lst):\n        return 'ascending'\n    if lst == sorted(lst, reverse=True):\n        return 'descending'\n    rotated_ascending = False\n    min_val = min(lst)\n    min_idx = lst.index(min_val)\n    rotated_lst = lst[min_idx:] + lst[:min_idx]\n    if rotated_lst == sorted(lst):\n        rotated_ascending = True\n    rotated_descending = False\n    max_val = max(lst)\n    max_idx = lst.index(max_val)\n    rotated_lst_desc = lst[max_idx:] + lst[:max_idx]\n    if rotated_lst_desc == sorted(lst, reverse=True):\n        rotated_descending = True\n    if rotated_ascending:\n        return 'rotated ascending'\n    elif rotated_descending:\n        return 'rotated descending'\n    else:\n        return 'unknown'"], "requirement": [], "outputs": "[['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['unknown'], ['rotated ascending'], ['rotated ascending'], ['ascending'], ['ascending'], ['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['unknown'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending']]", "probability": 0.06, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    sorted_lst = sorted(lst)\n    reversed_sorted_lst = sorted(lst, reverse=True)\n    is_rotated_ascending = any((lst[i:] + lst[:i] == sorted_lst for i in range(len(lst))))\n    is_rotated_descending = any((lst[i:] + lst[:i] == reversed_sorted_lst for i in range(len(lst))))\n    if is_ascending:\n        return 'The array is in ascending order.'\n    elif is_rotated_ascending:\n        return 'The array is rotated and in ascending order.'\n    elif is_descending:\n        return 'The array is in descending order.'\n    elif is_rotated_descending:\n        return 'The array is rotated and in descending order.'\n    else:\n        return 'Unexpected condition encountered.'"], "requirement": [], "outputs": "[['The array is in ascending order.'], ['The array is rotated and in ascending order.'], ['The array is rotated and in ascending order.'], ['The array is in descending order.'], ['Unexpected condition encountered.'], ['The array is rotated and in ascending order.'], ['The array is rotated and in ascending order.'], ['The array is in ascending order.'], ['The array is in ascending order.'], ['The array is in ascending order.'], ['The array is rotated and in ascending order.'], ['The array is rotated and in ascending order.'], ['The array is in descending order.'], ['Unexpected condition encountered.'], ['The array is rotated and in ascending order.'], ['The array is rotated and in ascending order.'], ['The array is rotated and in ascending order.'], ['The array is rotated and in ascending order.'], ['The array is rotated and in ascending order.'], ['The array is rotated and in ascending order.']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    \"\"\"\n    Determines if an array is in ascending or descending order and if it is rotated.\n    \n    Args:\n    lst (List[int]): The input list of integers.\n    \n    Returns:\n    str: A string indicating the order and rotation status of the list.\n    \"\"\"\n    is_ascending = all((x < y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x > y for x, y in zip(lst, lst[1:])))\n\n    def is_rotated(original: List[int], target: List[int]) -> bool:\n        return any((original == target[i:] + target[:i] for i in range(len(target))))\n    sorted_lst = sorted(lst)\n    reversed_lst = sorted_lst[::-1]\n    if is_ascending:\n        if not is_rotated(sorted_lst, lst):\n            return 'Ascending and Rotated'\n        else:\n            return 'Ascending'\n    elif is_descending:\n        if not is_rotated(reversed_lst, lst):\n            return 'Descending and Rotated'\n        else:\n            return 'Descending'"], "requirement": [], "outputs": "[['Ascending'], [None], [None], ['Descending'], [None], [None], [None], ['Ascending'], [None], ['Ascending'], [None], [None], ['Descending'], [None], [None], [None], [None], [None], [None], [None]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x < y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x > y for x, y in zip(lst, lst[1:])))\n\n    def is_rotated(original, rotated):\n        return original == rotated or original == rotated[::-1] or original in (rotated[i:] + rotated[:i] for i in range(len(rotated)))\n    sorted_lst = sorted(lst)\n    reverse_sorted_lst = sorted_lst[::-1]\n    if is_ascending:\n        for i in range(1, len(lst)):\n            if all((lst[j] <= lst[(j + 1) % len(lst)] for j in range(len(lst)))):\n                return 'The array is in ascending order and is not rotated.'\n            rotated_lst = lst[i:] + lst[:i]\n            if is_rotated(sorted_lst, rotated_lst):\n                return f'The array is in ascending order and is rotated by {i} positions.'\n    elif is_descending:\n        for i in range(1, len(lst)):\n            if all((lst[j] >= lst[(j + 1) % len(lst)] for j in range(len(lst)))):\n                return 'The array is in descending order and is not rotated.'\n            rotated_lst = lst[i:] + lst[:i]\n            if is_rotated(reverse_sorted_lst, rotated_lst):\n                return f'The array is in descending order and is rotated by {i} positions.'\n    return 'The array cannot be categorized.'"], "requirement": [], "outputs": "[['The array is in ascending order and is rotated by 1 positions.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array is in descending order and is rotated by 1 positions.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array is in ascending order and is rotated by 1 positions.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array is in descending order and is rotated by 1 positions.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array cannot be categorized.'], ['The array cannot be categorized.']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    sorted_lst_asc = sorted(lst)\n    sorted_lst_desc = sorted(lst, reverse=True)\n    if is_ascending:\n        return 'Ascending'\n    elif is_descending:\n        return 'Descending'\n    elif lst == sorted_lst_asc[1:] + sorted_lst_asc[:1] or lst == sorted_lst_asc[-1:] + sorted_lst_asc[:-1]:\n        return 'Rotated Ascending'\n    elif lst == sorted_lst_desc[1:] + sorted_lst_desc[:1] or lst == sorted_lst_desc[-1:] + sorted_lst_desc[:-1]:\n        return 'Rotated Descending'\n    else:\n        return 'Unknown'"], "requirement": [], "outputs": "[['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['Unknown'], ['Unknown'], ['Unknown'], ['Ascending'], ['Ascending'], ['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['Unknown'], ['Unknown'], ['Unknown'], ['Unknown'], ['Rotated Ascending'], ['Rotated Ascending'], ['Unknown']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    \"\"\"Determines if an array is in ascending or descending order and if it is rotated.\n\n    Args:\n        lst (List[int]): The input list of integers.\n\n    Returns:\n        str: A string indicating whether the list is in \"ascending\", \"descending\",\n             \"ascending rotated\", or \"descending rotated\" order.\n    \"\"\"\n    is_ascending = all((x < y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x > y for x, y in zip(lst, lst[1:])))\n    if is_ascending:\n        return 'ascending'\n    elif is_descending:\n        return 'descending'\n    for i in range(1, len(lst)):\n        first_part = lst[:i]\n        second_part = lst[i:]\n        combined_sorted = first_part + second_part\n        if all((x < y for x, y in zip(combined_sorted, combined_sorted[1:]))):\n            combined_reversed_split = second_part + first_part\n            if all((x <= y for x, y in zip(combined_reversed_split, combined_reversed_split[1:]))):\n                return 'ascending rotated'\n        if all((x > y for x, y in zip(combined_sorted, combined_sorted[1:]))):\n            combined_reversed_split = second_part + first_part\n            if all((x >= y for x, y in zip(combined_reversed_split, combined_reversed_split[1:]))):\n                return 'descending rotated'\n    raise ValueError('The provided list does not match any specified pattern')"], "requirement": [], "outputs": "[['ascending'], ['ValueError'], ['ValueError'], ['descending'], ['ValueError'], ['ValueError'], ['ValueError'], ['ascending'], ['ValueError'], ['ascending'], ['ValueError'], ['ValueError'], ['descending'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = lst == sorted(lst)\n    is_descending = lst == sorted(lst, reverse=True)\n\n    def is_rotated_sorted(arr, key):\n        n = len(arr)\n        for i in range(n):\n            if arr == list(sorted(arr))[i:] + list(sorted(arr))[:i]:\n                return True\n        return False\n    is_rotated_ascending = is_rotated_sorted(lst, 'asc')\n    is_rotated_descending = is_rotated_sorted(lst[::-1], 'desc')\n    if is_ascending:\n        return 'Ascending'\n    elif is_descending:\n        return 'Descending'\n    elif is_rotated_ascending:\n        return 'Rotated Ascending'\n    elif is_rotated_descending:\n        return 'Rotated Descending'\n    else:\n        return 'Unsorted'\n\ndef solve(lst: List[int]) -> str:\n    original_lst = lst.copy()\n    sorted_lst = sorted(lst)\n    reversed_lst = sorted_lst[::-1]\n    if lst == sorted_lst:\n        return 'Ascending'\n    elif lst == reversed_lst:\n        return 'Descending'\n    n = len(lst)\n    for i in range(n):\n        rotated_lst = lst[i:] + lst[:i]\n        if rotated_lst == sorted_lst:\n            return 'Rotated Ascending'\n        elif rotated_lst == reversed_lst:\n            return 'Rotated Descending'\n    return 'Unsorted'"], "requirement": [], "outputs": "[['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['Unsorted'], ['Rotated Ascending'], ['Rotated Ascending'], ['Ascending'], ['Ascending'], ['Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Descending'], ['Unsorted'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending'], ['Rotated Ascending']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    \"\"\"\n    Determines if an array is in ascending or descending order and if it is rotated.\n    \n    Args:\n    lst (List[int]): The input list of integers.\n    \n    Returns:\n    str: A string indicating the nature of the list.\n    \"\"\"\n    is_ascending = all((x < y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x > y for x, y in zip(lst, lst[1:])))\n    min_element = min(lst)\n    min_index = lst.index(min_element)\n    rotated_lst = lst[min_index:] + lst[:min_index]\n    is_rotated_ascending = all((x < y for x, y in zip(rotated_lst, rotated_lst[1:])))\n    is_rotated_descending = all((x > y for x, y in zip(rotated_lst, rotated_lst[1:])))\n    if is_ascending:\n        return 'The array is in ascending order.'\n    elif is_descending:\n        return 'The array is in descending order.'\n    elif is_rotated_ascending:\n        return f'The array is rotated and in ascending order. It was rotated at index {min_index}.'\n    elif is_rotated_descending:\n        return f'The array is rotated and in descending order. It was rotated at index {min_index}.'\n    else:\n        return 'The array is unsorted.'"], "requirement": [], "outputs": "[['The array is in ascending order.'], ['The array is rotated and in ascending order. It was rotated at index 1.'], ['The array is rotated and in ascending order. It was rotated at index 4.'], ['The array is in descending order.'], ['The array is unsorted.'], ['The array is rotated and in ascending order. It was rotated at index 2.'], ['The array is rotated and in ascending order. It was rotated at index 3.'], ['The array is in ascending order.'], ['The array is unsorted.'], ['The array is in ascending order.'], ['The array is rotated and in ascending order. It was rotated at index 1.'], ['The array is rotated and in ascending order. It was rotated at index 5.'], ['The array is in descending order.'], ['The array is unsorted.'], ['The array is rotated and in ascending order. It was rotated at index 2.'], ['The array is rotated and in ascending order. It was rotated at index 3.'], ['The array is rotated and in ascending order. It was rotated at index 4.'], ['The array is rotated and in ascending order. It was rotated at index 7.'], ['The array is rotated and in ascending order. It was rotated at index 1.'], ['The array is rotated and in ascending order. It was rotated at index 2.']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    \"\"\"\n    Determines if an array is in ascending or descending order and if it is rotated.\n    \n    Parameters:\n    lst (List[int]): The input list of integers.\n    \n    Returns:\n    str: A string indicating the order and rotation status of the array.\n    \"\"\"\n    if all((x < y for x, y in zip(lst, lst[1:]))):\n        return 'ascending'\n    elif all((x > y for x, y in zip(lst, lst[1:]))):\n        return 'descending'\n    n = len(lst)\n    for i in range(1, n):\n        rotated_ascending = all((lst[(i + j) % n] <= lst[(i + j + 1) % n] for j in range(n - 1)))\n        rotated_descending = all((lst[(i + j) % n] >= lst[(i + j + 1) % n] for j in range(n - 1)))\n        if rotated_ascending:\n            return 'rotated ascending'\n        if rotated_descending:\n            return 'rotated descending'\n    raise ValueError('Input array does not match any expected pattern.')"], "requirement": [], "outputs": "[['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['ValueError'], ['rotated ascending'], ['rotated ascending'], ['ascending'], ['rotated ascending'], ['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['ValueError'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    \"\"\"\n    Determines if an array is in ascending or descending order and if it is rotated.\n    \n    Parameters:\n    lst (List[int]): The list of integers to check.\n    \n    Returns:\n    str: A string indicating if the list is 'ascending', 'descending', 'rotated ascending', or 'rotated descending'.\n    \"\"\"\n    is_ascending = all((x < y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x > y for x, y in zip(lst, lst[1:])))\n    if is_ascending:\n        return 'ascending'\n    elif is_descending:\n        return 'descending'\n    n = len(lst)\n    for i in range(1, n):\n        shifted_lst = lst[i:] + lst[:i]\n        if all((x < y for x, y in zip(shifted_lst, shifted_lst[1:]))):\n            return 'rotated ascending'\n        elif all((x > y for x, y in zip(shifted_lst, shifted_lst[1:]))):\n            return 'rotated descending'\n    raise ValueError('The list did not match any expected pattern. This should not happen.')"], "requirement": [], "outputs": "[['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['ValueError'], ['rotated ascending'], ['rotated ascending'], ['ascending'], ['ValueError'], ['ascending'], ['rotated ascending'], ['rotated ascending'], ['descending'], ['ValueError'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending'], ['rotated ascending']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x <= y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x >= y for x, y in zip(lst, lst[1:])))\n    if is_ascending:\n        return 'Ascending'\n    elif is_descending:\n        return 'Descending'\n    n = len(lst)\n    for i in range(1, n):\n        if lst[i] < lst[i - 1]:\n            rotated_list = lst[i:] + lst[:i]\n            if sorted(lst) == rotated_list:\n                return 'Ascending Rotated'\n            elif sorted(lst, reverse=True) == rotated_list:\n                return 'Descending Rotated'\n            break\n    if is_ascending:\n        return 'Ascending'\n    elif is_descending:\n        return 'Descending'\n    else:\n        raise ValueError('List does not match any specified pattern')"], "requirement": [], "outputs": "[['Ascending'], ['Ascending Rotated'], ['Ascending Rotated'], ['Descending'], ['ValueError'], ['Ascending Rotated'], ['Ascending Rotated'], ['Ascending'], ['Ascending'], ['Ascending'], ['Ascending Rotated'], ['Ascending Rotated'], ['Descending'], ['ValueError'], ['Ascending Rotated'], ['Ascending Rotated'], ['Ascending Rotated'], ['Ascending Rotated'], ['Ascending Rotated'], ['Ascending Rotated']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef solve(lst: List[int]) -> str:\n    is_ascending = all((x < y for x, y in zip(lst, lst[1:])))\n    is_descending = all((x > y for x, y in zip(lst, lst[1:])))\n    sorted_ascending = sorted(lst)\n    sorted_descending = sorted(lst, reverse=True)\n    if is_ascending:\n        if lst != sorted_ascending and any((lst == sorted_ascending[i:] + sorted_ascending[:i] for i in range(len(lst)))):\n            return 'Rotated Ascending'\n        return 'Ascending'\n    if is_descending:\n        if lst != sorted_descending and any((lst == sorted_descending[i:] + sorted_descending[:i] for i in range(len(lst)))):\n            return 'Rotated Descending'\n        return 'Descending'\n    if len(set(lst)) == 1:\n        return 'All Elements Equal'"], "requirement": [], "outputs": "[['Ascending'], [None], [None], ['Descending'], [None], [None], [None], ['Ascending'], ['All Elements Equal'], ['Ascending'], [None], [None], ['Descending'], [None], [None], [None], [None], [None], [None], [None]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 3.1428522259794858, "llm_generated_inputs": "[[[1, 2, 3, 4, 5]], [[5, 1, 2, 3, 4]], [[2, 3, 4, 5, 1]], [[5, 4, 3, 2, 1]], [[1, 5, 2, 3, 4]], [[4, 5, 1, 2, 3]], [[3, 4, 5, 1, 2]], [[1]], [[1, 1, 1, 1, 1]], [[1, 2, 3, 4, 5, 6]], [[6, 1, 2, 3, 4, 5]], [[2, 3, 4, 5, 6, 1]], [[6, 5, 4, 3, 2, 1]], [[1, 6, 2, 3, 4, 5]], [[5, 6, 1, 2, 3, 4]], [[4, 5, 6, 1, 2, 3]], [[3, 4, 5, 6, 1, 2]], [[2, 3, 4, 5, 6, 7, 8, 1]], [[8, 1, 2, 3, 4, 5, 6, 7]], [[7, 8, 1, 2, 3, 4, 5, 6]]]", "input_output_examples": "[[[[1, 2, 3, 4, 5, 7]], [[7, 1, 2, 3, 4, 5]], [[4, 5, 6, 1, 2, 3]], [[9, 8, 7, 6]], [[5, 9, 8, 7, 6]]], [['A'], ['RA'], ['RA'], ['D'], ['RD']]]", "at_least_one_align": false}, "entry_point": "solve", "ground_truth": -1}
{"task_id": "TACO_lite/15", "requirement": "from typing import List\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n\"\"\"A core idea of several left-wing ideologies is that the wealthiest should *support* the poorest, no matter what and that is exactly what you are called to do using this kata (which, on a side note, was born out of the necessity to redistribute the width of `div`s into a given container).\n\nYou will be given two parameters, `population` and `minimum`: your goal is to give to each one according to his own needs (which we assume to be equal to `minimum` for everyone, no matter what), taking from the richest (bigger numbers) first.\n\nIf you happen to have few people as the richest, just take from the ones with the lowest index (the closest to the left, in few words) in the array first, on a 1:1 based heroic proletarian redistribution, until everyone is satisfied.\n\nTo clarify this rule, consider removing `minimum` from every member of the population, then iteratively (or recursively) adding 1 to the poorest while removing 1 from the richest. Pick the element most at left if more elements exist with the same level of minimal poverty, as they are certainly even more aligned with the party will than other poor people; similarly, it is ok to take from the richest one on the left first, so they can learn their lesson and be more kind, possibly giving more *gifts* to the inspectors of the State!\n\nIf giving `minimum` is unfeasable with the current resources (as it often comes to be the case in socialist communities...), just return an empty array `[]`.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    deficit = sum((max(minimum - p, 0) for p in population))\n    surplus = sum((max(p - minimum, 0) for p in population))\n    if deficit > surplus:\n        return []\n    while any((p < minimum for p in population)):\n        poorest = min(((v, i) for i, v in enumerate(population) if v < minimum))[1]\n        richest = max(((v, i) for i, v in enumerate(population) if v >= minimum))[1]\n        population[poorest] += 1\n        population[richest] -= 1\n    return population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    deficit = sum((max(minimum - p, 0) for p in population))\n    surplus = sum((max(p - minimum, 0) for p in population))\n    if deficit > surplus:\n        return []\n    while any((p < minimum for p in population)):\n        poorest = min(((p, i) for i, p in enumerate(population) if p < minimum))[1]\n        richest = max(((p, i) for i, p in enumerate(population) if p >= minimum))[1]\n        population[poorest] += 1\n        population[richest] -= 1\n    return population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_resources = sum(population)\n    required_resources = minimum * len(population)\n    if total_resources < required_resources:\n        return []\n    adjusted_population = [p - minimum for p in population]\n    while any((p < 0 for p in adjusted_population)):\n        richest_index = max(((value, index) for index, value in enumerate(adjusted_population)))[1]\n        poorest_index = min(((value, index) for index, value in enumerate(adjusted_population) if value < 0))[1]\n        adjusted_population[richest_index] -= 1\n        adjusted_population[poorest_index] += 1\n    final_population = [p + minimum for p in adjusted_population]\n    return final_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_wealth = sum(population)\n    required_wealth = minimum * len(population)\n    if total_wealth < required_wealth:\n        return []\n    adjusted_population = [p - minimum for p in population]\n    while any((p < 0 for p in adjusted_population)):\n        poorest_index = min(((v, i) for i, v in enumerate(adjusted_population) if v < 0))[1]\n        rich_candidates = [(v, i) for i, v in enumerate(adjusted_population) if v > 0]\n        if not rich_candidates:\n            break\n        richest_index = min(rich_candidates)[1]\n        adjusted_population[poorest_index] += 1\n        adjusted_population[richest_index] -= 1\n    result_population = [p + minimum for p in adjusted_population]\n    return result_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    shortfall = sum((max(minimum - p, 0) for p in population))\n    surplus = sum((max(p - minimum, 0) for p in population))\n    if shortfall > surplus:\n        return []\n    new_population = population.copy()\n    while any((p < minimum for p in new_population)):\n        poorest_index = min((i for i, p in enumerate(new_population) if p < minimum), key=lambda x: (minimum - new_population[x], x))\n        richest_index = max((i for i, p in enumerate(new_population) if p >= minimum), key=new_population.__getitem__)\n        new_population[poorest_index] += 1\n        new_population[richest_index] -= 1\n    return new_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    required_total = minimum * len(population)\n    current_total = sum(population)\n    if current_total < required_total:\n        return []\n    adjusted_population = [p - minimum for p in population]\n    while any((p < 0 for p in adjusted_population)):\n        poorest_index = next((i for i, p in enumerate(adjusted_population) if p < 0))\n        riches_value = max(adjusted_population)\n        riches_indices = [i for i, p in enumerate(adjusted_population) if p == riches_value]\n        richest_index = riches_indices[0]\n        adjusted_population[poorest_index] += 1\n        adjusted_population[richest_index] -= 1\n    result = [p + minimum for p in adjusted_population]\n    return result", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_need = sum((max(minimum - p, 0) for p in population))\n    total_surplus = sum((p - minimum for p in population if p > minimum))\n    if total_surplus < total_need:\n        return []\n    distribution = population.copy()\n    while any((p < minimum for p in distribution)):\n        need_help = [i for i, p in enumerate(distribution) if p < minimum]\n        can_help = [i for i, p in enumerate(distribution) if p > minimum]\n        for helper in sorted(can_help):\n            for needy in sorted(need_help):\n                if distribution[helper] > minimum and distribution[needy] < minimum:\n                    distribution[helper] -= 1\n                    distribution[needy] += 1\n                    break\n        if not any((p < minimum for p in distribution)):\n            break\n    return distribution", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    deficit = sum((max(minimum - p, 0) for p in population))\n    surplus = sum((max(p - minimum, 0) for p in population))\n    if deficit > surplus:\n        return []\n    while any((p < minimum for p in population)):\n        poorest = min(((p, i) for i, p in enumerate(population) if p < minimum))[1]\n        richest = max(((p, i) for i, p in enumerate(population) if p >= minimum))[1]\n        population[poorest] += 1\n        population[richest] -= 1\n    return population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_needed = len(population) * minimum\n    total_resources = sum(population)\n    if total_resources < total_needed:\n        return []\n    adjusted_population = [max(0, p - minimum) for p in population]\n    while any((p < 0 for p in adjusted_population)):\n        sorted_indices = sorted(range(len(adjusted_population)), key=lambda x: (adjusted_population[x], x))\n        poorest_index = next((i for i in sorted_indices if adjusted_population[i] < 0))\n        richest_index = next((i for i in reversed(sorted_indices) if adjusted_population[i] > 0))\n        adjusted_population[poorest_index] += 1\n        adjusted_population[richest_index] -= 1\n    final_population = [p + minimum for p in adjusted_population]\n    return final_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    deficit = 0\n    for p in population:\n        if p < minimum:\n            deficit += minimum - p\n    total_resources = sum(population)\n    if total_resources < len(population) * minimum:\n        return []\n    adjusted_population = population[:]\n    while True:\n        poorest_index = None\n        richest_index = None\n        for i, p in enumerate(adjusted_population):\n            if p < minimum:\n                if poorest_index is None or p < adjusted_population[poorest_index]:\n                    poorest_index = i\n            if p > minimum:\n                if richest_index is None or p > adjusted_population[richest_index]:\n                    richest_index = i\n        if poorest_index is None:\n            break\n        if richest_index is not None:\n            adjusted_population[poorest_index] += 1\n            adjusted_population[richest_index] -= 1\n        else:\n            break\n    return adjusted_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_wealth = sum(population)\n    required_wealth = minimum * len(population)\n    if total_wealth < required_wealth:\n        return []\n    surplus = [p - minimum for p in population]\n    while any((s > 0 for s in surplus)) and any((s < 0 for s in surplus)):\n        poorest_i = next((i for i, s in enumerate(surplus) if s < 0))\n        richest_i = next((i for i, s in enumerate(surplus) if s > 0))\n        surplus[poorest_i] += 1\n        surplus[richest_i] -= 1\n    final_population = [s + minimum for s in surplus]\n    return final_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    deficit = sum((minimum - x for x in population if x < minimum))\n    surplus = sum((x - minimum for x in population if x > minimum))\n    if deficit > surplus:\n        return []\n    pop = population[:]\n    while True:\n        if all((x >= minimum for x in pop)):\n            break\n        min_index = min((i for i, x in enumerate(pop) if x < minimum), key=lambda i: pop[i])\n        max_index = max((i for i, x in enumerate(pop) if x > minimum), key=lambda i: pop[i])\n        pop[min_index] += 1\n        pop[max_index] -= 1\n    return pop", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_resources = sum(population)\n    required_resources = minimum * len(population)\n    if total_resources < required_resources:\n        return []\n    adjusted_population = [p - minimum for p in population]\n    while any((p < 0 for p in adjusted_population)):\n        poorest_index = adjusted_population.index(min(adjusted_population))\n        max_value = max(adjusted_population)\n        if max_value <= 0:\n            break\n        richest_indices = [i for i, val in enumerate(adjusted_population) if val == max_value]\n        richest_index = min(richest_indices)\n        adjusted_population[poorest_index] += 1\n        adjusted_population[richest_index] -= 1\n    result = [p + minimum for p in adjusted_population]\n    return result", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    target_resources = minimum * len(population)\n    current_resources = sum(population)\n    if target_resources > current_resources:\n        return []\n    deficits = [min(minimum - p, 0) for p in population]\n    total_deficit = sum(deficits)\n    while total_deficit < 0:\n        sorted_population = sorted(enumerate(population), key=lambda x: (-x[1], x[0]))\n        for i, (_, wealth) in enumerate(sorted_population):\n            if wealth <= minimum:\n                break\n            for j, d in enumerate(deficits):\n                if d < 0:\n                    amount = min(wealth - minimum, -d)\n                    population[j] += amount\n                    population[sorted_population[i][0]] -= amount\n                    deficits[j] += amount\n                    total_deficit += amount\n                    break\n    for i, p in enumerate(population):\n        if p < minimum:\n            return []\n    return population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    needed_resources = [minimum - p for p in population]\n    if all((needed <= 0 for needed in needed_resources)):\n        return population\n    if sum(population) < minimum * len(population):\n        return []\n    while any((needed > 0 for needed in needed_resources)):\n        richest_index = max((i for i, p in enumerate(population) if p > minimum), default=None)\n        if richest_index is None:\n            break\n        for i, needed in enumerate(needed_resources):\n            if needed > 0 and population[richest_index] > minimum:\n                population[i] += 1\n                population[richest_index] -= 1\n                needed_resources[i] -= 1\n    if all((p >= minimum for p in population)):\n        return population\n    else:\n        return []", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    n = len(population)\n    total_resources = sum(population)\n    if total_resources < n * minimum:\n        return []\n    current_population = population.copy()\n    for i in range(n):\n        while current_population[i] < minimum:\n            richest_index = max(((val, idx) for idx, val in enumerate(current_population) if val > minimum))[1]\n            current_population[i] += 1\n            current_population[richest_index] -= 1\n    return current_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_deficit = sum((max(minimum - p, 0) for p in population))\n    total_surplus = sum((max(p - minimum, 0) for p in population))\n    if total_surplus < total_deficit:\n        return []\n    while any((p < minimum for p in population)):\n        sorted_population = sorted(enumerate(population), key=lambda x: (x[1], x[0]))\n        for i, (idx, wealth) in enumerate(sorted_population):\n            if wealth >= minimum and any((p < minimum for p in population)):\n                for j in range(len(sorted_population) - 1, -1, -1):\n                    if sorted_population[j][1] > minimum and any((p < minimum for p in population)):\n                        rich_idx = sorted_population[j][0]\n                        poor_idx = sorted_population[i][0]\n                        if population[rich_idx] > minimum and population[poor_idx] < minimum:\n                            population[rich_idx] -= 1\n                            population[poor_idx] += 1\n                            break\n    return population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    deficit = sum((max(minimum - p, 0) for p in population))\n    surplus = sum((max(p - minimum, 0) for p in population))\n    if deficit > surplus:\n        return []\n    while any((p < minimum for p in population)):\n        min_val = min(population)\n        max_val = max(population)\n        if min_val >= minimum:\n            break\n        for i, p in enumerate(population):\n            if p == min_val and max_val > minimum:\n                for j, q in enumerate(population):\n                    if q == max_val:\n                        population[i] += 1\n                        population[j] -= 1\n                        break\n                max_val = max(population)\n                min_val = min(population)\n    return population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_shortfall = sum((max(0, minimum - p) for p in population))\n    total_excess = sum((max(0, p - minimum) for p in population))\n    if total_excess < total_shortfall:\n        return []\n    new_population = population.copy()\n    while any((p < minimum for p in new_population)):\n        richest = [i for i, p in enumerate(new_population) if p == max(new_population)]\n        poorest = [i for i, p in enumerate(new_population) if p < minimum and (not poorest or p <= new_population[poorest[0]])]\n        richest_index = min(richest)\n        new_population[richest_index] -= 1\n        poorest_index = min(poorest)\n        new_population[poorest_index] += 1\n    return new_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_need = len(population) * minimum\n    if sum(population) < total_need:\n        return []\n    pop_copy = population.copy()\n    for i in range(len(pop_copy)):\n        pop_copy[i] -= minimum\n    while any((num < 0 for num in pop_copy)):\n        poorest_idx = -1\n        richest_idx = -1\n        for i, wealth in enumerate(pop_copy):\n            if wealth < 0 and (poorest_idx == -1 or i < poorest_idx):\n                poorest_idx = i\n            if wealth > 0 and (richest_idx == -1 or i < richest_idx):\n                richest_idx = i\n        pop_copy[poorest_idx] += 1\n        pop_copy[richest_idx] -= 1\n    return [x + minimum for x in pop_copy]", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_wealth = sum(population)\n    required_wealth = minimum * len(population)\n    if total_wealth < required_wealth:\n        return []\n    adjusted_population = [p - minimum for p in population]\n    while any((wealth < 0 for wealth in adjusted_population)):\n        poorest_index = min((i for i, wealth in enumerate(adjusted_population) if wealth < 0), key=lambda i: (adjusted_population[i], i))\n        richest_index = max((i for i, wealth in enumerate(adjusted_population) if wealth > 0), key=lambda i: (adjusted_population[i], -i))\n        adjusted_population[poorest_index] += 1\n        adjusted_population[richest_index] -= 1\n    return [wealth + minimum for wealth in adjusted_population]", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_deficit = sum((max(minimum - p, 0) for p in population))\n    total_surplus = sum((max(p - minimum, 0) for p in population))\n    if total_surplus < total_deficit:\n        return []\n    while any((p < minimum for p in population)):\n        poor_indices = [i for i, p in enumerate(population) if p < minimum]\n        rich_indices = [i for i, p in enumerate(population) if p > minimum]\n        if not poor_indices or not rich_indices:\n            break\n        for poor_idx in poor_indices:\n            for rich_idx in rich_indices:\n                if population[rich_idx] > minimum:\n                    population[poor_idx] += 1\n                    population[rich_idx] -= 1\n                if population[poor_idx] >= minimum:\n                    break\n            if population[poor_idx] >= minimum:\n                break\n    return [max(minimum, p) for p in population]", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    needed_resources = sum((max(minimum - p, 0) for p in population))\n    available_resources = sum((p for p in population if p > minimum))\n    if needed_resources > available_resources:\n        return []\n    wealth_diff = [(i, max(0, p - minimum)) for i, p in enumerate(population)]\n    need_diff = [(i, max(0, minimum - p)) for i, p in enumerate(population)]\n    wealth_diff.sort(key=lambda x: x[0])\n    need_diff.sort(key=lambda x: x[0])\n    final_population = population.copy()\n    while any((wealth > 0 for _, wealth in wealth_diff)) and any((need > 0 for _, need in need_diff)):\n        for i_wealth, wealth in wealth_diff:\n            if wealth > 0:\n                for i_need, need in need_diff:\n                    if need > 0:\n                        transfer_amount = min(wealth, need)\n                        final_population[i_wealth] -= transfer_amount\n                        final_population[i_need] += transfer_amount\n                        wealth_diff[wealth_diff.index((i_wealth, wealth))] = (i_wealth, wealth - transfer_amount)\n                        need_diff[need_diff.index((i_need, need))] = (i_need, need - transfer_amount)\n                        break\n                break\n    if all((p >= minimum for p in final_population)):\n        return final_population\n    else:\n        return []", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_needed = len(population) * minimum\n    if sum(population) < total_needed:\n        return []\n    indexed_population = [(i, wealth) for i, wealth in enumerate(population)]\n    sorted_population = sorted(indexed_population, key=lambda x: x[1])\n    result_population = population.copy()\n    for _ in range(len(sorted_population)):\n        current_wealths = [wealth for _, wealth in sorted_population]\n        if all((wealth >= minimum for wealth in current_wealths)):\n            break\n        for i, (_, wealth) in enumerate(sorted_population):\n            if wealth < minimum:\n                poor_index = sorted_population[i][0]\n                sorted_population[i] = (sorted_population[i][0], sorted_population[i][1] + 1)\n                for j in reversed(range(len(sorted_population))):\n                    rich_index = sorted_population[j][0]\n                    if sorted_population[j][1] > minimum:\n                        sorted_population[j] = (sorted_population[j][0], sorted_population[j][1] - 1)\n                        result_population[rich_index] -= 1\n                        result_population[poor_index] += 1\n                        break\n                break\n    return result_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_deficit = sum((minimum - p for p in population if p < minimum))\n    total_surplus = sum((p - minimum for p in population if p > minimum))\n    if total_surplus < total_deficit:\n        return []\n    while True:\n        poorest_indices = [i for i, p in enumerate(population) if p < minimum]\n        richest_indices = [i for i, p in enumerate(population) if p > minimum]\n        if not poorest_indices or not richest_indices:\n            break\n        for poorest, richest in zip(poorest_indices, richest_indices):\n            if population[richest] <= minimum:\n                break\n            population[poorest] += 1\n            population[richest] -= 1\n            if population[poorest] >= minimum:\n                poorest_indices.remove(poorest)\n            if population[richest] <= minimum:\n                richest_indices.remove(richest)\n            if not poorest_indices or not richest_indices:\n                break\n        excess_poor = len(poorest_indices) - len(richest_indices)\n        if excess_poor > 0:\n            for i in range(excess_poor):\n                if richest_indices:\n                    population[poorest_indices[i]] += 1\n                    population[richest_indices[i % len(richest_indices)]] -= 1\n    if all((p >= minimum for p in population)):\n        return population\n    else:\n        return []", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_resources = sum(population)\n    required_resources = len(population) * minimum\n    if total_resources < required_resources:\n        return []\n    adjusted_population = [p - minimum for p in population]\n    while True:\n        sorted_indices = sorted(range(len(adjusted_population)), key=lambda i: (-adjusted_population[i], i))\n        take_from_richest = None\n        give_to_poorest = None\n        for i in sorted_indices:\n            if adjusted_population[i] > 0 and take_from_richest is None:\n                take_from_richest = i\n            if adjusted_population[i] < 0 and give_to_poorest is None:\n                give_to_poorest = i\n            if take_from_richest is not None and give_to_poorest is not None:\n                break\n        if take_from_richest is None or give_to_poorest is None:\n            break\n        adjusted_population[take_from_richest] -= 1\n        adjusted_population[give_to_poorest] += 1\n    return [max(p + minimum, 0) for p in adjusted_population]"], "requirement": [], "outputs": "[[[9, 5, 5]], [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], [[15, 20, 25]], [[]], [[]], [[]], [[]], [[]], [[]], [[1, 2, 3, 1, 8]], [[]], [[6, 6, 6, 9, 9]]]", "probability": 0.52, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_resources = sum(population)\n    required_resources = minimum * len(population)\n    if total_resources < required_resources:\n        return []\n    result_population = population[:]\n    while min(result_population) < minimum:\n        poorest_idx = result_population.index(min(result_population))\n        richest_value = max(result_population)\n        richest_indices = [i for i, value in enumerate(result_population) if value == richest_value]\n        richest_idx = min(richest_indices)\n        result_population[richest_idx] -= 1\n        result_population[poorest_idx] += 1\n    return result_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    required_total = len(population) * minimum\n    current_total = sum(population)\n    if current_total < required_total:\n        return []\n    new_population = population.copy()\n    while min(new_population) < minimum:\n        poorest_index = new_population.index(min(new_population))\n        riches_indices = [i for i, wealth in enumerate(new_population) if wealth == max(new_population)]\n        richest_index = riches_indices[0]\n        if new_population[richest_index] > minimum:\n            new_population[poorest_index] += 1\n            new_population[richest_index] -= 1\n    return new_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_wealth = sum(population)\n    required_wealth = minimum * len(population)\n    if total_wealth < required_wealth:\n        return []\n    population = population.copy()\n    while min(population) < minimum:\n        poorest_index = population.index(min(population))\n        adjusted_population = [x if x > minimum else float('inf') for x in population]\n        richest_index = adjusted_population.index(min(adjusted_population))\n        population[poorest_index] += 1\n        population[richest_index] -= 1\n    return population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    if sum(population) < len(population) * minimum:\n        return []\n    adjusted_population = [x - minimum for x in population]\n    while max(adjusted_population) > 0 and min(adjusted_population) < 0:\n        sorted_population = sorted(((value, idx) for idx, value in enumerate(adjusted_population)))\n        for i, (value, idx) in enumerate(sorted_population):\n            if value > 0:\n                richest_idx = idx\n                break\n        for i, (value, idx) in enumerate(sorted_population):\n            if value < 0:\n                poorest_idx = idx\n                break\n        adjusted_population[richest_idx] -= 1\n        adjusted_population[poorest_idx] += 1\n    final_population = [x + minimum for x in adjusted_population]\n    return final_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_people = len(population)\n    required_total = total_people * minimum\n    if sum(population) < required_total:\n        return []\n    pop_copy = population[:]\n    while min(pop_copy) < minimum:\n        poorest_index = pop_copy.index(min(pop_copy))\n        richest_values = [value for value in pop_copy if value != minimum and value > minimum]\n        if not richest_values:\n            break\n        richest_index = pop_copy.index(max(richest_values))\n        pop_copy[richest_index] -= 1\n        pop_copy[poorest_index] += 1\n    if all((p >= minimum for p in pop_copy)):\n        return pop_copy\n    else:\n        return []", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    deficit = sum((minimum - p for p in population if p < minimum))\n    surplus = sum((p - minimum for p in population if p > minimum))\n    if deficit > surplus:\n        return []\n    result = population[:]\n    while True:\n        min_val = min(result)\n        max_val = max(result)\n        min_index = next((i for i, v in enumerate(result) if v == min_val))\n        max_index = next((i for i, v in enumerate(result) if v == max_val))\n        if min_val >= minimum:\n            break\n        if max_val <= minimum:\n            break\n        result[min_index] += 1\n        result[max_index] -= 1\n    if all((p >= minimum for p in result)):\n        return result\n    else:\n        return []"], "requirement": [], "outputs": "[[[9, 5, 5]], [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], [[15, 20, 25]], ['ValueError'], [[]], [[]], [[]], [[]], [[]], [[1, 2, 3, 4, 5]], [[]], [[6, 6, 6, 9, 9]]]", "probability": 0.12, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_resources = sum(population)\n    required_resources = minimum * len(population)\n    if total_resources < required_resources:\n        return []\n    distribution = [min(minimum, pop) for pop in population]\n    remaining_resources = total_resources - sum(distribution)\n    while remaining_resources > 0:\n        richest_index = max(((value, index) for index, value in enumerate(distribution)))[1]\n        poorest_index = min(((value, index) for index, value in enumerate(distribution)))[1]\n        if distribution[poorest_index] >= minimum:\n            break\n        transfer_amount = min(remaining_resources, minimum - distribution[poorest_index])\n        distribution[poorest_index] += transfer_amount\n        distribution[richest_index] -= transfer_amount\n        remaining_resources -= transfer_amount\n    return distribution", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    deficit = sum((minimum - p for p in population if p < minimum))\n    surplus = sum((p - minimum for p in population if p > minimum))\n    if deficit > surplus:\n        return []\n    adjusted_population = [min(minimum, p) for p in population]\n    while any((p < minimum for p in adjusted_population)):\n        sorted_indices = sorted(range(len(adjusted_population)), key=lambda x: (adjusted_population[x] == minimum, adjusted_population[x]))\n        for poor_index in sorted_indices:\n            if adjusted_population[poor_index] < minimum:\n                for rich_index in range(len(adjusted_population)):\n                    if adjusted_population[rich_index] > minimum:\n                        adjusted_population[poor_index] += 1\n                        adjusted_population[rich_index] -= 1\n                        break\n                else:\n                    break\n    return adjusted_population", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    required_total = len(population) * minimum\n    current_total = sum(population)\n    if current_total < required_total:\n        return []\n    adjusted_population = population[:]\n    for i in range(len(adjusted_population)):\n        if adjusted_population[i] > minimum:\n            current_total -= adjusted_population[i] - minimum\n            adjusted_population[i] = minimum\n    while current_total > sum(adjusted_population):\n        sorted_indices = sorted(range(len(adjusted_population)), key=lambda x: (-adjusted_population[x], x))\n        for idx in sorted_indices:\n            if adjusted_population[idx] > minimum and sum(adjusted_population) + 1 <= required_total:\n                adjusted_population[idx] -= 1\n                poorest_idx = adjusted_population.index(min(adjusted_population))\n                adjusted_population[poorest_idx] += 1\n                break\n    for i in range(len(adjusted_population)):\n        if adjusted_population[i] < minimum:\n            return []\n    return adjusted_population"], "requirement": [], "outputs": "[[[5, 5, 5]], [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], [[15, 15, 15]], [[]], [[]], [[]], [[]], [[]], [[]], [[1, 1, 1, 1, 1]], [[]], [[6, 6, 6, 6, 6]]]", "probability": 0.06, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_resource_needed = sum((max(minimum - p, 0) for p in population))\n    total_resource_available = sum((p for p in population if p >= minimum))\n    if total_resource_needed > total_resource_available:\n        return []\n    new_population = population.copy()\n    for i in range(len(new_population)):\n        if new_population[i] < minimum:\n            needed = min(minimum - new_population[i], total_resource_needed)\n            new_population[i] += needed\n            total_resource_needed -= needed\n    while True:\n        richest = max(((v, i) for i, v in enumerate(new_population)))[1]\n        poorest = min(((v, i) for i, v in enumerate(new_population) if v < minimum))[1]\n        if new_population[poorest] >= minimum:\n            break\n        new_population[richest] -= 1\n        new_population[poorest] += 1\n        if new_population[richest] < minimum:\n            break\n    for i in range(len(new_population)):\n        if new_population[i] < minimum:\n            return []\n    return new_population"], "requirement": [], "outputs": "[['ValueError'], ['ValueError'], ['ValueError'], [[]], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], [[]], ['ValueError'], [[]], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_wealth = sum(population)\n    needed_wealth = minimum * len(population)\n    if total_wealth < needed_wealth:\n        return []\n    surplus = [max(wealth - minimum, 0) for wealth in population]\n    deficit = [minimum - wealth if wealth < minimum else 0 for wealth in population]\n    while any((d > 0 for d in deficit)):\n        richest_idx = next((i for i, x in enumerate(surplus) if x > 0), None)\n        poorest_idx = next((i for i, x in enumerate(deficit) if x > 0), None)\n        if richest_idx is not None and poorest_idx is not None:\n            surplus[richest_idx] -= 1\n            deficit[poorest_idx] -= 1\n    final_distribution = [min(p + d, minimum) for p, d in zip(surplus, deficit)]\n    return [p + min for p in final_distribution]"], "requirement": [], "outputs": "[['TypeError'], ['TypeError'], [[]], [[]], ['TypeError'], [[]], ['TypeError'], [[]], [[]], [[]], [[]], [[]], [[]], ['TypeError'], [[]], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    required = sum((max(0, minimum - p) for p in population))\n    if required > sum((p for p in population if p >= minimum)):\n        return []\n    adjusted_population = [max(minimum, p) for p in population]\n    remaining_wealth = sum(population) - sum(adjusted_population)\n    while remaining_wealth < 0:\n        richest_index = max((i for i, p in enumerate(adjusted_population) if p > minimum), key=lambda i: adjusted_population[i])\n        poorest_index = min((i for i, p in enumerate(adjusted_population) if p == minimum), key=lambda i: i)\n        adjusted_population[richest_index] -= 1\n        adjusted_population[poorest_index] += 1\n        remaining_wealth += 1\n    return adjusted_population"], "requirement": [], "outputs": "[[[9, 5, 5]], [[2, 2, 2]], [[3, 2, 3, 2, 3]], [[]], [[5, 5, 5, 5, 5]], ['ValueError'], [[15, 20, 25]], [[]], [[8, 9, 9, 8]], [[9, 8, 8]], ['ValueError'], ['ValueError'], [[]], [[1, 2, 3, 4, 5]], [[]], [[6, 6, 6, 9, 9]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_resources = sum(population)\n    if total_resources < minimum * len(population):\n        return []\n    people = population[:]\n    for i in range(len(people)):\n        if people[i] > minimum:\n            transfer_amount = min(minimum, people[i] - minimum)\n            people[i] -= transfer_amount\n            minimum -= transfer_amount\n    while min(people) < minimum:\n        richest_index = max(range(len(people)), key=lambda i: (people[i], -i))\n        poorest_index = min((i for i in range(len(people)) if people[i] < minimum), default=None, key=lambda i: (people[i], i))\n        if richest_index is None or poorest_index is None:\n            break\n        transfer_amount = min(people[richest_index] - minimum, minimum - people[poorest_index])\n        if transfer_amount > 0:\n            people[poorest_index] += transfer_amount\n            people[richest_index] -= transfer_amount\n    for i in range(len(people)):\n        if people[i] < minimum:\n            return []\n    return people"], "requirement": [], "outputs": "[[[5, 4, 5]], [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], [[15, 15, 15]], ['ValueError'], [[]], [[]], [[]], [[]], [[]], [[1, 1, 3, 4, 5]], [[]], [[6, 6, 6, 6, 6]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    if sum(population) < minimum * len(population):\n        return []\n    result = [minimum] * len(population)\n    remaining_resources = sum(population) - minimum * len(population)\n    sorted_population = sorted(enumerate([max(p - minimum, 0) for p in population]), key=lambda x: (-x[1], x[0]))\n    for i in range(remaining_resources):\n        index = sorted_population[i % len(sorted_population)][0]\n        result[index] += 1\n    return result"], "requirement": [], "outputs": "[[[7, 6, 6]], [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], [[20, 20, 20]], [[]], [[]], [[]], [[]], [[]], [[]], [[3, 3, 3, 3, 3]], [[]], [[7, 7, 7, 8, 7]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_wealth = sum(population)\n    required_wealth = minimum * len(population)\n    if total_wealth < required_wealth:\n        return []\n    population_copy = population[:]\n    while True:\n        richest_index, richest_value = max(enumerate(population_copy), key=lambda p: (p[1], -p[0]))\n        if min(population_copy) >= minimum:\n            break\n        for i, wealth in enumerate(population_copy):\n            if wealth < minimum and richest_value > minimum:\n                population_copy[richest_index] -= 1\n                richest_value -= 1\n                population_copy[i] += 1\n                break\n        richest_value = population_copy[richest_index]\n    return population_copy", "from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_needed = len(population) * minimum\n    total_available = sum(population)\n    if total_needed > total_available:\n        return []\n    result = population[:]\n    while min(result) < minimum:\n        poorest_index = result.index(min(result))\n        richest_value = max(result)\n        richest_indices = [i for i, value in enumerate(result) if value == richest_value]\n        richest_index = min(richest_indices)\n        if result[richest_index] > minimum:\n            result[richest_index] -= 1\n            result[poorest_index] += 1\n        else:\n            break\n    for i in range(len(result)):\n        if result[i] < minimum:\n            return []\n    return result"], "requirement": [], "outputs": "[[[9, 5, 5]], [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], [[15, 20, 25]], ['ValueError'], [[]], [[]], [[]], [[]], [[]], [[1, 2, 3, 1, 8]], [[]], [[6, 6, 6, 9, 9]]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    needs = sum((max(minimum - p, 0) for p in population))\n    if sum(population) < len(population) * minimum:\n        return []\n    current_population = population[:]\n    while True:\n        changes = False\n        max_value = max(current_population)\n        min_value = min(current_population)\n        richest_index = next((i for i, value in enumerate(current_population) if value == max_value and value >= minimum))\n        poorest_index = next((i for i, value in enumerate(current_population) if value == min_value and value < minimum))\n        if min_value >= minimum:\n            break\n        if current_population[richest_index] - 1 >= minimum and current_population[poorest_index] + 1 <= min_value + 1:\n            current_population[richest_index] -= 1\n            current_population[poorest_index] += 1\n            changes = True\n        if not changes:\n            break\n    return current_population"], "requirement": [], "outputs": "[['StopIteration'], ['StopIteration'], [[]], [[]], ['StopIteration'], [[]], ['StopIteration'], ['ValueError'], [[]], [[]], [[]], [[]], [[]], ['StopIteration'], [[]], ['StopIteration']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    needed_resources = sum((max(minimum - wealth, 0) for wealth in population))\n    available_resources = sum((wealth - minimum for wealth in population if wealth > minimum))\n    if needed_resources > available_resources:\n        return []\n    population_copy = population.copy()\n    for i in range(len(population_copy)):\n        if population_copy[i] < minimum:\n            needed = minimum - population_copy[i]\n            population_copy[i] = minimum\n            needed_resources -= needed\n    while needed_resources < available_resources:\n        richest_index = max(((val, idx) for idx, val in enumerate(population_copy) if val >= minimum))[1]\n        poorest_index = min(((val, idx) for idx, val in enumerate(population_copy) if val <= minimum))[1]\n        if population_copy[richest_index] > minimum and population_copy[poorest_index] == minimum:\n            population_copy[richest_index] -= 1\n            population_copy[poorest_index] += 1\n        available_resources = sum((wealth - minimum for wealth in population_copy if wealth > minimum))\n    return population_copy"], "requirement": [], "outputs": "[['ValueError'], [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], ['ValueError'], [[]], [[]], [[]], [[]], [[]], [[]], ['ValueError'], [[]], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    if sum(population) < len(population) * minimum:\n        return []\n    population_diff = [min_val - minimum for min_val in population]\n    sorted_population = sorted(enumerate(population_diff), key=lambda x: (x[1], x[0]))\n    indices, values = zip(*sorted_population)\n    while max(values) > 0:\n        richest_index = next((i for i, val in enumerate(values) if val > 0))\n        poorest_index = next((i for i, val in enumerate(values) if val < 0))\n        values = list(values)\n        values[richest_index] -= 1\n        values[poorest_index] += 1\n    final_population = [minimum + value for _, value in sorted(zip(indices, values), key=lambda pair: pair[0])]\n    return final_population"], "requirement": [], "outputs": "[['StopIteration'], [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], ['StopIteration'], ['ValueError'], [[]], [[]], [[]], [[]], [[]], ['StopIteration'], [[]], ['StopIteration']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    if sum(population) < len(population) * minimum:\n        return []\n    deficits = [min(minimum - p, 0) for p in population]\n    while any((d < 0 for d in deficits)):\n        richest_idx = max((i for i, p in enumerate(population) if p >= minimum), key=lambda i: population[i])\n        poorest_idx = min((i for i, d in enumerate(deficits) if d < 0), key=lambda i: (d, i))\n        transfer_amount = min(minimum - population[richest_idx], deficits[poorest_idx] + minimum - population[poorest_idx])\n        transfer_amount = max(1, transfer_amount)\n        population[richest_idx] -= transfer_amount\n        population[poorest_idx] += transfer_amount\n        deficits[poorest_idx] = minimum - population[poorest_idx]\n    if all((p >= minimum for p in population)):\n        return population\n    return []"], "requirement": [], "outputs": "[['NameError'], [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], ['NameError'], [[]], [[]], [[]], [[]], [[]], [[]], ['NameError'], [[]], ['NameError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_needed = len(population) * minimum\n    total_resources = sum(population)\n    if total_needed > total_resources:\n        return []\n    pop_copy = population.copy()\n    while True:\n        sorted_pop = sorted(enumerate(pop_copy), key=lambda x: x[1])\n        poorest_index, poorest_value = sorted_pop[0]\n        richest_index, richest_value = max(((i, v) for i, v in sorted_pop if v > minimum), default=(None, None), key=lambda x: x[1])\n        if richest_value is None or richest_value <= minimum:\n            break\n        pop_copy[poorest_index] += 1\n        pop_copy[richest_index] -= 1\n    if all((v >= minimum for v in pop_copy)):\n        return pop_copy\n    else:\n        return []"], "requirement": [], "outputs": "['Timeout', [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], 'Timeout', ['IndexError'], [[]], [[]], [[]], [[]], [[]], 'Timeout', [[]], 'Timeout']", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    required_total = len(population) * minimum\n    current_total = sum(population)\n    if current_total < required_total:\n        return []\n    adjusted_population = population[:]\n    for i in range(len(adjusted_population)):\n        if adjusted_population[i] > minimum:\n            current_total -= adjusted_population[i] - minimum\n            adjusted_population[i] = minimum\n    while current_total > 0:\n        poorest_index = min(((value, index) for index, value in enumerate(adjusted_population) if value == minimum))[1]\n        richest_index = max(((value, index) for index, value in enumerate(adjusted_population) if value > minimum))[1]\n        if all((x <= minimum for x in adjusted_population)):\n            break\n        adjusted_population[richest_index] -= 1\n        adjusted_population[poorest_index] += 1\n        current_total -= 1\n    return adjusted_population"], "requirement": [], "outputs": "[['ValueError'], ['ValueError'], [[]], [[]], ['ValueError'], [[]], ['ValueError'], [[]], [[]], [[]], [[]], [[]], [[]], ['ValueError'], [[]], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_needed = len(population) * minimum\n    if sum(population) < total_needed:\n        return []\n    while True:\n        poorest = min(((value, idx) for idx, value in enumerate(population) if value < minimum))\n        richest = max(((value, idx) for idx, value in enumerate(population) if value > minimum))\n        if poorest[0] >= minimum or richest[0] <= minimum:\n            break\n        population[poorest[1]] += 1\n        population[richest[1]] -= 1\n    if all((p >= minimum for p in population)):\n        return population\n    else:\n        return []"], "requirement": [], "outputs": "[['ValueError'], ['ValueError'], [[]], [[]], ['ValueError'], [[]], ['ValueError'], ['ValueError'], [[]], [[]], [[]], [[]], [[]], ['ValueError'], [[]], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n    total_deficit = sum((max(minimum - p, 0) for p in population))\n    total_surplus = sum((max(p - minimum, 0) for p in population))\n    if total_surplus < total_deficit:\n        return []\n    population_after_adjustment = [max(p, minimum) for p in population]\n    remaining_surplus = sum((p - minimum for p in population_after_adjustment))\n    while remaining_surplus > 0:\n        sorted_population = sorted(enumerate(population_after_adjustment), key=lambda x: (x[1] - minimum, x[0]))\n        for i, (idx, value) in enumerate(sorted_population):\n            if value > minimum:\n                population_after_adjustment[idx] -= 1\n                remaining_surplus -= 1\n                if remaining_surplus == 0:\n                    break\n            elif value == minimum and remaining_surplus > 0:\n                for j in reversed(range(len(sorted_population))):\n                    ridx, rval = sorted_population[j]\n                    if rval > minimum:\n                        population_after_adjustment[idx] += 1\n                        population_after_adjustment[ridx] -= 1\n                        remaining_surplus -= 1\n                        break\n                if remaining_surplus == 0:\n                    break\n    return population_after_adjustment"], "requirement": [], "outputs": "[[[5, 6, 6]], [[2, 2, 2]], [[]], [[]], [[5, 5, 5, 5, 5]], [[]], [[16, 15, 17]], [[]], [[]], [[]], [[]], [[]], [[]], [[1, 2, 1, 1, 3]], [[]], [[6, 7, 7, 8, 5]]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.9091590448071243, "llm_generated_inputs": "[[[9, 5, 5], 5], [[2, 2, 2], 2], [[1, 1, 1, 1, 5], 2], [[1, 1, 1, 1, 1], 5], [[5, 5, 5, 5, 5], 5], [[10, 20, 30], 25], [[15, 20, 25], 15], [[], 5], [[10, 3, 7, 6], 8], [[0, 7, 9], 8], [[15, 10, 5, 5, 10], 10], [[5, 7, 9, 14], 10], [[100, 50, 25, 10, 5], 75], [[1, 2, 3, 1, 8], 1], [[5, 7, 9, 14], 20], [[6, 6, 6, 9, 9], 6]]", "input_output_examples": "[[[[2, 3, 5, 15, 75], 5], [[2, 3, 5, 45, 45], 5], [[2, 3, 5, 15, 75], 30]], [[[5, 5, 5, 15, 70]], [[5, 5, 5, 42, 43]], [[]]]]", "at_least_one_align": false}, "entry_point": "socialist_distribution", "ground_truth": -1}
{"task_id": "TACO_lite/16", "requirement": "def roots(a: float, b: float, c: float) -> float:\n\"\"\"Implement function which will return sum of roots of a quadratic equation rounded to 2 decimal places, if there are any possible roots, else return **None/null/nil/nothing**. If you use discriminant, when discriminant = 0, x1 = x2 = root => return sum of both roots. There will always be valid arguments. \n\nQuadratic equation - https://en.wikipedia.org/wiki/Quadratic_equation\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    else:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(2 * root1, 2)\n        else:\n            return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(2 * root1, 2)\n        else:\n            return round(root1 + root2, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(2 * root1, 2)\n        else:\n            return round(root1 + root2, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(root1 + root2, 2)\n        return round(root1 + root2, 2)\n    return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(2 * root1, 2)\n        return round(root1 + root2, 2)\n    return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(root1 + root1, 2)\n        else:\n            return round(root1 + root2, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    if discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    sqrt_discriminant = math.sqrt(discriminant)\n    root1 = (-b + sqrt_discriminant) / (2 * a)\n    root2 = (-b - sqrt_discriminant) / (2 * a)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    if discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        sum_of_roots = root1 + root2\n        return round(sum_of_roots, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    if discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        sqrt_discriminant = math.sqrt(discriminant)\n        root1 = (-b + sqrt_discriminant) / (2 * a)\n        root2 = (-b - sqrt_discriminant) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"Implement function which will return sum of roots of a quadratic equation rounded to 2 decimal places, if there are any possible roots, else return None. If you use discriminant, when discriminant = 0, x1 = x2 = root => return sum of both roots. There will always be valid arguments.\"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        sum_of_roots = -b / a\n        return round(sum_of_roots, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Returns the sum of roots of a quadratic equation rounded to 2 decimal places,\n    if there are any possible roots, else returns None.\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(2 * root1, 2)\n        else:\n            return round(root1 + root2, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(2 * root1, 2)\n        else:\n            return round(root1 + root2, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(root1 + root2, 2)\n        else:\n            return round(root1 + root2, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Returns the sum of the roots of a quadratic equation rounded to 2 decimal places.\n    If there are no real roots, returns None.\n    \n    Args:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of x\n        c (float): Constant term\n    \n    Returns:\n        float or None: Sum of roots rounded to 2 decimal places, or None if no real roots.\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        sum_of_roots = root1 + root2\n        return round(sum_of_roots, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    if discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"Implement function which will return sum of roots of a quadratic equation \n    rounded to 2 decimal places, if there are any possible roots, else return None.\n    \n    Args:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    \n    Returns:\n    float or None: Sum of roots rounded to 2 decimal places or None.\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    sum_of_roots = -b / a\n    return round(sum_of_roots, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(2 * root1, 2)\n        else:\n            return round(root1 + root2, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        sqrt_discriminant = math.sqrt(discriminant)\n        root1 = (-b + sqrt_discriminant) / (2 * a)\n        root2 = (-b - sqrt_discriminant) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Implements a function which returns the sum of roots of a quadratic equation\n    rounded to 2 decimal places, if there are any possible roots, else returns None.\n    \n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    \n    Returns:\n    float or None: Sum of roots rounded to 2 decimal places, or None if no real roots.\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"\n    This function returns the sum of roots of a quadratic equation \n    rounded to 2 decimal places if there are any possible roots, else returns None.\n    \n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    \n    Returns:\n    float or None: Sum of the roots rounded to 2 decimal places, or None if no roots exist\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"Implement function which will return sum of roots of a quadratic equation rounded to 2 decimal places, if there are any possible roots, else return None. If you use discriminant, when discriminant = 0, x1 = x2 = root => return sum of both roots. There will always be valid arguments.\n    \n    Args:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of x\n        c (float): Constant term\n    \n    Returns:\n        float: Sum of roots rounded to 2 decimal places or None if no real roots exist.\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root_sum = -b / a\n    return round(root_sum, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    if discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        if discriminant == 0:\n            return round(2 * root1, 2)\n        else:\n            return round(root1 + root2, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"\n    This function returns the sum of the roots of a quadratic equation \n    rounded to 2 decimal places if there are any possible roots, else it returns None.\n    If using the discriminant, when discriminant = 0, x1 = x2 = root => return sum of both roots.\n    \n    Args:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of x\n        c (float): Constant term\n    \n    Returns:\n        float: Sum of roots rounded to 2 decimal places, or None if no real roots.\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    if discriminant == 0:\n        root = -b / (2 * a)\n        sum_of_roots = 2 * root\n    else:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        sum_of_roots = root1 + root2\n    return round(sum_of_roots, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Returns the sum of the roots of a quadratic equation rounded to 2 decimal places,\n    if there are any possible roots; otherwise returns None.\n    \n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    \n    Returns:\n    float or None: Sum of the roots rounded to 2 decimal places or None if no roots\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        sum_roots = root1 + root2\n        return round(sum_roots, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"\n    This function returns the sum of roots of a quadratic equation rounded to 2 decimal places.\n    If there are no real roots, it returns None. If you use discriminant, when discriminant = 0,\n    x1 = x2 = root => return sum of both roots. There will always be valid arguments.\n\n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    \n    Returns:\n    float or None: Sum of roots rounded to 2 decimal places, or None if no real roots exist\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    sum_of_roots = -b / a\n    return round(sum_of_roots, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        sqrt_discriminant = math.sqrt(discriminant)\n        root1 = (-b + sqrt_discriminant) / (2 * a)\n        root2 = (-b - sqrt_discriminant) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        sum_of_roots = round(root1 + root2, 2)\n        return sum_of_roots\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Implement function which will return sum of roots of a quadratic equation \n    rounded to 2 decimal places, if there are any possible roots, else return None.\n    If you use discriminant, when discriminant = 0, x1 = x2 = root => return sum of both roots.\n    There will always be valid arguments.\n\n    Quadratic equation - https://en.wikipedia.org/wiki/Quadratic_equation\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant >= 0:\n        sum_of_roots = -b / a\n        return round(sum_of_roots, 2)\n    else:\n        return None", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"Implement function which will return sum of roots of a quadratic equation \n    rounded to 2 decimal places, if there are any possible roots, else return None.\n    \n    Args:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    \n    Returns:\n    float or None: Sum of roots rounded to 2 decimal places or None.\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    sum_of_roots = round(root1 + root2, 2)\n    return sum_of_roots", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        sqrt_discriminant = math.sqrt(discriminant)\n        root1 = (-b + sqrt_discriminant) / (2 * a)\n        root2 = (-b - sqrt_discriminant) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    if discriminant == 0:\n        return round(2 * root1, 2)\n    return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        sqrt_discriminant = math.sqrt(discriminant)\n        root1 = (-b + sqrt_discriminant) / (2 * a)\n        root2 = (-b - sqrt_discriminant) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Implements a function which returns the sum of roots of a quadratic equation \n    rounded to 2 decimal places if there are any possible roots, else returns None.\n    If you use discriminant, when discriminant = 0, x1 = x2 = root => return sum of both roots.\n    There will always be valid arguments.\n\n    Args:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of x\n        c (float): Constant term\n\n    Returns:\n        float or None: Sum of roots rounded to 2 decimal places or None if no real roots exist.\n    \"\"\"\n    D = b ** 2 - 4 * a * c\n    if D < 0:\n        return None\n    elif D == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        root1 = (-b + math.sqrt(D)) / (2 * a)\n        root2 = (-b - math.sqrt(D)) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Returns the sum of roots of a quadratic equation rounded to 2 decimal places.\n    If there are no real roots, returns None.\n    \n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    \n    Returns:\n    float or None: Sum of roots rounded to 2 decimal places or None if no real roots.\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        return round(root1 + root2, 2)", "import math\n\ndef roots(a: float, b: float, c: float) -> float:\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return None\n    elif discriminant == 0:\n        root = -b / (2 * a)\n        return round(2 * root, 2)\n    else:\n        root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        return round(root1 + root2, 2)"], "requirement": [], "outputs": "[[-2.0], [3.0], [-2.0], [0.0], [None], ['ZeroDivisionError'], [4.0], [10.0], [-2.0], [None], [2.0], [5.0], [None], [6.0], [-6.0]]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[1, 2, 1], [1, -3, 2], [2, 4, 2], [1, 0, -1], [1, 0, 1], [0, 2, 3], [-1, 4, -4], [1, -10, 25], [-2, -4, -2], [1, 1, 1], [1, -2, 1], [1, -5, 6], [1, -4, 5], [1, -6, 9], [1, 6, 9]]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "roots", "ground_truth": 0}
{"task_id": "TACO_lite/17", "requirement": "from typing import List\nfrom typing import Union\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n\"\"\"You are given a sequence of a journey in London, UK. The sequence will contain bus **numbers** and TFL tube names as **strings**.\n\nJourneys will always only contain a combination of tube names and bus numbers. Each tube journey costs `£2.40` and each bus journey costs `£1.50`. If there are `2` or more adjacent bus journeys, the bus fare is capped for sets of two adjacent buses and calculated as one bus fare for each set.\n\nYour task is to calculate the total cost of the journey and return the cost `rounded to 2 decimal places` in the format (where x is a number): `£x.xx`\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List, Union\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_buses = 0\n    for item in journey:\n        if isinstance(item, str):\n            total_cost += tube_cost\n            consecutive_buses = 0\n        elif isinstance(item, int):\n            consecutive_buses += 1\n            if consecutive_buses % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for segment in journey:\n        if isinstance(segment, str):\n            total_cost += tube_cost\n            bus_count = 0\n        elif isinstance(segment, int):\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_counter = 0\n    total_cost = 0.0\n    for item in journey:\n        if isinstance(item, str):\n            total_cost += tube_cost\n            bus_counter = 0\n        elif isinstance(item, int):\n            bus_counter += 1\n            if bus_counter % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    TUBE_COST = 2.4\n    BUS_COST = 1.5\n    BUS_CAP = 1.5\n    total_cost = 0.0\n    bus_counter = 0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += TUBE_COST\n            bus_counter = 0\n        else:\n            bus_counter += 1\n            if bus_counter % 2 == 1:\n                total_cost += BUS_COST\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nfrom math import ceil\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_buses = 0\n    for item in journey:\n        if isinstance(item, str):\n            total_cost += tube_cost\n            consecutive_buses = 0\n        else:\n            consecutive_buses += 1\n            if consecutive_buses % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_fare = 2.4\n    bus_fare = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_fare\n            bus_count = 0\n        elif isinstance(transport, int):\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += bus_fare\n    formatted_cost = f'£{total_cost:.2f}'\n    return formatted_cost", "from typing import List, Union\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_bus_count = 0\n    for item in journey:\n        if isinstance(item, str):\n            total_cost += tube_cost\n            consecutive_bus_count = 0\n        elif isinstance(item, int):\n            consecutive_bus_count += 1\n            if consecutive_bus_count % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            bus_count = 0\n        else:\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += bus_cost\n    formatted_cost = f'£{total_cost:.2f}'\n    return formatted_cost", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_fare = 2.4\n    bus_fare = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_fare\n            bus_count = 0\n        elif isinstance(transport, int):\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += bus_fare\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nfrom math import ceil\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_counter = 0\n    total_cost = 0.0\n    for item in journey:\n        if isinstance(item, str):\n            total_cost += tube_cost\n            bus_counter = 0\n        elif isinstance(item, int):\n            bus_counter += 1\n            if bus_counter % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_counter = 0\n    total_cost = 0.0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            bus_counter = 0\n        else:\n            bus_counter += 1\n            if bus_counter % 2 == 1:\n                total_cost += bus_cost\n    rounded_cost = round(total_cost, 2)\n    return f'£{rounded_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for i, item in enumerate(journey):\n        if isinstance(item, str):\n            total_cost += tube_cost\n            bus_count = 0\n        elif isinstance(item, int):\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for i, transport in enumerate(journey):\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            bus_count = 0\n        elif isinstance(transport, int):\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_counter = 0\n    total_cost = 0\n    for item in journey:\n        if isinstance(item, str):\n            total_cost += tube_cost\n            bus_counter = 0\n        elif isinstance(item, int):\n            bus_counter += 1\n            if bus_counter % 2 == 1:\n                total_cost += bus_cost\n    formatted_cost = '£{:.2f}'.format(round(total_cost, 2))\n    return formatted_cost", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_bus_count = 0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            consecutive_bus_count = 0\n        else:\n            consecutive_bus_count += 1\n            if consecutive_bus_count % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_counter = 0\n    total_cost = 0.0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            bus_counter = 0\n        elif isinstance(transport, int):\n            bus_counter += 1\n            if bus_counter % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_counter = 0\n    total_cost = 0.0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            bus_counter = 0\n        elif isinstance(transport, int):\n            bus_counter += 1\n            if bus_counter % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for i, transport in enumerate(journey):\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            bus_count = 0\n        elif isinstance(transport, int):\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nfrom math import ceil\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_fare = 2.4\n    bus_fare = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for item in journey:\n        if isinstance(item, int):\n            bus_count += 1\n        else:\n            if bus_count > 0:\n                total_cost += ceil(bus_count / 2) * bus_fare\n                bus_count = 0\n            total_cost += tube_fare\n    if bus_count > 0:\n        total_cost += ceil(bus_count / 2) * bus_fare\n    total_cost_rounded = f'£{total_cost:.2f}'\n    return total_cost_rounded", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            bus_count = 0\n        elif isinstance(transport, int):\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_bus_count = 0\n    for item in journey:\n        if isinstance(item, str):\n            total_cost += tube_cost\n            consecutive_bus_count = 0\n        elif isinstance(item, int):\n            consecutive_bus_count += 1\n            if consecutive_bus_count % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'\njourney_example = ['central', 1, 'northern', 2, 3, 'district', 4, 5]", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    total_cost = 0.0\n    tube_cost = 2.4\n    bus_cost = 1.5\n    consecutive_buses = 0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            consecutive_buses = 0\n        elif isinstance(transport, int):\n            consecutive_buses += 1\n            if consecutive_buses % 2 == 1:\n                total_cost += bus_cost\n    rounded_cost = round(total_cost, 2)\n    return f'£{rounded_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            bus_count = 0\n        elif isinstance(transport, int):\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += bus_cost\n    total_cost = round(total_cost, 2)\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nfrom math import ceil\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    \"\"\"\n    Calculate the total cost of a journey in London.\n    \n    Args:\n        journey (List[Union[int, str]]): A list of bus numbers (int) and TFL tube names (str).\n        \n    Returns:\n        str: Total cost of the journey rounded to 2 decimal places in the format £x.xx.\n    \"\"\"\n    tube_cost = 2.4\n    bus_cost = 1.5\n    adjacent_bus_count = 0\n    total_cost = 0.0\n    for transport in journey:\n        if isinstance(transport, int):\n            adjacent_bus_count += 1\n        else:\n            if adjacent_bus_count > 0:\n                total_cost += ceil(adjacent_bus_count / 2) * bus_cost\n                adjacent_bus_count = 0\n            total_cost += tube_cost\n    if adjacent_bus_count > 0:\n        total_cost += ceil(adjacent_bus_count / 2) * bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_fare = 2.4\n    bus_fare = 1.5\n    bus_fare_cap = bus_fare\n    total_cost = 0.0\n    consecutive_buses = 0\n    for mode in journey:\n        if isinstance(mode, int):\n            consecutive_buses += 1\n            if consecutive_buses % 2 == 0:\n                consecutive_buses = 0\n            elif consecutive_buses == 1:\n                total_cost += bus_fare\n        else:\n            consecutive_buses = 0\n            total_cost += tube_fare\n    formatted_cost = f'£{total_cost:.2f}'\n    return formatted_cost", "from typing import List, Union\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_bus_count = 0\n    for item in journey:\n        if isinstance(item, int):\n            consecutive_bus_count += 1\n        else:\n            if consecutive_bus_count > 0:\n                total_cost += consecutive_bus_count // 2 * bus_cost + consecutive_bus_count % 2 * bus_cost\n                consecutive_bus_count = 0\n            total_cost += tube_cost\n    if consecutive_bus_count > 0:\n        total_cost += consecutive_bus_count // 2 * bus_cost + consecutive_bus_count % 2 * bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nfrom math import ceil\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    \"\"\"Calculate the total cost of a journey in London.\n    \n    Args:\n        journey (List[Union[int, str]]): A list containing bus numbers (int) and TFL tube names (str).\n        \n    Returns:\n        str: The total cost of the journey rounded to 2 decimal places in the format £x.xx\n    \"\"\"\n    total_cost = 0.0\n    consecutive_buses = 0\n    for item in journey:\n        if isinstance(item, int):\n            consecutive_buses += 1\n        elif isinstance(item, str):\n            if consecutive_buses >= 2:\n                total_cost += 1.5 * (consecutive_buses // 2 + consecutive_buses % 2)\n            else:\n                total_cost += 1.5 * consecutive_buses\n            consecutive_buses = 0\n            total_cost += 2.4\n    if consecutive_buses >= 2:\n        total_cost += 1.5 * (consecutive_buses // 2 + consecutive_buses % 2)\n    else:\n        total_cost += 1.5 * consecutive_buses\n    formatted_cost = '£{:.2f}'.format(round(total_cost, 2))\n    return formatted_cost", "from typing import List, Union\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    bus_fare = 1.5\n    tube_fare = 2.4\n    max_adjacent_buses = 2\n    total_cost = 0.0\n    consecutive_buses = 0\n    for i, item in enumerate(journey):\n        if isinstance(item, int):\n            consecutive_buses += 1\n            if consecutive_buses == max_adjacent_buses:\n                total_cost += bus_fare\n                consecutive_buses = 0\n            elif consecutive_buses < max_adjacent_buses and i == len(journey) - 1:\n                total_cost += min(consecutive_buses, max_adjacent_buses) * bus_fare\n        else:\n            if consecutive_buses > 0 and consecutive_buses < max_adjacent_buses:\n                total_cost += min(consecutive_buses, max_adjacent_buses) * bus_fare\n            consecutive_buses = 0\n            total_cost += tube_fare\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nfrom decimal import Decimal, ROUND_HALF_UP\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = Decimal('2.40')\n    bus_cost = Decimal('1.50')\n    bus_cap = 2\n    total_cost = Decimal('0.00')\n    adjacent_buses = 0\n    for transport in journey:\n        if isinstance(transport, int):\n            adjacent_buses += 1\n            if adjacent_buses == bus_cap:\n                total_cost += bus_cost\n                adjacent_buses = 0\n            elif adjacent_buses == 1:\n                pass\n            else:\n                pass\n        else:\n            if adjacent_buses == 1:\n                total_cost += bus_cost\n            adjacent_buses = 0\n            total_cost += tube_cost\n    if adjacent_buses == 1:\n        total_cost += bus_cost\n    total_cost = total_cost.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)\n    return f'£{total_cost}'", "from typing import List, Union\nfrom math import ceil\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    adjacent_bus_count = 0\n    total_cost = 0.0\n    for step in journey:\n        if isinstance(step, int):\n            adjacent_bus_count += 1\n            if adjacent_bus_count == 2:\n                total_cost += bus_cost\n                adjacent_bus_count = 0\n        else:\n            if adjacent_bus_count == 1:\n                total_cost += bus_cost\n                adjacent_bus_count = 0\n            total_cost += tube_cost\n    if adjacent_bus_count == 1:\n        total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    cost = 0.0\n    tube_cost = 2.4\n    bus_cost = 1.5\n    consecutive_bus_count = 0\n    for mode in journey:\n        if isinstance(mode, int):\n            consecutive_bus_count += 1\n        else:\n            if consecutive_bus_count > 0:\n                cost += math.ceil(consecutive_bus_count / 2) * bus_cost\n                consecutive_bus_count = 0\n            cost += tube_cost\n    if consecutive_bus_count > 0:\n        cost += math.ceil(consecutive_bus_count / 2) * bus_cost\n    return f'£{cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_counter = 0\n    total_cost = 0.0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            bus_counter = 0\n        elif isinstance(transport, int):\n            bus_counter += 1\n            if bus_counter % 2 == 1:\n                total_cost += bus_cost\n    rounded_total_cost = round(total_cost, 2)\n    return f'£{rounded_total_cost:.2f}'", "from typing import List, Union\nfrom math import ceil\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    \"\"\"\n    Calculate the total cost of a journey in London, UK.\n    \n    Args:\n    journey (List[Union[int, str]]): A list containing bus numbers (int) and TFL tube names (str).\n    \n    Returns:\n    str: The total cost of the journey rounded to 2 decimal places in the format £x.xx.\n    \"\"\"\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_buses = 0\n    for item in journey:\n        if isinstance(item, str):\n            total_cost += tube_cost\n            consecutive_buses = 0\n        elif isinstance(item, int):\n            consecutive_buses += 1\n            if consecutive_buses % 2 == 1:\n                total_cost += bus_cost\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_bus_count = 0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            consecutive_bus_count = 0\n        elif isinstance(transport, int):\n            consecutive_bus_count += 1\n            if consecutive_bus_count % 2 == 1:\n                total_cost += bus_cost\n    formatted_cost = f'£{total_cost:.2f}'\n    return formatted_cost", "from typing import List, Union\nfrom decimal import Decimal, ROUND_HALF_UP\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    \"\"\"\n    Calculate the total cost of a journey in London, UK.\n    Bus numbers are integers and TFL tube names are strings.\n    Each tube journey costs £2.40 and each bus journey costs £1.50.\n    If there are 2 or more adjacent bus journeys, the bus fare is capped for sets of two adjacent buses and calculated as one bus fare for each set.\n    \n    Args:\n        journey (List[Union[int, str]]): A list of bus numbers (int) and tube names (str).\n    \n    Returns:\n        str: The total cost of the journey rounded to 2 decimal places in the format: £x.xx\n    \"\"\"\n    tube_cost = Decimal('2.40')\n    bus_cost = Decimal('1.50')\n    bus_fare_capped = Decimal('1.50')\n    total_cost = Decimal('0.00')\n    consecutive_buses = 0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            consecutive_buses = 0\n        elif isinstance(transport, int):\n            consecutive_buses += 1\n            if consecutive_buses % 2 == 1:\n                total_cost += bus_cost\n            else:\n                pass\n    rounded_cost = total_cost.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)\n    return f'£{rounded_cost}'", "from typing import List, Union\nfrom decimal import Decimal, getcontext\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    \"\"\"\n    Calculate the total cost of a journey in London, UK.\n    \n    Args:\n        journey (List[Union[int, str]]): A list containing bus numbers as integers and TFL tube names as strings.\n        \n    Returns:\n        str: The total cost of the journey rounded to 2 decimal places in the format \"£x.xx\".\n    \"\"\"\n    getcontext().prec = 4\n    tube_cost = Decimal('2.40')\n    bus_cost = Decimal('1.50')\n    adjacent_bus_count = 0\n    total_cost = Decimal('0.00')\n    for i, mode in enumerate(journey):\n        if isinstance(mode, int):\n            adjacent_bus_count += 1\n            if adjacent_bus_count == 2:\n                total_cost += bus_cost\n                adjacent_bus_count = 0\n        else:\n            if adjacent_bus_count == 1:\n                total_cost += bus_cost\n                adjacent_bus_count = 0\n            total_cost += tube_cost\n    if adjacent_bus_count == 1:\n        total_cost += bus_cost\n    return f'£{total_cost:,.2f}'", "from typing import List, Union\nfrom math import ceil\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    \"\"\"You are given a sequence of a journey in London, UK. The sequence will contain bus **numbers** and TFL tube names as **strings**.\n\n    Journeys will always only contain a combination of tube names and bus numbers. Each tube journey costs `£2.40` and each bus journey costs `£1.50`. If there are `2` or more adjacent bus journeys, the bus fare is capped for sets of two adjacent buses and calculated as one bus fare for each set.\n\n    Your task is to calculate the total cost of the journey and return the cost `rounded to 2 decimal places` in the format (where x is a number): `£x.xx`\n    \"\"\"\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_buses = 0\n    for step in journey:\n        if isinstance(step, int):\n            consecutive_buses += 1\n        else:\n            if consecutive_buses > 0:\n                total_cost += ceil(consecutive_buses / 2) * bus_cost\n                consecutive_buses = 0\n            total_cost += tube_cost\n    if consecutive_buses > 0:\n        total_cost += ceil(consecutive_buses / 2) * bus_cost\n    formatted_cost = f'£{total_cost:.2f}'\n    return formatted_cost", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_count = 0\n    total_cost = 0.0\n    for i, item in enumerate(journey):\n        if isinstance(item, str):\n            total_cost += tube_cost\n            bus_count = 0\n        elif isinstance(item, int):\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += bus_cost\n    rounded_total_cost = round(total_cost, 2)\n    return f'£{rounded_total_cost:.2f}'"], "requirement": [], "outputs": "[['£7.80'], ['£7.20'], ['£3.00'], ['£7.20'], ['£7.80'], ['£6.30'], ['£3.00'], ['£12.60'], ['£11.70'], ['£7.80'], ['£11.70'], ['£0.00'], ['£1.50'], ['£2.40'], ['£16.50']]", "probability": 0.76, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    total_cost = 0.0\n    bus_count = 0\n    for item in journey:\n        if isinstance(item, str):\n            total_cost += 2.4\n            bus_count = 0\n        elif isinstance(item, int):\n            bus_count += 1\n            if bus_count % 2 == 1:\n                total_cost += 1.5\n    rounded_cost = f'£{math.floor(total_cost * 100) / 100:.2f}'\n    return rounded_cost", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_buses = 0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            consecutive_buses = 0\n        elif isinstance(transport, int):\n            consecutive_buses += 1\n            if consecutive_buses % 2 == 1:\n                total_cost += bus_cost\n    return f'£{math.floor(total_cost * 100) / 100:.2f}'"], "requirement": [], "outputs": "[['£7.80'], ['£7.19'], ['£3.00'], ['£7.19'], ['£7.80'], ['£6.30'], ['£3.00'], ['£12.60'], ['£11.70'], ['£7.80'], ['£11.70'], ['£0.00'], ['£1.50'], ['£2.40'], ['£16.50']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    total_cost = 0.0\n    consecutive_buses = 0\n    for segment in journey:\n        if isinstance(segment, int):\n            consecutive_buses += 1\n        elif isinstance(segment, str):\n            consecutive_buses = 0\n            total_cost += tube_cost\n        if consecutive_buses >= 2:\n            total_cost += bus_cost\n            consecutive_buses = 0\n        elif consecutive_buses == 1:\n            total_cost += bus_cost\n    return f'£{round(total_cost, 2):.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    \"\"\"\n    Calculate the total cost of the journey in London, UK.\n    Bus numbers are represented as integers and TFL tube names as strings.\n    Each tube journey costs £2.40 and each bus journey costs £1.50.\n    If there are 2 or more adjacent bus journeys, the bus fare is capped for sets of two adjacent buses and calculated as one bus fare for each set.\n    \n    Args:\n    journey (List[Union[int, str]]): List containing bus numbers (int) and TFL tube names (str).\n    \n    Returns:\n    str: Total cost of the journey rounded to 2 decimal places in the format \"£x.xx\".\n    \"\"\"\n    bus_fare = 1.5\n    tube_fare = 2.4\n    total_cost = 0.0\n    consecutive_buses = 0\n    for transport in journey:\n        if isinstance(transport, int):\n            consecutive_buses += 1\n        else:\n            consecutive_buses = 0\n            total_cost += tube_fare\n        if consecutive_buses == 2:\n            total_cost += bus_fare\n            consecutive_buses = 0\n        elif consecutive_buses == 1:\n            total_cost += bus_fare\n    return f'£{total_cost:.2f}'"], "requirement": [], "outputs": "[['£7.80'], ['£7.20'], ['£6.00'], ['£7.20'], ['£7.80'], ['£7.80'], ['£6.00'], ['£15.60'], ['£11.70'], ['£10.80'], ['£11.70'], ['£0.00'], ['£1.50'], ['£2.40'], ['£16.50']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\nfrom itertools import groupby\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    total_cost = 0.0\n    bus_streak = 0\n    for key, group in groupby(journey, key=lambda x: isinstance(x, int)):\n        count = len(list(group))\n        if key:\n            bus_streak += count\n            total_cost += bus_streak // 2 * 1.5\n            bus_streak %= 2\n        else:\n            total_cost += count * 2.4\n            bus_streak = 0\n    total_cost += bus_streak * 1.5\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nfrom itertools import groupby\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    total_cost = 0.0\n    bus_count = 0\n    for key, group in groupby(journey, key=lambda x: isinstance(x, int)):\n        count = len(list(group))\n        if key:\n            bus_count += count\n            total_cost += bus_count // 2 * 1.5\n            bus_count %= 2\n        else:\n            total_cost += count * 2.4\n            bus_count = 0\n    total_cost += bus_count * 1.5\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nfrom math import ceil\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    \"\"\"\n    Calculate the total cost of a journey in London using TFL tube names and bus numbers.\n    Tube journeys cost £2.40 and bus journeys cost £1.50. Adjacent bus journeys are capped at one fare for every two buses.\n    \n    Args:\n        journey (List[Union[int, str]]): A list of tube names (str) and bus numbers (int).\n        \n    Returns:\n        str: The total cost of the journey rounded to 2 decimal places, formatted as \"£x.xx\".\n    \"\"\"\n    tube_fare = 2.4\n    bus_fare = 1.5\n    consecutive_buses = 0\n    total_cost = 0.0\n    for item in journey:\n        if isinstance(item, int):\n            consecutive_buses += 1\n        else:\n            consecutive_buses = 0\n            total_cost += tube_fare\n        if consecutive_buses == 2:\n            total_cost += bus_fare\n            consecutive_buses = 0\n    if consecutive_buses > 0:\n        total_cost += consecutive_buses // 2 * bus_fare\n        if consecutive_buses % 2 != 0:\n            total_cost += bus_fare\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    \"\"\"\n    Calculate the total cost of a journey in London, UK, considering bus and tube fares.\n    \n    Parameters:\n    journey (List[Union[int, str]]): A list of bus numbers (int) and TFL tube names (str).\n    \n    Returns:\n    str: The total cost of the journey rounded to 2 decimal places in the format \"£x.xx\".\n    \"\"\"\n    BUS_FARE = 1.5\n    TUBE_FARE = 2.4\n    BUS_CAP = 1.5\n    total_cost = 0.0\n    consecutive_buses = 0\n    for step in journey:\n        if isinstance(step, int):\n            consecutive_buses += 1\n        else:\n            total_cost += TUBE_FARE\n            consecutive_buses = 0\n        if consecutive_buses >= 2:\n            total_cost += BUS_FARE\n            consecutive_buses = 0\n    total_cost += min(consecutive_buses, 1) * BUS_FARE\n    total_cost_rounded = round(total_cost, 2)\n    return f'£{total_cost_rounded:.2f}'"], "requirement": [], "outputs": "[['£4.80'], ['£7.20'], ['£3.00'], ['£7.20'], ['£6.30'], ['£6.30'], ['£3.00'], ['£12.60'], ['£7.20'], ['£7.80'], ['£8.70'], ['£0.00'], ['£1.50'], ['£2.40'], ['£12.00']]", "probability": 0.08, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_fare = 2.4\n    bus_fare = 1.5\n    bus_fare_cap = bus_fare\n    total_cost = 0.0\n    consecutive_buses = 0\n    for mode in journey:\n        if isinstance(mode, int):\n            consecutive_buses += 1\n        else:\n            consecutive_buses = 0\n            total_cost += tube_fare\n        if consecutive_buses == 2:\n            total_cost += bus_fare_cap\n            consecutive_buses = 0\n        elif consecutive_buses == 1:\n            total_cost += bus_fare\n    if consecutive_buses == 1:\n        total_cost += bus_fare\n    return f'£{total_cost:.2f}'"], "requirement": [], "outputs": "[['£7.80'], ['£7.20'], ['£6.00'], ['£7.20'], ['£9.30'], ['£7.80'], ['£6.00'], ['£15.60'], ['£11.70'], ['£10.80'], ['£13.20'], ['£0.00'], ['£3.00'], ['£2.40'], ['£16.50']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    total_cost = 0.0\n    tube_cost = 2.4\n    bus_cost = 1.5\n    consecutive_buses = 0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            consecutive_buses = 0\n        elif isinstance(transport, int):\n            consecutive_buses += 1\n            if consecutive_buses % 2 == 0:\n                pass\n            else:\n                total_cost += bus_cost\n    if consecutive_buses % 2 != 0:\n        total_cost += bus_cost\n    total_cost = round(total_cost, 2)\n    return f'£{total_cost:.2f}'", "from typing import List, Union\nimport math\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    tube_cost = 2.4\n    bus_cost = 1.5\n    bus_cap = 1.5\n    total_cost = 0.0\n    adjacent_buses = 0\n    for transport in journey:\n        if isinstance(transport, str):\n            total_cost += tube_cost\n            adjacent_buses = 0\n        elif isinstance(transport, int):\n            adjacent_buses += 1\n            if adjacent_buses % 2 == 1:\n                total_cost += bus_cost\n    if adjacent_buses % 2 != 0:\n        total_cost += bus_cost\n    return f'£{total_cost:.2f}'"], "requirement": [], "outputs": "[['£7.80'], ['£7.20'], ['£3.00'], ['£7.20'], ['£9.30'], ['£6.30'], ['£3.00'], ['£12.60'], ['£11.70'], ['£7.80'], ['£13.20'], ['£0.00'], ['£3.00'], ['£2.40'], ['£16.50']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n    TUBE_FARE = 2.4\n    BUS_FARE = 1.5\n    BUS_CAP = 1.5\n    total_cost = 0.0\n    consecutive_buses = 0\n    previous_mode = None\n    for mode in journey:\n        if isinstance(mode, str):\n            if consecutive_buses >= 2:\n                total_cost += consecutive_buses // 2 * BUS_CAP + consecutive_buses % 2 * BUS_FARE\n                consecutive_buses = 0\n            total_cost += TUBE_FARE\n            previous_mode = 'tube'\n        elif previous_mode == 'bus':\n            consecutive_buses += 1\n        else:\n            consecutive_buses = 1\n            previous_mode = 'bus'\n    if consecutive_buses >= 2:\n        total_cost += consecutive_buses // 2 * BUS_CAP + consecutive_buses % 2 * BUS_FARE\n    else:\n        total_cost += consecutive_buses * BUS_FARE\n    return f'£{total_cost:.2f}'"], "requirement": [], "outputs": "[['£6.30'], ['£7.20'], ['£3.00'], ['£7.20'], ['£6.30'], ['£6.30'], ['£3.00'], ['£12.60'], ['£8.70'], ['£7.80'], ['£8.70'], ['£0.00'], ['£1.50'], ['£2.40'], ['£13.50']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 0.9533763134793082, "llm_generated_inputs": "[[[1, 'central', 2, 'piccadilly']], [['central', 'piccadilly', 'district']], [[1, 2, 3, 4]], [['central', 'central', 'central']], [['central', 1, 'central', 1]], [[1, 1, 'central', 'district']], [[1, 1, 1, 1]], [['central', 'district', 1, 1, 'central', 'district', 1, 1]], [[1, 'central', 1, 'central', 1, 'central']], [['central', 1, 1, 'central', 1, 1]], [['central', 1, 'central', 2, 'central', 3]], [[]], [[1]], [['central']], [[1, 'central', 'district', 2, 'piccadilly', 'bakerloo', 3, 'metropolitan']]]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "london_city_hacker", "ground_truth": -1}
{"task_id": "TACO_lite/18", "requirement": "from typing import List\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n\"\"\"A grid is a perfect starting point for many games (Chess, battleships, Candy Crush!).\n\nMaking a digital chessboard I think is an interesting way of visualising how loops can work together.\n\nYour task is to write a function that takes two integers `rows` and `columns` and returns a chessboard pattern as a two dimensional array.\n\nThe white spaces should be represented by an: `'O'`\n\nand the black an: `'X'`\n\nThe first row should always start with a white space `'O'`\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for row in range(rows):\n        row_contents = []\n        for col in range(columns):\n            if (row + col) % 2 == 0:\n                row_contents.append('O')\n            else:\n                row_contents.append('X')\n        board.append(row_contents)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board", "from typing import List\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n    \"\"\"\n    Generates a chessboard pattern as a two-dimensional array with the specified number of rows and columns.\n    \n    White spaces are represented by 'O' and black spaces by 'X'.\n    The first row always starts with a white space 'O'.\n    \n    :param rows: Number of rows in the chessboard.\n    :param columns: Number of columns in the chessboard.\n    :return: A list of lists representing the chessboard pattern.\n    \"\"\"\n    board = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if (i + j) % 2 == 0:\n                row.append('O')\n            else:\n                row.append('X')\n        board.append(row)\n    return board"], "requirement": [], "outputs": "[[[['O', 'X'], ['X', 'O']]], [[['O', 'X', 'O'], ['X', 'O', 'X'], ['O', 'X', 'O']]], [[['O', 'X', 'O', 'X', 'O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O', 'X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X', 'O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O', 'X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X', 'O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O', 'X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X', 'O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O', 'X', 'O', 'X', 'O']]], [[['O']]], [[]], [[[], [], [], [], []]], [[]], [[[], [], [], [], []]], [[['O', 'X', 'O', 'X']]], [[['O'], ['X'], ['O'], ['X']]], [[['O', 'X', 'O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X', 'O', 'X']]], [[['O', 'X', 'O', 'X', 'O', 'X', 'O'], ['X', 'O', 'X', 'O', 'X', 'O', 'X'], ['O', 'X', 'O', 'X', 'O', 'X', 'O'], ['X', 'O', 'X', 'O', 'X', 'O', 'X'], ['O', 'X', 'O', 'X', 'O', 'X', 'O'], ['X', 'O', 'X', 'O', 'X', 'O', 'X']]]]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[2, 2], [3, 3], [8, 8], [1, 1], [0, 5], [5, 0], [-1, 5], [5, -1], [1, 4], [4, 1], [7, 6], [6, 7]]", "input_output_examples": "[[[6, 4], [3, 7]], [[[['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O']]], [[['O', 'X', 'O', 'X', 'O', 'X', 'O'], ['X', 'O', 'X', 'O', 'X', 'O', 'X'], ['O', 'X', 'O', 'X', 'O', 'X', 'O']]]]]", "at_least_one_align": false}, "entry_point": "chess_board", "ground_truth": 0}
{"task_id": "TACO_lite/19", "requirement": "from typing import List\nfrom typing import Union\ndef beasts(heads: int, tails: int) -> Union[List[float], str]:\n\"\"\"You're in ancient Greece and giving Philoctetes a hand in preparing a training exercise for Hercules! You've filled a pit with two different ferocious mythical creatures for Hercules to battle!\n\nThe formidable **\"Orthus\"** is a 2 headed dog with 1 tail.  The mighty **\"Hydra\"** has 5 heads and 1 tail. \n\nBefore Hercules goes in, he asks you \"How many of each beast am  I up against!?\".\n\nYou know the total number of heads and the total number of tails, that's the dangerous parts, right? But you didn't consider how many of each beast. \n\n## Task\n\nGiven the number of heads and the number of tails, work out the number of each mythical beast! \n\nThe data is given as two parameters. Your answer should be returned as an array:\n\nIf there aren't any cases for the given amount of heads and tails - return \"No solutions\" or null (C#).\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    orthus = 0\n    hydra = 0\n    for hydra in range(tails + 1):\n        orthus = tails - hydra\n        if 2 * orthus + 5 * hydra == heads:\n            return [hydra, orthus]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[float], str]:\n    orthus_heads = 2\n    orthus_tails = 1\n    hydra_heads = 5\n    hydra_tails = 1\n    for hydra in range(tails + 1):\n        orthus = tails - hydra\n        if orthus * orthus_heads + hydra * hydra_heads == heads:\n            return [hydra, orthus]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    orthus_heads = 2\n    orthus_tails = 1\n    hydra_heads = 5\n    hydra_tails = 1\n    for num_orthus in range(tails + 1):\n        num_hydra = tails - num_orthus\n        if num_orthus * orthus_heads + num_hydra * hydra_heads == heads:\n            return [num_hydra, num_orthus]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    orthus_heads, orthus_tails = (2, 1)\n    hydra_heads, hydra_tails = (5, 1)\n    for hydra in range(tails + 1):\n        orthus = tails - hydra\n        if 2 * orthus + 5 * hydra == heads:\n            return [hydra, orthus]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    orthus_heads_per = 2\n    orthus_tails_per = 1\n    hydra_heads_per = 5\n    hydra_tails_per = 1\n    for hydra in range(tails + 1):\n        orthus = tails - hydra\n        if orthus * orthus_heads_per + hydra * hydra_heads_per == heads:\n            return [hydra, orthus]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    orthus_heads, orthus_tails = (2, 1)\n    hydra_heads, hydra_tails = (5, 1)\n    for num_orthus in range(tails + 1):\n        num_hydra = tails - num_orthus\n        total_heads = num_orthus * orthus_heads + num_hydra * hydra_heads\n        if total_heads == heads:\n            return [num_hydra, num_orthus]\n    return 'No solutions'"], "requirement": [], "outputs": "[[[1, 1]], ['No solutions'], ['No solutions'], ['No solutions'], [[0, 2]], ['No solutions'], [[0, 0]], ['No solutions'], ['No solutions'], ['No solutions'], [[0, 3]], ['No solutions'], ['No solutions'], ['No solutions'], ['No solutions'], [[20, 0]], ['No solutions'], [[2, 2]], ['No solutions'], ['No solutions']]", "probability": 0.12, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    for h in range(tails + 1):\n        d = tails - h\n        if 2 * h + 5 * d == heads:\n            return [h, d]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    orthus_heads, orthus_tails = (2, 1)\n    hydra_heads, hydra_tails = (5, 1)\n    for num_orthus in range(tails + 1):\n        num_hydra = tails - num_orthus\n        if num_orthus * orthus_heads + num_hydra * hydra_heads == heads:\n            return [num_orthus, num_hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    for hydra in range(tails + 1):\n        orthus = tails - hydra\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    orthus_heads = 2\n    orthus_tails = 1\n    hydra_heads = 5\n    hydra_tails = 1\n    for num_orthus in range(tails + 1):\n        num_hydra = tails - num_orthus\n        if num_orthus * orthus_heads + num_hydra * hydra_heads == heads and num_orthus * orthus_tails + num_hydra * hydra_tails == tails:\n            return [num_orthus, num_hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if tails < 0 or heads < 0:\n        return 'No solutions'\n    for y in range(tails + 1):\n        x = tails - y\n        if 2 * x + 5 * y == heads:\n            return [x, y]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, determine the number of Orthus (2-headed, 1-tailed dogs) \n    and Hydra (5-headed, 1-tailed serpents). Returns the count of each creature or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, determine the number of Orthus (2 heads, 1 tail) \n    and Hydra (5 heads, 1 tail) creatures.\n    \n    Returns:\n        List[int]: A list containing [number_of_orthus, number_of_hydra] if a solution exists.\n        str: \"No solutions\" if no valid combination can be found.\n    \"\"\"\n    for num_hydra in range(tails + 1):\n        num_orthus = tails - num_hydra\n        if 2 * num_orthus + 5 * num_hydra == heads:\n            return [num_orthus, num_hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if tails > heads:\n        return 'No solutions'\n    orthus_count = 0\n    hydra_count = 0\n    for i in range(tails + 1):\n        orthus_heads = 2 * i\n        remaining_heads = heads - orthus_heads\n        if remaining_heads >= 0 and remaining_heads % 5 == 0:\n            hydra_count = remaining_heads // 5\n            if i + hydra_count == tails:\n                orthus_count = i\n                break\n    else:\n        return 'No solutions'\n    return [orthus_count, hydra_count]", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, this function calculates the number of Orthus and Hydra.\n    \n    Parameters:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list containing the number of Orthus and Hydra or \"No solutions\" if not possible.\n    \"\"\"\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Calculate the number of Orthus and Hydra given the total number of heads and tails.\n    \n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list containing [number_of_orthus, number_of_hydra] or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Calculates the number of Orthus and Hydra based on the given number of heads and tails.\n    \n    Args:\n        heads (int): Total number of heads.\n        tails (int): Total number of tails.\n    \n    Returns:\n        Union[List[int], str]: A list containing the number of Orthus and Hydra or \"No solutions\" if not possible.\n    \"\"\"\n    for o in range(tails + 1):\n        h = tails - o\n        if 2 * o + 5 * h == heads:\n            return [o, h]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Calculates the number of Orthus and Hydra beasts given the total number of heads and tails.\n    \n    Parameters:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list containing [number_of_orthus, number_of_hydra] or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the number of heads and tails, this function calculates the number of Orthus and Hydra.\n    \n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list containing the number of Orthus and Hydra, or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, determine the number of Orthus (2 heads, 1 tail) \n    and Hydra (5 heads, 1 tail) in the pit. If no solution exists, return \"No solutions\".\n    \n    :param heads: Total number of heads\n    :param tails: Total number of tails\n    :return: List containing [number_of_orthus, number_of_hydra] or \"No solutions\" if not possible\n    \"\"\"\n    for hydra in range(tails + 1):\n        orthus = tails - hydra\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, this function calculates the number of Orthus (2 heads, 1 tail)\n    and Hydra (5 heads, 1 tail) in the pit. If no valid combination exists, it returns 'No solutions'.\n    \n    :param heads: Total number of heads.\n    :param tails: Total number of tails.\n    :return: List containing [number_of_orthus, number_of_hydra] or 'No solutions' if not possible.\n    \"\"\"\n    for hydra in range(tails + 1):\n        orthus = tails - hydra\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if (heads - 2 * tails) % 3 == 0:\n        y = (heads - 2 * tails) // 3\n        x = tails - y\n        if x >= 0 and y >= 0:\n            return [x, y]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if (heads - 2 * tails) % 3 != 0 or tails < 0 or heads < 0:\n        return 'No solutions'\n    hydra = (heads - 2 * tails) // 3\n    orthus = tails - hydra\n    if hydra < 0 or orthus < 0:\n        return 'No solutions'\n    return [orthus, hydra]", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, determine the number of Orthus (2-headed, 1-tailed dogs) \n    and Hydra (5-headed, 1-tailed serpents). If no valid combination exists, return \"No solutions\".\n    \n    Args:\n        heads (int): Total number of heads.\n        tails (int): Total number of tails.\n\n    Returns:\n        Union[List[int], str]: A list [number_of_orthus, number_of_hydra] or \"No solutions\" if invalid.\n    \"\"\"\n    for num_hydra in range(tails + 1):\n        num_orthus = tails - num_hydra\n        if 2 * num_orthus + 5 * num_hydra == heads:\n            return [num_orthus, num_hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if tails > heads or tails < 0 or heads < 0:\n        return 'No solutions'\n    if (heads - 2 * tails) % 3 != 0:\n        return 'No solutions'\n    hydra = (heads - 2 * tails) // 3\n    orthus = tails - hydra\n    if orthus < 0 or hydra < 0:\n        return 'No solutions'\n    return [orthus, hydra]", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Calculate the number of Orthus and Hydra based on the given number of heads and tails.\n\n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n\n    Returns:\n    Union[List[int], str]: A list containing [number_of_orthus, number_of_hydra] or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if (heads - 2 * tails) % 3 == 0:\n        y = (heads - 2 * tails) // 3\n        x = tails - y\n        if x >= 0 and y >= 0:\n            return [x, y]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if (heads - 2 * tails) % 3 != 0:\n        return 'No solutions'\n    y = (heads - 2 * tails) // 3\n    x = tails - y\n    if x < 0 or y < 0:\n        return 'No solutions'\n    return [x, y]", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, determines the number of Orthus and Hydra beasts.\n    \n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    List[int]: A list containing the number of Orthus and Hydra beasts, respectively.\n    str: \"No solutions\" if no combination of beasts matches the given heads and tails.\n    \"\"\"\n    for y in range(tails + 1):\n        x = tails - y\n        if 2 * x + 5 * y == heads:\n            return [x, y]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    solutions = []\n    for x in range(tails + 1):\n        y = tails - x\n        if 2 * x + 5 * y == heads:\n            solutions.append([x, y])\n    if not solutions:\n        return 'No solutions'\n    else:\n        return solutions[0]", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if (heads - 2 * tails) % 3 == 0 and heads - 2 * tails >= 0:\n        hydra = (heads - 2 * tails) // 3\n        orthus = tails - hydra\n        if orthus >= 0:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if (heads - 2 * tails) % 3 == 0 and heads - 2 * tails >= 0:\n        y = (heads - 2 * tails) // 3\n        x = tails - y\n        if x >= 0:\n            return [x, y]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the number of heads and tails, determine the number of Orthus (2 heads, 1 tail)\n    and Hydra (5 heads, 1 tail) creatures.\n    \n    Args:\n        heads (int): The total number of heads.\n        tails (int): The total number of tails.\n        \n    Returns:\n        Union[List[int], str]: A list containing the number of Orthus and Hydra creatures,\n                               or a string \"No solutions\" if no valid combination exists.\n    \"\"\"\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        calculated_heads = orthus * 2 + hydra * 5\n        if calculated_heads == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Determine the number of Orthus and Hydra based on the total number of heads and tails.\n    \n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list containing the number of Orthus and Hydra, or a string \"No solutions\" if no valid combination exists.\n    \"\"\"\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if (heads - 2 * tails) % 3 == 0:\n        y = (heads - 2 * tails) // 3\n        x = tails - y\n        if x >= 0 and y >= 0:\n            return [x, y]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Determines the number of Orthus and Hydra based on the total number of heads and tails.\n    \n    Parameters:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list containing the number of Orthus and Hydra or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    if (heads - 2 * tails) % 3 != 0 or heads - 2 * tails < 0:\n        return 'No solutions'\n    y = (heads - 2 * tails) // 3\n    x = tails - y\n    if x < 0 or y < 0:\n        return 'No solutions'\n    return [x, y]", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if (heads - 2 * tails) % 3 == 0:\n        y = (heads - 2 * tails) // 3\n        x = tails - y\n        if x >= 0 and y >= 0:\n            return [x, y]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, returns the number of Orthus (2 heads, 1 tail) \n    and Hydra (5 heads, 1 tail) creatures. If no solution is possible, returns \"No solutions\".\n    \n    :param heads: Total number of heads.\n    :param tails: Total number of tails.\n    :return: A list [Number of Orthus, Number of Hydra] or \"No solutions\" if not possible.\n    \"\"\"\n    for y in range(tails + 1):\n        x = tails - y\n        if 2 * x + 5 * y == heads:\n            return [x, y]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Calculate the number of Orthus and Hydra given the total number of heads and tails.\n    \n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list containing [number_of_orthus, number_of_hydra] or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    for num_orthus in range(tails + 1):\n        num_hydra = tails - num_orthus\n        if 2 * num_orthus + 5 * num_hydra == heads:\n            return [num_orthus, num_hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    if (heads - 2 * tails) % 3 == 0 and heads - 2 * tails >= 0:\n        y = (heads - 2 * tails) // 3\n        x = tails - y\n        if x >= 0:\n            return [x, y]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Determine the number of Orthus and Hydra based on the given number of heads and tails.\n    \n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list [number_of_orthus, number_of_hydra] or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    orthus_heads = 2\n    hydra_heads = 5\n    orthus_tails = 1\n    hydra_tails = 1\n    for hydra in range(tails + 1):\n        orthus = tails - hydra\n        if orthus * orthus_heads + hydra * hydra_heads == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Determine the number of Orthus and Hydra based on the given number of heads and tails.\n    \n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list containing the number of Orthus and Hydra, or \"No solutions\" if not possible.\n    \"\"\"\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, this function calculates the number of Orthus (2-headed dogs) \n    and Hydra (5-headed serpents) in the pit. If no valid solution exists, it returns \"No solutions\".\n    \n    Parameters:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list [number_of_orthus, number_of_hydra] or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    for hydra in range(tails + 1):\n        orthus = tails - hydra\n        if 2 * orthus + 5 * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, determines the number of Orthus (2-headed, 1-tailed)\n    and Hydra (5-headed, 1-tailed) creatures.\n    \n    Args:\n        heads (int): Total number of heads.\n        tails (int): Total number of tails.\n    \n    Returns:\n        Union[List[int], str]: A list of two integers [number_of_orthus, number_of_hydra] if a solution exists,\n                               otherwise returns \"No solutions\".\n    \"\"\"\n    if (heads - 2 * tails) % 3 == 0:\n        h = (heads - 2 * tails) // 3\n        o = tails - h\n        if o >= 0 and h >= 0:\n            return [o, h]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the number of heads and tails, returns the number of Orthus (2 heads, 1 tail) and Hydra (5 heads, 1 tail).\n    If no solution exists, returns \"No solutions\".\n    \"\"\"\n    for hydra_count in range(tails + 1):\n        orthus_count = tails - hydra_count\n        if 2 * orthus_count + 5 * hydra_count == heads:\n            return [orthus_count, hydra_count]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Determine the number of Orthus (2 heads, 1 tail) and Hydra (5 heads, 1 tail) based on the total number of heads and tails.\n    \n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list containing [number_of_orthus, number_of_hydra] or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    if (heads - 2 * tails) % 3 != 0:\n        return 'No solutions'\n    hydra = (heads - 2 * tails) // 3\n    orthus = tails - hydra\n    if 2 * orthus + 5 * hydra == heads and orthus + hydra == tails and (orthus >= 0) and (hydra >= 0):\n        return [orthus, hydra]\n    else:\n        return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Determine the number of Orthus and Hydra based on the total number of heads and tails.\n    \n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list [number_of_orthus, number_of_hydra] or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    heads_per_orthus = 2\n    tails_per_orthus = 1\n    heads_per_hydra = 5\n    tails_per_hydra = 1\n    for orthus in range(tails + 1):\n        hydra = tails - orthus\n        if heads_per_orthus * orthus + heads_per_hydra * hydra == heads:\n            return [orthus, hydra]\n    return 'No solutions'", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the number of heads and tails, returns the number of Orthus and Hydra.\n    \n    Args:\n    heads (int): The total number of heads.\n    tails (int): The total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list [orthus_count, hydra_count] or \"No solutions\" if no valid solution exists.\n    \"\"\"\n    if (heads - 2 * tails) % 3 != 0 or heads - 2 * tails < 0:\n        return 'No solutions'\n    hydra_count = (heads - 2 * tails) // 3\n    orthus_count = tails - hydra_count\n    if orthus_count < 0:\n        return 'No solutions'\n    return [orthus_count, hydra_count]", "from typing import List, Union\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n    \"\"\"\n    Given the total number of heads and tails, determine the number of Orthus and Hydra.\n    \n    Args:\n    heads (int): Total number of heads.\n    tails (int): Total number of tails.\n    \n    Returns:\n    Union[List[int], str]: A list containing [number_of_orthus, number_of_hydra] or \"No solutions\" if no valid combination exists.\n    \"\"\"\n    for num_orthus in range(tails + 1):\n        num_hydra = tails - num_orthus\n        if 2 * num_orthus + 5 * num_hydra == heads:\n            return [num_orthus, num_hydra]\n    return 'No solutions'"], "requirement": [], "outputs": "[[[1, 1]], ['No solutions'], ['No solutions'], ['No solutions'], [[2, 0]], ['No solutions'], [[0, 0]], ['No solutions'], ['No solutions'], ['No solutions'], [[3, 0]], ['No solutions'], ['No solutions'], ['No solutions'], ['No solutions'], [[0, 20]], ['No solutions'], [[2, 2]], ['No solutions'], ['No solutions']]", "probability": 0.88, "is_align_req": false, "DRS": null}], "entropy": 0.3669249912727096, "llm_generated_inputs": "[[7, 2], [10, 3], [5, 2], [9, 2], [4, 2], [1, 1], [0, 0], [15, 5], [20, 5], [8, 3], [6, 3], [12, 4], [-1, 2], [2, -1], [-3, -4], [100, 20], [3, 1], [14, 4], [30, 7], [50, 15]]", "input_output_examples": "[[[24, 15], [0, 0]], [[24, 15], ['No solutions']]]", "at_least_one_align": false}, "entry_point": "beasts", "ground_truth": -1}
{"task_id": "TACO_lite/20", "requirement": "from typing import List\ndef round_to_five(numbers: List[float]) -> List[float]:\n\"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n\n```if:python\nRoundings have to be done like \"in real life\": `22.5 -> 25`\n```\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_five(n):\n        return round(n / 5) * 5\n    return [nearest_five(num) for num in numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_five(n):\n        return round(n / 5) * 5\n    return [nearest_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_five(n):\n        return round(n / 5) * 5\n    return [nearest_five(num) for num in numbers]\n\ndef round_to_five_real_life(numbers: List[float]) -> List[float]:\n    return [round((num + 2.5) / 5) * 5 for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_single(x: float) -> float:\n        return round(x / 5) * 5\n    return [round_single(number) for number in numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return 5 * round(n / 5)\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_number(num):\n        return round(num / 5) * 5\n    return [round_number(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_individual(num):\n        return round(num / 5) * 5\n    return [round_individual(num) for num in numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array \n    rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to the nearest number divisible by 5.\n    Roundings are done like \"in real life\": e.g., 22.5 -> 25.\n    \n    Args:\n    numbers (List[float]): The list of numbers to round.\n    \n    Returns:\n    List[float]: The list of rounded numbers.\n    \"\"\"\n\n    def nearest_multiple_of_five(n: float) -> float:\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]\nimport math\n\ndef nearest_multiple_of_five_real_life(n):\n    return math.ceil(n / 5) * 5 if n % 5 >= 2.5 else math.floor(n / 5) * 5\n\ndef round_to_five_real_life(numbers: List[float]) -> List[float]:\n    return [nearest_multiple_of_five_real_life(num) for num in numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return 5 * round(n / 5)\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_single(num):\n        return round(num / 5) * 5\n    return [round_single(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_single(num):\n        return round(num / 5) * 5\n    return [round_single(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n: float) -> float:\n        return 5 * round(n / 5)\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round单个数字(x: float) -> float:\n        return round(x / 5) * 5\n    return [round单个数字(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]"], "requirement": [], "outputs": "[[[0, 5, 10]], [[0, 5, 10]], [[0, -5, -10]], [[20, 20, 20, 25, 25]], [[0, 10, 10, 20, 20]], [[0, 5, 5, 10, 10, 15]], [[0, 5, 10, 15, 20, 25]], [[0, 5, 5, 5, 5, 10]], [[20, 25, 30]], [[0, -10, -10, -20, -20]], ['OverflowError'], ['OverflowError'], ['ValueError']]", "probability": 0.58, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return math.ceil(n / 5) * 5 if n % 5 >= 2.5 else math.floor(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return math.ceil(n / 5) * 5 if n % 5 >= 2.5 else math.floor(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n: float) -> float:\n        return round(n / 5) * 5\n    rounded_numbers = [nearest_multiple_of_five(num) for num in numbers]\n    for i, num in enumerate(numbers):\n        lower_bound = num // 5 * 5\n        upper_bound = lower_bound + 5\n        if num - lower_bound == 2.5:\n            rounded_numbers[i] = upper_bound\n    return rounded_numbers", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n\n    def real_life_rounding(n):\n        remainder = n % 5\n        if remainder >= 2.5:\n            return (n // 5 + 1) * 5\n        else:\n            return round(n / 5) * 5\n    return [real_life_rounding(num) for num in numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n\n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_single(num):\n        return math.ceil(num / 5) * 5 if num % 5 >= 2.5 else math.floor(num / 5) * 5\n    return [round_single(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n: float) -> float:\n        return round(n / 5) * 5\n\n    def real_life_rounding(n: float) -> float:\n        remainder = n % 5\n        if remainder >= 2.5:\n            return (n // 5 + 1) * 5\n        else:\n            return round(n / 5) * 5\n    return [real_life_rounding(num) for num in numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return math.ceil(n / 5) * 5 if n % 5 >= 2.5 else math.floor(n / 5) * 5\n    return [nearest_multiple_of_five(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def closest_multiple_of_five(n):\n        return round(n / 5) * 5\n    adjusted_numbers = [n + 2.5 if n % 5 >= 2.5 else n for n in numbers]\n    return [closest_multiple_of_five(n) for n in adjusted_numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_individual(number: float) -> float:\n        quotient = number / 5\n        if quotient - math.floor(quotient) >= 0.5:\n            return math.ceil(quotient) * 5\n        else:\n            return math.floor(quotient) * 5\n    return [round_individual(num) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_five(n: float) -> float:\n        return round(n / 5) * 5\n\n    def nearest_five_real_life(n: float) -> float:\n        base = 5\n        remainder = n % base\n        if remainder >= 2.5:\n            return (n // base + 1) * base\n        else:\n            return round(n / base) * base\n    return [nearest_five_real_life(n) for n in numbers]", "from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round个体开发单个数值(value: float) -> float:\n        remainder = value % 5\n        if remainder >= 2.5:\n            return math.ceil(value / 5) * 5\n        else:\n            return math.floor(value / 5) * 5\n    return [round个体开发单个数值(num) for num in numbers]"], "requirement": [], "outputs": "[[[0, 5, 10]], [[0, 5, 10]], [[0, -5, -10]], [[20, 20, 25, 25, 25]], [[5, 10, 15, 20, 25]], [[0, 5, 5, 10, 10, 15]], [[0, 5, 10, 15, 20, 25]], [[5, 5, 5, 5, 5, 10]], [[20, 25, 30]], [[0, -5, -10, -15, -20]], ['OverflowError'], ['OverflowError'], ['ValueError']]", "probability": 0.22, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_individual(num):\n        remainder = num % 5\n        if remainder >= 2.5:\n            return num + (5 - remainder)\n        else:\n            return num - remainder\n    return [round(float(round_individual(num))) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_five(n):\n        remainder = n % 5\n        if remainder < 2.5:\n            return n - remainder\n        else:\n            return n + (5 - remainder)\n    return [round(nearest_five(num)) for num in numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        \n    Returns:\n        List[float]: A list of numbers rounded to the nearest multiple of 5.\n    \"\"\"\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n\n    def real_life_rounding(n):\n        remainder = n % 5\n        if remainder >= 2.5:\n            return n + (5 - remainder)\n        else:\n            return n - remainder\n    rounded_numbers = [real_life_rounding(n) for n in numbers]\n    return [round(x) for x in rounded_numbers]", "from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_single(num):\n        remainder = num % 5\n        if remainder >= 2.5:\n            return num + (5 - remainder)\n        else:\n            return num - remainder\n    return [round(float(round_single(num))) for num in numbers]"], "requirement": [], "outputs": "[[[0, 5, 10]], [[0, 5, 10]], [[0, -5, -10]], [[20, 20, 25, 25, 25]], [[5, 10, 15, 20, 25]], [[0, 5, 5, 10, 10, 15]], [[0, 5, 10, 15, 20, 25]], [[5, 5, 5, 5, 5, 10]], [[20, 25, 30]], [[0, -5, -10, -15, -20]], ['ValueError'], ['ValueError'], ['ValueError']]", "probability": 0.08, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_five(n):\n        return 5 * round(n / 5)\n\n    def real_life_rounding(n):\n        base = 5 * (n // 5)\n        if n - base >= 2.5:\n            return base + 5\n        else:\n            return base\n    return [real_life_rounding(n) for n in numbers]"], "requirement": [], "outputs": "[[[0.0, 5.0, 10.0]], [[0.0, 5.0, 10.0]], [[0.0, -5.0, -10.0]], [[20.0, 20.0, 25.0, 25.0, 25.0]], [[5.0, 10.0, 15.0, 20.0, 25.0]], [[0.0, 5.0, 5.0, 10.0, 10.0, 15.0]], [[0.0, 5.0, 10.0, 15.0, 20.0, 25.0]], [[5.0, 5.0, 5.0, 5.0, 5.0, 10.0]], [[20.0, 25.0, 30.0]], [[0.0, -5.0, -10.0, -15.0, -20.0]], [[nan]], [[nan]], [[nan]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Args:\n        numbers (List[float]): The list of numbers to be rounded.\n        \n    Returns:\n        List[float]: A new list with each element rounded to the nearest number divisible by 5.\n    \"\"\"\n\n    def round_single(num):\n        return round(num / 5) * 5\n\n    def real_life_round(num):\n        remainder = num % 5\n        if remainder >= 2.5:\n            return num + (5 - remainder)\n        else:\n            return num - remainder\n    return [real_life_round(num) for num in numbers]"], "requirement": [], "outputs": "[[[0.0, 5.0, 10.0]], [[0.0, 5.0, 10.0]], [[2.220446049250313e-16, -5.0, -10.0]], [[20.0, 20.0, 25.0, 25.0, 25.0]], [[5.0, 10.0, 15.0, 20.0, 25.0]], [[0.0, 5.0, 5.0, 10.0, 10.0, 15.0]], [[0.0, 5.0, 10.0, 15.0, 20.0, 25.0]], [[5.0, 5.0, 5.0, 5.0, 5.0, 10.0]], [[20.0, 25.0, 30.0]], [[0.0, -5.0, -10.0, -15.0, -20.0]], [[nan]], [[nan]], [[nan]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\nimport math\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def nearest_divisible_by_five(n: float) -> float:\n        remainder = n % 5\n        if remainder < 2.5:\n            return n - remainder\n        else:\n            return n + (5 - remainder)\n    return [nearest_divisible_by_five(n) for n in numbers]"], "requirement": [], "outputs": "[[[0.0, 5.0, 10.0]], [[0.0, 5.0, 10.0]], [[2.220446049250313e-16, -5.0, -10.0]], [[20.0, 20.0, 25.0, 25.0, 25.0]], [[5.0, 10.0, 15.0, 20.0, 25.0]], [[0.0, 5.0, 5.0, 10.0, 10.0, 15.0]], [[0.0, 5.0, 10.0, 15.0, 20.0, 25.0]], [[5.0, 5.0, 5.0, 5.0, 5.0, 10.0]], [[20.0, 25.0, 30.0]], [[0.0, -5.0, -10.0, -15.0, -20.0]], [[nan]], [[nan]], [[nan]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n\n    def nearest_multiple_of_five(n):\n        return round(n / 5) * 5\n\n    def real_life_rounding(n):\n        remainder = n % 5\n        if remainder >= 2.5:\n            return n + (5 - remainder)\n        else:\n            return n - remainder\n    rounded_numbers = [real_life_rounding(n) for n in numbers]\n    return rounded_numbers"], "requirement": [], "outputs": "[[[0.0, 5.0, 10.0]], [[0.0, 5.0, 10.0]], [[2.220446049250313e-16, -5.0, -10.0]], [[20.0, 20.0, 25.0, 25.0, 25.0]], [[5.0, 10.0, 15.0, 20.0, 25.0]], [[0.0, 5.0, 5.0, 10.0, 10.0, 15.0]], [[0.0, 5.0, 10.0, 15.0, 20.0, 25.0]], [[5.0, 5.0, 5.0, 5.0, 5.0, 10.0]], [[20.0, 25.0, 30.0]], [[0.0, -5.0, -10.0, -15.0, -20.0]], [[nan]], [[nan]], [[nan]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_individual(num: float) -> float:\n        return round(num / 5) * 5\n\n    def real_life_round(num: float) -> float:\n        remainder = num % 5\n        if remainder >= 2.5:\n            return num + (5 - remainder) if num > 0 else num - (5 + remainder)\n        else:\n            return num - remainder if num > 0 else num + (5 - remainder)\n        return round_individual(num)\n    return [real_life_round(num) for num in numbers]"], "requirement": [], "outputs": "[[[0.0, 5.0, 10.0]], [[5.0, 5.0, 10.0]], [[-10.0, 0.0, -5.0]], [[20.0, 20.0, 25.0, 25.0, 25.0]], [[5.0, 10.0, 15.0, 20.0, 25.0]], [[0.0, 5.0, 5.0, 10.0, 10.0, 15.0]], [[0.0, 5.0, 10.0, 15.0, 20.0, 25.0]], [[5.0, 5.0, 5.0, 5.0, 5.0, 10.0]], [[20.0, 25.0, 30.0]], [[-10.0, -15.0, -20.0, -25.0, -30.0]], [[nan]], [[nan]], [[nan]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n    \n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"\n\n    def round_single(x: float) -> float:\n        return round(x / 5) * 5\n    rounded_numbers = [round_single(num) if abs(num - round_single(num)) < 2.5 else round_single(num) + 5 for num in numbers]\n    return rounded_numbers"], "requirement": [], "outputs": "[[[0, 5, 10]], [[0, 5, 10]], [[0, -5, -10]], [[20, 20, 25, 25, 25]], [[5, 15, 15, 25, 25]], [[0, 5, 5, 10, 10, 15]], [[0, 5, 10, 15, 20, 25]], [[5, 5, 5, 5, 5, 15]], [[20, 25, 30]], [[5, -5, -5, -15, -15]], ['OverflowError'], ['OverflowError'], ['ValueError']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.3205509151307584, "llm_generated_inputs": "[[[1.2, 3.5, 7.8]], [[0.0, 4.9, 9.6]], [[-1.2, -3.5, -7.8]], [[22.1, 22.4, 22.5, 22.6, 22.9]], [[2.5, 7.5, 12.5, 17.5, 22.5]], [[0.1, 2.6, 5.1, 7.6, 10.1, 12.6]], [[1.4, 4.2, 9.8, 14.5, 19.1, 24.8]], [[2.5, 3.5, 4.5, 5.5, 6.5, 7.5]], [[20.0, 25.0, 30.0]], [[-2.5, -7.5, -12.5, -17.5, -22.5]], [[inf]], [[-inf]], [[nan]]]", "input_output_examples": "[[[[34.5, 56.2, 11, 13]]], [[[35, 55, 10, 15]]]]", "at_least_one_align": false}, "entry_point": "round_to_five", "ground_truth": -1}
{"task_id": "TACO_lite/21", "requirement": "from typing import List\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\"\"\"The number is the first integer with more than one digit that fulfills the property partially introduced in the title of this kata. \nWhat's the use of saying \"Eureka\"? Because this sum gives the same number.\n\nWe need a function to collect these numbers, that may receive two integers ```a```, ```b``` that defines the range ```[a, b]``` (inclusive) and outputs a list of the sorted numbers in the range that fulfills the property described above.\n\nIf there are no numbers of this kind in the range [a, b] the function should output an empty list.\n\nEnjoy it!!\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(digit) ** (i + 1) for i, digit in enumerate(str(num)))) == num\n    return [num for num in range(a, b + 1) if is_eureka(num)]", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(digit) ** (idx + 1) for idx, digit in enumerate(str(num)))) == num\n    result = []\n    for number in range(a, b + 1):\n        if is_eureka(number):\n            result.append(number)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka_number(n):\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(n)))) == n\n    return [n for n in range(a, b + 1) if is_eureka_number(n)]", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(num)))) == num\n    result = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(num)))) == num\n    eureka_numbers = [num for num in range(a, b + 1) if is_eureka(num)]\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return num == sum((int(d) ** (i + 1) for i, d in enumerate(str(num))))\n    result = [num for num in range(a, b + 1) if is_eureka(num)]\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(digit) ** (i + 1) for i, digit in enumerate(str(num)))) == num\n    eureka_numbers = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka_number(n: int) -> bool:\n        return n == sum((int(d) ** (i + 1) for i, d in enumerate(str(n))))\n    eureka_numbers = []\n    for num in range(a, b + 1):\n        if is_eureka_number(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return num == sum((int(digit) ** (i + 1) for i, digit in enumerate(str(num))))\n    eureka_numbers = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(n: int) -> bool:\n        return n == sum((int(d) ** (i + 1) for i, d in enumerate(str(n))))\n    eureka_numbers = [n for n in range(a, b + 1) if is_eureka(n)]\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(num)))) == num\n    eureka_numbers = [num for num in range(a, b + 1) if is_eureka(num)]\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(n: int) -> bool:\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(n)))) == n\n    return [n for n in range(a, b + 1) if is_eureka(n)]", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(num)))) == num\n    result = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        digits = [int(d) for d in str(num)]\n        return num == sum((d ** (i + 1) for i, d in enumerate(digits)))\n    eureka_numbers = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(num)))) == num\n    eureka_numbers = [num for num in range(a, b + 1) if is_eureka(num)]\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka_number(n: int) -> bool:\n        return sum((int(digit) ** (i + 1) for i, digit in enumerate(str(n)))) == n\n    eureka_numbers = []\n    for num in range(a, b + 1):\n        if is_eureka_number(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        digits = [int(d) for d in str(num)]\n        return num == sum((int(d) ** (i + 1) for i, d in enumerate(digits)))\n    result = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_sum_of_digit_powers(n):\n        str_n = str(n)\n        return n == sum((int(digit) ** (idx + 1) for idx, digit in enumerate(str_n)))\n    result = []\n    for num in range(a, b + 1):\n        if is_sum_of_digit_powers(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        digits = [int(d) for d in str(num)]\n        return num == sum((d ** (i + 1) for i, d in enumerate(digits)))\n    eureka_numbers = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        digits = [int(d) for d in str(num)]\n        return num == sum((int(d) ** (i + 1) for i, d in enumerate(digits)))\n    eureka_numbers = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(num)))) == num\n    result = [num for num in range(a, b + 1) if is_eureka(num)]\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka_number(n: int) -> bool:\n        return sum((int(digit) ** (i + 1) for i, digit in enumerate(str(n)))) == n\n    eureka_numbers = [num for num in range(a, b + 1) if is_eureka_number(num)]\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(n: int) -> bool:\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(n)))) == n\n    return [n for n in range(a, b + 1) if is_eureka(n)]", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        digits = [int(d) for d in str(num)]\n        return num == sum((d ** (i + 1) for i, d in enumerate(digits)))\n    result = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(n: int) -> bool:\n        return n == sum((int(digit) ** (idx + 1) for idx, digit in enumerate(str(n))))\n    return [n for n in range(a, b + 1) if is_eureka(n)]", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        total = 0\n        for i, digit in enumerate(str(num), start=1):\n            total += int(digit) ** i\n        return total == num\n    result = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(n: int) -> bool:\n        total = sum((int(digit) ** (idx + 1) for idx, digit in enumerate(str(n))))\n        return total == n\n    result = [num for num in range(a, b + 1) if is_eureka(num)]\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        digits = [int(d) for d in str(num)]\n        return num == sum((d ** (i + 1) for i, d in enumerate(digits)))\n    result = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka_number(n: int) -> bool:\n        digits = [int(d) for d in str(n)]\n        return n == sum((digit ** (i + 1) for i, digit in enumerate(digits)))\n    eureka_numbers = []\n    for num in range(a, b + 1):\n        if is_eureka_number(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        digits = [int(d) for d in str(num)]\n        return sum((int(d) ** (i + 1) for i, d in enumerate(digits))) == num\n    eureka_numbers = []\n    for num in range(a, b + 1):\n        if is_eureka(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(n: int) -> bool:\n        return n == sum((int(digit) ** (i + 1) for i, digit in enumerate(str(n))))\n    result = [n for n in range(a, b + 1) if is_eureka(n)]\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka_number(n: int) -> bool:\n        return n == sum((int(digit) ** (pos + 1) for pos, digit in enumerate(str(n))))\n    eureka_numbers = [num for num in range(a, b + 1) if is_eureka_number(num)]\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(digit) ** (i + 1) for i, digit in enumerate(str(num)))) == num\n    eureka_numbers = [num for num in range(a, b + 1) if is_eureka(num)]\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(digit) ** (idx + 1) for idx, digit in enumerate(str(num)))) == num\n    return [num for num in range(a, b + 1) if is_eureka(num)]"], "requirement": [], "outputs": "[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 89]], [[89, 135]], [[]], [[1, 2, 3, 4, 5, 6, 7, 8, 9]], [[]], [[]], [[1, 2, 3, 4, 5]], [[]], [[]], [[]], [[]], [[0]], ['ValueError'], [[]]]", "probability": 0.68, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return num == sum((int(digit) ** (i + 1) for i, digit in enumerate(str(num))))\n    result = []\n    for num in range(max(10, a), b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(n: int) -> bool:\n        return n == sum((int(d) ** (i + 1) for i, d in enumerate(str(n))))\n    result = []\n    for num in range(max(10, a), b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(n: int) -> bool:\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(n)))) == n\n    result = []\n    for num in range(max(10, a), b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return num == sum((int(d) ** (i + 1) for i, d in enumerate(str(num))))\n    result = []\n    for num in range(max(10, a), b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return num == sum((int(digit) ** (i + 1) for i, digit in enumerate(str(num))))\n    eureka_numbers = []\n    for num in range(max(10, a), b + 1):\n        if is_eureka(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(digit) ** (i + 1) for i, digit in enumerate(str(num)))) == num\n    eureka_numbers = []\n    for num in range(max(10, a), b + 1):\n        if is_eureka(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_sum_of_powers(n):\n        return n == sum((int(d) ** (i + 1) for i, d in enumerate(str(n))))\n    result = []\n    for num in range(max(a, 10), b + 1):\n        if is_sum_of_powers(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return num == sum((int(digit) ** (i + 1) for i, digit in enumerate(str(num))))\n    eureka_numbers = []\n    for num in range(max(10, a), b + 1):\n        if is_eureka(num):\n            eureka_numbers.append(num)\n    return eureka_numbers", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(num)))) == num\n    result = []\n    for num in range(max(10, a), b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(n: int) -> bool:\n        return n == sum((int(d) ** (i + 1) for i, d in enumerate(str(n))))\n    result = []\n    for num in range(max(10, a), b + 1):\n        if is_eureka(num):\n            result.append(num)\n    return result"], "requirement": [], "outputs": "[[[89]], [[89, 135]], [[]], [[]], [[]], [[]], [[]], [[]], [[]], [[]], [[]], [[]], [[]], [[]]]", "probability": 0.2, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(d) ** (i + 1) for i, d in enumerate(str(num)))) == num\n    return [num for num in range(a, b + 1) if is_eureka(num) and len(str(num)) > 1]", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(n: int) -> bool:\n        return n == sum((int(d) ** (i + 1) for i, d in enumerate(str(n))))\n    return [n for n in range(a, b + 1) if is_eureka(n) and len(str(n)) > 1]", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(digit) ** (i + 1) for i, digit in enumerate(str(num)))) == num\n    return [num for num in range(a, b + 1) if is_eureka(num) and len(str(num)) > 1]", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka_number(n):\n        return n == sum((int(d) ** (i + 1) for i, d in enumerate(str(n))))\n    eureka_numbers = [n for n in range(a, b + 1) if is_eureka_number(n) and len(str(n)) > 1]\n    return sorted(eureka_numbers)", "from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        return sum((int(digit) ** (i + 1) for i, digit in enumerate(str(num)))) == num\n    eureka_numbers = [num for num in range(a, b + 1) if is_eureka(num) and len(str(num)) > 1]\n    return sorted(eureka_numbers)"], "requirement": [], "outputs": "[[[89]], [[89, 135]], [[]], [[]], [[]], [[]], [[]], [[]], [[]], [[]], [[]], [[]], ['ValueError'], [[]]]", "probability": 0.1, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\n    def is_eureka(num):\n        digits = [int(d) for d in str(num)]\n        return sum((digit ** (i + 1) for i, digit in enumerate(digits))) == num\n    result = []\n    for number in range(max(2, a), b + 1):\n        if is_eureka(number):\n            result.append(number)\n    return result"], "requirement": [], "outputs": "[[[2, 3, 4, 5, 6, 7, 8, 9, 89]], [[89, 135]], [[]], [[2, 3, 4, 5, 6, 7, 8, 9]], [[]], [[]], [[2, 3, 4, 5]], [[]], [[]], [[]], [[]], [[]], [[2, 3, 4, 5, 6, 7, 8, 9]], [[]]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 0.8926370388469371, "llm_generated_inputs": "[[1, 100], [89, 135], [120, 130], [1, 10], [90, 100], [146, 157], [1, 5], [10, 12], [88, 88], [134, 134], [1000, 1100], [0, 0], [-10, 10], [150, 140]]", "input_output_examples": "[[[[1, 10]], [[1, 100]], [[90, 100]]], [[[1, 2, 3, 4, 5, 6, 7, 8, 9]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 89]], [[]]]]", "at_least_one_align": false}, "entry_point": "sum_dig_pow", "ground_truth": -1}
{"task_id": "TACO_lite/22", "requirement": "from typing import List\ndef interleave(*args: List[int]) -> List[int]:\n\"\"\"```if-not:ruby\nCreate a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with empty elements.\n```\n```if:ruby\nCreate a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with `nil`s.\n```\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    return [item for tuple in zip_longest(*args) for item in tuple if item is not None]", "from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    result = []\n    for elements in zip_longest(*args):\n        result.extend([elem for elem in elements if elem is not None])\n    return result", "from typing import List, Any\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Any]:\n    interleaved = [item for tuple in zip_longest(*args) for item in tuple if item is not None]\n    return interleaved", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for index in range(max_length):\n        for lst in args:\n            if index < len(lst):\n                result.append(lst[index])\n            else:\n                result.append(None)\n    return result", "from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    result = []\n    for elements in zip_longest(*args):\n        for element in elements:\n            result.append(element if element is not None else None)\n    return result", "from typing import List, Any\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Any]:\n    zipped = zip_longest(*args)\n    interleaved = [item for tuple_pair in zipped for item in tuple_pair if item is not None]\n    return interleaved", "from itertools import zip_longest\nfrom typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    interleaved = [item for tuple in zip_longest(*args) for item in tuple if item is not None]\n    return interleaved", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Any\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Any]:\n    interleaved = [item for tuple in zip_longest(*args) for item in tuple if item is not None]\n    return interleaved", "from typing import List, Any\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Any]:\n    interleaved = [item for tuple in zip_longest(*args) for item in tuple if item is not None]\n    return interleaved", "from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    result = []\n    for elements in zip_longest(*args):\n        for element in elements:\n            result.append(element if element is not None else None)\n    return result", "from itertools import zip_longest\nfrom typing import List, Any\n\ndef interleave(*args: List[int]) -> List[Any]:\n    interleaved = [item for tuple in zip_longest(*args) for item in tuple if item is not None]\n    return interleaved", "from typing import List, Any\n\ndef interleave(*args: List[int]) -> List[Any]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for index in range(max_length):\n        for lst in args:\n            if index < len(lst):\n                result.append(lst[index])\n            else:\n                result.append(None)\n    return result", "from typing import List, Any\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Any]:\n    zipped = zip_longest(*args)\n    interleaved = [item for tup in zipped for item in tup if item is not None]\n    return interleaved", "from typing import List, Tuple\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[int]:\n    zipped = zip_longest(*args)\n    interleaved = [item for tuple_pair in zipped for item in tuple_pair if item is not None]\n    return interleaved", "from typing import List, Iterator\nfrom itertools import zip_longest, chain, filterfalse\n\ndef interleave(*args: List[int]) -> List[int]:\n    zipped = zip_longest(*args)\n    interleaved = list(filterfalse(lambda x: x is None, chain.from_iterable(zipped)))\n    return interleaved", "from typing import List, Any\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Any]:\n    zipped = zip_longest(*args)\n    interleaved = [item for sublist in zipped for item in sublist if item is not None]\n    return interleaved", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for index in range(max_length):\n        for lst in args:\n            if index < len(lst):\n                result.append(lst[index])\n            else:\n                result.append(None)\n    return result", "from typing import List, Iterator\nfrom itertools import zip_longest, chain\n\ndef interleave(*args: List[int]) -> List[int]:\n    return [item for items in zip_longest(*args) for item in items if item is not None]", "from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    zipped = zip_longest(*args)\n    result = []\n    for group in zipped:\n        for item in group:\n            result.append(item)\n    return result", "from itertools import zip_longest\nfrom typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    zipped = zip_longest(*args)\n    interleaved = [elem for tup in zipped for elem in tup if elem is not None]\n    return interleaved", "from typing import List, Any\n\ndef interleave(*args: List[Any]) -> List[Any]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for index in range(max_length):\n        for lst in args:\n            if index < len(lst):\n                result.append(lst[index])\n            else:\n                result.append(None)\n    return result", "from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    zipped = zip_longest(*args)\n    interleaved = []\n    for group in zipped:\n        for item in group:\n            interleaved.append(item)\n    return interleaved", "from typing import List, Iterator\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[int]:\n    zipped = zip_longest(*args)\n    result = [item for tuple_group in zipped for item in tuple_group if item is not None]\n    return result", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_len = max((len(lst) for lst in args))\n    result = []\n    for i in range(max_len):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    result = []\n    for elements in zip_longest(*args):\n        for element in elements:\n            if element is not None:\n                result.append(element)\n            else:\n                result.append(None)\n    return result", "from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    result = []\n    for tuple_elem in zip_longest(*args):\n        result.extend([elem for elem in tuple_elem if elem is not None])\n    return result", "from typing import List, Tuple\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[int]:\n    zipped = zip_longest(*args)\n    result = [item for tup in zipped for item in tup if item is not None]\n    return result", "from typing import List\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[int]:\n    zipped = zip_longest(*args)\n    interleaved = [elem for tup in zipped for elem in tup if elem is not None]\n    return interleaved", "from typing import List, Iterator\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[int]:\n    zipped = zip_longest(*args)\n    interleaved = [item for sublist in zipped for item in sublist if item is not None]\n    return interleaved", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Any\n\ndef interleave(*args: List[int]) -> List[Any]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_length = max((len(lst) for lst in args))\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_length = max((len(lst) for lst in args))\n    result: List[Union[int, None]] = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Any\n\ndef interleave(*args: List[Any]) -> List[Any]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result: List[Union[int, None]] = []\n    for i in range(max_length):\n        for arg in args:\n            if i < len(arg):\n                result.append(arg[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Any\n\ndef interleave(*args: List[Any]) -> List[Any]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result: List[Union[int, None]] = []\n    for i in range(max_length):\n        for lst in args:\n            result.append(lst[i] if i < len(lst) else None)\n    return result", "from typing import List, Any\n\ndef interleave(*args: List[Any]) -> List[Any]:\n    max_length = max((len(lst) for lst in args)) if args else 0\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Iterable\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[int]:\n    result = []\n    for elements in zip_longest(*args):\n        for element in elements:\n            if element is not None:\n                result.append(element)\n            else:\n                result.append(None)\n    return result", "from typing import List, Any\n\ndef interleave(*args: List[int]) -> List[Any]:\n    max_length = max((len(lst) for lst in args))\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Any\n\ndef interleave(*args: List[int]) -> List[Any]:\n    max_length = max((len(lst) for lst in args))\n    result = []\n    for i in range(max_length):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n            else:\n                result.append(None)\n    return result", "from typing import List, Any\n\ndef interleave(*args: List[int]) -> List[Any]:\n    result = []\n    max_length = max((len(lst) for lst in args)) if args else 0\n    for i in range(max_length):\n        for lst in args:\n            result.append(lst[i] if i < len(lst) else None)\n    return result", "from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    \"\"\"\n    Create a function that accepts an arbitrary number of arrays and returns a single array \n    generated by alternately appending elements from the passed-in arguments. If one of them \n    is shorter than the others, the result should be padded with None.\n    \"\"\"\n    zipped = zip_longest(*args)\n    interleaved = [item for tup in zipped for item in tup if item is not None or all((x is None for x in tup))]\n    return interleaved", "from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    \"\"\"\n    Create a function, that accepts an arbitrary number of arrays and returns a single array generated by \n    alternately appending elements from the passed in arguments. If one of them is shorter than the others, \n    the result should be padded with None.\n    \"\"\"\n    zipped = zip_longest(*args, fillvalue=None)\n    interleaved = [item for group in zipped for item in group if item is not None or all((x is None for x in group))]\n    return interleaved", "from typing import List, Union\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    \"\"\"\n    Create a function that accepts an arbitrary number of arrays and returns a single array \n    generated by alternately appending elements from the passed in arguments. If one of them \n    is shorter than the others, the result should be padded with None.\n    \n    Args:\n        *args (List[int]): An arbitrary number of lists containing integers.\n    \n    Returns:\n        List[Union[int, None]]: A list of integers and None values interleaved from the input lists.\n    \"\"\"\n    interleaved = [item for tuple in zip_longest(*args) for item in tuple if item is not None or all((item == None for item in tuple))]\n    return interleaved", "from typing import List, Any\nfrom itertools import zip_longest\n\ndef interleave(*args: List[int]) -> List[Any]:\n    combined = zip_longest(*args)\n    result = []\n    for group in combined:\n        for item in group:\n            result.append(item if item is not None else 'empty')\n    return result", "from typing import List, Iterator\nfrom itertools import zip_longest\nfrom typing import Union\n\ndef interleave(*args: List[int]) -> List[Union[int, None]]:\n    zipped_lists = zip_longest(*args, fillvalue=None)\n    interleaved_list = [item for tuple_group in zipped_lists for item in tuple_group if item is not None]\n    return interleaved_list"], "requirement": [], "outputs": "[[[]]]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[[]]]", "input_output_examples": "[[[[1, 2, 3], ['c', 'd', 'e']], [[1, 2, 3], [4, 5]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[]]], [[[1, 'c', 2, 'd', 3, 'e']], [[1, 4, 2, 5, 3, None]], [[1, 4, 7, 2, 5, 8, 3, 6, 9]], [[]]]]", "at_least_one_align": false}, "entry_point": "interleave", "ground_truth": 0}
{"task_id": "TACO_lite/23", "requirement": "from typing import List\ndef memesorting(meme: List[str]) -> str:\n\"\"\"Roma is programmer and he likes memes about IT,  \nMaxim is chemist and he likes memes about chemistry,  \nDanik is designer and he likes memes about design,  \nand Vlad likes all other memes.\n\n___\n\nYou will be given a meme (string), and your task is to identify its category, and send it to the right receiver: `IT - 'Roma'`, `chemistry - 'Maxim'`, `design - 'Danik'`, or `other - 'Vlad'`.\n\nIT meme has letters `b, u, g`.  \nChemistry meme has letters `b, o, o, m`.  \nDesign meme has letters `e, d, i, t, s`.  \nIf there is more than 1 possible answer, the earliest match should be chosen.\n\n**Note:** letters are case-insensetive and should come in the order specified above.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef memesorting(meme: List[str]) -> str:\n\n    def check_pattern(meme, pattern):\n        i = 0\n        for char in meme:\n            if i < len(pattern) and char.lower() == pattern[i]:\n                i += 1\n            if i == len(pattern):\n                return True\n        return False\n    patterns = {'Roma': ['b', 'u', 'g'], 'Maxim': ['b', 'o', 'o', 'm'], 'Danik': ['e', 'd', 'i', 't', 's']}\n    for receiver, pattern in patterns.items():\n        if check_pattern(meme, pattern):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def check_pattern(meme, pattern):\n        i = 0\n        for char in meme:\n            if i < len(pattern) and char.lower() == pattern[i]:\n                i += 1\n            if i == len(pattern):\n                return True\n        return False\n    patterns = {'IT': ['b', 'u', 'g'], 'chemistry': ['b', 'o', 'o', 'm'], 'design': ['e', 'd', 'i', 't', 's']}\n    for category, pattern in patterns.items():\n        if check_pattern(meme, pattern):\n            return {'IT': 'Roma', 'chemistry': 'Maxim', 'design': 'Danik'}[category]\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def contains_sequence(meme, sequence):\n        index = 0\n        for char in meme:\n            if index < len(sequence) and char.lower() == sequence[index].lower():\n                index += 1\n            if index == len(sequence):\n                return True\n        return False\n    categories = [(('b', 'u', 'g'), 'Roma'), (('b', 'o', 'o', 'm'), 'Maxim'), (('e', 'd', 'i', 't', 's'), 'Danik')]\n    for sequence, receiver in categories:\n        if contains_sequence(meme, sequence):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: List[str]) -> str:\n\n    def check_pattern(meme, pattern):\n        i = 0\n        for char in meme:\n            if i < len(pattern) and char.lower() == pattern[i]:\n                i += 1\n            if i == len(pattern):\n                return True\n        return False\n    patterns = {'Roma': ['b', 'u', 'g'], 'Maxim': ['b', 'o', 'o', 'm'], 'Danik': ['e', 'd', 'i', 't', 's']}\n    for receiver, pattern in patterns.items():\n        if check_pattern(meme, pattern):\n            return receiver\n    return 'Vlad'"], "requirement": [], "outputs": "[['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad'], ['Vlad']]", "probability": 0.08, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def contains_sequence(text, sequence):\n        text = text.lower()\n        idx = 0\n        for char in text:\n            if idx < len(sequence) and char == sequence[idx].lower():\n                idx += 1\n            if idx == len(sequence):\n                return True\n        return False\n    if contains_sequence(meme, 'bug'):\n        return 'Roma'\n    elif contains_sequence(meme, 'boom'):\n        return 'Maxim'\n    elif contains_sequence(meme, 'edits'):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits'}\n    for receiver, pattern in patterns.items():\n        if pattern in meme:\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def has_sequence(s, seq):\n        s = s.lower()\n        index = -1\n        for char in seq:\n            index = s.find(char, index + 1)\n            if index == -1:\n                return False\n        return True\n    meme = meme.lower()\n    if has_sequence(meme, 'bug'):\n        return 'Roma'\n    elif has_sequence(meme, 'boom'):\n        return 'Maxim'\n    elif has_sequence(meme, 'edits'):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: List[str]) -> str:\n\n    def check_pattern(text, pattern):\n        text = text.lower()\n        iter_text = iter(text)\n        return all((char in iter_text for char in pattern))\n    patterns = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits'}\n    for person, pattern in patterns.items():\n        if check_pattern(meme, pattern):\n            return person\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def contains_in_order(meme, seq):\n        meme = meme.lower()\n        index = 0\n        for char in seq:\n            index = meme.find(char, index) + 1\n            if index == 0:\n                return False\n        return True\n    if contains_in_order(meme, 'bug'):\n        return 'Roma'\n    if contains_in_order(meme, 'boom'):\n        return 'Maxim'\n    if contains_in_order(meme, 'edits'):\n        return 'Danik'\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits', 'Vlad': ''}\n    for person, pattern in patterns.items():\n        if all((char in meme for char in pattern)):\n            return person\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    patterns = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits'}\n    meme = meme.lower()\n    for receiver, pattern in patterns.items():\n        if all((letter in meme for letter in pattern)):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {'bug': 'Roma', 'boom': 'Maxim', 'edits': 'Danik'}\n    for pattern, receiver in patterns.items():\n        if all((letter in meme for letter in pattern)):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: List[str]) -> str:\n\n    def contains_sequence(s, seq):\n        seq = list(seq)\n        iter_s = iter(s.lower())\n        return all((char in iter_s for char in seq))\n    mapping = {('b', 'u', 'g'): 'Roma', ('b', 'o', 'o', 'm'): 'Maxim', ('e', 'd', 'i', 't', 's'): 'Danik'}\n    for seq, person in mapping.items():\n        if contains_sequence(meme, seq):\n            return person\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def has_sequence(text, sequence):\n        text = text.lower()\n        index = 0\n        for char in text:\n            if index < len(sequence) and char == sequence[index]:\n                index += 1\n            if index == len(sequence):\n                return True\n        return False\n    it_sequence = ['b', 'u', 'g']\n    chemistry_sequence = ['b', 'o', 'o', 'm']\n    design_sequence = ['e', 'd', 'i', 't', 's']\n    if has_sequence(meme, it_sequence):\n        return 'Roma'\n    elif has_sequence(meme, chemistry_sequence):\n        return 'Maxim'\n    elif has_sequence(meme, design_sequence):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def has_sequence(word, sequence):\n        it = iter(word.lower())\n        return all((c in it for c in sequence))\n    if has_sequence(meme, 'bug'):\n        return 'Roma'\n    if has_sequence(meme, 'boom'):\n        return 'Maxim'\n    if has_sequence(meme, 'edits'):\n        return 'Danik'\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    patterns = [('bug', 'Roma'), ('boom', 'Maxim'), ('edits', 'Danik')]\n    meme_lower = meme.lower()\n    for pattern, receiver in patterns:\n        if all((char in meme_lower for char in pattern)):\n            last_index = -1\n            ordered = True\n            for char in pattern:\n                index = meme_lower.find(char, last_index + 1)\n                if index == -1 or index <= last_index:\n                    ordered = False\n                    break\n                last_index = index\n            if ordered:\n                return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def contains_in_order(word, letters):\n        it = iter(word.lower())\n        return all((any((c == letter for c in it)) for letter in letters))\n    if contains_in_order(meme, 'bug'):\n        return 'Roma'\n    elif contains_in_order(meme, 'boom'):\n        return 'Maxim'\n    elif contains_in_order(meme, 'edits'):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {('b', 'u', 'g'): 'Roma', ('b', 'o', 'o', 'm'): 'Maxim', ('e', 'd', 'i', 't', 's'): 'Danik'}\n    for pattern, receiver in patterns.items():\n        if all((letter in meme for letter in pattern)):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef check_sequence(meme: str, sequence: List[str]) -> bool:\n    index = 0\n    for char in meme.lower():\n        if char == sequence[index]:\n            index += 1\n        if index == len(sequence):\n            return True\n    return False\n\ndef memesorting(meme: str) -> str:\n    sequences = {'Roma': ['b', 'u', 'g'], 'Maxim': ['b', 'o', 'o', 'm'], 'Danik': ['e', 'd', 'i', 't', 's']}\n    for receiver, seq in sequences.items():\n        if check_sequence(meme, seq):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    it_pattern = 'bug'\n    chem_pattern = 'boom'\n    design_pattern = 'edits'\n\n    def contains_pattern(s, pattern):\n        i = 0\n        for char in s:\n            if i < len(pattern) and char == pattern[i]:\n                i += 1\n        return i == len(pattern)\n    if contains_pattern(meme, it_pattern):\n        return 'Roma'\n    elif contains_pattern(meme, chem_pattern):\n        return 'Maxim'\n    elif contains_pattern(meme, design_pattern):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: List[str]) -> str:\n\n    def check_pattern(s, pattern):\n        s = s.lower()\n        iter_s = iter(s)\n        return all((char in iter_s for char in pattern))\n    for m in meme:\n        if check_pattern(m, 'bug'):\n            return 'Roma'\n        elif check_pattern(m, 'boom'):\n            return 'Maxim'\n        elif check_pattern(m, 'edits'):\n            return 'Danik'\n        else:\n            return 'Vlad'\n\ndef memesorting(meme: str) -> str:\n\n    def check_pattern(s, pattern):\n        s = s.lower()\n        pattern = pattern.lower()\n        it = iter(s)\n        return all((char in it for char in pattern))\n    categories = [('bug', 'Roma'), ('boom', 'Maxim'), ('edits', 'Danik')]\n    for pattern, receiver in categories:\n        if check_pattern(meme, pattern):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n\n    def matches_pattern(meme, pattern):\n        pattern_index = 0\n        for char in meme:\n            if char == pattern[pattern_index]:\n                pattern_index += 1\n                if pattern_index == len(pattern):\n                    return True\n        return False\n    patterns = {'Roma': ['b', 'u', 'g'], 'Maxim': ['b', 'o', 'o', 'm'], 'Danik': ['e', 'd', 'i', 't', 's']}\n    for receiver, pattern in patterns.items():\n        if matches_pattern(meme, pattern):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits'}\n    for receiver, pattern in patterns.items():\n        if all((char in meme for char in pattern)) and ''.join(filter(lambda x: x in meme, pattern)) == pattern:\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    \"\"\"Identifies the category of a meme and sends it to the right receiver.\"\"\"\n\n    def contains_subsequence(main_str, subseq):\n        iterator = iter(main_str.lower())\n        return all((char in iterator for char in subseq.lower()))\n    if contains_subsequence(meme, 'bug'):\n        return 'Roma'\n    elif contains_subsequence(meme, 'boom'):\n        return 'Maxim'\n    elif contains_subsequence(meme, 'edits'):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    it_pattern = 'bug'\n    chemistry_pattern = 'boom'\n    design_pattern = 'edits'\n    meme_lower = meme.lower()\n\n    def contains_pattern(s, pattern):\n        start = 0\n        for char in pattern:\n            start = s.find(char, start) + 1\n            if start == 0:\n                return False\n        return True\n    if contains_pattern(meme_lower, it_pattern):\n        return 'Roma'\n    elif contains_pattern(meme_lower, chemistry_pattern):\n        return 'Maxim'\n    elif contains_pattern(meme_lower, design_pattern):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits'}\n    for receiver, pattern in patterns.items():\n        if all((char in meme for char in pattern)):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n\n    def check_pattern(meme, pattern):\n        i = 0\n        for char in meme:\n            if i < len(pattern) and char == pattern[i]:\n                i += 1\n            if i == len(pattern):\n                return True\n        return False\n    patterns = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits', 'Vlad': ''}\n    for person, pattern in patterns.items():\n        if check_pattern(meme, pattern):\n            return person\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {'IT': 'bug', 'chemistry': 'boom', 'design': 'edits'}\n    for category, pattern in patterns.items():\n        if all((meme.find(c, i) > -1 for i, c in enumerate(pattern))):\n            return {'IT': 'Roma', 'chemistry': 'Maxim', 'design': 'Danik'}[category]\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def contains_sequence(meme, sequence):\n        meme = meme.lower()\n        index = 0\n        for char in meme:\n            if index < len(sequence) and char == sequence[index]:\n                index += 1\n            if index == len(sequence):\n                return True\n        return False\n    sequences = {'Roma': ['b', 'u', 'g'], 'Maxim': ['b', 'o', 'o', 'm'], 'Danik': ['e', 'd', 'i', 't', 's']}\n    for person, seq in sequences.items():\n        if contains_sequence(meme, seq):\n            return person\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits'}\n    for receiver, pattern in patterns.items():\n        if all((char in meme for char in pattern)) and ''.join(filter(lambda x: x in meme, pattern)) == pattern:\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    it_sequence = 'bug'\n    chem_sequence = 'boom'\n    design_sequence = 'edits'\n    if all((meme.find(c) != -1 and meme.index(c) == i for i, c in enumerate(it_sequence))):\n        return 'Roma'\n    if all((meme.find(c) != -1 and meme.index(c) == i for i, c in enumerate(chem_sequence))):\n        return 'Maxim'\n    if all((meme.find(c) != -1 and meme.index(c) == i for i, c in enumerate(design_sequence))):\n        return 'Danik'\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    \"\"\"\n    Determines the receiver of a meme based on its content.\n    \n    Args:\n        meme (str): The meme text to categorize.\n        \n    Returns:\n        str: The name of the person who should receive the meme.\n    \"\"\"\n    meme = meme.lower()\n    patterns = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits'}\n    for person, pattern in patterns.items():\n        if all((char in meme for char in pattern)):\n            return person\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    \"\"\"Identify the category of a meme and return the receiver's name.\"\"\"\n    meme = meme.lower()\n\n    def contains_in_order(meme, pattern):\n        last_index = -1\n        for letter in pattern:\n            try:\n                current_index = meme.index(letter, last_index + 1)\n                last_index = current_index\n            except ValueError:\n                return False\n        return True\n    categories = {'IT': ['b', 'u', 'g'], 'chemistry': ['b', 'o', 'o', 'm'], 'design': ['e', 'd', 'i', 't', 's']}\n    for receiver, letters in (('Roma', categories['IT']), ('Maxim', categories['chemistry']), ('Danik', categories['design'])):\n        if contains_in_order(meme, letters):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n\n    def has_sequence(meme: str, sequence: List[str]) -> bool:\n        \"\"\"Check if the meme contains the given sequence of letters in order.\"\"\"\n        index = 0\n        for char in meme:\n            if index < len(sequence) and char == sequence[index]:\n                index += 1\n            if index == len(sequence):\n                return True\n        return False\n    categories = {'Roma': ['b', 'u', 'g'], 'Maxim': ['b', 'o', 'o', 'm'], 'Danik': ['e', 'd', 'i', 't', 's']}\n    for person, sequence in categories.items():\n        if has_sequence(meme, sequence):\n            return person\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    it_pattern = 'bug'\n    chem_pattern = 'boom'\n    design_pattern = 'edits'\n\n    def contains_in_order(s: str, pattern: str) -> bool:\n        start = 0\n        for char in pattern:\n            index = s.find(char, start)\n            if index == -1:\n                return False\n            start = index + 1\n        return True\n    if contains_in_order(meme, it_pattern):\n        return 'Roma'\n    elif contains_in_order(meme, chem_pattern):\n        return 'Maxim'\n    elif contains_in_order(meme, design_pattern):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def contains_sequence(s, seq):\n        index = 0\n        for char in s.lower():\n            if index < len(seq) and char == seq[index]:\n                index += 1\n            if index == len(seq):\n                return True\n        return False\n    sequences = {'Roma': ['b', 'u', 'g'], 'Maxim': ['b', 'o', 'o', 'm'], 'Danik': ['e', 'd', 'i', 't', 's']}\n    for receiver, seq in sequences.items():\n        if contains_sequence(meme, seq):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    \"\"\"Identifies the category of a meme and returns the appropriate receiver.\"\"\"\n\n    def has_consecutive_letters(s: str, letters: List[str]) -> bool:\n        s = s.lower()\n        start_index = 0\n        for letter in letters:\n            index = s.find(letter, start_index)\n            if index == -1:\n                return False\n            start_index = index + 1\n        return True\n    meme = meme.lower()\n    if has_consecutive_letters(meme, ['b', 'u', 'g']):\n        return 'Roma'\n    elif has_consecutive_letters(meme, ['b', 'o', 'o', 'm']):\n        return 'Maxim'\n    elif has_consecutive_letters(meme, ['e', 'd', 'i', 't', 's']):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def check_meme_pattern(meme, pattern):\n        meme_lower = iter(meme.lower())\n        return all((char in meme_lower for char in pattern))\n    patterns = {'Roma': ['b', 'u', 'g'], 'Maxim': ['b', 'o', 'o', 'm'], 'Danik': ['e', 'd', 'i', 't', 's']}\n    for person, pattern in patterns.items():\n        if check_meme_pattern(meme, pattern):\n            return person\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    it_pattern = 'bug'\n    chem_pattern = 'boom'\n    design_pattern = 'edits'\n\n    def contains_in_order(s: str, pattern: str) -> bool:\n        start = 0\n        for char in pattern:\n            index = s.find(char, start)\n            if index == -1:\n                return False\n            start = index + 1\n        return True\n    if contains_in_order(meme, it_pattern):\n        return 'Roma'\n    elif contains_in_order(meme, chem_pattern):\n        return 'Maxim'\n    elif contains_in_order(meme, design_pattern):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def contains_sequence(meme, seq):\n        seq_index = 0\n        for char in meme.lower():\n            if seq_index < len(seq) and char == seq[seq_index]:\n                seq_index += 1\n            if seq_index == len(seq):\n                return True\n        return False\n    it_seq = ['b', 'u', 'g']\n    chem_seq = ['b', 'o', 'o', 'm']\n    design_seq = ['e', 'd', 'i', 't', 's']\n    if contains_sequence(meme, it_seq):\n        return 'Roma'\n    elif contains_sequence(meme, chem_seq):\n        return 'Maxim'\n    elif contains_sequence(meme, design_seq):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def contains_in_order(word: str, chars: List[str]) -> bool:\n        word = word.lower()\n        last_index = -1\n        for char in chars:\n            index = word.find(char, last_index + 1)\n            if index == -1:\n                return False\n            last_index = index\n        return True\n    meme = meme.lower()\n    if contains_in_order(meme, ['b', 'u', 'g']):\n        return 'Roma'\n    elif contains_in_order(meme, ['b', 'o', 'o', 'm']):\n        return 'Maxim'\n    elif contains_in_order(meme, ['e', 'd', 'i', 't', 's']):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def contains_pattern(meme, pattern):\n        meme = meme.lower()\n        index = 0\n        for char in pattern:\n            index = meme.find(char, index) + 1\n            if index == 0:\n                return False\n        return True\n    patterns = {'Roma': ['b', 'u', 'g'], 'Maxim': ['b', 'o', 'o', 'm'], 'Danik': ['e', 'd', 'i', 't', 's']}\n    for person, pattern in patterns.items():\n        if contains_pattern(meme, pattern):\n            return person\n    return 'Vlad'", "from typing import List\n\ndef check_for_subsequence(meme: str, subseq: str) -> bool:\n    \"\"\"\n    Helper function to check if a string contains a subsequence in order.\n    \"\"\"\n    lower_meme = meme.lower()\n    subseq_index = 0\n    for char in lower_meme:\n        if subseq_index < len(subseq) and char == subseq[subseq_index]:\n            subseq_index += 1\n    return subseq_index == len(subseq)\n\ndef memesorting(meme: str) -> str:\n    \"\"\"\n    Determines the receiver of the meme based on its category.\n\n    Args:\n    meme (str): The meme as a string.\n\n    Returns:\n    str: The name of the person who should receive the meme ('Roma', 'Maxim', 'Danik', or 'Vlad').\n    \"\"\"\n    if check_for_subsequence(meme, 'bug'):\n        return 'Roma'\n    elif check_for_subsequence(meme, 'boom'):\n        return 'Maxim'\n    elif check_for_subsequence(meme, 'edits'):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits'}\n    for name, pattern in patterns.items():\n        if all((letter in meme for letter in pattern)) and ''.join([meme[meme.index(pattern[i])] for i in range(len(pattern))]) == pattern:\n            return name\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    \"\"\"Identify the category of a meme and return the receiver's name.\"\"\"\n    meme = meme.lower()\n\n    def contains_in_order(meme, pattern):\n        last_index = -1\n        for letter in pattern:\n            try:\n                current_index = meme.index(letter, last_index + 1)\n                last_index = current_index\n            except ValueError:\n                return False\n        return True\n    categories = {'IT': ['b', 'u', 'g'], 'chemistry': ['b', 'o', 'o', 'm'], 'design': ['e', 'd', 'i', 't', 's']}\n    for receiver, pattern in (('Roma', categories['IT']), ('Maxim', categories['chemistry']), ('Danik', categories['design'])):\n        if contains_in_order(meme, pattern):\n            return receiver\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {'IT': ('b', 'u', 'g'), 'chemistry': ('b', 'o', 'o', 'm'), 'design': ('e', 'd', 'i', 't', 's')}\n\n    def matches_pattern(meme, pattern):\n        index = 0\n        for char in meme:\n            if index < len(pattern) and char == pattern[index]:\n                index += 1\n            if index == len(pattern):\n                return True\n        return False\n    for category, pattern in patterns.items():\n        if matches_pattern(meme, pattern):\n            if category == 'IT':\n                return 'Roma'\n            elif category == 'chemistry':\n                return 'Maxim'\n            elif category == 'design':\n                return 'Danik'\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    it_pattern = 'bug'\n    chemistry_pattern = 'boom'\n    design_pattern = 'edits'\n\n    def contains_in_order(meme, pattern):\n        index = 0\n        for char in pattern:\n            index = meme.find(char, index) + 1\n            if index == 0:\n                return False\n        return True\n    if contains_in_order(meme, it_pattern):\n        return 'Roma'\n    elif contains_in_order(meme, chemistry_pattern):\n        return 'Maxim'\n    elif contains_in_order(meme, design_pattern):\n        return 'Danik'\n    else:\n        return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n    meme = meme.lower()\n    patterns = {'IT': ['b', 'u', 'g'], 'chemistry': ['b', 'o', 'o', 'm'], 'design': ['e', 'd', 'i', 't', 's']}\n\n    def has_pattern(meme, pattern):\n        index = 0\n        for char in meme:\n            if index < len(pattern) and char == pattern[index]:\n                index += 1\n            if index == len(pattern):\n                return True\n        return False\n    for category, pattern in patterns.items():\n        if has_pattern(meme, pattern):\n            if category == 'IT':\n                return 'Roma'\n            elif category == 'chemistry':\n                return 'Maxim'\n            elif category == 'design':\n                return 'Danik'\n    return 'Vlad'", "from typing import List\n\ndef memesorting(meme: str) -> str:\n\n    def has_pattern(meme, pattern):\n        i = 0\n        for char in meme.lower():\n            if i < len(pattern) and char == pattern[i]:\n                i += 1\n            if i == len(pattern):\n                return True\n        return False\n    patterns = {'Roma': ['b', 'u', 'g'], 'Maxim': ['b', 'o', 'o', 'm'], 'Danik': ['e', 'd', 'i', 't', 's']}\n    for person, pattern in patterns.items():\n        if has_pattern(meme, pattern):\n            return person\n    return 'Vlad'", "from typing import List\n\ndef check_subsequence(main_str, sub_seq):\n    main_str = main_str.lower()\n    sub_seq = sub_seq.lower()\n    i = 0\n    j = 0\n    while i < len(main_str) and j < len(sub_seq):\n        if main_str[i] == sub_seq[j]:\n            j += 1\n        i += 1\n    return j == len(sub_seq)\n\ndef memesorting(meme: str) -> str:\n    categories = {'Roma': 'bug', 'Maxim': 'boom', 'Danik': 'edits'}\n    for person, sub_seq in categories.items():\n        if check_subsequence(meme, sub_seq):\n            return person\n    return 'Vlad'"], "requirement": [], "outputs": "[['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError']]", "probability": 0.92, "is_align_req": false, "DRS": null}], "entropy": 0.2787693717685874, "llm_generated_inputs": "[[['bug fixes are fun']], [['Boom goes the dynamite']], [['Editing is an art']], [['Random meme about life']], [['bugs in the system']], [['OOM killed the process']], [['Design thinking and innovation']], [['A bug appeared out of nowhere']], [['The experiment led to a boom']], [['Edits were made to the file']], [['bUg']], [['BOOm']], [['ediTs']], [['BUG']], [['boom']], [['EDITs']], [['No match at all']], [['b u g']], [['b o o m']], [['e d i t s']], [['buG']], [['booM']], [['ediT']], [['a b u g']], [['a b o o m']], [['a e d i t s']]]", "input_output_examples": "[[['this is programmer meme because it has bug'], ['this is also programbur meme gecause it has needed key word'], ['this is edsigner meme cause it ha s key word'], ['this could be chemistry meme but our gey word boom is too late'], ['this could be chemistry meme but our gey word bo our gey word boom is too late']], [['IT - Roma'], ['IT - Roma'], ['design - Danik'], ['other - Vlad'], ['other - Vlad']]]", "at_least_one_align": false}, "entry_point": "memesorting", "ground_truth": -1}
{"task_id": "TACO_lite/24", "requirement": "def not_visible_cubes(n: int) -> int:\n\"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    inner_cube_size = max(n - 2, 0)\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    return (n - 2) ** 3 if n > 2 else 0", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    return (n - 2) ** 3 if n > 2 else 0", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    hidden_cubes = (n - 2) ** 3 if n > 2 else 0\n    return hidden_cubes", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    inner_cube_side = n - 2\n    if inner_cube_side < 0:\n        return 0\n    return inner_cube_side ** 3", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    hidden_cubes = (n - 2) ** 3 if n > 2 else 0\n    return hidden_cubes", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    inner_cube_size = max(n - 2, 0)\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    inner_cube_size = n - 2\n    return inner_cube_size ** 3 if inner_cube_size > 0 else 0", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_side = n - 2\n    if inner_cube_side <= 0:\n        return 0\n    return inner_cube_side ** 3", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    return (n - 2) ** 3 if n - 2 > 0 else 0", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    return (n - 2) ** 3 if n > 2 else 0", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    inner_cube_size = n - 2\n    return inner_cube_size ** 3 if inner_cube_size > 0 else 0", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    hidden_cubes = (n - 2) ** 3 if n > 2 else 0\n    return hidden_cubes", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    hidden_cubes = (n - 2) ** 3\n    return max(0, hidden_cubes)", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube.\n\n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    return (n - 2) ** 3", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    inner_cube_size = (n - 2) ** 3 if n > 2 else 0\n    return inner_cube_size", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    return (n - 2) ** 3", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    return (n - 2) ** 3 if n > 2 else 0", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    non_visible = (n - 2) ** 3\n    return max(0, non_visible)", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube (n x n x n).\n        \n    Returns:\n        int: The number of small cubes not visible from the outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = max(n - 2, 0)\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The dimension of the big cube (n x n x n).\n        \n    Returns:\n        int: The number of small cubes that are not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = (n - 2) ** 3\n    return inner_cube_size if inner_cube_size > 0 else 0", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    total_cubes = n ** 3\n    inner_cube_side_length = n - 2\n    inner_cubes = max(0, inner_cube_side_length) ** 3\n    return inner_cubes", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The number representing the length, width, and height of the big cube.\n        \n    Returns:\n        int: The number of small cubes not visible from the outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    return (n - 2) ** 3 if n > 2 else 0", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    inner_cube_side = n - 2\n    if inner_cube_side <= 0:\n        return 0\n    hidden_cubes = inner_cube_side ** 3\n    return hidden_cubes", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube (n x n x n).\n        \n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = n - 2\n    return inner_cube_size ** 3 if inner_cube_size > 0 else 0", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, \n       how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube (n x n x n).\n        \n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = max(0, n - 2)\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube.\n        \n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = (n - 2) ** 3\n    return inner_cube_size if inner_cube_size > 0 else 0", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube (n x n x n).\n        \n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = max(n - 2, 0)\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube, where each side has n small cubes.\n        \n    Returns:\n        int: The number of small cubes that are not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    return (n - 2) ** 3 if n > 2 else 0", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube (n x n x n).\n\n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = n - 2\n    return inner_cube_size ** 3 if inner_cube_size > 0 else 0", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    outer_layer = n ** 3 - (n - 2) ** 3\n    total_cubes = n ** 3\n    hidden_cubes = total_cubes - outer_layer\n    return hidden_cubes", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube, where each side has n small cubes.\n        \n    Returns:\n        int: The number of small cubes that are not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = max(n - 2, 0)\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    hidden_cubes = (n - 2) ** 3\n    return max(0, hidden_cubes)", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    inner_cube_size = n - 2\n    if inner_cube_size <= 0:\n        return 0\n    inner_cube_volume = inner_cube_size ** 3\n    return inner_cube_volume", "def not_visible_cubes(n: int) -> int:\n    \"\"\"\n    Imagine there's a big cube consisting of n^3 small cubes. \n    Calculate how many small cubes are not visible from outside.\n    \n    Parameters:\n    n (int): The size of the big cube (n x n x n)\n    \n    Returns:\n    int: The number of small cubes not visible from outside\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = max(n - 2, 0)\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube's side.\n        \n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_side = n - 2\n    if inner_cube_side <= 0:\n        return 0\n    not_visible_volume = inner_cube_side ** 3\n    return not_visible_volume", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    inner_cube_side = n - 2\n    if inner_cube_side <= 0:\n        return 0\n    not_visible = inner_cube_side ** 3\n    return not_visible", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Parameters:\n    n (int): The number of small cubes along each edge of the big cube\n    \n    Returns:\n    int: The number of small cubes not visible from the outside\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_length = n - 2\n    return inner_cube_length ** 3 if inner_cube_length > 0 else 0", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube (n x n x n)\n        \n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = n - 2\n    return inner_cube_size ** 3 if inner_cube_size > 0 else 0", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube.\n        \n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = n - 2\n    if inner_cube_size <= 0:\n        return 0\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube.\n        \n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = n - 2\n    if inner_cube_size < 0:\n        return 0\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube.\n\n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = n - 2\n    if inner_cube_size <= 0:\n        return 0\n    not_visible = inner_cube_size ** 3\n    return not_visible", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube (n x n x n)\n        \n    Returns:\n        int: The number of small cubes not visible from outside\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = (n - 2) ** 3 if n > 2 else 0\n    return inner_cube_size", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The number of small cubes along one edge of the big cube.\n        \n    Returns:\n        int: The number of small cubes that are not visible from the outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_side = n - 2\n    if inner_cube_side <= 0:\n        return 0\n    return inner_cube_side ** 3", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the cube (n x n x n).\n        \n    Returns:\n        int: The number of small cubes not visible from the outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = max(n - 2, 0)\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The length of the sides of the big cube.\n        \n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = n - 2\n    if inner_cube_size <= 0:\n        return 0\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the cube (n x n x n)\n        \n    Returns:\n        int: The number of small cubes not visible from outside\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_size = max(n - 2, 0)\n    return inner_cube_size ** 3", "def not_visible_cubes(n: int) -> int:\n    \"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n    \n    Args:\n        n (int): The size of the big cube.\n        \n    Returns:\n        int: The number of small cubes not visible from outside.\n    \"\"\"\n    if n <= 1:\n        return 0\n    inner_cube_side = n - 2\n    if inner_cube_side < 1:\n        return 0\n    return inner_cube_side ** 3", "def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    hidden_cubes = (n - 2) ** 3\n    return hidden_cubes if hidden_cubes > 0 else 0"], "requirement": [], "outputs": "[[0], [0], [1], [27], [512], [0], [0], [941192]]", "probability": 0.98, "is_align_req": false, "DRS": null}, {"programs_str": ["def not_visible_cubes(n: int) -> int:\n    if n <= 1:\n        return 0\n    return (n - 2) ** 3 if n > 2 else 1"], "requirement": [], "outputs": "[[0], [1], [1], [27], [512], [0], [0], [941192]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 0.098039113279732, "llm_generated_inputs": "[[1], [2], [3], [5], [10], [0], [-1], [100]]", "input_output_examples": "[[[4]], [[8]]]", "at_least_one_align": false}, "entry_point": "not_visible_cubes", "ground_truth": -1}
{"task_id": "TACO_lite/25", "requirement": "def fibonacci(m: int) -> int:\n\"\"\"### Problem Context\n\nThe [Fibonacci](http://en.wikipedia.org/wiki/Fibonacci_number) sequence is traditionally used to explain tree recursion.  \n\n```python\ndef fibonacci(n):\n    if n in [0, 1]:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n```\n\nThis algorithm serves welll its educative purpose but it's [tremendously inefficient](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2), not only because of recursion, but because we invoke the fibonacci function twice, and the right branch of recursion (i.e. `fibonacci(n-2)`) recalculates all the Fibonacci numbers already calculated by the left branch (i.e. `fibonacci(n-1)`).\n\nThis algorithm is so inefficient that the time to calculate any Fibonacci number over 50 is simply too much. You may go for a cup of coffee or go take a nap while you wait for the answer. But if you try it here in Code Wars you will most likely get a code timeout before any answers.\n\nFor this particular Kata we want to **implement the memoization solution**. This will be cool because it will let us *keep using the tree recursion* algorithm while still keeping it sufficiently optimized to get an answer very rapidly.\n\nThe trick of the memoized version is that we will keep a cache data structure (most likely an associative array) where we will store the Fibonacci numbers as we calculate them. When a Fibonacci number is calculated, we first look it up in the cache, if it's not there, we calculate it and put it in the cache, otherwise we returned the cached number.\n\nRefactor the function into a recursive Fibonacci function that using  a memoized data structure avoids the deficiencies of tree recursion Can you make it so the memoization cache is private to this function?\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {}\n    if m in _cache:\n        return _cache[m]\n    if m in [0, 1]:\n        return m\n    result = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    _cache[m] = result\n    return result", "def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int) -> int:\n    cache = {}\n\n    def fib(n):\n        if n in [0, 1]:\n            return n\n        if n not in cache:\n            cache[n] = fib(n - 1) + fib(n - 2)\n        return cache[n]\n    return fib(m)", "def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"\n    Computes the Fibonacci of m using memoization to optimize the recursive calls.\n    \n    Args:\n        m (int): The position in the Fibonacci sequence.\n        \n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int) -> int:\n\n    def fib(n, cache={}):\n        if n in cache:\n            return cache[n]\n        elif n in [0, 1]:\n            return n\n        else:\n            result = fib(n - 1) + fib(n - 2)\n            cache[n] = result\n            return result\n    return fib(m)", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Calculate the Fibonacci number of m using memoization to optimize recursion.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        _cache (dict, optional): A private cache to store computed Fibonacci numbers. Defaults to {0: 0, 1: 1}.\n\n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]", "def fibonacci(m: int, _cache: dict=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(n: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if n in _cache:\n        return _cache[n]\n    _cache[n] = fibonacci(n - 1, _cache) + fibonacci(n - 2, _cache)\n    return _cache[n]", "def fibonacci(m: int) -> int:\n    memo = {}\n\n    def fib(n):\n        if n in [0, 1]:\n            return n\n        if n not in memo:\n            memo[n] = fib(n - 1) + fib(n - 2)\n        return memo[n]\n    return fib(m)", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Calculate the m-th Fibonacci number using memoization to optimize recursion.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        \n    Returns:\n        int: The m-th Fibonacci number.\n    \"\"\"\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Calculate the Fibonacci number for given m using memoization.\n\n    Args:\n        m (int): The index of the Fibonacci sequence to compute.\n        \n    Returns:\n        int: The Fibonacci number at index m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int) -> int:\n    memo = {}\n\n    def fib(n):\n        if n in [0, 1]:\n            return n\n        if n in memo:\n            return memo[n]\n        memo[n] = fib(n - 1) + fib(n - 2)\n        return memo[n]\n    return fib(m)", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Compute the m-th Fibonacci number using memoization to optimize.\n\n    Args:\n        m (int): The position of the Fibonacci number to retrieve or compute.\n        _cache (dict, optional): A private dictionary used for memoization. Defaults to {0: 0, 1: 1}.\n\n    Returns:\n        int: The m-th Fibonacci number.\n    \"\"\"\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"\n    Returns the Fibonacci number at position m using memoization to optimize recursive calls.\n    \n    Args:\n    m (int): The position in the Fibonacci sequence to compute.\n    \n    Returns:\n    int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int) -> int:\n\n    def fib_memo(n, memo):\n        if n in memo:\n            return memo[n]\n        if n in [0, 1]:\n            result = n\n        else:\n            result = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)\n        memo[n] = result\n        return result\n    return fib_memo(m, {})", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Calculates the m-th Fibonacci number using memoization to optimize performance.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        _cache (dict, optional): A private cache to store computed Fibonacci numbers. Defaults to {0: 0, 1: 1}.\n\n    Returns:\n        int: The m-th Fibonacci number.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Calculate the Fibonacci number for a given integer m using memoization.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        _cache (dict): A private dictionary used to store previously computed Fibonacci numbers. Defaults to {0: 0, 1: 1}.\n\n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Calculates the m-th Fibonacci number using memoization to optimize performance.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        _cache (dict, optional): A private cache to store computed Fibonacci numbers. Defaults to {0: 0, 1: 1}.\n\n    Returns:\n        int: The m-th Fibonacci number.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Computes the Fibonacci number for a given integer using memoization.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        _cache (dict, optional): A private cache to store previously computed Fibonacci numbers. Defaults to {0: 0, 1: 1}.\n\n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"\n    Calculate the Fibonacci number for a given integer m using memoization.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n    \n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]", "def fibonacci(m: int, _cache=None) -> int:\n    \"\"\"Calculate the m-th Fibonacci number using memoization to avoid redundant calculations.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        _cache (dict, optional): Internal cache for memoization. Defaults to None.\n\n    Returns:\n        int: The m-th Fibonacci number.\n    \"\"\"\n    if _cache is None:\n        _cache = {}\n    if m in [0, 1]:\n        return m\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int) -> int:\n    cache = {}\n\n    def fib(n):\n        if n in cache:\n            return cache[n]\n        elif n in [0, 1]:\n            result = n\n        else:\n            result = fib(n - 1) + fib(n - 2)\n        cache[n] = result\n        return result\n    return fib(m)", "def fibonacci(m: int) -> int:\n    memo = {}\n\n    def fib(n):\n        if n in memo:\n            return memo[n]\n        if n in [0, 1]:\n            return n\n        result = fib(n - 1) + fib(n - 2)\n        memo[n] = result\n        return result\n    return fib(m)", "def fibonacci(m: int) -> int:\n    memo = {}\n\n    def fib(n):\n        if n in [0, 1]:\n            return n\n        if n not in memo:\n            memo[n] = fib(n - 1) + fib(n - 2)\n        return memo[n]\n    return fib(m)", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"\n    Calculates the Fibonacci number for a given integer m using memoization.\n    \n    Args:\n    m (int): The position of the Fibonacci sequence to compute.\n    \n    Returns:\n    int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Calculate the Fibonacci number for m using memoization.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        _cache (dict, optional): Private cache to store Fibonacci numbers. Defaults to {0: 0, 1: 1}.\n\n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]\n\ndef fibonacci(m: int) -> int:\n\n    def fib_helper(n, cache):\n        if n in cache:\n            return cache[n]\n        cache[n] = fib_helper(n - 1, cache) + fib_helper(n - 2, cache)\n        return cache[n]\n    return fib_helper(m, {0: 0, 1: 1})", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"\n    Calculate the Fibonacci number for a given integer m using memoization.\n    \n    Args:\n        m (int): The position in the Fibonacci sequence to compute.\n        \n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"\n    Calculate the Fibonacci number of m using memoization to optimize recursion.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        _cache (dict, optional): A private dictionary used for memoization. \n                                 Defaults to {0: 0, 1: 1}.\n\n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache: dict=None) -> int:\n    \"\"\"Calculate the Fibonacci number for a given integer m using memoization.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        _cache (dict, optional): A private cache to store computed Fibonacci numbers. Defaults to None.\n\n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"\n    Calculate the Fibonacci number for a given integer m using memoization.\n    \n    Args:\n        m (int): The position in the Fibonacci sequence.\n        \n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]\n\ndef fibonacci(m: int) -> int:\n\n    def fib_helper(n, cache):\n        if n in cache:\n            return cache[n]\n        cache[n] = fib_helper(n - 1, cache) + fib_helper(n - 2, cache)\n        return cache[n]\n    return fib_helper(m, {0: 0, 1: 1})", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Compute the m-th Fibonacci number using memoization to optimize recursion.\"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Calculate the Fibonacci number for a given integer m using memoization.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        \n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"\n    Calculate the Fibonacci number for a given integer m using memoization.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        \n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Calculate the Fibonacci number for a given m using memoization.\n\n    Args:\n    m (int): The position in the Fibonacci sequence.\n\n    Returns:\n    int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"Calculate the m-th Fibonacci number using memoization to optimize recursion.\n\n    Args:\n        m (int): The position in the Fibonacci sequence.\n        \n    Returns:\n        int: The m-th Fibonacci number.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]\n\ndef fibonacci(m: int) -> int:\n    _cache = {0: 0, 1: 1}\n\n    def fib_helper(n: int) -> int:\n        if n in _cache:\n            return _cache[n]\n        _cache[n] = fib_helper(n - 1) + fib_helper(n - 2)\n        return _cache[n]\n    return fib_helper(m)", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"\n    Calculate the Fibonacci number for a given integer m using memoization.\n    \n    Args:\n        m (int): The position in the Fibonacci sequence.\n        \n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1) + fibonacci(m - 2)\n    return _cache[m]", "def fibonacci(m: int, _cache={0: 0, 1: 1}) -> int:\n    \"\"\"\n    Calculate the Fibonacci number at position m using memoization.\n    \n    Args:\n        m (int): The position in the Fibonacci sequence.\n        _cache (dict, optional): A private dictionary to store previously computed Fibonacci numbers. Defaults to {0: 0, 1: 1}.\n    \n    Returns:\n        int: The Fibonacci number at position m.\n    \"\"\"\n    if m in _cache:\n        return _cache[m]\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int) -> int:\n    cache = {}\n\n    def fib(n):\n        if n in [0, 1]:\n            return n\n        if n in cache:\n            return cache[n]\n        cache[n] = fib(n - 1) + fib(n - 2)\n        return cache[n]\n    return fib(m)", "def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {}\n    if m in [0, 1]:\n        return m\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]", "def fibonacci(m: int, _cache={}) -> int:\n    \"\"\"Calculate the m-th Fibonacci number using memoization to optimize recursive calls.\"\"\"\n    if m in [0, 1]:\n        return m\n    if m not in _cache:\n        _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]"], "requirement": [], "outputs": "[[0], [1], [1], [5], [55], [6765], [832040], [102334155], [12586269025], ['RecursionError'], ['RecursionError'], ['RecursionError'], ['RecursionError'], ['TypeError'], ['TypeError'], ['TypeError'], [354224848179261915075]]", "probability": 0.94, "is_align_req": false, "DRS": null}, {"programs_str": ["def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m in _cache:\n        return _cache[m]\n    if m <= 1:\n        return m\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]"], "requirement": [], "outputs": "[[0], [1], [1], [5], [55], [6765], [832040], [102334155], [12586269025], [-1], [-10], [0.0], [60.2000000000001], ['TypeError'], ['TypeError'], ['TypeError'], [354224848179261915075]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def fibonacci(m: int, _cache=None) -> int:\n    if _cache is None:\n        _cache = {0: 0, 1: 1}\n    if m in _cache:\n        return _cache[m]\n    if m < 0:\n        raise ValueError('Input should be a non-negative integer')\n    _cache[m] = fibonacci(m - 1, _cache) + fibonacci(m - 2, _cache)\n    return _cache[m]"], "requirement": [], "outputs": "[[0], [1], [1], [5], [55], [6765], [832040], [102334155], [12586269025], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['TypeError'], ['TypeError'], ['TypeError'], [354224848179261915075]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from functools import lru_cache\n\ndef fibonacci(m: int) -> int:\n    if m in [0, 1]:\n        return m\n    return fibonacci(m - 1) + fibonacci(m - 2)"], "requirement": [], "outputs": "[[0], [1], [1], [5], [55], [6765], [832040], 'Timeout', 'Timeout', ['RecursionError'], ['RecursionError'], ['RecursionError'], ['RecursionError'], ['TypeError'], ['TypeError'], ['TypeError'], 'Timeout']", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 0.29288425982069105, "llm_generated_inputs": "[[0], [1], [2], [5], [10], [20], [30], [40], [50], [-1], [-10], [1.5], [10.8], ['string'], [[1, 2, 3]], [None], [100]]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "fibonacci", "ground_truth": -1}
{"task_id": "TACO_lite/26", "requirement": "def calculate_1rm(w: int, r: int) -> int:\n\"\"\"You just got done with your set at the gym, and you are wondering how much weight you could lift if you did a single repetition. Thankfully, a few scholars have devised formulas for this purpose (from [Wikipedia](https://en.wikipedia.org/wiki/One-repetition_maximum)) :\n\n\n### Epley\n\n\n### McGlothin\n\n\n### Lombardi\n\n\nYour function will receive a weight `w` and a number of repetitions `r` and must return your projected one repetition maximum. Since you are not sure which formula to use and you are feeling confident, your function will return the largest value from the three formulas shown above, rounded to the nearest integer. However, if the number of repetitions passed in is `1` (i.e., it is already a one rep max), your function must return `w`. Also, if the number of repetitions passed in is `0` (i.e., no repetitions were completed), your function must return `0`.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + 0.0333 * r)\n    lombardi = w * r ** 0.1\n    max_1rm = max(epley, mcglothin, lombardi)\n    return round(max_1rm)", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + 0.0333 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + 0.0333 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + 0.0333 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"Calculate the one-repetition maximum (1RM) based on given weight and repetitions.\n    \n    Args:\n        w (int): Weight lifted.\n        r (int): Number of repetitions performed.\n\n    Returns:\n        int: Projected one repetition maximum rounded to the nearest integer.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + 0.0333 * r)\n    lombardi = w * r ** 0.1\n    one_rm = max(epley, mcglothin, lombardi)\n    return round(one_rm)", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculates the one-repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Returns the largest value from these formulas,\n    rounded to the nearest integer. If r is 1, returns w. If r is 0, returns 0.\n    \n    :param w: The weight lifted.\n    :param r: The number of repetitions.\n    :return: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + 0.0333 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the largest value from the three formulas,\n    rounded to the nearest integer. If r is 1, return w. If r is 0, return 0.\n    \n    Parameters:\n    w (int): The weight lifted.\n    r (int): The number of repetitions.\n    \n    Returns:\n    int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + 0.0333 * r)\n    lombardi = w * r ** 0.1\n    max_1rm = max(epley, mcglothin, lombardi)\n    return round(max_1rm)"], "requirement": [], "outputs": "[[117], [267], [150], [0], [0], [279], [228], [420], [144], [96], [253], [197], [-12], ['TypeError'], [167], [75], [200], [100]]", "probability": 0.14, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import pow\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40)\n    lombardi = w * pow(r, 0.1)\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculates the one repetition maximum (1RM) using three different formulas \n    and returns the largest value rounded to the nearest integer.\n    \n    Args:\n        w (int): The weight lifted.\n        r (int): The number of repetitions.\n\n    Returns:\n        int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40)\n    lombardi = w * math.pow(r, 0.1)\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculates the one repetition maximum (1RM) using three different formulas \n    and returns the largest value rounded to the nearest integer.\n    \n    Args:\n        w (int): The weight lifted.\n        r (int): The number of repetitions.\n\n    Returns:\n        int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    else:\n        epley = w * (1 + r / 30)\n        mcglothin = w * (1 + r / 40)\n        lombardi = w * math.pow(r, 0.1)\n        max_1rm = max(epley, mcglothin, lombardi)\n        return round(max_1rm)"], "requirement": [], "outputs": "[[117], [267], [150], [0], [0], [279], [228], [420], [144], [96], [253], [197], [-11], ['ValueError'], [167], [75], [200], [100]]", "probability": 0.06, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (r + 1) / (0.033 * r + 1)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))"], "requirement": [], "outputs": "[[515], [1654], [150], [0], [0], [910], [1282], [2794], [701], [253], [972], [1040], [-12], ['TypeError'], [1265], [535], [200], [100]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (r / (1.0278 - 0.0278 * r))\n    lombardi = w * r ** 0.1\n    one_rep_max = max(epley, mcglothin, lombardi)\n    return round(one_rep_max)", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (r / (1.0278 - 0.0278 * r))\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))"], "requirement": [], "outputs": "[[563], [2667], [150], [0], [0], [794], [1788], [5186], [836], [185], [960], [1344], [-12], ['TypeError'], [4239], [1228], [200], [100]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (r + 1) / r\n    lombardi = w * math.pow(r, 0.1)\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (r + 1) / r\n    lombardi = w * math.pow(r, 0.1)\n    return round(max(epley, mcglothin, lombardi))"], "requirement": [], "outputs": "[[120], [267], [150], [0], [0], [333], [228], [420], [144], [135], [275], [197], [-12], ['ValueError'], [167], [75], [200], [100]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40)\n    lombardi = w * r ** 0.1\n    max_1rm = max(epley, mcglothin, lombardi)\n    return round(max_1rm)", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculates the one repetition maximum (1RM) using three different formulas\n    and returns the largest value rounded to the nearest integer.\n    \n    Args:\n    w (int): The weight lifted.\n    r (int): The number of repetitions.\n\n    Returns:\n    int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40)\n    lombardi = w * r ** 0.1\n    max_1rm = max(epley, mcglothin, lombardi)\n    return round(max_1rm)", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40) * (1 - 0.005 * (r - 1))\n    lombardi = w * r ** 0.1\n    max_1rm = max(epley, mcglothin, lombardi)\n    return round(max_1rm)", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculates the one-repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Returns the largest value from these formulas,\n    rounded to the nearest integer. If r is 1, returns w. If r is 0, returns 0.\n    \n    :param w: Weight lifted in the set (in pounds).\n    :param r: Number of repetitions performed.\n    :return: Projected one repetition maximum rounded to the nearest integer.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"Calculates the one repetition maximum based on the given weight and repetitions.\n    \n    Args:\n        w (int): The weight lifted.\n        r (int): The number of repetitions.\n\n    Returns:\n        int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / 40)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))"], "requirement": [], "outputs": "[[117], [267], [150], [0], [0], [279], [228], [420], [144], [96], [253], [197], [-11], ['TypeError'], [167], [75], [200], [100]]", "probability": 0.18, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / (r + 25))\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))"], "requirement": [], "outputs": "[[117], [267], [150], [0], [0], [279], [228], [420], [144], [97], [253], [197], [-12], ['TypeError'], [167], [75], [200], [100]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + 0.0333 * r)\n    lombardi = w * math.pow(r, 0.1)\n    return round(max(epley, mcglothin, lombardi))"], "requirement": [], "outputs": "[[117], [267], [150], [0], [0], [279], [228], [420], [144], [96], [253], [197], [-12], ['ValueError'], [167], [75], [200], [100]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (100 / (101.3 - 2.67123 * r))\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"Calculate the one-repetition maximum (1RM) using three formulas and return the largest value.\"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (100 / (101.3 - 2.67123 * r))\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    eply = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    return round(max(eply, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the largest value from these formulas,\n    rounded to the nearest integer. If r is 1, return w. If r is 0, return 0.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    max_1rm = max(epley, mcglothin, lombardi)\n    return round(max_1rm)", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one-repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Returns the largest value from these formulas,\n    rounded to the nearest integer. If r is 1, returns w; if r is 0, returns 0.\n    \n    Args:\n    w (int): The weight lifted.\n    r (int): The number of repetitions.\n\n    Returns:\n    int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the highest value from these formulas,\n    rounded to the nearest integer. If repetitions are 1, return the weight directly.\n    If repetitions are 0, return 0.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one-repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the largest value from these formulas,\n    rounded to the nearest integer. If r is 1, return w. If r is 0, return 0.\n    \n    Parameters:\n    w (int): The weight lifted.\n    r (int): The number of repetitions.\n\n    Returns:\n    int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (100 / (101.3 - 2.67123 * r))\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one-repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the largest value from these formulas,\n    rounded to the nearest integer. If r is 1, return w. If r is 0, return 0.\n    \n    Args:\n    w (int): The weight lifted.\n    r (int): The number of repetitions.\n    \n    Returns:\n    int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (100 / (101.3 - 2.67123 * r))\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one repetition maximum (1RM) using three different formulas \n    and return the largest value rounded to the nearest integer.\n    \n    Parameters:\n    w (int): The weight used for the exercise.\n    r (int): The number of repetitions completed.\n    \n    Returns:\n    int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one-repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the largest value from these formulas,\n    rounded to the nearest integer. If r is 1, return w. If r is 0, return 0.\n    \n    Parameters:\n    w (int): The weight lifted.\n    r (int): The number of repetitions.\n    \n    Returns:\n    int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one-repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the largest value from these formulas,\n    rounded to the nearest integer.\n    \n    If r is 1, return w as it is already a one rep max.\n    If r is 0, return 0 as no repetitions were completed.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (100 / (101.3 - 2.67123 * r))\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one repetition maximum (1RM) using the Epley, McGlothin, and Lombardi formulas.\n    \n    Parameters:\n    w (int): The weight lifted.\n    r (int): The number of repetitions performed.\n    \n    Returns:\n    int: The projected 1RM rounded to the nearest integer.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the projected one repetition maximum using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the largest value from the three formulas,\n    rounded to the nearest integer. If r is 1, return w. If r is 0, return 0.\n    \n    Parameters:\n    w (int): Weight lifted.\n    r (int): Number of repetitions.\n    \n    Returns:\n    int: Projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    max_1rm = max(epley, mcglothin, lombardi)\n    return round(max_1rm)", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one-repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the highest value from these formulas,\n    rounded to the nearest integer. If r is 1, return w. If r is 0, return 0.\n    \n    Args:\n    w (int): The weight lifted.\n    r (int): The number of repetitions.\n    \n    Returns:\n    int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    else:\n        epley = w * (1 + r / 30)\n        mcglothin = w * (100 / (101.3 - 2.67123 * r))\n        lombardi = w * r ** 0.1\n        return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one repetition maximum (1RM) using Epley, McGlothin, and Lombardi formulas.\n    \n    Parameters:\n    w (int): The weight lifted.\n    r (int): The number of repetitions performed.\n    \n    Returns:\n    int: The projected one repetition maximum rounded to the nearest integer.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))"], "requirement": [], "outputs": "[[117], [268], [150], [0], [0], [279], [228], [433], [144], [96], [253], [197], [-11], ['TypeError'], [209], [82], [200], [100]]", "probability": 0.36, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\" Calculates the one repetition maximum (1RM) using three formulas \n        and returns the maximum value from them.\n    \n    Args:\n        w (int): The weight lifted.\n        r (int): The number of repetitions.\n\n    Returns:\n        int: The projected one repetition maximum rounded to the nearest integer.\n    \"\"\"\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (r + 1) / (1.0278 - 0.0278 * r)\n    lombardi = w * r ** 0.1\n    max_1rm = max(epley, mcglothin, lombardi)\n    return round(max_1rm)"], "requirement": [], "outputs": "[[675], [2934], [150], [0], [0], [1059], [2011], [5618], [976], [278], [1200], [1536], [-12], ['TypeError'], [4451], [1310], [200], [100]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"Calculates the one repetition maximum using three formulas and returns the largest value.\n    \n    Args:\n        w (int): The weight lifted.\n        r (int): The number of repetitions performed.\n\n    Returns:\n        int: The projected one repetition maximum rounded to the nearest integer.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / (8 + r / 25))\n    lombardi = w * math.pow(r, 0.1)\n    return round(max(epley, mcglothin, lombardi))"], "requirement": [], "outputs": "[[161], [438], [150], [0], [0], [342], [353], [725], [207], [112], [328], [295], [-12], ['ValueError'], [327], [137], [200], [100]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the highest value from these formulas,\n    rounded to the nearest integer. If repetitions are 1, return the weight.\n    If repetitions are 0, return 0.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + (r - 1) / (30 - (r - 1)))\n    lombardi = w * r ** 0.1\n    max_1rm = max(epley, mcglothin, lombardi)\n    return round(max_1rm)"], "requirement": [], "outputs": "[[117], [286], [150], [0], [0], [279], [235], [474], [144], [96], [253], [200], [-12], ['TypeError'], [273], [94], [200], [100]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    if r == 0:\n        return 0\n    elif r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (1 + r / (100 - w))\n    lombardi = w * r ** 0.1\n    return round(max(epley, mcglothin, lombardi))"], "requirement": [], "outputs": "[['ZeroDivisionError'], [267], [150], [0], [0], [279], [228], [420], [144], [108], [253], [197], [-10], ['ZeroDivisionError'], ['ZeroDivisionError'], [75], [200], [100]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the largest value from these formulas,\n    rounded to the nearest integer.\n    \n    Args:\n    w (int): The weight lifted.\n    r (int): The number of repetitions.\n    \n    Returns:\n    int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = 100 * w / (101.3 - 2.67123 * r)\n    lombardi = w * math.pow(r, 0.1)\n    return round(max(epley, mcglothin, lombardi))", "import math\n\ndef calculate_1rm(w: int, r: int) -> int:\n    \"\"\"\n    Calculate the one repetition maximum (1RM) using three different formulas:\n    Epley, McGlothin, and Lombardi. Return the largest value from these formulas,\n    rounded to the nearest integer. If r == 1, return w. If r == 0, return 0.\n    \n    Args:\n    w (int): The weight lifted.\n    r (int): The number of repetitions.\n    \n    Returns:\n    int: The projected one repetition maximum.\n    \"\"\"\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    epley = w * (1 + r / 30)\n    mcglothin = w * (100 / (101.3 - 2.67123 * r))\n    lombardi = w * math.pow(r, 0.1)\n    return round(max(epley, mcglothin, lombardi))"], "requirement": [], "outputs": "[[117], [268], [150], [0], [0], [279], [228], [433], [144], [96], [253], [197], [-11], ['ValueError'], [209], [82], [200], [100]]", "probability": 0.04, "is_align_req": false, "DRS": null}], "entropy": 2.0544669288099833, "llm_generated_inputs": "[[100, 5], [200, 10], [150, 1], [0, 10], [100, 0], [250, 3], [180, 8], [300, 12], [120, 6], [90, 2], [220, 4], [160, 7], [-10, 5], [100, -5], [100, 20], [50, 15], [200, 1], [100, 1]]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "calculate_1rm", "ground_truth": -1}
{"task_id": "TACO_lite/27", "requirement": "def my_crib(n: int) -> str:\n\"\"\"## Task\n\nGiven `n` representing the number of floors build a beautiful multi-million dollar mansions like the ones in the example below:\n\n**Note:** whitespace should be preserved on both sides of the roof. Number of floors will go up to 30. There will be no tests with invalid input.\n\nIf you manage to complete it, you can try a harder version [here](https://www.codewars.com/kata/58360d112fb0ba255300008b).\n\nGood luck!\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def my_crib(n: int) -> str:\n    base_width = n * 2 - 1\n    result = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        result.append(f'{spaces}{stars}{spaces}')\n    for _ in range(n):\n        result.append('*' * base_width)\n    return '\\n'.join(result)", "def my_crib(n: int) -> str:\n    import math\n    total_width = n * 2 - 1\n    result = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        result.append(f'{spaces}{stars}{spaces}')\n    for _ in range(n):\n        result.append(f'{'*' * total_width}')\n    return '\\n'.join(result)", "def my_crib(n: int) -> str:\n    import math\n    total_width = 2 * n - 1\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    floor = ['*' * total_width] * n\n    crib = roof + floor\n    return '\\n'.join(crib)", "def my_crib(n: int) -> str:\n    from math import ceil\n    roof = []\n    max_width = 2 * n - 1\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    floor = []\n    for _ in range(n):\n        floor.append('*' * max_width)\n    crib = '\\n'.join(roof + floor)\n    return crib", "def my_crib(n: int) -> str:\n    from math import ceil\n    width = n * 2 - 1\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        roof.append(spaces + stars + spaces)\n    floor = []\n    for _ in range(n):\n        floor.append('*' * width)\n    crib = '\\n'.join(roof + floor)\n    return crib", "def my_crib(n: int) -> str:\n    base_width = n * 2 - 1\n    result = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        result.append(spaces + stars + spaces)\n    for _ in range(n):\n        result.append('*' * base_width)\n    return '\\n'.join(result)", "def my_crib(n: int) -> str:\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        roof.append(spaces + stars + spaces)\n    wall_width = 2 * n - 1\n    floor = ['*' * wall_width] * n\n    crib = roof + floor\n    return '\\n'.join(crib)", "def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    result = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (base_width - 2 * (n - i - 1))\n        result.append(f'{spaces}{stars}{spaces}')\n    for _ in range(n):\n        spaces = ' ' * ((base_width - (n * 2 - 1)) // 2)\n        stars = '*' * (n * 2 - 1)\n        result.append(f'{spaces}{stars}{spaces}')\n    return '\\n'.join(result)", "def my_crib(n: int) -> str:\n    from math import ceil\n    width = n * 2 - 1\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        roof.append(spaces + stars + spaces)\n    floor = ['*' * width] * n\n    crib = roof + floor\n    return '\\n'.join(crib)", "def my_crib(n: int) -> str:\n    from math import ceil\n    base_width = n * 2 - 1\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    floor = []\n    for _ in range(n):\n        spaces = ' ' * ((base_width + 1) // 2 - n)\n        stars = '*' * base_width\n        floor.append(f'{spaces}{stars}{spaces}')\n    return '\\n'.join(roof + floor)", "def my_crib(n: int) -> str:\n\n    def create_roof(n):\n        roof = []\n        for i in range(n):\n            spaces = ' ' * (n - i - 1)\n            stars = '*' * (2 * i + 1)\n            roof.append(spaces + stars + spaces)\n        return roof\n\n    def create_base(n):\n        base_width = 2 * n - 1\n        base = []\n        for _ in range(n):\n            base.append('*' * base_width)\n        return base\n    roof_part = create_roof(n)\n    base_part = create_base(n)\n    full_structure = roof_part + base_part\n    return '\\n'.join(full_structure)"], "requirement": [], "outputs": "[['*\\n*'], [' * \\n***\\n***\\n***'], ['  *  \\n *** \\n*****\\n*****\\n*****\\n*****'], ['   *   \\n  ***  \\n ***** \\n*******\\n*******\\n*******\\n*******\\n*******'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n*********\\n*********\\n*********\\n*********\\n*********'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************']]", "probability": 0.22, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    house = []\n    for i in range(n):\n        walls = '*'\n        spaces = ' ' * (2 * n - 2)\n        house.append(f'*{spaces}*')\n    crib = '\\n'.join(roof + house)\n    return crib"], "requirement": [], "outputs": "[['*\\n**'], [' * \\n***\\n*  *\\n*  *'], ['  *  \\n *** \\n*****\\n*    *\\n*    *\\n*    *'], ['   *   \\n  ***  \\n ***** \\n*******\\n*      *\\n*      *\\n*      *\\n*      *'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n*        *\\n*        *\\n*        *\\n*        *\\n*        *'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    crib = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        crib.append(spaces + stars + spaces)\n    floor_line = '+' + '-' * (2 * n - 2) + '+'\n    for _ in range(n):\n        crib.append(floor_line)\n    return '\\n'.join(crib)"], "requirement": [], "outputs": "[['*\\n++'], [' * \\n***\\n+--+\\n+--+'], ['  *  \\n *** \\n*****\\n+----+\\n+----+\\n+----+'], ['   *   \\n  ***  \\n ***** \\n*******\\n+------+\\n+------+\\n+------+\\n+------+'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n+--------+\\n+--------+\\n+--------+\\n+--------+\\n+--------+'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n+------------------+\\n+------------------+\\n+------------------+\\n+------------------+\\n+------------------+\\n+------------------+\\n+------------------+\\n+------------------+\\n+------------------+\\n+------------------+'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+\\n+--------------------------------------+'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+\\n+----------------------------------------------------------+'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+\\n+------------------------------------------------------------+']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        roof.append(spaces + stars + spaces)\n    floor_width = 2 * n - 1\n    floors = [('*' * floor_width).center(floor_width + 2) for _ in range(n)]\n    crib_parts = roof + floors\n    return '\\n'.join(crib_parts)", "def my_crib(n: int) -> str:\n    from math import ceil\n    base_width = n * 2 - 1\n    roof_width = base_width + 2\n    crib_levels = []\n    for i in range(1, n + 1):\n        spaces = ' ' * (n - i)\n        stars = '*' * (2 * i - 1)\n        crib_levels.append(spaces + stars + spaces)\n    for _ in range(n):\n        spaces = ' ' * ceil((roof_width - base_width) / 2)\n        stars = '*' * base_width\n        crib_levels.append(spaces + stars + spaces)\n    return '\\n'.join(crib_levels)", "def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    roof_width = base_width + 2\n    result = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        result.append(f'{spaces}{stars}{spaces}')\n    for i in range(n):\n        spaces = ' ' * math.ceil((roof_width - base_width) / 2)\n        stars = '*' * base_width\n        result.append(f'{spaces}{stars}{spaces}')\n    return '\\n'.join(result)"], "requirement": [], "outputs": "[['*\\n * '], [' * \\n***\\n *** \\n *** '], ['  *  \\n *** \\n*****\\n ***** \\n ***** \\n ***** '], ['   *   \\n  ***  \\n ***** \\n*******\\n ******* \\n ******* \\n ******* \\n ******* '], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n ********* \\n ********* \\n ********* \\n ********* \\n ********* '], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* '], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** '], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** '], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* ']]", "probability": 0.06, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    roof_width = base_width + 2 * (n - 1)\n    crib = []\n    for i in range(n):\n        spaces = ' ' * (n - 1 - i)\n        stars = '*' * (base_width + 2 * i)\n        crib.append(f'{spaces}{stars}{spaces}')\n    for _ in range(n):\n        walls = '|' + ' ' * (roof_width - 2) + '|'\n        crib.append(walls)\n    return '\\n'.join(crib)"], "requirement": [], "outputs": "[['*\\n||'], [' *** \\n*****\\n|   |\\n|   |'], ['  *****  \\n ******* \\n*********\\n|       |\\n|       |\\n|       |'], ['   *******   \\n  *********  \\n *********** \\n*************\\n|           |\\n|           |\\n|           |\\n|           |'], ['    *********    \\n   ***********   \\n  *************  \\n *************** \\n*****************\\n|               |\\n|               |\\n|               |\\n|               |\\n|               |'], ['         *******************         \\n        *********************        \\n       ***********************       \\n      *************************      \\n     ***************************     \\n    *****************************    \\n   *******************************   \\n  *********************************  \\n *********************************** \\n*************************************\\n|                                   |\\n|                                   |\\n|                                   |\\n|                                   |\\n|                                   |\\n|                                   |\\n|                                   |\\n|                                   |\\n|                                   |\\n|                                   |'], ['                   ***************************************                   \\n                  *****************************************                  \\n                 *******************************************                 \\n                *********************************************                \\n               ***********************************************               \\n              *************************************************              \\n             ***************************************************             \\n            *****************************************************            \\n           *******************************************************           \\n          *********************************************************          \\n         ***********************************************************         \\n        *************************************************************        \\n       ***************************************************************       \\n      *****************************************************************      \\n     *******************************************************************     \\n    *********************************************************************    \\n   ***********************************************************************   \\n  *************************************************************************  \\n *************************************************************************** \\n*****************************************************************************\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |\\n|                                                                           |'], ['                             ***********************************************************                             \\n                            *************************************************************                            \\n                           ***************************************************************                           \\n                          *****************************************************************                          \\n                         *******************************************************************                         \\n                        *********************************************************************                        \\n                       ***********************************************************************                       \\n                      *************************************************************************                      \\n                     ***************************************************************************                     \\n                    *****************************************************************************                    \\n                   *******************************************************************************                   \\n                  *********************************************************************************                  \\n                 ***********************************************************************************                 \\n                *************************************************************************************                \\n               ***************************************************************************************               \\n              *****************************************************************************************              \\n             *******************************************************************************************             \\n            *********************************************************************************************            \\n           ***********************************************************************************************           \\n          *************************************************************************************************          \\n         ***************************************************************************************************         \\n        *****************************************************************************************************        \\n       *******************************************************************************************************       \\n      *********************************************************************************************************      \\n     ***********************************************************************************************************     \\n    *************************************************************************************************************    \\n   ***************************************************************************************************************   \\n  *****************************************************************************************************************  \\n ******************************************************************************************************************* \\n*********************************************************************************************************************\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |\\n|                                                                                                                   |'], [''], [''], ['                              *************************************************************                              \\n                             ***************************************************************                             \\n                            *****************************************************************                            \\n                           *******************************************************************                           \\n                          *********************************************************************                          \\n                         ***********************************************************************                         \\n                        *************************************************************************                        \\n                       ***************************************************************************                       \\n                      *****************************************************************************                      \\n                     *******************************************************************************                     \\n                    *********************************************************************************                    \\n                   ***********************************************************************************                   \\n                  *************************************************************************************                  \\n                 ***************************************************************************************                 \\n                *****************************************************************************************                \\n               *******************************************************************************************               \\n              *********************************************************************************************              \\n             ***********************************************************************************************             \\n            *************************************************************************************************            \\n           ***************************************************************************************************           \\n          *****************************************************************************************************          \\n         *******************************************************************************************************         \\n        *********************************************************************************************************        \\n       ***********************************************************************************************************       \\n      *************************************************************************************************************      \\n     ***************************************************************************************************************     \\n    *****************************************************************************************************************    \\n   *******************************************************************************************************************   \\n  *********************************************************************************************************************  \\n *********************************************************************************************************************** \\n*************************************************************************************************************************\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |\\n|                                                                                                                       |']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    width = 2 * n - 1\n    crib = ''\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        crib += spaces + stars + spaces + '\\n'\n    for _ in range(n):\n        line = '|' + ' ' * (width - 2) + '|' + '\\n'\n        crib += line\n    return crib[:-1]"], "requirement": [], "outputs": "[['*\\n||'], [' * \\n***\\n| |\\n| |'], ['  *  \\n *** \\n*****\\n|   |\\n|   |\\n|   |'], ['   *   \\n  ***  \\n ***** \\n*******\\n|     |\\n|     |\\n|     |\\n|     |'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n|       |\\n|       |\\n|       |\\n|       |\\n|       |'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        roof.append(spaces + stars + spaces)\n    house = []\n    for i in range(n):\n        bars = '|' + '*' * (2 * n - 2) + '|'\n        house.append(bars)\n    crib = roof + house\n    return '\\n'.join(crib)"], "requirement": [], "outputs": "[['*\\n||'], [' * \\n***\\n|**|\\n|**|'], ['  *  \\n *** \\n*****\\n|****|\\n|****|\\n|****|'], ['   *   \\n  ***  \\n ***** \\n*******\\n|******|\\n|******|\\n|******|\\n|******|'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n|********|\\n|********|\\n|********|\\n|********|\\n|********|'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n|******************|\\n|******************|\\n|******************|\\n|******************|\\n|******************|\\n|******************|\\n|******************|\\n|******************|\\n|******************|\\n|******************|'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|\\n|**************************************|'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|\\n|**********************************************************|'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|\\n|************************************************************|']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    from math import ceil\n    base_width = n * 2 - 1\n    crib = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        crib.append(spaces + stars + spaces)\n    floor_line = '*' * base_width\n    for _ in range(n):\n        spaces = ' ' * ((base_width - n) // 2)\n        crib.append(spaces + floor_line + spaces)\n    return '\\n'.join(crib)"], "requirement": [], "outputs": "[['*\\n*'], [' * \\n***\\n***\\n***'], ['  *  \\n *** \\n*****\\n ***** \\n ***** \\n ***** '], ['   *   \\n  ***  \\n ***** \\n*******\\n ******* \\n ******* \\n ******* \\n ******* '], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n  *********  \\n  *********  \\n  *********  \\n  *********  \\n  *********  '], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    '], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         '], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              '], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               ']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    roof_height = math.ceil(n / 2)\n    floor_height = n\n    roof = []\n    for i in range(roof_height):\n        spaces = ' ' * (roof_height - i - 1)\n        stars = '*' * (i * 2 + 1)\n        line = f'{spaces}{stars}{spaces}'\n        roof.append(line)\n    floors = []\n    for _ in range(floor_height):\n        line = f'{'*' * base_width}'\n        floors.append(line)\n    crib = '\\n'.join(roof + floors)\n    return crib"], "requirement": [], "outputs": "[['*\\n*'], ['*\\n***\\n***'], [' * \\n***\\n*****\\n*****\\n*****'], [' * \\n***\\n*******\\n*******\\n*******\\n*******'], ['  *  \\n *** \\n*****\\n*********\\n*********\\n*********\\n*********\\n*********'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************'], ['              *              \\n             ***             \\n            *****            \\n           *******           \\n          *********          \\n         ***********         \\n        *************        \\n       ***************       \\n      *****************      \\n     *******************     \\n    *********************    \\n   ***********************   \\n  *************************  \\n *************************** \\n*****************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************'], [''], [''], ['               *               \\n              ***              \\n             *****             \\n            *******            \\n           *********           \\n          ***********          \\n         *************         \\n        ***************        \\n       *****************       \\n      *******************      \\n     *********************     \\n    ***********************    \\n   *************************   \\n  ***************************  \\n ***************************** \\n*******************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    from math import ceil\n    base_width = n * 2 - 1\n    crib = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        crib.append(spaces + stars + spaces)\n    floor_line = '+' + '-' * base_width + '+'\n    for _ in range(n):\n        crib.append(floor_line)\n    return '\\n'.join(crib)"], "requirement": [], "outputs": "[['*\\n+-+'], [' * \\n***\\n+---+\\n+---+'], ['  *  \\n *** \\n*****\\n+-----+\\n+-----+\\n+-----+'], ['   *   \\n  ***  \\n ***** \\n*******\\n+-------+\\n+-------+\\n+-------+\\n+-------+'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n+---------+\\n+---------+\\n+---------+\\n+---------+\\n+---------+'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    result = [f'{' ' * ((base_width - (i * 2 + 1)) // 2)}{'|' * (i * 2 + 1)}' for i in range(n)]\n    for i in range(n):\n        stars = i * 2 + 1\n        spaces = (base_width - stars) // 2\n        result.insert(0, f'{' ' * spaces}{'*' * stars}')\n    return '\\n'.join(result)"], "requirement": [], "outputs": "[['*\\n|'], ['***\\n *\\n |\\n|||'], ['*****\\n ***\\n  *\\n  |\\n |||\\n|||||'], ['*******\\n *****\\n  ***\\n   *\\n   |\\n  |||\\n |||||\\n|||||||'], ['*********\\n *******\\n  *****\\n   ***\\n    *\\n    |\\n   |||\\n  |||||\\n |||||||\\n|||||||||'], ['*******************\\n *****************\\n  ***************\\n   *************\\n    ***********\\n     *********\\n      *******\\n       *****\\n        ***\\n         *\\n         |\\n        |||\\n       |||||\\n      |||||||\\n     |||||||||\\n    |||||||||||\\n   |||||||||||||\\n  |||||||||||||||\\n |||||||||||||||||\\n|||||||||||||||||||'], ['***************************************\\n *************************************\\n  ***********************************\\n   *********************************\\n    *******************************\\n     *****************************\\n      ***************************\\n       *************************\\n        ***********************\\n         *********************\\n          *******************\\n           *****************\\n            ***************\\n             *************\\n              ***********\\n               *********\\n                *******\\n                 *****\\n                  ***\\n                   *\\n                   |\\n                  |||\\n                 |||||\\n                |||||||\\n               |||||||||\\n              |||||||||||\\n             |||||||||||||\\n            |||||||||||||||\\n           |||||||||||||||||\\n          |||||||||||||||||||\\n         |||||||||||||||||||||\\n        |||||||||||||||||||||||\\n       |||||||||||||||||||||||||\\n      |||||||||||||||||||||||||||\\n     |||||||||||||||||||||||||||||\\n    |||||||||||||||||||||||||||||||\\n   |||||||||||||||||||||||||||||||||\\n  |||||||||||||||||||||||||||||||||||\\n |||||||||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||||||||||'], ['***********************************************************\\n *********************************************************\\n  *******************************************************\\n   *****************************************************\\n    ***************************************************\\n     *************************************************\\n      ***********************************************\\n       *********************************************\\n        *******************************************\\n         *****************************************\\n          ***************************************\\n           *************************************\\n            ***********************************\\n             *********************************\\n              *******************************\\n               *****************************\\n                ***************************\\n                 *************************\\n                  ***********************\\n                   *********************\\n                    *******************\\n                     *****************\\n                      ***************\\n                       *************\\n                        ***********\\n                         *********\\n                          *******\\n                           *****\\n                            ***\\n                             *\\n                             |\\n                            |||\\n                           |||||\\n                          |||||||\\n                         |||||||||\\n                        |||||||||||\\n                       |||||||||||||\\n                      |||||||||||||||\\n                     |||||||||||||||||\\n                    |||||||||||||||||||\\n                   |||||||||||||||||||||\\n                  |||||||||||||||||||||||\\n                 |||||||||||||||||||||||||\\n                |||||||||||||||||||||||||||\\n               |||||||||||||||||||||||||||||\\n              |||||||||||||||||||||||||||||||\\n             |||||||||||||||||||||||||||||||||\\n            |||||||||||||||||||||||||||||||||||\\n           |||||||||||||||||||||||||||||||||||||\\n          |||||||||||||||||||||||||||||||||||||||\\n         |||||||||||||||||||||||||||||||||||||||||\\n        |||||||||||||||||||||||||||||||||||||||||||\\n       |||||||||||||||||||||||||||||||||||||||||||||\\n      |||||||||||||||||||||||||||||||||||||||||||||||\\n     |||||||||||||||||||||||||||||||||||||||||||||||||\\n    |||||||||||||||||||||||||||||||||||||||||||||||||||\\n   |||||||||||||||||||||||||||||||||||||||||||||||||||||\\n  |||||||||||||||||||||||||||||||||||||||||||||||||||||||\\n |||||||||||||||||||||||||||||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||'], [''], [''], ['*************************************************************\\n ***********************************************************\\n  *********************************************************\\n   *******************************************************\\n    *****************************************************\\n     ***************************************************\\n      *************************************************\\n       ***********************************************\\n        *********************************************\\n         *******************************************\\n          *****************************************\\n           ***************************************\\n            *************************************\\n             ***********************************\\n              *********************************\\n               *******************************\\n                *****************************\\n                 ***************************\\n                  *************************\\n                   ***********************\\n                    *********************\\n                     *******************\\n                      *****************\\n                       ***************\\n                        *************\\n                         ***********\\n                          *********\\n                           *******\\n                            *****\\n                             ***\\n                              *\\n                              |\\n                             |||\\n                            |||||\\n                           |||||||\\n                          |||||||||\\n                         |||||||||||\\n                        |||||||||||||\\n                       |||||||||||||||\\n                      |||||||||||||||||\\n                     |||||||||||||||||||\\n                    |||||||||||||||||||||\\n                   |||||||||||||||||||||||\\n                  |||||||||||||||||||||||||\\n                 |||||||||||||||||||||||||||\\n                |||||||||||||||||||||||||||||\\n               |||||||||||||||||||||||||||||||\\n              |||||||||||||||||||||||||||||||||\\n             |||||||||||||||||||||||||||||||||||\\n            |||||||||||||||||||||||||||||||||||||\\n           |||||||||||||||||||||||||||||||||||||||\\n          |||||||||||||||||||||||||||||||||||||||||\\n         |||||||||||||||||||||||||||||||||||||||||||\\n        |||||||||||||||||||||||||||||||||||||||||||||\\n       |||||||||||||||||||||||||||||||||||||||||||||||\\n      |||||||||||||||||||||||||||||||||||||||||||||||||\\n     |||||||||||||||||||||||||||||||||||||||||||||||||||\\n    |||||||||||||||||||||||||||||||||||||||||||||||||||||\\n   |||||||||||||||||||||||||||||||||||||||||||||||||||||||\\n  |||||||||||||||||||||||||||||||||||||||||||||||||||||||||\\n |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    house = []\n    for i in range(n):\n        walls = '*' + ' ' * (2 * n - 2) + '*'\n        house.append(walls)\n    base = [f'{'*' * (2 * n)}'] * n\n    crib = roof + house + base\n    return '\\n'.join(crib)"], "requirement": [], "outputs": "[['*\\n**\\n**'], [' * \\n***\\n*  *\\n*  *\\n****\\n****'], ['  *  \\n *** \\n*****\\n*    *\\n*    *\\n*    *\\n******\\n******\\n******'], ['   *   \\n  ***  \\n ***** \\n*******\\n*      *\\n*      *\\n*      *\\n*      *\\n********\\n********\\n********\\n********'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n*        *\\n*        *\\n*        *\\n*        *\\n*        *\\n**********\\n**********\\n**********\\n**********\\n**********'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n********************\\n********************\\n********************\\n********************\\n********************\\n********************\\n********************\\n********************\\n********************\\n********************'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************\\n****************************************'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************\\n************************************************************'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************\\n**************************************************************']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    crib_lines = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        crib_lines.append(spaces + stars + spaces)\n    for i in range(n):\n        stars = '*' * base_width\n        pipe_pattern = '|' + ' ' * (base_width - 2) + '|'\n        if i == 0:\n            crib_lines.append(stars)\n        else:\n            crib_lines.append(pipe_pattern)\n    return '\\n'.join(crib_lines)"], "requirement": [], "outputs": "[['*\\n*'], [' * \\n***\\n***\\n| |'], ['  *  \\n *** \\n*****\\n*****\\n|   |\\n|   |'], ['   *   \\n  ***  \\n ***** \\n*******\\n*******\\n|     |\\n|     |\\n|     |'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n*********\\n|       |\\n|       |\\n|       |\\n|       |'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n*******************\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n***************************************\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n***********************************************************\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n*************************************************************\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    roof_height = math.ceil(n / 2)\n    roof = []\n    for i in range(roof_height):\n        spaces = ' ' * (n - 1 - i)\n        stars = '*' * (1 + 2 * i)\n        roof.append(f'{spaces}{stars}{spaces}')\n    house_body = []\n    for i in range(n):\n        side_spaces = ' ' * (n - 1)\n        middle_stars = '*' * base_width\n        house_body.append(f'{side_spaces}{middle_stars}{side_spaces}')\n    crib = '\\n'.join(roof + house_body)\n    return crib"], "requirement": [], "outputs": "[['*\\n*'], [' * \\n *** \\n *** '], ['  *  \\n *** \\n  *****  \\n  *****  \\n  *****  '], ['   *   \\n  ***  \\n   *******   \\n   *******   \\n   *******   \\n   *******   '], ['    *    \\n   ***   \\n  *****  \\n    *********    \\n    *********    \\n    *********    \\n    *********    \\n    *********    '], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         '], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   '], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             '], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              ']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    width = 2 * n + (n - 1) * 2\n    result = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        result.append(f'{spaces}{stars}{spaces}')\n    for i in range(n):\n        floor = '|' + '=' * (width - 2) + '|'\n        result.append(floor)\n    return '\\n'.join(result)"], "requirement": [], "outputs": "[['*\\n||'], [' * \\n***\\n|====|\\n|====|'], ['  *  \\n *** \\n*****\\n|========|\\n|========|\\n|========|'], ['   *   \\n  ***  \\n ***** \\n*******\\n|============|\\n|============|\\n|============|\\n|============|'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n|================|\\n|================|\\n|================|\\n|================|\\n|================|'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n|====================================|\\n|====================================|\\n|====================================|\\n|====================================|\\n|====================================|\\n|====================================|\\n|====================================|\\n|====================================|\\n|====================================|\\n|====================================|'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|\\n|============================================================================|'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|\\n|====================================================================================================================|'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|\\n|========================================================================================================================|']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    from math import floor\n    base_width = n * 2 - 1\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        roof.append(spaces + stars + spaces)\n    body = []\n    for _ in range(n):\n        line = ('*' + ' ' * (base_width - 2) + '*').center(base_width + 2)\n        body.append(line)\n    crib_parts = roof + body\n    return '\\n'.join(crib_parts)"], "requirement": [], "outputs": "[['*\\n **'], [' * \\n***\\n * * \\n * * '], ['  *  \\n *** \\n*****\\n *   * \\n *   * \\n *   * '], ['   *   \\n  ***  \\n ***** \\n*******\\n *     * \\n *     * \\n *     * \\n *     * '], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n *       * \\n *       * \\n *       * \\n *       * \\n *       * '], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n *                 * \\n *                 * \\n *                 * \\n *                 * \\n *                 * \\n *                 * \\n *                 * \\n *                 * \\n *                 * \\n *                 * '], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * \\n *                                     * '], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * \\n *                                                         * '], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * \\n *                                                           * ']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    house_width = n * 2 - 1\n    roof = []\n    for i in range(math.ceil(n / 2)):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    floors = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * house_width\n        floors.append(f'{spaces}{stars}{spaces}')\n    mansion = '\\n'.join(roof + floors)\n    return mansion"], "requirement": [], "outputs": "[['*\\n*'], [' * \\n *** \\n***'], ['  *  \\n *** \\n  *****  \\n ***** \\n*****'], ['   *   \\n  ***  \\n   *******   \\n  *******  \\n ******* \\n*******'], ['    *    \\n   ***   \\n  *****  \\n    *********    \\n   *********   \\n  *********  \\n ********* \\n*********'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n         *******************         \\n        *******************        \\n       *******************       \\n      *******************      \\n     *******************     \\n    *******************    \\n   *******************   \\n  *******************  \\n ******************* \\n*******************'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n                   ***************************************                   \\n                  ***************************************                  \\n                 ***************************************                 \\n                ***************************************                \\n               ***************************************               \\n              ***************************************              \\n             ***************************************             \\n            ***************************************            \\n           ***************************************           \\n          ***************************************          \\n         ***************************************         \\n        ***************************************        \\n       ***************************************       \\n      ***************************************      \\n     ***************************************     \\n    ***************************************    \\n   ***************************************   \\n  ***************************************  \\n *************************************** \\n***************************************'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n                             ***********************************************************                             \\n                            ***********************************************************                            \\n                           ***********************************************************                           \\n                          ***********************************************************                          \\n                         ***********************************************************                         \\n                        ***********************************************************                        \\n                       ***********************************************************                       \\n                      ***********************************************************                      \\n                     ***********************************************************                     \\n                    ***********************************************************                    \\n                   ***********************************************************                   \\n                  ***********************************************************                  \\n                 ***********************************************************                 \\n                ***********************************************************                \\n               ***********************************************************               \\n              ***********************************************************              \\n             ***********************************************************             \\n            ***********************************************************            \\n           ***********************************************************           \\n          ***********************************************************          \\n         ***********************************************************         \\n        ***********************************************************        \\n       ***********************************************************       \\n      ***********************************************************      \\n     ***********************************************************     \\n    ***********************************************************    \\n   ***********************************************************   \\n  ***********************************************************  \\n *********************************************************** \\n***********************************************************'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n                              *************************************************************                              \\n                             *************************************************************                             \\n                            *************************************************************                            \\n                           *************************************************************                           \\n                          *************************************************************                          \\n                         *************************************************************                         \\n                        *************************************************************                        \\n                       *************************************************************                       \\n                      *************************************************************                      \\n                     *************************************************************                     \\n                    *************************************************************                    \\n                   *************************************************************                   \\n                  *************************************************************                  \\n                 *************************************************************                 \\n                *************************************************************                \\n               *************************************************************               \\n              *************************************************************              \\n             *************************************************************             \\n            *************************************************************            \\n           *************************************************************           \\n          *************************************************************          \\n         *************************************************************         \\n        *************************************************************        \\n       *************************************************************       \\n      *************************************************************      \\n     *************************************************************     \\n    *************************************************************    \\n   *************************************************************   \\n  *************************************************************  \\n ************************************************************* \\n*************************************************************']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    base_width = n * 2 + 2\n    result = [(n * ' ' + '/' + (base_width - 2) * ' ' + '\\\\').center(base_width + 2)]\n    for i in range(n, 0, -1):\n        floor = '|' + ('==' if i == n else '  ') + (i * 2 - 2) * '  ' + ('==' if i == n else '  ') + '|'\n        result.append(floor.center(base_width))\n    result.append('+' + '-' * (base_width - 2) + '+')\n    return '\\n'.join(result)"], "requirement": [], "outputs": "[[' /  \\\\ \\n|====|\\n+--+'], ['  /    \\\\\\n|==    ==|\\n|    |\\n+----+'], ['   /      \\\\\\n|==        ==|\\n|        |\\n |    | \\n+------+'], ['    /        \\\\\\n|==            ==|\\n|            |\\n|        |\\n  |    |  \\n+--------+'], ['     /          \\\\\\n|==                ==|\\n|                |\\n|            |\\n |        | \\n   |    |   \\n+----------+'], ['          /                    \\\\\\n|==                                    ==|\\n|                                    |\\n|                                |\\n|                            |\\n|                        |\\n|                    |\\n  |                |  \\n    |            |    \\n      |        |      \\n        |    |        \\n+--------------------+'], ['                    /                                        \\\\\\n|==                                                                            ==|\\n|                                                                            |\\n|                                                                        |\\n|                                                                    |\\n|                                                                |\\n|                                                            |\\n|                                                        |\\n|                                                    |\\n|                                                |\\n|                                            |\\n|                                        |\\n  |                                    |  \\n    |                                |    \\n      |                            |      \\n        |                        |        \\n          |                    |          \\n            |                |            \\n              |            |              \\n                |        |                \\n                  |    |                  \\n+----------------------------------------+'], ['                              /                                                            \\\\\\n|==                                                                                                                    ==|\\n|                                                                                                                    |\\n|                                                                                                                |\\n|                                                                                                            |\\n|                                                                                                        |\\n|                                                                                                    |\\n|                                                                                                |\\n|                                                                                            |\\n|                                                                                        |\\n|                                                                                    |\\n|                                                                                |\\n|                                                                            |\\n|                                                                        |\\n|                                                                    |\\n|                                                                |\\n|                                                            |\\n  |                                                        |  \\n    |                                                    |    \\n      |                                                |      \\n        |                                            |        \\n          |                                        |          \\n            |                                    |            \\n              |                                |              \\n                |                            |                \\n                  |                        |                  \\n                    |                    |                    \\n                      |                |                      \\n                        |            |                        \\n                          |        |                          \\n                            |    |                            \\n+------------------------------------------------------------+'], [' /\\\\ \\n++'], ['/\\\\\\n++'], ['                               /                                                              \\\\\\n|==                                                                                                                        ==|\\n|                                                                                                                        |\\n|                                                                                                                    |\\n|                                                                                                                |\\n|                                                                                                            |\\n|                                                                                                        |\\n|                                                                                                    |\\n|                                                                                                |\\n|                                                                                            |\\n|                                                                                        |\\n|                                                                                    |\\n|                                                                                |\\n|                                                                            |\\n|                                                                        |\\n|                                                                    |\\n|                                                                |\\n |                                                            | \\n   |                                                        |   \\n     |                                                    |     \\n       |                                                |       \\n         |                                            |         \\n           |                                        |           \\n             |                                    |             \\n               |                                |               \\n                 |                            |                 \\n                   |                        |                   \\n                     |                    |                     \\n                       |                |                       \\n                         |            |                         \\n                           |        |                           \\n                             |    |                             \\n+--------------------------------------------------------------+']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    from math import ceil\n    total_width = 2 * n + 2\n    mansion = []\n    for i in range(n):\n        spaces_before_star = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        mansion.append(f'{spaces_before_star}{stars}{spaces_before_star}')\n    for i in range(n + 1):\n        floor = '*' + '#' * (total_width - 2) + '*'\n        mansion.append(floor)\n    return '\\n'.join(mansion)"], "requirement": [], "outputs": "[['*\\n*##*\\n*##*'], [' * \\n***\\n*####*\\n*####*\\n*####*'], ['  *  \\n *** \\n*****\\n*######*\\n*######*\\n*######*\\n*######*'], ['   *   \\n  ***  \\n ***** \\n*******\\n*########*\\n*########*\\n*########*\\n*########*\\n*########*'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n*##########*\\n*##########*\\n*##########*\\n*##########*\\n*##########*\\n*##########*'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n*####################*\\n*####################*\\n*####################*\\n*####################*\\n*####################*\\n*####################*\\n*####################*\\n*####################*\\n*####################*\\n*####################*\\n*####################*'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*\\n*########################################*'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*\\n*############################################################*'], ['**'], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*\\n*##############################################################*']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    from math import ceil\n    base_width = n * 2 - 1\n    roof_width = base_width + 2\n    roof = []\n    for i in range(ceil(n / 2)):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    base = []\n    for i in range(n):\n        spaces = ' ' * ((roof_width - base_width) // 2)\n        stars = '*' * base_width\n        base.append(f'{spaces}{stars}{spaces}')\n    crib = '\\n'.join(roof + base)\n    return crib"], "requirement": [], "outputs": "[['*\\n * '], [' * \\n *** \\n *** '], ['  *  \\n *** \\n ***** \\n ***** \\n ***** '], ['   *   \\n  ***  \\n ******* \\n ******* \\n ******* \\n ******* '], ['    *    \\n   ***   \\n  *****  \\n ********* \\n ********* \\n ********* \\n ********* \\n ********* '], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* \\n ******************* '], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** \\n *************************************** '], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** \\n *********************************************************** '], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* \\n ************************************************************* ']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    from math import ceil\n\n    def draw_roof(floors):\n        roof = []\n        max_width = 2 * floors - 1\n        for i in range(floors):\n            spaces = ' ' * (floors - i - 1)\n            stars = '*' * (2 * i + 1)\n            roof.append(f'{spaces}{stars}{spaces}')\n        return '\\n'.join(roof)\n\n    def draw_walls_and_floor(floors):\n        wall = '|' + ' ' * (2 * floors - 2) + '|'\n        floor = '+' + '-' * (2 * floors - 2) + '+'\n        return f'{wall}\\n'.join([floor] + [wall] * floors + [floor])\n    if n == 0:\n        return ''\n    roof_part = draw_roof(n)\n    structure_part = draw_walls_and_floor(n)\n    return f'{roof_part}\\n{structure_part}'"], "requirement": [], "outputs": "[['*\\n++||\\n||||\\n++'], [' * \\n***\\n+--+|  |\\n|  ||  |\\n|  ||  |\\n+--+'], ['  *  \\n *** \\n*****\\n+----+|    |\\n|    ||    |\\n|    ||    |\\n|    ||    |\\n+----+'], ['   *   \\n  ***  \\n ***** \\n*******\\n+------+|      |\\n|      ||      |\\n|      ||      |\\n|      ||      |\\n|      ||      |\\n+------+'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n+--------+|        |\\n|        ||        |\\n|        ||        |\\n|        ||        |\\n|        ||        |\\n|        ||        |\\n+--------+'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n+------------------+|                  |\\n|                  ||                  |\\n|                  ||                  |\\n|                  ||                  |\\n|                  ||                  |\\n|                  ||                  |\\n|                  ||                  |\\n|                  ||                  |\\n|                  ||                  |\\n|                  ||                  |\\n|                  ||                  |\\n+------------------+'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n+--------------------------------------+|                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n|                                      ||                                      |\\n+--------------------------------------+'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n+----------------------------------------------------------+|                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n|                                                          ||                                                          |\\n+----------------------------------------------------------+'], [''], ['\\n++||\\n++'], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n+------------------------------------------------------------+|                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n|                                                            ||                                                            |\\n+------------------------------------------------------------+']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    result = []\n    base_width = 2 * n - 1\n    roof_width = base_width + 2 * (n - 1)\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (base_width + 2 * i)\n        result.append(spaces + stars + spaces)\n    for i in range(n):\n        spaces = ' ' * (n - 1)\n        stars = '*' * base_width\n        result.append(spaces + stars + spaces)\n    return '\\n'.join(result)"], "requirement": [], "outputs": "[['*\\n*'], [' *** \\n*****\\n *** \\n *** '], ['  *****  \\n ******* \\n*********\\n  *****  \\n  *****  \\n  *****  '], ['   *******   \\n  *********  \\n *********** \\n*************\\n   *******   \\n   *******   \\n   *******   \\n   *******   '], ['    *********    \\n   ***********   \\n  *************  \\n *************** \\n*****************\\n    *********    \\n    *********    \\n    *********    \\n    *********    \\n    *********    '], ['         *******************         \\n        *********************        \\n       ***********************       \\n      *************************      \\n     ***************************     \\n    *****************************    \\n   *******************************   \\n  *********************************  \\n *********************************** \\n*************************************\\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         \\n         *******************         '], ['                   ***************************************                   \\n                  *****************************************                  \\n                 *******************************************                 \\n                *********************************************                \\n               ***********************************************               \\n              *************************************************              \\n             ***************************************************             \\n            *****************************************************            \\n           *******************************************************           \\n          *********************************************************          \\n         ***********************************************************         \\n        *************************************************************        \\n       ***************************************************************       \\n      *****************************************************************      \\n     *******************************************************************     \\n    *********************************************************************    \\n   ***********************************************************************   \\n  *************************************************************************  \\n *************************************************************************** \\n*****************************************************************************\\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   \\n                   ***************************************                   '], ['                             ***********************************************************                             \\n                            *************************************************************                            \\n                           ***************************************************************                           \\n                          *****************************************************************                          \\n                         *******************************************************************                         \\n                        *********************************************************************                        \\n                       ***********************************************************************                       \\n                      *************************************************************************                      \\n                     ***************************************************************************                     \\n                    *****************************************************************************                    \\n                   *******************************************************************************                   \\n                  *********************************************************************************                  \\n                 ***********************************************************************************                 \\n                *************************************************************************************                \\n               ***************************************************************************************               \\n              *****************************************************************************************              \\n             *******************************************************************************************             \\n            *********************************************************************************************            \\n           ***********************************************************************************************           \\n          *************************************************************************************************          \\n         ***************************************************************************************************         \\n        *****************************************************************************************************        \\n       *******************************************************************************************************       \\n      *********************************************************************************************************      \\n     ***********************************************************************************************************     \\n    *************************************************************************************************************    \\n   ***************************************************************************************************************   \\n  *****************************************************************************************************************  \\n ******************************************************************************************************************* \\n*********************************************************************************************************************\\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             \\n                             ***********************************************************                             '], [''], [''], ['                              *************************************************************                              \\n                             ***************************************************************                             \\n                            *****************************************************************                            \\n                           *******************************************************************                           \\n                          *********************************************************************                          \\n                         ***********************************************************************                         \\n                        *************************************************************************                        \\n                       ***************************************************************************                       \\n                      *****************************************************************************                      \\n                     *******************************************************************************                     \\n                    *********************************************************************************                    \\n                   ***********************************************************************************                   \\n                  *************************************************************************************                  \\n                 ***************************************************************************************                 \\n                *****************************************************************************************                \\n               *******************************************************************************************               \\n              *********************************************************************************************              \\n             ***********************************************************************************************             \\n            *************************************************************************************************            \\n           ***************************************************************************************************           \\n          *****************************************************************************************************          \\n         *******************************************************************************************************         \\n        *********************************************************************************************************        \\n       ***********************************************************************************************************       \\n      *************************************************************************************************************      \\n     ***************************************************************************************************************     \\n    *****************************************************************************************************************    \\n   *******************************************************************************************************************   \\n  *********************************************************************************************************************  \\n *********************************************************************************************************************** \\n*************************************************************************************************************************\\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              \\n                              *************************************************************                              ']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    from math import ceil\n    base_width = n * 2 - 1\n    roof_height = ceil(n / 2)\n    roof = []\n    for i in range(roof_height):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        roof.append(spaces + stars + spaces)\n    base = []\n    for _ in range(n):\n        base.append('*' * base_width)\n    crib_parts = roof + base\n    return '\\n'.join(crib_parts)"], "requirement": [], "outputs": "[['*\\n*'], [' * \\n***\\n***'], ['  *  \\n *** \\n*****\\n*****\\n*****'], ['   *   \\n  ***  \\n*******\\n*******\\n*******\\n*******'], ['    *    \\n   ***   \\n  *****  \\n*********\\n*********\\n*********\\n*********\\n*********'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    house = []\n    for i in range(n):\n        bars = '|' * n\n        spaces = ' ' * (2 * n - 1)\n        house.append(f'{bars}{spaces}{bars}')\n    floor = []\n    floor_line = '+' + '-' * (2 * n - 1) + '+'\n    for _ in range(n):\n        floor.append(floor_line)\n    crib = '\\n'.join(roof + house + floor)\n    return crib"], "requirement": [], "outputs": "[['*\\n| |\\n+-+'], [' * \\n***\\n||   ||\\n||   ||\\n+---+\\n+---+'], ['  *  \\n *** \\n*****\\n|||     |||\\n|||     |||\\n|||     |||\\n+-----+\\n+-----+\\n+-----+'], ['   *   \\n  ***  \\n ***** \\n*******\\n||||       ||||\\n||||       ||||\\n||||       ||||\\n||||       ||||\\n+-------+\\n+-------+\\n+-------+\\n+-------+'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n|||||         |||||\\n|||||         |||||\\n|||||         |||||\\n|||||         |||||\\n|||||         |||||\\n+---------+\\n+---------+\\n+---------+\\n+---------+\\n+---------+'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n||||||||||                   ||||||||||\\n||||||||||                   ||||||||||\\n||||||||||                   ||||||||||\\n||||||||||                   ||||||||||\\n||||||||||                   ||||||||||\\n||||||||||                   ||||||||||\\n||||||||||                   ||||||||||\\n||||||||||                   ||||||||||\\n||||||||||                   ||||||||||\\n||||||||||                   ||||||||||\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+\\n+-------------------+'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n||||||||||||||||||||                                       ||||||||||||||||||||\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+\\n+---------------------------------------+'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n||||||||||||||||||||||||||||||                                                           ||||||||||||||||||||||||||||||\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+\\n+-----------------------------------------------------------+'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n|||||||||||||||||||||||||||||||                                                             |||||||||||||||||||||||||||||||\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+\\n+-------------------------------------------------------------+']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    width = n * 2 - 1\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    base = []\n    for _ in range(n):\n        line = '|' + '*' * (width - 2) + '|'\n        base.append(line)\n    crib = '\\n'.join(roof + base)\n    return crib"], "requirement": [], "outputs": "[['*\\n||'], [' * \\n***\\n|*|\\n|*|'], ['  *  \\n *** \\n*****\\n|***|\\n|***|\\n|***|'], ['   *   \\n  ***  \\n ***** \\n*******\\n|*****|\\n|*****|\\n|*****|\\n|*****|'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n|*******|\\n|*******|\\n|*******|\\n|*******|\\n|*******|'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n|*****************|\\n|*****************|\\n|*****************|\\n|*****************|\\n|*****************|\\n|*****************|\\n|*****************|\\n|*****************|\\n|*****************|\\n|*****************|'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|\\n|*************************************|'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|\\n|*********************************************************|'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|\\n|***********************************************************|']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    from math import ceil\n    base_width = n * 2 - 1\n    roof_height = ceil(n / 2)\n    floor_height = n\n    roof = []\n    for i in range(roof_height):\n        spaces = ' ' * (roof_height - i - 1)\n        stars = '*' * (i * 2 + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    floors = []\n    for i in range(floor_height):\n        pillars = '|' + ' ' * (base_width - 2) + '|'\n        floors.append(pillars)\n    crib = roof + floors\n    base_line = '+' + '-' * (base_width - 2) + '+'\n    crib.append(base_line)\n    return '\\n'.join(crib)"], "requirement": [], "outputs": "[['*\\n||\\n++'], ['*\\n| |\\n| |\\n+-+'], [' * \\n***\\n|   |\\n|   |\\n|   |\\n+---+'], [' * \\n***\\n|     |\\n|     |\\n|     |\\n|     |\\n+-----+'], ['  *  \\n *** \\n*****\\n|       |\\n|       |\\n|       |\\n|       |\\n|       |\\n+-------+'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n|                 |\\n+-----------------+'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n|                                     |\\n+-------------------------------------+'], ['              *              \\n             ***             \\n            *****            \\n           *******           \\n          *********          \\n         ***********         \\n        *************        \\n       ***************       \\n      *****************      \\n     *******************     \\n    *********************    \\n   ***********************   \\n  *************************  \\n *************************** \\n*****************************\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n|                                                         |\\n+---------------------------------------------------------+'], ['++'], ['++'], ['               *               \\n              ***              \\n             *****             \\n            *******            \\n           *********           \\n          ***********          \\n         *************         \\n        ***************        \\n       *****************       \\n      *******************      \\n     *********************     \\n    ***********************    \\n   *************************   \\n  ***************************  \\n ***************************** \\n*******************************\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n+-----------------------------------------------------------+']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    from math import ceil\n    base_width = n * 2 - 1\n    crib = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        crib.append(spaces + stars + spaces)\n    floor_line = '+' + '-' * base_width + '+'\n    for _ in range(n):\n        crib.append(floor_line)\n        interior_spaces = '|' + ' ' * base_width + '|'\n        crib.append(interior_spaces)\n    crib.append(floor_line)\n    return '\\n'.join(crib)"], "requirement": [], "outputs": "[['*\\n+-+\\n| |\\n+-+'], [' * \\n***\\n+---+\\n|   |\\n+---+\\n|   |\\n+---+'], ['  *  \\n *** \\n*****\\n+-----+\\n|     |\\n+-----+\\n|     |\\n+-----+\\n|     |\\n+-----+'], ['   *   \\n  ***  \\n ***** \\n*******\\n+-------+\\n|       |\\n+-------+\\n|       |\\n+-------+\\n|       |\\n+-------+\\n|       |\\n+-------+'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n+---------+\\n|         |\\n+---------+\\n|         |\\n+---------+\\n|         |\\n+---------+\\n|         |\\n+---------+\\n|         |\\n+---------+'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n+-------------------+\\n|                   |\\n+-------------------+\\n|                   |\\n+-------------------+\\n|                   |\\n+-------------------+\\n|                   |\\n+-------------------+\\n|                   |\\n+-------------------+\\n|                   |\\n+-------------------+\\n|                   |\\n+-------------------+\\n|                   |\\n+-------------------+\\n|                   |\\n+-------------------+\\n|                   |\\n+-------------------+'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+\\n|                                       |\\n+---------------------------------------+'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+\\n|                                                           |\\n+-----------------------------------------------------------+'], ['++'], ['++'], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+\\n|                                                             |\\n+-------------------------------------------------------------+']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    crib_lines = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        crib_lines.append(spaces + stars + spaces)\n    base_line = '+' + '-' * base_width + '+'\n    crib_lines.append(base_line)\n    for _ in range(n):\n        spaces = '|' + ' ' * base_width + '|'\n        crib_lines.append(spaces)\n    crib_lines.append(base_line)\n    return '\\n'.join(crib_lines)", "def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    crib_lines = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        crib_lines.append(spaces + stars + spaces)\n    base_line = '+' + '-' * base_width + '+'\n    crib_lines.append(base_line)\n    for _ in range(n):\n        spaces = '|' + ' ' * base_width + '|'\n        crib_lines.append(spaces)\n    crib_lines.append(base_line)\n    return '\\n'.join(crib_lines)"], "requirement": [], "outputs": "[['*\\n+-+\\n| |\\n+-+'], [' * \\n***\\n+---+\\n|   |\\n|   |\\n+---+'], ['  *  \\n *** \\n*****\\n+-----+\\n|     |\\n|     |\\n|     |\\n+-----+'], ['   *   \\n  ***  \\n ***** \\n*******\\n+-------+\\n|       |\\n|       |\\n|       |\\n|       |\\n+-------+'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n+---------+\\n|         |\\n|         |\\n|         |\\n|         |\\n|         |\\n+---------+'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n+-------------------+\\n|                   |\\n|                   |\\n|                   |\\n|                   |\\n|                   |\\n|                   |\\n|                   |\\n|                   |\\n|                   |\\n|                   |\\n+-------------------+'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n+---------------------------------------+\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n|                                       |\\n+---------------------------------------+'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n+-----------------------------------------------------------+\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n|                                                           |\\n+-----------------------------------------------------------+'], ['++\\n++'], ['++\\n++'], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n+-------------------------------------------------------------+\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n|                                                             |\\n+-------------------------------------------------------------+']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n\n    def generate_roof(floors):\n        roof = []\n        max_width = 2 * floors - 1\n        for i in range(floors):\n            spaces = ' ' * (floors - i - 1)\n            stars = '*' * (2 * i + 1)\n            roof.append(spaces + stars + spaces)\n        return '\\n'.join(roof)\n\n    def generate_floors(floors):\n        floor_line = '*' + ' ' * (2 * floors - 2) + '*'\n        return '\\n'.join([floor_line] * floors)\n    roof_part = generate_roof(n)\n    floor_part = generate_floors(n)\n    mansion = f'{roof_part}\\n{floor_part}'\n    return mansion"], "requirement": [], "outputs": "[['*\\n**'], [' * \\n***\\n*  *\\n*  *'], ['  *  \\n *** \\n*****\\n*    *\\n*    *\\n*    *'], ['   *   \\n  ***  \\n ***** \\n*******\\n*      *\\n*      *\\n*      *\\n*      *'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n*        *\\n*        *\\n*        *\\n*        *\\n*        *'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *\\n*                  *'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *\\n*                                      *'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *\\n*                                                          *'], ['\\n'], ['\\n'], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *\\n*                                                            *']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    from math import floor\n    width = n * 2 - 1\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        roof.append(spaces + stars + spaces)\n    floors = []\n    for i in range(n):\n        spaces = ' ' * floor((width - (n + 2)) / 2)\n        bars = '|' + ' ' * (width - 2) + '|'\n        floors.append(spaces + bars + spaces)\n    crib = '\\n'.join(roof + floors)\n    return crib"], "requirement": [], "outputs": "[['*\\n||'], [' * \\n***\\n| |\\n| |'], ['  *  \\n *** \\n*****\\n|   |\\n|   |\\n|   |'], ['   *   \\n  ***  \\n ***** \\n*******\\n|     |\\n|     |\\n|     |\\n|     |'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n |       | \\n |       | \\n |       | \\n |       | \\n |       | '], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n   |                 |   \\n   |                 |   \\n   |                 |   \\n   |                 |   \\n   |                 |   \\n   |                 |   \\n   |                 |   \\n   |                 |   \\n   |                 |   \\n   |                 |   '], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        \\n        |                                     |        '], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             \\n             |                                                         |             '], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              \\n              |                                                           |              ']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n\n    def create_roof():\n        width = 2 * n + (n - 1) * 2\n        roof = []\n        for i in range(n):\n            spaces = ' ' * ((width - (2 * i + 1)) // 2)\n            stars = '*' * (2 * i + 1)\n            roof.append(spaces + stars + spaces)\n        return '\\n'.join(roof)\n\n    def create_floors():\n        floor_width = 2 * n + (n - 1) * 2\n        floors = []\n        for _ in range(n):\n            floor = '|' + '-' * (floor_width - 2) + '|'\n            floors.append(floor)\n        return '\\n'.join(floors)\n    crib = create_roof() + '\\n' + create_floors()\n    return crib"], "requirement": [], "outputs": "[['*\\n||'], ['  *  \\n *** \\n|----|\\n|----|'], ['    *    \\n   ***   \\n  *****  \\n|--------|\\n|--------|\\n|--------|'], ['      *      \\n     ***     \\n    *****    \\n   *******   \\n|------------|\\n|------------|\\n|------------|\\n|------------|'], ['        *        \\n       ***       \\n      *****      \\n     *******     \\n    *********    \\n|----------------|\\n|----------------|\\n|----------------|\\n|----------------|\\n|----------------|'], ['                  *                  \\n                 ***                 \\n                *****                \\n               *******               \\n              *********              \\n             ***********             \\n            *************            \\n           ***************           \\n          *****************          \\n         *******************         \\n|------------------------------------|\\n|------------------------------------|\\n|------------------------------------|\\n|------------------------------------|\\n|------------------------------------|\\n|------------------------------------|\\n|------------------------------------|\\n|------------------------------------|\\n|------------------------------------|\\n|------------------------------------|'], ['                                      *                                      \\n                                     ***                                     \\n                                    *****                                    \\n                                   *******                                   \\n                                  *********                                  \\n                                 ***********                                 \\n                                *************                                \\n                               ***************                               \\n                              *****************                              \\n                             *******************                             \\n                            *********************                            \\n                           ***********************                           \\n                          *************************                          \\n                         ***************************                         \\n                        *****************************                        \\n                       *******************************                       \\n                      *********************************                      \\n                     ***********************************                     \\n                    *************************************                    \\n                   ***************************************                   \\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|\\n|----------------------------------------------------------------------------|'], ['                                                          *                                                          \\n                                                         ***                                                         \\n                                                        *****                                                        \\n                                                       *******                                                       \\n                                                      *********                                                      \\n                                                     ***********                                                     \\n                                                    *************                                                    \\n                                                   ***************                                                   \\n                                                  *****************                                                  \\n                                                 *******************                                                 \\n                                                *********************                                                \\n                                               ***********************                                               \\n                                              *************************                                              \\n                                             ***************************                                             \\n                                            *****************************                                            \\n                                           *******************************                                           \\n                                          *********************************                                          \\n                                         ***********************************                                         \\n                                        *************************************                                        \\n                                       ***************************************                                       \\n                                      *****************************************                                      \\n                                     *******************************************                                     \\n                                    *********************************************                                    \\n                                   ***********************************************                                   \\n                                  *************************************************                                  \\n                                 ***************************************************                                 \\n                                *****************************************************                                \\n                               *******************************************************                               \\n                              *********************************************************                              \\n                             ***********************************************************                             \\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|\\n|--------------------------------------------------------------------------------------------------------------------|'], ['\\n'], ['\\n'], ['                                                            *                                                            \\n                                                           ***                                                           \\n                                                          *****                                                          \\n                                                         *******                                                         \\n                                                        *********                                                        \\n                                                       ***********                                                       \\n                                                      *************                                                      \\n                                                     ***************                                                     \\n                                                    *****************                                                    \\n                                                   *******************                                                   \\n                                                  *********************                                                  \\n                                                 ***********************                                                 \\n                                                *************************                                                \\n                                               ***************************                                               \\n                                              *****************************                                              \\n                                             *******************************                                             \\n                                            *********************************                                            \\n                                           ***********************************                                           \\n                                          *************************************                                          \\n                                         ***************************************                                         \\n                                        *****************************************                                        \\n                                       *******************************************                                       \\n                                      *********************************************                                      \\n                                     ***********************************************                                     \\n                                    *************************************************                                    \\n                                   ***************************************************                                   \\n                                  *****************************************************                                  \\n                                 *******************************************************                                 \\n                                *********************************************************                                \\n                               ***********************************************************                               \\n                              *************************************************************                              \\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|\\n|------------------------------------------------------------------------------------------------------------------------|']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    crib = [f'{' ' * (n - i - 1)}{('* ' * (i + 1)).strip()}{' ' * (n - i - 1)}' for i in range(n)]\n    for i in range(n):\n        line = '*' * base_width\n        crib.append(f'{' ' * (n - math.ceil(base_width / 2))}{line}{' ' * (n - math.ceil(base_width / 2))}')\n    return '\\n'.join(crib)"], "requirement": [], "outputs": "[['*\\n*'], [' * \\n* *\\n***\\n***'], ['  *  \\n * * \\n* * *\\n*****\\n*****\\n*****'], ['   *   \\n  * *  \\n * * * \\n* * * *\\n*******\\n*******\\n*******\\n*******'], ['    *    \\n   * *   \\n  * * *  \\n * * * * \\n* * * * *\\n*********\\n*********\\n*********\\n*********\\n*********'], ['         *         \\n        * *        \\n       * * *       \\n      * * * *      \\n     * * * * *     \\n    * * * * * *    \\n   * * * * * * *   \\n  * * * * * * * *  \\n * * * * * * * * * \\n* * * * * * * * * *\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************'], ['                   *                   \\n                  * *                  \\n                 * * *                 \\n                * * * *                \\n               * * * * *               \\n              * * * * * *              \\n             * * * * * * *             \\n            * * * * * * * *            \\n           * * * * * * * * *           \\n          * * * * * * * * * *          \\n         * * * * * * * * * * *         \\n        * * * * * * * * * * * *        \\n       * * * * * * * * * * * * *       \\n      * * * * * * * * * * * * * *      \\n     * * * * * * * * * * * * * * *     \\n    * * * * * * * * * * * * * * * *    \\n   * * * * * * * * * * * * * * * * *   \\n  * * * * * * * * * * * * * * * * * *  \\n * * * * * * * * * * * * * * * * * * * \\n* * * * * * * * * * * * * * * * * * * *\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************'], ['                             *                             \\n                            * *                            \\n                           * * *                           \\n                          * * * *                          \\n                         * * * * *                         \\n                        * * * * * *                        \\n                       * * * * * * *                       \\n                      * * * * * * * *                      \\n                     * * * * * * * * *                     \\n                    * * * * * * * * * *                    \\n                   * * * * * * * * * * *                   \\n                  * * * * * * * * * * * *                  \\n                 * * * * * * * * * * * * *                 \\n                * * * * * * * * * * * * * *                \\n               * * * * * * * * * * * * * * *               \\n              * * * * * * * * * * * * * * * *              \\n             * * * * * * * * * * * * * * * * *             \\n            * * * * * * * * * * * * * * * * * *            \\n           * * * * * * * * * * * * * * * * * * *           \\n          * * * * * * * * * * * * * * * * * * * *          \\n         * * * * * * * * * * * * * * * * * * * * *         \\n        * * * * * * * * * * * * * * * * * * * * * *        \\n       * * * * * * * * * * * * * * * * * * * * * * *       \\n      * * * * * * * * * * * * * * * * * * * * * * * *      \\n     * * * * * * * * * * * * * * * * * * * * * * * * *     \\n    * * * * * * * * * * * * * * * * * * * * * * * * * *    \\n   * * * * * * * * * * * * * * * * * * * * * * * * * * *   \\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * *  \\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************'], [''], [''], ['                              *                              \\n                             * *                             \\n                            * * *                            \\n                           * * * *                           \\n                          * * * * *                          \\n                         * * * * * *                         \\n                        * * * * * * *                        \\n                       * * * * * * * *                       \\n                      * * * * * * * * *                      \\n                     * * * * * * * * * *                     \\n                    * * * * * * * * * * *                    \\n                   * * * * * * * * * * * *                   \\n                  * * * * * * * * * * * * *                  \\n                 * * * * * * * * * * * * * *                 \\n                * * * * * * * * * * * * * * *                \\n               * * * * * * * * * * * * * * * *               \\n              * * * * * * * * * * * * * * * * *              \\n             * * * * * * * * * * * * * * * * * *             \\n            * * * * * * * * * * * * * * * * * * *            \\n           * * * * * * * * * * * * * * * * * * * *           \\n          * * * * * * * * * * * * * * * * * * * * *          \\n         * * * * * * * * * * * * * * * * * * * * * *         \\n        * * * * * * * * * * * * * * * * * * * * * * *        \\n       * * * * * * * * * * * * * * * * * * * * * * * *       \\n      * * * * * * * * * * * * * * * * * * * * * * * * *      \\n     * * * * * * * * * * * * * * * * * * * * * * * * * *     \\n    * * * * * * * * * * * * * * * * * * * * * * * * * * *    \\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * *   \\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  \\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    base_width = n * 2 - 1\n    lines = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (i * 2 + 1)\n        lines.append(spaces + stars + spaces)\n    for i in range(n):\n        line = '|' + '=' * (base_width - 2) + '|'\n        lines.append(line)\n    return '\\n'.join(lines)"], "requirement": [], "outputs": "[['*\\n||'], [' * \\n***\\n|=|\\n|=|'], ['  *  \\n *** \\n*****\\n|===|\\n|===|\\n|===|'], ['   *   \\n  ***  \\n ***** \\n*******\\n|=====|\\n|=====|\\n|=====|\\n|=====|'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n|=======|\\n|=======|\\n|=======|\\n|=======|\\n|=======|'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n|=================|\\n|=================|\\n|=================|\\n|=================|\\n|=================|\\n|=================|\\n|=================|\\n|=================|\\n|=================|\\n|=================|'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|\\n|=====================================|'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|\\n|=========================================================|'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|\\n|===========================================================|']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n\n    def create_line(content, width, pad_char=' '):\n        return f'{pad_char * ((width - len(content)) // 2)}{content}{pad_char * ((width - len(content)) // 2)}'\n    width = n * 2 + 2\n    result = []\n    for i in range(n):\n        spaces = ' ' * (n - i - 1)\n        stars = '*' * (2 * i + 1)\n        result.append(create_line(spaces + stars, width, pad_char=' '))\n    for _ in range(n):\n        result.append(create_line('||', width, pad_char='*'))\n    return '\\n'.join(result)"], "requirement": [], "outputs": "[[' * \\n*||*'], ['   *  \\n *** \\n**||**\\n**||**'], ['    *  \\n   ***  \\n ***** \\n***||***\\n***||***\\n***||***'], ['      *   \\n    ***  \\n   *****  \\n ******* \\n****||****\\n****||****\\n****||****\\n****||****'], ['       *   \\n      ***   \\n    *****  \\n   *******  \\n ********* \\n*****||*****\\n*****||*****\\n*****||*****\\n*****||*****\\n*****||*****'], ['               *      \\n             ***     \\n            *****     \\n          *******    \\n         *********    \\n       ***********   \\n      *************   \\n    ***************  \\n   *****************  \\n ******************* \\n**********||**********\\n**********||**********\\n**********||**********\\n**********||**********\\n**********||**********\\n**********||**********\\n**********||**********\\n**********||**********\\n**********||**********\\n**********||**********'], ['                              *           \\n                            ***          \\n                           *****          \\n                         *******         \\n                        *********         \\n                      ***********        \\n                     *************        \\n                   ***************       \\n                  *****************       \\n                *******************      \\n               *********************      \\n             ***********************     \\n            *************************     \\n          ***************************    \\n         *****************************    \\n       *******************************   \\n      *********************************   \\n    ***********************************  \\n   *************************************  \\n *************************************** \\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************\\n********************||********************'], ['                                             *                \\n                                           ***               \\n                                          *****               \\n                                        *******              \\n                                       *********              \\n                                     ***********             \\n                                    *************             \\n                                  ***************            \\n                                 *****************            \\n                               *******************           \\n                              *********************           \\n                            ***********************          \\n                           *************************          \\n                         ***************************         \\n                        *****************************         \\n                      *******************************        \\n                     *********************************        \\n                   ***********************************       \\n                  *************************************       \\n                ***************************************      \\n               *****************************************      \\n             *******************************************     \\n            *********************************************     \\n          ***********************************************    \\n         *************************************************    \\n       ***************************************************   \\n      *****************************************************   \\n    *******************************************************  \\n   *********************************************************  \\n *********************************************************** \\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************\\n******************************||******************************'], [''], [''], ['                                              *                \\n                                             ***                \\n                                           *****               \\n                                          *******               \\n                                        *********              \\n                                       ***********              \\n                                     *************             \\n                                    ***************             \\n                                  *****************            \\n                                 *******************            \\n                               *********************           \\n                              ***********************           \\n                            *************************          \\n                           ***************************          \\n                         *****************************         \\n                        *******************************         \\n                      *********************************        \\n                     ***********************************        \\n                   *************************************       \\n                  ***************************************       \\n                *****************************************      \\n               *******************************************      \\n             *********************************************     \\n            ***********************************************     \\n          *************************************************    \\n         ***************************************************    \\n       *****************************************************   \\n      *******************************************************   \\n    *********************************************************  \\n   ***********************************************************  \\n ************************************************************* \\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************\\n*******************************||*******************************']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    base_width = 2 * n - 1\n    roof_width_increment = 2\n    roof = []\n    for i in range(n):\n        spaces = ' ' * (n - 1 - i)\n        stars = '*' * (roof_width_increment * i + 1)\n        roof.append(f'{spaces}{stars}{spaces}')\n    body = []\n    for i in range(n):\n        spaces = ' ' * (n - 1)\n        stars = '|' + ' ' * (base_width - 2) + '|'\n        body.append(f'{spaces}{stars}{spaces}')\n    base = ['*' * base_width] * n\n    crib_parts = roof + body + base\n    return '\\n'.join(crib_parts)"], "requirement": [], "outputs": "[['*\\n||\\n*'], [' * \\n***\\n | | \\n | | \\n***\\n***'], ['  *  \\n *** \\n*****\\n  |   |  \\n  |   |  \\n  |   |  \\n*****\\n*****\\n*****'], ['   *   \\n  ***  \\n ***** \\n*******\\n   |     |   \\n   |     |   \\n   |     |   \\n   |     |   \\n*******\\n*******\\n*******\\n*******'], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n    |       |    \\n    |       |    \\n    |       |    \\n    |       |    \\n    |       |    \\n*********\\n*********\\n*********\\n*********\\n*********'], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n    ***********    \\n   *************   \\n  ***************  \\n ***************** \\n*******************\\n         |                 |         \\n         |                 |         \\n         |                 |         \\n         |                 |         \\n         |                 |         \\n         |                 |         \\n         |                 |         \\n         |                 |         \\n         |                 |         \\n         |                 |         \\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************\\n*******************'], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n         *********************         \\n        ***********************        \\n       *************************       \\n      ***************************      \\n     *****************************     \\n    *******************************    \\n   *********************************   \\n  ***********************************  \\n ************************************* \\n***************************************\\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n                   |                                     |                   \\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************\\n***************************************'], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n              *******************************              \\n             *********************************             \\n            ***********************************            \\n           *************************************           \\n          ***************************************          \\n         *****************************************         \\n        *******************************************        \\n       *********************************************       \\n      ***********************************************      \\n     *************************************************     \\n    ***************************************************    \\n   *****************************************************   \\n  *******************************************************  \\n ********************************************************* \\n***********************************************************\\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n                             |                                                         |                             \\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************\\n***********************************************************'], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n                              |                                                           |                              \\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************\\n*************************************************************']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    roof_width = base_width + 2\n    roof = []\n    for i in range(1, roof_width + 1, 2):\n        spaces = ' ' * ((roof_width - i) // 2)\n        stars = '*' * i\n        roof.append(spaces + stars + spaces)\n    base = []\n    for _ in range(n):\n        side_spaces = ' ' * (math.ceil(n / 2) - 1)\n        middle_stars = '*' * base_width\n        base.append(side_spaces + middle_stars + side_spaces)\n    crib = '\\n'.join(roof + base)\n    return crib"], "requirement": [], "outputs": "[[' * \\n***\\n*'], ['  *  \\n *** \\n*****\\n***\\n***'], ['   *   \\n  ***  \\n ***** \\n*******\\n ***** \\n ***** \\n ***** '], ['    *    \\n   ***   \\n  *****  \\n ******* \\n*********\\n ******* \\n ******* \\n ******* \\n ******* '], ['     *     \\n    ***    \\n   *****   \\n  *******  \\n ********* \\n***********\\n  *********  \\n  *********  \\n  *********  \\n  *********  \\n  *********  '], ['          *          \\n         ***         \\n        *****        \\n       *******       \\n      *********      \\n     ***********     \\n    *************    \\n   ***************   \\n  *****************  \\n ******************* \\n*********************\\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    \\n    *******************    '], ['                    *                    \\n                   ***                   \\n                  *****                  \\n                 *******                 \\n                *********                \\n               ***********               \\n              *************              \\n             ***************             \\n            *****************            \\n           *******************           \\n          *********************          \\n         ***********************         \\n        *************************        \\n       ***************************       \\n      *****************************      \\n     *******************************     \\n    *********************************    \\n   ***********************************   \\n  *************************************  \\n *************************************** \\n*****************************************\\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         \\n         ***************************************         '], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n              *********************************              \\n             ***********************************             \\n            *************************************            \\n           ***************************************           \\n          *****************************************          \\n         *******************************************         \\n        *********************************************        \\n       ***********************************************       \\n      *************************************************      \\n     ***************************************************     \\n    *****************************************************    \\n   *******************************************************   \\n  *********************************************************  \\n *********************************************************** \\n*************************************************************\\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              \\n              ***********************************************************              '], ['*'], [''], ['                               *                               \\n                              ***                              \\n                             *****                             \\n                            *******                            \\n                           *********                           \\n                          ***********                          \\n                         *************                         \\n                        ***************                        \\n                       *****************                       \\n                      *******************                      \\n                     *********************                     \\n                    ***********************                    \\n                   *************************                   \\n                  ***************************                  \\n                 *****************************                 \\n                *******************************                \\n               *********************************               \\n              ***********************************              \\n             *************************************             \\n            ***************************************            \\n           *****************************************           \\n          *******************************************          \\n         *********************************************         \\n        ***********************************************        \\n       *************************************************       \\n      ***************************************************      \\n     *****************************************************     \\n    *******************************************************    \\n   *********************************************************   \\n  ***********************************************************  \\n ************************************************************* \\n***************************************************************\\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               \\n               *************************************************************               ']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def my_crib(n: int) -> str:\n    import math\n    base_width = n * 2 - 1\n    roof_top = math.ceil(n / 2)\n    roof = []\n    for i in range(roof_top):\n        spaces = ' ' * (n - 1 - i)\n        stars = '*' * (i * 2 + 1)\n        roof.append(spaces + stars + spaces)\n    base = []\n    for i in range(n):\n        spaces = ' ' * ((base_width - (n + 2)) // 2)\n        if i == 0:\n            base.append(' ' * (n - 1) + '|' + '*' * (n - 2) + '|')\n        else:\n            base.append(spaces + '|' + '=' * (n + 2) + '|' + spaces)\n    crib = '\\n'.join(roof + base)\n    return crib"], "requirement": [], "outputs": "[['*\\n||'], [' * \\n ||\\n|====|'], ['  *  \\n *** \\n  |*|\\n|=====|\\n|=====|'], ['   *   \\n  ***  \\n   |**|\\n|======|\\n|======|\\n|======|'], ['    *    \\n   ***   \\n  *****  \\n    |***|\\n |=======| \\n |=======| \\n |=======| \\n |=======| '], ['         *         \\n        ***        \\n       *****       \\n      *******      \\n     *********     \\n         |********|\\n   |============|   \\n   |============|   \\n   |============|   \\n   |============|   \\n   |============|   \\n   |============|   \\n   |============|   \\n   |============|   \\n   |============|   '], ['                   *                   \\n                  ***                  \\n                 *****                 \\n                *******                \\n               *********               \\n              ***********              \\n             *************             \\n            ***************            \\n           *****************           \\n          *******************          \\n                   |******************|\\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        \\n        |======================|        '], ['                             *                             \\n                            ***                            \\n                           *****                           \\n                          *******                          \\n                         *********                         \\n                        ***********                        \\n                       *************                       \\n                      ***************                      \\n                     *****************                     \\n                    *******************                    \\n                   *********************                   \\n                  ***********************                  \\n                 *************************                 \\n                ***************************                \\n               *****************************               \\n                             |****************************|\\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             \\n             |================================|             '], [''], [''], ['                              *                              \\n                             ***                             \\n                            *****                            \\n                           *******                           \\n                          *********                          \\n                         ***********                         \\n                        *************                        \\n                       ***************                       \\n                      *****************                      \\n                     *******************                     \\n                    *********************                    \\n                   ***********************                   \\n                  *************************                  \\n                 ***************************                 \\n                *****************************                \\n               *******************************               \\n                              |*****************************|\\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              \\n              |=================================|              ']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 3.29084342087002, "llm_generated_inputs": "[[1], [2], [3], [4], [5], [10], [20], [30], [0], [-5], [31]]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "my_crib", "ground_truth": -1}
{"task_id": "TACO_lite/28", "requirement": "def get_middle(s: str) -> str:\n\"\"\"You are going to be given a word. Your job is to return the middle character of the word. If the word's length is odd, return the middle character. If the word's length is even, return the middle 2 characters.\n\n#Input\n\nA word (string) of length `0 < str < 1000` (In javascript you may get slightly more than 1000 in some test cases due to an error in the test cases). You do not need to test for this. This is only here to tell you that you do not need to worry about your solution timing out.\n\n\n#Output\n\nThe middle character(s) of the word represented as a string.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    mid = length // 2\n    if length % 2 == 0:\n        return s[mid - 1:mid + 1]\n    else:\n        return s[mid]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    mid = length // 2\n    if length % 2 == 0:\n        return s[mid - 1:mid + 1]\n    else:\n        return s[mid]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    mid = length // 2\n    if length % 2 == 0:\n        return s[mid - 1:mid + 1]\n    else:\n        return s[mid]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle_index = length // 2\n    if length % 2 == 0:\n        return s[middle_index - 1:middle_index + 1]\n    else:\n        return s[middle_index]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    if length % 2 == 0:\n        mid_index = length // 2\n        return s[mid_index - 1:mid_index + 1]\n    else:\n        mid_index = length // 2\n        return s[mid_index]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    if length % 2 == 0:\n        mid = length // 2\n        return s[mid - 1:mid + 1]\n    else:\n        mid = length // 2\n        return s[mid]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]", "def get_middle(s: str) -> str:\n    length = len(s)\n    if length % 2 == 1:\n        middle_index = length // 2\n        return s[middle_index]\n    else:\n        middle_index_1 = length // 2 - 1\n        middle_index_2 = length // 2\n        return s[middle_index_1:middle_index_2 + 1]", "def get_middle(s: str) -> str:\n    length = len(s)\n    middle = length // 2\n    if length % 2 == 0:\n        return s[middle - 1:middle + 1]\n    else:\n        return s[middle]"], "requirement": [], "outputs": "[['es'], ['t'], ['dd'], ['A'], [''], ['ab'], ['b'], ['bc'], ['cd'], ['y'], ['xy'], ['e'], ['5'], ['56']]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[['test'], ['testing'], ['middle'], ['A'], [''], ['ab'], ['abc'], ['abcd'], ['abcdef'], ['xyz'], ['xy'], ['racecar'], ['123456789'], ['1234567890']]", "input_output_examples": "[[['test'], ['testing'], ['middle'], ['A']], [['es'], ['t'], ['dd'], ['A']]]", "at_least_one_align": false}, "entry_point": "get_middle", "ground_truth": 0}
{"task_id": "TACO_lite/29", "requirement": "def josephus_survivor(n: int, k: int) -> int:\n\"\"\"In this kata you have to correctly return who is the \"survivor\", ie: the last element of a Josephus permutation.\n\nBasically you have to assume that n people are put into a circle and that they are eliminated in steps of k elements.\n\nThe above link about the \"base\" kata description will give you a more thorough insight about the origin of this kind of permutation, but basically that's all that there is to know to solve this kata.\n\n**Notes and tips:** using the solution to the other kata to check your function may be helpful, but as much larger numbers will be used, using an array/list to compute the number of the survivor may be too slow; you may assume that both n and k will always be >=1.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    from functools import reduce\n\n    def josephus(n, k):\n        if n == 1:\n            return 0\n        else:\n            return (josephus(n - 1, k) + k) % n\n    survivor_position = josephus(n, k)\n    return survivor_position + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return (josephus_survivor(n - 1, k) + k - 1) % n + 1", "def josephus_survivor(n: int, k: int) -> int:\n    from typing import Tuple\n\n    def find_survivor(n: int, k: int) -> int:\n        if n == 1:\n            return 0\n        else:\n            return (find_survivor(n - 1, k) + k) % n\n    return find_survivor(n, k) + 1"], "requirement": [], "outputs": "[[4], [1], [17], [2], [4], [37], [100], [36], ['RecursionError'], [1], [4], [1], [2], [8], [95], ['RecursionError'], ['RecursionError'], ['RecursionError'], [1], [8]]", "probability": 0.78, "is_align_req": false, "DRS": null}, {"programs_str": ["def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    pos = 0\n    for i in range(2, n + 1):\n        pos = (pos + k) % i\n    return pos + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    elif k == 1:\n        return n\n    position = 0\n    for i in range(2, n + 1):\n        position = (position + k) % i\n    return position + 1", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    pos = 0\n    for i in range(2, n + 1):\n        pos = (pos + k) % i\n    return pos + 1"], "requirement": [], "outputs": "[[4], [1], [17], [2], [4], [37], [100], [36], [63], [1], [4], [1], [2], [8], [95], [9332], [1], [1], [1], [8]]", "probability": 0.06, "is_align_req": false, "DRS": null}, {"programs_str": ["def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 0\n    else:\n        return (josephus_survivor(n - 1, k) + k) % n", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 0\n    else:\n        return (josephus_survivor(n - 1, k) + k) % n", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 0\n    else:\n        return (josephus_survivor(n - 1, k) + k) % n", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 0\n    else:\n        return (josephus_survivor(n - 1, k) + k) % n", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 0\n    else:\n        previous_survivor = josephus_survivor(n - 1, k)\n        return (previous_survivor + k) % n", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 0\n    else:\n        return (josephus_survivor(n - 1, k) + k) % n\n\ndef find_survivor(n: int, k: int) -> int:\n    return josephus_survivor(n, k) + 1"], "requirement": [], "outputs": "[[3], [0], [16], [1], [3], [36], [99], [35], ['RecursionError'], [0], [3], [0], [1], [7], [94], ['RecursionError'], ['RecursionError'], ['RecursionError'], [0], [7]]", "probability": 0.12, "is_align_req": false, "DRS": null}, {"programs_str": ["from collections import deque\n\ndef josephus_survivor(n: int, k: int) -> int:\n    if n == 1 or k == 1:\n        return n\n    people = list(range(1, n + 1))\n    index = 0\n    while len(people) > 1:\n        index = (index + k - 1) % len(people)\n        people.pop(index)\n    return people[0]", "def josephus_survivor(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    if k == 1:\n        return n\n    remaining = list(range(1, n + 1))\n    index = 0\n    while len(remaining) > 1:\n        index = (index + k - 1) % len(remaining)\n        del remaining[index]\n    return remaining[0]"], "requirement": [], "outputs": "[[4], [1], [17], [2], [4], [37], [100], [36], [63], [1], [4], [1], [2], [8], [95], [9332], ['IndexError'], ['IndexError'], [1], [8]]", "probability": 0.04, "is_align_req": false, "DRS": null}], "entropy": 0.7457911605971708, "llm_generated_inputs": "[[7, 3], [1, 1], [40, 2], [5, 5], [10, 3], [98, 5], [100, 1], [50, 10], [1000, 10], [23, 7], [15, 15], [2, 2], [2, 1], [10, 10], [100, 50], [10000, 100], [0, 10], [-5, 10], [10, 0], [10, -5]]", "input_output_examples": "[[[7, 3]], [[4]]]", "at_least_one_align": false}, "entry_point": "josephus_survivor", "ground_truth": -1}
{"task_id": "TACO_lite/30", "requirement": "def kontti(s: str) -> str:\n\"\"\"Kontti language is a finnish word play game.\n\nYou add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\"); \n\nIf no vowel is present, the word stays the same.\n\nWrite a string method that turns a sentence into kontti language!\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        match = re.search('([bcdfghjklmnpqrstvwxyz]*)([aeiouy]?)(.*)', word, re.I)\n        if match:\n            consonants, first_vowel, rest = match.groups()\n            if first_vowel:\n                return f'{rest}{consonants}-kontti'\n        return f'{word}-kontti'\n    return ' '.join((transform_word(word) for word in s.split()))"], "requirement": [], "outputs": "[['lloh-kontti'], ['rldw-kontti'], ['pple-kontti'], ['range-kontti'], ['sky-kontti'], ['crypt-kontti'], ['rhythm-kontti'], ['EIOUY-kontti'], ['-kontti -kontti -kontti -kontti -kontti y-kontti'], ['lloh-kontti rldw-kontti'], ['llo,h-kontti rld!w-kontti'], ['sTh-kontti s-kontti -kontti st.t-kontti'], [''], [''], ['12345-kontti'], ['!@#$%-kontti'], ['nttiK-kontti nguagel-kontti s-kontti n.f-kontti'], ['Why-kontti dd-kontti th-kontti nttik-kontti ckench-kontti sscr-kontti th-kontti ad?r-kontti']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouy'\n        match = re.search('[aeiouy]', word, re.I)\n        if match:\n            index = match.start()\n            part1 = word[:index][::-1]\n            part2 = word[index:]\n            return part1 + part2 + 'kontti'\n        else:\n            return word\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)"], "requirement": [], "outputs": "[['hellokontti'], ['worldkontti'], ['applekontti'], ['orangekontti'], ['ksykontti'], ['rcyptkontti'], ['hrythmkontti'], ['AEIOUYkontti'], ['akontti ekontti ikontti okontti ukontti ykontti'], ['hellokontti worldkontti'], ['hello,kontti world!kontti'], ['hTiskontti iskontti akontti test.kontti'], [''], [''], ['12345'], ['!@#$%'], ['Konttikontti languagekontti iskontti fun.kontti'], ['hWykontti didkontti htekontti konttikontti hcickenkontti rcosskontti htekontti road?kontti']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouyAEIOUY'\n        match = re.search('[aeiouyAEIOUY]', word)\n        if match:\n            first_vowel_index = match.start()\n            prefix = word[:first_vowel_index + 1]\n            suffix = word[first_vowel_index + 1:]\n            return suffix + prefix + 'kontti'\n        else:\n            return word + 'kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)"], "requirement": [], "outputs": "[['llohekontti'], ['rldwokontti'], ['ppleakontti'], ['rangeokontti'], ['skykontti'], ['ptcrykontti'], ['thmrhykontti'], ['EIOUYAkontti'], ['akontti ekontti ikontti okontti ukontti ykontti'], ['llohekontti rldwokontti'], ['llo,hekontti rld!wokontti'], ['sThikontti sikontti akontti st.tekontti'], [''], [''], ['12345kontti'], ['!@#$%kontti'], ['nttiKokontti nguagelakontti sikontti n.fukontti'], ['Whykontti ddikontti thekontti nttikokontti ckenchikontti sscrokontti thekontti ad?rokontti']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef kontti(s: str) -> str:\n    \"\"\"Converts a sentence into Kontti language.\n    \n    Args:\n        s (str): The input sentence to convert.\n        \n    Returns:\n        str: The converted sentence in Kontti language.\n    \"\"\"\n\n    def process_word(word):\n        vowels = 'aeiouyAEIOUY'\n        for i, char in enumerate(word):\n            if char in vowels:\n                return word[:i + 1] + '-kontti' + word[i + 1:]\n        return word + '-kontti'\n    words = s.split()\n    kontti_words = [process_word(word) for word in words]\n    return ' '.join(kontti_words)"], "requirement": [], "outputs": "[['he-konttillo'], ['wo-konttirld'], ['a-konttipple'], ['o-konttirange'], ['sky-kontti'], ['cry-konttipt'], ['rhy-konttithm'], ['A-konttiEIOUY'], ['a-kontti e-kontti i-kontti o-kontti u-kontti y-kontti'], ['he-konttillo wo-konttirld'], ['he-konttillo, wo-konttirld!'], ['Thi-konttis i-konttis a-kontti te-konttist.'], [''], [''], ['12345-kontti'], ['!@#$%-kontti'], ['Ko-konttintti la-konttinguage i-konttis fu-konttin.'], ['Why-kontti di-konttid the-kontti ko-konttintti chi-kontticken cro-konttiss the-kontti ro-konttiad?']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouyAEIOUY'\n        first_vowel_index = next((i for i, c in enumerate(word) if c in vowels), -1)\n        if first_vowel_index != -1:\n            prefix = word[:first_vowel_index + 1]\n            suffix = word[first_vowel_index + 1:]\n            transformed_prefix = prefix[::-1]\n            return transformed_prefix + suffix + 'kontti'\n        else:\n            return word\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        match = re.search('[aeiouyAEIOUY]', word)\n        if match:\n            index = match.start()\n            prefix = word[:index + 1]\n            suffix = word[index + 1:]\n            transformed_prefix = prefix[::-1]\n            return transformed_prefix + suffix + 'kontti'\n        else:\n            return word\n    return ' '.join((transform_word(word) for word in s.split()))"], "requirement": [], "outputs": "[['ehllokontti'], ['owrldkontti'], ['applekontti'], ['orangekontti'], ['ykskontti'], ['yrcptkontti'], ['yhrthmkontti'], ['AEIOUYkontti'], ['akontti ekontti ikontti okontti ukontti ykontti'], ['ehllokontti owrldkontti'], ['ehllo,kontti owrld!kontti'], ['ihTskontti iskontti akontti etst.kontti'], [''], [''], ['12345'], ['!@#$%'], ['oKnttikontti alnguagekontti iskontti ufn.kontti'], ['yhWkontti iddkontti ehtkontti oknttikontti ihcckenkontti orcsskontti ehtkontti orad?kontti']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouy'\n        match = re.search(f'[^{vowels}]*[{' + vowels + '}]', word)\n        if match:\n            start = match.group()\n            rest = word[len(start):]\n            transformed_start = start[::-1] + 'kontti'\n            return transformed_start + rest\n        else:\n            return word + 'kontti'\n    words = s.split()\n    kontti_words = [transform_word(word) for word in words]\n    return ' '.join(kontti_words)"], "requirement": [], "outputs": "[['ehkonttillo'], ['owkonttirld'], ['elppkonttie'], ['okonttirange'], ['skonttiky'], ['cryptkontti'], ['rhythmkontti'], ['AEIOUYkontti'], ['akontti ekontti ikontti okontti ukontti ykontti'], ['ehkonttillo owkonttirld'], ['ehkonttillo, owkonttirld!'], ['skonttihis skonttis akontti etkonttist.'], [''], [''], ['12345kontti'], ['!@#$%kontti'], ['oKkonttintti lkonttianguage skonttis fun.kontti'], ['Whykontti didkontti ehtkontti okkonttintti ekckontticken orckonttiss ehtkontti orkonttiad?']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        first_vowel_index = None\n        for i, char in enumerate(word):\n            if char.lower() in 'aeiouy':\n                first_vowel_index = i\n                break\n        if first_vowel_index is None:\n            return word + '-kontti'\n        transformed_part = word[first_vowel_index::-1] + word[first_vowel_index + 1:]\n        return transformed_part + '-kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "import re\nVOWELS = 'aeiouyAEIOUY'\nKONTTI_SUFFIX = '-kontti'\n\ndef kontti(s: str) -> str:\n\n    def process_word(word: str) -> str:\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), None)\n        if first_vowel_index is not None:\n            prefix = word[:first_vowel_index + 1][::-1]\n            suffix = word[first_vowel_index + 1:]\n            return prefix + suffix + KONTTI_SUFFIX\n        else:\n            return word + KONTTI_SUFFIX\n    return ' '.join((process_word(word) for word in s.split()))", "def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word: str) -> str:\n        vowels = 'aeiouyAEIOUY'\n        match = re.search(f'[{vowels}]', word)\n        if match:\n            idx = match.start()\n            if idx > 0:\n                word = word[idx] + word[1:idx] + word[0] + word[idx + 1:] + '-kontti'\n            else:\n                word = word + '-kontti'\n        else:\n            word = word + '-kontti'\n        return word\n    return ' '.join((transform_word(word) for word in s.split()))", "def kontti(s: str) -> str:\n    import re\n\n    def process_word(word):\n        match = re.search('[aeiouy]', word, re.IGNORECASE)\n        if match:\n            first_vowel_index = match.start()\n            start = word[:first_vowel_index + 1]\n            end = word[first_vowel_index + 1:]\n            swapped_start = start[::-1]\n            return swapped_start + end + '-kontti'\n        else:\n            return word + '-kontti'\n    words = s.split()\n    return ' '.join((process_word(word) for word in words))", "import re\nVOWELS = 'aeiouyAEIOUY'\nKONTTI_SUFFIX = '-kontti'\n\ndef kontti(s: str) -> str:\n\n    def process_word(word: str) -> str:\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), None)\n        if first_vowel_index is not None:\n            prefix = word[:first_vowel_index + 1][::-1]\n            suffix = word[first_vowel_index + 1:]\n            new_word = prefix + suffix + KONTTI_SUFFIX\n            return new_word\n        else:\n            return word + KONTTI_SUFFIX\n    words = s.split()\n    kontti_words = [process_word(word) for word in words]\n    return ' '.join(kontti_words)", "def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouyAEIOUY'\n        first_vowel_index = next((i for i, c in enumerate(word) if c in vowels), -1)\n        if first_vowel_index == -1:\n            return word + '-kontti'\n        part1 = word[:first_vowel_index + 1][::-1]\n        part2 = word[first_vowel_index + 1:]\n        return part1 + part2 + '-kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "import re\nVOWELS = 'aeiouyAEIOUY'\n\ndef kontti(s: str) -> str:\n\n    def process_word(word):\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), None)\n        if first_vowel_index is not None:\n            swapped_part = word[:first_vowel_index + 1][::-1]\n            rest_of_word = word[first_vowel_index + 1:]\n            word = swapped_part + rest_of_word\n        return word + '-kontti'\n    words = s.split()\n    kontti_words = [process_word(word) for word in words]\n    return ' '.join(kontti_words)", "import re\nVOWELS = 'aeiouyAEIOUY'\nKONTTI_SUFFIX = '-kontti'\n\ndef kontti(s: str) -> str:\n\n    def process_word(word: str) -> str:\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), None)\n        if first_vowel_index is None:\n            return word + KONTTI_SUFFIX\n        first_part = word[:first_vowel_index + 1][::-1]\n        second_part = word[first_vowel_index + 1:]\n        return first_part + second_part + KONTTI_SUFFIX\n    words = s.split()\n    processed_words = [process_word(word) for word in words]\n    return ' '.join(processed_words)", "import re\nVOWELS = 'aeiouyAEIOUY'\n\ndef kontti(s: str) -> str:\n\n    def process_word(word: str) -> str:\n        first_vowel_index = next((i for i, letter in enumerate(word) if letter in VOWELS), None)\n        if first_vowel_index is not None:\n            prefix = word[:first_vowel_index + 1]\n            suffix = word[first_vowel_index + 1:]\n            reversed_prefix = prefix[::-1]\n            word = reversed_prefix + suffix\n        return word + '-kontti'\n    return ' '.join((process_word(word) for word in s.split()))", "import re\nVOWELS = 'aeiouyAEIOUY'\nKONTTI_SUFFIX = '-kontti'\n\ndef kontti(s: str) -> str:\n\n    def transform_word(word):\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), -1)\n        if first_vowel_index != -1:\n            prefix = word[:first_vowel_index + 1][::-1]\n            suffix = word[first_vowel_index + 1:]\n            word = prefix + suffix + KONTTI_SUFFIX\n        else:\n            word += KONTTI_SUFFIX\n        return word\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouy'\n        match = re.search('[aeiouy]', word, re.IGNORECASE)\n        if match:\n            idx = match.start()\n            pre_vowel = word[:idx + 1]\n            post_vowel = word[idx + 1:]\n            transformed_word = pre_vowel[::-1] + post_vowel + '-kontti'\n            return transformed_word\n        else:\n            return word + '-kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouy'\n        first_vowel_index = next((i for i, c in enumerate(word) if c.lower() in vowels), -1)\n        if first_vowel_index != -1:\n            part1 = word[:first_vowel_index + 1]\n            part2 = word[first_vowel_index + 1:]\n            part1_reversed = part1[::-1]\n            transformed_word = part1_reversed + part2\n        else:\n            transformed_word = word\n        return transformed_word + '-kontti'\n    words = s.split()\n    kontti_words = [transform_word(word) for word in words]\n    return ' '.join(kontti_words)", "import re\nVOWELS = 'aeiouyAEIOUY'\n\ndef kontti(s: str) -> str:\n\n    def convert_word(word: str) -> str:\n        first_vowel_index = None\n        for i, char in enumerate(word):\n            if char in VOWELS:\n                first_vowel_index = i\n                break\n        if first_vowel_index is not None:\n            part1 = word[:first_vowel_index + 1][::-1]\n            part2 = word[first_vowel_index + 1:]\n            word = part1 + part2\n        return word + '-kontti'\n    words = s.split()\n    converted_words = [convert_word(word) for word in words]\n    return ' '.join(converted_words)", "import re\nVOWELS = 'aeiouyAEIOUY'\nKONTTI_SUFFIX = '-kontti'\n\ndef kontti(s: str) -> str:\n\n    def process_word(word):\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), -1)\n        if first_vowel_index == -1:\n            return word + KONTTI_SUFFIX\n        pre_vowel = word[:first_vowel_index + 1]\n        post_vowel = word[first_vowel_index + 1:]\n        reversed_pre_vowel = pre_vowel[::-1]\n        return reversed_pre_vowel + post_vowel + KONTTI_SUFFIX\n    words = s.split()\n    processed_words = [process_word(word) for word in words]\n    return ' '.join(processed_words)", "import re\n\ndef kontti(s: str) -> str:\n    \"\"\"Kontti language is a Finnish word play game.\n    \n    You add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\"); \n    If no vowel is present, the word stays the same.\n\n    Args:\n        s (str): The input sentence to transform.\n\n    Returns:\n        str: The transformed sentence in Kontti language.\n    \"\"\"\n\n    def transform_word(word):\n        vowels = 'aeiouyAEIOUY'\n        for i, char in enumerate(word):\n            if char in vowels:\n                if i > 0:\n                    word = word[i] + word[1:i] + word[0] + word[i + 1:]\n                break\n        return word + '-kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouyAEIOUY'\n        first_vowel_index = next((i for i, c in enumerate(word) if c in vowels), None)\n        if first_vowel_index is not None:\n            start, rest = (word[:first_vowel_index + 1], word[first_vowel_index + 1:])\n            reversed_start = start[::-1]\n            transformed_word = reversed_start + rest + '-kontti'\n            return transformed_word\n        else:\n            return word + '-kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "import re\nVOWELS = 'aeiouyAEIOUY'\nKONTTI_SUFFIX = '-kontti'\n\ndef kontti(s: str) -> str:\n\n    def process_word(word):\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), None)\n        if first_vowel_index is None:\n            return word + KONTTI_SUFFIX\n        else:\n            pre_vowel_part = word[:first_vowel_index + 1][::-1]\n            post_vowel_part = word[first_vowel_index + 1:]\n            return pre_vowel_part + post_vowel_part + KONTTI_SUFFIX\n    return ' '.join((process_word(word) for word in s.split()))", "import re\nVOWELS = 'aeiouyAEIOUY'\n\ndef kontti(s: str) -> str:\n    \"\"\"Kontti language is a Finnish word play game.\n    \n    You add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\"); \n    \n    If no vowel is present, the word stays the same.\n    \n    Args:\n        s (str): The input sentence to transform into Kontti language.\n        \n    Returns:\n        str: The transformed sentence in Kontti language.\n    \"\"\"\n\n    def transform_word(word: str) -> str:\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), -1)\n        if first_vowel_index == -1:\n            return word + '-kontti'\n        prefix = word[:first_vowel_index + 1]\n        suffix = word[first_vowel_index + 1:]\n        swapped_prefix = ''.join([prefix[i] for i in range(len(prefix) - 1, -1, -1)])\n        return swapped_prefix + suffix + '-kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        first_vowel_pos = next((i for i, c in enumerate(word) if c.lower() in 'aeiouy'), -1)\n        if first_vowel_pos == -1:\n            return word + '-kontti'\n        prefix = word[:first_vowel_pos + 1]\n        suffix = word[first_vowel_pos + 1:]\n        transformed_word = prefix[::-1] + suffix + '-kontti'\n        return transformed_word\n    words = s.split()\n    kontti_words = [transform_word(word) for word in words]\n    return ' '.join(kontti_words)", "import re\n\ndef kontti(s: str) -> str:\n    \"\"\"Kontti language is a Finnish word play game.\n    \n    You add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\"); \n    If no vowel is present, the word stays the same.\n\n    Args:\n        s (str): The input sentence to transform into Kontti language.\n\n    Returns:\n        str: The transformed sentence in Kontti language.\n    \"\"\"\n    vowels = 'aeiouy'\n    words = s.split()\n\n    def transform_word(word):\n        first_vowel_index = next((i for i, c in enumerate(word) if c.lower() in vowels), None)\n        if first_vowel_index is not None:\n            if first_vowel_index > 0:\n                part1 = word[first_vowel_index::-1]\n                part2 = word[first_vowel_index + 1:]\n                new_word = part1 + part2\n            else:\n                new_word = word\n        else:\n            new_word = word\n        return new_word + '-kontti'\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)"], "requirement": [], "outputs": "[['ehllo-kontti'], ['owrld-kontti'], ['apple-kontti'], ['orange-kontti'], ['yks-kontti'], ['yrcpt-kontti'], ['yhrthm-kontti'], ['AEIOUY-kontti'], ['a-kontti e-kontti i-kontti o-kontti u-kontti y-kontti'], ['ehllo-kontti owrld-kontti'], ['ehllo,-kontti owrld!-kontti'], ['ihTs-kontti is-kontti a-kontti etst.-kontti'], [''], [''], ['12345-kontti'], ['!@#$%-kontti'], ['oKntti-kontti alnguage-kontti is-kontti ufn.-kontti'], ['yhW-kontti idd-kontti eht-kontti okntti-kontti ihccken-kontti orcss-kontti eht-kontti orad?-kontti']]", "probability": 0.4, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouy'\n        index_of_first_vowel = next((i for i, c in enumerate(word) if c.lower() in vowels), -1)\n        if index_of_first_vowel != -1:\n            part1 = word[:index_of_first_vowel]\n            part2 = word[index_of_first_vowel:]\n            transformed_part1 = part1[::-1]\n            transformed_word = transformed_part1 + part2\n        else:\n            transformed_word = word\n        return transformed_word + '-kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "import re\n\ndef kontti(s: str) -> str:\n\n    def transform_word(word):\n        vowels = 'aeiouyAEIOUY'\n        match = re.search('[{}]+'.format(vowels), word)\n        if not match:\n            return word + '-kontti'\n        first_vowel_index = match.start()\n        beginning_consonants = word[:first_vowel_index]\n        rest_of_word = word[first_vowel_index:]\n        swapped_part = beginning_consonants[::-1] + rest_of_word\n        return swapped_part + '-kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "import re\nVOWELS = 'aeiouyAEIOUY'\nKONTTI_SUFFIX = '-kontti'\n\ndef kontti(s: str) -> str:\n\n    def process_word(word: str) -> str:\n        if not any((char in VOWELS for char in word)):\n            return word + KONTTI_SUFFIX\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), None)\n        if first_vowel_index is None:\n            return word + KONTTI_SUFFIX\n        beginning_consonants = word[:first_vowel_index][::-1]\n        rest_of_word = word[first_vowel_index:]\n        return beginning_consonants + rest_of_word + KONTTI_SUFFIX\n    words = s.split()\n    kontti_words = [process_word(word) for word in words]\n    return ' '.join(kontti_words)", "import re\nVOWELS = 'aeiouyAEIOUY'\nKONTTI_SUFFIX = '-kontti'\n\ndef kontti(s: str) -> str:\n    \"\"\"Converts a sentence to Kontti language.\n    \n    Args:\n        s (str): The input sentence.\n\n    Returns:\n        str: The sentence converted to Kontti language.\n    \"\"\"\n\n    def process_word(word):\n        first_vowel_index = next((i for i, letter in enumerate(word) if letter in VOWELS), -1)\n        if first_vowel_index == -1:\n            return f'{word}{KONTTI_SUFFIX}'\n        prefix, rest = (word[:first_vowel_index], word[first_vowel_index:])\n        reversed_prefix = prefix[::-1]\n        return f'{reversed_prefix}{rest}{KONTTI_SUFFIX}'\n    words = s.split()\n    kontti_words = [process_word(word) for word in words]\n    return ' '.join(kontti_words)"], "requirement": [], "outputs": "[['hello-kontti'], ['world-kontti'], ['apple-kontti'], ['orange-kontti'], ['ksy-kontti'], ['rcypt-kontti'], ['hrythm-kontti'], ['AEIOUY-kontti'], ['a-kontti e-kontti i-kontti o-kontti u-kontti y-kontti'], ['hello-kontti world-kontti'], ['hello,-kontti world!-kontti'], ['hTis-kontti is-kontti a-kontti test.-kontti'], [''], [''], ['12345-kontti'], ['!@#$%-kontti'], ['Kontti-kontti language-kontti is-kontti fun.-kontti'], ['hWy-kontti did-kontti hte-kontti kontti-kontti hcicken-kontti rcoss-kontti hte-kontti road?-kontti']]", "probability": 0.08, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouyAEIOUY'\n        vowel_index = next((i for i, c in enumerate(word) if c in vowels), None)\n        if vowel_index is not None:\n            part1 = word[:vowel_index + 1][::-1]\n            part2 = word[vowel_index + 1:]\n            transformed_word = part1 + part2 + 'kontti'\n        else:\n            transformed_word = word + 'kontti'\n        return transformed_word\n    words = s.split()\n    kontti_words = [transform_word(word) for word in words]\n    return ' '.join(kontti_words)", "def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouyAEIOUY'\n        for i, char in enumerate(word):\n            if char in vowels:\n                break\n        else:\n            return word + 'kontti'\n        prefix = word[:i + 1]\n        suffix = word[i + 1:]\n        swapped_prefix = prefix[::-1]\n        return swapped_prefix + suffix + 'kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word: str) -> str:\n        vowels = 'aeiouy'\n        for i, letter in enumerate(word):\n            if letter.lower() in vowels:\n                prefix = word[:i + 1]\n                suffix = word[i + 1:]\n                return prefix[::-1] + suffix + 'kontti'\n        return word + 'kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)", "def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouyAEIOUY'\n        first_vowel_index = None\n        for i, char in enumerate(word):\n            if char in vowels:\n                first_vowel_index = i\n                break\n        if first_vowel_index is not None:\n            prefix = word[:first_vowel_index + 1]\n            postfix = word[first_vowel_index + 1:]\n            swapped_prefix = prefix[::-1]\n            transformed_word = swapped_prefix + postfix\n        else:\n            transformed_word = word\n        return transformed_word + 'kontti'\n    words = s.split()\n    kontti_words = [transform_word(word) for word in words]\n    return ' '.join(kontti_words)", "import re\n\ndef kontti(s: str) -> str:\n\n    def word_to_kontti(word: str) -> str:\n        vowels = 'aeiouyAEIOUY'\n        first_vowel_index = next((i for i, char in enumerate(word) if char in vowels), None)\n        if first_vowel_index is not None:\n            part1 = word[:first_vowel_index + 1]\n            part2 = word[first_vowel_index + 1:]\n            part1_swapped = part1[::-1]\n            return part1_swapped + part2 + 'kontti'\n        else:\n            return word + 'kontti'\n    words = s.split()\n    kontti_words = [word_to_kontti(word) for word in words]\n    return ' '.join(kontti_words)", "def kontti(s: str) -> str:\n    import re\n\n    def convert_word(word):\n        match = re.search('[aeiouyAEIOUY]', word)\n        if match:\n            index = match.start()\n            modified_word = word[index::-1] + word[index + 1:] + 'kontti'\n        else:\n            modified_word = word + 'kontti'\n        return modified_word\n    return ' '.join((convert_word(word) for word in s.split()))"], "requirement": [], "outputs": "[['ehllokontti'], ['owrldkontti'], ['applekontti'], ['orangekontti'], ['ykskontti'], ['yrcptkontti'], ['yhrthmkontti'], ['AEIOUYkontti'], ['akontti ekontti ikontti okontti ukontti ykontti'], ['ehllokontti owrldkontti'], ['ehllo,kontti owrld!kontti'], ['ihTskontti iskontti akontti etst.kontti'], [''], [''], ['12345kontti'], ['!@#$%kontti'], ['oKnttikontti alnguagekontti iskontti ufn.kontti'], ['yhWkontti iddkontti ehtkontti oknttikontti ihcckenkontti orcsskontti ehtkontti orad?kontti']]", "probability": 0.12, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def process_word(word):\n        vowels = 'aeiouy'\n        match = re.search(f'[^{vowels}]*[{vowels}]', word)\n        if match:\n            prefix = match.group(0)\n            rest = word[match.end():]\n            swapped_prefix = prefix[::-1]\n            return swapped_prefix + rest + '-kontti'\n        else:\n            return word\n    words = s.split()\n    kontti_words = [process_word(word) for word in words]\n    return ' '.join(kontti_words)"], "requirement": [], "outputs": "[['ehllo-kontti'], ['owrld-kontti'], ['apple-kontti'], ['orange-kontti'], ['yks-kontti'], ['yrcpt-kontti'], ['yhrthm-kontti'], ['AEIOUY'], ['a-kontti e-kontti i-kontti o-kontti u-kontti y-kontti'], ['ehllo-kontti owrld-kontti'], ['ehllo,-kontti owrld!-kontti'], ['ihTs-kontti is-kontti a-kontti etst.-kontti'], [''], [''], ['12345'], ['!@#$%'], ['oKntti-kontti alnguage-kontti is-kontti ufn.-kontti'], ['yhW-kontti idd-kontti eht-kontti okntti-kontti ihccken-kontti orcss-kontti eht-kontti orad?-kontti']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouy'\n        match = re.search(f'[{vowels}]', word, re.IGNORECASE)\n        if match:\n            first_vowel_index = match.start()\n            prefix = word[:first_vowel_index + 1]\n            suffix = word[first_vowel_index + 1:]\n            transformed_prefix = prefix[::-1]\n            return transformed_prefix + suffix + '-kontti'\n        else:\n            return word\n    words = s.split()\n    kontti_words = [transform_word(word) for word in words]\n    return ' '.join(kontti_words)", "import re\n\ndef kontti(s: str) -> str:\n    \"\"\"Kontti language is a Finnish word play game.\n    \n    You add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\"); \n    \n    If no vowel is present, the word stays the same.\n    \n    Args:\n        s (str): The input sentence.\n    \n    Returns:\n        str: The sentence in Kontti language.\n    \"\"\"\n\n    def process_word(word):\n        vowels = 'aeiouy'\n        match = re.search(f'[{vowels}{vowels.upper()}]', word)\n        if match:\n            index = match.start()\n            swapped_part = word[:index + 1][::-1]\n            rest_of_word = word[index + 1:]\n            processed_word = swapped_part + rest_of_word + '-kontti'\n        else:\n            processed_word = word\n        return processed_word\n    words = s.split()\n    kontti_words = [process_word(word) for word in words]\n    return ' '.join(kontti_words)", "from typing import List\n\ndef kontti(s: str) -> str:\n    \"\"\"Kontti language is a Finnish word play game.\n    \n    You add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\"); \n    If no vowel is present, the word stays the same.\n    \n    Args:\n        s (str): The input sentence to be converted.\n    \n    Returns:\n        str: The sentence in Kontti language.\n    \"\"\"\n\n    def process_word(word: str) -> str:\n        vowels = 'aeiouy'\n        first_vowel_index = None\n        for i, char in enumerate(word):\n            if char.lower() in vowels:\n                first_vowel_index = i\n                break\n        if first_vowel_index is not None:\n            part1 = word[:first_vowel_index + 1][::-1]\n            part2 = word[first_vowel_index + 1:]\n            new_word = part1 + part2 + '-kontti'\n            return new_word\n        else:\n            return word\n    words = s.split()\n    processed_words = [process_word(word) for word in words]\n    return ' '.join(processed_words)", "import re\nVOWELS = 'aeiouyAEIOUY'\nKONTTI_SUFFIX = '-kontti'\n\ndef kontti(s: str) -> str:\n    \"\"\"Converts a sentence into Kontti language.\n    \n    Parameters:\n    s (str): The input sentence to convert.\n    \n    Returns:\n    str: The converted sentence in Kontti language.\n    \"\"\"\n\n    def process_word(word):\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), None)\n        if first_vowel_index is not None:\n            swapped_part = word[first_vowel_index::-1] + word[first_vowel_index + 1:]\n            return swapped_part + KONTTI_SUFFIX\n        else:\n            return word\n    words = s.split()\n    processed_words = [process_word(word) for word in words]\n    return ' '.join(processed_words)", "import re\n\ndef kontti(s: str) -> str:\n    \"\"\"Kontti language is a Finnish word play game.\n    \n    You add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\"); \n    If no vowel is present, the word stays the same.\n\n    Args:\n        s (str): The input sentence to convert to Kontti language.\n\n    Returns:\n        str: The converted sentence in Kontti language.\n    \"\"\"\n\n    def process_word(word: str) -> str:\n        vowels = 'aeiouy'\n        for i, char in enumerate(word):\n            if char.lower() in vowels:\n                if i > 0:\n                    word = word[i] + word[1:i] + word[0] + word[i + 1:]\n                break\n        return word + '-kontti'\n    words = s.split()\n    processed_words = [process_word(word) if re.search('[aeiouy]', word, re.IGNORECASE) else word for word in words]\n    return ' '.join(processed_words)"], "requirement": [], "outputs": "[['ehllo-kontti'], ['owrld-kontti'], ['apple-kontti'], ['orange-kontti'], ['yks-kontti'], ['yrcpt-kontti'], ['yhrthm-kontti'], ['AEIOUY-kontti'], ['a-kontti e-kontti i-kontti o-kontti u-kontti y-kontti'], ['ehllo-kontti owrld-kontti'], ['ehllo,-kontti owrld!-kontti'], ['ihTs-kontti is-kontti a-kontti etst.-kontti'], [''], [''], ['12345'], ['!@#$%'], ['oKntti-kontti alnguage-kontti is-kontti ufn.-kontti'], ['yhW-kontti idd-kontti eht-kontti okntti-kontti ihccken-kontti orcss-kontti eht-kontti orad?-kontti']]", "probability": 0.1, "is_align_req": false, "DRS": null}, {"programs_str": ["import re\n\ndef kontti(s: str) -> str:\n    \"\"\"Kontti language is a Finnish word play game.\n    \n    You add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\"); \n    \n    If no vowel is present, the word stays the same.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        str: The input string converted to Kontti language.\n    \"\"\"\n\n    def transform_word(word):\n        vowels = 'aeiouy'\n        match = re.search(f'[^{vowels}]*[{vowels}]+', word, re.IGNORECASE)\n        if match:\n            prefix = match.group()\n            rest = word[len(prefix):]\n            transformed_prefix = prefix[::-1]\n            return f'{transformed_prefix}{rest}-kontti'\n        else:\n            return f'{word}-kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)"], "requirement": [], "outputs": "[['ehllo-kontti'], ['owrld-kontti'], ['apple-kontti'], ['orange-kontti'], ['yks-kontti'], ['yrcpt-kontti'], ['yhrthm-kontti'], ['YUOIEA-kontti'], ['a-kontti e-kontti i-kontti o-kontti u-kontti y-kontti'], ['ehllo-kontti owrld-kontti'], ['ehllo,-kontti owrld!-kontti'], ['ihTs-kontti is-kontti a-kontti etst.-kontti'], [''], [''], ['12345-kontti'], ['!@#$%-kontti'], ['oKntti-kontti alnguage-kontti is-kontti ufn.-kontti'], ['yhW-kontti idd-kontti eht-kontti okntti-kontti ihccken-kontti orcss-kontti eht-kontti aord?-kontti']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        vowels = 'aeiouy'\n        for i, char in enumerate(word):\n            if char.lower() in vowels:\n                break\n        else:\n            return word + 'kontti'\n        if i == 0:\n            transformed_word = word[0] + word[i + 1:] + word[i] + 'kontti'\n        else:\n            transformed_word = word[i] + word[1:i] + word[0] + word[i + 1:] + 'kontti'\n        return transformed_word\n    words = s.split()\n    kontti_words = [transform_word(word) for word in words]\n    return ' '.join(kontti_words)"], "requirement": [], "outputs": "[['ehllokontti'], ['owrldkontti'], ['appleakontti'], ['orangeokontti'], ['ykskontti'], ['yrcptkontti'], ['yhrthmkontti'], ['AEIOUYAkontti'], ['aakontti eekontti iikontti ookontti uukontti yykontti'], ['ehllokontti owrldkontti'], ['ehllo,kontti owrld!kontti'], ['ihTskontti isikontti aakontti etst.kontti'], [''], [''], ['12345kontti'], ['!@#$%kontti'], ['oKnttikontti alnguagekontti isikontti ufn.kontti'], ['yhWkontti iddkontti ehtkontti oknttikontti ihcckenkontti orcsskontti ehtkontti orad?kontti']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def process_word(word):\n        match = re.search('[aeiouyAEIOUY]', word)\n        if not match:\n            return word + 'kontti'\n        vowel_index = match.start()\n        part1 = word[:vowel_index + 1][::-1]\n        part2 = word[vowel_index + 1:]\n        return (part1 + part2 + 'kontti').lower()\n    words = s.split()\n    processed_words = [process_word(word) for word in words]\n    return ' '.join(processed_words)"], "requirement": [], "outputs": "[['ehllokontti'], ['owrldkontti'], ['applekontti'], ['orangekontti'], ['ykskontti'], ['yrcptkontti'], ['yhrthmkontti'], ['aeiouykontti'], ['akontti ekontti ikontti okontti ukontti ykontti'], ['ehllokontti owrldkontti'], ['ehllo,kontti owrld!kontti'], ['ihtskontti iskontti akontti etst.kontti'], [''], [''], ['12345kontti'], ['!@#$%kontti'], ['oknttikontti alnguagekontti iskontti ufn.kontti'], ['yhwkontti iddkontti ehtkontti oknttikontti ihcckenkontti orcsskontti ehtkontti orad?kontti']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import re\nVOWELS = 'aeiouyAEIOUY'\nKONTTI_SUFFIX = '-kontti'\n\ndef kontti(s: str) -> str:\n\n    def process_word(word: str) -> str:\n        first_vowel_index = next((i for i, c in enumerate(word) if c in VOWELS), None)\n        if first_vowel_index is not None:\n            part1 = word[:first_vowel_index + 1][::-1]\n            part2 = word[first_vowel_index + 1:]\n            processed_word = part1 + part2 + KONTTI_SUFFIX\n        else:\n            processed_word = word + KONTTI_SUFFIX\n        return processed_word\n    words = re.findall('\\\\b\\\\w+\\\\b', s)\n    non_words = re.findall('\\\\W+', s)\n    kontti_sentence = ''\n    for i, word in enumerate(words):\n        kontti_sentence += process_word(word)\n        if i < len(non_words):\n            kontti_sentence += non_words[i]\n    return kontti_sentence + (non_words[-1] if len(non_words) > len(words) else '')", "import re\n\ndef kontti(s: str) -> str:\n    \"\"\"Kontti language is a finnish word play game.\n    \n    You add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\"); \n    \n    If no vowel is present, the word stays the same.\n    \n    Args:\n        s (str): The input sentence to convert into Kontti language.\n    \n    Returns:\n        str: The sentence converted to Kontti language.\n    \"\"\"\n    vowels = 'aeiouy'\n\n    def transform_word(word):\n        first_vowel_index = None\n        for i, char in enumerate(word):\n            if char.lower() in vowels:\n                first_vowel_index = i\n                break\n        if first_vowel_index is None:\n            return word + '-kontti'\n        part1 = word[:first_vowel_index + 1]\n        part2 = word[first_vowel_index + 1:]\n        reversed_part1 = part1[::-1]\n        return reversed_part1 + part2 + '-kontti'\n    words = re.findall('\\\\b\\\\w+\\\\b', s)\n    transformed_words = [transform_word(word) for word in words]\n    result_parts = []\n    last_end = 0\n    for match in re.finditer('\\\\b\\\\w+\\\\b', s):\n        start, end = match.span()\n        result_parts.append(s[last_end:start])\n        result_parts.append(transformed_words.pop(0))\n        last_end = end\n    result_parts.append(s[last_end:])\n    return ''.join(result_parts)"], "requirement": [], "outputs": "[['ehllo-kontti'], ['owrld-kontti'], ['apple-kontti'], ['orange-kontti'], ['yks-kontti'], ['yrcpt-kontti'], ['yhrthm-kontti'], ['AEIOUY-kontti'], ['a-kontti e-kontti i-kontti o-kontti u-kontti y-kontti'], ['ehllo-kontti owrld-kontti'], ['ehllo-kontti, owrld-kontti!'], ['ihTs-kontti is-kontti a-kontti etst-kontti.'], [''], [' '], ['12345-kontti'], ['!@#$%'], ['oKntti-kontti alnguage-kontti is-kontti ufn-kontti.'], ['yhW-kontti idd-kontti eht-kontti okntti-kontti ihccken-kontti orcss-kontti eht-kontti orad-kontti?']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["def kontti(s: str) -> str:\n    import re\n\n    def transform_word(word):\n        match = re.search('[aeiouy]', word, re.IGNORECASE)\n        if match:\n            vowel_index = match.start()\n            prefix = word[:vowel_index + 1]\n            suffix = word[vowel_index + 1:]\n            transformed_part = suffix + prefix\n        else:\n            transformed_part = word\n        return transformed_part + '-kontti'\n    return ' '.join((transform_word(word) for word in s.split()))"], "requirement": [], "outputs": "[['llohe-kontti'], ['rldwo-kontti'], ['pplea-kontti'], ['rangeo-kontti'], ['sky-kontti'], ['ptcry-kontti'], ['thmrhy-kontti'], ['EIOUYA-kontti'], ['a-kontti e-kontti i-kontti o-kontti u-kontti y-kontti'], ['llohe-kontti rldwo-kontti'], ['llo,he-kontti rld!wo-kontti'], ['sThi-kontti si-kontti a-kontti st.te-kontti'], [''], [''], ['12345-kontti'], ['!@#$%-kontti'], ['nttiKo-kontti nguagela-kontti si-kontti n.fu-kontti'], ['Why-kontti ddi-kontti the-kontti nttiko-kontti ckenchi-kontti sscro-kontti the-kontti ad?ro-kontti']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import re\n\ndef kontti(s: str) -> str:\n    \"\"\"Kontti language is a Finnish word play game.\n    \n    You add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\"); \n    If no vowel is present, the word stays the same.\n\n    Args:\n        s (str): The input sentence to transform.\n\n    Returns:\n        str: The transformed sentence in Kontti language.\n    \"\"\"\n\n    def transform_word(word):\n        match = re.search('[aeiouy]', word, re.IGNORECASE)\n        if match:\n            vowel_index = match.start()\n            transformed_part = word[vowel_index::-1] + word[vowel_index + 1:] + '-kontti'\n            return transformed_part.lower()\n        else:\n            return word.lower() + '-kontti'\n    words = s.split()\n    transformed_words = [transform_word(word) for word in words]\n    return ' '.join(transformed_words)"], "requirement": [], "outputs": "[['ehllo-kontti'], ['owrld-kontti'], ['apple-kontti'], ['orange-kontti'], ['yks-kontti'], ['yrcpt-kontti'], ['yhrthm-kontti'], ['aeiouy-kontti'], ['a-kontti e-kontti i-kontti o-kontti u-kontti y-kontti'], ['ehllo-kontti owrld-kontti'], ['ehllo,-kontti owrld!-kontti'], ['ihts-kontti is-kontti a-kontti etst.-kontti'], [''], [''], ['12345-kontti'], ['!@#$%-kontti'], ['okntti-kontti alnguage-kontti is-kontti ufn.-kontti'], ['yhw-kontti idd-kontti eht-kontti okntti-kontti ihccken-kontti orcss-kontti eht-kontti orad?-kontti']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 2.171419845121386, "llm_generated_inputs": "[['hello'], ['world'], ['apple'], ['orange'], ['sky'], ['crypt'], ['rhythm'], ['AEIOUY'], ['a e i o u y'], ['hello world'], ['hello, world!'], ['This is a test.'], [''], [' '], ['12345'], ['!@#$%'], ['Kontti language is fun.'], ['Why did the kontti chicken cross the road?']]", "input_output_examples": "[[['tame'], ['fruity']], [['kome-tantti'], ['koity-fruntti']]]", "at_least_one_align": false}, "entry_point": "kontti", "ground_truth": -1}
{"task_id": "TACO_lite/31", "requirement": "def count_divisors(n: int) -> int:\n\"\"\"In this Kata we focus on finding a sum S(n) which is the total number of divisors taken for all natural numbers less or equal to n. More formally, we investigate the sum of n components denoted by d(1) + d(2) + ... + d(n) in which for any i starting from 1 up to n the value of d(i) tells us how many distinct numbers divide i without a remainder. \n\nYour solution should work for possibly large values of n without a timeout.\nAssume n to be greater than zero and not greater than 999 999 999 999 999.\nBrute force approaches will not be feasible options in such cases. It is fairly simple to conclude that for every n>1 there holds a recurrence S(n) = S(n-1) + d(n) with initial case S(1) = 1.\n\nTry to convince yourself that for any natural k, the number S(k) is the same as the number of pairs (m,n) that solve the inequality mn <= k in natural numbers.\nOnce it becomes clear, we can think of a partition of all the solutions into classes just by saying that a pair (m,n) belongs to the class indexed by n.\nThe question now arises if it is possible to count solutions of n-th class. If f(n) stands for the number of solutions that belong to n-th class, it means that S(k) = f(1) + f(2) + f(3) + ...\n\nThe reasoning presented above leads us to some kind of a formula for S(k), however not necessarily the most efficient one. Can you imagine that all the solutions to inequality mn <= k can be split using sqrt(k) as pivotal item?\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers up to n.\"\"\"\n    S = 0\n    for divisor in range(1, int(math.sqrt(n)) + 1):\n        S += n // divisor\n    sqrt_n = int(math.sqrt(n))\n    S -= sqrt_n * sqrt_n - sqrt_n\n    return S", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers up to n.\"\"\"\n\n    def divisor_count(x):\n        \"\"\"Helper function to calculate the number of divisors for a given number x.\"\"\"\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 2 if i * i != x else 1\n        return count\n    total = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        total += n // i - (i - 1)\n    total -= sqrt_n * (sqrt_n - 1) // 2\n    return total"], "requirement": [], "outputs": "[[1], [5], [12], [29], [86], [201], [3085], [41934], [533763], [6486991], [6486017], 'Timeout', ['ValueError'], [0], [1.0], ['TypeError']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    limit = int(math.sqrt(n)) + 1\n    divisors = [0] * (n + 1)\n    for i in range(1, limit):\n        for j in range(i, n // i + 1):\n            divisors[i * j] += 2 if i != j else 1\n    S = 0\n    for i in range(1, n + 1):\n        S += divisors[i]\n    return S"], "requirement": [], "outputs": "[[1], [10], [27], [66], [207], [482], [7069], [93668], [1166750], [13969985], [13970034], ['MemoryError'], ['ValueError'], [0], ['TypeError'], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    if n == 1:\n        return 1\n    total_divisors = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        total_divisors += n // i\n    total_divisors -= sqrt_n * (sqrt_n - 1) // 2\n    return total_divisors", "import math\n\ndef count_divisors(n: int) -> int:\n    if n == 1:\n        return 1\n    sqrt_n = int(math.sqrt(n))\n    total_divisors_sum = 0\n    for i in range(1, sqrt_n + 1):\n        total_divisors_sum += n // i\n    total_divisors_sum -= sqrt_n * (sqrt_n - 1) // 2\n    return total_divisors_sum", "import math\n\ndef count_divisors(n: int) -> int:\n\n    def d(i: int) -> int:\n        count = 0\n        for j in range(1, int(math.sqrt(i)) + 1):\n            if i % j == 0:\n                count += 2 if j * j != i else 1\n        return count\n    total = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        total += n // i\n    total -= sqrt_n * (sqrt_n - 1) // 2\n    return total", "import math\n\ndef count_divisors(n: int) -> int:\n    if n == 1:\n        return 1\n    sqrt_n = int(math.sqrt(n))\n    count = 0\n    for i in range(1, sqrt_n + 1):\n        count += n // i\n    count -= sqrt_n * (sqrt_n - 1) // 2\n    return count"], "requirement": [], "outputs": "[[1], [6], [15], [35], [107], [246], [3550], [46884], [583533], [6985492], [6985517], 'Timeout', ['ValueError'], [0], [1.0], ['TypeError']]", "probability": 0.08, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n\n    def divisor_count(num):\n        count = 0\n        for i in range(1, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                count += 2\n                if i == num // i:\n                    count -= 1\n        return count\n    total_sum = 0\n    for i in range(1, n + 1):\n        total_sum += divisor_count(i)\n    return total_sum\n\ndef optimized_count_divisors(n: int) -> int:\n    total_sum = 0\n    for i in range(1, n + 1):\n        total_sum += n // i\n    return total_sum", "import math\n\ndef count_divisors(n: int) -> int:\n\n    def divisor_count(x):\n        \"\"\"Helper function to calculate the number of divisors for a given number x.\"\"\"\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 2\n                if i * i == x:\n                    count -= 1\n        return count\n    S = 0\n    for i in range(1, n + 1):\n        S += divisor_count(i)\n    return S\n\ndef count_divisors_optimized(n: int) -> int:\n    S = 0\n    for i in range(1, n + 1):\n        S += n // i\n    return S", "import math\n\ndef count_divisors(n: int) -> int:\n\n    def divisors_count(x):\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 2\n                if i * i == x:\n                    count -= 1\n        return count\n    total_sum = 0\n    for i in range(1, n + 1):\n        total_sum += divisors_count(i)\n    return total_sum\n\ndef S(n: int) -> int:\n    sqrt_n = int(math.sqrt(n))\n    total = 0\n    for i in range(1, sqrt_n + 1):\n        total += n // i\n    total -= sqrt_n * (sqrt_n - 1) // 2\n    return total", "import math\n\ndef count_divisors(n: int) -> int:\n\n    def d(i: int) -> int:\n        count = 0\n        for j in range(1, int(math.sqrt(i)) + 1):\n            if i % j == 0:\n                count += 2 if j * j != i else 1\n        return count\n\n    def S(k: int) -> int:\n        result = 0\n        for i in range(1, k + 1):\n            result += d(i)\n        return result\n    return S(n)\n\ndef optimized_count_divisors(n: int) -> int:\n    result = 0\n    sqrt_n = int(math.sqrt(n))\n    for m in range(1, sqrt_n + 1):\n        result += n // m\n    result -= sqrt_n * (sqrt_n - 1) // 2\n    return result\n\ndef count_divisors_optimized(n: int) -> int:\n    return optimized_count_divisors(n)", "import math\n\ndef count_divisors(n: int) -> int:\n\n    def d(i: int) -> int:\n        count = 0\n        for j in range(1, int(math.sqrt(i)) + 1):\n            if i % j == 0:\n                count += 2 if j * j != i else 1\n        return count\n    sum_of_divisors = 0\n    for i in range(1, n + 1):\n        sum_of_divisors += d(i)\n    return sum_of_divisors\n\ndef count_divisors_optimized(n: int) -> int:\n    total_pairs = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        total_pairs += n // i\n    total_pairs -= sqrt_n * (sqrt_n + 1) // 2 - sqrt_n\n    return total_pairs", "import math\n\ndef count_divisors(n: int) -> int:\n\n    def divisors_count(x):\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 2 if i * i != x else 1\n        return count\n    sum_divisors = 0\n    for i in range(1, n + 1):\n        sum_divisors += divisors_count(i)\n    return sum_divisors", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers up to n.\"\"\"\n\n    def divisor_count(x):\n        \"\"\"Helper function to calculate number of divisors for a given x.\"\"\"\n        divisors = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                divisors += 2 if i * i != x else 1\n        return divisors\n    total_divisor_sum = 0\n    for i in range(1, n + 1):\n        total_divisor_sum += divisor_count(i)\n    return total_divisor_sum\n\ndef count_divisors_efficient(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers up to n efficiently.\"\"\"\n    divisor_counts = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            divisor_counts[j] += 1\n    return sum(divisor_counts)", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers up to n.\"\"\"\n\n    def num_divisors(k: int) -> int:\n        \"\"\"Return the number of divisors of k.\"\"\"\n        count = 0\n        for i in range(1, int(math.sqrt(k)) + 1):\n            if k % i == 0:\n                count += 2 if i * i != k else 1\n        return count\n    total = 0\n    for i in range(1, n + 1):\n        total += num_divisors(i)\n    return total\n\ndef optimized_count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers up to n efficiently.\"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += n // i\n    return total", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the number of divisors for all natural numbers from 1 to n.\n    \n    Args:\n    n (int): The upper limit of the natural numbers to consider.\n    \n    Returns:\n    int: The sum of the number of divisors for all natural numbers up to n.\n    \"\"\"\n    total_divisors = 0\n    for i in range(1, n + 1):\n        total_divisors += sum((i % d == 0 for d in range(1, math.isqrt(i) + 1))) * 2 - (math.isqrt(i) ** 2 == i)\n    return total_divisors\n\ndef optimized_count_divisors(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the number of divisors for all natural numbers from 1 to n efficiently.\n    \n    Args:\n    n (int): The upper limit of the natural numbers to consider.\n    \n    Returns:\n    int: The sum of the number of divisors for all natural numbers up to n.\n    \"\"\"\n    total_divisors = 0\n    for i in range(1, math.isqrt(n) + 1):\n        total_divisors += n // i\n    for i in range(1, math.isqrt(n) + 1):\n        if i * i <= n:\n            total_divisors -= 1\n    return total_divisors", "import math\n\ndef count_divisors(n: int) -> int:\n\n    def divisors(x):\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 2\n                if i == x // i:\n                    count -= 1\n        return count\n    S = 0\n    for i in range(1, n + 1):\n        S += divisors(i)\n    return S\n\ndef count_divisors_optimized(n: int) -> int:\n    S = 0\n    for divisor in range(1, int(math.sqrt(n)) + 1):\n        S += n // divisor * 2\n        if divisor == n // divisor:\n            S -= 1\n    S -= int(math.sqrt(n))\n    return S", "import math\n\ndef count_divisors(n: int) -> int:\n    if n <= 0:\n        return 0\n    total_divisors = 0\n    for i in range(1, n + 1):\n        total_divisors += len(divisors(i))\n    return total_divisors\n\ndef divisors(num):\n    divs = []\n    for i in range(1, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            divs.append(i)\n            if num // i != i:\n                divs.append(num // i)\n    return divs\n\ndef divisor_sum(n: int) -> int:\n    if n <= 0:\n        return 0\n    sqrt_n = int(math.sqrt(n))\n    total = 0\n    for x in range(1, sqrt_n + 1):\n        total += n // x\n    total -= sqrt_n * sqrt_n\n    total += sqrt_n\n    return total", "import math\n\ndef count_divisors(n: int) -> int:\n\n    def divisor_count(x):\n        \"\"\"Helper function to calculate the number of divisors for a given number x.\"\"\"\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 2\n                if i * i == x:\n                    count -= 1\n        return count\n    S = 0\n    for i in range(1, n + 1):\n        S += divisor_count(i)\n    return S"], "requirement": [], "outputs": "[[1], [10], [27], [66], [207], [482], [7069], [93668], [1166750], 'Timeout', 'Timeout', 'Timeout', [0], [0], ['TypeError'], ['TypeError']]", "probability": 0.24, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n\n    def S(k):\n        sqrt_k = int(math.sqrt(k))\n        total_pairs = sum((k // m for m in range(1, sqrt_k + 1))) - sqrt_k ** 2\n        total_pairs += sqrt_k\n        total_pairs += sum((k // n for n in range(sqrt_k + 1, k // (sqrt_k + 1) + 1)))\n        return total_pairs\n    return S(n)", "import math\n\ndef count_divisors(n: int) -> int:\n    if n == 1:\n        return 1\n    S = 0\n    for i in range(1, math.isqrt(n) + 1):\n        S += n // i\n    S -= math.isqrt(n) * math.isqrt(n)\n    S += math.isqrt(n)\n    return S"], "requirement": [], "outputs": "[[1], [5], [12], [29], [86], [201], [3085], [41934], [533763], [6486991], [6486017], 'Timeout', ['ValueError'], [0], ['TypeError'], ['TypeError']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    S = 0\n    for i in range(1, n + 1):\n        S += n // i\n    return S", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers from 1 to n.\n    \n    Args:\n        n (int): The upper limit natural number.\n        \n    Returns:\n        int: The sum of the number of divisors from 1 to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    total_divisors_sum = 0\n    for i in range(1, n + 1):\n        total_divisors_sum += n // i\n    return total_divisors_sum", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers up to n.\n\n    Args:\n        n (int): The upper limit for calculating the sum of the number of divisors.\n\n    Returns:\n        int: The sum of the number of divisors for all natural numbers up to n.\n    \"\"\"\n    S = 0\n    for i in range(1, n + 1):\n        S += n // i\n    return S", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all numbers from 1 to n.\"\"\"\n    if n <= 0:\n        return 0\n    total_divisors = 0\n    for i in range(1, n + 1):\n        total_divisors += n // i\n    return total_divisors", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers less than or equal to n.\"\"\"\n    S = 0\n    for i in range(1, n + 1):\n        S += n // i\n    return S", "import math\n\ndef count_divisors(n: int) -> int:\n    S = 0\n    for i in range(1, n + 1):\n        S += n // i\n    return S", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculates the sum of the number of divisors for all natural numbers up to n.\"\"\"\n    total_divisors = 0\n    for i in range(1, n + 1):\n        divisors_for_i = n // i\n        total_divisors += divisors_for_i\n    return total_divisors", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers up to n.\"\"\"\n    total_divisors = 0\n    for i in range(1, n + 1):\n        total_divisors += n // i\n    return total_divisors", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the number of divisors for all natural numbers from 1 to n.\n    \n    Args:\n    n (int): The upper limit of natural numbers to consider. Must be greater than zero and not greater than 999,999,999,999,999.\n    \n    Returns:\n    int: The sum of the number of divisors for all natural numbers from 1 to n.\n    \"\"\"\n    total_divisors = 0\n    for i in range(1, n + 1):\n        total_divisors += n // i\n    return total_divisors", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculates the sum of the number of divisors for all natural numbers up to n.\n    \n    Args:\n        n (int): The upper limit of natural numbers to calculate divisors for.\n        \n    Returns:\n        int: The sum of the number of divisors for all natural numbers up to n.\n    \"\"\"\n    if n < 1:\n        return 0\n    S = 0\n    for i in range(1, n + 1):\n        S += n // i\n    return S", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers less than or equal to n.\"\"\"\n    S = 0\n    for i in range(1, n + 1):\n        S += n // i\n    return S", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the number of divisors for all natural numbers up to n.\n    \n    Args:\n    n (int): The upper limit, where 0 < n <= 999,999,999,999,999.\n    \n    Returns:\n    int: The sum of the number of divisors for all natural numbers up to n.\n    \"\"\"\n    sum_of_divisors = 0\n    for i in range(1, n + 1):\n        sum_of_divisors += n // i\n    return sum_of_divisors", "import math\n\ndef count_divisors(n: int) -> int:\n\n    def d(x):\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 2 if i * i != x else 1\n        return count\n    total_sum = 0\n    for i in range(1, n + 1):\n        total_sum += n // i\n    return total_sum", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers up to n.\n    \n    Args:\n        n (int): The upper limit of the range to calculate the sum of divisors.\n        \n    Returns:\n        int: The sum of the number of divisors for all numbers from 1 to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    S = 0\n    for i in range(1, n + 1):\n        S += n // i\n    return S", "import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the number of divisors for all natural numbers up to n.\n    \n    Args:\n    n (int): The upper limit for calculating the sum of divisors.\n    \n    Returns:\n    int: The sum of the number of divisors for all natural numbers up to n.\n    \"\"\"\n    S = 0\n    for i in range(1, n + 1):\n        S += n // i\n    return S"], "requirement": [], "outputs": "[[1], [10], [27], [66], [207], [482], [7069], [93668], [1166750], [13969985], [13970034], 'Timeout', [0], [0], ['TypeError'], ['TypeError']]", "probability": 0.3, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the sum of the number of divisors for all natural numbers up to n.\n    \n    Args:\n        n (int): The upper limit of the range to calculate the sum of divisors for.\n        \n    Returns:\n        int: The sum of the number of divisors for all natural numbers up to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    total_divisors = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        total_divisors += n // i\n    sqrt_n = int(math.sqrt(n))\n    total_divisors -= sqrt_n * (sqrt_n - 1) // 2\n    return total_divisors"], "requirement": [], "outputs": "[[1], [6], [15], [35], [107], [246], [3550], [46884], [583533], [6985492], [6985517], 'Timeout', [0], [0], [1.0], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"\n    Calculates the sum of the number of divisors for all natural numbers up to n.\n    \n    Args:\n        n (int): The upper limit of natural numbers to consider.\n        \n    Returns:\n        int: The sum of the number of divisors for all natural numbers up to n.\n    \"\"\"\n    if n == 1:\n        return 1\n    sqrt_n = int(math.sqrt(n))\n    total_sum = 0\n    for i in range(1, sqrt_n + 1):\n        total_sum += n // i\n    if sqrt_n * sqrt_n == n:\n        total_sum -= sqrt_n\n    for i in range(1, sqrt_n):\n        total_sum += sqrt_n * (sqrt_n // i - 1)\n    total_sum -= sqrt_n * (sqrt_n - 1) // 2\n    return total_sum"], "requirement": [], "outputs": "[[1], [8], [21], [51], [170], [406], [6092], [84984], [1075545], [13033438], [13053517], 'Timeout', ['ValueError'], [0], [1.0], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculates the sum of the number of divisors for all natural numbers up to n.\"\"\"\n    total_divisors = 0\n    for i in range(1, math.isqrt(n) + 1):\n        total_divisors += n // i\n    total_divisors -= math.isqrt(n)\n    total_divisors += math.isqrt(n)\n    return total_divisors", "import math\n\ndef count_divisors(n: int) -> int:\n    S = 0\n    for i in range(1, math.isqrt(n) + 1):\n        S += n // i\n    for i in range(1, math.isqrt(n) + 1):\n        if i * i <= n:\n            S += 1\n    S -= math.isqrt(n)\n    return S"], "requirement": [], "outputs": "[[1], [7], [18], [41], [128], [291], [4015], [51834], [633303], [7483993], [7485017], 'Timeout', ['ValueError'], [0], ['TypeError'], ['TypeError']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    limit = int(math.sqrt(n)) + 1\n    divisors = [1] * limit\n    for i in range(2, limit):\n        for j in range(i, limit, i):\n            divisors[j] += 1\n    total = 0\n    for i in range(1, limit):\n        total += n // i * divisors[i]\n    for i in range(1, limit):\n        square = i * i\n        if square > n:\n            break\n        total -= divisors[i]\n    return total"], "requirement": [], "outputs": "[[0], [6], [21], [59], [218], [567], [10230], [163902], [2367642], [32291964], [32308124], 'Timeout', ['ValueError'], [0], [0.0], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculates the sum of the number of divisors for all numbers from 1 to n.\n    \n    Args:\n        n (int): The upper limit of the range to calculate the sum of divisors.\n        \n    Returns:\n        int: The sum of the number of divisors for all numbers from 1 to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n\n    def S(k):\n        sqrt_k = int(math.sqrt(k))\n        result = 0\n        for i in range(1, sqrt_k + 1):\n            result += k // i\n        result -= sqrt_k * (sqrt_k - 1) // 2\n        for i in range(1, sqrt_k + 1):\n            result += k // i\n        return result - sqrt_k * sqrt_k\n    return S(n)"], "requirement": [], "outputs": "[[1], [9], [24], [60], [186], [437], [6604], [88718], [1116980], [13471484], [13470534], 'Timeout', [0], [0], [1.0], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"\n    Calculates the sum of the number of divisors for all natural numbers from 1 to n.\n    \n    Args:\n        n (int): The upper limit of the range of natural numbers. (1 <= n <= 999,999,999,999,999)\n    \n    Returns:\n        int: The sum of the number of divisors for all natural numbers from 1 to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    result = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        result += n // i\n    result -= sqrt_n * (sqrt_n - 1) // 2\n    result += sqrt_n\n    return result"], "requirement": [], "outputs": "[[1], [8], [18], [39], [114], [256], [3581], [46984], [583849], [6986491], [6986517], 'Timeout', [0], [0], [2.0], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculate the total number of divisors for all natural numbers less or equal to n.\"\"\"\n\n    def divisors_count(x):\n        \"\"\"Helper function to count the number of divisors of x.\"\"\"\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 2\n                if i * i == x:\n                    count -= 1\n        return count\n    sqrt_n = int(math.sqrt(n))\n    divisors = [divisors_count(i) for i in range(1, sqrt_n + 1)]\n    total_divisors = 0\n    for i in range(1, sqrt_n + 1):\n        total_divisors += n // i * divisors[i - 1]\n    for i in range(sqrt_n + 1, n + 1):\n        total_divisors += n // i\n    return total_divisors"], "requirement": [], "outputs": "[[1], [12], [35], [92], [313], [785], [13397], [206218], [2902962], [38785009], [38800210], 'Timeout', ['ValueError'], [0], ['TypeError'], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculates the sum of the number of divisors for all numbers from 1 to n.\n    \n    Args:\n        n (int): The upper limit of the range to calculate the sum of divisors.\n        \n    Returns:\n        int: The sum of the number of divisors for all numbers from 1 to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    def S(k):\n        total = 0\n        sqrt_k = int(math.sqrt(k))\n        for i in range(1, sqrt_k + 1):\n            total += k // i\n        total *= 2\n        total -= sqrt_k * sqrt_k\n        return total\n    return S(n)"], "requirement": [], "outputs": "[[1], [10], [27], [66], [207], [482], [7069], [93668], [1166750], [13969985], [13970034], 'Timeout', [0], [0], [1.0], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Calculates the sum of the number of divisors for all natural numbers up to n.\"\"\"\n\n    def d(x):\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 2 if i * i != x else 1\n        return count\n    S = [0] * (n + 1)\n    S[1] = 1\n    for i in range(1, n + 1):\n        S[i] = S[i - 1] + d(i)\n    return S[n]\n\ndef optimized_count_divisors(n: int) -> int:\n    \"\"\"Calculates the sum of the number of divisors for all natural numbers up to n using an optimized approach.\"\"\"\n    S = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        S += n // i\n    root = int(math.sqrt(n))\n    S -= root * (root - 1) // 2\n    return S * 2 - root"], "requirement": [], "outputs": "[[1], [10], [27], [66], [207], [482], [7069], [93668], [1166750], 'Timeout', 'Timeout', ['MemoryError'], ['IndexError'], ['IndexError'], ['TypeError'], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    \"\"\"Computes the sum of the number of divisors for each integer from 1 to n.\n    \n    Args:\n        n (int): The upper limit for calculating the sum of divisors.\n        \n    Returns:\n        int: The sum of the number of divisors for all numbers from 1 to n.\n    \"\"\"\n    result = 0\n    sqrt_k = int(math.sqrt(n))\n    for m in range(1, sqrt_k + 1):\n        result += n // m\n    for m in range(1, sqrt_k + 1):\n        result += n // (m + 1) if n // (m + 1) > 0 else 0\n    result -= sqrt_k\n    return result"], "requirement": [], "outputs": "[[0], [8], [25], [62], [205], [481], [7030], [93667], [1166605], [13967987], [13970033], 'Timeout', ['ValueError'], [0], [0.0], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n\n    def S(k):\n        sqrt_k = int(math.sqrt(k))\n        result = 0\n        for i in range(1, sqrt_k + 1):\n            result += k // i\n        result *= 2\n        result -= sqrt_k * sqrt_k\n        return result\n    return S(n)"], "requirement": [], "outputs": "[[1], [10], [27], [66], [207], [482], [7069], [93668], [1166750], [13969985], [13970034], 'Timeout', ['ValueError'], [0], [1.0], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef count_divisors(n: int) -> int:\n    sqrt_n = int(math.sqrt(n))\n    total_count = 0\n    for i in range(1, sqrt_n + 1):\n        total_count += n // i\n    total_count *= 2\n    total_count -= sqrt_n\n    return total_count - sqrt_n * (sqrt_n + 1) // 2"], "requirement": [], "outputs": "[[0], [9], [27], [68], [221], [517], [7503], [98518], [1216204], [14467487], [14468534], 'Timeout', ['ValueError'], [0], [0.0], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import isqrt\n\ndef count_divisors(n: int) -> int:\n    S = 0\n    for i in range(1, n + 1):\n        S += i // 1\n    S = 2 * sum((n // k for k in range(1, isqrt(n) + 1))) - isqrt(n) ** 2\n    return S"], "requirement": [], "outputs": "[[1], [10], [27], [66], [207], [482], [7069], [93668], [1166750], [13969985], [13970034], 'Timeout', ['ValueError'], [0], ['TypeError'], ['TypeError']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 2.3091491385915783, "llm_generated_inputs": "[[1], [5], [10], [20], [50], [100], [1000], [10000], [100000], [999999], [1000000], [999999999999999], [-1], [0], [1.5], ['100']]", "input_output_examples": "[[[1], [2], [3], [4], [5]], [[1], [3], [5], [8], [10]]]", "at_least_one_align": false}, "entry_point": "count_divisors", "ground_truth": -1}
{"task_id": "TACO_lite/32", "requirement": "def bumps(road: str) -> str:\n\"\"\"Your car is old, it breaks easily. The shock absorbers are gone and you think it can handle about 15 more bumps before it dies totally.\n\nUnfortunately for you, your drive is very bumpy! Given a string showing either flat road (\"\\_\") or bumps (\"n\"), work out if you make it home safely. 15 bumps or under, return \"Woohoo!\", over 15 bumps return \"Car Dead\".\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'", "def bumps(road: str) -> str:\n    bump_count = road.count('n')\n    if bump_count <= 15:\n        return 'Woohoo!'\n    else:\n        return 'Car Dead'"], "requirement": [], "outputs": "[['Woohoo!'], ['Woohoo!'], ['Woohoo!'], ['Car Dead'], ['Car Dead'], ['Woohoo!'], ['Car Dead'], ['Woohoo!'], ['Car Dead'], ['Woohoo!'], ['Woohoo!'], ['Car Dead'], ['Woohoo!'], ['Woohoo!'], ['Woohoo!']]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[['____________________'], ['n_______________________n'], ['nnnnnnnnnnnnnnn__________'], ['nnnnnnnnnnnnnnnn_________'], ['nnnnnnnnnnnnnnnnn________'], ['nnn_n_n_nn_nnn__nnn______'], ['nnnnnnnnnnnnnnnnnn_______'], [''], ['nnnnnnnnnnnnnnnnnnnn_____'], ['____________________n_n_n'], ['n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_'], ['n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n'], ['__________________________'], ['n_________________________'], ['_________________________n']]", "input_output_examples": "[[['____n_n_n_n_n_n_n_n_n_n_n_n_n_n_n'], ['nnnnnnnnnnnnnnn']], [['Woohoo!'], ['Car Dead']]]", "at_least_one_align": false}, "entry_point": "bumps", "ground_truth": 0}
{"task_id": "TACO_lite/33", "requirement": "from typing import List\nfrom typing import Union\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n\"\"\"Write Cara a function `charcheck()` with the arguments:\n\n- `\"text\"`: a string containing Cara's answer for the question\n- `\"max\"`: a number equal to the maximum number of characters allowed in the answer\n- `\"spaces\"`: a boolean which is `True` if spaces are included in the character count and `False` if they are not\n\nThe function `charcheck()` should return an array: `[True, \"Answer\"]` , where `\"Answer\"` is equal to the original text, if Cara's answer is short enough.\n\nIf her answer `\"text\"` is too long, return an array: `[False, \"Answer\"]`. \nThe second element should be the original `\"text\"` string truncated to the length of the limit.\n\nWhen the `\"spaces\"` argument is `False`, you should remove the spaces from the `\"Answer\"`.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx]\n    return [len(text) <= mx, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx]\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx]\n    is_within_limit = len(text) <= mx\n    return [is_within_limit, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx]\n    is_within_limit = len(text) <= mx\n    return [is_within_limit, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx]\n    is_valid = len(text) <= mx\n    return [is_valid, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx]\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n        text = text_no_spaces\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx]\n    is_within_limit = len(text) <= mx\n    return [is_within_limit, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) > mx:\n        text = text[:mx]\n        return [False, text]\n    else:\n        return [True, text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx]\n    is_within_limit = len(text) <= mx\n    return [is_within_limit, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) > mx:\n        truncated_text = text[:mx]\n        return [False, truncated_text]\n    else:\n        return [True, text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx]\n    is_within_limit = len(text) <= mx\n    return [is_within_limit, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    \"\"\"\n    Checks if the text is within the character limit and formats it based on the spaces flag.\n    \n    Args:\n    - text (str): The input string.\n    - mx (int): Maximum number of characters allowed in the answer.\n    - spaces (bool): If True, spaces are counted; if False, spaces are removed.\n    \n    Returns:\n    - List[Union[bool, str]]: A list containing a boolean indicating if the text is within limits \n                               and the formatted text.\n    \"\"\"\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx]\n    is_within_limit = len(text) <= mx\n    return [is_within_limit, truncated_text]"], "requirement": [], "outputs": "[[[True, 'hello world']], [[False, 'hello']], [[True, 'helloworld']], [[False, 'hello']], [[False, 'abc def g']], [[False, 'abc def ']], [[True, 'abcdefghi']], [[False, 'abcdefgh']], [[True, '']], [[True, '']], [[False, 'a b c d e f g h i j k l m ']], [[True, 'abcdefghijklmnopqrstuvwxyz']], [[True, '   leading and trailing spaces   ']], [[False, '   leading and trailing spaces']], [[True, 'leadingandtrailingspaces']], [[True, 'singleword']], [[False, 'singleword with many']], [[False, 'singlewordwithmanych']], [[True, '     ']], [[True, '']]]", "probability": 0.7, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx] if len(text) > mx else text\n    is_within_limit = len(truncated_text) <= mx\n    return [is_within_limit, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text = text.replace(' ', '')\n    truncated_text = text[:mx] if len(text) > mx else text\n    is_within_limit = len(truncated_text) <= mx\n    return [is_within_limit, truncated_text]"], "requirement": [], "outputs": "[[[True, 'hello world']], [[True, 'hello']], [[True, 'helloworld']], [[True, 'hello']], [[True, 'abc def g']], [[True, 'abc def ']], [[True, 'abcdefghi']], [[True, 'abcdefgh']], [[True, '']], [[True, '']], [[True, 'a b c d e f g h i j k l m ']], [[True, 'abcdefghijklmnopqrstuvwxyz']], [[True, '   leading and trailing spaces   ']], [[True, '   leading and trailing spaces']], [[True, 'leadingandtrailingspaces']], [[True, 'singleword']], [[True, 'singleword with many']], [[True, 'singlewordwithmanych']], [[True, '     ']], [[True, '']]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    original_text = text\n    if not spaces:\n        text = text.replace(' ', '')\n    if len(text) <= mx:\n        return [True, original_text]\n    else:\n        truncated_text = original_text[:mx]\n        if not spaces:\n            truncated_text = truncated_text.replace(' ', '')\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    check_text = text.replace(' ', '') if not spaces else text\n    if len(check_text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        if not spaces:\n            truncated_text = truncated_text.replace(' ', '')\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        count_text = text.replace(' ', '')\n    else:\n        count_text = text\n    if len(count_text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        if not spaces:\n            truncated_text = truncated_text.replace(' ', '')\n        return [False, truncated_text]"], "requirement": [], "outputs": "[[[True, 'hello world']], [[False, 'hello']], [[True, 'hello world']], [[False, 'hello']], [[False, 'abc def g']], [[False, 'abc def ']], [[True, 'abc def ghi']], [[False, 'abcdef']], [[True, '']], [[True, '']], [[False, 'a b c d e f g h i j k l m ']], [[True, 'a b c d e f g h i j k l m n o p q r s t u v w x y z']], [[True, '   leading and trailing spaces   ']], [[False, '   leading and trailing spaces']], [[True, '   leading and trailing spaces   ']], [[True, 'singleword']], [[False, 'singleword with many']], [[False, 'singlewordwithmany']], [[True, '     ']], [[True, '     ']]]", "probability": 0.06, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n    else:\n        text_no_spaces = text\n    if len(text_no_spaces) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx] if spaces else text_no_spaces[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n    else:\n        text_no_spaces = text\n    if len(text_no_spaces) > mx:\n        truncated_text = text_no_spaces[:mx]\n        return [False, truncated_text]\n    else:\n        return [True, text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n    else:\n        text_no_spaces = text\n    if len(text_no_spaces) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx] if spaces else text_no_spaces[:mx]\n        return [False, truncated_text]"], "requirement": [], "outputs": "[[[True, 'hello world']], [[False, 'hello']], [[True, 'hello world']], [[False, 'hello']], [[False, 'abc def g']], [[False, 'abc def ']], [[True, 'abc def ghi']], [[False, 'abcdefgh']], [[True, '']], [[True, '']], [[False, 'a b c d e f g h i j k l m ']], [[True, 'a b c d e f g h i j k l m n o p q r s t u v w x y z']], [[True, '   leading and trailing spaces   ']], [[False, '   leading and trailing spaces']], [[True, '   leading and trailing spaces   ']], [[True, 'singleword']], [[False, 'singleword with many']], [[False, 'singlewordwithmanych']], [[True, '     ']], [[True, '     ']]]", "probability": 0.06, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n    else:\n        text_no_spaces = text\n    if len(text_no_spaces) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n        original_text = text\n        text = text_no_spaces\n    if len(text) <= mx:\n        return [True, original_text if not spaces else text]\n    else:\n        truncated_text = original_text[:mx] if not spaces else text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n    else:\n        text_no_spaces = text\n    if len(text_no_spaces) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n        modified_text = text_no_spaces\n    else:\n        modified_text = text\n    if len(modified_text) <= mx:\n        return [True, text]\n    else:\n        truncated_text = text[:mx]\n        return [False, truncated_text]"], "requirement": [], "outputs": "[[[True, 'hello world']], [[False, 'hello']], [[True, 'hello world']], [[False, 'hello']], [[False, 'abc def g']], [[False, 'abc def ']], [[True, 'abc def ghi']], [[False, 'abc def ']], [[True, '']], [[True, '']], [[False, 'a b c d e f g h i j k l m ']], [[True, 'a b c d e f g h i j k l m n o p q r s t u v w x y z']], [[True, '   leading and trailing spaces   ']], [[False, '   leading and trailing spaces']], [[True, '   leading and trailing spaces   ']], [[True, 'singleword']], [[False, 'singleword with many']], [[False, 'singleword with many']], [[True, '     ']], [[True, '     ']]]", "probability": 0.08, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n    else:\n        text_no_spaces = text\n    if len(text_no_spaces) <= mx:\n        return [True, text]\n    else:\n        if not spaces:\n            truncated_text = text[:mx + text[:mx].count(' ')]\n        else:\n            truncated_text = text[:mx]\n        return [False, truncated_text]", "from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n        truncated_text = text_no_spaces[:mx]\n    else:\n        truncated_text = text[:mx]\n    if spaces and len(text) <= mx or (not spaces and len(text_no_spaces) <= mx):\n        return [True, text]\n    else:\n        if not spaces:\n            index = 0\n            final_text = list(truncated_text)\n            for i in range(len(text)):\n                if index >= len(truncated_text):\n                    break\n                if text[i] != ' ':\n                    index += 1\n                else:\n                    final_text.insert(index, ' ')\n                    index += 1\n            truncated_text = ''.join(final_text)\n        return [False, truncated_text]"], "requirement": [], "outputs": "[[[True, 'hello world']], [[False, 'hello']], [[True, 'hello world']], [[False, 'hello']], [[False, 'abc def g']], [[False, 'abc def ']], [[True, 'abc def ghi']], [[False, 'abc def gh']], [[True, '']], [[True, '']], [[False, 'a b c d e f g h i j k l m ']], [[True, 'a b c d e f g h i j k l m n o p q r s t u v w x y z']], [[True, '   leading and trailing spaces   ']], [[False, '   leading and trailing spaces']], [[True, '   leading and trailing spaces   ']], [[True, 'singleword']], [[False, 'singleword with many']], [[False, 'singleword with manych']], [[True, '     ']], [[True, '     ']]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List, Union\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n    if not spaces:\n        text_no_spaces = text.replace(' ', '')\n    else:\n        text_no_spaces = text\n    if len(text_no_spaces) <= mx:\n        return [True, text]\n    else:\n        if spaces:\n            truncated_text = text[:mx]\n        else:\n            truncated_text = text[:mx + text.count(' ')]\n        return [False, truncated_text]"], "requirement": [], "outputs": "[[[True, 'hello world']], [[False, 'hello']], [[True, 'hello world']], [[False, 'hello ']], [[False, 'abc def g']], [[False, 'abc def ']], [[True, 'abc def ghi']], [[False, 'abc def gh']], [[True, '']], [[True, '']], [[False, 'a b c d e f g h i j k l m ']], [[True, 'a b c d e f g h i j k l m n o p q r s t u v w x y z']], [[True, '   leading and trailing spaces   ']], [[False, '   leading and trailing spaces']], [[True, '   leading and trailing spaces   ']], [[True, 'singleword']], [[False, 'singleword with many']], [[False, 'singleword with manych']], [[True, '     ']], [[True, '     ']]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.1250905644109965, "llm_generated_inputs": "[['hello world', 11, True], ['hello world', 5, True], ['hello world', 10, False], ['hello world', 5, False], ['abc def ghi', 9, True], ['abc def ghi', 8, True], ['abc def ghi', 9, False], ['abc def ghi', 8, False], ['', 10, True], ['', 10, False], ['a b c d e f g h i j k l m n o p q r s t u v w x y z', 26, True], ['a b c d e f g h i j k l m n o p q r s t u v w x y z', 26, False], ['   leading and trailing spaces   ', 38, True], ['   leading and trailing spaces   ', 30, True], ['   leading and trailing spaces   ', 30, False], ['singleword', 11, True], ['singleword with manycharacters', 20, True], ['singleword with manycharacters', 20, False], ['     ', 5, True], ['     ', 5, False]]", "input_output_examples": "[[[('Cara Hertz', 10, True)], [('Cara Hertz', 9, False)], [('Cara Hertz', 5, True)], [('Cara Hertz', 5, False)]], [[[True, 'Cara Hertz']], [[True, 'CaraHertz']], [[False, 'Cara ']], [[False, 'CaraH']]]]", "at_least_one_align": false}, "entry_point": "charcheck", "ground_truth": -1}
{"task_id": "TACO_lite/34", "requirement": "def convert_recipe(recipe: str) -> str:\n\"\"\"Mary wrote a recipe book and is about to publish it, but because of a new European law, she needs to update and include all measures in grams.\n\nGiven all the measures in tablespoon (`tbsp`) and in teaspoon (`tsp`), considering `1 tbsp = 15g` and `1 tsp = 5g`, append to the end of the measurement the biggest equivalent integer (rounding up).\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    words = recipe.split()\n    converted_words = []\n    for word in words:\n        if word.endswith('tbsp'):\n            amount = float(word.replace('tbsp', '').strip())\n            grams = ceil(amount * 15)\n            converted_words.append(f'{word} ({grams}g)')\n        elif word.endswith('tsp'):\n            amount = float(word.replace('tsp', '').strip())\n            grams = ceil(amount * 5)\n            converted_words.append(f'{word} ({grams}g)')\n        else:\n            converted_words.append(word)\n    return ' '.join(converted_words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = float(word[:-4])\n            grams = ceil(amount * 15)\n            words[i] += f' ({grams}g)'\n        elif word.endswith('tsp'):\n            amount = float(word[:-3])\n            grams = ceil(amount * 5)\n            words[i] += f' ({grams}g)'\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = float(word.replace('tbsp', '').strip())\n            grams = ceil(amount * 15)\n            words[i] += f' ({grams}g)'\n        elif word.endswith('tsp'):\n            amount = float(word.replace('tsp', '').strip())\n            grams = ceil(amount * 5)\n            words[i] += f' ({grams}g)'\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in a recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    \n    Args:\n    recipe (str): A string containing the recipe with measurements in tbsp and tsp.\n    \n    Returns:\n    str: The recipe with measurements converted to grams, rounded up to the nearest integer.\n    \"\"\"\n    words = recipe.split()\n    converted_words = []\n    for word in words:\n        if word.endswith('tbsp'):\n            value = float(word[:-4])\n            grams = ceil(value * 15)\n            converted_words.append(f'{word} ({grams}g)')\n        elif word.endswith('tsp'):\n            value = float(word[:-3])\n            grams = ceil(value * 5)\n            converted_words.append(f'{word} ({grams}g)')\n        else:\n            converted_words.append(word)\n    return ' '.join(converted_words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    words = recipe.split()\n    converted_words = []\n    for word in words:\n        if word.endswith('tbsp'):\n            measure = int(word[:-4])\n            grams = ceil(measure * 15)\n            converted_words.append(f'{word} ({grams}g)')\n        elif word.endswith('tsp'):\n            measure = int(word[:-3])\n            grams = ceil(measure * 5)\n            converted_words.append(f'{word} ({grams}g)')\n        else:\n            converted_words.append(word)\n    return ' '.join(converted_words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    words = recipe.split()\n    converted_words = []\n    for word in words:\n        if word.endswith('tbsp'):\n            amount = float(word[:-4])\n            grams = ceil(amount * 15)\n            converted_words.append(f'{word} ({grams}g)')\n        elif word.endswith('tsp'):\n            amount = float(word[:-3])\n            grams = ceil(amount * 5)\n            converted_words.append(f'{word} ({grams}g)')\n        else:\n            converted_words.append(word)\n    return ' '.join(converted_words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    \n    Args:\n        recipe (str): The recipe string containing measurements in tbsp and tsp.\n        \n    Returns:\n        str: The updated recipe string with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = float(word.split('tbsp')[0])\n            grams = ceil(amount * 15)\n            words[i] = f'{word} ({grams}g)'\n        elif word.endswith('tsp'):\n            amount = float(word.split('tsp')[0])\n            grams = ceil(amount * 5)\n            words[i] = f'{word} ({grams}g)'\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    1 tbsp = 15g and 1 tsp = 5g. The function appends the biggest equivalent integer (rounding up).\n    \n    Args:\n    recipe (str): The original recipe string containing measurements.\n    \n    Returns:\n    str: The updated recipe string with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = float(word.split('tbsp')[0])\n            grams = ceil(amount * 15)\n            words[i] += f' ({grams}g)'\n        elif word.endswith('tsp'):\n            amount = float(word.split('tsp')[0])\n            grams = ceil(amount * 5)\n            words[i] += f' ({grams}g)'\n    return ' '.join(words)\nrecipe = 'Mix 2 tbsp of sugar, 3 tsp of cinnamon, and 1 tbsp of butter'", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"Converts the measurements in a recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    \n    Args:\n        recipe (str): The original recipe string containing measurements in tbsp and tsp.\n        \n    Returns:\n        str: The updated recipe string with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    converted_words = []\n    for word in words:\n        if word.endswith('tbsp'):\n            num = float(word.replace('tbsp', '').strip())\n            grams = ceil(num * 15)\n            converted_words.append(f'{num} tbsp ({grams}g)')\n        elif word.endswith('tsp'):\n            num = float(word.replace('tsp', '').strip())\n            grams = ceil(num * 5)\n            converted_words.append(f'{num} tsp ({grams}g)')\n        else:\n            converted_words.append(word)\n    return ' '.join(converted_words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    \n    Args:\n        recipe (str): The recipe string containing measurements in tbsp and tsp.\n        \n    Returns:\n        str: The updated recipe string with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    converted = []\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = float(word.split('tbsp')[0])\n            grams = ceil(amount * 15)\n            converted.append(f'{amount} tbsp ({grams}g)')\n        elif word.endswith('tsp'):\n            amount = float(word.split('tsp')[0])\n            grams = ceil(amount * 5)\n            converted.append(f'{amount} tsp ({grams}g)')\n        else:\n            converted.append(word)\n    return ' '.join(converted)\nrecipe = 'Mix 2 tbsp of sugar, 1.5 tsp of baking soda, and 4 tbsp of butter.'", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in a recipe from tablespoons (tbsp) and teaspoons (tsp) to grams (g).\n    1 tbsp = 15g, 1 tsp = 5g. The function rounds up to the nearest integer.\n    \n    :param recipe: A string containing the recipe with measurements.\n    :return: A string with the updated recipe including gram measurements.\n    \"\"\"\n    words = recipe.split()\n    converted_words = []\n    for word in words:\n        if word.endswith('tbsp'):\n            amount = float(word.replace('tbsp', '').strip())\n            grams = ceil(amount * 15)\n            converted_words.append(f'{word} ({grams}g)')\n        elif word.endswith('tsp'):\n            amount = float(word.replace('tsp', '').strip())\n            grams = ceil(amount * 5)\n            converted_words.append(f'{word} ({grams}g)')\n        else:\n            converted_words.append(word)\n    return ' '.join(converted_words)"], "requirement": [], "outputs": "[['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], [''], ['invalid input']]", "probability": 0.22, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    words = recipe.split()\n    converted_words = []\n    measures = {'tbsp': 15, 'tsp': 5}\n    for word in words:\n        if word in measures:\n            amount = measures[word]\n            quantity = float(converted_words[-1].replace(',', '.'))\n            grams = quantity * amount\n            converted_words.append(f'{ceil(grams)}g')\n        else:\n            converted_words.append(word)\n    return ' '.join(converted_words)"], "requirement": [], "outputs": "[['2 30g sugar'], ['3 15g salt'], ['10 150g flour'], ['7 35g baking powder'], ['1 15g honey, 2 10g lemon juice'], ['0 0g water'], ['0 0g pepper'], ['1.5 23g butter'], ['2.8 14g vanilla extract'], ['-1 -15g cocoa'], ['-3 -15g cinnamon'], ['25 375g milk'], ['47 235g oil'], [''], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    unit_to_grams = {'tbsp': 15, 'tsp': 5}\n    words = recipe.split()\n    converted_recipe = []\n    for i, word in enumerate(words):\n        if word in unit_to_grams:\n            prev_word = words[i - 1]\n            try:\n                value = float(prev_word)\n                grams = ceil(value * unit_to_grams[word])\n                converted_recipe.append(f'{word} ({grams}g)')\n            except ValueError:\n                converted_recipe.append(word)\n        else:\n            converted_recipe.append(word)\n    return ' '.join(converted_recipe)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"Converts measurements in a recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    \n    Args:\n        recipe (str): A string containing the recipe with measurements in tbsp and tsp.\n        \n    Returns:\n        str: The recipe string with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith(('tbsp', 'tsp')):\n            try:\n                value = float(words[i - 1])\n                if 'tbsp' in word:\n                    grams = ceil(value * 15)\n                elif 'tsp' in word:\n                    grams = ceil(value * 5)\n                words[i] = f'{word} ({grams}g)'\n            except ValueError:\n                continue\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"Converts measurements in a recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    \n    Args:\n        recipe (str): The recipe string containing measurements in tbsp and tsp.\n\n    Returns:\n        str: The updated recipe string with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith(('tbsp', 'tsp')):\n            try:\n                value = float(words[i - 1])\n                if word.endswith('tbsp'):\n                    grams = ceil(value * 15)\n                elif word.endswith('tsp'):\n                    grams = ceil(value * 5)\n                words[i] = f'{word} ({grams}g)'\n            except ValueError:\n                continue\n    return ' '.join(words)", "import math\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    1 tbsp = 15g, 1 tsp = 5g. Rounds up to the nearest gram.\n    \n    Args:\n        recipe (str): The original recipe text with measurements.\n\n    Returns:\n        str: The updated recipe text with measurements in grams.\n    \"\"\"\n    conversion_table = {'tbsp': 15, 'tsp': 5}\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word in conversion_table:\n            quantity_str = words[i - 1]\n            if quantity_str.replace('.', '', 1).isdigit() or (quantity_str.startswith('-') and quantity_str[1:].replace('.', '', 1).isdigit()):\n                quantity = float(quantity_str)\n                grams = math.ceil(quantity * conversion_table[word])\n                words.insert(i + 1, f'({grams}g)')\n    return ' '.join(words)\nrecipe_example = 'Mix 2 tbsp of sugar, 3 tsp of salt, and 1.5 tbsp of oil.'"], "requirement": [], "outputs": "[['2 tbsp (30g) sugar'], ['3 tsp (15g) salt'], ['10 tbsp (150g) flour'], ['7 tsp (35g) baking powder'], ['1 tbsp (15g) honey, 2 tsp (10g) lemon juice'], ['0 tbsp (0g) water'], ['0 tsp (0g) pepper'], ['1.5 tbsp (23g) butter'], ['2.8 tsp (14g) vanilla extract'], ['-1 tbsp (-15g) cocoa'], ['-3 tsp (-15g) cinnamon'], ['25 tbsp (375g) milk'], ['47 tsp (235g) oil'], [''], ['invalid input']]", "probability": 0.08, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    1 tbsp = 15g, 1 tsp = 5g. Rounds up to the nearest integer.\n    \n    :param recipe: A string containing the recipe with measurements in tbsp and tsp.\n    :return: The modified recipe string with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = word[:-4]\n            try:\n                grams = ceil(float(amount) * 15)\n                words[i] += f' ({grams}g)'\n            except ValueError:\n                pass\n        elif word.endswith('tsp'):\n            amount = word[:-3]\n            try:\n                grams = ceil(float(amount) * 5)\n                words[i] += f' ({grams}g)'\n            except ValueError:\n                pass\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons and teaspoons to grams,\n    appending the largest equivalent integer (rounding up).\n\n    Args:\n        recipe (str): The original recipe string containing 'tbsp' and 'tsp'.\n\n    Returns:\n        str: The updated recipe with measurements in grams.\n    \"\"\"\n    words = recipe.split()\n    converted_words = []\n    for word in words:\n        if 'tbsp' in word:\n            try:\n                num = float(word.replace('tbsp', ''))\n                grams = ceil(num * 15)\n                converted_words.append(f'{word} ({grams}g)')\n            except ValueError:\n                converted_words.append(word)\n        elif 'tsp' in word:\n            try:\n                num = float(word.replace('tsp', ''))\n                grams = ceil(num * 5)\n                converted_words.append(f'{word} ({grams}g)')\n            except ValueError:\n                converted_words.append(word)\n        else:\n            converted_words.append(word)\n    return ' '.join(converted_words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts all the measures in the recipe from tablespoon (`tbsp`) and teaspoon (`tsp`) to grams.\n    Considering `1 tbsp = 15g` and `1 tsp = 5g`, append to the end of the measurement the biggest equivalent integer (rounding up).\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = word[:-len('tbsp')].strip()\n            if amount.replace('.', '', 1).isdigit():\n                grams = ceil(float(amount) * 15)\n                words[i] = f'{word} ({grams}g)'\n        elif word.endswith('tsp'):\n            amount = word[:-len('tsp')].strip()\n            if amount.replace('.', '', 1).isdigit():\n                grams = ceil(float(amount) * 5)\n                words[i] = f'{word} ({grams}g)'\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"Mary wrote a recipe book and is about to publish it, but because of a new European law, she needs to update and include all measures in grams.\n\n    Given all the measures in tablespoon (`tbsp`) and in teaspoon (`tsp`), considering `1 tbsp = 15g` and `1 tsp = 5g`, append to the end of the measurement the biggest equivalent integer (rounding up).\n    \"\"\"\n    words = recipe.split()\n    converted_words = []\n    for word in words:\n        if 'tbsp' in word:\n            try:\n                amount = float(word.split('tbsp')[0])\n                grams = ceil(amount * 15)\n                converted_words.append(f'{word} ({grams}g)')\n            except ValueError:\n                converted_words.append(word)\n        elif 'tsp' in word:\n            try:\n                amount = float(word.split('tsp')[0])\n                grams = ceil(amount * 5)\n                converted_words.append(f'{word} ({grams}g)')\n            except ValueError:\n                converted_words.append(word)\n        else:\n            converted_words.append(word)\n    return ' '.join(converted_words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    1 tbsp = 15g and 1 tsp = 5g. The function appends the biggest equivalent integer (rounding up).\n    \n    Args:\n    recipe (str): A string containing the recipe with measurements in tbsp and tsp.\n    \n    Returns:\n    str: The modified recipe with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = word[:-4]\n            if amount.replace('.', '', 1).isdigit():\n                grams = ceil(float(amount) * 15)\n                words[i] += f' ({grams}g)'\n        elif word.endswith('tsp'):\n            amount = word[:-3]\n            if amount.replace('.', '', 1).isdigit():\n                grams = ceil(float(amount) * 5)\n                words[i] += f' ({grams}g)'\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"Converts measurements in a recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    \n    Args:\n        recipe (str): A string containing the recipe with measurements in tbsp and tsp.\n        \n    Returns:\n        str: The recipe with measurements converted to grams and rounded up to the nearest integer.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = word[:-len('tbsp')]\n            if amount.replace('.', '', 1).isdigit():\n                grams = ceil(float(amount) * 15)\n                words[i] += f' ({grams}g)'\n        elif word.endswith('tsp'):\n            amount = word[:-len('tsp')]\n            if amount.replace('.', '', 1).isdigit():\n                grams = ceil(float(amount) * 5)\n                words[i] += f' ({grams}g)'\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"Converts all tablespoon (`tbsp`) and teaspoon (`tsp`) measurements in the recipe to grams, rounding up to the nearest integer.\n    \n    Args:\n        recipe (str): The recipe text containing measurements in tbsp and tsp.\n        \n    Returns:\n        str: The modified recipe text with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = word[:-len('tbsp')]\n            try:\n                grams = ceil(float(amount) * 15)\n                words[i] = f'{amount} tbsp ({grams}g)'\n            except ValueError:\n                pass\n        elif word.endswith('tsp'):\n            amount = word[:-len('tsp')]\n            try:\n                grams = ceil(float(amount) * 5)\n                words[i] = f'{amount} tsp ({grams}g)'\n            except ValueError:\n                pass\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in a recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    1 tbsp = 15g, 1 tsp = 5g. The function appends the closest higher integer equivalent in grams.\n    \n    :param recipe: A string containing the recipe with measurements in tbsp and tsp.\n    :return: A string with the updated recipe including gram measurements.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = word[:-len('tbsp')]\n            if amount.replace('.', '', 1).isdigit():\n                grams = ceil(float(amount) * 15)\n                words[i] += f' ({grams}g)'\n        elif word.endswith('tsp'):\n            amount = word[:-len('tsp')]\n            if amount.replace('.', '', 1).isdigit():\n                grams = ceil(float(amount) * 5)\n                words[i] += f' ({grams}g)'\n    return ' '.join(words)\nrecipe = 'Mix 2 tbsp of sugar, 1.5 tsp of salt, and 0.75 tbsp of cinnamon.'", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"Mary wrote a recipe book and is about to publish it, but because of a new European law, she needs to update and include all measures in grams.\n\n    Given all the measures in tablespoon (`tbsp`) and in teaspoon (`tsp`), considering `1 tbsp = 15g` and `1 tsp = 5g`, append to the end of the measurement the biggest equivalent integer (rounding up).\n    \"\"\"\n    words = recipe.split()\n    converted_words = []\n    for word in words:\n        if 'tbsp' in word:\n            num_str = ''.join(filter(str.isdigit, word))\n            if num_str:\n                num = int(num_str)\n                grams = ceil(num * 15)\n                converted_words.append(word + f' ({grams}g)')\n            else:\n                converted_words.append(word)\n        elif 'tsp' in word:\n            num_str = ''.join(filter(str.isdigit, word))\n            if num_str:\n                num = int(num_str)\n                grams = ceil(num * 5)\n                converted_words.append(word + f' ({grams}g)')\n            else:\n                converted_words.append(word)\n        else:\n            converted_words.append(word)\n    return ' '.join(converted_words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in a recipe from tablespoons (`tbsp`) and teaspoons (`tsp`) to grams.\n    1 tbsp = 15g and 1 tsp = 5g. Rounds up to the nearest integer.\n    \n    Args:\n    recipe (str): The original recipe text containing measurements in tbsp and tsp.\n    \n    Returns:\n    str: The updated recipe text with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = word[:-4]\n            if amount.replace('.', '', 1).isdigit():\n                grams = ceil(float(amount) * 15)\n                words[i] = f'{amount} tbsp ({grams}g)'\n        elif word.endswith('tsp'):\n            amount = word[:-3]\n            if amount.replace('.', '', 1).isdigit():\n                grams = ceil(float(amount) * 5)\n                words[i] = f'{amount} tsp ({grams}g)'\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams (g).\n    1 tbsp = 15g and 1 tsp = 5g. Rounds up to the nearest integer.\n    \n    Args:\n    recipe (str): The original recipe as a string.\n\n    Returns:\n    str: The updated recipe with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = word[:-4]\n            try:\n                grams = ceil(float(amount) * 15)\n                words[i] = f'{amount} tbsp ({grams}g)'\n            except ValueError:\n                continue\n        elif word.endswith('tsp'):\n            amount = word[:-3]\n            try:\n                grams = ceil(float(amount) * 5)\n                words[i] = f'{amount} tsp ({grams}g)'\n            except ValueError:\n                continue\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    Uses the conversion rates: 1 tbsp = 15g and 1 tsp = 5g, rounding up to the nearest gram.\n    \n    Parameters:\n    - recipe (str): The recipe as a string containing measurements in tbsp and tsp.\n    \n    Returns:\n    - str: The updated recipe with measurements converted to grams.\n    \"\"\"\n\n    def convert_measurement(value: str, unit: str) -> str:\n        try:\n            num = float(value)\n            if unit == 'tbsp':\n                grams = ceil(num * 15)\n            elif unit == 'tsp':\n                grams = ceil(num * 5)\n            else:\n                return f'{value}{unit}'\n            return f'{value}{unit} ({grams}g)'\n        except ValueError:\n            return f'{value}{unit}'\n    words = recipe.split()\n    converted_words = []\n    i = 0\n    while i < len(words):\n        word = words[i]\n        if word.endswith(('tbsp', 'tsp')):\n            value = word[:-4]\n            unit = word[-4:]\n            converted_word = convert_measurement(value, unit)\n            converted_words.append(converted_word)\n        else:\n            converted_words.append(word)\n        i += 1\n    return ' '.join(converted_words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in a recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    It appends the biggest equivalent integer measurement in grams, rounding up.\n    \n    Parameters:\n    - recipe (str): The recipe string containing measurements in tbsp and tsp.\n\n    Returns:\n    - str: The updated recipe string with measurements converted and appended in grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            numeric_part = word.rstrip('tbsp')\n            if numeric_part.replace('.', '', 1).isdigit() or (numeric_part.startswith('-') and numeric_part[1:].replace('.', '', 1).isdigit()):\n                tablespoons = float(numeric_part)\n                grams = ceil(tablespoons * 15)\n                words[i] += f' ({grams}g)'\n        elif word.endswith('tsp'):\n            numeric_part = word.rstrip('tsp')\n            if numeric_part.replace('.', '', 1).isdigit() or (numeric_part.startswith('-') and numeric_part[1:].replace('.', '', 1).isdigit()):\n                teaspoons = float(numeric_part)\n                grams = ceil(teaspoons * 5)\n                words[i] += f' ({grams}g)'\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measures in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    1 tbsp = 15g and 1 tsp = 5g. The function rounds up to the nearest integer.\n    \n    Args:\n    recipe (str): A string containing the recipe with measurements in tbsp and tsp.\n    \n    Returns:\n    str: The updated recipe with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    converted_recipe = []\n    for word in words:\n        if 'tbsp' in word:\n            num_str = ''.join(filter(str.isdigit, word))\n            if num_str:\n                num_tbsp = int(num_str)\n                grams = ceil(num_tbsp * 15)\n                new_word = word.replace('tbsp', f'tbsp ({grams}g)')\n                converted_recipe.append(new_word)\n            else:\n                converted_recipe.append(word)\n        elif 'tsp' in word:\n            num_str = ''.join(filter(str.isdigit, word))\n            if num_str:\n                num_tsp = int(num_str)\n                grams = ceil(num_tsp * 5)\n                new_word = word.replace('tsp', f'tsp ({grams}g)')\n                converted_recipe.append(new_word)\n            else:\n                converted_recipe.append(word)\n        else:\n            converted_recipe.append(word)\n    return ' '.join(converted_recipe)\nrecipe = 'Mix 2 tbsp of sugar and 3 tsp of vanilla extract.'"], "requirement": [], "outputs": "[['2 tbsp sugar'], ['3 tsp salt'], ['10 tbsp flour'], ['7 tsp baking powder'], ['1 tbsp honey, 2 tsp lemon juice'], ['0 tbsp water'], ['0 tsp pepper'], ['1.5 tbsp butter'], ['2.8 tsp vanilla extract'], ['-1 tbsp cocoa'], ['-3 tsp cinnamon'], ['25 tbsp milk'], ['47 tsp oil'], [''], ['invalid input']]", "probability": 0.28, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"Converts recipe measures from tablespoons and teaspoons to grams.\n    \n    Args:\n        recipe (str): The original recipe text.\n        \n    Returns:\n        str: The updated recipe text with measures in grams.\n    \"\"\"\n    conversions = {'tbsp': 15, 'tsp': 5}\n\n    def convert_measure(match):\n        measure = match.group(1)\n        unit = match.group(2)\n        amount = float(measure)\n        grams = ceil(amount * conversions[unit])\n        return f'{measure} {unit} ({grams}g)'\n    import re\n    pattern = re.compile('(\\\\d+(\\\\.\\\\d+)?)\\\\s*(tbsp|tsp)')\n    updated_recipe = pattern.sub(convert_measure, recipe)\n    return updated_recipe", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    unit_to_grams = {'tbsp': 15, 'tsp': 5}\n    lines = recipe.splitlines()\n\n    def convert_measurement(match):\n        amount = float(match.group(1))\n        unit = match.group(2)\n        grams_per_unit = unit_to_grams[unit]\n        grams = ceil(amount * grams_per_unit)\n        return f'{amount} {unit} ({grams}g)'\n    import re\n    pattern = re.compile('(\\\\d+(\\\\.\\\\d+)?)\\\\s*(tbsp|tsp)')\n    converted_lines = []\n    for line in lines:\n        converted_line = pattern.sub(convert_measurement, line)\n        converted_lines.append(converted_line)\n    return '\\n'.join(converted_lines)"], "requirement": [], "outputs": "[['KeyError'], ['KeyError'], ['KeyError'], ['KeyError'], ['KeyError'], ['KeyError'], ['KeyError'], ['KeyError'], ['KeyError'], ['KeyError'], ['KeyError'], ['KeyError'], ['KeyError'], [' '], ['invalid input']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    lines = recipe.splitlines()\n    converted_lines = []\n    for line in lines:\n        if 'tbsp' in line:\n            parts = line.rsplit('tbsp', 1)\n            amount_str = parts[0].strip().split()[-1]\n            try:\n                amount = float(amount_str)\n                grams = ceil(amount * 15)\n                converted_lines.append(f'{line} ({grams}g)')\n            except ValueError:\n                converted_lines.append(line)\n        elif 'tsp' in line:\n            parts = line.rsplit('tsp', 1)\n            amount_str = parts[0].strip().split()[-1]\n            try:\n                amount = float(amount_str)\n                grams = ceil(amount * 5)\n                converted_lines.append(f'{line} ({grams}g)')\n            except ValueError:\n                converted_lines.append(line)\n        else:\n            converted_lines.append(line)\n    return '\\n'.join(converted_lines)"], "requirement": [], "outputs": "[['2 tbsp sugar (30g)'], ['3 tsp salt (15g)'], ['10 tbsp flour (150g)'], ['7 tsp baking powder (35g)'], ['1 tbsp honey, 2 tsp lemon juice (15g)'], ['0 tbsp water (0g)'], ['0 tsp pepper (0g)'], ['1.5 tbsp butter (23g)'], ['2.8 tsp vanilla extract (14g)'], ['-1 tbsp cocoa (-15g)'], ['-3 tsp cinnamon (-15g)'], ['25 tbsp milk (375g)'], ['47 tsp oil (235g)'], [' '], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    1 tbsp = 15g and 1 tsp = 5g. The function appends the biggest equivalent integer (rounding up).\n    \"\"\"\n    conversions = {'tbsp': 15, 'tsp': 5}\n\n    def convert_measurement(match):\n        amount = float(match.group(1))\n        unit = match.group(2)\n        if unit in conversions:\n            grams = ceil(amount * conversions[unit])\n            return f'{amount}{unit} ({grams}g)'\n        return match.group(0)\n    import re\n    pattern = '(\\\\d+(\\\\.\\\\d+)?)\\\\s*(tbsp|tsp)'\n    converted_recipe = re.sub(pattern, convert_measurement, recipe)\n    return converted_recipe", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"Converts measurements in a recipe from tablespoons and teaspoons to grams.\n    \n    Args:\n        recipe (str): The recipe string containing 'tbsp' and 'tsp'.\n        \n    Returns:\n        str: The updated recipe with measurements in grams, rounded up to the nearest integer.\n    \"\"\"\n    conversions = {'tbsp': 15, 'tsp': 5}\n\n    def convert_measurement(match):\n        unit = match.group(1)\n        value = float(match.group(2))\n        converted_value = ceil(value * conversions[unit])\n        return f'{value} {unit} ({converted_value}g)'\n    import re\n    pattern = re.compile('(\\\\btbsp\\\\b|\\\\btsp\\\\b)\\\\s*([0-9.]+)')\n    updated_recipe = pattern.sub(convert_measurement, recipe)\n    return updated_recipe"], "requirement": [], "outputs": "[['2 tbsp sugar'], ['3 tsp salt'], ['10 tbsp flour'], ['7 tsp baking powder'], ['1 tbsp honey, 2 tsp lemon juice'], ['0 tbsp water'], ['0 tsp pepper'], ['1.5 tbsp butter'], ['2.8 tsp vanilla extract'], ['-1 tbsp cocoa'], ['-3 tsp cinnamon'], ['25 tbsp milk'], ['47 tsp oil'], [' '], ['invalid input']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts all measurements in a recipe from tablespoons (`tbsp`) and teaspoons (`tsp`) to grams.\n    1 tbsp = 15g and 1 tsp = 5g. The function appends the biggest equivalent integer (rounding up).\n    \n    Args:\n    recipe (str): A string containing the recipe with measurements in tbsp and tsp.\n    \n    Returns:\n    str: The updated recipe with measurements converted to grams.\n    \"\"\"\n\n    def convert_measurement(match):\n        unit, amount_str = match.groups()\n        amount = float(amount_str)\n        if unit == 'tbsp':\n            converted = ceil(amount * 15)\n        elif unit == 'tsp':\n            converted = ceil(amount * 5)\n        return f'{amount} {unit} ({converted}g)'\n    import re\n    pattern = re.compile('(\\\\d+)\\\\s*(tbsp|tsp)')\n    updated_recipe = pattern.sub(convert_measurement, recipe)\n    return updated_recipe"], "requirement": [], "outputs": "[['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], [' '], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    conversions = {'tbsp': 15, 'tsp': 5}\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word in conversions:\n            num_str = words[i - 1]\n            num = float(num_str)\n            gram_value = num * conversions[word]\n            rounded_grams = ceil(gram_value)\n            words[i] = f'{word}({rounded_grams}g)'\n    converted_recipe = ' '.join(words)\n    return converted_recipe"], "requirement": [], "outputs": "[['2 tbsp(30g) sugar'], ['3 tsp(15g) salt'], ['10 tbsp(150g) flour'], ['7 tsp(35g) baking powder'], ['1 tbsp(15g) honey, 2 tsp(10g) lemon juice'], ['0 tbsp(0g) water'], ['0 tsp(0g) pepper'], ['1.5 tbsp(23g) butter'], ['2.8 tsp(14g) vanilla extract'], ['-1 tbsp(-15g) cocoa'], ['-3 tsp(-15g) cinnamon'], ['25 tbsp(375g) milk'], ['47 tsp(235g) oil'], [''], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in a recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    \n    Args:\n    recipe (str): A string containing the recipe with measurements in tbsp and tsp.\n    \n    Returns:\n    str: The updated recipe string with measurements converted to grams.\n    \"\"\"\n    conversions = {'tbsp': 15, 'tsp': 5}\n\n    def convert_measurement(match):\n        unit = match.group(2).strip()\n        value = float(match.group(1))\n        grams = ceil(value * conversions[unit])\n        return f'{value} {unit} ({grams}g)'\n    import re\n    pattern = re.compile('(\\\\d+(\\\\.\\\\d+)?)\\\\s*(tbsp|tsp)')\n    updated_recipe = pattern.sub(convert_measurement, recipe)\n    return updated_recipe"], "requirement": [], "outputs": "[['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['KeyError'], ['KeyError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], ['AttributeError'], [' '], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    \n    Args:\n        recipe (str): The recipe string containing measurements in tbsp and tsp.\n        \n    Returns:\n        str: The updated recipe string with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word == 'tbsp' and i > 0 and words[i - 1].isdigit():\n            tablespoons = int(words[i - 1])\n            grams = ceil(tablespoons * 15)\n            words[i] = f'tbsp ({grams}g)'\n        elif word == 'tsp' and i > 0 and words[i - 1].isdigit():\n            teaspoons = int(words[i - 1])\n            grams = ceil(teaspoons * 5)\n            words[i] = f'tsp ({grams}g)'\n    return ' '.join(words)\nrecipe = 'Mix 2 tbsp of sugar and 3 tsp of vanilla extract.'"], "requirement": [], "outputs": "[['2 tbsp (30g) sugar'], ['3 tsp (15g) salt'], ['10 tbsp (150g) flour'], ['7 tsp (35g) baking powder'], ['1 tbsp (15g) honey, 2 tsp (10g) lemon juice'], ['0 tbsp (0g) water'], ['0 tsp (0g) pepper'], ['1.5 tbsp butter'], ['2.8 tsp vanilla extract'], ['-1 tbsp cocoa'], ['-3 tsp cinnamon'], ['25 tbsp (375g) milk'], ['47 tsp (235g) oil'], [''], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    conversions = {'tbsp': 15, 'tsp': 5}\n    lines = recipe.splitlines()\n    converted_lines = []\n    for line in lines:\n        for unit, factor in conversions.items():\n            if unit in line:\n                try:\n                    value_str = ''.join(filter(str.isdigit, line.split(unit)[0].strip().split()[-1]))\n                    value = float(value_str) if value_str else 1\n                    grams = ceil(value * factor)\n                    line = line.strip() + f' ({grams}g)'\n                    break\n                except ValueError:\n                    continue\n        converted_lines.append(line)\n    return '\\n'.join(converted_lines)"], "requirement": [], "outputs": "[['2 tbsp sugar (30g)'], ['3 tsp salt (15g)'], ['10 tbsp flour (150g)'], ['7 tsp baking powder (35g)'], ['1 tbsp honey, 2 tsp lemon juice (15g)'], ['0 tbsp water (0g)'], ['0 tsp pepper (0g)'], ['1.5 tbsp butter (225g)'], ['2.8 tsp vanilla extract (140g)'], ['-1 tbsp cocoa (15g)'], ['-3 tsp cinnamon (15g)'], ['25 tbsp milk (375g)'], ['47 tsp oil (235g)'], [' '], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams (g).\n    1 tbsp = 15g and 1 tsp = 5g. Rounds up to the nearest integer.\n    \n    Args:\n    recipe (str): The original recipe string containing measurements in tbsp and tsp.\n    \n    Returns:\n    str: The modified recipe string with measurements converted and appended in grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = word[:-4]\n            if amount.isdigit() or (amount[0] == '-' and amount[1:].isdigit()):\n                grams = ceil(int(amount) * 15)\n                words[i] += f' ({grams}g)'\n        elif word.endswith('tsp'):\n            amount = word[:-3]\n            if amount.isdigit() or (amount[0] == '-' and amount[1:].isdigit()):\n                grams = ceil(int(amount) * 5)\n                words[i] += f' ({grams}g)'\n    return ' '.join(words)", "from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts all occurrences of tablespoon (`tbsp`) and teaspoon (`tsp`) in the recipe string to grams.\n    1 tbsp = 15g and 1 tsp = 5g, rounding up to the nearest integer.\n    \n    Args:\n        recipe (str): The original recipe string with measurements in tbsp and tsp.\n        \n    Returns:\n        str: The updated recipe string with measurements converted to grams.\n    \"\"\"\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word.endswith('tbsp'):\n            amount = word[:-len('tbsp')]\n            if amount.isdigit() or (amount[0] == '-' and amount[1:].isdigit()):\n                amount_in_grams = ceil(int(amount) * 15)\n                words[i] = f'{amount} tbsp ({amount_in_grams}g)'\n        elif word.endswith('tsp'):\n            amount = word[:-len('tsp')]\n            if amount.isdigit() or (amount[0] == '-' and amount[1:].isdigit()):\n                amount_in_grams = ceil(int(amount) * 5)\n                words[i] = f'{amount} tsp ({amount_in_grams}g)'\n    return ' '.join(words)\nrecipe = 'Mix 2 tbsp of sugar and 3 tsp of cinnamon.'"], "requirement": [], "outputs": "[['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], ['IndexError'], [''], ['invalid input']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    conversions = {'tbsp': 15, 'tsp': 5}\n    lines = recipe.splitlines()\n    converted_lines = []\n    for line in lines:\n        for unit, gram in conversions.items():\n            if unit in line:\n                try:\n                    num_str = ''.join(filter(str.isdigit, line))\n                    num = int(num_str)\n                    gram_equiv = ceil(num * gram)\n                    new_line = f'{line}, {gram_equiv}g'\n                    converted_lines.append(new_line)\n                    break\n                except ValueError:\n                    converted_lines.append(line)\n                    break\n        else:\n            converted_lines.append(line)\n    return '\\n'.join(converted_lines)"], "requirement": [], "outputs": "[['2 tbsp sugar, 30g'], ['3 tsp salt, 15g'], ['10 tbsp flour, 150g'], ['7 tsp baking powder, 35g'], ['1 tbsp honey, 2 tsp lemon juice, 180g'], ['0 tbsp water, 0g'], ['0 tsp pepper, 0g'], ['1.5 tbsp butter, 225g'], ['2.8 tsp vanilla extract, 140g'], ['-1 tbsp cocoa, 15g'], ['-3 tsp cinnamon, 15g'], ['25 tbsp milk, 375g'], ['47 tsp oil, 235g'], [' '], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    conversions = {'tbsp': 15, 'tsp': 5}\n    lines = recipe.splitlines()\n    converted_lines = []\n    for line in lines:\n        for unit, factor in conversions.items():\n            if unit in line:\n                try:\n                    quantity_str = line.split(unit)[0].strip().split()[-1]\n                    quantity = float(quantity_str)\n                    grams = ceil(quantity * factor)\n                    line = line.replace(quantity_str + ' ' + unit, f'{quantity} {unit} ({grams}g)')\n                except ValueError:\n                    continue\n        converted_lines.append(line)\n    return '\\n'.join(converted_lines)\nrecipe = '2 tbsp of sugar\\n1 tsp of salt\\n3 tbsp of butter'"], "requirement": [], "outputs": "[['2.0 tbsp (30g) sugar'], ['3.0 tsp (15g) salt'], ['10.0 tbsp (150g) flour'], ['7.0 tsp (35g) baking powder'], ['1.0 tbsp (15g) honey, 2.0 tsp (10g) lemon juice'], ['0.0 tbsp (0g) water'], ['0.0 tsp (0g) pepper'], ['1.5 tbsp (23g) butter'], ['2.8 tsp (14g) vanilla extract'], ['-1.0 tbsp (-15g) cocoa'], ['-3.0 tsp (-15g) cinnamon'], ['25.0 tbsp (375g) milk'], ['47.0 tsp (235g) oil'], [' '], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    1 tbsp = 15g and 1 tsp = 5g. The function appends the biggest equivalent integer (rounding up).\n    \n    Args:\n    recipe (str): A string containing the recipe with measurements in tbsp and tsp.\n    \n    Returns:\n    str: The modified recipe with measurements converted to grams.\n    \"\"\"\n    measures = {'tbsp': 15, 'tsp': 5}\n    words = recipe.split()\n    for i, word in enumerate(words):\n        if word in measures:\n            prev_word = words[i - 1]\n            try:\n                value = float(prev_word)\n                grams = ceil(value * measures[word])\n                words[i - 1] = f'{prev_word}{word} ({grams}g)'\n            except ValueError:\n                continue\n    return ' '.join(words)"], "requirement": [], "outputs": "[['2tbsp (30g) tbsp sugar'], ['3tsp (15g) tsp salt'], ['10tbsp (150g) tbsp flour'], ['7tsp (35g) tsp baking powder'], ['1tbsp (15g) tbsp honey, 2tsp (10g) tsp lemon juice'], ['0tbsp (0g) tbsp water'], ['0tsp (0g) tsp pepper'], ['1.5tbsp (23g) tbsp butter'], ['2.8tsp (14g) tsp vanilla extract'], ['-1tbsp (-15g) tbsp cocoa'], ['-3tsp (-15g) tsp cinnamon'], ['25tbsp (375g) tbsp milk'], ['47tsp (235g) tsp oil'], [''], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    conversions = {'tbsp': 15, 'tsp': 5}\n    lines = recipe.splitlines()\n    new_lines = []\n    for line in lines:\n        for unit, grams in conversions.items():\n            if unit in line:\n                parts = line.split()\n                for i, part in enumerate(parts):\n                    if unit in part:\n                        try:\n                            num = float(parts[i - 1])\n                            converted = ceil(num * grams)\n                            parts[i] = f'{parts[i]} ({converted}g)'\n                        except ValueError:\n                            continue\n                line = ' '.join(parts)\n        new_lines.append(line)\n    return '\\n'.join(new_lines)\nrecipe = '1 tbsp of sugar\\n2 tsp of salt'"], "requirement": [], "outputs": "[['2 tbsp (30g) sugar'], ['3 tsp (15g) salt'], ['10 tbsp (150g) flour'], ['7 tsp (35g) baking powder'], ['1 tbsp (15g) honey, 2 tsp (10g) lemon juice'], ['0 tbsp (0g) water'], ['0 tsp (0g) pepper'], ['1.5 tbsp (23g) butter'], ['2.8 tsp (14g) vanilla extract'], ['-1 tbsp (-15g) cocoa'], ['-3 tsp (-15g) cinnamon'], ['25 tbsp (375g) milk'], ['47 tsp (235g) oil'], [' '], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    conversions = {'tbsp': 15, 'tsp': 5}\n    lines = recipe.split('\\n')\n    converted_lines = []\n    for line in lines:\n        for unit, grams in conversions.items():\n            if unit in line:\n                parts = line.split(unit)\n                if len(parts) > 1:\n                    try:\n                        quantity_str = ''.join([char for char in parts[0].strip()[::-1] if char.isdigit() or char == '.'])\n                        quantity = float(quantity_str[::-1])\n                        converted_quantity = ceil(quantity * grams)\n                        parts[0] = parts[0].rstrip(quantity_str).strip()\n                        line = f'{parts[0]}{unit} ({converted_quantity}g)'\n                    except ValueError:\n                        pass\n        converted_lines.append(line)\n    return '\\n'.join(converted_lines)\nrecipe = '1 tbsp of sugar\\n1 tsp of salt\\n2 tbsp of flour'"], "requirement": [], "outputs": "[['2tbsp (30g)'], ['3tsp (15g)'], ['10tbsp (150g)'], ['7tsp (35g)'], ['1tbsp (15g)'], ['0tbsp (0g)'], ['0tsp (0g)'], ['1.5tbsp (23g)'], ['2.8tsp (14g)'], ['-1tbsp (15g)'], ['-3tsp (15g)'], ['25tbsp (375g)'], ['47tsp (235g)'], [' '], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    tbsp_to_grams = 15\n    tsp_to_grams = 5\n    lines = recipe.splitlines()\n    converted_lines = []\n    for line in lines:\n        if 'tbsp' in line:\n            parts = line.split(' ')\n            for i, part in enumerate(parts):\n                if 'tbsp' in part:\n                    try:\n                        amount = float(parts[i - 1])\n                        grams = ceil(amount * tbsp_to_grams)\n                        parts[i] = f'{parts[i]} ({grams}g)'\n                    except ValueError:\n                        pass\n        elif 'tsp' in line:\n            parts = line.split(' ')\n            for i, part in enumerate(parts):\n                if 'tsp' in part:\n                    try:\n                        amount = float(parts[i - 1])\n                        grams = ceil(amount * tsp_to_grams)\n                        parts[i] = f'{parts[i]} ({grams}g)'\n                    except ValueError:\n                        pass\n        converted_line = ' '.join(parts)\n        converted_lines.append(converted_line)\n    return '\\n'.join(converted_lines)\nrecipe = '1 tbsp sugar\\n2 tsp salt\\n3 tbsp flour'"], "requirement": [], "outputs": "[['2 tbsp (30g) sugar'], ['3 tsp (15g) salt'], ['10 tbsp (150g) flour'], ['7 tsp (35g) baking powder'], ['1 tbsp (15g) honey, 2 tsp lemon juice'], ['0 tbsp (0g) water'], ['0 tsp (0g) pepper'], ['1.5 tbsp (23g) butter'], ['2.8 tsp (14g) vanilla extract'], ['-1 tbsp (-15g) cocoa'], ['-3 tsp (-15g) cinnamon'], ['25 tbsp (375g) milk'], ['47 tsp (235g) oil'], ['UnboundLocalError'], ['UnboundLocalError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts all measurements in the given recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    1 tbsp = 15g and 1 tsp = 5g. Appends the biggest equivalent integer (rounding up) to the end of the measurement.\n    \n    :param recipe: The original recipe string with measurements.\n    :return: The updated recipe string with measurements converted to grams.\n    \"\"\"\n\n    def to_grams(value, unit):\n        if unit == 'tbsp':\n            return ceil(value * 15)\n        elif unit == 'tsp':\n            return ceil(value * 5)\n        else:\n            return None\n    words = recipe.split()\n    result = []\n    i = 0\n    while i < len(words):\n        word = words[i]\n        if word.endswith(('tbsp', 'tsp')):\n            try:\n                value = float(words[i - 1])\n                unit = word\n                grams = to_grams(value, unit)\n                result.append(f'{value} {unit} ({grams}g)')\n                i += 1\n            except ValueError:\n                result.append(word)\n        else:\n            result.append(word)\n        i += 1\n    return ' '.join(result)\nrecipe = 'Mix 2 tbsp of sugar, 3 tsp of salt, and 4 tbsp of butter.'"], "requirement": [], "outputs": "[['2 2.0 tbsp (30g)'], ['3 3.0 tsp (15g)'], ['10 10.0 tbsp (150g)'], ['7 7.0 tsp (35g) powder'], ['1 1.0 tbsp (15g) 2 2.0 tsp (10g) juice'], ['0 0.0 tbsp (0g)'], ['0 0.0 tsp (0g)'], ['1.5 1.5 tbsp (23g)'], ['2.8 2.8 tsp (14g) extract'], ['-1 -1.0 tbsp (-15g)'], ['-3 -3.0 tsp (-15g)'], ['25 25.0 tbsp (375g)'], ['47 47.0 tsp (235g)'], [''], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from math import ceil\n\ndef convert_recipe(recipe: str) -> str:\n    \"\"\"\n    Converts measurements in the recipe from tablespoons (tbsp) and teaspoons (tsp) to grams.\n    1 tbsp = 15g and 1 tsp = 5g. The function rounds up to the nearest integer.\n    \n    Args:\n    recipe (str): A string containing the recipe with measurements.\n\n    Returns:\n    str: The updated recipe with measurements in grams.\n    \"\"\"\n    lines = recipe.splitlines()\n    converted_lines = []\n    for line in lines:\n        if 'tbsp' in line:\n            parts = line.split('tbsp')\n            number_part = ''.join(filter(str.isdigit, parts[0]))\n            if number_part:\n                number = int(number_part)\n                grams = ceil(number * 15)\n                line = line.replace(f'{number} tbsp', f'{number} tbsp ({grams}g)')\n        elif 'tsp' in line:\n            parts = line.split('tsp')\n            number_part = ''.join(filter(str.isdigit, parts[0]))\n            if number_part:\n                number = int(number_part)\n                grams = ceil(number * 5)\n                line = line.replace(f'{number} tsp', f'{number} tsp ({grams}g)')\n        converted_lines.append(line)\n    return '\\n'.join(converted_lines)"], "requirement": [], "outputs": "[['2 tbsp (30g) sugar'], ['3 tsp (15g) salt'], ['10 tbsp (150g) flour'], ['7 tsp (35g) baking powder'], ['1 tbsp (15g) honey, 2 tsp lemon juice'], ['0 tbsp (0g) water'], ['0 tsp (0g) pepper'], ['1.5 tbsp butter'], ['2.8 tsp vanilla extract'], ['-1 tbsp (15g) cocoa'], ['-3 tsp (15g) cinnamon'], ['25 tbsp (375g) milk'], ['47 tsp (235g) oil'], [' '], ['invalid input']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 2.4514687825634476, "llm_generated_inputs": "[['2 tbsp sugar'], ['3 tsp salt'], ['10 tbsp flour'], ['7 tsp baking powder'], ['1 tbsp honey, 2 tsp lemon juice'], ['0 tbsp water'], ['0 tsp pepper'], ['1.5 tbsp butter'], ['2.8 tsp vanilla extract'], ['-1 tbsp cocoa'], ['-3 tsp cinnamon'], ['25 tbsp milk'], ['47 tsp oil'], [' '], ['invalid input']]", "input_output_examples": "[[['2 tbsp of butter'], ['1/2 tbsp of oregano'], ['1/2 tsp of salt'], ['Add to the mixing bowl and coat well with 1 tbsp of olive oil & 1/2 tbsp of dried dill']], [['2 tbsp (30g) of butter'], ['1/2 tbsp (8g) of oregano'], ['1/2 tbsp (3g) of salt'], ['Add to the mixing bowl and coat well with 1 tbsp (15g) of olive oil & 1/2 tbsp (8g) of dried dill']]]", "at_least_one_align": false}, "entry_point": "convert_recipe", "ground_truth": -1}
{"task_id": "TACO_lite/35", "requirement": "from typing import List\ndef move_zeros(arr: List[int]) -> List[int]:\n\"\"\"Write an algorithm that takes an array and moves all of the zeros to the end, preserving the order of the other elements.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [num for num in arr if num != 0]\n    zero_elements = [0] * (len(arr) - len(non_zero_elements))\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [0] * (len(arr) - len(non_zeros))\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [num for num in arr if num != 0]\n    zero_elements = [0] * (len(arr) - len(non_zero_elements))\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [num for num in arr if num != 0]\n    zero_elements = [0] * (len(arr) - len(non_zero_elements))\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [0] * (len(arr) - len(non_zeros))\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [0] * (len(arr) - len(non_zeros))\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [0] * (len(arr) - len(non_zeros))\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [num for num in arr if num != 0]\n    zeros = [0] * (len(arr) - len(non_zeros))\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [num for num in arr if num != 0]\n    zero_elements = [0] * (len(arr) - len(non_zero_elements))\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [num for num in arr if num != 0]\n    zero_elements = [0] * (len(arr) - len(non_zero_elements))\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [num for num in arr if num != 0]\n    zero_elements = [0] * (len(arr) - len(non_zero_elements))\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    result = non_zero_elements + zero_elements\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    result = non_zero_elements + zero_elements\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    result = non_zeros + zeros\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    result = non_zero_elements + zero_elements\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    result = non_zero_elements + zero_elements\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    result = non_zeros + zeros\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    result = non_zero_elements + zero_elements\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [0] * (len(arr) - len(non_zero_elements))\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    result = non_zero_elements + zero_elements\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [0] * (len(arr) - len(non_zeros))\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    \"\"\"Write an algorithm that takes an array and moves all of the zeros to the end, preserving the order of the other elements.\"\"\"\n    non_zero_elements = [num for num in arr if num != 0]\n    zero_elements = [0] * (len(arr) - len(non_zero_elements))\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [0] * (len(arr) - len(non_zeros))\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    \"\"\"Write an algorithm that takes an array and moves all of the zeros to the end, preserving the order of the other elements.\"\"\"\n    non_zero_elements = [num for num in arr if num != 0]\n    zero_elements = [0] * (len(arr) - len(non_zero_elements))\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    result = non_zeros + zeros\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    result = non_zeros + zeros\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [0] * (len(arr) - len(non_zeros))\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    \"\"\"Write an algorithm that takes an array and moves all of the zeros to the end, preserving the order of the other elements.\"\"\"\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    result = non_zero_elements + zero_elements\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    result = non_zeros + zeros\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    return non_zero_elements + zero_elements", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    result = non_zeros + zeros\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [x for x in arr if x == 0]\n    result = non_zero_elements + zero_elements\n    return result", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [x for x in arr if x == 0]\n    return non_zeros + zeros", "from typing import List\n\ndef move_zeros(arr: List[int]) -> List[int]:\n    non_zero_elements = [num for num in arr if num != 0]\n    zero_elements = [num for num in arr if num == 0]\n    result = non_zero_elements + zero_elements\n    return result"], "requirement": [], "outputs": "[[[1, 2, 3, 4, 0, 0]], [[1, 2, 3, 4, 5, 6]], [[0, 0, 0, 0, 0, 0]], [[1, 2, 3, 4, 5, 0, 0, 0, 0]], [[]], [[0]], [[1]], [[1, 1, 1, 0, 0, 0, 0]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0]], [[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]]]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[[0, 1, 2, 0, 3, 4]], [[1, 2, 3, 4, 5, 6]], [[0, 0, 0, 0, 0, 0]], [[1, 0, 2, 0, 3, 0, 4, 0, 5]], [[]], [[0]], [[1]], [[1, 0, 0, 0, 1, 0, 1]], [[0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 6, 7, 8, 9, 0]], [[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]]]", "input_output_examples": "[[[[False, 1, 0, 1, 2, 0, 1, 3, 'a']]], [[[False, 1, 1, 2, 1, 3, 'a', 0, 0]]]]", "at_least_one_align": false}, "entry_point": "move_zeros", "ground_truth": 0}
{"task_id": "TACO_lite/36", "requirement": "def string_parse(string: str) -> str:\n\"\"\"Create a program that will take in a string as input and, if there are duplicates of more than two alphabetical characters in the string, returns the string with all the extra characters in a bracket.\n\nPlease also ensure that the input is a string, and return \"Please enter a valid string\" if it is not.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    n = len(string)\n    while i < n:\n        count = 1\n        while i + 1 < n and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            i += 1\n            count += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        elif count == 2:\n            result.append(string[i] * 2)\n        else:\n            result.append(string[i])\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    n = len(string)\n    while i < n:\n        count = 1\n        while i + 1 < n and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count <= 2:\n            result.append(string[i] * count)\n        else:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count <= 2:\n            result.append(string[i] * count)\n        else:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        elif count == 2:\n            result.append(string[i] * 2)\n        else:\n            result.append(string[i])\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        j = i + 1\n        while j < len(string) and string[i] == string[j]:\n            count += 1\n            j += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i = j\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(string[i] + '[' + string[i] * (count - 2) + ']')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    count = 1\n    for i in range(len(string)):\n        if i < len(string) - 1 and string[i] == string[i + 1]:\n            count += 1\n        else:\n            if count <= 2:\n                result.append(string[i] * count)\n            else:\n                result.append(string[i] + f'[{string[i] * (count - 2)}]')\n            count = 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['a[a]'], ['aab[b]c[cc]'], ['aabbcc'], ['abcdef[f]g'], ['abcdefg'], ['a[a]b[bb]c[c]ddef'], ['a[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa]'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['A[A]bbCcDdEe'], [' [ ]'], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.38, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(string[i] * 2 + '[' + string[i] * (count - 2) + ']')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        j = i + 1\n        while j < len(string) and string[i] == string[j]:\n            count += 1\n            j += 1\n        if count > 2:\n            result.append(string[i] * 2 + f'[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i = j\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    n = len(string)\n    while i < n:\n        count = 1\n        while i + 1 < n and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(string[i] * 2 + f'[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(string[i] * 2 + f'[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(string[i] * 2 + f'[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(string[i] * 2 + f'[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(string[i] * 2 + f'[{string[i] * (count - 2)}]')\n        elif count == 2:\n            result.append(string[i] * 2)\n        else:\n            result.append(string[i])\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(string[i] * 2 + f'[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(string[i] * 2 + f'[{string[i] * (count - 2)}]')\n        else:\n            result.append(string[i] * count)\n        i += 1\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['aa[a]'], ['aabb[b]cc[cc]'], ['aabbcc'], ['abcdeff[f]g'], ['abcdefg'], ['aa[a]bb[bb]cc[c]ddef'], ['aa[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa]'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['AA[A]bbCcDdEe'], ['  [ ]'], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.18, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{count - 2}]')\n        else:\n            result.append(string[i] * min(2, count))\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{count - 2}]')\n        else:\n            result.append(string[i] * min(2, count))\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{count - 2}]')\n        else:\n            result.append(string[i] * min(count, 2))\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{count - 2}]')\n        else:\n            result.append(string[i] * min(2, count))\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{count - 2}]')\n        else:\n            result.append(string[i] * min(2, count))\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{count - 2}]')\n        else:\n            result.extend([string[i]] * min(2, count))\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{count - 2}]')\n        else:\n            result.append(string[i] * min(2, count))\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    count = 1\n    for i in range(len(string)):\n        if i < len(string) - 1 and string[i] == string[i + 1]:\n            count += 1\n        else:\n            if count > 2:\n                result.append(f'{string[i]}[{count - 2}]')\n            else:\n                result.append(string[i] * min(2, count))\n            count = 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{count - 2}]')\n        else:\n            result.append(string[i] * min(2, count))\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    n = len(string)\n    while i < n:\n        count = 1\n        while i + 1 < n and string[i] == string[i + 1]:\n            i += 1\n            count += 1\n        if count > 2:\n            result.append(f'{string[i]}[{count - 2}]')\n        else:\n            result.append(string[i] * min(count, 2))\n        i += 1\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['a[1]'], ['aab[1]c[2]'], ['aabbcc'], ['abcdef[1]g'], ['abcdefg'], ['a[1]b[2]c[1]ddef'], ['a[48]'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['A[1]bbCcDdEe'], [' [1]'], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.2, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1]:\n            count += 1\n            i += 1\n        if count > 2:\n            result.append(f'{string[i]}[{count - 2}]')\n        else:\n            result.append(string[i])\n        i += 1\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    char_count = 1\n    for i in range(len(string)):\n        if i == len(string) - 1 or string[i] != string[i + 1]:\n            if char_count > 2:\n                result.append(f'{string[i]}[{char_count - 2}]')\n            elif char_count == 2:\n                result.append(string[i])\n            else:\n                result.append(string[i])\n            char_count = 1\n        else:\n            char_count += 1\n    return ''.join(result)"], "requirement": [], "outputs": "[['a'], ['a[1]'], ['ab[1]c[2]'], ['abc'], ['abcdef[1]g'], ['abcdefg'], ['a[1]b[2]c[1]def'], ['a[48]'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['A[1]bCcDdEe'], [' [1]'], ['a b c d e f g'], ['abcdeFGH']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    count = 1\n    for i in range(len(string)):\n        if i > 0 and string[i] == string[i - 1] and string[i].isalpha():\n            count += 1\n        else:\n            count = 1\n        if count <= 2:\n            result.append(string[i])\n        else:\n            if len(result) == 0 or result[-1] != ']':\n                result.append('[')\n            result.append(string[i])\n            if count == 3:\n                result.append(']')\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['aa[a]'], ['aabb[b]cc[c]c'], ['aabbcc'], ['abcdeff[f]g'], ['abcdefg'], ['aa[a]bb[b]bcc[c]ddef'], ['aa[a]a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['AA[A]bbCcDdEe'], ['   '], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    count = 1\n    for i in range(len(string)):\n        if i > 0 and string[i] == string[i - 1]:\n            count += 1\n        else:\n            count = 1\n        if count <= 2:\n            result.append(string[i])\n        elif i == len(string) - 1 or string[i] != string[i + 1]:\n            result.append(f'[{string[i]}]' * (count - 2))\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['aa[a]'], ['aabb[b]cc[c][c]'], ['aabbcc'], ['abcdeff[f]g'], ['abcdefg'], ['aa[a]bb[b][b]cc[c]ddef'], ['aa[a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a][a]'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['AA[A]bbCcDdEe'], ['  [ ]'], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    count = 1\n    for i in range(len(string)):\n        if i > 0 and string[i] == string[i - 1]:\n            count += 1\n        else:\n            count = 1\n        if count <= 2:\n            result.append(string[i])\n        elif count == 3:\n            result.append('[' + string[i])\n        elif count > 3:\n            result.append(string[i])\n    if count > 2:\n        result.append(']')\n    return ''.join(result)", "def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    count = 1\n    for i in range(len(string)):\n        if i > 0 and string[i] == string[i - 1]:\n            count += 1\n        else:\n            count = 1\n        if count <= 2:\n            result.append(string[i])\n        elif count == 3:\n            result.append('[' + string[i])\n        elif count > 3:\n            result.append(string[i])\n    if count >= 3:\n        result.append(']')\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['aa[a]'], ['aabb[bcc[cc]'], ['aabbcc'], ['abcdeff[fg'], ['abcdefg'], ['aa[abb[bbcc[cddef'], ['aa[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa]'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['AA[AbbCcDdEe'], ['  [ ]'], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    temp = []\n    for i, char in enumerate(string):\n        if i == 0 or char == string[i - 1]:\n            temp.append(char)\n        else:\n            if len(temp) > 2:\n                result.append('[' + ''.join(temp) + ']')\n            else:\n                result.extend(temp)\n            temp = [char]\n    if len(temp) > 2:\n        result.append('[' + ''.join(temp) + ']')\n    else:\n        result.extend(temp)\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['[aaa]'], ['aa[bbb][cccc]'], ['aabbcc'], ['abcde[fff]g'], ['abcdefg'], ['[aaa][bbbb][ccc]ddef'], ['[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa]'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['[AAA]bbCcDdEe'], ['[   ]'], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    i = 0\n    while i < len(string):\n        count = 1\n        while i + 1 < len(string) and string[i] == string[i + 1] and (count < 3):\n            count += 1\n            i += 1\n        if i + 1 < len(string) and string[i] == string[i + 1]:\n            j = i + 1\n            while j < len(string) and string[i] == string[j]:\n                j += 1\n            result.append(string[i] * min(2, count) + '[' + string[i] * (j - i - 1) + ']')\n            i = j\n        else:\n            result.append(string[i] * count)\n            i += 1\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['aaa'], ['aabbbcc[c]'], ['aabbcc'], ['abcdefffg'], ['abcdefg'], ['aaabb[b]cccddef'], ['aa[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa]'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['AAAbbCcDdEe'], ['   '], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    count = 1\n    for i in range(len(string)):\n        if i > 0 and string[i] == string[i - 1]:\n            count += 1\n        else:\n            count = 1\n        if count > 2:\n            if not result or result[-1] != f'[{string[i]}':\n                result.append(f'[{string[i]}')\n        else:\n            result.append(string[i])\n        if i == len(string) - 1 or string[i] != string[i + 1]:\n            if result and result[-1][0] == '[':\n                result[-1] += ']'\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['aa[a]'], ['aabb[b]cc[c]'], ['aabbcc'], ['abcdeff[f]g'], ['abcdefg'], ['aa[a]bb[b]cc[c]ddef'], ['aa[a]'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['AA[A]bbCcDdEe'], ['  [ ]'], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    count = 1\n    for i in range(len(string)):\n        if i > 0 and string[i] == string[i - 1]:\n            count += 1\n        else:\n            count = 1\n        if count <= 2:\n            result.append(string[i])\n        else:\n            if count == 3:\n                result[-2] = '[' + result[-2]\n            result.append(string[i])\n            result[-1] += ']'\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['[aaa]'], ['aa[bbb][ccc]c]'], ['aabbcc'], ['abcde[fff]g'], ['abcdefg'], ['[aaa][bbb]b][ccc]ddef'], ['[aaa]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['[AAA]bbCcDdEe'], ['[   ]'], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    count = 1\n    for i in range(len(string)):\n        if i > 0 and string[i] == string[i - 1]:\n            count += 1\n        else:\n            count = 1\n        if count > 2:\n            if len(result) == 0 or result[-1] != '[':\n                result.append('[')\n            result.append(string[i])\n            if len(result) > 1 and result[-2] != '[':\n                result.append(']')\n        else:\n            result.append(string[i])\n    if len(result) >= 2 and result[-1] != ']' and (result[0] == '['):\n        result.append(']')\n    return ''.join(result)"], "requirement": [], "outputs": "[['aa'], ['aa[a'], ['aabb[bcc[c[c'], ['aabbcc'], ['abcdeff[fg'], ['abcdefg'], ['aa[abb[b[bcc[cddef'], ['aa[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a[a'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['AA[AbbCcDdEe'], ['  [ '], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def string_parse(string: str) -> str:\n    if not isinstance(string, str):\n        return 'Please enter a valid string'\n    result = []\n    temp_char = ''\n    count = 0\n    for char in string:\n        if char.isalpha():\n            if char == temp_char:\n                count += 1\n            else:\n                temp_char = char\n                count = 1\n            if count <= 2:\n                result.append(char)\n            else:\n                result.append(']' + char)\n        else:\n            result.append(char)\n            temp_char = ''\n            count = 0\n    result_str = ''.join(result)\n    corrected_result = []\n    bracket_opened = False\n    for i in range(len(result_str)):\n        if i > 0 and result_str[i] == result_str[i - 1] and result_str[i - 1].isalpha() and (result_str[i] != ']'):\n            if not bracket_opened:\n                corrected_result.append('[')\n                bracket_opened = True\n            corrected_result.append(result_str[i])\n        else:\n            if bracket_opened:\n                corrected_result.append(']')\n                bracket_opened = False\n            corrected_result.append(result_str[i])\n    if bracket_opened:\n        corrected_result.append(']')\n    return ''.join(corrected_result).replace(']', '', 1)"], "requirement": [], "outputs": "[['a[a'], ['a[a]a'], ['a[ab[b]]bc[c]]c]c'], ['a[ab[b]c[c]'], ['abcdef[f]fg'], ['abcdefg'], ['a[a]ab[b]]b]bc[c]]cd[d]ef'], ['a[a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a]a'], ['12345'], ['Please enter a valid string'], ['Please enter a valid string'], ['!@#$%^&*()'], ['AaAaA'], ['A[A]Ab[b]CcDdEe'], ['   '], ['a b c d e f g'], ['a[ab[b]c[c]d[d]e[e]F[F]G[G]H[H]']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.8816669763807745, "llm_generated_inputs": "[['aa'], ['aaa'], ['aabbbcccc'], ['aabbcc'], ['abcdefffg'], ['abcdefg'], ['aaabbbbcccddef'], ['aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'], ['12345'], [12345], [None], ['!@#$%^&*()'], ['AaAaA'], ['AAAbbCcDdEe'], ['   '], ['a b c d e f g'], ['aabbccddeeFFGGHH']]", "input_output_examples": "[[['aaaabbcdefffffffg']], [['aa[aa]bbcdeff[fffff]g']]]", "at_least_one_align": false}, "entry_point": "string_parse", "ground_truth": -1}
{"task_id": "TACO_lite/37", "requirement": "from typing import List\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n\"\"\"Every Friday and Saturday night, farmer counts amount of sheep returned back to his farm (sheep returned on Friday stay and don't leave for a weekend).\n\nSheep return in groups each of the days -> you will be given two arrays with these numbers (one for Friday and one for Saturday night). Entries are always positive ints, higher than zero.\n\nFarmer knows the total amount of sheep, this is a third parameter. You need to return the amount of sheep lost (not returned to the farm) after final sheep counting on Saturday.\n\nGood luck! :-)\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_sheep = sum(friday)\n    saturday_sheep = sum(saturday)\n    returned_sheep = friday_sheep + saturday_sheep\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_sheep = sum(friday)\n    saturday_sheep = sum(saturday)\n    returned_sheep = friday_sheep + saturday_sheep\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_sheep = sum(friday)\n    saturday_sheep = sum(saturday)\n    total_returned = friday_sheep + saturday_sheep\n    lost_sheep = total - total_returned\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_friday = sum(friday)\n    returned_saturday = sum(saturday)\n    total_returned = returned_friday + returned_saturday\n    lost = total - total_returned\n    return lost", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_total = sum(friday)\n    saturday_total = sum(saturday)\n    returned_sheep = friday_total + saturday_total\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_total = sum(friday)\n    saturday_total = sum(saturday)\n    returned_total = friday_total + saturday_total\n    lost_sheep = total - returned_total\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_sheep = sum(friday)\n    saturday_sheep = sum(saturday)\n    returned_sheep = friday_sheep + saturday_sheep\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_total = sum(friday)\n    saturday_total = sum(saturday)\n    returned_sheep = friday_total + saturday_total\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_sum = sum(friday)\n    saturday_sum = sum(saturday)\n    returned_sheep = friday_sum + saturday_sum\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_sheep = sum(friday)\n    saturday_sheep = sum(saturday)\n    total_returned = friday_sheep + saturday_sheep\n    lost_sheep = total - total_returned\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    \"\"\"\n    Calculate the number of sheep lost after counting on Friday and Saturday nights.\n\n    Args:\n    friday (List[int]): List of sheep counts returning on Friday.\n    saturday (List[int]): List of sheep counts returning on Saturday.\n    total (int): Total number of sheep.\n\n    Returns:\n    int: Number of sheep lost.\n    \"\"\"\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_sheep = sum(friday)\n    saturday_sheep = sum(saturday)\n    total_returned = friday_sheep + saturday_sheep\n    lost_sheep = total - total_returned\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    \"\"\"\n    Calculate the number of sheep lost after counting on Friday and Saturday.\n\n    :param friday: List of positive integers representing groups of sheep returning on Friday.\n    :param saturday: List of positive integers representing groups of sheep returning on Saturday.\n    :param total: Total number of sheep that should have returned.\n    :return: Number of sheep lost.\n    \"\"\"\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    friday_sheep = sum(friday)\n    saturday_sheep = sum(saturday)\n    returned_sheep = friday_sheep + saturday_sheep\n    lost_sheep = total - returned_sheep\n    return lost_sheep", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep"], "requirement": [], "outputs": "[[4], [0], [10], [0], [1], [1], [-6], [5], [0], [0], [50], [0], [0], [0], [0], [3], [-5]]", "probability": 0.88, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep if lost_sheep >= 0 else 0", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep if lost_sheep >= 0 else 0", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return max(0, lost_sheep)", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep if lost_sheep >= 0 else 0", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    returned_friday = sum(friday)\n    returned_saturday = sum(saturday)\n    total_returned = returned_friday + returned_saturday\n    lost = total - total_returned\n    return lost if lost >= 0 else 0", "from typing import List\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n    \"\"\"\n    Calculate the number of sheep lost after counting on Friday and Saturday.\n\n    Args:\n    friday (List[int]): A list of positive integers representing groups of sheep that returned on Friday.\n    saturday (List[int]): A list of positive integers representing groups of sheep that returned on Saturday.\n    total (int): The total number of sheep.\n\n    Returns:\n    int: The number of sheep that are lost.\n    \"\"\"\n    returned_sheep = sum(friday) + sum(saturday)\n    lost_sheep = total - returned_sheep\n    return lost_sheep if lost_sheep >= 0 else 0"], "requirement": [], "outputs": "[[4], [0], [10], [0], [1], [1], [0], [5], [0], [0], [50], [0], [0], [0], [0], [3], [0]]", "probability": 0.12, "is_align_req": false, "DRS": null}], "entropy": 0.3669249912727096, "llm_generated_inputs": "[[[1, 2, 3], [4, 5, 6], 25], [[5, 5, 5], [5, 5, 5], 30], [[10], [20], 40], [[], [], 0], [[1, 2, 3], [], 7], [[], [1, 2, 3], 7], [[1, 2, 3], [4, 5, 6], 15], [[1, 2], [3, 4], 15], [[10, 20], [30, 40], 100], [[1, 1, 1], [1, 1, 1], 6], [[100], [200], 350], [[5, 5, 5, 5], [10, 10, 10, 10], 60], [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], 55], [[1, 2, 3, 4], [5, 6, 7, 8], 36], [[1, 1, 1, 1, 1], [2, 2, 2, 2, 2], 15], [[2, 4, 6], [8, 10, 12], 45], [[5, 10, 15], [20, 25, 30], 100]]", "input_output_examples": "[[[[1, 2], [3, 4], 15], [[3, 1, 2], [4, 5], 21]], [[5], [6]]]", "at_least_one_align": false}, "entry_point": "lostsheep", "ground_truth": -1}
{"task_id": "TACO_lite/38", "requirement": "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n\"\"\"Base on the fairy tale [Diamonds and Toads](https://en.wikipedia.org/wiki/Diamonds_and_Toads) from Charles Perrault. In this kata you will have to complete a function that take 2 arguments: \n\n- A string, that correspond to what the daugther says.\n- A string, that tell you wich fairy the girl have met, this one can be `good` or `evil`. \n\nThe function should return the following count as a hash:\n\n- If the girl have met the `good` fairy:\n  - count 1 `ruby` everytime you see a `r` and 2 everytime you see a `R`\n  - count 1 `crystal` everytime you see a `c` and 2 everytime you see a `C`\n- If the girl have met the `evil` fairy: \n  - count 1 `python` everytime you see a `p` and 2 everytime uou see a `P`\n  - count 1 `squirrel` everytime you see a `s` and 2 everytime you see a `S`\n  \n**Note**: For this kata I decided to remplace the normal `Diamonds` and `Toads` by some programming languages. And just discover that [Squirrel](https://en.wikipedia.org/wiki/Squirrel_(programming_language) is a programming language.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    good_fairy_mapping = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy_mapping = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    counter = collections.defaultdict(int)\n    if fairy == 'good':\n        for char in sentence:\n            if char in good_fairy_mapping:\n                counter['ruby' if char in 'rR' else 'crystal'] += good_fairy_mapping[char]\n    elif fairy == 'evil':\n        for char in sentence:\n            if char in evil_fairy_mapping:\n                counter['python' if char in 'pP' else 'squirrel'] += evil_fairy_mapping[char]\n    return dict(counter)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import defaultdict\n    counts = defaultdict(int)\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                counts['ruby'] += 1\n            elif char == 'R':\n                counts['ruby'] += 2\n            elif char == 'c':\n                counts['crystal'] += 1\n            elif char == 'C':\n                counts['crystal'] += 2\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                counts['python'] += 1\n            elif char == 'P':\n                counts['python'] += 2\n            elif char == 's':\n                counts['squirrel'] += 1\n            elif char == 'S':\n                counts['squirrel'] += 2\n    return dict(counts)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = collections.defaultdict(int)\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                counts['ruby'] += 1\n            elif char == 'R':\n                counts['ruby'] += 2\n            elif char == 'c':\n                counts['crystal'] += 1\n            elif char == 'C':\n                counts['crystal'] += 2\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                counts['python'] += 1\n            elif char == 'P':\n                counts['python'] += 2\n            elif char == 's':\n                counts['squirrel'] += 1\n            elif char == 'S':\n                counts['squirrel'] += 2\n    return dict(counts)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    result = collections.defaultdict(int)\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                result['ruby'] += 1\n            elif char == 'R':\n                result['ruby'] += 2\n            elif char == 'c':\n                result['crystal'] += 1\n            elif char == 'C':\n                result['crystal'] += 2\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                result['python'] += 1\n            elif char == 'P':\n                result['python'] += 2\n            elif char == 's':\n                result['squirrel'] += 1\n            elif char == 'S':\n                result['squirrel'] += 2\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = collections.Counter()\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                counts['ruby'] += 1\n            elif char == 'R':\n                counts['ruby'] += 2\n            elif char == 'c':\n                counts['crystal'] += 1\n            elif char == 'C':\n                counts['crystal'] += 2\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                counts['python'] += 1\n            elif char == 'P':\n                counts['python'] += 2\n            elif char == 's':\n                counts['squirrel'] += 1\n            elif char == 'S':\n                counts['squirrel'] += 2\n    return dict(counts)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    result = collections.defaultdict(int)\n    if fairy == 'good':\n        letter_mapping = {'r': ('ruby', 1), 'R': ('ruby', 2), 'c': ('crystal', 1), 'C': ('crystal', 2)}\n    elif fairy == 'evil':\n        letter_mapping = {'p': ('python', 1), 'P': ('python', 2), 's': ('squirrel', 1), 'S': ('squirrel', 2)}\n    else:\n        raise ValueError(\"Invalid fairy type. It should be either 'good' or 'evil'.\")\n    for char in sentence:\n        if char in letter_mapping:\n            item, count = letter_mapping[char]\n            result[item] += count\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = collections.defaultdict(int)\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                counts['ruby'] += 1\n            elif char == 'R':\n                counts['ruby'] += 2\n            elif char == 'c':\n                counts['crystal'] += 1\n            elif char == 'C':\n                counts['crystal'] += 2\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                counts['python'] += 1\n            elif char == 'P':\n                counts['python'] += 2\n            elif char == 's':\n                counts['squirrel'] += 1\n            elif char == 'S':\n                counts['squirrel'] += 2\n    return dict(counts)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import defaultdict\n    result = defaultdict(int)\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                result['ruby'] += 1\n            elif char == 'R':\n                result['ruby'] += 2\n            elif char == 'c':\n                result['crystal'] += 1\n            elif char == 'C':\n                result['crystal'] += 2\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                result['python'] += 1\n            elif char == 'P':\n                result['python'] += 2\n            elif char == 's':\n                result['squirrel'] += 1\n            elif char == 'S':\n                result['squirrel'] += 2\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    good_fairy_mapping = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy_mapping = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    result = collections.defaultdict(int)\n    if fairy == 'good':\n        for char in sentence:\n            if char in good_fairy_mapping:\n                result['ruby' if char.lower() == 'r' else 'crystal'] += good_fairy_mapping[char]\n    elif fairy == 'evil':\n        for char in sentence:\n            if char in evil_fairy_mapping:\n                result['python' if char.lower() == 'p' else 'squirrel'] += evil_fairy_mapping[char]\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    item_counts = collections.defaultdict(int)\n    if fairy == 'good':\n        char_to_item = {'r': 'ruby', 'R': 'ruby', 'c': 'crystal', 'C': 'crystal'}\n        multiplier = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    elif fairy == 'evil':\n        char_to_item = {'p': 'python', 'P': 'python', 's': 'squirrel', 'S': 'squirrel'}\n        multiplier = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    else:\n        return {}\n    for char in sentence:\n        if char in char_to_item:\n            item_counts[char_to_item[char]] += multiplier[char]\n    return dict(item_counts)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = collections.defaultdict(int)\n    fairy_rules = {'good': {'r': 'ruby', 'R': 'ruby', 'c': 'crystal', 'C': 'crystal'}, 'evil': {'p': 'python', 'P': 'python', 's': 'squirrel', 'S': 'squirrel'}}\n    multiplier = lambda char: 2 if char.isupper() else 1\n    if fairy not in fairy_rules:\n        raise ValueError(\"Fairy must be either 'good' or 'evil'\")\n    for char in sentence:\n        if char.lower() in fairy_rules[fairy]:\n            item = fairy_rules[fairy][char]\n            counts[item] += multiplier(char)\n    return dict(counts)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import Counter\n    item_counts = Counter()\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                item_counts['ruby'] += 1\n            elif char == 'R':\n                item_counts['ruby'] += 2\n            elif char == 'c':\n                item_counts['crystal'] += 1\n            elif char == 'C':\n                item_counts['crystal'] += 2\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                item_counts['python'] += 1\n            elif char == 'P':\n                item_counts['python'] += 2\n            elif char == 's':\n                item_counts['squirrel'] += 1\n            elif char == 'S':\n                item_counts['squirrel'] += 2\n    return dict(item_counts)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = {'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}\n    for char in sentence:\n        if fairy == 'good':\n            if char == 'r':\n                counts['ruby'] += 1\n            elif char == 'R':\n                counts['ruby'] += 2\n            elif char == 'c':\n                counts['crystal'] += 1\n            elif char == 'C':\n                counts['crystal'] += 2\n        elif fairy == 'evil':\n            if char == 'p':\n                counts['python'] += 1\n            elif char == 'P':\n                counts['python'] += 2\n            elif char == 's':\n                counts['squirrel'] += 1\n            elif char == 'S':\n                counts['squirrel'] += 2\n    return {k: v for k, v in counts.items() if v != 0}", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    result = {}\n    good_fairy_mapping = {'r': 'ruby', 'R': 'ruby', 'c': 'crystal', 'C': 'crystal'}\n    evil_fairy_mapping = {'p': 'python', 'P': 'python', 's': 'squirrel', 'S': 'squirrel'}\n    multiplier = lambda char: 2 if char.isupper() else 1\n    if fairy == 'good':\n        mapping = good_fairy_mapping\n    elif fairy == 'evil':\n        mapping = evil_fairy_mapping\n    else:\n        raise ValueError(\"The fairy argument must be either 'good' or 'evil'.\")\n    for char in sentence:\n        if char.lower() in mapping or char.upper() in mapping:\n            item = mapping[char]\n            result[item] = result.get(item, 0) + multiplier(char)\n    return result", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = {'good': {'ruby': 0, 'crystal': 0}, 'evil': {'python': 0, 'squirrel': 0}}\n    for char in sentence:\n        if fairy == 'good':\n            if char == 'r':\n                counts['good']['ruby'] += 1\n            elif char == 'R':\n                counts['good']['ruby'] += 2\n            elif char == 'c':\n                counts['good']['crystal'] += 1\n            elif char == 'C':\n                counts['good']['crystal'] += 2\n        elif fairy == 'evil':\n            if char == 'p':\n                counts['evil']['python'] += 1\n            elif char == 'P':\n                counts['evil']['python'] += 2\n            elif char == 's':\n                counts['evil']['squirrel'] += 1\n            elif char == 'S':\n                counts['evil']['squirrel'] += 2\n    return {k: v for k, v in counts[fairy].items() if v > 0}", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    result = {'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                result['ruby'] += 1\n            elif char == 'R':\n                result['ruby'] += 2\n            elif char == 'c':\n                result['crystal'] += 1\n            elif char == 'C':\n                result['crystal'] += 2\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                result['python'] += 1\n            elif char == 'P':\n                result['python'] += 2\n            elif char == 's':\n                result['squirrel'] += 1\n            elif char == 'S':\n                result['squirrel'] += 2\n    result = {k: v for k, v in result.items() if v != 0}\n    return result", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    good_fairy_mapping = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy_mapping = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    result = collections.defaultdict(int)\n    if fairy == 'good':\n        for char in sentence:\n            if char in good_fairy_mapping:\n                result['ruby' if char.lower() == 'r' else 'crystal'] += good_fairy_mapping[char]\n    elif fairy == 'evil':\n        for char in sentence:\n            if char in evil_fairy_mapping:\n                result['python' if char.lower() == 'p' else 'squirrel'] += evil_fairy_mapping[char]\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = collections.defaultdict(int)\n    if fairy == 'good':\n        counts['ruby'] = sum([2 if ch == 'R' else 1 if ch == 'r' else 0 for ch in sentence])\n        counts['crystal'] = sum([2 if ch == 'C' else 1 if ch == 'c' else 0 for ch in sentence])\n    elif fairy == 'evil':\n        counts['python'] = sum([2 if ch == 'P' else 1 if ch == 'p' else 0 for ch in sentence])\n        counts['squirrel'] = sum([2 if ch == 'S' else 1 if ch == 's' else 0 for ch in sentence])\n    return {k: v for k, v in counts.items() if v > 0}", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = collections.defaultdict(int)\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                counts['ruby'] += 1\n            elif char == 'R':\n                counts['ruby'] += 2\n            elif char == 'c':\n                counts['crystal'] += 1\n            elif char == 'C':\n                counts['crystal'] += 2\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                counts['python'] += 1\n            elif char == 'P':\n                counts['python'] += 2\n            elif char == 's':\n                counts['squirrel'] += 1\n            elif char == 'S':\n                counts['squirrel'] += 2\n    return dict(counts)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    counts = {'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}\n    chars = list(sentence)\n    for char in chars:\n        if fairy == 'good':\n            if char == 'r':\n                counts['ruby'] += 1\n            elif char == 'R':\n                counts['ruby'] += 2\n            elif char == 'c':\n                counts['crystal'] += 1\n            elif char == 'C':\n                counts['crystal'] += 2\n        elif fairy == 'evil':\n            if char == 'p':\n                counts['python'] += 1\n            elif char == 'P':\n                counts['python'] += 2\n            elif char == 's':\n                counts['squirrel'] += 1\n            elif char == 'S':\n                counts['squirrel'] += 2\n    result = {key: value for key, value in counts.items() if value > 0}\n    return result", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    if fairy == 'good':\n        count_map = {'r': ('ruby', 1), 'R': ('ruby', 2), 'c': ('crystal', 1), 'C': ('crystal', 2)}\n    elif fairy == 'evil':\n        count_map = {'p': ('python', 1), 'P': ('python', 2), 's': ('squirrel', 1), 'S': ('squirrel', 2)}\n    else:\n        return {}\n    item_counter = collections.Counter()\n    for char in sentence:\n        if char in count_map:\n            item, count = count_map[char]\n            item_counter[item] += count\n    return dict(item_counter)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import defaultdict\n    result = defaultdict(int)\n    good_fairy_mapping = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy_mapping = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    if fairy == 'good':\n        mapping = good_fairy_mapping\n        result_keys = {'r': 'ruby', 'R': 'ruby', 'c': 'crystal', 'C': 'crystal'}\n    elif fairy == 'evil':\n        mapping = evil_fairy_mapping\n        result_keys = {'p': 'python', 'P': 'python', 's': 'squirrel', 'S': 'squirrel'}\n    else:\n        return {}\n    for char in sentence:\n        if char in mapping:\n            result[result_keys[char]] += mapping[char]\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import Counter\n    result = {'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}\n    if fairy == 'good':\n        char_map = {'r': ('ruby', 1), 'R': ('ruby', 2), 'c': ('crystal', 1), 'C': ('crystal', 2)}\n    elif fairy == 'evil':\n        char_map = {'p': ('python', 1), 'P': ('python', 2), 's': ('squirrel', 1), 'S': ('squirrel', 2)}\n    else:\n        return result\n    for char in sentence:\n        if char in char_map:\n            item, count = char_map[char]\n            result[item] += count\n    return {key: value for key, value in result.items() if value != 0}", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import defaultdict\n    result = defaultdict(int)\n    good_fairy_mapping = {'r': 'ruby', 'R': 'ruby', 'c': 'crystal', 'C': 'crystal'}\n    evil_fairy_mapping = {'p': 'python', 'P': 'python', 's': 'squirrel', 'S': 'squirrel'}\n    multiplier = {'r': 1, 'R': 2, 'c': 1, 'C': 2, 'p': 1, 'P': 2, 's': 1, 'S': 2}\n    if fairy == 'good':\n        char_mapping = good_fairy_mapping\n    elif fairy == 'evil':\n        char_mapping = evil_fairy_mapping\n    else:\n        raise ValueError(\"Fairy must be either 'good' or 'evil'\")\n    for char in sentence:\n        if char in char_mapping:\n            item = char_mapping[char]\n            result[item] += multiplier[char]\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counters = {'good': {'r': ('ruby', 1), 'R': ('ruby', 2), 'c': ('crystal', 1), 'C': ('crystal', 2)}, 'evil': {'p': ('python', 1), 'P': ('python', 2), 's': ('squirrel', 1), 'S': ('squirrel', 2)}}\n    if fairy not in counters:\n        raise ValueError(\"The fairy argument must be either 'good' or 'evil'\")\n    count_dict = collections.defaultdict(int)\n    for char in sentence:\n        if char in counters[fairy]:\n            item, count = counters[fairy][char]\n            count_dict[item] += count\n    return dict(count_dict)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    result = {'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                result['ruby'] += 1\n            elif char == 'R':\n                result['ruby'] += 2\n            elif char == 'c':\n                result['crystal'] += 1\n            elif char == 'C':\n                result['crystal'] += 2\n        result = {k: v for k, v in result.items() if v != 0 and k in ('ruby', 'crystal')}\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                result['python'] += 1\n            elif char == 'P':\n                result['python'] += 2\n            elif char == 's':\n                result['squirrel'] += 1\n            elif char == 'S':\n                result['squirrel'] += 2\n        result = {k: v for k, v in result.items() if v != 0 and k in ('python', 'squirrel')}\n    return result", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = {'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}\n    if fairy == 'good':\n        char_mapping = {'r': ('ruby', 1), 'R': ('ruby', 2), 'c': ('crystal', 1), 'C': ('crystal', 2)}\n    elif fairy == 'evil':\n        char_mapping = {'p': ('python', 1), 'P': ('python', 2), 's': ('squirrel', 1), 'S': ('squirrel', 2)}\n    else:\n        return counts\n    for char in sentence:\n        if char in char_mapping:\n            item, value = char_mapping[char]\n            counts[item] += value\n    return {k: v for k, v in counts.items() if v > 0}", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import Counter\n    counts = {'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}\n    if fairy == 'good':\n        for char in sentence:\n            if char == 'r':\n                counts['ruby'] += 1\n            elif char == 'R':\n                counts['ruby'] += 2\n            elif char == 'c':\n                counts['crystal'] += 1\n            elif char == 'C':\n                counts['crystal'] += 2\n    elif fairy == 'evil':\n        for char in sentence:\n            if char == 'p':\n                counts['python'] += 1\n            elif char == 'P':\n                counts['python'] += 2\n            elif char == 's':\n                counts['squirrel'] += 1\n            elif char == 'S':\n                counts['squirrel'] += 2\n    counts = {key: value for key, value in counts.items() if value > 0}\n    return counts", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import defaultdict\n    result = defaultdict(int)\n    good_fairy_map = {'r': 'ruby', 'R': 'ruby', 'c': 'crystal', 'C': 'crystal'}\n    evil_fairy_map = {'p': 'python', 'P': 'python', 's': 'squirrel', 'S': 'squirrel'}\n    multiplier = {'r': 1, 'R': 2, 'c': 1, 'C': 2, 'p': 1, 'P': 2, 's': 1, 'S': 2}\n    if fairy == 'good':\n        char_map = good_fairy_map\n    elif fairy == 'evil':\n        char_map = evil_fairy_map\n    else:\n        raise ValueError(\"fairy must be either 'good' or 'evil'\")\n    for char in sentence:\n        if char in char_map:\n            item = char_map[char]\n            result[item] += multiplier[char]\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import defaultdict\n    counts = defaultdict(int)\n    good_fairy_mapping = {'r': 'ruby', 'R': 'ruby', 'c': 'crystal', 'C': 'crystal'}\n    evil_fairy_mapping = {'p': 'python', 'P': 'python', 's': 'squirrel', 'S': 'squirrel'}\n    if fairy == 'good':\n        mapping = good_fairy_mapping\n        multiplier_dict = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    elif fairy == 'evil':\n        mapping = evil_fairy_mapping\n        multiplier_dict = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    else:\n        raise ValueError(\"fairy must be either 'good' or 'evil'\")\n    for char in sentence:\n        if char in mapping:\n            item = mapping[char]\n            multiplier = multiplier_dict[char]\n            counts[item] += multiplier\n    return dict(counts)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = {'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}\n    good_fairy_mapping = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy_mapping = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    if fairy == 'good':\n        char_mapping = good_fairy_mapping\n        item_names = {'r': 'ruby', 'R': 'ruby', 'c': 'crystal', 'C': 'crystal'}\n    elif fairy == 'evil':\n        char_mapping = evil_fairy_mapping\n        item_names = {'p': 'python', 'P': 'python', 's': 'squirrel', 'S': 'squirrel'}\n    else:\n        return counts\n    for char in sentence:\n        if char in char_mapping:\n            counts[item_names[char]] += char_mapping[char]\n    result = {item: count for item, count in counts.items() if count > 0}\n    return result", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import defaultdict\n    result = defaultdict(int)\n    good_fairy = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    if fairy == 'good':\n        mapping = good_fairy\n        keys = ('ruby', 'crystal')\n    elif fairy == 'evil':\n        mapping = evil_fairy\n        keys = ('python', 'squirrel')\n    else:\n        return {}\n    for char in sentence:\n        if char in mapping:\n            result[keys[0 if char.lower() == list(mapping.keys())[0].lower() else 1]] += mapping[char]\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import defaultdict\n\n    def count_occurrences(letter_lower, letter_upper, word_lower, word_upper, sentence):\n        counts = defaultdict(int)\n        for char in sentence:\n            if char == letter_lower:\n                counts[word_lower] += 1\n            elif char == letter_upper:\n                counts[word_upper] += 2\n        return counts\n    result = defaultdict(int)\n    if fairy == 'good':\n        good_counts = count_occurrences('r', 'R', 'ruby', 'ruby', sentence)\n        result.update(good_counts)\n        good_counts = count_occurrences('c', 'C', 'crystal', 'crystal', sentence)\n        result.update(good_counts)\n    elif fairy == 'evil':\n        evil_counts = count_occurrences('p', 'P', 'python', 'python', sentence)\n        result.update(evil_counts)\n        evil_counts = count_occurrences('s', 'S', 'squirrel', 'squirrel', sentence)\n        result.update(evil_counts)\n    return dict(result)"], "requirement": [], "outputs": "[[{'ruby': 3, 'crystal': 1}], [{'ruby': 4}], [{'crystal': 3, 'ruby': 2}], [{'ruby': 6, 'crystal': 6}], [{'ruby': 3, 'crystal': 1}], [{'python': 4}], [{'squirrel': 3}], [{'python': 6, 'squirrel': 6}], [{'python': 3, 'squirrel': 3}], [{}], [{}], [{'ruby': 1}], [{}], [{'ruby': 3, 'crystal': 3}], [{'python': 3, 'squirrel': 3}]]", "probability": 0.66, "is_align_req": false, "DRS": null}, {"programs_str": ["def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n\n    def count_characters(target_chars, sentence):\n        counter = collections.Counter({char: 0 for char in target_chars})\n        for char in sentence:\n            if char in target_chars:\n                counter[char] += 1\n            elif char.swapcase() in target_chars:\n                counter[char.swapcase()] += 2\n        return counter\n    if fairy == 'good':\n        counts = count_characters('rRcC', sentence)\n        return {'ruby': counts['r'] + counts['R'], 'crystal': counts['c'] + counts['C']}\n    elif fairy == 'evil':\n        counts = count_characters('pPsS', sentence)\n        return {'python': counts['p'] + counts['P'], 'squirrel': counts['s'] + counts['S']}\n    else:\n        return {}"], "requirement": [], "outputs": "[[{'ruby': 3, 'crystal': 1}], [{'ruby': 2, 'crystal': 0}], [{'ruby': 2, 'crystal': 2}], [{'ruby': 4, 'crystal': 4}], [{'ruby': 3, 'crystal': 1}], [{'python': 2, 'squirrel': 0}], [{'python': 0, 'squirrel': 2}], [{'python': 4, 'squirrel': 4}], [{'python': 2, 'squirrel': 2}], [{'ruby': 0, 'crystal': 0}], [{'python': 0, 'squirrel': 0}], [{'ruby': 1, 'crystal': 0}], [{'python': 0, 'squirrel': 0}], [{'ruby': 2, 'crystal': 2}], [{'python': 2, 'squirrel': 2}]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import Counter\n    if fairy == 'good':\n        ruby_count = sum((1 if char == 'r' else 2 if char == 'R' else 0 for char in sentence))\n        crystal_count = sum((1 if char == 'c' else 2 if char == 'C' else 0 for char in sentence))\n        return {'ruby': ruby_count, 'crystal': crystal_count}\n    elif fairy == 'evil':\n        python_count = sum((1 if char == 'p' else 2 if char == 'P' else 0 for char in sentence))\n        squirrel_count = sum((1 if char == 's' else 2 if char == 'S' else 0 for char in sentence))\n        return {'python': python_count, 'squirrel': squirrel_count}\n    else:\n        raise ValueError(\"fairy must be either 'good' or 'evil'\")", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    if fairy == 'good':\n        result = {'ruby': 0, 'crystal': 0}\n        counts = {'r': ('ruby', 1), 'R': ('ruby', 2), 'c': ('crystal', 1), 'C': ('crystal', 2)}\n    elif fairy == 'evil':\n        result = {'python': 0, 'squirrel': 0}\n        counts = {'p': ('python', 1), 'P': ('python', 2), 's': ('squirrel', 1), 'S': ('squirrel', 2)}\n    else:\n        raise ValueError(\"Fairy must be either 'good' or 'evil'\")\n    for char in sentence:\n        if char in counts:\n            item, value = counts[char]\n            result[item] += value\n    return result", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = collections.defaultdict(int)\n    if fairy == 'good':\n        counts['ruby'] = sum((2 if char == 'R' else 1 if char == 'r' else 0 for char in sentence))\n        counts['crystal'] = sum((2 if char == 'C' else 1 if char == 'c' else 0 for char in sentence))\n    elif fairy == 'evil':\n        counts['python'] = sum((2 if char == 'P' else 1 if char == 'p' else 0 for char in sentence))\n        counts['squirrel'] = sum((2 if char == 'S' else 1 if char == 's' else 0 for char in sentence))\n    else:\n        raise ValueError(\"Fairy must be either 'good' or 'evil'\")\n    return dict(counts)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    if fairy == 'good':\n        gem_counter = {'ruby': 0, 'crystal': 0}\n        sentence = collections.Counter(sentence)\n        gem_counter['ruby'] = sentence['r'] + sentence['R'] * 2\n        gem_counter['crystal'] = sentence['c'] + sentence['C'] * 2\n    elif fairy == 'evil':\n        creature_counter = {'python': 0, 'squirrel': 0}\n        sentence = collections.Counter(sentence)\n        creature_counter['python'] = sentence['p'] + sentence['P'] * 2\n        creature_counter['squirrel'] = sentence['s'] + sentence['S'] * 2\n    else:\n        return {}\n    return gem_counter if fairy == 'good' else creature_counter", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import defaultdict\n    result = defaultdict(int)\n    if fairy == 'good':\n        result['ruby'] = sum((2 if char == 'R' else 1 if char == 'r' else 0 for char in sentence))\n        result['crystal'] = sum((2 if char == 'C' else 1 if char == 'c' else 0 for char in sentence))\n    elif fairy == 'evil':\n        result['python'] = sum((2 if char == 'P' else 1 if char == 'p' else 0 for char in sentence))\n        result['squirrel'] = sum((2 if char == 'S' else 1 if char == 's' else 0 for char in sentence))\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import Counter\n    if fairy == 'good':\n        gem_counts = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n        result = {'ruby': 0, 'crystal': 0}\n    elif fairy == 'evil':\n        gem_counts = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n        result = {'python': 0, 'squirrel': 0}\n    else:\n        raise ValueError(\"The fairy argument must be either 'good' or 'evil'.\")\n    counter = Counter(sentence)\n    for char in counter:\n        if char in gem_counts:\n            if fairy == 'good':\n                if char.lower() == 'r':\n                    result['ruby'] += gem_counts[char] * counter[char]\n                elif char.lower() == 'c':\n                    result['crystal'] += gem_counts[char] * counter[char]\n            elif fairy == 'evil':\n                if char.lower() == 'p':\n                    result['python'] += gem_counts[char] * counter[char]\n                elif char.lower() == 's':\n                    result['squirrel'] += gem_counts[char] * counter[char]\n    return result", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import Counter\n    if fairy == 'good':\n        scores = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n        result = {'ruby': 0, 'crystal': 0}\n    elif fairy == 'evil':\n        scores = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n        result = {'python': 0, 'squirrel': 0}\n    else:\n        raise ValueError(\"Fairy must be either 'good' or 'evil'\")\n    for char in sentence:\n        if char in scores:\n            if fairy == 'good':\n                if char in ['r', 'R']:\n                    result['ruby'] += scores[char]\n                elif char in ['c', 'C']:\n                    result['crystal'] += scores[char]\n            elif fairy == 'evil':\n                if char in ['p', 'P']:\n                    result['python'] += scores[char]\n                elif char in ['s', 'S']:\n                    result['squirrel'] += scores[char]\n    return result", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    if fairy == 'good':\n        count_map = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n        result = {'ruby': 0, 'crystal': 0}\n    elif fairy == 'evil':\n        count_map = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n        result = {'python': 0, 'squirrel': 0}\n    else:\n        raise ValueError(\"fairy must be either 'good' or 'evil'\")\n    for char in sentence:\n        if char in count_map:\n            if fairy == 'good' and (char.lower() == 'r' or char.lower() == 'c'):\n                item = 'ruby' if char.lower() == 'r' else 'crystal'\n                result[item] += count_map[char]\n            elif fairy == 'evil' and (char.lower() == 'p' or char.lower() == 's'):\n                item = 'python' if char.lower() == 'p' else 'squirrel'\n                result[item] += count_map[char]\n    return result", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    result = collections.defaultdict(int)\n    good_fairy_rules = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy_rules = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    if fairy == 'good':\n        rules = good_fairy_rules\n        result['ruby'] = 0\n        result['crystal'] = 0\n    elif fairy == 'evil':\n        rules = evil_fairy_rules\n        result['python'] = 0\n        result['squirrel'] = 0\n    else:\n        return {}\n    for char in sentence:\n        if char in rules:\n            count = rules[char]\n            if fairy == 'good':\n                if char.lower() == 'r':\n                    result['ruby'] += count\n                elif char.lower() == 'c':\n                    result['crystal'] += count\n            elif fairy == 'evil':\n                if char.lower() == 'p':\n                    result['python'] += count\n                elif char.lower() == 's':\n                    result['squirrel'] += count\n    return dict(result)", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import Counter\n    if fairy == 'good':\n        gem_rules = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n        result = {'ruby': 0, 'crystal': 0}\n    elif fairy == 'evil':\n        gem_rules = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n        result = {'python': 0, 'squirrel': 0}\n    else:\n        raise ValueError(\"The fairy argument must be 'good' or 'evil'\")\n    counter = Counter()\n    for char in sentence:\n        if char in gem_rules:\n            count = gem_rules[char]\n            if char.islower():\n                if fairy == 'good':\n                    counter['ruby'] += count if char == 'r' else 0\n                    counter['crystal'] += count if char == 'c' else 0\n                elif fairy == 'evil':\n                    counter['python'] += count if char == 'p' else 0\n                    counter['squirrel'] += count if char == 's' else 0\n            elif fairy == 'good':\n                counter['ruby'] += count if char == 'R' else 0\n                counter['crystal'] += count if char == 'C' else 0\n            elif fairy == 'evil':\n                counter['python'] += count if char == 'P' else 0\n                counter['squirrel'] += count if char == 'S' else 0\n    for key in result:\n        result[key] = counter[key]\n    return result", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import Counter\n    if fairy == 'good':\n        item_counts = {'ruby': 0, 'crystal': 0}\n        letter_values = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    elif fairy == 'evil':\n        item_counts = {'python': 0, 'squirrel': 0}\n        letter_values = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    else:\n        raise ValueError(\"fairy must be either 'good' or 'evil'\")\n    item_mapping = {('r', 'R'): 'ruby' if fairy == 'good' else None, ('c', 'C'): 'crystal' if fairy == 'good' else None, ('p', 'P'): 'python' if fairy == 'evil' else None, ('s', 'S'): 'squirrel' if fairy == 'evil' else None}\n    for char in sentence:\n        if char in letter_values:\n            value = letter_values[char]\n            item = next((v for k, v in item_mapping.items() if char in k and v), None)\n            if item:\n                item_counts[item] += value\n    return item_counts", "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    good_fairy_rules = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy_rules = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    item_counts = collections.Counter()\n    if fairy == 'good':\n        rules = good_fairy_rules\n        item_counts['ruby'] = 0\n        item_counts['crystal'] = 0\n    elif fairy == 'evil':\n        rules = evil_fairy_rules\n        item_counts['python'] = 0\n        item_counts['squirrel'] = 0\n    else:\n        return {}\n    for char in sentence:\n        if char in rules:\n            key = 'ruby' if char.lower() == 'r' else 'crystal' if char.lower() == 'c' else 'python' if char.lower() == 'p' else 'squirrel'\n            item_counts[key] += rules[char]\n    return dict(item_counts)"], "requirement": [], "outputs": "[[{'ruby': 3, 'crystal': 1}], [{'ruby': 4, 'crystal': 0}], [{'ruby': 2, 'crystal': 3}], [{'ruby': 6, 'crystal': 6}], [{'ruby': 3, 'crystal': 1}], [{'python': 4, 'squirrel': 0}], [{'python': 0, 'squirrel': 3}], [{'python': 6, 'squirrel': 6}], [{'python': 3, 'squirrel': 3}], [{'ruby': 0, 'crystal': 0}], [{'python': 0, 'squirrel': 0}], [{'ruby': 1, 'crystal': 0}], [{'python': 0, 'squirrel': 0}], [{'ruby': 3, 'crystal': 3}], [{'python': 3, 'squirrel': 3}]]", "probability": 0.24, "is_align_req": false, "DRS": null}, {"programs_str": ["def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import defaultdict\n    counts = defaultdict(int)\n    good_fairy_rules = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy_rules = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    if fairy == 'good':\n        rules = good_fairy_rules\n        result_keys = ['ruby', 'crystal']\n    elif fairy == 'evil':\n        rules = evil_fairy_rules\n        result_keys = ['python', 'squirrel']\n    else:\n        raise ValueError(\"Fairy must be 'good' or 'evil'\")\n    for char in sentence:\n        if char in rules:\n            counts[result_keys[0 if char.lower() in 'rc' else 1]] += rules[char]\n    return dict(counts)"], "requirement": [], "outputs": "[[{'ruby': 4}], [{'ruby': 4}], [{'ruby': 5}], [{'ruby': 12}], [{'ruby': 4}], [{'squirrel': 4}], [{'squirrel': 3}], [{'squirrel': 12}], [{'squirrel': 6}], [{}], [{}], [{'ruby': 1}], [{}], [{'ruby': 6}], [{'squirrel': 6}]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import Counter\n    count = {'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}\n    good_fairy_mapping = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy_mapping = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    if fairy == 'good':\n        mapping = good_fairy_mapping\n        items = ['ruby', 'crystal']\n    elif fairy == 'evil':\n        mapping = evil_fairy_mapping\n        items = ['python', 'squirrel']\n    else:\n        return count\n    for char in sentence:\n        if char in mapping:\n            index = items[0] if char.lower() in 'rc' else items[1]\n            count[index] += mapping[char]\n    return count"], "requirement": [], "outputs": "[[{'ruby': 4, 'crystal': 0, 'python': 0, 'squirrel': 0}], [{'ruby': 4, 'crystal': 0, 'python': 0, 'squirrel': 0}], [{'ruby': 5, 'crystal': 0, 'python': 0, 'squirrel': 0}], [{'ruby': 12, 'crystal': 0, 'python': 0, 'squirrel': 0}], [{'ruby': 4, 'crystal': 0, 'python': 0, 'squirrel': 0}], [{'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 4}], [{'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 3}], [{'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 12}], [{'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 6}], [{'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}], [{'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}], [{'ruby': 1, 'crystal': 0, 'python': 0, 'squirrel': 0}], [{'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}], [{'ruby': 6, 'crystal': 0, 'python': 0, 'squirrel': 0}], [{'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 6}]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    from collections import Counter\n    if fairy == 'good':\n        scores = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n        result_keys = ['ruby', 'crystal']\n    elif fairy == 'evil':\n        scores = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n        result_keys = ['python', 'squirrel']\n    else:\n        raise ValueError(\"fairy must be either 'good' or 'evil'\")\n    counts = Counter({key: 0 for key in result_keys})\n    for char in sentence:\n        if char in scores:\n            if char.islower():\n                counts[result_keys[0]] += scores[char]\n            else:\n                counts[result_keys[1]] += scores[char]\n    return dict(counts)"], "requirement": [], "outputs": "[[{'ruby': 4, 'crystal': 0}], [{'ruby': 0, 'crystal': 4}], [{'ruby': 3, 'crystal': 2}], [{'ruby': 4, 'crystal': 8}], [{'ruby': 4, 'crystal': 0}], [{'python': 0, 'squirrel': 4}], [{'python': 1, 'squirrel': 2}], [{'python': 4, 'squirrel': 8}], [{'python': 2, 'squirrel': 4}], [{'ruby': 0, 'crystal': 0}], [{'python': 0, 'squirrel': 0}], [{'ruby': 1, 'crystal': 0}], [{'python': 0, 'squirrel': 0}], [{'ruby': 2, 'crystal': 4}], [{'python': 2, 'squirrel': 4}]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n    import collections\n    counts = {'ruby': 0, 'crystal': 0, 'python': 0, 'squirrel': 0}\n    good_fairy_mapping = {'r': 1, 'R': 2, 'c': 1, 'C': 2}\n    evil_fairy_mapping = {'p': 1, 'P': 2, 's': 1, 'S': 2}\n    if fairy == 'good':\n        char_mapping = good_fairy_mapping\n        result_keys = ['ruby', 'crystal']\n    elif fairy == 'evil':\n        char_mapping = evil_fairy_mapping\n        result_keys = ['python', 'squirrel']\n    else:\n        raise ValueError(\"Invalid fairy type. Only 'good' or 'evil' are allowed.\")\n    for char in sentence:\n        if char in char_mapping:\n            counts[result_keys[0]] += char_mapping[char] if char.lower() == list(char_mapping.keys())[0].lower() else 0\n            counts[result_keys[1]] += char_mapping[char] if char.lower() == list(char_mapping.keys())[1].lower() else 0\n    return {key: counts[key] for key in result_keys}"], "requirement": [], "outputs": "[[{'ruby': 3, 'crystal': 3}], [{'ruby': 4, 'crystal': 4}], [{'ruby': 2, 'crystal': 2}], [{'ruby': 6, 'crystal': 6}], [{'ruby': 3, 'crystal': 3}], [{'python': 4, 'squirrel': 4}], [{'python': 0, 'squirrel': 0}], [{'python': 6, 'squirrel': 6}], [{'python': 3, 'squirrel': 3}], [{'ruby': 0, 'crystal': 0}], [{'python': 0, 'squirrel': 0}], [{'ruby': 1, 'crystal': 1}], [{'python': 0, 'squirrel': 0}], [{'ruby': 3, 'crystal': 3}], [{'python': 3, 'squirrel': 3}]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.007950418911149, "llm_generated_inputs": "[['rare crystal', 'good'], ['Ruby Rules', 'good'], ['crazy CriStals', 'good'], ['rrRRccCC', 'good'], ['regular crystals', 'good'], ['Python Power', 'evil'], ['silly Squirrel', 'evil'], ['ppPPssSS', 'evil'], ['PpSs', 'evil'], ['', 'good'], ['', 'evil'], ['random text', 'good'], ['random text', 'evil'], ['RrCcPpSs', 'good'], ['RrCcPpSs', 'evil']]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "diamonds_and_toads", "ground_truth": -1}
{"task_id": "TACO_lite/39", "requirement": "def get_grade(s1: int, s2: int, s3: int) -> str:\n\"\"\"## Grade book\n\nComplete the function so that it finds the mean of the three scores passed to it and returns the letter value associated with that grade.\n\nNumerical Score    | Letter Grade\n---                | ---\n90 <= score <= 100 | 'A'\n80 <= score < 90   | 'B'\n70 <= score < 80   | 'C'\n60 <= score < 70   | 'D'\n 0 <= score < 60   | 'F'\n\nTested values are all between 0 and 100. Theres is no need to check for negative values or values greater than 100.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    average_score = (s1 + s2 + s3) / 3\n    if 90 <= average_score <= 100:\n        return 'A'\n    elif 80 <= average_score < 90:\n        return 'B'\n    elif 70 <= average_score < 80:\n        return 'C'\n    elif 60 <= average_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = sum([s1, s2, s3]) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    average_score = (s1 + s2 + s3) / 3\n    if 90 <= average_score <= 100:\n        return 'A'\n    elif 80 <= average_score < 90:\n        return 'B'\n    elif 70 <= average_score < 80:\n        return 'C'\n    elif 60 <= average_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    average_score = (s1 + s2 + s3) / 3\n    if 90 <= average_score <= 100:\n        return 'A'\n    elif 80 <= average_score < 90:\n        return 'B'\n    elif 70 <= average_score < 80:\n        return 'C'\n    elif 60 <= average_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    average_score = (s1 + s2 + s3) / 3\n    if 90 <= average_score <= 100:\n        return 'A'\n    elif 80 <= average_score < 90:\n        return 'B'\n    elif 70 <= average_score < 80:\n        return 'C'\n    elif 60 <= average_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    average_score = (s1 + s2 + s3) / 3\n    if 90 <= average_score <= 100:\n        return 'A'\n    elif 80 <= average_score < 90:\n        return 'B'\n    elif 70 <= average_score < 80:\n        return 'C'\n    elif 60 <= average_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    average_score = (s1 + s2 + s3) / 3\n    if 90 <= average_score <= 100:\n        return 'A'\n    elif 80 <= average_score < 90:\n        return 'B'\n    elif 70 <= average_score < 80:\n        return 'C'\n    elif 60 <= average_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    average_score = (s1 + s2 + s3) / 3\n    if 90 <= average_score <= 100:\n        return 'A'\n    elif 80 <= average_score < 90:\n        return 'B'\n    elif 70 <= average_score < 80:\n        return 'C'\n    elif 60 <= average_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'", "def get_grade(s1: int, s2: int, s3: int) -> str:\n    mean_score = (s1 + s2 + s3) / 3\n    if 90 <= mean_score <= 100:\n        return 'A'\n    elif 80 <= mean_score < 90:\n        return 'B'\n    elif 70 <= mean_score < 80:\n        return 'C'\n    elif 60 <= mean_score < 70:\n        return 'D'\n    else:\n        return 'F'"], "requirement": [], "outputs": "[['A'], ['B'], ['C'], ['D'], ['F'], ['B'], ['A'], ['F'], ['D'], ['F'], ['B'], ['C'], ['A'], ['A'], ['D']]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[95, 92, 98], [85, 88, 82], [75, 77, 70], [65, 68, 60], [55, 58, 50], [90, 80, 70], [100, 90, 80], [0, 50, 25], [60, 60, 60], [59, 59, 59], [89, 89, 89], [79, 79, 79], [99, 99, 99], [100, 100, 100], [69, 69, 69]]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "get_grade", "ground_truth": 0}
{"task_id": "TACO_lite/40", "requirement": "from typing import Union\ndef palindrome(num: int) -> Union[bool, str]:\n\"\"\"A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward. For a given number `num`, write a function to test if it's a numerical palindrome or not and return a boolean (true if it is and false if not).\n\n```if-not:haskell\nReturn \"Not valid\" if the input is not an integer or less than `0`.\n```\n```if:haskell\nReturn `Nothing` if the input is less than `0` and `Just True` or `Just False` otherwise.\n```\n\nOther Kata in this Series:\nNumerical Palindrome #1\nNumerical Palindrome #1.5\nNumerical Palindrome #2\nNumerical Palindrome #3\nNumerical Palindrome #3.5\nNumerical Palindrome #4\nNumerical Palindrome #5\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    str_num = str(num)\n    return str_num == str_num[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    reversed_num_str = num_str[::-1]\n    return num_str == reversed_num_str", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    if num_str == num_str[::-1]:\n        return True\n    else:\n        return False", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return str(num) == str(num)[::-1]", "from typing import Union\n\ndef palindrome(num: int) -> Union[bool, str]:\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    num_str = str(num)\n    return num_str == num_str[::-1]"], "requirement": [], "outputs": "[[True], [True], [False], ['Not valid'], [True], [True], ['Not valid'], ['Not valid'], ['Not valid'], ['Not valid'], [False]]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[121], [12321], [123456], [-121], [0], [1], [123.456], ['12321'], [None], [[121]], [True]]", "input_output_examples": "[[[2332], [110011], [54322345]], [[True], [True], [True]]]", "at_least_one_align": false}, "entry_point": "palindrome", "ground_truth": 0}
{"task_id": "TACO_lite/41", "requirement": "def sabb(stg: str, value: int, happiness: int) -> str:\n\"\"\"Learning to code around your full time job is taking over your life. You realise that in order to make significant steps quickly, it would help to go to a coding bootcamp in London.\n\nProblem is, many of them cost a fortune, and those that don't still involve a significant amount of time off work - who will pay your mortgage?!\n\nTo offset this risk, you decide that rather than leaving work totally, you will request a sabbatical so that you can go back to work post bootcamp and be paid while you look for your next role.\n\nYou need to approach your boss. Her decision will be based on three parameters:\n\nval=your value to the organisation\nhappiness=her happiness level at the time of asking and finally\nThe numbers of letters from 'sabbatical' that are present in string `s`.\n\nNote that if `s` contains three instances of the letter 'l', that still scores three points, even though there is only one in the word sabbatical.\n\nIf the sum of the three parameters (as described above) is > 22, return 'Sabbatical! Boom!', else return 'Back to your desk, boy.'.\n\n~~~if:c\nNOTE: For the C translation you should return a string literal.\n~~~\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical = 'sabbatical'\n    count = sum((stg.count(c) for c in sabbatical))\n    total_score = value + happiness + count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    letter_score = sum((stg.count(letter) for letter in target_word))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabbatical'\n    letter_count = sum((stg.count(letter) for letter in target_letters))\n    total_score = value + happiness + letter_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    letter_score = sum((stg.count(letter) for letter in target_word))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_letters = 'sabbatical'\n    count = sum((stg.count(letter) for letter in sabbatical_letters))\n    total_score = value + happiness + count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_letters = 'sabbatical'\n    score = sum((stg.count(letter) for letter in sabbatical_letters))\n    total = score + value + happiness\n    if total > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    score = sum((stg.count(letter) for letter in target_word))\n    total_score = score + value + happiness\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_letters = 'sabbatical'\n    letter_score = sum((stg.count(letter) for letter in sabbatical_letters))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabbatical'\n    letter_count = sum((stg.count(letter) for letter in target_letters))\n    total_score = value + happiness + letter_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabbatical'\n    count = sum((stg.count(letter) for letter in target_letters))\n    total = value + happiness + count\n    if total > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    letter_score = sum((stg.count(letter) for letter in target_word))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabbatical'\n    count = sum((stg.count(letter) for letter in target_letters))\n    total_score = count + value + happiness\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    word = 'sabbatical'\n    count = sum([stg.count(c) for c in word])\n    total = count + value + happiness\n    if total > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabbatical'\n    letter_score = sum((stg.count(letter) for letter in target_letters))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_letters = 'sabbatical'\n    score = sum((stg.count(letter) for letter in sabbatical_letters))\n    total_score = score + value + happiness\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_letters = 'sabbatical'\n    score = sum((stg.lower().count(letter) for letter in sabbatical_letters))\n    total_score = value + happiness + score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_letters = 'sabbatical'\n    count = sum((stg.count(letter) for letter in sabbatical_letters))\n    total = value + happiness + count\n    if total > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabbatical'\n    letter_score = sum((stg.count(char) for char in target_letters))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_letters = 'sabbatical'\n    count = sum((stg.count(letter) for letter in sabbatical_letters))\n    total_score = value + happiness + count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    score = sum((stg.count(letter) for letter in target_word))\n    total = value + happiness + score\n    if total > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    letter_score = sum((stg.count(letter) for letter in target_word))\n    total_score = value + happiness + letter_score\n    return 'Sabbatical! Boom!' if total_score > 22 else 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabbatical'\n    letter_count = sum((stg.count(letter) for letter in target_letters))\n    total_score = value + happiness + letter_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    sabbatical_score = sum((stg.count(c) for c in target_word))\n    total_score = value + happiness + sabbatical_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabbatical'\n    letter_score = sum((stg.count(letter) for letter in target_letters))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabbatical'\n    letter_count = sum((stg.count(letter) for letter in target_letters))\n    total_score = value + happiness + letter_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabbatical'\n    letter_score = sum((stg.count(char) for char in target_letters))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_letters = 'sabbatical'\n    letter_count = sum((stg.count(letter) for letter in sabbatical_letters))\n    total_score = value + happiness + letter_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'"], "requirement": [], "outputs": "[['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Sabbatical! Boom!']]", "probability": 0.54, "is_align_req": false, "DRS": null}, {"programs_str": ["def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = 'sabtical'\n    count = sum((stg.count(char) for char in target_letters))\n    total_score = value + happiness + count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'"], "requirement": [], "outputs": "[['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Back to your desk, boy.']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    letter_score = sum((min(stg.count(letter), target_word.count(letter)) for letter in set(target_word)))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_word = 'sabbatical'\n    matching_letters = sum((min(stg.count(letter), sabbatical_word.count(letter)) for letter in set(sabbatical_word)))\n    total_score = matching_letters + value + happiness\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_word = 'sabbatical'\n    matching_letters = sum((min(stg.count(c), sabbatical_word.count(c)) for c in set(sabbatical_word)))\n    total_score = value + happiness + matching_letters\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    match_count = sum((min(stg.count(char), target_word.count(char)) for char in set(target_word)))\n    total_score = value + happiness + match_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'"], "requirement": [], "outputs": "[['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.']]", "probability": 0.08, "is_align_req": false, "DRS": null}, {"programs_str": ["def sabb(stg: str, value: int, happiness: int) -> str:\n    word_to_check = 'sabbatical'\n    count = sum((stg.count(char) for char in set(word_to_check)))\n    total_score = count + value + happiness\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    match_count = sum((stg.count(letter) for letter in set(target_word)))\n    total_score = value + happiness + match_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = set('sabbatical')\n    letter_score = sum((stg.lower().count(letter) for letter in target_letters))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    char_count = sum((stg.count(c) for c in set(target_word)))\n    total_score = value + happiness + char_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    char_count = sum((stg.count(char) for char in set(target_word)))\n    total_score = value + happiness + char_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    score = sum((stg.count(letter) for letter in set(target_word)))\n    total_score = score + value + happiness\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    letter_score = sum((stg.count(letter) for letter in set(target_word)))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    word_to_check = 'sabbatical'\n    count = sum((stg.count(c) for c in set(word_to_check) if c in stg))\n    total_score = value + happiness + count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_word = 'sabbatical'\n    letter_count = sum((stg.count(letter) for letter in set(sabbatical_word)))\n    total_score = value + happiness + letter_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    sabbatical_count = sum((stg.count(char) for char in set(target_word) if char in stg))\n    total_score = value + happiness + sabbatical_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_letters = set('sabbatical')\n    letter_score = sum((1 for char in stg if char in target_letters))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    letter_score = sum((stg.count(letter) for letter in set(target_word)))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    letter_score = sum((stg.count(letter) for letter in set(target_word)))\n    total_score = value + happiness + letter_score\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    letter_count = sum((stg.count(letter) for letter in set(target_word)))\n    total_score = value + happiness + letter_count\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    sabbatical_word = 'sabbatical'\n    letter_score = sum((stg.count(c) for c in set(sabbatical_word)))\n    total_score = value + happiness + letter_score\n    return 'Sabbatical! Boom!' if total_score > 22 else 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    letter_count = sum((stg.count(char) for char in set(target_word) if char in stg))\n    total_score = letter_count + value + happiness\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'", "def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    count = sum((stg.count(c) for c in set(target_word)))\n    total_score = count + value + happiness\n    if total_score > 22:\n        return 'Sabbatical! Boom!'\n    else:\n        return 'Back to your desk, boy.'"], "requirement": [], "outputs": "[['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Back to your desk, boy.'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Back to your desk, boy.'], ['Back to your desk, boy.']]", "probability": 0.34, "is_align_req": false, "DRS": null}, {"programs_str": ["def sabb(stg: str, value: int, happiness: int) -> str:\n    target_word = 'sabbatical'\n    matches = sum((max(stg.count(char), target_word.count(char)) for char in set(target_word)))\n    total_score = value + happiness + matches\n    return 'Sabbatical! Boom!' if total_score > 22 else 'Back to your desk, boy.'"], "requirement": [], "outputs": "[['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!'], ['Sabbatical! Boom!']]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.0580750119171036, "llm_generated_inputs": "[['sabbatical', 10, 5], ['sabbatical', 10, 8], ['ssbbttllccaa', 7, 7], ['abc', 15, 5], ['xyz', 20, 2], ['', 15, 10], ['sabbatical', 8, 7], ['sabbatical', 6, 9], ['ssaaaaa', 10, 4], ['ssbb', 12, 3], ['aaa', 10, 10], ['bbaacc', 10, 4], ['sabb', 13, 3], ['london', 10, 8], ['codingbootcamp', 5, 10], ['fulltimejob', 7, 9], ['significantsteps', 6, 9], ['decisionbasedonthree', 10, 6], ['riskoffset', 8, 8], ['backtodesk', 5, 10]]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "sabb", "ground_truth": -1}
{"task_id": "TACO_lite/42", "requirement": "from typing import List\ndef sort_array(xs: List[int]) -> List[int]:\n\"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, and even numbers in descending order.\n\nNote that zero is an even number. If you have an empty array, you need to return it.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    odd_index, even_index = (0, 0)\n    for x in xs:\n        if x % 2 != 0:\n            result.append(odds[odd_index])\n            odd_index += 1\n        else:\n            result.append(evens[even_index])\n            even_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted((x for x in xs if x % 2 == 0), reverse=True)\n    result = []\n    odd_index, even_index = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens[even_index])\n            even_index += 1\n        else:\n            result.append(odds[odd_index])\n            odd_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    odd_i, even_i = (0, 0)\n    for x in xs:\n        if x % 2 != 0:\n            result.append(odds[odd_i])\n            odd_i += 1\n        else:\n            result.append(evens[even_i])\n            even_i += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds.pop(0))\n        else:\n            result.append(sorted_evens.pop(0))\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted((x for x in xs if x % 2 == 0), reverse=True)\n    result = []\n    odd_i, even_i = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens[even_i])\n            even_i += 1\n        else:\n            result.append(odds[odd_i])\n            odd_i += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    odd_index, even_index = (0, 0)\n    for x in xs:\n        if x % 2 != 0:\n            result.append(odds[odd_index])\n            odd_index += 1\n        else:\n            result.append(evens[even_index])\n            even_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds.pop(0))\n        else:\n            result.append(sorted_evens.pop(0))\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    for x in xs:\n        if x % 2 == 0:\n            result.append(sorted_evens.pop(0))\n        else:\n            result.append(sorted_odds.pop(0))\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"Sorts odd numbers in ascending order and even numbers in descending order within the array.\"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted((x for x in xs if x % 2 == 0), reverse=True)\n    result = []\n    i, j = (0, 0)\n    for x in xs:\n        if x % 2 != 0:\n            result.append(odds[i])\n            i += 1\n        else:\n            result.append(evens[j])\n            j += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds.pop(0))\n        else:\n            result.append(sorted_evens.pop(0) if sorted_evens else 0)\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    odd_mapping = iter(sorted_odds)\n    even_mapping = iter(sorted_evens)\n    result = [next(odd_mapping) if x % 2 != 0 else next(even_mapping) for x in xs]\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    odd_index = 0\n    even_index = 0\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds[odd_index])\n            odd_index += 1\n        else:\n            result.append(sorted_evens[even_index])\n            even_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted((x for x in xs if x % 2 == 0), reverse=True)\n    result = []\n    odd_idx, even_idx = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens[even_idx])\n            even_idx += 1\n        else:\n            result.append(odds[odd_idx])\n            odd_idx += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    iter_odds = iter(odds)\n    iter_evens = iter(evens)\n    result = []\n    for x in xs:\n        if x % 2 != 0:\n            result.append(next(iter_odds))\n        else:\n            result.append(next(iter_evens))\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return xs\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    for x in xs:\n        if x % 2 == 0:\n            result.append(sorted_evens.pop(0))\n        else:\n            result.append(sorted_odds.pop(0))\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    odd_idx, even_idx = (0, 0)\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds[odd_idx])\n            odd_idx += 1\n        else:\n            result.append(sorted_evens[even_idx])\n            even_idx += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, \n    and even numbers in descending order. Note that zero is an even number. If you have an empty array, \n    you need to return it.\"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens.pop(0))\n        else:\n            result.append(odds.pop(0))\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, \n    and even numbers in descending order. Note that zero is an even number. If you have an empty array, \n    you need to return it.\"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted((x for x in xs if x % 2 == 0), reverse=True)\n    result = []\n    o_idx, e_idx = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens[e_idx])\n            e_idx += 1\n        else:\n            result.append(odds[o_idx])\n            o_idx += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    odd_index, even_index = (0, 0)\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds[odd_index])\n            odd_index += 1\n        else:\n            result.append(sorted_evens[even_index])\n            even_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, and even numbers in descending order.\n\n    Note that zero is an even number. If you have an empty array, you need to return it.\n    \"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens.pop(0))\n        else:\n            result.append(odds.pop(0))\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"Sorts odd numbers in ascending order and even numbers in descending order within the array.\n    \n    Args:\n        xs (List[int]): The input list of integers.\n        \n    Returns:\n        List[int]: The list with odd numbers sorted in ascending order and even numbers sorted in descending order.\n    \"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    odd_idx, even_idx = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens[even_idx])\n            even_idx += 1\n        else:\n            result.append(odds[odd_idx])\n            odd_idx += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"Sorts odd numbers in ascending order and even numbers in descending order within the given array.\n    \n    Args:\n        xs (List[int]): The input list of integers.\n        \n    Returns:\n        List[int]: The modified list with odd numbers sorted in ascending order and even numbers sorted in descending order.\n    \"\"\"\n    if not xs:\n        return []\n    odd_numbers = sorted([x for x in xs if x % 2 != 0])\n    even_numbers = sorted((x for x in xs if x % 2 == 0), reverse=True)\n    result = []\n    odd_index, even_index = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            result.append(even_numbers[even_index])\n            even_index += 1\n        else:\n            result.append(odd_numbers[odd_index])\n            odd_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, and even numbers in descending order.\n\n    Note that zero is an even number. If you have an empty array, you need to return it.\n    \"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    odd_index, even_index = (0, 0)\n    for x in xs:\n        if x % 2 != 0:\n            result.append(odds[odd_index])\n            odd_index += 1\n        else:\n            result.append(evens[even_index])\n            even_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, \n    and even numbers in descending order. Note that zero is an even number. If you have an empty array, \n    you need to return it.\"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted((x for x in xs if x % 2 == 0), reverse=True)\n    result = []\n    odd_index, even_index = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens[even_index])\n            even_index += 1\n        else:\n            result.append(odds[odd_index])\n            odd_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, \n    and even numbers in descending order. Note that zero is an even number. If you have an empty array, \n    you need to return it.\"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    odd_index, even_index = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens[even_index])\n            even_index += 1\n        else:\n            result.append(odds[odd_index])\n            odd_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"\n    Sorts odd numbers in ascending order and even numbers in descending order within the array.\n    If the array is empty, returns it as is.\n    \"\"\"\n    if not xs:\n        return []\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    mapping = {x: sorted_odds.pop(0) if x % 2 != 0 else sorted_evens.pop(0) for x in xs}\n    return [mapping[x] for x in xs]", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, \n    and even numbers in descending order. Note that zero is an even number. If you have an empty array, \n    you need to return it.\"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    sorted_xs = []\n    odd_idx, even_idx = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            sorted_xs.append(evens[even_idx])\n            even_idx += 1\n        else:\n            sorted_xs.append(odds[odd_idx])\n            odd_idx += 1\n    return sorted_xs", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, and even numbers in descending order.\n\n    Note that zero is an even number. If you have an empty array, you need to return it.\n    \"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    odds_iter = iter(odds)\n    evens_iter = iter(evens)\n    sorted_xs = [next(odds_iter) if x % 2 != 0 else next(evens_iter) for x in xs]\n    return sorted_xs", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return xs\n    odd_numbers = [x for x in xs if x % 2 != 0]\n    even_numbers = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odd_numbers)\n    sorted_evens = sorted(even_numbers, reverse=True)\n    result = []\n    odd_index = 0\n    even_index = 0\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds[odd_index])\n            odd_index += 1\n        else:\n            result.append(sorted_evens[even_index])\n            even_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"\n    Sorts odd numbers in ascending order and even numbers in descending order within the array.\n    \n    Args:\n        xs (List[int]): The input list of integers.\n        \n    Returns:\n        List[int]: The sorted list with odd numbers in ascending order and even numbers in descending order.\n    \"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    sorted_xs = []\n    odd_idx, even_idx = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            sorted_xs.append(evens[even_idx])\n            even_idx += 1\n        else:\n            sorted_xs.append(odds[odd_idx])\n            odd_idx += 1\n    return sorted_xs", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, \n    and even numbers in descending order. Note that zero is an even number. If you have an empty array, you need to return it.\"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    sorted_xs = []\n    odd_index, even_index = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            sorted_xs.append(evens[even_index])\n            even_index += 1\n        else:\n            sorted_xs.append(odds[odd_index])\n            odd_index += 1\n    return sorted_xs", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, and even numbers in descending order.\n\n    Note that zero is an even number. If you have an empty array, you need to return it.\n    \"\"\"\n    if not xs:\n        return []\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    odd_index = 0\n    even_index = 0\n    for x in xs:\n        if x % 2 == 0:\n            result.append(sorted_evens[even_index])\n            even_index += 1\n        else:\n            result.append(sorted_odds[odd_index])\n            odd_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"Sorts odd numbers in ascending order and even numbers in descending order within the array.\n    \n    Args:\n        xs (List[int]): The input list of integers.\n        \n    Returns:\n        List[int]: The list with odd numbers sorted in ascending order and even numbers sorted in descending order.\n    \"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    odd_idx, even_idx = (0, 0)\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens[even_idx])\n            even_idx += 1\n        else:\n            result.append(odds[odd_idx])\n            odd_idx += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, \n    and even numbers in descending order. Note that zero is an even number. If you have an empty array, \n    you need to return it.\"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens.pop(0))\n        else:\n            result.append(odds.pop(0))\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds.pop(0))\n        else:\n            result.append(sorted_evens.pop(0))\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    mapping = {}\n    for i, val in enumerate(odds):\n        mapping[val] = sorted_odds[i]\n    for i, val in enumerate(evens):\n        mapping[val] = sorted_evens[i]\n    return [mapping[x] if x in mapping else x for x in xs]", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"Sorts odd numbers in ascending order and even numbers in descending order within the array.\n    \n    Args:\n        xs (List[int]): The list of integers to be sorted.\n        \n    Returns:\n        List[int]: The sorted list according to the specified conditions.\n    \"\"\"\n    if not xs:\n        return []\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    odd_idx, even_idx = (0, 0)\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds[odd_idx])\n            odd_idx += 1\n        else:\n            result.append(sorted_evens[even_idx])\n            even_idx += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    mapping = {x: sorted_odds.pop(0) if x % 2 != 0 else sorted_evens.pop(0) for x in xs}\n    return [mapping[x] for x in xs]", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    odd_index = 0\n    even_index = 0\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds[odd_index])\n            odd_index += 1\n        else:\n            result.append(sorted_evens[even_index])\n            even_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, \n    and even numbers in descending order. Note that zero is an even number. If you have an empty array, \n    you need to return it.\"\"\"\n    if not xs:\n        return xs\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    sorted_xs = []\n    i, j = (0, 0)\n    for x in xs:\n        if x % 2 != 0:\n            sorted_xs.append(sorted_odds[i])\n            i += 1\n        else:\n            sorted_xs.append(sorted_evens[j])\n            j += 1\n    return sorted_xs", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    mapping = {}\n    for i, val in enumerate(odds):\n        mapping[val] = sorted_odds[i]\n    for i, val in enumerate(evens):\n        mapping[val] = sorted_evens[i]\n    return [mapping[x] if x in mapping else x for x in xs]", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    mapping = {}\n    for i, num in enumerate(odds):\n        mapping[num] = sorted_odds[i]\n    for i, num in enumerate(evens):\n        mapping[num] = sorted_evens[i]\n    return [mapping[x] if x in mapping else x for x in xs]", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    mapping = {x: sorted_odds.pop(0) if x % 2 != 0 else sorted_evens.pop(0) for x in xs}\n    return [mapping[x] for x in xs]", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    odd_index = 0\n    even_index = 0\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds[odd_index])\n            odd_index += 1\n        else:\n            result.append(sorted_evens[even_index])\n            even_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"\n    Sorts odd numbers in ascending order and even numbers in descending order within the array.\n    If the array is empty, returns it as is.\n    \n    :param xs: List[int] - The input list of integers.\n    :return: List[int] - The sorted list based on the specified conditions.\n    \"\"\"\n    if not xs:\n        return []\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    result = []\n    odd_index, even_index = (0, 0)\n    for x in xs:\n        if x % 2 != 0:\n            result.append(sorted_odds[odd_index])\n            odd_index += 1\n        else:\n            result.append(sorted_evens[even_index])\n            even_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    mapping = {x: sorted_odds.pop(0) if x % 2 != 0 else sorted_evens.pop(0) for x in xs}\n    result = [mapping[x] for x in xs]\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, and even numbers in descending order.\n\n    Note that zero is an even number. If you have an empty array, you need to return it.\n    \"\"\"\n    if not xs:\n        return []\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    sorted_dict = {}\n    for x in xs:\n        if x % 2 == 0:\n            sorted_dict[x] = sorted_evens.pop(0)\n        else:\n            sorted_dict[x] = sorted_odds.pop(0)\n    return [sorted_dict[x] for x in xs]", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    \"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, \n    and even numbers in descending order.\n    \n    Note that zero is an even number. If you have an empty array, you need to return it.\n    \"\"\"\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    result = []\n    odd_index = 0\n    even_index = 0\n    for x in xs:\n        if x % 2 == 0:\n            result.append(evens[even_index])\n            even_index += 1\n        else:\n            result.append(odds[odd_index])\n            odd_index += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    if not xs:\n        return xs\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    sorted_dict = {x: i for i, x in enumerate(sorted_odds + sorted_evens)}\n    result = [sorted_odds.pop(0) if x % 2 != 0 else sorted_evens.pop(0) for x in xs if x % 2 != 0 and sorted_odds or (x % 2 == 0 and sorted_evens)]\n    return result\n\ndef sort_array_optimized(xs: List[int]) -> List[int]:\n    if not xs:\n        return []\n    odds = sorted([x for x in xs if x % 2 != 0])\n    evens = sorted([x for x in xs if x % 2 == 0], reverse=True)\n    odd_i, even_i = (0, 0)\n    result = []\n    for x in xs:\n        if x % 2 != 0:\n            result.append(odds[odd_i])\n            odd_i += 1\n        else:\n            result.append(evens[even_i])\n            even_i += 1\n    return result", "from typing import List\n\ndef sort_array(xs: List[int]) -> List[int]:\n    odds = [x for x in xs if x % 2 != 0]\n    evens = [x for x in xs if x % 2 == 0]\n    sorted_odds = sorted(odds)\n    sorted_evens = sorted(evens, reverse=True)\n    sorted_dict = {}\n    for x in sorted_odds:\n        sorted_dict[x] = None\n    for x in sorted_evens:\n        sorted_dict[x] = None\n    result = []\n    for x in xs:\n        if x % 2 == 0:\n            result.append(sorted_evens.pop(0))\n        else:\n            result.append(sorted_odds.pop(0))\n    return result"], "requirement": [], "outputs": "[[[]], [[1, 3, 8, 4, 5, 2]], [[1, 3, 5, 7, 9]], [[10, 8, 6, 4, 2, 0]], [[1, 6, 3, 4, 5, 2]], [[8, 6, 4, 2]], [[-1, 1, 2, -2]], [[0, -3, -2, -1, -4]], [[-7, -5, -3, -1, 1, 3, 5, 7]], [[11, 13, 17, 19, 8, 6, 4, 2]]]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[[]], [[5, 3, 2, 8, 1, 4]], [[1, 3, 5, 7, 9]], [[10, 8, 6, 4, 2, 0]], [[1, 2, 3, 4, 5, 6]], [[2, 4, 6, 8]], [[1, -1, 2, -2]], [[0, -1, -2, -3, -4]], [[7, -7, 5, -5, 3, -3, 1, -1]], [[11, 13, 17, 19, 2, 4, 6, 8]]]", "input_output_examples": "[[[[5, 3, 2, 8, 1, 4]]], [[[1, 3, 8, 4, 5, 2]]]]", "at_least_one_align": false}, "entry_point": "sort_array", "ground_truth": 0}
{"task_id": "TACO_lite/43", "requirement": "def missing_angle(h: float, a: float, o: float) -> int:\n\"\"\"\nYour challange is to write a function (```missingAngle``` in C/C#, ```missing_angle``` in Ruby), that calculates the angle θ in degrees to the nearest integer. You will be given three arguments representing each side: o, h and a. One of the arguments equals zero. Use the length of the two other sides to calculate θ. You will not be expected to handle any erronous data in your solution.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    else:\n        raise ValueError('One of the sides must be zero.')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer.\n    One of the arguments (h, a, o) equals zero.\n    Uses the length of the two other sides to calculate θ.\n    \n    Args:\n    h (float): Hypotenuse\n    a (float): Adjacent side\n    o (float): Opposite side\n    \n    Returns:\n    int: The angle θ in degrees to the nearest integer.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        angle_rad = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle_rad = math.acos(a / h)\n    else:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle_rad = math.atan(o / a)\n    angle_deg = round(math.degrees(angle_rad))\n    return angle_deg", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    else:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        angle = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle = math.degrees(math.asin(o / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle = math.degrees(math.acos(a / h))\n    return round(angle)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(o ** 2 + a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.asin(o / h))\n    else:\n        raise ValueError('One of the sides must be zero.')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculate the angle θ in degrees to the nearest integer given two sides of a right triangle.\n    \n    Args:\n        h (float): The length of the hypotenuse\n        a (float): The length of the adjacent side\n        o (float): The length of the opposite side\n    \n    Returns:\n        int: The angle θ in degrees to the nearest integer\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        angle_radians = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle_radians = math.acos(a / h)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle_radians = math.asin(o / h)\n    angle_degrees = int(round(math.degrees(angle_radians)))\n    return angle_degrees", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(o ** 2 + a ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.atan(o / a))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer given two sides of a right triangle.\n    \n    Args:\n        h (float): Hypotenuse length.\n        a (float): Adjacent side length.\n        o (float): Opposite side length.\n        \n    Returns:\n        int: The angle θ in degrees to the nearest integer.\n    \"\"\"\n    if h == 0:\n        theta = math.degrees(math.atan(o / a))\n    elif a == 0:\n        theta = math.degrees(math.asin(o / h))\n    elif o == 0:\n        theta = math.degrees(math.acos(a / h))\n    else:\n        raise ValueError('One and only one argument should be zero.')\n    return round(theta)", "import math\nfrom typing import Tuple\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer using the lengths of two non-zero sides.\n    \n    Args:\n    h (float): Hypotenuse length.\n    a (float): Adjacent side length.\n    o (float): Opposite side length.\n    \n    Returns:\n    int: The angle θ in degrees.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.atan(o / a))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    else:\n        raise ValueError('One of the arguments must be zero.')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        angle_rad = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle_rad = math.acos(a / h)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle_rad = math.atan(o / a)\n    else:\n        raise ValueError('One of the sides must be zero.')\n    angle_deg = round(math.degrees(angle_rad))\n    return angle_deg", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculate the angle θ in degrees to the nearest integer using the lengths of two sides of a right triangle.\n    \n    Parameters:\n    h (float): Hypotenuse of the triangle\n    a (float): Adjacent side of the triangle\n    o (float): Opposite side of the triangle\n    \n    Returns:\n    int: The angle θ in degrees to the nearest integer.\n    \"\"\"\n    if h == 0:\n        θ = math.degrees(math.atan(o / a))\n    elif a == 0:\n        θ = math.degrees(math.asin(o / h))\n    elif o == 0:\n        θ = math.degrees(math.acos(a / h))\n    else:\n        raise ValueError('One of the arguments must be zero.')\n    return round(θ)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    else:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer using the lengths of \n    two given sides of a right triangle. One of the arguments (h, a, o) should be 0.\n    \n    Parameters:\n        h (float): Hypotenuse length\n        a (float): Adjacent side length\n        o (float): Opposite side length\n    \n    Returns:\n        int: The angle θ in degrees to the nearest integer.\n    \"\"\"\n    if [h, a, o].count(0) != 1:\n        raise ValueError('Exactly one of the arguments must be zero.')\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        angle = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle = math.degrees(math.acos(a / h))\n    else:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle = math.degrees(math.atan(o / a))\n    return round(angle)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        angle_radians = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle_radians = math.atan(o / a)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle_radians = math.acos(a / h)\n    else:\n        raise ValueError('One of the sides must be zero.')\n    angle_degrees = int(round(math.degrees(angle_radians)))\n    return angle_degrees", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        angle_radians = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle_radians = math.acos(a / h)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle_radians = math.atan(o / a)\n    else:\n        raise ValueError('One of the sides must be zero.')\n    angle_degrees = round(math.degrees(angle_radians))\n    return angle_degrees", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0 and a != 0 and (o != 0):\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.atan(o / a))\n    elif a == 0 and h != 0 and (o != 0):\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif o == 0 and h != 0 and (a != 0):\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    else:\n        raise ValueError('One and only one side should be zero')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(o ** 2 + a ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.asin(o / h))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer.\n    \n    Parameters:\n    h (float): Length of the hypotenuse\n    a (float): Length of the adjacent side\n    o (float): Length of the opposite side\n    \n    Returns:\n    int: The angle θ in degrees, rounded to the nearest integer.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        angle_rad = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle_rad = math.acos(a / h)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle_rad = math.atan(o / a)\n    else:\n        raise ValueError('One of the sides must be zero.')\n    angle_deg = round(math.degrees(angle_rad))\n    return angle_deg", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta_rad = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta_rad = math.atan(o / a)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta_rad = math.acos(a / h)\n    else:\n        raise ValueError('One of the sides must be 0.')\n    theta_deg = round(math.degrees(theta_rad))\n    return theta_deg", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    sides = [h, a, o]\n    if sides.count(0) != 1 or any((side < 0 for side in sides)):\n        raise ValueError('Exactly one side must be zero and all sides must be non-negative.')\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    else:\n        raise ValueError('Exactly one side must be zero.')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    else:\n        raise ValueError('One of the arguments must be zero.')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(o ** 2 + a ** 2)\n        angle_rad = math.atan(o / a)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle_rad = math.asin(o / h)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle_rad = math.acos(a / h)\n    else:\n        raise ValueError('One of the sides must be zero.')\n    angle_deg = round(math.degrees(angle_rad))\n    return angle_deg", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        angle_rad = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle_rad = math.acos(a / h)\n    else:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle_rad = math.atan(o / a)\n    angle_deg = round(math.degrees(angle_rad))\n    return angle_deg", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if [h, a, o].count(0) != 1:\n        raise ValueError('Exactly one of the sides must be zero.')\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    else:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.asin(o / h))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    zero_count = sum([1 for x in [h, a, o] if x == 0])\n    if zero_count != 1:\n        raise ValueError('Exactly one of the arguments must be zero')\n    if h == 0:\n        theta = math.degrees(math.atan(o / a))\n    elif a == 0:\n        theta = math.degrees(math.asin(o / h))\n    elif o == 0:\n        theta = math.degrees(math.acos(a / h))\n    else:\n        raise ValueError('One of the sides must be zero')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer using the lengths of two non-zero sides.\n    \n    Args:\n        h (float): Hypotenuse of the triangle.\n        a (float): Adjacent side of the triangle.\n        o (float): Opposite side of the triangle.\n    \n    Returns:\n        int: Angle θ in degrees to the nearest integer.\n    \"\"\"\n    if [h, a, o].count(0) != 1:\n        raise ValueError('Exactly one of the arguments must be zero.')\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    else:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(o ** 2 + a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.atan(o / a))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    else:\n        raise ValueError('One of the sides must be zero.')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculate the angle θ in degrees to the nearest integer given the lengths of two sides of a right triangle.\n    \n    Args:\n        h (float): The length of the hypotenuse.\n        a (float): The length of the adjacent side.\n        o (float): The length of the opposite side.\n    \n    Returns:\n        int: The angle θ in degrees to the nearest integer.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    else:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta_rad = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta_rad = math.atan(o / a)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta_rad = math.acos(a / h)\n    theta_deg = math.degrees(theta_rad)\n    return round(theta_deg)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h != 0 and a != 0 and (o == 0):\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif h != 0 and o != 0 and (a == 0):\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    elif a != 0 and o != 0 and (h == 0):\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.atan(o / a))\n    else:\n        raise ValueError('One and only one of the sides must be zero.')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculate the angle θ in degrees to the nearest integer.\n    \n    Args:\n        h (float): The length of the hypotenuse.\n        a (float): The length of the adjacent side.\n        o (float): The length of the opposite side.\n    \n    Returns:\n        int: The angle θ in degrees to the nearest integer.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        angle_radians = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle_radians = math.atan(o / a)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle_radians = math.acos(a / h)\n    angle_degrees = math.degrees(angle_radians)\n    return round(angle_degrees)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculate the angle θ in degrees to the nearest integer.\n    \n    Args:\n        h (float): Length of the hypotenuse.\n        a (float): Length of the adjacent side.\n        o (float): Length of the opposite side.\n        \n    Returns:\n        int: The angle θ in degrees to the nearest integer.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.atan(o / a))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculate the angle θ in degrees to the nearest integer using the lengths of two sides of a right triangle.\n    \n    Args:\n    h (float): The hypotenuse length (one of h, a, o can be 0)\n    a (float): The adjacent side length\n    o (float): The opposite side length\n    \n    Returns:\n    int: The angle θ in degrees rounded to the nearest integer.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.asin(o / h))\n    else:\n        raise ValueError('One of the inputs must be zero.')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer using the lengths of two non-zero sides.\n    \n    Args:\n        h (float): Hypotenuse of the right-angled triangle.\n        a (float): Adjacent side of the right-angled triangle.\n        o (float): Opposite side of the right-angled triangle.\n    \n    Returns:\n        int: Angle θ in degrees rounded to the nearest integer.\n    \"\"\"\n    if h == 0:\n        angle_rad = math.atan2(o, a)\n    elif a == 0:\n        angle_rad = math.asin(o / h)\n    elif o == 0:\n        angle_rad = math.acos(a / h)\n    else:\n        raise ValueError('One and only one argument must be zero.')\n    angle_deg = round(math.degrees(angle_rad))\n    return angle_deg", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer given two sides of a right triangle.\n    \n    Args:\n    h (float): The hypotenuse length.\n    a (float): The adjacent side length.\n    o (float): The opposite side length.\n\n    Returns:\n    int: The angle θ in degrees to the nearest integer.\n    \"\"\"\n    if [h, a, o].count(0) != 1:\n        raise ValueError('Exactly one side must be zero')\n    sides = [side for side in [h, a, o] if side != 0]\n    if h == 0:\n        h = math.sqrt(sides[0] ** 2 + sides[1] ** 2)\n        angle_radians = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        angle_radians = math.acos(a / h)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        angle_radians = math.asin(o / h)\n    angle_degrees = math.degrees(angle_radians)\n    return round(angle_degrees)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.atan(o / a))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.acos(a / h))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer given the lengths of two sides of a right triangle.\n    \n    Parameters:\n    h (float): The length of the hypotenuse.\n    a (float): The length of the adjacent side.\n    o (float): The length of the opposite side.\n    \n    Returns:\n    int: The angle θ in degrees to the nearest integer.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.atan(o / a))\n    else:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    zero_count = sum([1 for x in [h, a, o] if x == 0])\n    if zero_count != 1:\n        raise ValueError('Exactly one argument must be zero.')\n    if h == 0:\n        θ = math.degrees(math.atan(o / a))\n    elif a == 0:\n        θ = math.degrees(math.asin(o / h))\n    elif o == 0:\n        θ = math.degrees(math.acos(a / h))\n    else:\n        raise ValueError('One of the arguments must be zero.')\n    return round(θ)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.asin(o / h))\n    else:\n        raise ValueError('One and only one of the arguments should be zero.')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculate the angle θ in degrees to the nearest integer.\n    \n    Parameters:\n    h (float): Hypotenuse length\n    a (float): Adjacent side length\n    o (float): Opposite side length\n    \n    Returns:\n    int: The angle θ in degrees\n    \"\"\"\n    if [h, a, o].count(0) != 1:\n        raise ValueError('Exactly one argument must be zero.')\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    else:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculate the angle θ in degrees to the nearest integer using the given sides of a right triangle.\n    \n    :param h: Hypotenuse length (or 0 if unknown)\n    :param a: Adjacent side length (or 0 if unknown)\n    :param o: Opposite side length (or 0 if unknown)\n    :return: The angle θ in degrees as an integer\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    else:\n        raise ValueError('One and only one argument should be zero')\n    return round(theta)", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer using the lengths of two sides of a right triangle.\n    \n    Args:\n        h (float): The length of the hypotenuse. If this side is unknown, it should be 0.\n        a (float): The length of the adjacent side. If this side is unknown, it should be 0.\n        o (float): The length of the opposite side. If this side is unknown, it should be 0.\n        \n    Returns:\n        int: The angle θ in degrees, rounded to the nearest integer.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta_rad = math.asin(o / h)\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta_rad = math.acos(a / h)\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta_rad = math.atan(o / a)\n    theta_deg = round(math.degrees(theta_rad))\n    return theta_deg", "import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer using the given sides of a right triangle.\n    \n    Args:\n        h (float): Hypotenuse length.\n        a (float): Adjacent side length.\n        o (float): Opposite side length.\n    \n    Returns:\n        int: The angle θ in degrees.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        a = math.sqrt(h ** 2 - o ** 2)\n        theta = math.degrees(math.acos(a / h))\n    elif o == 0:\n        o = math.sqrt(h ** 2 - a ** 2)\n        theta = math.degrees(math.atan(o / a))\n    return round(theta)"], "requirement": [], "outputs": "[[53], [37], [37], [67], [44], [39], [28], [16], [44], [31]]", "probability": 0.96, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculates the angle θ in degrees to the nearest integer using the lengths of two sides of a right triangle.\n    \n    Parameters:\n        h (float): The length of the hypotenuse.\n        a (float): The length of the adjacent side.\n        o (float): The length of the opposite side.\n        \n    Returns:\n        int: The angle θ in degrees to the nearest integer.\n    \"\"\"\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        theta = math.degrees(math.atan(o / h))\n    elif o == 0:\n        theta = math.degrees(math.acos(a / h))\n    else:\n        raise ValueError('One and only one side must be zero.')\n    return round(theta)"], "requirement": [], "outputs": "[[53], [31], [37], [43], [44], [39], [28], [16], [44], [31]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["import math\n\ndef missing_angle(h: float, a: float, o: float) -> int:\n    \"\"\"\n    Calculate the missing angle θ in degrees to the nearest integer.\n    \n    Parameters:\n    h (float): The hypotenuse of the triangle.\n    a (float): The adjacent side of the triangle.\n    o (float): The opposite side of the triangle.\n    \n    Returns:\n    int: The angle θ in degrees.\n    \"\"\"\n    if [h, a, o].count(0) != 1:\n        raise ValueError('Exactly one of the arguments must be zero.')\n    if h == 0:\n        h = math.sqrt(a ** 2 + o ** 2)\n        theta = math.degrees(math.asin(o / h))\n    elif a == 0:\n        theta = math.degrees(math.acos(a / h))\n    elif o == 0:\n        theta = math.degrees(math.atan(o / a))\n    else:\n        raise ValueError('One of the sides must be zero.')\n    return round(theta)"], "requirement": [], "outputs": "[[0], [90], [37], [90], [0], [39], [0], [16], [0], [31]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 0.19567003495657082, "llm_generated_inputs": "[[5, 3, 0], [10, 0, 6], [0, 8, 6], [13, 0, 12], [7, 5, 0], [0, 10, 8], [17, 15, 0], [0, 25, 7], [29, 21, 0], [0, 5, 3]]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "missing_angle", "ground_truth": -1}
{"task_id": "TACO_lite/44", "requirement": "def xor(a: int, b: int) -> bool:\n\"\"\"# Exclusive \"or\" (xor) Logical Operator\n\n## Overview\n\nIn some scripting languages like PHP, there exists a logical operator (e.g. ```&&```, ```||```, ```and```, ```or```, etc.) called the \"Exclusive Or\" (hence the name of this Kata).  The exclusive or evaluates two booleans.  It then returns true if **exactly one of the two expressions are true**, false otherwise.  \n\n## Task\n\nSince we cannot define keywords in Javascript (well, at least I don't know how to do it), your task is to define a function ```xor(a, b)``` where a and b are the two expressions to be evaluated.  Your ```xor``` function should have the behaviour described above, returning true if **exactly one of the two expressions evaluate to true**, false otherwise.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def xor(a: int, b: int) -> bool:\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator\n\n    Args:\n        a (int): First expression to evaluate.\n        b (int): Second expression to evaluate.\n\n    Returns:\n        bool: True if exactly one of the two expressions are true, False otherwise.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Returns True if exactly one of the two inputs is True, False otherwise.\n    \n    :param a: First boolean input (True or False)\n    :param b: Second boolean input (True or False)\n    :return: The result of the exclusive or operation on the two inputs.\n    \"\"\"\n    return a and (not b) or (not a and b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n    \n    Returns True if exactly one of the two expressions are true, False otherwise.\n    \n    Parameters:\n    a (int): First expression to evaluate.\n    b (int): Second expression to evaluate.\n    \n    Returns:\n    bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    Returns True if exactly one of the two expressions are true, False otherwise.\n\n    Parameters:\n    a (int): The first boolean expression.\n    b (int): The second boolean expression.\n\n    Returns:\n    bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator.\n\n    Returns True if exactly one of the two expressions are true, False otherwise.\n\n    Args:\n        a (int): First expression to evaluate.\n        b (int): Second expression to evaluate.\n\n    Returns:\n        bool: Result of the XOR operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator.\n\n    Args:\n        a (int): First expression to evaluate.\n        b (int): Second expression to evaluate.\n\n    Returns:\n        bool: True if exactly one of the two expressions evaluates to true, False otherwise.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator\n    \n    Returns True if exactly one of the two expressions are true, False otherwise.\n    \n    Args:\n        a (int): First expression to evaluate.\n        b (int): Second expression to evaluate.\n        \n    Returns:\n        bool: Result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    Returns True if exactly one of the two expressions are true, False otherwise.\n    \n    Parameters:\n    a (int): The first boolean expression.\n    b (int): The second boolean expression.\n\n    Returns:\n    bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator\n    \n    Returns True if exactly one of the two expressions are true, False otherwise.\n    \n    Args:\n        a (int): First expression to evaluate.\n        b (int): Second expression to evaluate.\n        \n    Returns:\n        bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Implements the exclusive \"or\" (XOR) logical operation.\n    \n    Args:\n        a (int): First boolean expression (0 or 1).\n        b (int): Second boolean expression (0 or 1).\n\n    Returns:\n        bool: True if exactly one of the two expressions is true, False otherwise.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    Args:\n        a (int): First boolean expression (0 or 1)\n        b (int): Second boolean expression (0 or 1)\n\n    Returns:\n        bool: True if exactly one of the two expressions is true, False otherwise.\n    \"\"\"\n    return a and (not b) or (not a and b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Implements the exclusive or (xor) logical operation.\n    \n    Parameters:\n    a (int): The first boolean expression (0 or 1).\n    b (int): The second boolean expression (0 or 1).\n    \n    Returns:\n    bool: True if exactly one of the two expressions is true, False otherwise.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator\n    \n    Returns True if exactly one of the two expressions are true, False otherwise.\n    \n    Args:\n        a (int): First expression to evaluate.\n        b (int): Second expression to evaluate.\n        \n    Returns:\n        bool: Result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n    \n    Returns True if exactly one of the two expressions evaluates to true, False otherwise.\n    \n    Parameters:\n    a (int): The first expression to evaluate.\n    b (int): The second expression to evaluate.\n    \n    Returns:\n    bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator\n    \n    Returns True if exactly one of the two expressions are true, False otherwise.\n    \n    Args:\n        a (int): First expression to evaluate.\n        b (int): Second expression to evaluate.\n        \n    Returns:\n        bool: The result of the xor operation on the two expressions.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    Returns True if exactly one of the two expressions evaluates to true, False otherwise.\n\n    Parameters:\n    a (int): First boolean expression\n    b (int): Second boolean expression\n\n    Returns:\n    bool: The result of the xor operation\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator\n    \n    This function evaluates two boolean values and returns True if exactly \n    one of the two expressions are True, False otherwise.\n    \n    Args:\n        a (int): The first boolean expression to evaluate.\n        b (int): The second boolean expression to evaluate.\n        \n    Returns:\n        bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    Returns True if exactly one of the two expressions are True, False otherwise.\n    \n    Parameters:\n    a (int): First boolean expression (0 or 1)\n    b (int): Second boolean expression (0 or 1)\n\n    Returns:\n    bool: Result of the XOR operation\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator.\n\n    Args:\n        a (int): First boolean expression.\n        b (int): Second boolean expression.\n\n    Returns:\n        bool: True if exactly one of the two expressions is true, False otherwise.\n    \"\"\"\n    return a and (not b) or (not a and b)", "def xor(a: int, b: int) -> bool:\n    \"\"\" \n    Exclusive \"or\" (xor) Logical Operator\n\n    This function evaluates two boolean values and returns True if exactly one of the two expressions are true, \n    and False otherwise.\n\n    Args:\n        a (int): The first boolean value.\n        b (int): The second boolean value.\n\n    Returns:\n        bool: The result of the exclusive or operation.\n    \"\"\"\n    return a and (not b) or (not a and b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator.\n\n    Returns True if exactly one of the two expressions are true, False otherwise.\n    \n    Args:\n        a (int): The first expression to evaluate.\n        b (int): The second expression to evaluate.\n        \n    Returns:\n        bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function takes two integers and returns True if exactly one of the \n    two expressions are true, False otherwise.\n    \n    :param a: First integer\n    :param b: Second integer\n    :return: Boolean result of the xor operation\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Implements the exclusive \"or\" (xor) logical operation.\n    \n    Args:\n        a (int): First boolean expression (0 or 1).\n        b (int): Second boolean expression (0 or 1).\n\n    Returns:\n        bool: True if exactly one of the two expressions is true, False otherwise.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function evaluates two boolean inputs and returns True if exactly one of the two expressions is True, \n    and False otherwise.\n\n    Parameters:\n    a (int): First boolean expression (0 or 1)\n    b (int): Second boolean expression (0 or 1)\n\n    Returns:\n    bool: Result of the xor operation\n    \"\"\"\n    return bool(a) ^ bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    Returns True if exactly one of the two expressions are true, False otherwise.\n    \n    :param a: First boolean expression\n    :param b: Second boolean expression\n    :return: Boolean result of exclusive or operation\n    \"\"\"\n    return a and (not b) or (not a and b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator.\n\n    This function takes two integers and returns True if exactly one of the \n    two expressions are true (1), and False otherwise.\n\n    Args:\n        a (int): First expression (0 or 1).\n        b (int): Second expression (0 or 1).\n\n    Returns:\n        bool: The result of the exclusive or operation.\n    \"\"\"\n    a_bool = bool(a)\n    b_bool = bool(b)\n    return a_bool != b_bool", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function evaluates two boolean inputs and returns True if exactly one of the inputs is True.\n    Otherwise, it returns False.\n\n    Parameters:\n    a (int): The first boolean input (0 or 1).\n    b (int): The second boolean input (0 or 1).\n\n    Returns:\n    bool: The result of the xor operation on the two inputs.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n    \n    Returns True if exactly one of the two expressions evaluates to true, False otherwise.\n    \n    Parameters:\n    a (int): First expression to evaluate.\n    b (int): Second expression to evaluate.\n    \n    Returns:\n    bool: The result of the exclusive or operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function evaluates two boolean values and returns True if exactly one of the \n    two expressions is True, otherwise it returns False.\n    \n    Parameters:\n    a (int): The first boolean expression (0 or 1).\n    b (int): The second boolean expression (0 or 1).\n\n    Returns:\n    bool: The result of the exclusive or operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    Returns True if exactly one of the two expressions are True, False otherwise.\n    \n    Parameters:\n    a (int): First boolean expression (0 or 1)\n    b (int): Second boolean expression (0 or 1)\n\n    Returns:\n    bool: Result of the XOR operation\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    Returns True if exactly one of the two expressions evaluates to True, False otherwise.\n    \n    Parameters:\n    a (int): The first boolean expression (0 or 1).\n    b (int): The second boolean expression (0 or 1).\n\n    Returns:\n    bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function takes two integers and returns True if exactly one of the \n    two expressions are true, False otherwise.\n    \n    Parameters:\n    a (int): The first integer to evaluate\n    b (int): The second integer to evaluate\n    \n    Returns:\n    bool: True if exactly one of the two expressions is true, False otherwise\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Implements the exclusive \"or\" (xor) logical operation for two integers.\n    Returns True if exactly one of the two expressions is true (non-zero),\n    and False otherwise.\n    \n    Parameters:\n        a (int): The first integer to evaluate.\n        b (int): The second integer to evaluate.\n        \n    Returns:\n        bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Evaluates two boolean inputs and returns True if exactly one of the inputs is True.\n    \n    Args:\n        a (int): First boolean input (0 or 1).\n        b (int): Second boolean input (0 or 1).\n        \n    Returns:\n        bool: The result of the XOR operation on the inputs.\n    \"\"\"\n    a_bool = bool(a)\n    b_bool = bool(b)\n    return a_bool != b_bool", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function takes two integers and returns True if exactly one of the \n    two expressions are true (i.e., one is 1 and the other is 0), and False otherwise.\n    \n    Parameters:\n    - a (int): First operand (0 or 1)\n    - b (int): Second operand (0 or 1)\n\n    Returns:\n    - bool: The result of the XOR operation between a and b\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n    \n    Returns True if exactly one of the two expressions are true, False otherwise.\n    \n    Parameters:\n    a (int): The first expression to evaluate.\n    b (int): The second expression to evaluate.\n    \n    Returns:\n    bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function takes two integers and returns True if exactly one of the \n    two expressions are true (i.e., non-zero), and False otherwise.\n    \n    Args:\n        a (int): The first integer to evaluate.\n        b (int): The second integer to evaluate.\n        \n    Returns:\n        bool: True if exactly one expression is true, False otherwise.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n    \n    This function takes two integers and returns True if exactly one of the \n    two expressions are true, False otherwise.\n    \n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    \n    Returns:\n    bool: The result of the xor operation.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function takes two integers and returns True if exactly one of the \n    two expressions are true, False otherwise.\n    \n    Parameters:\n    a (int): The first integer to evaluate\n    b (int): The second integer to evaluate\n    \n    Returns:\n    bool: The result of the exclusive or operation\n    \"\"\"\n    a_bool = bool(a)\n    b_bool = bool(b)\n    return a_bool != b_bool", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function evaluates two boolean inputs and returns True if exactly one of the inputs is True.\n    Otherwise, it returns False.\n\n    Parameters:\n    a (int): First boolean input (0 or 1)\n    b (int): Second boolean input (0 or 1)\n\n    Returns:\n    bool: The result of the exclusive or operation on the two inputs\n    \"\"\"\n    a_bool = bool(a)\n    b_bool = bool(b)\n    return a_bool != b_bool", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function evaluates two boolean expressions and returns True if exactly one of the \n    two expressions is True, False otherwise.\n    \n    Parameters:\n    a (int): The first boolean expression (1 for True, 0 for False).\n    b (int): The second boolean expression (1 for True, 0 for False).\n\n    Returns:\n    bool: The result of the exclusive or operation on the two expressions.\n    \"\"\"\n    a_bool = bool(a)\n    b_bool = bool(b)\n    return a_bool != b_bool", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    Overview\n    The exclusive or evaluates two booleans. It then returns true if exactly one of the two expressions are true, false otherwise.  \n\n    Task\n    Define a function `xor(a, b)` where a and b are the two expressions to be evaluated. Your `xor` function should have the behaviour described above, returning true if exactly one of the two expressions evaluate to true, false otherwise.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n    \n    This function evaluates two boolean inputs and returns True if exactly one of the inputs is True.\n    \n    Parameters:\n    a (int): First boolean expression (1 for True, 0 for False)\n    b (int): Second boolean expression (1 for True, 0 for False)\n    \n    Returns:\n    bool: The result of the exclusive or operation on the inputs\n    \"\"\"\n    a = bool(a)\n    b = bool(b)\n    return a != b", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Implements the exclusive \"or\" (XOR) logical operation for two integers interpreted as boolean values.\n    \n    Args:\n        a (int): The first operand, treated as a boolean (0 for False, non-zero for True).\n        b (int): The second operand, treated as a boolean (0 for False, non-zero for True).\n        \n    Returns:\n        bool: True if exactly one of the operands is True (non-zero), False otherwise.\n    \"\"\"\n    a_bool = bool(a)\n    b_bool = bool(b)\n    return a_bool != b_bool", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function evaluates two boolean inputs and returns True if exactly one of the two expressions are true, \n    and False otherwise.\n    \n    Parameters:\n    a (int): A integer value that gets cast to boolean\n    b (int): Another integer value that gets cast to boolean\n    \n    Returns:\n    bool: The result of the xor operation on the two boolean inputs.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"\n    Exclusive \"or\" (xor) Logical Operator\n\n    This function takes two integers and returns True if exactly one of the \n    two expressions are true (1), and False otherwise.\n    \n    Parameters:\n    a (int): First expression to evaluate.\n    b (int): Second expression to evaluate.\n\n    Returns:\n    bool: The result of the exclusive or operation.\n    \"\"\"\n    a_bool = bool(a)\n    b_bool = bool(b)\n    return a_bool != b_bool", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator\n    \n    This function evaluates two boolean expressions and returns True if exactly one of the expressions is True, False otherwise.\n    \n    Args:\n        a (int): First boolean expression (0 or 1).\n        b (int): Second boolean expression (0 or 1).\n\n    Returns:\n        bool: True if exactly one expression is True, False otherwise.\n    \"\"\"\n    return bool(a) ^ bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator.\n\n    This function evaluates two boolean expressions and returns True if exactly one of the two expressions is True.\n    Otherwise, it returns False.\n\n    Args:\n        a (int): The first expression to evaluate.\n        b (int): The second expression to evaluate.\n\n    Returns:\n        bool: The result of the xor operation on the two expressions.\n    \"\"\"\n    return bool(a) != bool(b)", "def xor(a: int, b: int) -> bool:\n    \"\"\"Exclusive \"or\" (xor) Logical Operator.\n\n    This function evaluates two boolean expressions and returns True if exactly one of the expressions is True.\n    \n    Args:\n        a (int): The first boolean expression (0 or 1).\n        b (int): The second boolean expression (0 or 1).\n\n    Returns:\n        bool: The result of the xor operation.\n    \"\"\"\n    a_bool = bool(a)\n    b_bool = bool(b)\n    return a_bool != b_bool"], "requirement": [], "outputs": "[[True], [True], [False], [False], [True], [True], [True], [False], [True], [True], [False], [True]]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[[True, False], [False, True], [True, True], [False, False], [True, False], [True, False], [False, True], [False, False], [True, False], [False, True], [False, False], [True, False]]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "xor", "ground_truth": 0}
{"task_id": "TACO_lite/45", "requirement": "from typing import List\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n\"\"\"Don't Drink the Water\n\nGiven a two-dimensional array representation of a glass of mixed liquids, sort the array such that the liquids appear in the glass based on their density. (Lower density floats to the top) The width of the glass will not change from top to bottom.\n\n```\n======================\n|   Density Chart    |\n======================\n| Honey   | H | 1.36 |\n| Water   | W | 1.00 |\n| Alcohol | A | 0.87 |\n| Oil     | O | 0.80 |\n----------------------\n```\n\nThe glass representation may be larger or smaller. If a liquid doesn't fill a row, it floats to the top and to the left.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for sublist in glass for item in sublist]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density.get(x, float('inf')))\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    result = [sorted_flat_glass[i * num_cols:(i + 1) * num_cols] for i in range(num_rows)]\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_list = [item for sublist in glass for item in sublist if item in density_map]\n    sorted_flat_list = sorted(flat_list, key=lambda x: density_map[x])\n    result = []\n    index = 0\n    for row in glass:\n        new_row = []\n        for _ in row:\n            if index < len(sorted_flat_list):\n                new_row.append(sorted_flat_list[index])\n                index += 1\n            else:\n                new_row.append('')\n        result.append(new_row)\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened = [item for sublist in glass for item in sublist]\n    sorted_flattened = sorted(flattened, key=lambda x: density_map.get(x, float('inf')))\n    rows = len(glass)\n    cols = len(glass[0]) if glass else 0\n    separated = [sorted_flattened[i * cols:(i + 1) * cols] for i in range(rows)]\n    return separated", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_map.get(x, float('inf')))\n    height = len(glass)\n    width = len(glass[0]) if glass else 0\n    new_glass = [sorted_flat_glass[i * width:(i + 1) * width] for i in range(height)]\n    return new_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density.get(x, float('inf')))\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    sorted_glass = [sorted_flat_glass[i * num_cols:(i + 1) * num_cols] for i in range(num_rows)]\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened = [item for row in glass for item in row]\n    sorted_flattened = sorted(flattened, key=lambda x: density_map.get(x, float('inf')))\n    height = len(glass)\n    width = len(glass[0]) if glass else 0\n    result = [sorted_flattened[i * width:(i + 1) * width] for i in range(height)]\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for sublist in glass for item in sublist if item in density]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density[x])\n    rows, cols = (len(glass), len(glass[0]) if glass else 0)\n    result_glass = [sorted_flat_glass[i * cols:(i + 1) * cols] for i in range(rows)]\n    return result_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_map.get(x, float('inf')))\n    width = len(glass[0]) if glass else 0\n    height = len(glass)\n    sorted_glass = []\n    index = 0\n    for _ in range(height):\n        sorted_glass.append(sorted_flat_glass[index:index + width])\n        index += width\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_list = [item for row in glass for item in row if item]\n    sorted_flat_list = sorted(flat_list, key=lambda x: density_map.get(x, float('inf')))\n    result_glass = []\n    index = 0\n    for row in glass:\n        new_row = []\n        for _ in row:\n            if index < len(sorted_flat_list):\n                new_row.append(sorted_flat_list[index])\n                index += 1\n            else:\n                new_row.append('')\n        result_glass.append(new_row)\n    return result_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_chart = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_chart[x])\n    sorted_glass = []\n    index = 0\n    for row in glass:\n        new_row = []\n        for _ in row:\n            if index < len(sorted_flat_glass):\n                new_row.append(sorted_flat_glass[index])\n                index += 1\n            else:\n                new_row.append('')\n        sorted_glass.append(new_row)\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'O': 0.8, 'A': 0.87, 'W': 1.0, 'H': 1.36}\n    flat_glass = [item for sublist in glass for item in sublist]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_map.get(x, float('inf')))\n    rows = len(glass)\n    cols = len(glass[0]) if glass else 0\n    separated_glass = [sorted_flat_glass[i * cols:(i + 1) * cols] for i in range(rows)]\n    return separated_glass\nglass = [['A', 'H', 'W'], ['O', 'A', 'H'], ['W', 'O', 'A']]", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_chart = {'O': 0.8, 'A': 0.87, 'W': 1.0, 'H': 1.36}\n    flattened = [item for row in glass for item in row if item in density_chart]\n    sorted_flattened = sorted(flattened, key=lambda x: density_chart[x])\n    result = []\n    index = 0\n    for i in range(len(glass)):\n        row = []\n        for j in range(len(glass[i])):\n            if index < len(sorted_flattened):\n                row.append(sorted_flattened[index])\n                index += 1\n            else:\n                row.append('')\n        result.append(row)\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row]\n    sorted_flat_glass = sorted([item for item in flat_glass if item in density_map], key=density_map.get)\n    result = []\n    index = 0\n    for row in glass:\n        result.append(sorted_flat_glass[index:index + len(row)])\n        index += len(row)\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for sublist in glass for item in sublist]\n    sorted_liquids = sorted(flat_glass, key=lambda x: density_map.get(x, float('inf')))\n    width = len(glass[0]) if glass else 0\n    height = len(glass)\n    return [sorted_liquids[i * width:(i + 1) * width] for i in range(height)]", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_chart = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for sublist in glass for item in sublist if item in density_chart]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_chart[x])\n    rows, cols = (len(glass), len(glass[0]) if glass else 0)\n    result = [sorted_flat_glass[i * cols:(i + 1) * cols] for i in range(rows)]\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened_glass = [liquid for row in glass for liquid in row]\n    sorted_liquids = sorted(flattened_glass, key=lambda x: densities.get(x, float('inf')))\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    sorted_glass = [sorted_liquids[i * num_cols:(i + 1) * num_cols] for i in range(num_rows)]\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density = {'O': 0.8, 'A': 0.87, 'W': 1.0, 'H': 1.36}\n    flattened = [item for sublist in glass for item in sublist]\n    sorted_flattened = sorted(flattened, key=lambda x: (density.get(x, float('inf')), x))\n    rows, cols = (len(glass), len(glass[0]) if glass else 0)\n    result = [sorted_flattened[i * cols:(i + 1) * cols] for i in range(rows)]\n    return result\nglass = [['O', 'H', 'W', 'A'], ['W', 'O', 'A', 'H'], ['H', 'W', 'O', 'A']]", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_map.get(x, float('inf')))\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    sorted_glass = [sorted_flat_glass[i * num_cols:(i + 1) * num_cols] for i in range(num_rows)]\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened = [item for sublist in glass for item in sublist]\n    sorted_flattened = sorted(flattened, key=lambda x: density_map.get(x, float('inf')))\n    rows = len(glass)\n    cols = len(glass[0]) if glass else 0\n    separated = [sorted_flattened[i * cols:(i + 1) * cols] for i in range(rows)]\n    return separated", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_chart = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened_glass = [item for row in glass for item in row]\n    sorted_liq = sorted(flattened_glass, key=lambda x: density_chart.get(x, float('inf')))\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    result = [sorted_liq[i * num_cols:(i + 1) * num_cols] for i in range(num_rows)]\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item in densities]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: densities[x])\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    sorted_glass = [sorted_flat_glass[i * num_cols:(i + 1) * num_cols] for i in range(num_rows)]\n    for i, row in enumerate(glass):\n        if len(row) < num_cols:\n            sorted_glass[i] = sorted_flat_glass[:len(row)]\n            sorted_flat_glass = sorted_flat_glass[len(row):]\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density.get(x, float('inf')))\n    width = len(glass[0]) if glass else 0\n    height = len(glass)\n    sorted_glass = [sorted_flat_glass[i * width:(i + 1) * width] for i in range(height)]\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Sorts a two-dimensional array representation of a glass of mixed liquids based on their density.\n    \n    Args:\n        glass (List[List[str]]): 2D list representing the glass with mixed liquids.\n        \n    Returns:\n        List[List[str]]: 2D list with the liquids sorted by density.\n    \"\"\"\n    density = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_sorted = sorted([item for row in glass for item in row], key=lambda x: density[x])\n    rows, cols = (len(glass), len(glass[0]))\n    sorted_glass = [flat_sorted[i * cols:(i + 1) * cols] for i in range(rows)]\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Sorts a two-dimensional array representation of a glass of mixed liquids based on their density.\n    \n    Parameters:\n        glass (List[List[str]]): A 2D list representing the glass of mixed liquids.\n        \n    Returns:\n        List[List[str]]: A 2D list with liquids sorted by density.\n    \"\"\"\n    density_order = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_order.get(x, float('inf')))\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    sorted_glass = [sorted_flat_glass[i * num_cols:(i + 1) * num_cols] for i in range(num_rows)]\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for sublist in glass for item in sublist]\n    sorted_liquids = sorted(flat_glass, key=lambda x: densities.get(x, 0))\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    sorted_glass = [sorted_liquids[i * num_cols:(i + 1) * num_cols] for i in range(num_rows)]\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_map.get(x, float('inf')))\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    sorted_glass = [sorted_flat_glass[i * num_cols:(i + 1) * num_cols] for i in range(num_rows)]\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_list = [item for sublist in glass for item in sublist]\n    sorted_flat_list = sorted(flat_list, key=lambda x: density_map.get(x, float('-inf')))\n    size = len(glass)\n    if size == 0:\n        return []\n    width = len(glass[0])\n    return [sorted_flat_list[i * width:(i + 1) * width] for i in range(size)]\nglass = [['O', 'H', 'W', 'A'], ['O', 'W', 'A', 'W'], ['H', 'H', 'O', 'A']]"], "requirement": [], "outputs": "[[[['O', 'O', 'O', 'A'], ['A', 'A', 'W', 'W'], ['W', 'H', 'H', 'H']]], [[['O', 'O', 'O', 'A'], ['A', 'A', 'W', 'W'], ['W', 'H', 'H', 'H']]], [[['O', 'O', 'O'], ['A', 'A', 'A'], ['W', 'W', 'W'], ['H', 'H', 'H']]], [[['O', 'O', 'O'], ['A', 'A', 'A'], ['W', 'W', 'W'], ['H', 'H', 'H']]], [[['O', 'O', 'O', 'A', 'A'], ['A', 'A', 'W', 'W', 'W'], ['W', 'H', 'H', 'H', 'H']]], [[[]]], [[['O'], ['A'], ['W'], ['H']]], [[['O', 'A', 'W', 'H'], []]], [[['O', 'A'], ['W', 'W'], ['H', 'H']]], [[['O', 'O', 'A'], ['A', 'W', 'W'], ['W', 'H', 'H']]]]", "probability": 0.54, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_map[x])\n    result = [['' for _ in range(len(glass[0]))] for _ in range(len(glass))]\n    idx = 0\n    for row in reversed(range(len(result))):\n        for col in range(len(result[row])):\n            if idx < len(sorted_flat_glass):\n                result[row][col] = sorted_flat_glass[idx]\n                idx += 1\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_chart = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_chart[x])\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    result = [['' for _ in range(num_cols)] for _ in range(num_rows)]\n    index = 0\n    for row in range(num_rows - 1, -1, -1):\n        for col in range(num_cols):\n            if index < len(sorted_flat_glass):\n                result[row][col] = sorted_flat_glass[index]\n                index += 1\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item in densities]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: densities[x])\n    result_glass = [[''] * len(glass[0]) for _ in range(len(glass))]\n    index = 0\n    for i in range(len(glass) - 1, -1, -1):\n        for j in range(len(glass[0])):\n            if index < len(sorted_flat_glass):\n                result_glass[i][j] = sorted_flat_glass[index]\n                index += 1\n    return result_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_chart = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_list = [item for sublist in glass for item in sublist if item]\n    sorted_flat_list = sorted(flat_list, key=lambda x: density_chart[x])\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    result = [['' for _ in range(num_cols)] for _ in range(num_rows)]\n    index = 0\n    for row in range(num_rows - 1, -1, -1):\n        for col in range(num_cols):\n            if index < len(sorted_flat_list):\n                result[row][col] = sorted_flat_list[index]\n                index += 1\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_list = [item for row in glass for item in row if item in densities]\n    sorted_flat_list = sorted(flat_list, key=lambda x: densities[x])\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    result = [['' for _ in range(num_cols)] for _ in range(num_rows)]\n    for i, liquid in enumerate(sorted_flat_list):\n        row_index = num_rows - 1 - i // num_cols\n        col_index = i % num_cols\n        result[row_index][col_index] = liquid\n    return result"], "requirement": [], "outputs": "[[[['W', 'H', 'H', 'H'], ['A', 'A', 'W', 'W'], ['O', 'O', 'O', 'A']]], [[['W', 'H', 'H', 'H'], ['A', 'A', 'W', 'W'], ['O', 'O', 'O', 'A']]], [[['H', 'H', 'H'], ['W', 'W', 'W'], ['A', 'A', 'A'], ['O', 'O', 'O']]], [[['H', 'H', 'H'], ['W', 'W', 'W'], ['A', 'A', 'A'], ['O', 'O', 'O']]], [[['W', 'H', 'H', 'H', 'H'], ['A', 'A', 'W', 'W', 'W'], ['O', 'O', 'O', 'A', 'A']]], [[[]]], [[['H'], ['W'], ['A'], ['O']]], [[['', '', '', ''], ['O', 'A', 'W', 'H']]], [[['H', 'H'], ['W', 'W'], ['O', 'A']]], [[['W', 'H', 'H'], ['A', 'W', 'W'], ['O', 'O', 'A']]]]", "probability": 0.1, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened_glass = [item for sublist in glass for item in sublist if item in density_map]\n    sorted_flattened_glass = sorted(flattened_glass, key=density_map.get)\n    rows, cols = (len(glass), len(glass[0]))\n    result = [['' for _ in range(cols)] for _ in range(rows)]\n    index = 0\n    for liquid in sorted_flattened_glass:\n        row, col = divmod(index, cols)\n        result[row][col] = liquid\n        index += 1\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_chart = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [cell for row in glass for cell in row if cell]\n    sorted_liquids = sorted(flat_glass, key=lambda x: density_chart.get(x, 0))\n    num_rows, num_cols = (len(glass), len(glass[0]) if glass else 0)\n    new_glass = []\n    for i in range(num_rows):\n        row = []\n        for j in range(num_cols):\n            if sorted_liquids:\n                row.append(sorted_liquids.pop(0))\n            else:\n                row.append('')\n        new_glass.append(row)\n    return new_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item in densities]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: densities[x])\n    result = [['' for _ in range(len(glass[0]))] for _ in range(len(glass))]\n    index = 0\n    for i in range(len(result)):\n        for j in range(len(result[0])):\n            if index < len(sorted_flat_glass):\n                result[i][j] = sorted_flat_glass[index]\n                index += 1\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item in densities]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: densities[x])\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    sorted_glass = []\n    for i in range(num_rows):\n        row = []\n        for j in range(num_cols):\n            if sorted_flat_glass:\n                row.append(sorted_flat_glass.pop(0))\n            else:\n                row.append('')\n        sorted_glass.append(row)\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: densities[x])\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    result = []\n    index = 0\n    for _ in range(num_rows):\n        row = []\n        for __ in range(num_cols):\n            if index < len(sorted_flat_glass):\n                row.append(sorted_flat_glass[index])\n                index += 1\n            else:\n                row.append('')\n        result.append(row)\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened_glass = [item for row in glass for item in row if item in densities]\n    sorted_flattened_glass = sorted(flattened_glass, key=lambda x: densities[x])\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    sorted_glass = [['' for _ in range(num_cols)] for _ in range(num_rows)]\n    index = 0\n    for i in range(num_rows):\n        for j in range(num_cols):\n            if index < len(sorted_flattened_glass):\n                sorted_glass[i][j] = sorted_flattened_glass[index]\n                index += 1\n            else:\n                break\n    return sorted_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_map[x])\n    rows, cols = (len(glass), len(glass[0]))\n    result = [['' for _ in range(cols)] for _ in range(rows)]\n    index = 0\n    for i in range(rows):\n        for j in range(cols):\n            if index < len(sorted_flat_glass):\n                result[i][j] = sorted_flat_glass[index]\n                index += 1\n    return result\nglass = [['H', 'W', 'A'], ['O', '', 'H'], ['W', 'A', '']]", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: densities[x])\n    result_glass = [['' for _ in range(len(glass[0]))] for _ in range(len(glass))]\n    index = 0\n    for i in range(len(result_glass)):\n        for j in range(len(result_glass[i])):\n            if index < len(sorted_flat_glass):\n                result_glass[i][j] = sorted_flat_glass[index]\n                index += 1\n            else:\n                break\n    return result_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened_glass = [item for sublist in glass for item in sublist if item]\n    sorted_liquids = sorted(flattened_glass, key=lambda x: densities[x])\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    result_glass = []\n    for i in range(num_rows):\n        row = []\n        for j in range(num_cols):\n            if sorted_liquids:\n                row.append(sorted_liquids.pop(0))\n            else:\n                row.append('')\n        result_glass.append(row)\n    return result_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    \"\"\"Don't Drink the Water\n\n    Given a two-dimensional array representation of a glass of mixed liquids, sort the array such that the liquids appear in the glass based on their density. (Lower density floats to the top) The width of the glass will not change from top to bottom.\n\n    Density Chart:\n    ----------------------\n    | Honey   | H | 1.36 |\n    | Water   | W | 1.00 |\n    | Alcohol | A | 0.87 |\n    | Oil     | O | 0.80 |\n    ----------------------\n\n    The glass representation may be larger or smaller. If a liquid doesn't fill a row, it floats to the top and to the left.\n    \"\"\"\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for sublist in glass for item in sublist if item]\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_map[x])\n    rows = len(glass)\n    cols = len(glass[0]) if glass else 0\n    result_glass = []\n    for i in range(rows):\n        row = [''] * cols\n        for j in range(cols):\n            if sorted_flat_glass:\n                row[j] = sorted_flat_glass.pop(0)\n        result_glass.append(row)\n    return result_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for row in glass for item in row if item]\n    sorted_items = sorted(flat_glass, key=lambda x: density_map[x])\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    new_glass = []\n    index = 0\n    for _ in range(num_rows):\n        row = []\n        for _ in range(num_cols):\n            if index < len(sorted_items):\n                row.append(sorted_items[index])\n                index += 1\n            else:\n                row.append('')\n        new_glass.append(row)\n    return new_glass"], "requirement": [], "outputs": "[[[['O', 'O', 'O', 'A'], ['A', 'A', 'W', 'W'], ['W', 'H', 'H', 'H']]], [[['O', 'O', 'O', 'A'], ['A', 'A', 'W', 'W'], ['W', 'H', 'H', 'H']]], [[['O', 'O', 'O'], ['A', 'A', 'A'], ['W', 'W', 'W'], ['H', 'H', 'H']]], [[['O', 'O', 'O'], ['A', 'A', 'A'], ['W', 'W', 'W'], ['H', 'H', 'H']]], [[['O', 'O', 'O', 'A', 'A'], ['A', 'A', 'W', 'W', 'W'], ['W', 'H', 'H', 'H', 'H']]], [[[]]], [[['O'], ['A'], ['W'], ['H']]], [[['O', 'A', 'W', 'H'], ['', '', '', '']]], [[['O', 'A'], ['W', 'W'], ['H', 'H']]], [[['O', 'O', 'A'], ['A', 'W', 'W'], ['W', 'H', 'H']]]]", "probability": 0.22, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened_glass = [liquid for row in glass for liquid in row]\n    sorted_liquids = sorted(flattened_glass, key=lambda x: densities.get(x, 0))\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if num_rows > 0 else 0\n    new_glass = []\n    for i in range(0, len(sorted_liquids), num_cols):\n        new_glass.append(sorted_liquids[i:i + num_cols])\n    return new_glass", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_chart = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_list = [item for row in glass for item in row]\n    liquids = [liquid for liquid in flat_list if liquid in density_chart]\n    sorted_liquids = sorted(liquids, key=lambda x: density_chart[x])\n    result = []\n    for i in range(0, len(flat_list), len(glass[0])):\n        row = sorted_liquids[i:i + len(glass[0])]\n        if len(row) < len(glass[0]):\n            row.extend([''] * (len(glass[0]) - len(row)))\n        result.append(row)\n    return result"], "requirement": [], "outputs": "[[[['O', 'O', 'O', 'A'], ['A', 'A', 'W', 'W'], ['W', 'H', 'H', 'H']]], [[['O', 'O', 'O', 'A'], ['A', 'A', 'W', 'W'], ['W', 'H', 'H', 'H']]], [[['O', 'O', 'O'], ['A', 'A', 'A'], ['W', 'W', 'W'], ['H', 'H', 'H']]], [[['O', 'O', 'O'], ['A', 'A', 'A'], ['W', 'W', 'W'], ['H', 'H', 'H']]], [[['O', 'O', 'O', 'A', 'A'], ['A', 'A', 'W', 'W', 'W'], ['W', 'H', 'H', 'H', 'H']]], ['ValueError'], [[['O'], ['A'], ['W'], ['H']]], [[['O', 'A', 'W', 'H']]], [[['O', 'A'], ['W', 'W'], ['H', 'H']]], [[['O', 'O', 'A'], ['A', 'W', 'W'], ['W', 'H', 'H']]]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_map = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_glass = [item for sublist in glass for item in sublist if item != ' ']\n    sorted_flat_glass = sorted(flat_glass, key=lambda x: density_map.get(x, float('inf')))\n    result = []\n    for i in range(0, len(sorted_flat_glass), len(glass[0])):\n        row = sorted_flat_glass[i:i + len(glass[0])]\n        if len(row) < len(glass[0]):\n            row += [' '] * (len(glass[0]) - len(row))\n        result.append(row)\n    return result[::-1]\nglass = [['H', 'O', 'W'], ['W', 'A', 'O'], ['O', ' ', ' ']]"], "requirement": [], "outputs": "[[[['W', 'H', 'H', 'H'], ['A', 'A', 'W', 'W'], ['O', 'O', 'O', 'A']]], [[['W', 'H', 'H', 'H'], ['A', 'A', 'W', 'W'], ['O', 'O', 'O', 'A']]], [[['H', 'H', 'H'], ['W', 'W', 'W'], ['A', 'A', 'A'], ['O', 'O', 'O']]], [[['H', 'H', 'H'], ['W', 'W', 'W'], ['A', 'A', 'A'], ['O', 'O', 'O']]], [[['W', 'H', 'H', 'H', 'H'], ['A', 'A', 'W', 'W', 'W'], ['O', 'O', 'O', 'A', 'A']]], ['ValueError'], [[['H'], ['W'], ['A'], ['O']]], [[['O', 'A', 'W', 'H']]], [[['H', 'H'], ['W', 'W'], ['O', 'A']]], [[['W', 'H', 'H'], ['A', 'W', 'W'], ['O', 'O', 'A']]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    density_chart = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened_glass = [item for row in glass for item in row if item != '.']\n    sorted_liquids = sorted(flattened_glass, key=lambda x: density_chart[x])\n    num_rows = len(glass)\n    num_cols = len(glass[0]) if glass else 0\n    result_glass = []\n    index = 0\n    for _ in range(num_rows):\n        row = []\n        for _ in range(num_cols):\n            if index < len(sorted_liquids):\n                row.append(sorted_liquids[index])\n                index += 1\n            else:\n                row.append('.')\n        result_glass.append(row)\n    return result_glass"], "requirement": [], "outputs": "[[[['O', 'O', 'O', 'A'], ['A', 'A', 'W', 'W'], ['W', 'H', 'H', 'H']]], [[['O', 'O', 'O', 'A'], ['A', 'A', 'W', 'W'], ['W', 'H', 'H', 'H']]], [[['O', 'O', 'O'], ['A', 'A', 'A'], ['W', 'W', 'W'], ['H', 'H', 'H']]], [[['O', 'O', 'O'], ['A', 'A', 'A'], ['W', 'W', 'W'], ['H', 'H', 'H']]], [[['O', 'O', 'O', 'A', 'A'], ['A', 'A', 'W', 'W', 'W'], ['W', 'H', 'H', 'H', 'H']]], [[[]]], [[['O'], ['A'], ['W'], ['H']]], [[['O', 'A', 'W', 'H'], ['.', '.', '.', '.']]], [[['O', 'A'], ['W', 'W'], ['H', 'H']]], [[['O', 'O', 'A'], ['A', 'W', 'W'], ['W', 'H', 'H']]]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flattened_glass = [item for row in glass for item in row if item]\n    sorted_flattened_glass = sorted(flattened_glass, key=lambda x: densities[x])\n    result = [['' for _ in range(len(glass[0]))] for _ in range(len(glass))]\n    index = 0\n    for row in reversed(range(len(glass))):\n        for col in range(len(glass[row])):\n            if index < len(sorted_flattened_glass):\n                result[row][col] = sorted_flattened_glass[index]\n                index += 1\n    return result", "from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    densities = {'H': 1.36, 'W': 1.0, 'A': 0.87, 'O': 0.8}\n    flat_list = [item for row in glass for item in row if item in densities]\n    sorted_flat_list = sorted(flat_list, key=lambda x: densities[x])\n    result = [[''] * len(glass[0]) for _ in range(len(glass))]\n    index = 0\n    for i in range(len(glass) - 1, -1, -1):\n        for j in range(len(glass[i])):\n            if index < len(sorted_flat_list):\n                result[i][j] = sorted_flat_list[index]\n                index += 1\n    return result"], "requirement": [], "outputs": "[[[['W', 'H', 'H', 'H'], ['A', 'A', 'W', 'W'], ['O', 'O', 'O', 'A']]], [[['W', 'H', 'H', 'H'], ['A', 'A', 'W', 'W'], ['O', 'O', 'O', 'A']]], [[['H', 'H', 'H'], ['W', 'W', 'W'], ['A', 'A', 'A'], ['O', 'O', 'O']]], [[['H', 'H', 'H'], ['W', 'W', 'W'], ['A', 'A', 'A'], ['O', 'O', 'O']]], [[['W', 'H', 'H', 'H', 'H'], ['A', 'A', 'W', 'W', 'W'], ['O', 'O', 'O', 'A', 'A']]], [[[]]], [[['H'], ['W'], ['A'], ['O']]], [[['O', 'A', 'W', 'H'], ['', '', '', '']]], [[['H', 'H'], ['W', 'W'], ['O', 'A']]], [[['W', 'H', 'H'], ['A', 'W', 'W'], ['O', 'O', 'A']]]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Sorts the liquids in a two-dimensional array based on their density.\n    \n    Parameters:\n    glass (List[List[str]]): A 2D list representing the glass of mixed liquids.\n    \n    Returns:\n    List[List[str]]: The sorted 2D list with liquids organized by their density.\n    \"\"\"\n    density_map = {'O': 0.8, 'A': 0.87, 'W': 1.0, 'H': 1.36}\n    flattened_glass = [item for sublist in glass for item in sublist if item]\n    sorted_flatten_glass = sorted(flattened_glass, key=density_map.get)\n    num_rows = len(glass)\n    num_cols = len(glass[0])\n    result = [[' ' for _ in range(num_cols)] for _ in range(num_rows)]\n    idx = 0\n    for row in range(num_rows - 1, -1, -1):\n        for col in range(num_cols):\n            if idx < len(sorted_flatten_glass):\n                result[row][col] = sorted_flatten_glass[idx]\n                idx += 1\n    return result"], "requirement": [], "outputs": "[[[['W', 'H', 'H', 'H'], ['A', 'A', 'W', 'W'], ['O', 'O', 'O', 'A']]], [[['W', 'H', 'H', 'H'], ['A', 'A', 'W', 'W'], ['O', 'O', 'O', 'A']]], [[['H', 'H', 'H'], ['W', 'W', 'W'], ['A', 'A', 'A'], ['O', 'O', 'O']]], [[['H', 'H', 'H'], ['W', 'W', 'W'], ['A', 'A', 'A'], ['O', 'O', 'O']]], [[['W', 'H', 'H', 'H', 'H'], ['A', 'A', 'W', 'W', 'W'], ['O', 'O', 'O', 'A', 'A']]], [[[]]], [[['H'], ['W'], ['A'], ['O']]], [[[' ', ' ', ' ', ' '], ['O', 'A', 'W', 'H']]], [[['H', 'H'], ['W', 'W'], ['O', 'A']]], [[['W', 'H', 'H'], ['A', 'W', 'W'], ['O', 'O', 'A']]]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.3883385720819612, "llm_generated_inputs": "[[[['H', 'W', 'A', 'O'], ['W', 'A', 'O', 'H'], ['O', 'H', 'W', 'A']]], [[['O', 'A', 'W', 'H'], ['H', 'W', 'A', 'O'], ['A', 'O', 'H', 'W']]], [[['H', 'H', 'H'], ['W', 'W', 'W'], ['A', 'A', 'A'], ['O', 'O', 'O']]], [[['O', 'O', 'O'], ['A', 'A', 'A'], ['W', 'W', 'W'], ['H', 'H', 'H']]], [[['H', 'W', 'A', 'O', 'H'], ['W', 'A', 'O', 'H', 'W'], ['A', 'O', 'H', 'W', 'A']]], [[[]]], [[['H'], ['W'], ['A'], ['O']]], [[['O', 'A', 'W', 'H'], []]], [[['O', 'W'], ['H', 'A'], ['W', 'H']]], [[['A', 'W', 'H'], ['O', 'H', 'W'], ['W', 'A', 'O']]]]", "input_output_examples": "[[[['H', 'H', 'W', 'O'], ['W', 'W', 'O', 'W'], ['H', 'H', 'O', 'O']]], [[['O', 'O', 'O', 'O'], ['W', 'W', 'W', 'W'], ['H', 'H', 'H', 'H']]]]", "at_least_one_align": false}, "entry_point": "separate_liquids", "ground_truth": -1}
{"task_id": "TACO_lite/46", "requirement": "from typing import List\ndef build_square(blocks: List[int]) -> bool:\n\"\"\"# The Invitation\n\nMost of us played with toy blocks growing up. It was fun and you learned stuff. So what else can you do but rise to the challenge when a 3-year old exclaims, \"Look, I made a square!\", then pointing to a pile of blocks, \"Can _you_ do it?\"\n\n# These Blocks\n\nJust to play along, of course we'll be viewing these blocks in two dimensions. Depth now being disregarded, it turns out the pile has four different sizes of block: `1x1`, `1x2`, `1x3`, and `1x4`. The smallest one represents the area of a square, the other three are rectangular, and all differ by their width. Integers matching these four widths are used to represent the blocks in the input.\n\n# This Square\n\nWell, the kid made a `4x4` square from this pile, so you'll have to match that. Noticing the way they fit together, you realize the structure must be built in fours rows, one row at a time, where the blocks must be placed horizontally. With the known types of block, there are five types of row you could build:\n\n* 1 four-unit block\n* 1 three-unit block plus 1 one-unit bock (in either order)\n* 2 two-unit blocks\n* 1 two-unit block plus 2 one-unit blocks (in any order)\n* 4 one-unit blocks\n\nAmounts for all four of the block sizes in the pile will each vary from `0` to `16`. The total size of the pile will also vary from `0` to `16`. The order of rows is irrelevant. A valid square doesn't have to use up all the given blocks.\n\n# Input\n```python\nblocks ~ a random list of integers (1 <= x <= 4)\n```\n# Output\n```python\nTrue or False ~ whether you can build a square\n```\n# Enjoy!\n\nIf interested, I also have [this kata](https://www.codewars.com/kata/5cb7baa989b1c50014a53333) as well as [this other kata](https://www.codewars.com/kata/5cb5eb1f03c3ff4778402099) to consider solving.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    for _ in range(4):\n        found_valid_row = False\n        patterns = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n        for pattern in patterns:\n            if all((block_counts[block] >= count for block, count in Counter(pattern).items())):\n                for block in pattern:\n                    block_counts[block] -= 1\n                found_valid_row = True\n                break\n        if not found_valid_row:\n            return False\n    return True", "from collections import Counter\nfrom typing import List\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    for _ in range(4):\n        if 4 in block_counts and block_counts[4] > 0:\n            block_counts[4] -= 1\n        elif 3 in block_counts and block_counts[3] > 0 and (1 in block_counts) and (block_counts[1] > 0):\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n        elif 2 in block_counts and block_counts[2] >= 2:\n            block_counts[2] -= 2\n        elif 2 in block_counts and block_counts[2] > 0 and (1 in block_counts) and (block_counts[1] >= 2):\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n        elif 1 in block_counts and block_counts[1] >= 4:\n            block_counts[1] -= 4\n        else:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef can_build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    row_variations = [{4: 1}, {3: 1, 1: 1}, {1: 1, 3: 1}, {2: 2}, {2: 1, 1: 2}, {1: 2, 2: 1}, {1: 4}]\n\n    def can_form_row(counts):\n        for row in row_variations:\n            if all((counts[block] >= count for block, count in row.items())):\n                return (True, row)\n        return (False, None)\n    for _ in range(4):\n        success, used_row = can_form_row(block_counts)\n        if not success:\n            return False\n        for block, count in used_row.items():\n            block_counts[block] -= count\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    possible_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n    for _ in range(4):\n        row_formed = False\n        for row in possible_rows:\n            temp_block_counts = block_counts.copy()\n            valid_row = True\n            for block_size in row:\n                if temp_block_counts[block_size] <= 0:\n                    valid_row = False\n                    break\n                temp_block_counts[block_size] -= 1\n            if valid_row:\n                block_counts = temp_block_counts\n                row_formed = True\n                break\n        if not row_formed:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef can_build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    rows = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n    for _ in range(4):\n        found_valid_row = False\n        for row in rows:\n            if all((block_counts[block] >= count for block, count in row.items())):\n                for block, count in row.items():\n                    block_counts[block] -= count\n                found_valid_row = True\n                break\n        if not found_valid_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    row_configurations = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n\n    def can_form_row(config):\n        for size, count in config.items():\n            if block_counts[size] < count:\n                return False\n        return True\n\n    def use_blocks(config):\n        for size, count in config.items():\n            block_counts[size] -= count\n    for _ in range(4):\n        row_formed = False\n        for config in row_configurations:\n            if can_form_row(config):\n                use_blocks(config)\n                row_formed = True\n                break\n        if not row_formed:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    row_configurations = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n\n    def can_build_row(config):\n        for size, count in config.items():\n            if block_counts[size] < count:\n                return False\n        return True\n\n    def build_row(config):\n        for size, count in config.items():\n            block_counts[size] -= count\n    for _ in range(4):\n        for config in row_configurations:\n            if can_build_row(config):\n                build_row(config)\n                break\n        else:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    required_blocks_per_row = {1: 4, 2: 2, 3: 1, 4: 1}\n    for _ in range(4):\n        if block_counts[4] > 0:\n            block_counts[4] -= 1\n            continue\n        elif block_counts[3] > 0 and block_counts[1] > 0:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n            continue\n        elif block_counts[2] >= 2:\n            block_counts[2] -= 2\n            continue\n        elif block_counts[2] == 1 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n            continue\n        elif block_counts[1] >= 4:\n            block_counts[1] -= 4\n            continue\n        else:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    target_row_length = 4\n    num_rows = 4\n    for _ in range(num_rows):\n        if block_counts[4] > 0:\n            block_counts[4] -= 1\n        elif block_counts[3] > 0 and block_counts[1] > 0:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n        elif block_counts[2] >= 2:\n            block_counts[2] -= 2\n        elif block_counts[2] > 0 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n        elif block_counts[1] >= 4:\n            block_counts[1] -= 4\n        else:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef can_build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    row_configurations = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n    for _ in range(4):\n        found_valid_row = False\n        for config in row_configurations:\n            temp_block_counts = block_counts.copy()\n            valid = True\n            for block in config:\n                if temp_block_counts[block] <= 0:\n                    valid = False\n                    break\n                temp_block_counts[block] -= 1\n            if valid:\n                block_counts = temp_block_counts\n                found_valid_row = True\n                break\n        if not found_valid_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n\n    def can_form_row(bcounts):\n        if bcounts[4] >= 1:\n            return True\n        if bcounts[3] >= 1 and bcounts[1] >= 1:\n            return True\n        if bcounts[2] >= 2:\n            return True\n        if bcounts[2] >= 1 and bcounts[1] >= 2:\n            return True\n        if bcounts[1] >= 4:\n            return True\n        return False\n    for _ in range(4):\n        if not can_form_row(block_counts):\n            return False\n        if block_counts[4] >= 1:\n            block_counts[4] -= 1\n        elif block_counts[3] >= 1 and block_counts[1] >= 1:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n        elif block_counts[2] >= 2:\n            block_counts[2] -= 2\n        elif block_counts[2] >= 1 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n        elif block_counts[1] >= 4:\n            block_counts[1] -= 4\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    row_configs = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n\n    def can_form_row(row_config):\n        temp_counts = block_counts.copy()\n        for block in row_config:\n            if temp_counts[block] <= 0:\n                return False\n            temp_counts[block] -= 1\n        return True\n    for _ in range(4):\n        found_valid_row = False\n        for config in row_configs:\n            if can_form_row(config):\n                found_valid_row = True\n                for block in config:\n                    block_counts[block] -= 1\n                break\n        if not found_valid_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    total_blocks = sum(blocks)\n    if total_blocks < 16:\n        return False\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n\n    def can_form_row(row: List[int]):\n        temp_counts = block_counts.copy()\n        for block in row:\n            if temp_counts[block] <= 0:\n                return False\n            temp_counts[block] -= 1\n        return True\n    for _ in range(4):\n        found_valid_row = False\n        for row in valid_rows:\n            if can_form_row(row):\n                found_valid_row = True\n                for block in row:\n                    block_counts[block] -= 1\n                break\n        if not found_valid_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    rows_needed = 4\n\n    def can_build_row():\n        for size in [4, 3, 2, 1]:\n            if block_counts[size] > 0:\n                if size == 4:\n                    block_counts[4] -= 1\n                    return True\n                elif size == 3 and block_counts[1] > 0:\n                    block_counts[3] -= 1\n                    block_counts[1] -= 1\n                    return True\n                elif size == 2:\n                    if block_counts[2] >= 2:\n                        block_counts[2] -= 2\n                        return True\n                    elif block_counts[2] == 1 and block_counts[1] >= 2:\n                        block_counts[2] -= 1\n                        block_counts[1] -= 2\n                        return True\n                    elif block_counts[1] >= 4:\n                        block_counts[1] -= 4\n                        return True\n                elif size == 1 and block_counts[1] >= 4:\n                    block_counts[1] -= 4\n                    return True\n        return False\n    for _ in range(rows_needed):\n        if not can_build_row():\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n\n    def can_form_row(row_blocks):\n        temp_counts = block_counts.copy()\n        for block in row_blocks:\n            if temp_counts[block] == 0:\n                return False\n            temp_counts[block] -= 1\n        return True\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n    for _ in range(4):\n        found_valid_row = False\n        for row in valid_rows:\n            if can_form_row(row):\n                found_valid_row = True\n                for block in row:\n                    block_counts[block] -= 1\n                break\n        if not found_valid_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    if len(blocks) < 4:\n        return False\n    block_counts = Counter(blocks)\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n\n    def can_form_row(row, block_counts):\n        temp_counts = block_counts.copy()\n        for block in row:\n            if temp_counts[block] > 0:\n                temp_counts[block] -= 1\n            else:\n                return False\n        return True\n    for _ in range(4):\n        found_valid_row = False\n        for row in valid_rows:\n            if can_form_row(row, block_counts):\n                found_valid_row = True\n                for block in row:\n                    block_counts[block] -= 1\n                break\n        if not found_valid_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef can_build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n\n    def can_build_row(block_counts, row):\n        temp_counts = block_counts.copy()\n        for block in row:\n            if temp_counts[block] <= 0:\n                return False\n            temp_counts[block] -= 1\n        return True\n    for _ in range(4):\n        found = False\n        for row in valid_rows:\n            if can_build_row(block_counts, row):\n                for block in row:\n                    block_counts[block] -= 1\n                found = True\n                break\n        if not found:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    valid_combinations = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n\n    def can_build_square(rows_remaining, block_counts):\n        if rows_remaining == 0:\n            return True\n        for combination in valid_combinations:\n            temp_block_counts = block_counts.copy()\n            valid = True\n            for block in combination:\n                if temp_block_counts[block] > 0:\n                    temp_block_counts[block] -= 1\n                else:\n                    valid = False\n                    break\n            if valid and can_build_square(rows_remaining - 1, temp_block_counts):\n                return True\n        return False\n    return can_build_square(4, block_counts)", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    possible_row_configurations = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n    for _ in range(4):\n        row_found = False\n        for configuration in possible_row_configurations:\n            if all((block_counts[block_size] >= count for block_size, count in Counter(configuration).items())):\n                for block_size in configuration:\n                    block_counts[block_size] -= 1\n                row_found = True\n                break\n        if not row_found:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n\n    def can_form_row(row):\n        temp_counts = block_counts.copy()\n        for block in row:\n            if temp_counts[block] == 0:\n                return False\n            temp_counts[block] -= 1\n        return True\n    for _ in range(4):\n        found_valid_row = False\n        for row in valid_rows:\n            if can_form_row(row):\n                for block in row:\n                    block_counts[block] -= 1\n                found_valid_row = True\n                break\n        if not found_valid_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n    for _ in range(4):\n        found_row = False\n        for row in valid_rows:\n            temp_blocks = block_counts.copy()\n            if can_form_row(row, temp_blocks):\n                block_counts = temp_blocks\n                found_row = True\n                break\n        if not found_row:\n            return False\n    return True\n\ndef can_form_row(row: List[int], block_counts: Counter) -> bool:\n    for block in row:\n        if block_counts[block] > 0:\n            block_counts[block] -= 1\n        else:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef can_build_square(blocks: List[int]) -> bool:\n    block_count = Counter(blocks)\n    valid_rows = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n    for _ in range(4):\n        valid_row_found = False\n        for row in valid_rows:\n            temp_block_count = block_count.copy()\n            row_valid = True\n            for block_size, count in row.items():\n                if temp_block_count[block_size] < count:\n                    row_valid = False\n                    break\n                temp_block_count[block_size] -= count\n            if row_valid:\n                valid_row_found = True\n                block_count = temp_block_count\n                break\n        if not valid_row_found:\n            return False\n    return True", "from collections import Counter\nfrom typing import List\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    row_patterns = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n    for _ in range(4):\n        row_formed = False\n        for pattern in row_patterns:\n            if all((block_counts[block_type] >= count for block_type, count in pattern.items())):\n                for block_type, count in pattern.items():\n                    block_counts[block_type] -= count\n                row_formed = True\n                break\n        if not row_formed:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    rows = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n\n    def can_build_row(row):\n        temp_block_counts = block_counts.copy()\n        for block_size, required_count in row.items():\n            if temp_block_counts[block_size] < required_count:\n                return False\n            temp_block_counts[block_size] -= required_count\n        return True\n    for _ in range(4):\n        built_row = False\n        for row in rows:\n            if can_build_row(row):\n                for block_size, required_count in row.items():\n                    block_counts[block_size] -= required_count\n                built_row = True\n                break\n        if not built_row:\n            return False\n    return True", "from collections import Counter\nfrom typing import List\n\ndef can_build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    valid_rows = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n    for _ in range(4):\n        found_row = False\n        for valid_row in valid_rows:\n            if all((block_counts[block_size] >= count for block_size, count in valid_row.items())):\n                for block_size, count in valid_row.items():\n                    block_counts[block_size] -= count\n                found_row = True\n                break\n        if not found_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    if sum(block_counts.values()) < 4:\n        return False\n    total_units = sum((size * count for size, count in block_counts.items()))\n    if total_units < 16:\n        return False\n\n    def can_form_row(block_counts):\n        if block_counts[4] >= 1:\n            return True\n        if block_counts[3] >= 1 and block_counts[1] >= 1:\n            return True\n        if block_counts[2] >= 2:\n            return True\n        if block_counts[2] >= 1 and block_counts[1] >= 2:\n            return True\n        if block_counts[1] >= 4:\n            return True\n        return False\n    for _ in range(4):\n        if not can_form_row(block_counts):\n            return False\n        if block_counts[4] >= 1:\n            block_counts[4] -= 1\n        elif block_counts[3] >= 1 and block_counts[1] >= 1:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n        elif block_counts[2] >= 2:\n            block_counts[2] -= 2\n        elif block_counts[2] >= 1 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n        elif block_counts[1] >= 4:\n            block_counts[1] -= 4\n        else:\n            return False\n    return True", "from collections import Counter\nfrom typing import List\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n\n    def can_build_row(row_config, block_counts):\n        for block_size, count in row_config.items():\n            if block_counts[block_size] < count:\n                return False\n            block_counts[block_size] -= count\n        return True\n    valid_rows = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n    for _ in range(4):\n        for row in valid_rows:\n            new_block_counts = block_counts.copy()\n            if can_build_row(row, new_block_counts):\n                block_counts = new_block_counts\n                break\n        else:\n            return False\n    return sum(block_counts.values()) >= 0", "from typing import List\nfrom collections import Counter\n\ndef can_build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    total_blocks_needed = 16\n\n    def can_build_row(counts):\n        if counts[4] > 0:\n            new_counts = counts.copy()\n            new_counts[4] -= 1\n            return new_counts\n        if counts[3] > 0 and counts[1] > 0:\n            new_counts = counts.copy()\n            new_counts[3] -= 1\n            new_counts[1] -= 1\n            return new_counts\n        if counts[2] >= 2:\n            new_counts = counts.copy()\n            new_counts[2] -= 2\n            return new_counts\n        if counts[2] > 0 and counts[1] >= 2:\n            new_counts = counts.copy()\n            new_counts[2] -= 1\n            new_counts[1] -= 2\n            return new_counts\n        if counts[1] >= 4:\n            new_counts = counts.copy()\n            new_counts[1] -= 4\n            return new_counts\n        return None\n    for _ in range(4):\n        block_counts = can_build_row(block_counts)\n        if block_counts is None:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    rows_needed = 4\n    while rows_needed > 0:\n        if block_counts[4] > 0:\n            block_counts[4] -= 1\n            rows_needed -= 1\n        elif block_counts[3] > 0 and block_counts[1] > 0:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n            rows_needed -= 1\n        elif block_counts[2] >= 2:\n            block_counts[2] -= 2\n            rows_needed -= 1\n        elif block_counts[2] > 0 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n            rows_needed -= 1\n        elif block_counts[1] >= 4:\n            block_counts[1] -= 4\n            rows_needed -= 1\n        else:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    needed_blocks = {1: 0, 2: 0, 3: 0, 4: 0}\n    for _ in range(4):\n        found_row = False\n        if block_counts[4] >= 1:\n            block_counts[4] -= 1\n            found_row = True\n        elif block_counts[3] >= 1 and block_counts[1] >= 1:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n            found_row = True\n        elif block_counts[2] >= 2:\n            block_counts[2] -= 2\n            found_row = True\n        elif block_counts[2] >= 1 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n            found_row = True\n        elif block_counts[1] >= 4:\n            block_counts[1] -= 4\n            found_row = True\n        if not found_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    \"\"\"\n    Checks if it's possible to build a 4x4 square using the given blocks.\n    Each block is represented by an integer (1, 2, 3, or 4) indicating its width.\n    The function returns True if a 4x4 square can be built, False otherwise.\n    \"\"\"\n    block_counts = Counter(blocks)\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n    for _ in range(4):\n        found_row = False\n        for row in valid_rows:\n            temp_block_counts = block_counts.copy()\n            for block in row:\n                if temp_block_counts[block] > 0:\n                    temp_block_counts[block] -= 1\n                else:\n                    break\n            else:\n                block_counts = temp_block_counts\n                found_row = True\n                break\n        if not found_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    total_area_needed = 16\n\n    def can_form_row():\n        nonlocal total_area_needed\n        if block_counts[4] > 0:\n            block_counts[4] -= 1\n            return True\n        if block_counts[3] > 0 and block_counts[1] > 0:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n            return True\n        if block_counts[2] >= 2:\n            block_counts[2] -= 2\n            return True\n        if block_counts[2] > 0 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n            return True\n        if block_counts[1] >= 4:\n            block_counts[1] -= 4\n            return True\n        return False\n    for _ in range(4):\n        if not can_form_row():\n            return False\n        total_area_needed -= 4\n    return total_area_needed == 0", "from typing import List\nfrom collections import Counter\n\ndef can_build_square(blocks: List[int]) -> bool:\n    \"\"\"\n    Checks if it is possible to build a 4x4 square using the given blocks.\n    Each block can be of size 1, 2, 3, or 4.\n    \n    Args:\n        blocks: A list of integers representing the block sizes.\n        \n    Returns:\n        True if a 4x4 square can be built, False otherwise.\n    \"\"\"\n    block_counts = Counter(blocks)\n    valid_rows = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n    for _ in range(4):\n        found_row = False\n        for row_template in valid_rows:\n            row_blocks = row_template.copy()\n            for block_size, count in row_blocks.items():\n                if block_counts[block_size] >= count:\n                    block_counts[block_size] -= count\n                else:\n                    break\n            else:\n                found_row = True\n                break\n        if not found_row:\n            return False\n    for count in block_counts.values():\n        if count < 0:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef can_build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n\n    def can_form_row():\n        if block_counts[4] > 0:\n            block_counts[4] -= 1\n            return True\n        if block_counts[3] > 0 and block_counts[1] > 0:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n            return True\n        if block_counts[1] >= 4:\n            block_counts[1] -= 4\n            return True\n        if block_counts[2] >= 2:\n            block_counts[2] -= 2\n            return True\n        if block_counts[2] > 0 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n            return True\n        if block_counts[1] >= 4:\n            block_counts[1] -= 4\n            return True\n        return False\n    for _ in range(4):\n        if not can_form_row():\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    for _ in range(4):\n        if block_counts[4] > 0:\n            block_counts[4] -= 1\n        elif block_counts[3] > 0 and block_counts[1] > 0:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n        elif block_counts[2] >= 2:\n            block_counts[2] -= 2\n        elif block_counts[2] > 0 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n        elif block_counts[1] >= 4:\n            block_counts[1] -= 4\n        else:\n            return False\n    return True", "from collections import Counter\nfrom typing import List\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    valid_rows = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n\n    def can_form_row(block_counts):\n        for row in valid_rows:\n            temp_counts = block_counts.copy()\n            for block_size, count in row.items():\n                if temp_counts[block_size] >= count:\n                    temp_counts[block_size] -= count\n                else:\n                    break\n            else:\n                return (True, temp_counts)\n        return (False, block_counts)\n    for _ in range(4):\n        can_build_row, updated_block_counts = can_form_row(block_counts)\n        if not can_build_row:\n            return False\n        block_counts = updated_block_counts\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    \"\"\"\n    Determine if it's possible to build a 4x4 square using the given blocks.\n    \n    Args:\n    blocks (List[int]): A list of integers representing block sizes (1, 2, 3, or 4).\n    \n    Returns:\n    bool: True if it's possible to build a square, False otherwise.\n    \"\"\"\n    block_counts = Counter(blocks)\n    for _ in range(4):\n        found_row = False\n        if block_counts[4] > 0:\n            block_counts[4] -= 1\n            found_row = True\n        elif block_counts[3] > 0 and block_counts[1] > 0:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n            found_row = True\n        elif block_counts[2] >= 2:\n            block_counts[2] -= 2\n            found_row = True\n        elif block_counts[2] > 0 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n            found_row = True\n        elif block_counts[1] >= 4:\n            block_counts[1] -= 4\n            found_row = True\n        if not found_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    for _ in range(4):\n        if 4 in block_counts and block_counts[4] > 0:\n            block_counts[4] -= 1\n        elif 3 in block_counts and block_counts[3] > 0 and (1 in block_counts) and (block_counts[1] > 0):\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n        elif 2 in block_counts and block_counts[2] >= 2:\n            block_counts[2] -= 2\n        elif 2 in block_counts and block_counts[2] > 0 and (1 in block_counts) and (block_counts[1] >= 2):\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n        elif 1 in block_counts and block_counts[1] >= 4:\n            block_counts[1] -= 4\n        else:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n\n    def can_build_row(block_counts):\n        for row in valid_rows:\n            temp_counts = block_counts.copy()\n            try:\n                for block in row:\n                    if temp_counts[block] <= 0:\n                        raise ValueError\n                    temp_counts[block] -= 1\n                return (True, temp_counts)\n            except ValueError:\n                continue\n        return (False, None)\n    for _ in range(4):\n        success, new_block_counts = can_build_row(block_counts)\n        if not success:\n            return False\n        block_counts = new_block_counts\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    for _ in range(4):\n        found_valid_row = False\n        if block_counts[4] >= 1:\n            block_counts[4] -= 1\n            found_valid_row = True\n        elif block_counts[3] >= 1 and block_counts[1] >= 1:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n            found_valid_row = True\n        elif block_counts[2] >= 2:\n            block_counts[2] -= 2\n            found_valid_row = True\n        elif block_counts[2] >= 1 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n            found_valid_row = True\n        elif block_counts[1] >= 4:\n            block_counts[1] -= 4\n            found_valid_row = True\n        if not found_valid_row:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    target_area = 16\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 1, 1]]\n\n    def can_build_square(block_counts):\n        for _ in range(4):\n            found_row = False\n            for row in valid_rows:\n                temp_block_counts = block_counts.copy()\n                if try_build_row(temp_block_counts, row):\n                    block_counts = temp_block_counts\n                    found_row = True\n                    break\n            if not found_row:\n                return False\n        return sum(block_counts.values()) >= 0\n\n    def try_build_row(block_counts, row):\n        for width in row:\n            if block_counts[width] <= 0:\n                return False\n            block_counts[width] -= 1\n        return True\n    return can_build_square(block_counts)"], "requirement": [], "outputs": "[[True], [False], [False], [False], [False], [False], [False], [True], [True], [False], [False], [False], [False], [True], [True], [True], [False], [True]]", "probability": 0.82, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\nfrom collections import Counter\n\ndef can_build_square(blocks: List[int]) -> bool:\n    count = Counter(blocks)\n    while sum(count.values()) >= 4:\n        if count[4] > 0:\n            count[4] -= 1\n        elif count[2] >= 2:\n            count[2] -= 2\n        elif count[3] > 0 and count[1] > 0:\n            count[3] -= 1\n            count[1] -= 1\n        elif count[2] > 0 and count[1] >= 2:\n            count[2] -= 1\n            count[1] -= 2\n        elif count[1] >= 4:\n            count[1] -= 4\n        else:\n            return False\n        if sum(count.values()) % 4 == 0:\n            continue\n        else:\n            return False\n    return sum(count.values()) == 0"], "requirement": [], "outputs": "[[False], [True], [False], [False], [True], [True], [False], [False], [True], [True], [False], [False], [False], [False], [False], [False], [False], [False]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from collections import Counter\nfrom typing import List\n\ndef build_square(blocks: List[int]) -> bool:\n    count = Counter(blocks)\n    valid_rows = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n\n    def can_build_row(count):\n        for row in valid_rows:\n            row_counter = Counter(row)\n            if all((count[block] >= row_counter[block] for block in row_counter)):\n                for block in row_counter:\n                    count[block] -= row_counter[block]\n                return True\n        return False\n    for _ in range(4):\n        if not can_build_row(count):\n            return False\n    total_blocks_used = sum(count.values())\n    if total_blocks_used == 0:\n        return True\n    return all((val == 0 for val in count.values()))", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    if sum(block_counts.values()) < 4:\n        return False\n    unit_count = block_counts[1] + 2 * block_counts[2] + 3 * block_counts[3] + 4 * block_counts[4]\n    if unit_count != 16:\n        return False\n\n    def can_make_row(units_left, block_counts):\n        if units_left == 0:\n            return True\n        original_counts = block_counts.copy()\n        if block_counts[4] > 0:\n            block_counts[4] -= 1\n            if can_make_row(0, block_counts):\n                return True\n            block_counts = original_counts.copy()\n        if block_counts[3] > 0 and block_counts[1] > 0:\n            block_counts[3] -= 1\n            block_counts[1] -= 1\n            if can_make_row(0, block_counts):\n                return True\n            block_counts = original_counts.copy()\n        if block_counts[2] >= 2:\n            block_counts[2] -= 2\n            if can_make_row(0, block_counts):\n                return True\n            block_counts = original_counts.copy()\n        if block_counts[2] > 0 and block_counts[1] >= 2:\n            block_counts[2] -= 1\n            block_counts[1] -= 2\n            if can_make_row(0, block_counts):\n                return True\n            block_counts = original_counts.copy()\n        if block_counts[1] >= 4:\n            block_counts[1] -= 4\n            if can_make_row(0, block_counts):\n                return True\n            block_counts = original_counts.copy()\n        return False\n    for _ in range(4):\n        if not can_make_row(4, block_counts):\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    if sum(block_counts.values()) < 4:\n        return False\n    unit_count = block_counts[1] + 2 * block_counts[2] + 3 * block_counts[3] + 4 * block_counts[4]\n    if unit_count != 16:\n        return False\n    valid_rows = [{4: 1}, {3: 1, 1: 1}, {2: 2}, {2: 1, 1: 2}, {1: 4}]\n\n    def is_row_buildable(blocks_needed, block_counts):\n        \"\"\"\n        Checks if it's possible to build rows using the available blocks.\n        \"\"\"\n        for row in valid_rows:\n            temp_counts = block_counts.copy()\n            can_build = True\n            for block_size, count in row.items():\n                if temp_counts[block_size] >= count:\n                    temp_counts[block_size] -= count\n                else:\n                    can_build = False\n                    break\n            if can_build:\n                blocks_needed -= 4\n                block_counts = temp_counts\n                if blocks_needed == 0:\n                    return True\n                if is_row_buildable(blocks_needed, block_counts):\n                    return True\n        return False\n    return is_row_buildable(16, block_counts)"], "requirement": [], "outputs": "[[True], [False], [False], [False], [False], [False], [False], [False], [True], [False], [False], [False], [False], [False], [False], [True], [False], [True]]", "probability": 0.06, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n\n    def can_build_row(row):\n        temp_counts = block_counts.copy()\n        for block in row:\n            if temp_counts[block] <= 0:\n                return False\n            temp_counts[block] -= 1\n        return True\n\n    def backtrack(rows_built):\n        if rows_built == 4:\n            return True\n        for row in valid_rows:\n            if can_build_row(row):\n                new_block_counts = block_counts.copy()\n                for block in row:\n                    new_block_counts[block] -= 1\n                if backtrack(rows_built + 1):\n                    return True\n                block_counts.update(new_block_counts)\n        return False\n    return backtrack(0)", "from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    required_rows = 4\n    row_width = 4\n    possible_row_combinations = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n\n    def can_build_row(remaining_blocks: Counter) -> bool:\n        for combination in possible_row_combinations:\n            temp_counter = remaining_blocks.copy()\n            valid_combination = True\n            for block_size in combination:\n                if temp_counter[block_size] > 0:\n                    temp_counter[block_size] -= 1\n                else:\n                    valid_combination = False\n                    break\n            if valid_combination:\n                return True\n        return False\n    for _ in range(required_rows):\n        if not can_build_row(block_counts):\n            return False\n    return True"], "requirement": [], "outputs": "[[True], [True], [True], [True], [True], [True], [True], [True], [True], [False], [False], [True], [True], [True], [True], [True], [False], [True]]", "probability": 0.04, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    \"\"\"\n    Determines if a 4x4 square can be built using the given blocks.\n    \n    :param blocks: List of integers representing blocks (1, 2, 3, or 4)\n    :return: True if a 4x4 square can be built, otherwise False\n    \"\"\"\n    block_counts = Counter(blocks)\n    num_1_blocks = block_counts[1]\n    num_2_blocks = block_counts[2]\n    num_3_blocks = block_counts[3]\n    num_4_blocks = block_counts[4]\n    rows_filled_by_4 = min(4, num_4_blocks)\n    if rows_filled_by_4 == 4:\n        return True\n    remaining_rows = 4 - rows_filled_by_4\n    num_4_blocks -= rows_filled_by_4\n    max_possible_3_and_1_rows = min(num_3_blocks, num_1_blocks, remaining_rows)\n    remaining_rows -= max_possible_3_and_1_rows\n    num_3_blocks -= max_possible_3_and_1_rows\n    num_1_blocks -= max_possible_3_and_1_rows\n    if remaining_rows == 0:\n        return True\n    max_possible_2_block_rows = min(num_2_blocks // 2 + num_2_blocks % 2, remaining_rows)\n    remaining_rows -= max_possible_2_block_rows\n    num_2_blocks -= max_possible_2_block_rows * 2 if max_possible_2_block_rows * 2 <= num_2_blocks else num_2_blocks\n    if remaining_rows == 0:\n        return True\n    while remaining_rows > 0:\n        for combination in [(2, 1, 1), (1, 1, 1, 1)]:\n            needed_count = sum([block_counts[block_size] for block_size in combination])\n            if needed_count >= len(combination) and remaining_rows > 0:\n                for block_size in combination:\n                    if block_counts[block_size] > 0:\n                        block_counts[block_size] -= 1\n                        needed_count -= 1\n                if needed_count == 0:\n                    remaining_rows -= 1\n                    break\n        else:\n            return False\n    return remaining_rows == 0"], "requirement": [], "outputs": "[[True], [False], [False], [False], [False], [False], [False], [True], [False], [False], [False], [False], [False], [True], [True], [True], [False], [True]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    \"\"\"\n    Determines if it's possible to build a 4x4 square using the given blocks.\n    \n    Args:\n    blocks (List[int]): A list of integers representing block sizes (1 <= x <= 4).\n    \n    Returns:\n    bool: True if it's possible to build a 4x4 square, False otherwise.\n    \"\"\"\n    block_counts = Counter(blocks)\n    total_units = sum((block_counts[i] * i for i in range(1, 5)))\n    if total_units != 16:\n        return False\n    valid_rows = [[4], [3, 1], [1, 3], [2, 2], [2, 1, 1], [1, 2, 1], [1, 1, 2], [1, 1, 1, 1]]\n    for row组合 in valid_rows:\n        if check_row_combinations(block_counts, row组合):\n            return True\n    return False\n\ndef check_row_combinations(block_counts: Counter, row_combination: List[int]) -> bool:\n    \"\"\"\n    Checks if a combination of rows can be formed from the available blocks.\n    \n    Args:\n    block_counts (Counter): A counter object with block sizes as keys and counts as values.\n    row_combination (List[int]): A list representing the current row configuration.\n    \n    Returns:\n    bool: True if the combination is valid, False otherwise.\n    \"\"\"\n    temp_counts = block_counts.copy()\n    for block_size in row_combination:\n        if temp_counts[block_size] > 0:\n            temp_counts[block_size] -= 1\n        else:\n            return False\n    if sum((temp_counts[i] * i for i in range(1, 5))) == 0:\n        return True\n    for next_row in valid_rows:\n        if check_row_combinations(temp_counts, next_row):\n            return True\n    return False"], "requirement": [], "outputs": "[['NameError'], [False], [False], [False], [False], [False], [False], [False], ['NameError'], [False], [False], [False], [False], [False], [False], ['NameError'], [False], ['NameError']]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\nfrom collections import Counter\n\ndef build_square(blocks: List[int]) -> bool:\n    block_counts = Counter(blocks)\n    count_1 = block_counts[1]\n    count_2 = block_counts[2]\n    count_3 = block_counts[3]\n    count_4 = block_counts[4]\n\n    def can_build_square():\n        row_types = {'4': {'4': 1}, '3+1': {'3': 1, '1': 1}, '1+3': {'1': 1, '3': 1}, '2+2': {'2': 2}, '2+1+1': {'2': 1, '1': 2}, '1+2+1': {'1': 2, '2': 1}, '1+1+1+1': {'1': 4}}\n        possible_rows = [['4'] * 4, ['3+1', '3+1', '3+1', '3+1'], ['3+1', '3+1', '2+2', '2+2'], ['3+1', '2+2', '2+1+1', '1+2+1'], ['2+2', '2+2', '2+2', '2+2'], ['2+1+1', '2+1+1', '2+1+1', '1+2+1'], ['1+2+1', '1+2+1', '1+2+1', '1+2+1'], ['1+1+1+1'] * 4, ['2+2', '2+2', '1+2+1', '1+2+1'], ['3+1', '3+1', '1+1+1+1', '1+1+1+1'], ['2+2', '2+1+1', '2+1+1', '1+1+1+1']]\n        for rows in possible_rows:\n            temp_count_1 = count_1\n            temp_count_2 = count_2\n            temp_count_3 = count_3\n            temp_count_4 = count_4\n            valid = True\n            for row in rows:\n                row_blocks = row_types[row]\n                for block_size, required_count in row_blocks.items():\n                    if block_size == '1':\n                        temp_count_1 -= required_count\n                    elif block_size == '2':\n                        temp_count_2 -= required_count\n                    elif block_size == '3':\n                        temp_count_3 -= required_count\n                    elif block_size == '4':\n                        temp_count_4 -= required_count\n                    if temp_count_1 < 0 or temp_count_2 < 0 or temp_count_3 < 0 or (temp_count_4 < 0):\n                        valid = False\n                        break\n                if not valid:\n                    break\n            if valid:\n                return True\n        return False\n    return can_build_square()"], "requirement": [], "outputs": "[[True], [False], [False], [False], [False], [False], [False], [False], [True], [False], [False], [False], [False], [True], [True], [True], [False], [True]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 0.7732512861881293, "llm_generated_inputs": "[[[4, 4, 4, 4]], [[1, 1, 1, 1, 2, 2]], [[3, 1, 1, 3, 1, 1]], [[2, 2, 2, 2]], [[1, 1, 2, 1, 1, 2]], [[1, 1, 1, 1, 1, 1, 1, 1]], [[1, 2, 3, 4]], [[4, 4, 3, 1, 2, 2, 1, 3]], [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], [[]], [[1]], [[4, 4, 4]], [[3, 3, 2, 2, 1, 1]], [[4, 4, 4, 4, 4, 4, 4, 4]], [[1, 2, 3, 4, 4, 4, 4, 1, 2, 3]], [[2, 2, 2, 2, 2, 2, 2, 2]], [[3, 3, 3, 3]], [[1, 1, 1, 1, 3, 3, 3, 3]]]", "input_output_examples": "[[[1, 3, 2, 2, 4, 1, 1, 3, 1, 4, 2], [1, 3, 2, 4, 3, 3, 2]], [[True], [False]]]", "at_least_one_align": false}, "entry_point": "build_square", "ground_truth": -1}
{"task_id": "TACO_lite/47", "requirement": "def sea_sick(sea: str) -> str:\n\"\"\"Thanks to the effects of El Nino this year my holiday snorkelling trip was akin to being in a washing machine... Not fun at all.\n\nGiven a string made up of '~' and '\\_' representing waves and calm respectively, your job is to check whether a person would become seasick.\n\nRemember, only the process of change from wave to calm (and vice versa) will add to the effect (really wave peak to trough but this will do). Find out how many changes in level the string has and if that figure is more than 20% of the string, return \"Throw Up\", if less, return \"No Problem\".\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((x != y for x, y in zip(sea, sea[1:])))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    from math import ceil\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    return 'Throw Up' if changes > threshold else 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    return 'Throw Up' if changes > threshold else 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    percentage_changes = changes / len(sea) * 100 if sea else 0\n    return 'Throw Up' if percentage_changes > 20 else 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((x != y for x, y in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((x != y for x, y in zip(sea, sea[1:])))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    from math import ceil\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    from math import ceil\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    length = len(sea)\n    changes = 0\n    for i in range(1, length):\n        if sea[i] != sea[i - 1]:\n            changes += 1\n    threshold = math.ceil(length * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = 0.2 * len(sea)\n    return 'Throw Up' if changes > threshold else 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    twenty_percent = len(sea) * 0.2\n    if changes > twenty_percent:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((x != y for x, y in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    total_length = len(sea)\n    changes = 0\n    for i in range(1, total_length):\n        if sea[i] != sea[i - 1]:\n            changes += 1\n    threshold = total_length * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    total_length = len(sea)\n    prev_char = None\n    change_count = 0\n    for char in sea:\n        if char != prev_char:\n            change_count += 1\n            prev_char = char\n    if change_count > 0:\n        change_count -= 1\n    change_percentage = change_count / total_length * 100\n    if change_percentage > 20:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = 0\n    total_length = len(sea)\n    for i in range(1, total_length):\n        if sea[i] != sea[i - 1]:\n            changes += 1\n    change_percentage = changes / total_length * 100\n    if change_percentage > 20:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    length = len(sea)\n    changes = 0\n    for i in range(1, length):\n        if sea[i] != sea[i - 1]:\n            changes += 1\n    threshold = math.ceil(length * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    total_length = len(sea)\n    changes = 0\n    for i in range(1, total_length):\n        if sea[i] != sea[i - 1]:\n            changes += 1\n    threshold = math.ceil(total_length * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = math.ceil(len(sea) * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    changes = 0\n    prev_char = None\n    total_length = len(sea)\n    for char in sea:\n        if char != prev_char:\n            changes += 1\n            prev_char = char\n    if total_length > 0:\n        changes -= 1\n    threshold = math.ceil(0.2 * total_length)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    changes = sum((1 for i in range(1, len(sea)) if sea[i] != sea[i - 1]))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    total_length = len(sea)\n    prev_char = None\n    changes = 0\n    for char in sea:\n        if char != prev_char:\n            changes += 1\n            prev_char = char\n    threshold = math.ceil(0.2 * total_length)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    from math import ceil\n    changes = sum((a != b for a, b in zip(sea, sea[1:])))\n    threshold = len(sea) * 0.2\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    from math import ceil\n    length = len(sea)\n    if length == 0:\n        return 'No Problem'\n    changes = sum((1 for i in range(1, length) if sea[i] != sea[i - 1]))\n    threshold = ceil(length * 0.2)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'", "def sea_sick(sea: str) -> str:\n    import math\n    total_length = len(sea)\n    if total_length == 0:\n        return 'No Problem'\n    changes = 0\n    prev_char = sea[0]\n    for char in sea:\n        if char != prev_char:\n            changes += 1\n            prev_char = char\n    threshold = math.ceil(0.2 * total_length)\n    if changes > threshold:\n        return 'Throw Up'\n    else:\n        return 'No Problem'"], "requirement": [], "outputs": "[['Throw Up'], ['Throw Up'], ['No Problem'], ['No Problem'], ['Throw Up'], ['No Problem'], ['No Problem'], ['Throw Up'], ['Throw Up'], ['Throw Up'], ['Throw Up'], ['Throw Up'], ['No Problem'], ['No Problem'], ['No Problem'], ['Throw Up'], ['Throw Up']]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[['~ ~~ ~~~ ~ ~ ~~~~'], ['~~___~~__~~_~~_'], ['~~~~~~'], ['______'], ['~_~_~_~_~_~_~_~_~_~_~_'], ['~'], ['_'], ['~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~'], ['~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_'], ['~_~_~_~_~_~_~_~_~_~_~'], ['~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~'], ['~_~_~_~_~_~_~_~_~~~___'], ['~~~_______'], ['~~~~~~~_____'], ['~~~_______~~~~~'], ['~_~_~_~_~_~_~_~_~_~'], ['~_~_~_~_~_~_~_~_~_~_~_~_~_~_~_~']]", "input_output_examples": "[[], []]", "at_least_one_align": false}, "entry_point": "sea_sick", "ground_truth": 0}
{"task_id": "TACO_lite/48", "requirement": "def same_encryption(s1: str, s2: str) -> bool:\n\"\"\"# Task\n John loves encryption. He can encrypt any string by the following algorithm:\n```\ntake the first and the last letters of the word;\nreplace the letters between them with their number;\nreplace this number with the sum of it digits \n          until a single digit is obtained.```\nGiven two strings(`s1` and `s2`), return `true` if their encryption is the same, or `false` otherwise.\n\n# Input/Output\n\n\n - `[input]` string `s1`\n\n  The first string to be encrypted.\n  \n  `s1.length >= 3`\n \n \n - `[input]` string `s2`\n\n  The second string to be encrypted.\n\n  `s2.length >= 3`\n  \n  \n - `[output]` a boolean value\n\n `true` if encryption is the same, `false` otherwise.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first = s[0]\n        last = s[-1]\n        num_chars = len(s) - 2\n        sum_digits = num_chars\n        while sum_digits > 9:\n            sum_digits = sum((int(digit) for digit in str(sum_digits)))\n        return f'{first}{sum_digits}{last}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first = s[0]\n        last = s[-1]\n        mid_len = len(s) - 2\n\n        def sum_digits(num):\n            return sum((int(digit) for digit in str(num)))\n        while mid_len >= 10:\n            mid_len = sum_digits(mid_len)\n        return f'{first}{mid_len}{last}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_letter = s[0]\n        last_letter = s[-1]\n        middle_length = len(s) - 2\n\n        def sum_digits(n: int) -> int:\n            while n > 9:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        middle_sum = sum_digits(middle_length)\n        return f'{first_letter}{middle_sum}{last_letter}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n\n        def sum_digits(n: int) -> int:\n            return sum((int(digit) for digit in str(n)))\n\n        def reduce_to_single_digit(n: int) -> int:\n            while n >= 10:\n                n = sum_digits(n)\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        middle_length = len(s) - 2\n        reduced_digit = reduce_to_single_digit(middle_length)\n        return f'{first_char}{reduced_digit}{last_char}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_length = len(s) - 2\n        sum_digits = sum((int(digit) for digit in str(middle_length)))\n        while sum_digits >= 10:\n            sum_digits = sum((int(digit) for digit in str(sum_digits)))\n        return f'{first_char}{sum_digits}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first = s[0]\n        last = s[-1]\n        middle_length = len(s) - 2\n\n        def sum_of_digits(n: int) -> int:\n            while n > 9:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        middle_sum = sum_of_digits(middle_length)\n        return f'{first}{middle_sum}{last}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_chars_count = len(s) - 2\n        while middle_chars_count >= 10:\n            middle_chars_count = sum((int(digit) for digit in str(middle_chars_count)))\n        return f'{first_char}{middle_chars_count}{last_char}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n\n        def sum_of_digits(n: int) -> int:\n            while n >= 10:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        middle_length = len(s) - 2\n        reduced_number = sum_of_digits(middle_length)\n        return f'{first_char}{reduced_number}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def reduce_to_single_digit(n):\n    while n >= 10:\n        n = sum((int(digit) for digit in str(n)))\n    return n\n\ndef encrypt_string(s: str) -> str:\n    first_char = s[0]\n    last_char = s[-1]\n    middle_length = len(s) - 2\n    reduced_middle_length = reduce_to_single_digit(middle_length)\n    return f'{first_char}{reduced_middle_length}{last_char}'\n\ndef same_encryption(s1: str, s2: str) -> bool:\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_length = len(s) - 2\n        digit_sum = sum_digits(middle_length)\n        return f'{first_char}{digit_sum}{last_char}'\n\n    def sum_digits(n: int) -> str:\n        while n >= 10:\n            n = sum((int(digit) for digit in str(n)))\n        return str(n)\n    return encrypt(s1) == encrypt(s2)", "def reduce_to_single_digit(num):\n    while num > 9:\n        num = sum((int(digit) for digit in str(num)))\n    return num\n\ndef encrypt_string(s: str) -> str:\n    first_letter = s[0]\n    last_letter = s[-1]\n    middle_length = len(s) - 2\n    reduced_digit = reduce_to_single_digit(middle_length)\n    return f'{first_letter}{reduced_digit}{last_letter}'\n\ndef same_encryption(s1: str, s2: str) -> bool:\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_length = len(s) - 2\n\n        def sum_of_digits(n: int) -> int:\n            if n < 10:\n                return n\n            else:\n                return sum_of_digits(sum((int(digit) for digit in str(n))))\n        middle_sum = sum_of_digits(middle_length)\n        return f'{first_char}{middle_sum}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def get_encryption(s: str) -> str:\n\n    def sum_digits(n: int) -> int:\n        return sum((int(digit) for digit in str(n)))\n\n    def reduce_to_single_digit(n: int) -> int:\n        while n >= 10:\n            n = sum_digits(n)\n        return n\n    first_char = s[0]\n    last_char = s[-1]\n    num_chars_between = len(s) - 2\n    reduced_digit = reduce_to_single_digit(num_chars_between)\n    return f'{first_char}{reduced_digit}{last_char}'\n\ndef same_encryption(s1: str, s2: str) -> bool:\n    return get_encryption(s1) == get_encryption(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n\n        def sum_of_digits(n: int) -> int:\n            return sum((int(digit) for digit in str(n)))\n\n        def reduce_to_single_digit(n: int) -> int:\n            while n >= 10:\n                n = sum_of_digits(n)\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        middle_length = len(s) - 2\n        reduced_digit = reduce_to_single_digit(middle_length)\n        return f'{first_char}{reduced_digit}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def digit_sum(n: int) -> int:\n    \"\"\"Helper function to sum digits until a single digit is obtained.\"\"\"\n    while n > 9:\n        n = sum((int(digit) for digit in str(n)))\n    return n\n\ndef encrypt(s: str) -> str:\n    \"\"\"Encrypt the string using John's algorithm.\"\"\"\n    first_char = s[0]\n    last_char = s[-1]\n    count = len(s) - 2\n    digit = digit_sum(count)\n    return f'{first_char}{digit}{last_char}'\n\ndef same_encryption(s1: str, s2: str) -> bool:\n    \"\"\"Check if the encryption of two strings is the same.\"\"\"\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first = s[0]\n        last = s[-1]\n        num_chars = len(s) - 2\n        while num_chars > 9:\n            num_chars = sum((int(digit) for digit in str(num_chars)))\n        return f'{first}{num_chars}{last}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(word: str) -> str:\n        first_letter = word[0]\n        last_letter = word[-1]\n        middle_chars_count = len(word) - 2\n\n        def sum_digits(n):\n            while n >= 10:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        middle_digit_sum = sum_digits(middle_chars_count)\n        return f'{first_letter}{middle_digit_sum}{last_letter}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n\n        def sum_digits(n: int) -> int:\n            while n >= 10:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        middle_length = len(s) - 2\n        reduced_number = sum_digits(middle_length)\n        return f'{first_char}{reduced_number}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_letter = s[0]\n        last_letter = s[-1]\n        between_length = len(s) - 2\n\n        def sum_digits(n: int) -> int:\n            while n > 9:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        single_digit = sum_digits(between_length)\n        encrypted = f'{first_letter}{single_digit}{last_letter}'\n        return encrypted\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n\n        def digit_sum(n: int) -> int:\n            return sum((int(digit) for digit in str(n)))\n\n        def reduce_to_single_digit(n: int) -> int:\n            while n >= 10:\n                n = digit_sum(n)\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        middle_length = len(s) - 2\n        reduced_digit = reduce_to_single_digit(middle_length)\n        return f'{first_char}{reduced_digit}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first = s[0]\n        last = s[-1]\n        middle_length = len(s) - 2\n\n        def sum_of_digits(n: int) -> int:\n            if n < 10:\n                return n\n            else:\n                return sum_of_digits(sum((int(digit) for digit in str(n))))\n        reduced_middle = sum_of_digits(middle_length)\n        return f'{first}{reduced_middle}{last}'\n    return encrypt(s1) == encrypt(s2)", "def reduce_to_single_digit(n):\n    \"\"\"Reduce a number to a single digit by summing its digits repeatedly.\"\"\"\n    while n >= 10:\n        n = sum((int(digit) for digit in str(n)))\n    return n\n\ndef encrypt_string(s: str) -> str:\n    \"\"\"Encrypt the string according to John's algorithm.\"\"\"\n    first_char = s[0]\n    last_char = s[-1]\n    middle_length = len(s) - 2\n    reduced_digit = reduce_to_single_digit(middle_length)\n    return f'{first_char}{reduced_digit}{last_char}'\n\ndef same_encryption(s1: str, s2: str) -> bool:\n    \"\"\"Check if two strings have the same encryption.\"\"\"\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n\n        def sum_digits(n: int) -> int:\n            while n > 9:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        middle_chars_count = len(s) - 2\n        middle_digits_sum = sum_digits(middle_chars_count)\n        return f'{first_char}{middle_digits_sum}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_len = len(s) - 2\n\n        def sum_digits(n: int) -> int:\n            while n > 9:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        middle_len_digit = sum_digits(middle_len)\n        return f'{first_char}{middle_len_digit}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n\n        def sum_of_digits(n: int) -> int:\n            return sum((int(digit) for digit in str(n)))\n\n        def reduce_to_single_digit(n: int) -> int:\n            while n >= 10:\n                n = sum_of_digits(n)\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        middle_length = len(s) - 2\n        reduced_digit = reduce_to_single_digit(middle_length)\n        return f'{first_char}{reduced_digit}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def reduce_to_single_digit(n: int) -> int:\n    \"\"\"Reduces a number to a single digit by summing its digits repeatedly.\"\"\"\n    while n > 9:\n        n = sum((int(digit) for digit in str(n)))\n    return n\n\ndef encrypt_string(s: str) -> str:\n    \"\"\"Encrypts the string according to the specified algorithm.\"\"\"\n    first_char = s[0]\n    last_char = s[-1]\n    middle_length = len(s) - 2\n    reduced_middle = reduce_to_single_digit(middle_length)\n    encrypted = f'{first_char}{reduced_middle}{last_char}'\n    return encrypted\n\ndef same_encryption(s1: str, s2: str) -> bool:\n    \"\"\"Returns true if the encryption of s1 and s2 is the same, false otherwise.\"\"\"\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_chars_count = len(s) - 2\n\n        def sum_of_digits(n: int) -> int:\n            \"\"\"Calculate the sum of digits until a single digit is obtained.\"\"\"\n            while n >= 10:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        return f'{first_char}{sum_of_digits(middle_chars_count)}{last_char}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_chars_count = len(s) - 2\n\n        def reduce_to_single_digit(num):\n            while num > 9:\n                num = sum((int(digit) for digit in str(num)))\n            return num\n        digit_result = reduce_to_single_digit(middle_chars_count)\n        encrypted_string = f'{first_char}{digit_result}{last_char}'\n        return encrypted_string\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n\n        def sum_of_digits(n: int) -> int:\n            while n >= 10:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        num_chars_between = len(s) - 2\n        reduced_num = sum_of_digits(num_chars_between)\n        return f'{first_char}{reduced_num}{last_char}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_length = len(s) - 2\n\n        def reduce_to_single_digit(n: int) -> int:\n            while n >= 10:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        middle_reduction = reduce_to_single_digit(middle_length)\n        return f'{first_char}{middle_reduction}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first = s[0]\n        last = s[-1]\n        middle_length = len(s) - 2\n        digit_sum = sum((int(digit) for digit in str(middle_length)))\n        while digit_sum > 9:\n            digit_sum = sum((int(digit) for digit in str(digit_sum)))\n        return f'{first}{digit_sum}{last}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def encrypt_string(s: str) -> str:\n\n    def sum_digits(n: int) -> int:\n        return sum((int(digit) for digit in str(n)))\n\n    def reduce_to_single_digit(n: int) -> int:\n        while n >= 10:\n            n = sum_digits(n)\n        return n\n    first_char = s[0]\n    last_char = s[-1]\n    middle_length = len(s) - 2\n    reduced_digit = reduce_to_single_digit(middle_length)\n    return f'{first_char}{reduced_digit}{last_char}'\n\ndef same_encryption(s1: str, s2: str) -> bool:\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(word: str) -> str:\n        first_letter = word[0]\n        last_letter = word[-1]\n        middle_length = len(word) - 2\n        reduced_number = reduce_to_single_digit(middle_length)\n        return f'{first_letter}{reduced_number}{last_letter}'\n\n    def reduce_to_single_digit(n: int) -> int:\n        while n >= 10:\n            n = sum((int(digit) for digit in str(n)))\n        return n\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_part = s[1:-1]\n        num_digits = len(middle_part)\n\n        def sum_of_digits(n: int) -> int:\n            while n > 9:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        reduced_num = sum_of_digits(num_digits)\n        return f'{first_char}{reduced_num}{last_char}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s):\n        first = s[0]\n        last = s[-1]\n        mid_length = len(s) - 2\n        while mid_length > 9:\n            mid_length = sum((int(digit) for digit in str(mid_length)))\n        return f'{first}{mid_length}{last}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first = s[0]\n        last = s[-1]\n        middle_length = len(s) - 2\n        middle_sum = sum((int(digit) for digit in str(middle_length)))\n        while middle_sum > 9:\n            middle_sum = sum((int(digit) for digit in str(middle_sum)))\n        encrypted = f'{first}{middle_sum}{last}'\n        return encrypted\n    return encrypt(s1) == encrypt(s2)", "from math import log10\n\ndef reduce_to_single_digit(n):\n    \"\"\"Helper function to reduce a number to a single digit.\"\"\"\n    while n >= 10:\n        n = sum((int(digit) for digit in str(n)))\n    return n\n\ndef encrypt_string(s: str) -> str:\n    \"\"\"Encrypt the string according to John's algorithm.\"\"\"\n    first_char = s[0]\n    last_char = s[-1]\n    num_chars_between = len(s) - 2\n    reduced_num = reduce_to_single_digit(num_chars_between)\n    return f'{first_char}{reduced_num}{last_char}'\n\ndef same_encryption(s1: str, s2: str) -> bool:\n    \"\"\"Check if two strings have the same encryption.\"\"\"\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        num_chars_between = str(len(s) - 2)\n        while len(num_chars_between) > 1:\n            num_chars_between = str(sum((int(digit) for digit in num_chars_between)))\n        return first_char + num_chars_between + last_char\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_chars_count = len(s) - 2\n\n        def sum_digits(n):\n            while n > 9:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        middle_sum = sum_digits(middle_chars_count)\n        return f'{first_char}{middle_sum}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s):\n        first = s[0]\n        last = s[-1]\n        middle_length = len(s) - 2\n        digit_sum = sum_digits(middle_length)\n        return f'{first}{digit_sum}{last}'\n\n    def sum_digits(n):\n        while n >= 10:\n            n = sum((int(digit) for digit in str(n)))\n        return n\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n\n        def sum_of_digits(n: int) -> int:\n            return sum((int(digit) for digit in str(n)))\n\n        def reduce_to_single_digit(n: int) -> int:\n            while n >= 10:\n                n = sum_of_digits(n)\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        middle_part_length = len(s) - 2\n        reduced_number = reduce_to_single_digit(middle_part_length)\n        return f'{first_char}{reduced_number}{last_char}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_letter = s[0]\n        last_letter = s[-1]\n        num_chars_between = len(s) - 2\n        while num_chars_between >= 10:\n            num_chars_between = sum((int(digit) for digit in str(num_chars_between)))\n        encrypted = f'{first_letter}{num_chars_between}{last_letter}'\n        return encrypted\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first = s[0]\n        last = s[-1]\n        num_chars = len(s) - 2\n\n        def sum_digits(n: int) -> int:\n            while n >= 10:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        middle_digit = sum_digits(num_chars)\n        return f'{first}{middle_digit}{last}'\n    return encrypt(s1) == encrypt(s2)", "def sum_of_digits(n: int) -> int:\n    \"\"\"Helper function to compute the sum of digits until a single digit is obtained.\"\"\"\n    if n < 10:\n        return n\n    return sum_of_digits(sum((int(digit) for digit in str(n))))\n\ndef encrypt_string(s: str) -> str:\n    \"\"\"Encrypt the string according to the specified algorithm.\"\"\"\n    first_char = s[0]\n    last_char = s[-1]\n    middle_length = len(s) - 2\n    reduced_middle_length = sum_of_digits(middle_length)\n    encrypted_string = f'{first_char}{reduced_middle_length}{last_char}'\n    return encrypted_string\n\ndef same_encryption(s1: str, s2: str) -> bool:\n    \"\"\"Check if two strings have the same encryption.\"\"\"\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first = s[0]\n        last = s[-1]\n        middle_count = len(s) - 2\n\n        def sum_digits(n):\n            return sum((int(digit) for digit in str(n)))\n        while middle_count >= 10:\n            middle_count = sum_digits(middle_count)\n        encrypted = f'{first}{middle_count}{last}'\n        return encrypted\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_chars_count = len(s) - 2\n\n        def reduce_to_single_digit(n: int) -> int:\n            while n >= 10:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        reduced_middle_chars_count = reduce_to_single_digit(middle_chars_count)\n        return f'{first_char}{reduced_middle_chars_count}{last_char}'\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n\n        def reduce_to_single_digit(n: int) -> int:\n            while n >= 10:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        num_chars_between = len(s) - 2\n        reduced_num = reduce_to_single_digit(num_chars_between)\n        encrypted_string = f'{first_char}{reduced_num}{last_char}'\n        return encrypted_string\n    return encrypt(s1) == encrypt(s2)", "from functools import reduce\n\ndef same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        count = len(s) - 2\n\n        def sum_digits(n: int) -> int:\n            while n >= 10:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        digit_sum = sum_digits(count)\n        encrypted_str = f'{first_char}{digit_sum}{last_char}'\n        return encrypted_str\n    return encrypt_string(s1) == encrypt_string(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt(s: str) -> str:\n\n        def sum_digits(n: int) -> int:\n            return sum((int(digit) for digit in str(n)))\n\n        def reduce_to_single_digit(n: int) -> int:\n            while n >= 10:\n                n = sum_digits(n)\n            return n\n        first_char = s[0]\n        last_char = s[-1]\n        num_chars_between = len(s) - 2\n        reduced_num = reduce_to_single_digit(num_chars_between)\n        encrypted_string = f'{first_char}{reduced_num}{last_char}'\n        return encrypted_string\n    return encrypt(s1) == encrypt(s2)", "def same_encryption(s1: str, s2: str) -> bool:\n\n    def encrypt_string(s: str) -> str:\n        first_char = s[0]\n        last_char = s[-1]\n        middle_chars_length = len(s) - 2\n\n        def sum_digits(n: int) -> int:\n            while n > 9:\n                n = sum((int(digit) for digit in str(n)))\n            return n\n        middle_sum = sum_digits(middle_chars_length)\n        return f'{first_char}{middle_sum}{last_char}'\n    return encrypt_string(s1) == encrypt_string(s2)"], "requirement": [], "outputs": "[[True], [True], [True], [True], [False], [True], [True], [True], [True], [False], [True], [True], [True], [False], [True], [False], [False], [True], [False], [False], [False], [True], [False]]", "probability": 1.0, "is_align_req": false, "DRS": null}], "entropy": 0.0, "llm_generated_inputs": "[['hello', 'hemmo'], ['world', 'wormd'], ['abc', 'adc'], ['encrypt', 'enc1ypt'], ['algorithm', 'algo9rithm'], ['function', 'fun2tion'], ['same', 's4me'], ['sample', 'sa4ple'], ['code', 'c3de'], ['python', 'p5hon'], ['java', 'j4va'], ['example', 'ex4mple'], ['data', 'd2ta'], ['structure', 'st7cture'], ['binary', 'b4nary'], ['testing', 'te6ing'], ['length', 'le5th'], ['input', 'in3ut'], ['output', 'ou3ut'], ['error', 'e3or'], ['boundary', 'bo8dry'], ['single', 'si4gle'], ['edgecase', 'ed5case']]", "input_output_examples": "[[['EbnhGfjklmjhgz', 'Eabcz']], [[True]]]", "at_least_one_align": false}, "entry_point": "same_encryption", "ground_truth": 0}
{"task_id": "TACO_lite/49", "requirement": "from typing import List\ndef diff(arr: List[str]) -> str:\n\"\"\"Your task is to find the number couple with the greatest difference from a given array of number-couples. \n\nAll number couples will be given as strings and all numbers in them will be positive integers.  \n\nIn case there are more than one option, you should identify whichever is first.\n\nIf there is no difference, return false.\n\"\"\"", "clusters": {"cluster_list": [{"programs_str": ["from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        difference = abs(num1 - num2)\n        if difference > max_diff:\n            max_diff = difference\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        difference = abs(num1 - num2)\n        if difference > max_diff:\n            max_diff = difference\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    max_diff_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_diff_couple = couple\n    if max_diff == 0:\n        return False\n    return max_diff_couple"], "requirement": [], "outputs": "[['3-5'], ['10-20'], [False], ['1-100'], ['100-1'], ['3-4'], ['100-200'], ['3-8'], [''], [False]]", "probability": 0.14, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = None\n    result = None\n    for pair in arr:\n        num1, num2 = map(int, pair.split('-'))\n        difference = abs(num1 - num2)\n        if max_diff is None or difference > max_diff:\n            max_diff = difference\n            result = pair\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    result_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        difference = abs(num1 - num2)\n        if difference > max_diff:\n            max_diff = difference\n            result_couple = couple\n    return result_couple if max_diff > 0 else False", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    result_couple = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    else:\n        return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    result = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    result_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    result_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    max_diff_couple = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff == 0:\n            continue\n        if current_diff > max_diff or max_diff_couple is None:\n            max_diff = current_diff\n            max_diff_couple = couple\n    return max_diff_couple if max_diff_couple is not None else False", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    result_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff_couple = None\n    max_diff = -1\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if max_diff_couple is None or current_diff > max_diff:\n            max_diff = current_diff\n            max_diff_couple = couple\n    if max_diff == 0:\n        return False\n    return max_diff_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n\n    def calculate_difference(couple_str: str) -> int:\n        num1, num2 = map(int, couple_str.split('-'))\n        return abs(num1 - num2)\n    max_diff = -1\n    max_diff_couple = None\n    for couple in arr:\n        current_diff = calculate_difference(couple)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_diff_couple = couple\n        elif current_diff == 0:\n            continue\n    return max_diff_couple if max_diff > 0 else False", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = None\n    max_diff_couple = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if max_diff is None or current_diff > max_diff:\n            max_diff = current_diff\n            max_diff_couple = couple\n        if max_diff == 0:\n            continue\n    if max_diff is None or max_diff == 0:\n        return False\n    return max_diff_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    max_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_couple = couple\n    if max_diff == 0:\n        return False\n    return max_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n\n    def calculate_difference(couple_str: str) -> int:\n        num1, num2 = map(int, couple_str.split('-'))\n        return abs(num1 - num2)\n    if len(arr) < 2:\n        return False\n    differences = [(calculate_difference(item), item) for item in arr]\n    differences.sort(key=lambda x: x[0], reverse=True)\n    if differences[0][0] == 0:\n        return False\n    return differences[0][1]"], "requirement": [], "outputs": "[['3-5'], ['10-20'], [False], ['1-100'], ['100-1'], ['3-4'], ['100-200'], ['3-8'], [False], [False]]", "probability": 0.26, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = None\n    result = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split(','))\n        difference = abs(num1 - num2)\n        if max_diff is None or difference > max_diff:\n            max_diff = difference\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split(','))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result_couple = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split(','))\n        current_diff = abs(num1 - num2)\n        if result_couple is None or current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = None\n    result = None\n    for couple in arr:\n        nums = list(map(int, couple.split(',')))\n        current_diff = abs(nums[0] - nums[1])\n        if max_diff is None or current_diff > max_diff:\n            max_diff = current_diff\n            result = couple\n    if max_diff == 0:\n        return False\n    return result"], "requirement": [], "outputs": "[['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], [None], ['ValueError']]", "probability": 0.08, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split(','))\n        difference = abs(num1 - num2)\n        if difference > max_diff:\n            max_diff = difference\n            result = couple\n    if max_diff == 0:\n        return False\n    else:\n        return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result = ''\n    for couple in arr:\n        nums = list(map(int, couple.split(',')))\n        if len(nums) != 2:\n            continue\n        difference = abs(nums[0] - nums[1])\n        if difference > max_diff:\n            max_diff = difference\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split(','))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split(','))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split(','))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    max_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split())\n        current_diff = abs(num1 - num2)\n        if max_diff == -1 or current_diff > max_diff:\n            max_diff = current_diff\n            max_couple = couple\n    if max_diff == 0:\n        return False\n    return max_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split(','))\n        current_diff = abs(num1 - num2)\n        if max_diff == -1 or current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    \"\"\"Finds the number couple with the greatest difference from a given array of number-couples.\n    \n    Args:\n        arr (List[str]): A list of strings, where each string represents a couple of positive integers.\n        \n    Returns:\n        str: The number couple with the greatest difference or False if there is no difference.\n    \"\"\"\n    max_diff = -1\n    result = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split())\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            result = couple\n    if max_diff == 0:\n        return False\n    return result"], "requirement": [], "outputs": "[['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], [''], ['ValueError']]", "probability": 0.16, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = None\n    result_couple = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if max_diff is None or current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = None\n    result_couple = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if max_diff is None or current_diff > max_diff:\n            max_diff = current_diff\n            result_couple = couple\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    max_couple = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if max_couple is None or current_diff > max_diff:\n            max_diff = current_diff\n            max_couple = couple\n    if max_diff == 0:\n        return False\n    return max_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    max_couple = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_couple = couple\n    if max_diff == 0:\n        return False\n    return max_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff_couple = None\n    max_diff = -1\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if max_diff == -1 or current_diff > max_diff:\n            max_diff = current_diff\n            max_diff_couple = couple\n    if max_diff == 0:\n        return False\n    return max_diff_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    result = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        difference = abs(num1 - num2)\n        if difference > max_diff:\n            max_diff = difference\n            result = couple\n    if max_diff == 0:\n        return False\n    return result", "from typing import List, Tuple\n\ndef diff(arr: List[str]) -> str:\n\n    def parse_couple(couple_str: str) -> Tuple[int, int]:\n        num1, num2 = map(int, couple_str.split('-'))\n        return (num1, num2)\n    max_diff = -1\n    max_couple = None\n    for couple_str in arr:\n        num1, num2 = parse_couple(couple_str)\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_couple = couple_str\n    if max_diff == 0:\n        return False\n    return max_couple", "from typing import List, Tuple\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    max_couple = None\n    for couple in arr:\n        num1, num2 = map(int, couple.split('-'))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_couple = couple\n    if max_diff == 0:\n        return False\n    return max_couple", "from typing import List, Tuple\nimport re\n\ndef diff(arr: List[str]) -> str:\n    \"\"\"\n    Find the number couple with the greatest difference from a given array of number-couples.\n    \n    All number couples will be given as strings and all numbers in them will be positive integers.\n    \n    In case there are more than one option, identify whichever appears first.\n    \n    If there is no difference, return False.\n    \"\"\"\n\n    def calculate_diff(couple: str) -> int:\n        nums = list(map(int, re.findall('\\\\d+', couple)))\n        if len(nums) != 2:\n            raise ValueError('Each couple must contain exactly two positive integers.')\n        return abs(nums[0] - nums[1])\n    max_diff = -1\n    max_couple = None\n    for couple in arr:\n        current_diff = calculate_diff(couple)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_couple = couple\n    if max_diff == 0:\n        return False\n    return max_couple"], "requirement": [], "outputs": "[['3-5'], ['10-20'], [False], ['1-100'], ['100-1'], ['3-4'], ['100-200'], ['3-8'], [None], [False]]", "probability": 0.18, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    max_diff_couple = None\n    for couple_str in arr:\n        numbers = list(map(int, couple_str.split(',')))\n        if len(numbers) != 2:\n            continue\n        current_diff = abs(numbers[0] - numbers[1])\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_diff_couple = couple_str\n    if max_diff == 0:\n        return False\n    return max_diff_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    max_couple = ''\n    for couple in arr:\n        num1, num2 = map(int, couple.split(','))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_couple = couple\n    if max_diff == 0:\n        return False\n    return max_couple", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    max_diff = -1\n    max_index = -1\n    for i, couple in enumerate(arr):\n        num1, num2 = map(int, couple.split(','))\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_index = i\n    if max_index == -1 or max_diff == 0:\n        return False\n    return arr[max_index]", "from typing import List, Tuple\nfrom ast import literal_eval\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    max_diff = -1\n    result_couple = None\n    for couple_str in arr:\n        couple = literal_eval(couple_str)\n        if isinstance(couple, tuple) and len(couple) == 2 and all((isinstance(num, int) and num >= 0 for num in couple)):\n            current_diff = abs(couple[0] - couple[1])\n            if current_diff > max_diff:\n                max_diff = current_diff\n                result_couple = couple_str\n    if max_diff == 0:\n        return False\n    return result_couple", "from typing import List, Tuple\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    couples: List[Tuple[int, int]] = [tuple(map(int, couple.split(','))) for couple in arr]\n    max_diff = -1\n    max_diff_couple = None\n    for couple in couples:\n        diff = abs(couple[0] - couple[1])\n        if diff > max_diff:\n            max_diff = diff\n            max_diff_couple = couple\n    if max_diff == 0:\n        return False\n    return f'{max_diff_couple[0]},{max_diff_couple[1]}'", "from typing import List, Tuple\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n\n    def parse_couple(couple_str: str) -> Tuple[int, int]:\n        num1, num2 = couple_str.split(',')\n        return (int(num1), int(num2))\n    max_diff = -1\n    max_index = -1\n    for index, couple in enumerate(arr):\n        num1, num2 = parse_couple(couple)\n        current_diff = abs(num1 - num2)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_index = index\n    if max_diff == 0:\n        return False\n    return arr[max_index]", "from typing import List\n\ndef diff(arr: List[str]) -> str:\n    \"\"\"\n    Finds the number couple with the greatest difference from a given array of number-couples.\n    \n    Args:\n        arr (List[str]): A list of strings where each string represents a couple of positive integers.\n        \n    Returns:\n        str or bool: The number couple with the greatest difference as a string if there is any difference, otherwise False.\n    \"\"\"\n    if not arr:\n        return False\n    couples_with_diff = []\n    for couple in arr:\n        num1, num2 = map(int, couple.split())\n        difference = abs(num1 - num2)\n        couples_with_diff.append((difference, couple))\n    couples_with_diff.sort(key=lambda x: x[0], reverse=True)\n    max_diff, max_diff_couple = couples_with_diff[0]\n    if max_diff == 0:\n        return False\n    return max_diff_couple"], "requirement": [], "outputs": "[['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], [False], ['ValueError']]", "probability": 0.14, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef diff(arr: List[str]) -> str:\n\n    def parse_and_diff(couple_str: str):\n        num1, num2 = map(int, couple_str.split(','))\n        return (abs(num1 - num2), couple_str)\n    if not arr or len(arr) < 2:\n        return False\n    diffs = [parse_and_diff(c) for c in arr]\n    diffs.sort(key=lambda x: (-x[0], arr.index(x[1])))\n    if diffs[0][0] == 0:\n        return False\n    return diffs[0][1]"], "requirement": [], "outputs": "[['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], ['ValueError'], [False], [False]]", "probability": 0.02, "is_align_req": false, "DRS": null}, {"programs_str": ["from typing import List\n\ndef diff(arr: List[str]) -> str:\n    if not arr:\n        return False\n    parsed_couples = []\n    for couple in arr:\n        nums = couple.split(',')\n        if len(nums) != 2 or not all((num.strip().isdigit() for num in nums)):\n            return False\n        parsed_couples.append((int(nums[0].strip()), int(nums[1].strip())))\n    max_diff = -1\n    max_index = -1\n    for index, (a, b) in enumerate(parsed_couples):\n        current_diff = abs(a - b)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            max_index = index\n    if max_diff == 0:\n        return False\n    return arr[max_index]"], "requirement": [], "outputs": "[[False], [False], [False], [False], [False], [False], [False], [False], [False], [False]]", "probability": 0.02, "is_align_req": false, "DRS": null}], "entropy": 1.8611667112737744, "llm_generated_inputs": "[[['1-2', '3-5', '7-8']], [['10-20', '30-40', '50-60']], [['5-5', '10-10', '15-15']], [['1-100', '2-3', '4-7']], [['100-1', '2-3', '4-7']], [['1-1', '2-2', '3-4']], [['100-200', '201-202', '50-150']], [['3-8', '8-3', '1-1']], [[]], [['10-10']]]", "input_output_examples": "[[[['56-23', '1-100']], [['1-3', '5-7', '2-3']], [['11-11', '344-344']]], [['1-100'], ['1-3'], [False]]]", "at_least_one_align": false}, "entry_point": "diff", "ground_truth": -1}

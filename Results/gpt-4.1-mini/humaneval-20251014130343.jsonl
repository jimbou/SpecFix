{"task_id": "HumanEval/0", "original_requirement": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "repaired_requirement": null, "original_clusters": {"requirement": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "entry_point": "has_close_elements", "cluster_list": [{"programs_str": ["from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(1, len(numbers_sorted)):\n        if numbers_sorted[i] - numbers_sorted[i - 1] < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(1, len(numbers_sorted)):\n        if abs(numbers_sorted[i] - numbers_sorted[i - 1]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers = sorted(numbers)\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i + 1] - numbers[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if numbers_sorted[i + 1] - numbers_sorted[i] < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False"], "outputs": "[[False], [False], [False], [True], [False], [True], [True], [True]]", "probability": 1.0, "is_align_req": 1, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[[[], 1.0], [[1.0], 0.1], [[1.0, 1.0], 0.0], [[1.0, 1.0], 0.1], [[1.0, 2.0, 3.0], 0.5], [[1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3], [[1.0, 1000000.0, 1e-10, 0.9999999], 1e-07], [[-1.0, -1.1, -1.05], 0.1]]", "input_output_examples": "[[[[1.0, 2.0, 3.0], 0.5], [[1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3]], [[False], [True]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true}, "repaired_clusters": null, "result": {"original_passk": 1.0, "original_avg_pass_rate": 1.0, "repaired_pass_rate": null, "original_nzpassk": true, "original_majority_passk": true, "original_entropy": 0, "repaired_passk": null, "repaired_avg_pass_rate": null, "repaired_nzpassk": null, "repaired_majority_passk": null, "repaired_entropy": null}}
{"task_id": "HumanEval/1", "original_requirement": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "repaired_requirement": null, "original_clusters": {"requirement": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "entry_point": "separate_paren_groups", "cluster_list": [{"programs_str": ["from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string:\n        current_group.append(char)\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current = []\n    balance = 0\n    for char in paren_string:\n        current.append(char)\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    balance = 0\n    start = 0\n    for i, ch in enumerate(paren_string):\n        if ch == '(':\n            if balance == 0:\n                start = i\n            balance += 1\n        elif ch == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    current = []\n    for ch in paren_string:\n        current.append(ch)\n        if ch == '(':\n            stack.append(ch)\n        elif ch == ')':\n            if stack:\n                stack.pop()\n            if not stack:\n                result.append(''.join(current))\n                current = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    s = paren_string.replace(' ', '')\n    result = []\n    current = []\n    balance = 0\n    for ch in s:\n        current.append(ch)\n        if ch == '(':\n            balance += 1\n        elif ch == ')':\n            balance -= 1\n        if balance == 0 and current:\n            result.append(''.join(current))\n            current = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string:\n        current_group.append(char)\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current = []\n    balance = 0\n    for ch in paren_string:\n        current.append(ch)\n        if ch == '(':\n            balance += 1\n        elif ch == ')':\n            balance -= 1\n        if balance == 0 and current:\n            result.append(''.join(current))\n            current = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    cleaned = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    current_group = []\n    for ch in cleaned:\n        current_group.append(ch)\n        if ch == '(':\n            stack.append(ch)\n        elif ch == ')':\n            stack.pop()\n            if not stack:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current = []\n    balance = 0\n    for ch in paren_string:\n        if ch == '(':\n            balance += 1\n            current.append(ch)\n        elif ch == ')':\n            balance -= 1\n            current.append(ch)\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    current = []\n    balance = 0\n    for ch in paren_string:\n        current.append(ch)\n        if ch == '(':\n            balance += 1\n        elif ch == ')':\n            balance -= 1\n        if balance == 0 and current:\n            groups.append(''.join(current))\n            current = []\n    return groups", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    s = paren_string.replace(' ', '')\n    result = []\n    current = []\n    balance = 0\n    for char in s:\n        current.append(char)\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string:\n        current_group.append(char)\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    balance = 0\n    current = []\n    for ch in paren_string:\n        current.append(ch)\n        if ch == '(':\n            balance += 1\n        elif ch == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current = []\n    balance = 0\n    for char in paren_string:\n        current.append(char)\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and current:\n            result.append(''.join(current))\n            current = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current_group = []\n    balance = 0\n    for ch in paren_string:\n        current_group.append(ch)\n        if ch == '(':\n            balance += 1\n        elif ch == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            current_group.append(char)\n            balance += 1\n        elif char == ')':\n            current_group.append(char)\n            balance -= 1\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    cleaned = paren_string.replace(' ', '')\n    result = []\n    current = ''\n    balance = 0\n    for ch in cleaned:\n        current += ch\n        if ch == '(':\n            balance += 1\n        elif ch == ')':\n            balance -= 1\n        if balance == 0 and current:\n            result.append(current)\n            current = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    s = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    start_index = 0\n    for i, ch in enumerate(s):\n        if ch == '(':\n            if not stack:\n                start_index = i\n            stack.append(ch)\n        elif ch == ')':\n            stack.pop()\n            if not stack:\n                result.append(s[start_index:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current = []\n    balance = 0\n    for ch in paren_string:\n        if ch == '(':\n            balance += 1\n            current.append(ch)\n        elif ch == ')':\n            balance -= 1\n            current.append(ch)\n        if balance == 0 and current:\n            result.append(''.join(current))\n            current = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    s = paren_string.replace(' ', '')\n    result = []\n    current = []\n    balance = 0\n    for ch in s:\n        current.append(ch)\n        if ch == '(':\n            balance += 1\n        elif ch == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    return result"], "outputs": "[[['()', '(())', '(()())']], [[]], [['()']], [['()', '()', '()']], [['((()))', '(())', '()']], [['()', '(())', '(()())']], [['(()())', '(((())))', '()']], [['()', '(())', '(((())))', '(())']], [['(())', '(())', '(()())']]]", "probability": 1.0, "is_align_req": 1, "test_consistency": 1, "failed_input_output_examples": "[]"}], "entropy": 0, "llm_generated_inputs": "[['( ) (( )) (( )( ))'], [''], ['()'], ['() () ()'], ['((())) (()) ()'], [' ( ) (( )) (( )( )) '], ['(( )())(((())))()'], ['( )(())(((())))(())'], ['(( ) )(( ))(( )( ))']]", "input_output_examples": "[[['( ) (( )) (( )( ))']], [[['()', '(())', '(()())']]]]", "weighted_test_consistency": 1.0, "at_least_one_align": true}, "repaired_clusters": null, "result": {"original_passk": 1.0, "original_avg_pass_rate": 1.0, "repaired_pass_rate": null, "original_nzpassk": true, "original_majority_passk": true, "original_entropy": 0, "repaired_passk": null, "repaired_avg_pass_rate": null, "repaired_nzpassk": null, "repaired_majority_passk": null, "repaired_entropy": null}}

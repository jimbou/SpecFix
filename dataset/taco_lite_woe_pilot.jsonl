{"requirement": "def is_anagram(test: str, original: str) -> bool:\n\"\"\"An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n**Note:** anagrams are case insensitive\n\nComplete the function to return `true` if the two arguments given are anagrams of each other; return `false` otherwise.\n\"\"\"", "inputs": [["foefet", "toffee"], ["Buckethead", "DeathCubeK"], ["Twoo", "WooT"], ["dumble", "bumble"], ["ound", "round"], ["apple", "pale"]], "outputs": [[true], [true], [true], [false], [false], [false]], "starter_code": "def is_anagram(test: str, original: str) -> bool:", "canonical_solution": "def is_anagram(test, original):\n    return sorted(original.lower()) == sorted(test.lower())", "entry_point": "is_anagram", "task_id": "TACO_lite/0", "input_output_examples": "[[['foefet', 'toffee'], ['Buckethead', 'DeathCubeK']], [[True], [True]]]"}
{"requirement": "def make_acronym(phrase: str) -> str:\n\"\"\"Implement a function called makeAcronym that returns the first letters of each word in a passed in string.\n\nMake sure the letters returned are uppercase.\n\nIf the value passed in is not a string return 'Not a string'.\n\nIf the value passed in is a string which contains characters other than spaces and alphabet letters, return 'Not letters'.\n\nIf the string is empty, just return the string itself: \"\".\n\"\"\"", "inputs": [["My aunt sally"], ["Please excuse my dear aunt Sally"], ["How much wood would a woodchuck chuck if a woodchuck could chuck wood"], ["Unique New York"], ["a42"], ["1111"], [64], [[]], [{}], [""]], "outputs": [["MAS"], ["PEMDAS"], ["HMWWAWCIAWCCW"], ["UNY"], ["Not letters"], ["Not letters"], ["Not a string"], ["Not a string"], ["Not a string"], [""]], "starter_code": "def make_acronym(phrase: str) -> str:", "canonical_solution": "def make_acronym(phrase):\n    try:\n        return ''.join((word[0].upper() if word.isalpha() else 0 for word in phrase.split()))\n    except AttributeError:\n        return 'Not a string'\n    except TypeError:\n        return 'Not letters'", "entry_point": "make_acronym", "task_id": "TACO_lite/1", "input_output_examples": "[[['Hello codewarrior'], ['a42'], [42], [[2, 12]], [{'name': 'Abraham'}]], [['HC'], ['Not letters'], ['Not a string'], ['Not a string'], ['Not a string']]]"}
{"requirement": "def solve_for_x(equation: str) -> int:\n\"\"\"# Solve For X\n\nYou will be given an equation as a string and you will need to [solve for X](https://www.mathplacementreview.com/algebra/basic-algebra.php#solve-for-a-variable) and return x's value.\n\nNOTES:\n * All numbers will be whole numbers\n * Don't forget about the [order of operations](https://www.mathplacementreview.com/algebra/basic-algebra.php#order-of-operations).\n * If the random tests don't pass the first time, just run them again.\n\"\"\"", "inputs": [["x - 5 = 20"], ["5 * x + 5 = 30"], ["20 = 5 * x - 5"], ["24 = 4 + 5 * x"], ["x = 5"], ["x * 100 = 700"], ["2 * x + 5 = 105"], ["2 * x = 198"], ["x - 100 + 2 - 50 = 52"], ["x / 3 = 33"], ["x + 80 = 20"], ["x + 20 = -60"], ["5 * x + 20 - x = 60"], ["x + x + 6 = 10"], ["5 * x = x + 8"], ["x = x / 2 + 25"], ["(5 - 3) * x = x + 2"], ["(x - 30) * 2 = x"]], "outputs": [[25], [5], [5], [4], [5], [7], [50], [99], [200], [99], [-60], [-80], [10], [2], [2], [50], [2], [60]], "starter_code": "def solve_for_x(equation: str) -> int:", "canonical_solution": "from itertools import count\n\ndef solve_for_x(equation):\n    return next((x for n in count(0) for x in [n, -n] if eval(equation.replace('x', str(x)).replace('=', '=='))))", "entry_point": "solve_for_x", "task_id": "TACO_lite/2", "input_output_examples": "[[['x - 5 = 20'], ['20 = 5 * x - 5'], ['5 * x = x + 8'], ['(5 - 3) * x = x + 2']], [[25], [5], [2], [2]]]"}
{"requirement": "from typing import List\n\n\ndef total(arr: List[int]) -> int:\n\"\"\"Write a function that takes an array/list of numbers and returns a number such that \n\n**Note:** each array/list will have at least an element and all elements will be valid numbers.\n\"\"\"", "inputs": [[[1, 2, 3, 4, 5]], [[1, 2, 3, 4]], [[1, 2, 3]], [[4, 4, 52, 23, 32, 1, -1]], [[4, 4, 5, -1]], [[-1, -1, -1]], [[-1, -1, -10, 42, 92, 1, 23, 6, -3]], [[-1, 1, -1, 1]], [[42]]], "outputs": [[48], [20], [8], [1753], [30], [-4], [9248], [0], [42]], "starter_code": "from typing import List\ndef total(arr: List[int]) -> int:", "canonical_solution": "def total(arr):\n    while len(arr) > 1:\n        arr = [x + y for x, y in zip(arr, arr[1:])]\n    return arr[0]", "entry_point": "total", "task_id": "TACO_lite/3", "input_output_examples": "[[[[-1, -1, -1]], [[1, 2, 3, 4]]], [[-4], [20]]]"}
{"requirement": "def faro_cycles(n: int) -> int:\n\"\"\"A faro shuffle of a deck of playing cards is a shuffle in which the deck is split exactly in half and then the cards in the two halves are perfectly interwoven, such that the original bottom card is still on the bottom and the original top card is still on top.\n\nIf 8 perfect faro shuffles are performed on a deck of 52 playing cards, the deck is restored to its original order.\n\nWrite a function that inputs an integer n and returns an integer representing the number of faro shuffles it takes to restore a deck of n cards to its original order.\n\nAssume n is an even number between 2 and 2000.\n\"\"\"", "inputs": [[2], [52], [542], [1250], [1954]], "outputs": [[1], [8], [540], [156], [30]], "starter_code": "def faro_cycles(n: int) -> int:", "canonical_solution": "def faro_cycles(n):\n    x, cnt = (2, 1)\n    while x != 1 and n > 3:\n        cnt += 1\n        x = x * 2 % (n - 1)\n    return cnt", "entry_point": "faro_cycles", "task_id": "TACO_lite/4", "input_output_examples": "[[[6]], [[8]]]"}
{"requirement": "from typing import List\n\n\ndef word_search(query: str, seq: List[str]) -> List[str]:\n\"\"\"Write a method that will search an array of strings for all strings that contain another string, ignoring capitalization. Then return an array of the found strings. \n\nThe method takes two parameters, the query string and the array of strings to search, and returns an array. \n\nIf the string isn't contained in any of the strings in the array, the method returns an array containing a single string: \"Empty\" (or `Nothing` in Haskell, or \"None\" in Python and C)\n\"\"\"", "inputs": [["ab", ["za", "ab", "abc", "zab", "zbc"]], ["aB", ["za", "ab", "abc", "zab", "zbc"]], ["ab", ["za", "aB", "Abc", "zAB", "zbc"]], ["abcd", ["za", "aB", "Abc", "zAB", "zbc"]]], "outputs": [[["ab", "abc", "zab"]], [["ab", "abc", "zab"]], [["aB", "Abc", "zAB"]], [["None"]]], "starter_code": "from typing import List\ndef word_search(query: str, seq: List[str]) -> List[str]:", "canonical_solution": "def word_search(query, seq):\n    return [x for x in seq if query.lower() in x.lower()] or ['None']", "entry_point": "word_search", "task_id": "TACO_lite/5", "input_output_examples": "[[['me', ['home', 'milk', 'Mercury', 'fish']]], [[['home', 'Mercury']]]]"}
{"requirement": "from typing import List\n\n\ndef calculate_grade(scores: List[int]) -> str:\n\"\"\"You're a statistics professor and the deadline for submitting your students' grades is tonight at midnight. Each student's grade is determined by their mean score across all of the tests they took this semester.\n\nYou've decided to automate grade calculation by writing a function `calculate_grade()` that takes a list of test scores as an argument and returns a one character string representing the student's grade calculated as follows:\n\n * 90% <= mean score <= 100%: `\"A\"`,\n * 80% <= mean score < 90%: `\"B\"`,\n * 70% <= mean score < 80%: `\"C\"`,\n * 60% <= mean score < 70%: `\"D\"`,\n * mean score < 60%: `\"F\"`\n\nYour function should handle an input list of any length greater than zero.\n\"\"\"", "inputs": [[[92, 94, 99]], [[50, 60, 70, 80, 90]], [[50, 55]]], "outputs": [["A"], ["C"], ["F"]], "starter_code": "from typing import List\ndef calculate_grade(scores: List[int]) -> str:", "canonical_solution": "from bisect import bisect\nfrom statistics import mean\n\ndef calculate_grade(scores):\n    return 'FDCBA'[bisect([60, 70, 80, 90], mean(scores))]", "entry_point": "calculate_grade", "task_id": "TACO_lite/6", "input_output_examples": "[[[[92, 94, 99]], [[50, 60, 70, 80, 90]]], [['A'], ['C']]]"}
{"requirement": "def trump_detector(ts: str) -> float:\n\"\"\"We all love the future president (or Führer or duce or sōtō as he could find them more fitting) donald trump, but we might fear that some of his many fans like John Miller or John Barron are not making him justice, sounding too much like their (and our as well, of course!) hero and thus risking to compromise him.\n\nFor this reason we need to create a function to detect the original and unique rythm of our beloved leader, typically having a lot of extra vowels, all ready to fight the estabilishment.\n\nThe index is calculated based on how many vowels are repeated more than once in a row and dividing them by the total number of vowels a petty enemy of America would use.\n\n**Notes:** vowels are only the ones in the patriotic group of \"aeiou\": \"y\" should go back to Greece if she thinks she can have the same rights of true American vowels; there is always going to be at least a vowel, as silence is the option of coward Kenyan/terrorist presidents and their friends.\n\nRound each result by two decimal digits: there is no place for small fry in Trump's America.\n\n*Special thanks for [Izabela](https://www.codewars.com/users/ijelonek) for support and proof-reading.*\n\"\"\"", "inputs": [["I will build a huge wall"], ["HUUUUUGEEEE WAAAAAALL"], ["MEXICAAAAAAAANS GOOOO HOOOMEEEE"], ["America NUUUUUKEEEE Oooobaaaamaaaaa"], ["listen migrants: IIII KIIIDD YOOOUUU NOOOOOOTTT"]], "outputs": [[0], [4], [2.5], [1.89], [1.56]], "starter_code": "def trump_detector(ts: str) -> float:", "canonical_solution": "import re\n\ndef trump_detector(ts):\n    x = re.findall('([aeiou])(\\\\1*)', ts, re.I)\n    y = [len(i[1]) for i in x]\n    return round(sum(y) / len(y), 2)", "entry_point": "trump_detector", "task_id": "TACO_lite/7", "input_output_examples": "[[['I will build a huge wall'], ['HUUUUUGEEEE WAAAAAALL'], ['listen migrants: IIII KIIIDD YOOOUUU NOOOOOOTTT']], [[0.0], [4.0], [1.56]]]"}
{"requirement": "from typing import List\n\n\ndef likes(names: List[str]) -> str:\n\"\"\"You probably know the \"like\" system from Facebook and other pages. People can \"like\" blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.\n\nImplement a function `likes :: [String] -> String`, which must take in input array, containing the names of people who like an item. It must return the display text.\n\nFor 4 or more names, the number in `and 2 others` simply increases.\n\"\"\"", "inputs": [[[]], [["Peter"]], [["Jacob", "Alex"]], [["Max", "John", "Mark"]], [["Alex", "Jacob", "Mark", "Max"]]], "outputs": [["no one likes this"], ["Peter likes this"], ["Jacob and Alex like this"], ["Max, John and Mark like this"], ["Alex, Jacob and 2 others like this"]], "starter_code": "from typing import List\ndef likes(names: List[str]) -> str:", "canonical_solution": "def likes(names):\n    n = len(names)\n    return {0: 'no one likes this', 1: '{} likes this', 2: '{} and {} like this', 3: '{}, {} and {} like this', 4: '{}, {} and {others} others like this'}[min(4, n)].format(*names[:3], others=n - 2)", "entry_point": "likes", "task_id": "TACO_lite/8", "input_output_examples": "[[[[]], [['Peter']], [['Jacob', 'Alex']], [['Max', 'John', 'Mark']], [['Alex', 'Jacob', 'Mark', 'Max']]], [['no one likes this'], ['Peter likes this'], ['Jacob and Alex like this'], ['Max, John and Mark like this'], ['Alex, Jacob and 2 others like this']]]"}
{"requirement": "def solve(p: int) -> str:\n\"\"\"Consider the following well known rules:\n\n- A number is divisible by 3 if the sum of its digits is divisible by 3. Let's call '3' a \"1-sum\" prime\n- For 37, we take numbers in groups of threes from the right and check if the sum of these groups is divisible by 37. \n  Let's call this a \"3-sum\" prime because we use groups of 3.\n- For 41, we take numbers in groups of fives from the right and check if the sum of these groups is divisible by 41. This is a \"5-sum\" prime.\n- Other examples: 239 is a \"7-sum\" prime (groups of 7), while 199 is a \"99-sum\" prime (groups of 99).\n\nLet's look at another type of prime:\n- For 11, we need to add all digits by alternating their signs from the right. \n  Let's call this a \"1-altsum\" prime\n- For 7, we need to group the digits into threes from the right and add all groups by alternating their signs.\n- 7 is a \"3-altsum\" prime because we use groups of threes. 47 is a \"23-altsum\" (groups of 23), while 73 is a \"4-altsum\" prime (groups of 4).\n\n\nYou will be given a prime number `p` and your task is to find the smallest positive integer `n` such that `p’s` divisibility testing is `n-sum` or `n-altsum`.\n\nPrimes will not exceed `50,000,000`. \n\nYou can get some insight from [Fermat's little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem). \n\nGood luck!\n\"\"\"", "inputs": [[3], [7], [11], [13], [37], [47], [73], [239], [376049], [999883], [24701723], [45939401]], "outputs": [["1-sum"], ["3-altsum"], ["1-altsum"], ["3-altsum"], ["3-sum"], ["23-altsum"], ["4-altsum"], ["7-sum"], ["47006-altsum"], ["499941-sum"], ["12350861-sum"], ["11484850-altsum"]], "starter_code": "def solve(p: int) -> str:", "canonical_solution": "import math\n\ndef divisors(n):\n    divs = [1]\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divs.extend([i, n // i])\n    divs.extend([n])\n    return list(set(divs))\n\ndef solve(p):\n    for d in sorted(divisors(p - 1)):\n        if pow(10, d, p) == 1:\n            return '{}-sum'.format(d)\n            break\n        elif pow(10, d, p) == p - 1:\n            return '{}-altsum'.format(d)\n            break", "entry_point": "solve", "task_id": "TACO_lite/9", "input_output_examples": "[[[3], [7]], [['1-sum'], ['3-altsum']]]"}
{"requirement": "from typing import List\n\n\ndef beggars(values: List[int], n: int) -> List[int]:\n\"\"\"Born a misinterpretation of [this kata](https://www.codewars.com/kata/simple-fun-number-334-two-beggars-and-gold/), your task here is pretty simple: given an array of values and an amount of beggars, you are supposed to return an array with the sum of what each beggar brings home, assuming they all take regular turns, from the first to the last.\n\nAlso note that not all beggars have to take the same amount of \"offers\", meaning that the length of the array is not necessarily a multiple of `n`; length can be even shorter, in which case the last beggars will of course take nothing (`0`).\n\n***Note:*** in case you don't get why this kata is about *English* beggars, then you are not familiar on how religiously queues are taken in the kingdom ;)\n\"\"\"", "inputs": [[[1, 2, 3, 4, 5], 1], [[1, 2, 3, 4, 5], 2], [[1, 2, 3, 4, 5], 3], [[1, 2, 3, 4, 5], 6], [[1, 2, 3, 4, 5], 0]], "outputs": [[[15]], [[9, 6]], [[5, 7, 3]], [[1, 2, 3, 4, 5, 0]], [[]]], "starter_code": "from typing import List\ndef beggars(values: List[int], n: int) -> List[int]:", "canonical_solution": "def beggars(values, n):\n    return [sum(values[i::n]) for i in range(n)]", "entry_point": "beggars", "task_id": "TACO_lite/10", "input_output_examples": "[[[[1, 2, 3, 4, 5], 2], [[1, 2, 3, 4, 5], 3]], [[[9, 6]], [[5, 7, 3]]]]"}
{"requirement": "def fizz_buzz_cuckoo_clock(t: str) -> str:\n\"\"\"## Your story\nYou've always loved both Fizz Buzz katas and cuckoo clocks, and when you walked by a garage sale and saw an ornate cuckoo clock with a missing pendulum, and a \"Beyond-Ultimate Raspberry Pi Starter Kit\" filled with all sorts of sensors and motors and other components, it's like you were suddenly hit by a beam of light and knew that it was your mission to combine the two to create a computerized Fizz Buzz cuckoo clock!\n\nYou took them home and set up shop on the kitchen table, getting more and more excited as you got everything working together just perfectly. Soon the only task remaining was to write a function to select from the sounds you had recorded depending on what time it was:\n\n\n\n## Your plan\n* When a minute is evenly divisible by three, the clock will say the word \"Fizz\".\n* When a minute is evenly divisible by five, the clock will say the word \"Buzz\".\n* When a minute is evenly divisible by both, the clock will say \"Fizz Buzz\", with two exceptions:\n  1. On the hour, instead of \"Fizz Buzz\", the clock door will open, and the cuckoo bird will come out and \"Cuckoo\" between one and twelve times depending on the hour.\n  2. On the half hour, instead of \"Fizz Buzz\", the clock door will open, and the cuckoo will come out and \"Cuckoo\" just once. \n* With minutes that are not evenly divisible by either three or five, at first you had intended to have the clock just say the numbers ala Fizz Buzz, but then you decided at least for version 1.0 to just have the clock make a quiet, subtle \"tick\" sound for a little more clock nature and a little less noise.\n\nYour input will be a string containing hour and minute values in 24-hour time, separated by a colon, and with leading zeros.\n\nYour return value will be a string containing the combination of Fizz, Buzz, Cuckoo, and/or tick sounds that the clock needs to make at that time, separated by spaces. Note that although the input is in 24-hour time, cuckoo clocks' cuckoos are in 12-hour time. \n\nHave fun!\n\"\"\"", "inputs": [["13:34"], ["21:00"], ["11:15"], ["03:03"], ["14:30"], ["08:55"], ["00:00"], ["12:00"]], "outputs": [["tick"], ["Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo"], ["Fizz Buzz"], ["Fizz"], ["Cuckoo"], ["Buzz"], ["Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo"], ["Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo"]], "starter_code": "def fizz_buzz_cuckoo_clock(t: str) -> str:", "canonical_solution": "def fizz_buzz_cuckoo_clock(t):\n    h, m = list(map(int, t.split(':')))\n    h = h - 12 if h > 12 else h + 12 if h == 0 else h\n    if m == 0:\n        return ' '.join(('Cuckoo' for i in range(h)))\n    if m == 30:\n        return 'Cuckoo'\n    if m % 3 == 0 and m % 5 == 0:\n        return 'Fizz Buzz'\n    if m % 3 == 0:\n        return 'Fizz'\n    if m % 5 == 0:\n        return 'Buzz'\n    return 'tick'", "entry_point": "fizz_buzz_cuckoo_clock", "task_id": "TACO_lite/11", "input_output_examples": "[[['13:34'], ['21:00'], ['11:15'], ['03:03'], ['14:30'], ['08:55'], ['00:00'], ['12:00']], [['tick'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['Fizz Buzz'], ['Fizz'], ['Cuckoo'], ['Buzz'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo'], ['Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo']]]"}
{"requirement": "from typing import Tuple\n\n\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:\n\"\"\"A [Power Law](https://en.wikipedia.org/wiki/Power_law) distribution occurs whenever \"a relative change in one quantity results in a proportional relative change in the other quantity.\" \n\nTherefore, if I give you any pair of co-ordinates (x1,y1) and (x2,y2) in a power law distribution, you can plot the entire rest of the distribution and tell me the value of *y* for any other value of *x*. \n\nGiven a pair of co-ordinates (x1,y1) and (x2,y2) and another x co-ordinate *x3*, return the value of *y3*\n\n(x1,y1) and (x2,y2) will be given as arrays. Answer should be to the nearest integer, but random tests will give you leeway of 1% of the reference solution to account for possible discrepancies from different methods.\n\"\"\"", "inputs": [[[1, 120], [2, 60], 4], [[1, 120], [2, 60], 8], [[1, 120], [4, 30], 8], [[1, 120], [3, 60], 9], [[1, 120], [3, 60], 27], [[1, 120], [9, 30], 27], [[1, 81], [2, 27], 4], [[1, 81], [2, 27], 8], [[1, 81], [4, 9], 8], [[1, 81], [5, 27], 25], [[1, 81], [5, 27], 125], [[1, 81], [25, 9], 125], [[4, 30], [2, 60], 1], [[5, 27], [1, 81], 1], [[4, 9], [8, 3], 1], [[1, 120], [1, 120], 1], [[4, 99], [4, 99], 4], [[9, 1], [9, 1], 9]], "outputs": [[30], [15], [15], [30], [15], [15], [9], [3], [3], [9], [3], [3], [120], [81], [81], [120], [99], [1]], "starter_code": "from typing import Tuple\ndef power_law(p1: Tuple[float, float], p2: Tuple[float, float], x3: float) -> int:", "canonical_solution": "from math import log\n\ndef power_law(p1, p2, x3):\n    (x1, y1), (x2, y2) = (p1, p2)\n    x1 += 1e-09\n    y1 += 1e-09\n    return round(y1 * (y2 / y1) ** log(x3 / x1, x2 / x1))", "entry_point": "power_law", "task_id": "TACO_lite/12", "input_output_examples": "[[[[1, 120], [2, 60], 4]], [[30]]]"}
{"requirement": "from typing import List\n\n\ndef human_years_cat_years_dog_years(x: int) -> List[int]:\n\"\"\"# Kata Task\n\nI have a cat and a dog.\n\nI got them at the same time as kitten/puppy. That was `humanYears` years ago.\n\nReturn their respective ages now as [`humanYears`,`catYears`,`dogYears`]\n\nNOTES:\n* humanYears >= 1\n* humanYears are whole numbers only\n\n## Cat Years\n\n* `15` cat years for first year\n* `+9` cat years for second year\n* `+4` cat years for each year after that\n\n## Dog Years\n\n* `15` dog years for first year\n* `+9` dog years for second year\n* `+5` dog years for each year after that\n\n\n\n**References**\n\n* http://www.catster.com/cats-101/calculate-cat-age-in-cat-years\n* http://www.slate.com/articles/news_and_politics/explainer/2009/05/a_dogs_life.html\n\n\n\nIf you liked this Kata there is another related one here\n\"\"\"", "inputs": [[1], [2], [10]], "outputs": [[[1, 15, 15]], [[2, 24, 24]], [[10, 56, 64]]], "starter_code": "from typing import List\ndef human_years_cat_years_dog_years(x: int) -> List[int]:", "canonical_solution": "def human_years_cat_years_dog_years(x):\n    return [x, 24 + (x - 2) * 4 if x != 1 else 15, 24 + (x - 2) * 5 if x != 1 else 15]", "entry_point": "human_years_cat_years_dog_years", "task_id": "TACO_lite/13", "input_output_examples": "[[], []]"}
{"requirement": "from typing import List\n\n\ndef solve(lst: List[int]) -> str:\n\"\"\"In this Kata, you will be given an array and your task will be to determine if an array is in ascending or descending order and if it is rotated or not. \n\nConsider the array `[1,2,3,4,5,7,12]`. This array is sorted in `Ascending` order. If we rotate this array once to the left, we get `[12,1,2,3,4,5,7]` and twice-rotated we get `[7,12,1,2,3,4,5]`. These two rotated arrays are in `Rotated Ascending` order.\n\nSimilarly, the array `[9,6,5,3,1]` is in `Descending` order, but we can rotate it to get an array in `Rotated Descending` order: `[1,9,6,5,3]` or `[3,1,9,6,5]` etc.\n\nArrays will never be unsorted, except for those that are rotated as shown above. Arrays will always have an answer.\n\nGood luck!\n\"\"\"", "inputs": [[[1, 2, 3, 4, 5, 7]], [[7, 1, 2, 3, 4, 5]], [[2, 3, 4, 5, 7, 12]], [[7, 12, 1, 2, 3, 4, 5]], [[4, 5, 6, 1, 2, 3]], [[9, 8, 7, 6, 5]], [[5, 9, 8, 7, 6]], [[6, 5, 9, 8, 7]], [[9, 6, 7]], [[10, 12, 11]], [[13, 10, 11]]], "outputs": [["A"], ["RA"], ["A"], ["RA"], ["RA"], ["D"], ["RD"], ["RD"], ["RA"], ["RD"], ["RA"]], "starter_code": "from typing import List\ndef solve(lst: List[int]) -> str:", "canonical_solution": "def solve(lst):\n    a, b, c = (lst[0] < lst[1], lst[1] < lst[2], lst[-1] < lst[0])\n    m = a if a == b else c\n    return ('R' if c == m else '') + ('A' if m else 'D')", "entry_point": "solve", "task_id": "TACO_lite/14", "input_output_examples": "[[[[1, 2, 3, 4, 5, 7]], [[7, 1, 2, 3, 4, 5]], [[4, 5, 6, 1, 2, 3]], [[9, 8, 7, 6]], [[5, 9, 8, 7, 6]]], [['A'], ['RA'], ['RA'], ['D'], ['RD']]]"}
{"requirement": "from typing import List\n\n\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:\n\"\"\"A core idea of several left-wing ideologies is that the wealthiest should *support* the poorest, no matter what and that is exactly what you are called to do using this kata (which, on a side note, was born out of the necessity to redistribute the width of `div`s into a given container).\n\nYou will be given two parameters, `population` and `minimum`: your goal is to give to each one according to his own needs (which we assume to be equal to `minimum` for everyone, no matter what), taking from the richest (bigger numbers) first.\n\nIf you happen to have few people as the richest, just take from the ones with the lowest index (the closest to the left, in few words) in the array first, on a 1:1 based heroic proletarian redistribution, until everyone is satisfied.\n\nIf giving `minimum` is unfeasable with the current resources (as it often comes to be the case in socialist communities...), just return an empty array `[]`.\n\"\"\"", "inputs": [[[5, 5, 5, 15, 70], 5], [[20, 20, 20, 20, 20], 20], [[5, 5, 5, 42, 43], 5], [[2, 3, 5, 45, 45], 30], [[30, 30, 30, 30, 30], 30]], "outputs": [[[5, 5, 5, 15, 70]], [[20, 20, 20, 20, 20]], [[5, 5, 5, 42, 43]], [[]], [[30, 30, 30, 30, 30]]], "starter_code": "from typing import List\ndef socialist_distribution(population: List[int], minimum: int) -> List[int]:", "canonical_solution": "def socialist_distribution(population, minimum):\n    if minimum > sum(population) // len(population):\n        return []\n    while min(population) < minimum:\n        population[population.index(min(population))] += 1\n        population[population.index(max(population))] -= 1\n    return population", "entry_point": "socialist_distribution", "task_id": "TACO_lite/15", "input_output_examples": "[[[[2, 3, 5, 15, 75], 5], [[2, 3, 5, 45, 45], 5], [[2, 3, 5, 15, 75], 30]], [[[5, 5, 5, 15, 70]], [[5, 5, 5, 42, 43]], [[]]]]"}
{"requirement": "def roots(a: float, b: float, c: float) -> float:\n\"\"\"Implement function which will return sum of roots of a quadratic equation rounded to 2 decimal places, if there are any possible roots, else return **None/null/nil/nothing**. If you use discriminant, when discriminant = 0, x1 = x2 = root => return sum of both roots. There will always be valid arguments.\n\nQuadratic equation - https://en.wikipedia.org/wiki/Quadratic_equation\n\"\"\"", "inputs": [[1, -35, -23], [6, 0, -24], [-5, 21, 0], [6, 4, 8], [1, 5, -24], [3, 11, 6], [2, 2, 9], [1, -1.6666666666666667, -26], [1, 6, 10], [7, -2, -5], [1, 8, 20], [2, 3, -2], [1, 4, 12], [3, -2, -5], [3, 4, 9], [5, 4, 0], [4, -5, 0], [1, 4, 9], [1, 0, -49], [2, 8, 8], [1, 0, -0.16], [1, 6, 12], [1, 0, -9], [-3, 0, 12], [1, 3, 9], [3, 7, 0], [5, 3, 6], [1, 4, 4], [-1, 0, 5.29], [1, 12, 36], [1, 0, -0.09], [2, 5, 11], [3, 0, -15], [1, -3, 0], [1, 8, 16], [2, 6, 9], [-1, 36, 0], [5, -8, 0], [1, 5, 12], [-14, 0, 0], [1, 7, 20], [1, -6, 0], [1, -11, 30], [1, 3, 12], [1, 6, 9], [8, 47, 41]], "outputs": [[35], [0], [4.2], [null], [-5], [-3.67], [null], [1.67], [null], [0.29], [null], [-1.5], [null], [0.67], [null], [-0.8], [1.25], [null], [0], [-4], [0], [null], [0], [0], [null], [-2.33], [null], [-4], [0], [-12], [0], [null], [0], [3], [-8], [null], [36], [1.6], [null], [0], [null], [6], [11], [null], [-6], [-5.88]], "starter_code": "def roots(a: float, b: float, c: float) -> float:", "canonical_solution": "def roots(a, b, c):\n    if b ** 2 >= 4 * a * c:\n        return round(-b / a, 2)", "entry_point": "roots", "task_id": "TACO_lite/16", "input_output_examples": "[[], []]"}
{"requirement": "from typing import List\nfrom typing import Union\n\n\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:\n\"\"\"You are given a sequence of a journey in London, UK. The sequence will contain bus **numbers** and TFL tube names as **strings**.\n\nJourneys will always only contain a combination of tube names and bus numbers. Each tube journey costs `£2.40` and each bus journey costs `£1.50`. If there are `2` or more adjacent bus journeys, the bus fare is capped for sets of two adjacent buses and calculated as one bus fare for each set.\n\nYour task is to calculate the total cost of the journey and return the cost `rounded to 2 decimal places` in the format (where x is a number): `£x.xx`\n\"\"\"", "inputs": [[[12, "Central", "Circle", 21]], [["Piccidilly", 56]], [["Northern", "Central", "Circle"]], [["Piccidilly", 56, 93, 243]], [[386, 56, 1, 876]], [[]]], "outputs": [["£7.80"], ["£3.90"], ["£7.20"], ["£5.40"], ["£3.00"], ["£0.00"]], "starter_code": "from typing import List\nfrom typing import Union\ndef london_city_hacker(journey: List[Union[int, str]]) -> str:", "canonical_solution": "def london_city_hacker(journey):\n    tube = 2.4\n    bus = 1.5\n    total_cost = 0.0\n    count = 0\n    for link in journey:\n        if isinstance(link, str):\n            total_cost += tube\n            count = 0\n        elif count == 0:\n            total_cost += bus\n            count += 1\n        else:\n            count = 0\n    return '£{:.2f}'.format(total_cost)", "entry_point": "london_city_hacker", "task_id": "TACO_lite/17", "input_output_examples": "[[], []]"}
{"requirement": "from typing import List\n\n\ndef chess_board(rows: int, columns: int) -> List[List[str]]:\n\"\"\"A grid is a perfect starting point for many games (Chess, battleships, Candy Crush!).\n\nMaking a digital chessboard I think is an interesting way of visualising how loops can work together.\n\nYour task is to write a function that takes two integers `rows` and `columns` and returns a chessboard pattern as a two dimensional array.\n\nThe white spaces should be represented by an: `'O'`\n\nand the black an: `'X'`\n\nThe first row should always start with a white space `'O'`\n\"\"\"", "inputs": [[1, 1], [1, 2], [2, 1], [2, 2], [6, 6]], "outputs": [[[["O"]]], [[["O", "X"]]], [[["O"], ["X"]]], [[["O", "X"], ["X", "O"]]], [[["O", "X", "O", "X", "O", "X"], ["X", "O", "X", "O", "X", "O"], ["O", "X", "O", "X", "O", "X"], ["X", "O", "X", "O", "X", "O"], ["O", "X", "O", "X", "O", "X"], ["X", "O", "X", "O", "X", "O"]]]], "starter_code": "from typing import List\ndef chess_board(rows: int, columns: int) -> List[List[str]]:", "canonical_solution": "def chess_board(rows, columns):\n    return [['OX'[(row + col) % 2] for col in range(columns)] for row in range(rows)]", "entry_point": "chess_board", "task_id": "TACO_lite/18", "input_output_examples": "[[[6, 4], [3, 7]], [[[['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O']]], [[['O', 'X', 'O', 'X', 'O', 'X', 'O'], ['X', 'O', 'X', 'O', 'X', 'O', 'X'], ['O', 'X', 'O', 'X', 'O', 'X', 'O']]]]]"}
{"requirement": "from typing import List\nfrom typing import Union\n\n\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:\n\"\"\"You're in ancient Greece and giving Philoctetes a hand in preparing a training exercise for Hercules! You've filled a pit with two different ferocious mythical creatures for Hercules to battle!\n\nThe formidable **\"Orthus\"** is a 2 headed dog with 1 tail.  The mighty **\"Hydra\"** has 5 heads and 1 tail. \n\nBefore Hercules goes in, he asks you \"How many of each beast am  I up against!?\".\n\nYou know the total number of heads and the total number of tails, that's the dangerous parts, right? But you didn't consider how many of each beast. \n\n## Task\n\nGiven the number of heads and the number of tails, work out the number of each mythical beast! \n\nThe data is given as two parameters. Your answer should be returned as an array:\n\nIf there aren't any cases for the given amount of heads and tails - return \"No solutions\" or null (C#).\n\"\"\"", "inputs": [[123, 39], [371, 88], [24, 12], [113, 37], [635, 181], [25, 555], [12, 25], [54, 956], [5455, 54956], [0, 0], [-1, -1], [-45, 5], [99, 0], [0, 99], [5, -55]], "outputs": [[[24, 15]], [[23, 65]], [[12, 0]], [[24, 13]], [[90, 91]], ["No solutions"], ["No solutions"], ["No solutions"], ["No solutions"], [[0, 0]], ["No solutions"], ["No solutions"], ["No solutions"], ["No solutions"], ["No solutions"]], "starter_code": "from typing import List\nfrom typing import Union\ndef beasts(heads: int, tails: int) -> Union[List[int], str]:", "canonical_solution": "def beasts(heads, tails):\n    orthus = (5 * tails - heads) / 3\n    hydra = tails - orthus\n    return [orthus, hydra] if orthus >= 0 and hydra >= 0 else 'No solutions'", "entry_point": "beasts", "task_id": "TACO_lite/19", "input_output_examples": "[[[24, 15], [0, 0]], [[24, 15], ['No solutions']]]"}
{"requirement": "from typing import List\n\n\ndef round_to_five(numbers: List[float]) -> List[float]:\n    \"\"\"Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n\n    Roundings have to be done like \"in real life\": `22.5 -> 25`\n    \"\"\"", "inputs": [[[1, 5, 87, 45, 8, 8]], [[3, 56.2, 11, 13]], [[22.5, 544.9, 77.5]]], "outputs": [[[0, 5, 85, 45, 10, 10]], [[5, 55, 10, 15]], [[25, 545, 80]]], "starter_code": "from typing import List\ndef round_to_five(numbers: List[float]) -> List[float]:", "canonical_solution": "from decimal import Decimal, ROUND_HALF_UP\n\ndef round_to_five(numbers):\n    return [(n / 5).quantize(1, ROUND_HALF_UP) * 5 for n in map(Decimal, numbers)]", "entry_point": "round_to_five", "task_id": "TACO_lite/20", "input_output_examples": "[[[[34.5, 56.2, 11, 13]]], [[[35, 55, 10, 15]]]]"}
{"requirement": "from typing import List\n\n\ndef sum_dig_pow(a: int, b: int) -> List[int]:\n\"\"\"The number ```89``` is the first integer with more than one digit that fulfills the property partially introduced in the title of this kata. \nWhat's the use of saying \"Eureka\"? Because this sum gives the same number.\n\nWe need a function to collect these numbers, that may receive two integers ```a```, ```b``` that defines the range ```[a, b]``` (inclusive) and outputs a list of the sorted numbers in the range that fulfills the property described above.\n\nIf there are no numbers of this kind in the range [a, b] the function should output an empty list.\n\nEnjoy it!!\n\"\"\"", "inputs": [[1, 100], [10, 89], [10, 100], [90, 100], [90, 150], [50, 150], [10, 150], [89, 135]], "outputs": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 89]], [[89]], [[89]], [[]], [[135]], [[89, 135]], [[89, 135]], [[89, 135]]], "starter_code": "from typing import List\ndef sum_dig_pow(a: int, b: int) -> List[int]:", "canonical_solution": "def dig_pow(n):\n    return sum((int(x) ** y for y, x in enumerate(str(n), 1)))\n\ndef sum_dig_pow(a, b):\n    return [x for x in range(a, b + 1) if x == dig_pow(x)]", "entry_point": "sum_dig_pow", "task_id": "TACO_lite/21", "input_output_examples": "[[[[1, 10]], [[1, 100]], [[90, 100]]], [[[1, 2, 3, 4, 5, 6, 7, 8, 9]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 89]], [[]]]]"}
{"requirement": "from typing import List\n\n\ndef interleave(*args: List[int]) -> List[int]:\n\"\"\"```if-not:ruby\nCreate a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with empty elements.\n```\n```if:ruby\nCreate a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with `nil`s.\n```\n\"\"\"", "inputs": [[[1, 2, 3], ["c", "d", "e"]], [[1, 2, 3], [4, 5]], [[1, 2], [3, 4, 5]], [[null], [null, null], [null, null, null]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[]]], "outputs": [[[1, "c", 2, "d", 3, "e"]], [[1, 4, 2, 5, 3, null]], [[1, 3, 2, 4, null, 5]], [[null, null, null, null, null, null, null, null, null]], [[1, 4, 7, 2, 5, 8, 3, 6, 9]], [[]]], "starter_code": "from typing import List\ndef interleave(*args: List[int]) -> List[int]:", "canonical_solution": "from itertools import chain, zip_longest\n\ndef interleave(*args):\n    return list(chain.from_iterable(zip_longest(*args)))", "entry_point": "interleave", "task_id": "TACO_lite/22", "input_output_examples": "[[[[1, 2, 3], ['c', 'd', 'e']], [[1, 2, 3], [4, 5]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[]]], [[[1, 'c', 2, 'd', 3, 'e']], [[1, 4, 2, 5, 3, None]], [[1, 4, 7, 2, 5, 8, 3, 6, 9]], [[]]]]"}
{"requirement": "from typing import List\n\n\ndef memesorting(meme: List[str]) -> str:\n\"\"\"Roma is programmer and he likes memes about IT,  \nMaxim is chemist and he likes memes about chemistry,  \nDanik is designer and he likes memes about design,  \nand Vlad likes all other memes.\n\n___\n\nYou will be given a meme (string), and your task is to identify its category, and send it to the right receiver: `IT - 'Roma'`, `chemistry - 'Maxim'`, `design - 'Danik'`, or `other - 'Vlad'`.\n\nIT meme has letters `b, u, g`.  \nChemistry meme has letters `b, o, o, m`.  \nDesign meme has letters `e, d, i, t, s`.  \nIf there is more than 1 possible answer, the earliest match should be chosen.\n\n**Note:** letters are case-insensetive and should come in the order specified above.\n\n___\n\n\"\"\"", "inputs": [["This is programmer meme ecause it has bug"], ["This is also programbur meme gecause it has needed key word"], ["This is edsigner meme cause it has key word"], ["This could be chemistry meme but our gey word boom is too late"], ["This is meme"]], "outputs": [["Roma"], ["Roma"], ["Danik"], ["Roma"], ["Vlad"]], "starter_code": "from typing import List\ndef memesorting(meme: List[str]) -> str:", "canonical_solution": "import re\nfrom itertools import accumulate\npatterns = [(re.compile('.*'.join('bug'), flags=re.I), 'Roma'), (re.compile('.*'.join('boom'), flags=re.I), 'Maxim'), (re.compile('.*'.join('edits'), flags=re.I), 'Danik')]\n\ndef memesorting(meme):\n    return next((who for m in accumulate(meme) for pattern, who in patterns if pattern.search(m)), 'Vlad')", "entry_point": "memesorting", "task_id": "TACO_lite/23", "input_output_examples": "[[['this is programmer meme because it has bug'], ['this is also programbur meme gecause it has needed key word'], ['this is edsigner meme cause it ha s key word'], ['this could be chemistry meme but our gey word boom is too late'], ['this could be chemistry meme but our gey word bo our gey word boom is too late']], [['IT - Roma'], ['IT - Roma'], ['design - Danik'], ['other - Vlad'], ['other - Vlad']]]"}
{"requirement": "def not_visible_cubes(n: int) -> int:\n\"\"\"Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n\"\"\"", "inputs": [[0], [1], [2], [3], [4], [5], [7], [12], [18], [10002]], "outputs": [[0], [0], [0], [1], [8], [27], [125], [1000], [4096], [1000000000000]], "starter_code": "def not_visible_cubes(n: int) -> int:", "canonical_solution": "def not_visible_cubes(n):\n    return max(n - 2, 0) ** 3", "entry_point": "not_visible_cubes", "task_id": "TACO_lite/24", "input_output_examples": "[[[4]], [[8]]]"}
{"requirement": "def fibonacci(m: int) -> int:\n\"\"\"### Problem Context\n\nThe [Fibonacci](http://en.wikipedia.org/wiki/Fibonacci_number) sequence is traditionally used to explain tree recursion.  \n\nThis algorithm serves well its educative purpose but it's [tremendously inefficient](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2), not only because of recursion, but because we invoke the fibonacci function twice, and the right branch of recursion (i.e. `fibonacci(n-2)`) recalculates all the Fibonacci numbers already calculated by the left branch (i.e. `fibonacci(n-1)`).\n\nThis algorithm is so inefficient that the time to calculate any Fibonacci number over 50 is simply too much. You may go for a cup of coffee or go take a nap while you wait for the answer. But if you try it here in Code Wars you will most likely get a code timeout before any answers.\n\nFor this particular Kata we want to **implement the memoization solution**. This will be cool because it will let us *keep using the tree recursion* algorithm while still keeping it sufficiently optimized to get an answer very rapidly.\n\nThe trick of the memoized version is that we will keep a cache data structure (most likely an associative array) where we will store the Fibonacci numbers as we calculate them. When a Fibonacci number is calculated, we first look it up in the cache, if it's not there, we calculate it and put it in the cache, otherwise we returned the cached number.\n\nRefactor the function into a recursive Fibonacci function that using a memoized data structure avoids the deficiencies of tree recursion. Can you make it so the memoization cache is private to this function?\n\"\"\"", "inputs": [[70], [60], [50]], "outputs": [[190392490709135], [1548008755920], [12586269025]], "starter_code": "def fibonacci(m: int) -> int:", "canonical_solution": "def fibonacci(m):\n    cache = {0: 0, 1: 1}\n\n    def fib(n):\n        if n not in cache:\n            cache[n] = fib(n - 1) + fib(n - 2)\n        return cache[n]\n    return fib(m)", "entry_point": "fibonacci", "task_id": "TACO_lite/25", "input_output_examples": "[[], []]"}
{"requirement": "def calculate_1rm(w: int, r: int) -> int:\n\"\"\"You just got done with your set at the gym, and you are wondering how much weight you could lift if you did a single repetition. Thankfully, a few scholars have devised formulas for this purpose (from [Wikipedia](https://en.wikipedia.org/wiki/One-repetition_maximum)) :\n\n\n### Epley\n\n\n### McGlothin\n\n\n### Lombardi\n\n\nYour function will receive a weight `w` and a number of repetitions `r` and must return your projected one repetition maximum. Since you are not sure which formula to use and you are feeling confident, your function will return the largest value from the three formulas shown above, rounded to the nearest integer. However, if the number of repetitions passed in is `1` (i.e., it is already a one rep max), your function must return `w`. Also, if the number of repetitions passed in is `0` (i.e., no repetitions were completed), your function must return `0`.\n\"\"\"", "inputs": [[135, 20], [200, 8], [270, 2], [360, 1], [400, 0]], "outputs": [[282], [253], [289], [360], [0]], "starter_code": "def calculate_1rm(w: int, r: int) -> int:", "canonical_solution": "def calculate_1rm(w, r):\n    if r == 0:\n        return 0\n    if r == 1:\n        return w\n    return round(max([w * (1 + r / 30), 100 * w / (101.3 - 2.67123 * r), w * r ** 0.1]))", "entry_point": "calculate_1rm", "task_id": "TACO_lite/26", "input_output_examples": "[[], []]"}
{"requirement": "def my_crib(n: int) -> str:\n\"\"\"## Task\n\nGiven `n` representing the number of floors build a beautiful multi-million dollar mansions.\n\n**Note:** whitespace should be preserved on both sides of the roof. Number of floors will go up to 30. There will be no tests with invalid input.\n\nIf you manage to complete it, you can try a harder version [here](https://www.codewars.com/kata/58360d112fb0ba255300008b).\n\nGood luck!\n\"\"\"", "inputs": [[1], [2], [3]], "outputs": [[" /\\ \n/__\\\n|__|"], ["  /\\  \n /  \\ \n/____\\\n|    |\n|____|"], ["   /\\   \n  /  \\  \n /    \\ \n/______\\\n|      |\n|      |\n|______|"]], "starter_code": "def my_crib(n: int) -> str:", "canonical_solution": "def my_crib(n):\n    roof = '\\n'.join(('%s/%s\\\\%s' % (' ' * (n - i), ' ' * i * 2, ' ' * (n - i)) for i in range(n)))\n    ceiling = '\\n/%s\\\\\\n' % ('_' * (n * 2))\n    walls = '|%s|\\n' % (' ' * (n * 2)) * (n - 1)\n    floor = '|%s|' % ('_' * (n * 2))\n    return roof + ceiling + walls + floor", "entry_point": "my_crib", "task_id": "TACO_lite/27", "input_output_examples": "[[], []]"}
{"requirement": "def get_middle(s: str) -> str:\n\"\"\"You are going to be given a word. Your job is to return the middle character of the word. If the word's length is odd, return the middle character. If the word's length is even, return the middle 2 characters.\n\n#Input\n\nA word (string) of length `0 < str < 1000` (In javascript you may get slightly more than 1000 in some test cases due to an error in the test cases). You do not need to test for this. This is only here to tell you that you do not need to worry about your solution timing out.\n\n\n#Output\n\nThe middle character(s) of the word represented as a string.\n\"\"\"", "inputs": [["test"], ["testing"], ["middle"], ["A"], ["of"]], "outputs": [["es"], ["t"], ["dd"], ["A"], ["of"]], "starter_code": "def get_middle(s: str) -> str:", "canonical_solution": "def get_middle(s):\n    return s[(len(s) - 1) // 2:len(s) // 2 + 1]", "entry_point": "get_middle", "task_id": "TACO_lite/28", "input_output_examples": "[[['test'], ['testing'], ['middle'], ['A']], [['es'], ['t'], ['dd'], ['A']]]"}
{"requirement": "def josephus_survivor(n: int, k: int) -> int:\n\"\"\"In this kata you have to correctly return who is the \"survivor\", ie: the last element of a Josephus permutation.\n\nBasically you have to assume that n people are put into a circle and that they are eliminated in steps of k elements.\n\nThe above link about the \"base\" kata description will give you a more thorough insight about the origin of this kind of permutation, but basically that's all that there is to know to solve this kata.\n\n**Notes and tips:** using the solution to the other kata to check your function may be helpful, but as much larger numbers will be used, using an array/list to compute the number of the survivor may be too slow; you may assume that both n and k will always be >=1.\n\"\"\"", "inputs": [[7, 3], [11, 19], [40, 3], [14, 2], [100, 1], [1, 300], [2, 300], [5, 300], [7, 300], [300, 300]], "outputs": [[4], [10], [28], [13], [100], [1], [1], [1], [7], [265]], "starter_code": "def josephus_survivor(n: int, k: int) -> int:", "canonical_solution": "def josephus_survivor(n, k):\n    v = 0\n    for i in range(1, n + 1):\n        v = (v + k) % i\n    return v + 1", "entry_point": "josephus_survivor", "task_id": "TACO_lite/29", "input_output_examples": "[[[7, 3]], [[4]]]"}
{"requirement": "def kontti(s: str) -> str:\n\"\"\"Kontti language is a finnish word play game.\n\nYou add `-kontti` to the end of each word and then swap their characters until and including the first vowel (\"aeiouy\");\n\nIf no vowel is present, the word stays the same.\n\nWrite a string method that turns a sentence into kontti language!\n\"\"\"", "inputs": [["lamppu"], ["lamppu sofia"], ["silly game"], ["aeiou"], ["xyz lamppu"], [""], ["lAmppU"], ["silly grrr"]], "outputs": [["komppu-lantti"], ["komppu-lantti kofia-sontti"], ["kolly-sintti kome-gantti"], ["koeiou-antti"], ["koz-xyntti komppu-lantti"], [""], ["komppU-lAntti"], ["kolly-sintti grrr"]], "starter_code": "def kontti(s: str) -> str:", "canonical_solution": "import re\n\ndef kontti(s):\n    return ' '.join([re.sub('([^aeiouy]*[aeiouy])(.*)', 'ko\\\\2-\\\\1ntti', w, flags=re.I) for w in s.split()])", "entry_point": "kontti", "task_id": "TACO_lite/30", "input_output_examples": "[[['tame'], ['fruity']], [['kome-tantti'], ['koity-fruntti']]]"}
{"requirement": "def count_divisors(n: int) -> int:\n\"\"\"In this Kata we focus on finding a sum S(n) which is the total number of divisors taken for all natural numbers less or equal to n. More formally, we investigate the sum of n components denoted by d(1) + d(2) + ... + d(n) in which for any i starting from 1 up to n the value of d(i) tells us how many distinct numbers divide i without a remainder. \n\nYour solution should work for possibly large values of n without a timeout.\nAssume n to be greater than zero and not greater than 999 999 999 999 999.\nBrute force approaches will not be feasible options in such cases. It is fairly simple to conclude that for every n>1 there holds a recurrence S(n) = S(n-1) + d(n) with initial case S(1) = 1.\n\nTry to convince yourself that for any natural k, the number S(k) is the same as the number of pairs (m,n) that solve the inequality mn <= k in natural numbers.\nOnce it becomes clear, we can think of a partition of all the solutions into classes just by saying that a pair (m,n) belongs to the class indexed by n.\nThe question now arises if it is possible to count solutions of n-th class. If f(n) stands for the number of solutions that belong to n-th class, it means that S(k) = f(1) + f(2) + f(3) + ...\n\nThe reasoning presented above leads us to some kind of a formula for S(k), however not necessarily the most efficient one. Can you imagine that all the solutions to inequality mn <= k can be split using sqrt(k) as pivotal item?\n\"\"\"", "inputs": [[5], [10], [20], [59], [105], [785], [1001], [8009], [9999999999999], [9999999999998], [9999999999995], [9999999949950]], "outputs": [[10], [27], [66], [249], [510], [5364], [7077], [73241], [300880375389561], [300880375389537], [300880375389493], [300880373832097]], "starter_code": "def count_divisors(n: int) -> int:", "canonical_solution": "def count_divisors(n):\n    r = int(n ** (1 / 2))\n    return 2 * sum((n // i for i in range(1, r + 1))) - r * r", "entry_point": "count_divisors", "task_id": "TACO_lite/31", "input_output_examples": "[[[1], [2], [3], [4], [5]], [[1], [3], [5], [8], [10]]]"}
{"requirement": "def bumps(road: str) -> str:\n\"\"\"Your car is old, it breaks easily. The shock absorbers are gone and you think it can handle about 15 more bumps before it dies totally.\n\nUnfortunately for you, your drive is very bumpy! Given a string showing either flat road (\"\\_\") or bumps (\"n\"), work out if you make it home safely. 15 bumps or under, return \"Woohoo!\", over 15 bumps return \"Car Dead\".\n\"\"\"", "inputs": [["n"], ["_nnnnnnn_n__n______nn__nn_nnn"], ["______n___n_"], ["nnnnnnnnnnnnnnnnnnnnn"]], "outputs": [["Woohoo!"], ["Car Dead"], ["Woohoo!"], ["Car Dead"]], "starter_code": "def bumps(road: str) -> str:", "canonical_solution": "def bumps(road):\n    return 'Woohoo!' if road.count('n') <= 15 else 'Car Dead'", "entry_point": "bumps", "task_id": "TACO_lite/32", "input_output_examples": "[[['____n_n_n_n_n_n_n_n_n_n_n_n_n_n_n'], ['nnnnnnnnnnnnnnn']], [['Woohoo!'], ['Car Dead']]]"}
{"requirement": "from typing import List\nfrom typing import Union\n\n\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:\n\"\"\"Cara is applying for several different jobs.\nThe online application forms ask her to respond within a specific character count.\nCara needs to check that her answers fit into the character limit.\n\nAnnoyingly, some application forms count spaces as a character, and some don't.\n\nYour challenge: \n\nWrite Cara a function `charcheck()` with the arguments:\n\n- `\"text\"`: a string containing Cara's answer for the question\n- `\"max\"`: a number equal to the maximum number of characters allowed in the answer\n- `\"spaces\"`: a boolean which is `True` if spaces are included in the character count and `False` if they are not\n\nThe function `charcheck()` should return an array: `[True, \"Answer\"]` , where `\"Answer\"` is equal to the original text, if Cara's answer is short enough.\n\nIf her answer `\"text\"` is too long, return an array: `[False, \"Answer\"]`. \nThe second element should be the original `\"text\"` string truncated to the length of the limit.\n\nWhen the `\"spaces\"` argument is `False`, you should remove the spaces from the `\"Answer\"`.\n\"\"\"", "inputs": [["I am applying for the role of Base Manager on Titan.", 60, true], ["I am looking to relocate to the vicinity of Saturn for family reasons.", 70, true], ["As Deputy Base Manager on Phobos for five Martian years, I have significant relevant experience.", 90, false], ["A challenging career moment came with the rapid depletion of water supplies on Phobos.", 80, false], ["But, as I pointed out, anyone complaining about standing downwind was lying. There was no wind.", 75, true], ["I have no notice period on Phobos. I can start immediately.", 50, true]], "outputs": [[[true, "I am applying for the role of Base Manager on Titan."]], [[true, "I am looking to relocate to the vicinity of Saturn for family reasons."]], [[true, "AsDeputyBaseManageronPhobosforfiveMartianyears,Ihavesignificantrelevantexperience."]], [[true, "AchallengingcareermomentcamewiththerapiddepletionofwatersuppliesonPhobos."]], [[false, "But, as I pointed out, anyone complaining about standing downwind was lying"]], [[false, "I have no notice period on Phobos. I can start imm"]]], "starter_code": "from typing import List\nfrom typing import Union\ndef charcheck(text: str, mx: int, spaces: bool) -> List[Union[bool, str]]:", "canonical_solution": "def charcheck(text, mx, spaces):\n    text = text if spaces else text.replace(' ', '')\n    return [len(text) <= mx, text[:mx]]", "entry_point": "charcheck", "task_id": "TACO_lite/33", "input_output_examples": "[[[('Cara Hertz', 10, True)], [('Cara Hertz', 9, False)], [('Cara Hertz', 5, True)], [('Cara Hertz', 5, False)]], [[[True, 'Cara Hertz']], [[True, 'CaraHertz']], [[False, 'Cara ']], [[False, 'CaraH']]]]"}
{"requirement": "def convert_recipe(recipe: str) -> str:\n\"\"\"Mary wrote a recipe book and is about to publish it, but because of a new European law, she needs to update and include all measures in grams.\n\nGiven all the measures in tablespoon (`tbsp`) and in teaspoon (`tsp`), considering `1 tbsp = 15g` and `1 tsp = 5g`, append to the end of the measurement the biggest equivalent integer (rounding up).\n\"\"\"", "inputs": [["2 tbsp of butter"], ["Add to the mixing bowl and coat well with 1 tbsp of olive oil & 1/2 tbsp of dried dill"], ["1/2 tsp of baking powder"], ["In another bowl, add 2 tsp of vanilla extract, 3 tsp of baking soda and 1/2 tsp of salt"], ["10 tbsp of cocoa powder"], ["1/8 tbsp of baking soda"], ["In a large bowl, combine confectioners' sugar, sour cream and vanilla"]], "outputs": [["2 tbsp (30g) of butter"], ["Add to the mixing bowl and coat well with 1 tbsp (15g) of olive oil & 1/2 tbsp (8g) of dried dill"], ["1/2 tsp (3g) of baking powder"], ["In another bowl, add 2 tsp (10g) of vanilla extract, 3 tsp (15g) of baking soda and 1/2 tsp (3g) of salt"], ["10 tbsp (150g) of cocoa powder"], ["1/8 tbsp (2g) of baking soda"], ["In a large bowl, combine confectioners' sugar, sour cream and vanilla"]], "starter_code": "def convert_recipe(recipe: str) -> str:", "canonical_solution": "import re, math\n\ndef convert_recipe(recipe):\n\n    def repl(m):\n        ratio = 15 if m.group(2) == 'tbsp' else 5\n        return m.group(0) + ' (%sg)' % math.ceil(eval(m.group(1)) * ratio)\n    return re.sub('([0-9/]+) (tb?sp)', repl, recipe)", "entry_point": "convert_recipe", "task_id": "TACO_lite/34", "input_output_examples": "[[['2 tbsp of butter'], ['1/2 tbsp of oregano'], ['1/2 tsp of salt'], ['Add to the mixing bowl and coat well with 1 tbsp of olive oil & 1/2 tbsp of dried dill']], [['2 tbsp (30g) of butter'], ['1/2 tbsp (8g) of oregano'], ['1/2 tbsp (3g) of salt'], ['Add to the mixing bowl and coat well with 1 tbsp (15g) of olive oil & 1/2 tbsp (8g) of dried dill']]]"}
{"requirement": "from typing import List\n\n\ndef move_zeros(arr: List[int]) -> List[int]:\n\"\"\"Write an algorithm that takes an array and moves all of the zeros to the end, preserving the order of the other elements.\n\"\"\"", "inputs": [[[1, 2, 0, 1, 0, 1, 0, 3, 0, 1]], [[9, 0.0, 0, 9, 1, 2, 0, 1, 0, 1, 0.0, 3, 0, 1, 9, 0, 0, 0, 0, 9]], [["a", 0, 0, "b", "c", "d", 0, 1, 0, 1, 0, 3, 0, 1, 9, 0, 0, 0, 0, 9]], [["a", 0, 0, "b", null, "c", "d", 0, 1, false, 0, 1, 0, 3, [], 0, 1, 9, 0, 0, {}, 0, 0, 9]], [[0, 1, null, 2, false, 1, 0]], [["a", "b"]], [["a"]], [[0, 0]], [[0]], [[]]], "outputs": [[[1, 2, 1, 1, 3, 1, 0, 0, 0, 0]], [[9, 9, 1, 2, 1, 1, 3, 1, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [["a", "b", "c", "d", 1, 1, 3, 1, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [["a", "b", null, "c", "d", 1, false, 1, 3, [], 1, 9, {}, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[1, null, 2, false, 1, 0, 0]], [["a", "b"]], [["a"]], [[0, 0]], [[0]], [[]]], "starter_code": "from typing import List\ndef move_zeros(arr: List[int]) -> List[int]:", "canonical_solution": "def move_zeros(arr):\n    l = [i for i in arr if isinstance(i, bool) or i != 0]\n    return l + [0] * (len(arr) - len(l))", "entry_point": "move_zeros", "task_id": "TACO_lite/35", "input_output_examples": "[[[[False, 1, 0, 1, 2, 0, 1, 3, 'a']]], [[[False, 1, 1, 2, 1, 3, 'a', 0, 0]]]]"}
{"requirement": "def string_parse(string: str) -> str:\n\"\"\"Create a program that will take in a string as input and, if there are duplicates of more than two alphabetical characters in the string, returns the string with all the extra characters in a bracket.\n\nPlease also ensure that the input is a string, and return \"Please enter a valid string\" if it is not.\n\"\"\"", "inputs": [["aaaabbcdefffffffg"], [3], ["boopdedoop"], ["helloookat"], [true], [""], ["aAAabbcdeffFfFffg"], ["aAAabbcdeFFFffffg"], [{}], [[5.3]]], "outputs": [["aa[aa]bbcdeff[fffff]g"], ["Please enter a valid string"], ["boopdedoop"], ["helloo[o]kat"], ["Please enter a valid string"], [""], ["aAAabbcdeffFfFffg"], ["aAAabbcdeFF[F]ff[ff]g"], ["Please enter a valid string"], ["Please enter a valid string"]], "starter_code": "def string_parse(string: str) -> str:", "canonical_solution": "import re\n\ndef string_parse(string):\n    return re.sub('(.)\\\\1(\\\\1+)', '\\\\1\\\\1[\\\\2]', string) if isinstance(string, str) else 'Please enter a valid string'", "entry_point": "string_parse", "task_id": "TACO_lite/36", "input_output_examples": "[[['aaaabbcdefffffffg']], [['aa[aa]bbcdeff[fffff]g']]]"}
{"requirement": "from typing import List\n\n\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:\n\"\"\"Every Friday and Saturday night, farmer counts amount of sheep returned back to his farm (sheep returned on Friday stay and don't leave for a weekend).\n\nSheep return in groups each of the days -> you will be given two arrays with these numbers (one for Friday and one for Saturday night). Entries are always positive ints, higher than zero.\n\nFarmer knows the total amount of sheep, this is a third parameter. You need to return the amount of sheep lost (not returned to the farm) after final sheep counting on Saturday.\n\nGood luck! :-)\n\"\"\"", "inputs": [[[1, 2], [3, 4], 15], [[3, 1, 2], [4, 5], 21], [[5, 1, 4], [5, 4], 29], [[11, 23, 3, 4, 15], [7, 14, 9, 21, 15], 300], [[2, 7, 13, 17], [23, 56, 44, 12, 1, 2, 1], 255], [[2, 5, 8], [11, 23, 3, 4, 15, 112, 12, 4], 355], [[1, 1, 1, 2, 1, 2], [2, 1, 2, 1, 2, 1], 30], [[5, 10, 15], [11, 23, 3, 4, 15], 89], [[3, 6, 9, 12], [3, 2, 1, 2, 3, 1], 44]], "outputs": [[5], [6], [10], [178], [77], [156], [13], [3], [2]], "starter_code": "from typing import List\ndef lostsheep(friday: List[int], saturday: List[int], total: int) -> int:", "canonical_solution": "def lostsheep(friday, saturday, total):\n    return total - sum(friday + saturday)", "entry_point": "lostsheep", "task_id": "TACO_lite/37", "input_output_examples": "[[[[1, 2], [3, 4], 15], [[3, 1, 2], [4, 5], 21]], [[5], [6]]]"}
{"requirement": "def diamonds_and_toads(sentence: str, fairy: str) -> dict:\n\"\"\"Base on the fairy tale [Diamonds and Toads](https://en.wikipedia.org/wiki/Diamonds_and_Toads) from Charles Perrault. In this kata you will have to complete a function that take 2 arguments: \n\n- A string, that correspond to what the daugther says.\n- A string, that tell you wich fairy the girl have met, this one can be `good` or `evil`. \n\nThe function should return the following count as a hash:\n\n- If the girl have met the `good` fairy:\n  - count 1 `ruby` everytime you see a `r` and 2 everytime you see a `R`\n  - count 1 `crystal` everytime you see a `c` and 2 everytime you see a `C`\n- If the girl have met the `evil` fairy: \n  - count 1 `python` everytime you see a `p` and 2 everytime uou see a `P`\n  - count 1 `squirrel` everytime you see a `s` and 2 everytime you see a `S`\n  \n**Note**: For this kata I decided to remplace the normal `Diamonds` and `Toads` by some programming languages. And just discover that [Squirrel](https://en.wikipedia.org/wiki/Squirrel_(programming_language) is a programming language.\n\"\"\"", "inputs": [["Ruby and Crystal", "good"], ["This string contain some Ruby and some Crystal in it", "good"], ["Python and Squirrel", "evil"], ["This string contain some Python and some Squirrel in it", "evil"]], "outputs": [[{"ruby": 3, "crystal": 2}], [{"ruby": 4, "crystal": 3}], [{"python": 2, "squirrel": 2}], [{"python": 2, "squirrel": 6}]], "starter_code": "def diamonds_and_toads(sentence: str, fairy: str) -> dict:", "canonical_solution": "from collections import Counter\n\ndef diamonds_and_toads(sentence, fairy):\n    c = Counter(sentence)\n    d = {'good': ['ruby', 'crystal'], 'evil': ['python', 'squirrel']}\n    return {s: c[s[0]] + 2 * c[s[0].upper()] for s in d[fairy]}", "entry_point": "diamonds_and_toads", "task_id": "TACO_lite/38", "input_output_examples": "[[], []]"}
{"requirement": "def get_grade(s1: int, s2: int, s3: int) -> str:\n\"\"\"## Grade book\n\nComplete the function so that it finds the mean of the three scores passed to it and returns the letter value associated with that grade.\n\nNumerical Score    | Letter Grade\n---                | ---\n90 <= score <= 100 | 'A'\n80 <= score < 90   | 'B'\n70 <= score < 80   | 'C'\n60 <= score < 70   | 'D'\n 0 <= score < 60   | 'F'\n\nTested values are all between 0 and 100. Theres is no need to check for negative values or values greater than 100.\n\"\"\"", "inputs": [[95, 90, 93], [100, 85, 96], [92, 93, 94], [100, 100, 100], [70, 70, 100], [82, 85, 87], [84, 79, 85], [70, 70, 70], [75, 70, 79], [60, 82, 76], [65, 70, 59], [66, 62, 68], [58, 62, 70], [44, 55, 52], [48, 55, 52], [58, 59, 60], [0, 0, 0]], "outputs": [["A"], ["A"], ["A"], ["A"], ["B"], ["B"], ["B"], ["C"], ["C"], ["C"], ["D"], ["D"], ["D"], ["F"], ["F"], ["F"], ["F"]], "starter_code": "def get_grade(s1: int, s2: int, s3: int) -> str:", "canonical_solution": "def get_grade(s1, s2, s3):\n    m = (s1 + s2 + s3) / 3.0\n    if 90 <= m <= 100:\n        return 'A'\n    elif 80 <= m < 90:\n        return 'B'\n    elif 70 <= m < 80:\n        return 'C'\n    elif 60 <= m < 70:\n        return 'D'\n    return 'F'", "entry_point": "get_grade", "task_id": "TACO_lite/39", "input_output_examples": "[[], []]"}
{"requirement": "from typing import Union\n\n\ndef palindrome(num: int) -> Union[bool, str]:\n\"\"\"A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward. \n\nFor a given number `num`, write a function to test if it's a numerical palindrome or not and return a boolean (true if it is and false if not).\n\n```if-not:haskell\nReturn \"Not valid\" if the input is not an integer or less than `0`.\n```\n```if:haskell\nReturn `Nothing` if the input is less than `0` and `Just True` or `Just False` otherwise.\n```\n\nOther Kata in this Series:\nNumerical Palindrome #1\nNumerical Palindrome #1.5\nNumerical Palindrome #2\nNumerical Palindrome #3\nNumerical Palindrome #3.5\nNumerical Palindrome #4\nNumerical Palindrome #5\n\"\"\"", "inputs": [[1221], [110011], [1456009006541], [123322], [1], [152], [9999], ["ACCDDCCA"], ["@14AbC"], ["1221"], [-450]], "outputs": [[true], [true], [true], [false], [true], [false], [true], ["Not valid"], ["Not valid"], ["Not valid"], ["Not valid"]], "starter_code": "from typing import Union\ndef palindrome(num: int) -> Union[bool, str]:", "canonical_solution": "def palindrome(num):\n    if type(num) is not int or num < 1:\n        return 'Not valid'\n    return num == int(str(num)[::-1])", "entry_point": "palindrome", "task_id": "TACO_lite/40", "input_output_examples": "[[[2332], [110011], [54322345]], [[True], [True], [True]]]"}
{"requirement": "def sabb(stg: str, value: int, happiness: int) -> str:\n\"\"\"Learning to code around your full time job is taking over your life. You realise that in order to make significant steps quickly, it would help to go to a coding bootcamp in London.\n\nProblem is, many of them cost a fortune, and those that don't still involve a significant amount of time off work - who will pay your mortgage?!\n\nTo offset this risk, you decide that rather than leaving work totally, you will request a sabbatical so that you can go back to work post bootcamp and be paid while you look for your next role.\n\nYou need to approach your boss. Her decision will be based on three parameters:\n\nval=your value to the organisation\nhappiness=her happiness level at the time of asking and finally\nThe numbers of letters from 'sabbatical' that are present in string `s`.\n\nNote that if `s` contains three instances of the letter 'l', that still scores three points, even though there is only one in the word sabbatical.\n\nIf the sum of the three parameters (as described above) is > 22, return 'Sabbatical! Boom!', else return 'Back to your desk, boy.'.\n\n~~~if:c\nNOTE: For the C translation you should return a string literal.\n~~~\n\"\"\"", "inputs": [["Can I have a sabbatical?", 5, 5], ["Why are you shouting?", 7, 2], ["What do you mean I cant learn to code??", 8, 9], ["Please calm down", 9, 1], ["I can?! Nice. FaC..Im coming :D", 9, 9]], "outputs": [["Sabbatical! Boom!"], ["Back to your desk, boy."], ["Sabbatical! Boom!"], ["Back to your desk, boy."], ["Sabbatical! Boom!"]], "starter_code": "def sabb(stg: str, value: int, happiness: int) -> str:", "canonical_solution": "def sabb(stg, value, happiness):\n    sabbatical = value + happiness + sum((1 for c in stg if c in 'sabbatical')) > 22\n    return 'Sabbatical! Boom!' if sabbatical else 'Back to your desk, boy.'", "entry_point": "sabb", "task_id": "TACO_lite/41", "input_output_examples": "[[], []]"}
{"requirement": "from typing import List\n\n\ndef sort_array(xs: List[int]) -> List[int]:\n\"\"\"You are given an array of integers. Your task is to sort odd numbers within the array in ascending order, and even numbers in descending order.\n\nNote that zero is an even number. If you have an empty array, you need to return it.\n\"\"\"", "inputs": [[[5, 3, 2, 8, 1, 4, 11]], [[2, 22, 37, 11, 4, 1, 5, 0]], [[1, 111, 11, 11, 2, 1, 5, 0]], [[]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]], [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]], [[0, 1, 2, 3, 4, 9, 8, 7, 6, 5]]], "outputs": [[[1, 3, 8, 4, 5, 2, 11]], [[22, 4, 1, 5, 2, 11, 37, 0]], [[1, 1, 5, 11, 2, 11, 111, 0]], [[]], [[1, 8, 3, 6, 5, 4, 7, 2, 9, 0]], [[8, 1, 6, 3, 4, 5, 2, 7, 0, 9]], [[8, 1, 6, 3, 4, 5, 2, 7, 0, 9]]], "starter_code": "from typing import List\ndef sort_array(xs: List[int]) -> List[int]:", "canonical_solution": "def sort_array(xs):\n    es = sorted((x for x in xs if x % 2 == 0))\n    os = sorted((x for x in xs if x % 2 != 0), reverse=True)\n    return [(es if x % 2 == 0 else os).pop() for x in xs]", "entry_point": "sort_array", "task_id": "TACO_lite/42", "input_output_examples": "[[[[5, 3, 2, 8, 1, 4]]], [[[1, 3, 8, 4, 5, 2]]]]"}
{"requirement": "def missing_angle(h: float, a: float, o: float) -> int:\n\"\"\"Below is a right-angled triangle:\n\n```\n  |\\\n  | \\\n  |  \\\n  |   \\ \no |    \\ h \n  |     \\\n  |    θ \\\n  |_______\\ \n     a\n```\n\nYour challange is to write a function (```missingAngle``` in C/C#, ```missing_angle``` in Ruby), that calculates the angle θ in degrees to the nearest integer. You will be given three arguments representing each side: o, h and a. One of the arguments equals zero. Use the length of the two other sides to calculate θ. You will not be expected to handle any erronous data in your solution.\n\"\"\"", "inputs": [[0, 400, 300], [5, 4, 0], [8, 0, 5], [16.7, 0, 12.3], [7, 5, 0]], "outputs": [[37], [37], [39], [47], [44]], "starter_code": "def missing_angle(h: float, a: float, o: float) -> int:", "canonical_solution": "import math\n\ndef missing_angle(h, a, o):\n    if h == 0:\n        radians = math.atan(o / a)\n    elif a == 0:\n        radians = math.asin(o / h)\n    else:\n        radians = math.acos(a / h)\n    return round(math.degrees(radians))", "entry_point": "missing_angle", "task_id": "TACO_lite/43", "input_output_examples": "[[], []]"}
{"requirement": "def xor(a: int, b: int) -> bool:\n\"\"\"# Exclusive \"or\" (xor) Logical Operator\n\n## Overview\n\nIn some scripting languages like PHP, there exists a logical operator (e.g. ```&&```, ```||```, ```and```, ```or```, etc.) called the \"Exclusive Or\" (hence the name of this Kata).  The exclusive or evaluates two booleans.  It then returns true if **exactly one of the two expressions are true**, false otherwise.\n\n## Task\n\nSince we cannot define keywords in Javascript (well, at least I don't know how to do it), your task is to define a function ```xor(a, b)``` where a and b are the two expressions to be evaluated.  Your ```xor``` function should have the behaviour described above, returning true if **exactly one of the two expressions evaluate to true**, false otherwise.\n\"\"\"", "inputs": [[false, false], [true, false], [false, true], [true, true]], "outputs": [[false], [true], [true], [false]], "starter_code": "def xor(a: int, b: int) -> bool:", "canonical_solution": "def xor(a, b):\n    return a != b", "entry_point": "xor", "task_id": "TACO_lite/44", "input_output_examples": "[[], []]"}
{"requirement": "from typing import List\n\n\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:\n\"\"\"Don't Drink the Water\n\nGiven a two-dimensional array representation of a glass of mixed liquids, sort the array such that the liquids appear in the glass based on their density. (Lower density floats to the top) The width of the glass will not change from top to bottom.\n\n======================\n|   Density Chart    |\n======================\n| Honey   | H | 1.36 |\n| Water   | W | 1.00 |\n| Alcohol | A | 0.87 |\n| Oil     | O | 0.80 |\n----------------------\n\nThe glass representation may be larger or smaller. If a liquid doesn't fill a row, it floats to the top and to the left.\n\"\"\"", "inputs": [[[["H", "H", "W", "O"], ["W", "W", "O", "W"], ["H", "H", "O", "O"]]], [[["A", "A", "O", "H"], ["A", "H", "W", "O"], ["W", "W", "A", "W"], ["H", "H", "O", "O"]]], [[["A", "H", "W", "O"]]], [[["A"], ["H"], ["W"], ["O"]]], [[]]], "outputs": [[[["O", "O", "O", "O"], ["W", "W", "W", "W"], ["H", "H", "H", "H"]]], [[["O", "O", "O", "O"], ["A", "A", "A", "A"], ["W", "W", "W", "W"], ["H", "H", "H", "H"]]], [[["O", "A", "W", "H"]]], [[["O"], ["A"], ["W"], ["H"]]], [[]]], "starter_code": "from typing import List\ndef separate_liquids(glass: List[List[str]]) -> List[List[str]]:", "canonical_solution": "DENSITY = {'H': 1.36, 'W': 1, 'A': 0.87, 'O': 0.8}\n\ndef separate_liquids(glass):\n    if not glass:\n        return []\n    column = len(glass[0])\n    liquids = sorted((b for a in glass for b in a), key=lambda c: DENSITY[c])\n    return [liquids[d:d + column] for d in range(0, len(liquids), column)]", "entry_point": "separate_liquids", "task_id": "TACO_lite/45", "input_output_examples": "[[[['H', 'H', 'W', 'O'], ['W', 'W', 'O', 'W'], ['H', 'H', 'O', 'O']]], [[['O', 'O', 'O', 'O'], ['W', 'W', 'W', 'W'], ['H', 'H', 'H', 'H']]]]"}
{"requirement": "from typing import List\n\n\ndef build_square(blocks: List[int]) -> bool:\n\"\"\"# The Invitation\n\nMost of us played with toy blocks growing up. It was fun and you learned stuff. So what else can you do but rise to the challenge when a 3-year old exclaims, \"Look, I made a square!\", then pointing to a pile of blocks, \"Can _you_ do it?\"\n\n# These Blocks\n\nJust to play along, of course we'll be viewing these blocks in two dimensions. Depth now being disregarded, it turns out the pile has four different sizes of block: `1x1`, `1x2`, `1x3`, and `1x4`. The smallest one represents the area of a square, the other three are rectangular, and all differ by their width. Integers matching these four widths are used to represent the blocks in the input.\n\n# This Square\n\nWell, the kid made a `4x4` square from this pile, so you'll have to match that. Noticing the way they fit together, you realize the structure must be built in fours rows, one row at a time, where the blocks must be placed horizontally. With the known types of block, there are five types of row you could build:\n\n* 1 four-unit block\n* 1 three-unit block plus 1 one-unit bock (in either order)\n* 2 two-unit blocks\n* 1 two-unit block plus 2 one-unit blocks (in any order)\n* 4 one-unit blocks\n\nAmounts for all four of the block sizes in the pile will each vary from `0` to `16`. The total size of the pile will also vary from `0` to `16`. The order of rows is irrelevant. A valid square doesn't have to use up all the given blocks.\n\n# Input\n```python\nblocks ~ a random list of integers (1 <= x <= 4)\n```\n# Output\n```python\nTrue or False ~ whether you can build a square\n```\n# Enjoy!\n\nIf interested, I also have [this kata](https://www.codewars.com/kata/5cb7baa989b1c50014a53333) as well as [this other kata](https://www.codewars.com/kata/5cb5eb1f03c3ff4778402099) to consider solving.\n\"\"\"", "inputs": [[[]], [[2, 2, 1, 1, 2]], [[3, 3]], [[3, 3, 3, 3, 3, 3, 3]], [[]], [[3, 2]], [[1, 1, 1]], [[2, 2, 1, 1]], [[]], [[]]], "outputs": [[true], [true], [false], [false], [true], [false], [false], [true], [true], [false]], "starter_code": "from typing import List\ndef build_square(blocks: List[int]) -> bool:", "canonical_solution": "def build_square(blocks):\n    for x in range(4):\n        if 4 in blocks:\n            blocks.remove(4)\n        elif 3 in blocks and 1 in blocks:\n            blocks.remove(3)\n            blocks.remove(1)\n        elif blocks.count(2) >= 2:\n            blocks.remove(2)\n            blocks.remove(2)\n        elif 2 in blocks and blocks.count(1) >= 2:\n            blocks.remove(2)\n            blocks.remove(1)\n            blocks.remove(1)\n        elif blocks.count(1) >= 4:\n            blocks.remove(1)\n            blocks.remove(1)\n            blocks.remove(1)\n            blocks.remove(1)\n        else:\n            return False\n    return True", "entry_point": "build_square", "task_id": "TACO_lite/46", "input_output_examples": "[[[1, 3, 2, 2, 4, 1, 1, 3, 1, 4, 2], [1, 3, 2, 4, 3, 3, 2]], [[True], [False]]]"}
{"requirement": "def sea_sick(sea: str) -> str:\n\"\"\"Thanks to the effects of El Nino this year my holiday snorkelling trip was akin to being in a washing machine... Not fun at all.\n\nGiven a string made up of '~' and '\\_' representing waves and calm respectively, your job is to check whether a person would become seasick.\n\nRemember, only the process of change from wave to calm (and vice versa) will add to the effect (really wave peak to trough but this will do). Find out how many changes in level the string has and if that figure is more than 20% of the string, return \"Throw Up\", if less, return \"No Problem\".\n\n\n\"\"\"", "inputs": [["~"], ["_~~~~~~~_~__~______~~__~~_~~"], ["______~___~_"], ["____"], ["_~~_~____~~~~~~~__~_~"]], "outputs": [["No Problem"], ["Throw Up"], ["Throw Up"], ["No Problem"], ["Throw Up"]], "starter_code": "def sea_sick(sea: str) -> str:", "canonical_solution": "def sea_sick(sea):\n    return 'Throw Up' if (sea.count('~_') + sea.count('_~')) / len(sea) > 0.2 else 'No Problem'", "entry_point": "sea_sick", "task_id": "TACO_lite/47", "input_output_examples": "[[], []]"}
{"requirement": "def same_encryption(s1: str, s2: str) -> bool:\n\"\"\"# Task\n John loves encryption. He can encrypt any string by the following algorithm:\n```\ntake the first and the last letters of the word;\nreplace the letters between them with their number;\nreplace this number with the sum of it digits \n          until a single digit is obtained.```\nGiven two strings(`s1` and `s2`), return `true` if their encryption is the same, or `false` otherwise.\n\n# Input/Output\n\n\n - `[input]` string `s1`\n\n  The first string to be encrypted.\n  \n  `s1.length >= 3`\n \n \n - `[input]` string `s2`\n\n  The second string to be encrypted.\n\n  `s2.length >= 3`\n  \n  \n - `[output]` a boolean value\n\n `true` if encryption is the same, `false` otherwise.\n\"\"\"", "inputs": [["abc", "abc"], ["abc", "abd"], ["fKhjuytrdfcdc", "flJc"], ["OKhjuytrdfcdc", "OijK"]], "outputs": [[true], [false], [true], [false]], "starter_code": "def same_encryption(s1: str, s2: str) -> bool:", "canonical_solution": "def same_encryption(s1, s2):\n    return (s1[0], s1[-1], len(s1) % 9) == (s2[0], s2[-1], len(s2) % 9)", "entry_point": "same_encryption", "task_id": "TACO_lite/48", "input_output_examples": "[[['EbnhGfjklmjhgz', 'Eabcz']], [[True]]]"}
{"requirement": "from typing import List\n\n\ndef diff(arr: List[str]) -> str:\n\"\"\"Your task is to find the number couple with the greatest difference from a given array of number-couples. \n\nAll number couples will be given as strings and all numbers in them will be positive integers.  \n\nIn case there are more than one option, you should identify whichever is first. \n\nIf there is no difference, return false.\n\"\"\"", "inputs": [[["43-45", "1021-55", "000-18888", "92-34", "76-32", "99-1", "1020-54"]], [["1-2", "2-4", "5-7", "8-9", "44-45"]], [["1-1000", "2-1000", "100-67", "98-45", "8-9"]], [["33-33", "77-77"]], [["23-67", "67-23", "88-88", "45-46"]], [["45896-2354", "4654-556767", "2455-423522", "3455-355", "34-34", "2524522-0"]], [["1-1", "2-2", "1-0", "77-77"]], [["0-0"]], [[]]], "outputs": [["000-18888"], ["2-4"], ["1-1000"], [false], ["23-67"], ["2524522-0"], ["1-0"], [false], [false]], "starter_code": "from typing import List\ndef diff(arr: List[str]) -> str:", "canonical_solution": "def diff(arr):\n    r = arr and max(arr, key=lambda x: abs(eval(x)))\n    return bool(arr and eval(r)) and r", "entry_point": "diff", "task_id": "TACO_lite/49", "input_output_examples": "[[[['56-23', '1-100']], [['1-3', '5-7', '2-3']], [['11-11', '344-344']]], [['1-100'], ['1-3'], [False]]]"}

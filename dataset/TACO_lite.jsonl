{"question": "Given a number s (in string form). Find the smallest number (without leading zeros) which can be obtained by rearranging the digits of the given number.\n\n**Your Task:**\nYou don't need to read or print anything. Your task is to complete the function `minimum_number()` which takes the number as an input parameter and returns the smallest number that can be formed without leading zeros by rearranging the digits of the number.\n\n**Expected Time Complexity:** O(N * log(N)) where N is the number of digits of the given number\n\n**Expected Space Complexity:** O(1)\n\n**Constraints:**\n- 1 <= N <= 10<sup>5</sup>", "solutions": ["class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tl = list(s)\n\t\tl.sort()\n\t\tfor i in range(len(l)):\n\t\t\tif int(l[i]) > 0:\n\t\t\t\t(l[0], l[i]) = (l[i], l[0])\n\t\t\t\tbreak\n\t\tn = ''\n\t\tfor i in l:\n\t\t\tn += i\n\t\treturn n\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\td = {}\n\t\tfor i in s:\n\t\t\ti = int(i)\n\t\t\tif i in d:\n\t\t\t\td[i] += 1\n\t\t\telse:\n\t\t\t\td[i] = 1\n\t\tt = list(d.keys())\n\t\tt.sort()\n\t\tif len(t) == 1:\n\t\t\treturn str(t[0]) * d[t[0]]\n\t\tres = str(t[1] * 10 + t[0])\n\t\t(d[t[0]], d[t[1]]) = (d[t[0]] - 1, d[t[1]] - 1)\n\t\tfor i in t:\n\t\t\tres += str(i) * d[int(i)]\n\t\treturn res\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tsort = sorted(s)\n\t\ts = ''\n\t\ti = 0\n\t\twhile sort[i] == '0' and i < len(sort) - 1:\n\t\t\ti += 1\n\t\tif i == len(sort):\n\t\t\tfor ele in sort:\n\t\t\t\ts += ele\n\t\ttemp = sort[0]\n\t\tsort[0] = sort[i]\n\t\tsort[i] = temp\n\t\tfor ele in sort:\n\t\t\ts += ele\n\t\treturn s\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tarr = []\n\t\tnew = []\n\t\ts = list(s)\n\t\tfor i in s:\n\t\t\tif int(i) == 0:\n\t\t\t\tnew.append(int(i))\n\t\t\telse:\n\t\t\t\tarr.append(int(i))\n\t\tif len(new) == len(s):\n\t\t\treturn ''.join(s)\n\t\tarr.sort()\n\t\tnew1 = [arr.pop(0)]\n\t\tnew1.extend(new)\n\t\tnew1.extend(arr)\n\t\tans = ''\n\t\tfor i in new1:\n\t\t\tans += str(i)\n\t\tans = int(ans)\n\t\treturn ans\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tj = sorted(s)\n\t\tp = ''\n\t\tif j[0] != '0':\n\t\t\treturn p.join(j)\n\t\telse:\n\t\t\tfor i in range(len(j)):\n\t\t\t\tif j[i] != '0':\n\t\t\t\t\ttemp = j[0]\n\t\t\t\t\tj[0] = j[i]\n\t\t\t\t\tj[i] = temp\n\t\t\t\t\tbreak\n\t\treturn p.join(j)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tm = sorted(s)\n\t\tfor i in range(len(m)):\n\t\t\tif int(m[i]) > 0:\n\t\t\t\t(m[0], m[i]) = (m[i], m[0])\n\t\t\t\tbreak\n\t\tsr = ''\n\t\tfor i in m:\n\t\t\tsr += i\n\t\treturn sr\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tlst = list(s)\n\t\tlst.sort()\n\t\ttmp = ''\n\t\tfor (i, n) in enumerate(lst):\n\t\t\tif n != '0':\n\t\t\t\ttmp = lst.pop(i)\n\t\t\t\tbreak\n\t\treturn str(tmp) + ''.join(lst)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tl = list(s)\n\t\tl.sort()\n\t\ttmp = ''\n\t\tfor (i, ele) in enumerate(l):\n\t\t\tif ele != '0':\n\t\t\t\ttmp = str(l.pop(i))\n\t\t\t\tbreak\n\t\treturn str(tmp) + ''.join(l)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tn = len(s)\n\t\tlst = list(map(int, s))\n\t\tlst.sort()\n\t\tfor i in range(n):\n\t\t\tif lst[i] != 0:\n\t\t\t\t(lst[0], lst[i]) = (lst[i], lst[0])\n\t\t\t\tbreak\n\t\tans = ''\n\t\tfor i in lst:\n\t\t\tans += str(i)\n\t\treturn ans\n", "import functools\n\nclass Solution:\n\n\tdef minimum_Number(self, s):\n\t\tc = 0\n\t\tarr = []\n\t\tfor i in s:\n\t\t\tif i != 0:\n\t\t\t\tarr.append(i)\n\t\t\tif i == '0':\n\t\t\t\tc += 1\n\t\tif c == len(s):\n\t\t\treturn s\n\n\t\tdef fuc(a, b):\n\t\t\tif a + b > b + a:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn -1\n\t\tarr.sort()\n\t\tnews = str(int(''.join(arr)))\n\t\tif c == 0:\n\t\t\treturn news\n\t\telse:\n\t\t\treturn news[0] + '0' * c + news[1:]\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tnum = sorted(s)\n\t\tt = 0\n\t\tfor i in num:\n\t\t\tif i == '0':\n\t\t\t\tt += 1\n\t\t\telse:\n\t\t\t\tbreak\n\t\tnum = num[t:]\n\t\tif len(num) > 0:\n\t\t\tx = num[0]\n\t\telse:\n\t\t\treturn '0' * t\n\t\tnum = ['0'] * t + num[1:]\n\t\tnum.insert(0, x)\n\t\treturn ''.join(num)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tg = s.count('0')\n\t\tl = s.replace('0', '')\n\t\tif len(l) == 0:\n\t\t\treturn s\n\t\tl = sorted(l)\n\t\tl.sort()\n\t\th = [l[0]]\n\t\tfor i in range(g):\n\t\t\th.append('0')\n\t\tfor i in range(1, len(l)):\n\t\t\th.append(l[i])\n\t\treturn ''.join(h)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tx = [i for i in s]\n\t\tx.sort()\n\t\tc = 0\n\t\tfor i in range(len(x)):\n\t\t\tif x[i] != '0':\n\t\t\t\tc = i\n\t\t\t\tbreak\n\t\t(x[0], x[c]) = (x[c], x[0])\n\t\treturn ''.join(x)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tsnum = sorted(list(s))\n\t\tczero = snum.count('0')\n\t\tif czero == len(snum):\n\t\t\treturn s\n\t\tsnum[0] = snum[czero]\n\t\tsnum[czero] = '0'\n\t\treturn ''.join(snum)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tlst = []\n\t\tfor c in s:\n\t\t\tlst.append(c)\n\t\tlst.sort()\n\t\tn = len(lst)\n\t\ti = 0\n\t\twhile i < n and lst[i] == '0':\n\t\t\ti += 1\n\t\tif i == n:\n\t\t\treturn int(''.join(lst))\n\t\telse:\n\t\t\t(lst[0], lst[i]) = (lst[i], lst[0])\n\t\t\treturn int(''.join(lst))\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\ts = sorted(s)\n\t\tans = ''\n\t\ttemp = ''\n\t\tflag = 1\n\t\tfor i in s:\n\t\t\tif i == '0':\n\t\t\t\ttemp = temp + i\n\t\t\t\tflag = 0\n\t\t\telse:\n\t\t\t\tans = ans + i\n\t\t\t\tif flag == 0:\n\t\t\t\t\tans = ans + temp\n\t\t\t\t\tflag = 1\n\t\tif len(ans) == 0:\n\t\t\treturn temp\n\t\treturn ans\nif __name__ == '__main__':\n\tT = int(input())\n\tfor i in range(T):\n\t\ts = input()\n\t\tob = Solution()\n\t\tans = ob.minimum_Number(s)\n\t\tprint(ans)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tl = list(s)\n\t\tl.sort()\n\t\tfor i in range(len(l)):\n\t\t\tif int(l[i]) > 0:\n\t\t\t\t(l[0], l[i]) = (l[i], l[0])\n\t\t\t\tbreak\n\t\tn = ''\n\t\tfor i in l:\n\t\t\tn += i\n\t\treturn n\nif __name__ == '__main__':\n\tT = int(input())\n\tfor i in range(T):\n\t\ts = input()\n\t\tob = Solution()\n\t\tans = ob.minimum_Number(s)\n\t\tprint(ans)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tx = list(sorted(s))\n\t\tk = ''\n\t\tfor i in x:\n\t\t\tif i != '0':\n\t\t\t\tk += i\n\t\t\t\tbreak\n\t\tif len(k) == 0:\n\t\t\treturn s\n\t\tx.remove(k[0])\n\t\tfor i in x:\n\t\t\tk += i\n\t\treturn k\nif __name__ == '__main__':\n\tT = int(input())\n\tfor i in range(T):\n\t\ts = input()\n\t\tob = Solution()\n\t\tans = ob.minimum_Number(s)\n\t\tprint(ans)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tarr = list(s)\n\t\tarr.sort()\n\t\tfor i in range(len(arr)):\n\t\t\tif arr[i] != '0':\n\t\t\t\ttemp = arr[i]\n\t\t\t\tarr.pop(i)\n\t\t\t\tbreak\n\t\tif len(arr) == len(s):\n\t\t\treturn s\n\t\telse:\n\t\t\treturn temp + ''.join(arr)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tres = [int(x) for x in str(s)]\n\t\tmo = ''\n\t\tres.sort()\n\t\tif res[len(res) - 2] == 0:\n\t\t\tres.sort(reverse=True)\n\t\t\tfor s in res:\n\t\t\t\tmo = mo + str(s)\n\t\t\treturn int(mo)\n\t\tif res[0] == 0:\n\t\t\tfor i in range(len(res) - 1):\n\t\t\t\tif res[i] > 0:\n\t\t\t\t\tres[0] = res[i]\n\t\t\t\t\tres[i] = 0\n\t\t\t\t\tbreak\n\t\tfor s in res:\n\t\t\tmo = mo + str(s)\n\t\treturn int(mo)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\ts = list(s)\n\t\ts.sort()\n\t\tind = 0\n\t\tleng = len(s)\n\t\twhile ind < leng and s[ind] == '0':\n\t\t\tind += 1\n\t\tif ind == leng:\n\t\t\treturn int(''.join(s))\n\t\tp = s.pop(ind)\n\t\ts.insert(0, p)\n\t\treturn int(''.join(s))\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tdic = {}\n\t\tfor el in range(10):\n\t\t\tdic[str(el)] = 0\n\t\tif s[0] != '-':\n\t\t\tfor el in s:\n\t\t\t\tdic[el] += 1\n\t\t\tnewS = ''\n\t\t\tfor el in range(1, 10):\n\t\t\t\tnewS += str(el) * dic[str(el)]\n\t\t\tif dic['0'] != 0 and len(newS) > 0:\n\t\t\t\tnewS = newS[0] + '0' * dic['0'] + newS[1:]\n\t\t\telif dic['0'] != 0 and len(newS) == 0:\n\t\t\t\tnewS += '0' * dic['0']\n\t\t\treturn newS\n\t\telse:\n\t\t\tfor el in s[1:]:\n\t\t\t\tdic[el] += 1\n\t\t\tnewS = ''\n\t\t\tfor el in range(9, -1, -1):\n\t\t\t\tnewS += str(el) * dic[str(el)]\n\t\t\tnewS = '-' + newS\n\t\t\treturn newS\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\ts = sorted(s)\n\t\tif s[-1] == '0':\n\t\t\treturn ''.join(s)\n\t\ti = 0\n\t\twhile s[i] == '0':\n\t\t\ti += 1\n\t\t(s[i], s[0]) = (s[0], s[i])\n\t\treturn ''.join(s)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tn = len(s)\n\t\ts = list(s)\n\t\ts = sorted(s)\n\t\ti = 0\n\t\twhile i < n - 1 and s[i] == '0':\n\t\t\ti += 1\n\t\tif i == 0:\n\t\t\treturn ''.join(s)\n\t\telse:\n\t\t\t(s[0], s[i]) = (s[i], s[0])\n\t\treturn ''.join(s)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tlst = list(s)\n\t\tnum = sorted(lst)\n\t\tnum = ''.join(num)\n\t\tnum = list(num)\n\t\tfor i in range(len(num)):\n\t\t\tif num[i] == '0':\n\t\t\t\tcontinue\n\t\t\t(num[i], num[0]) = (num[0], num[i])\n\t\t\treturn ''.join(num)\n\t\treturn ''.join(num)\n", "class Solution:\n\n\tdef minimum_Number(self, n):\n\t\tarr = sorted([int(i) for i in list(str(n))])\n\t\tzcount = arr.count(0)\n\t\tif zcount == 0:\n\t\t\treturn int(''.join(arr))\n\t\telif zcount == len(arr):\n\t\t\treturn 0\n\t\telse:\n\t\t\ts = str(arr[zcount])\n\t\t\tfor _ in range(zcount):\n\t\t\t\ts += '0'\n\t\t\tfor i in arr[zcount + 1:]:\n\t\t\t\ts += str(i)\n\t\t\treturn int(s)\n", "import heapq\n\nclass Solution:\n\n\tdef minimum_Number(self, s):\n\t\ts = list(s)\n\t\ts.sort()\n\t\ts.append('-1')\n\t\ti = 0\n\t\twhile s[i] == '0':\n\t\t\ti += 1\n\t\tif i == len(s) - 1:\n\t\t\treturn 0\n\t\ts.pop()\n\t\t(s[0], s[i]) = (s[i], s[0])\n\t\treturn ''.join(s)\n", "class Solution:\n\n\tdef minimum_Number(self, s):\n\t\tn = len(s)\n\t\tls = list(s)\n\t\tls.sort()\n\t\ti = 0\n\t\twhile i < n and ls[i] == '0':\n\t\t\ti += 1\n\t\tif i < n:\n\t\t\t(ls[0], ls[i]) = (ls[i], ls[0])\n\t\treturn ''.join(ls)\n"], "starter_code": "#User function Template for python3\n\n\n\nclass Solution:\n\n\tdef minimum_Number(self, s):\n\n\t\t# Code here", "input_output": {"inputs": ["s = \"846903\"", "s = \"55010\""], "outputs": ["304689", "10055"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Mathematical"], "name": null, "source": "geeksforgeeks", "tags": ["Mathematics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/smallest-number-by-rearranging-digits-of-a-given-number0820/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N * log(N)) where N is the number of digits of the given number"}
{"question": "An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n**Note:** anagrams are case insensitive\n\nComplete the function to return `true` if the two arguments given are anagrams of each other; return `false` otherwise.", "solutions": ["def is_anagram(test, original):\n\treturn sorted(original.lower()) == sorted(test.lower())\n", "from collections import Counter\n\ndef is_anagram(test, original):\n\treturn Counter(test.lower()) == Counter(original.lower())\n", "def is_anagram(test, original):\n\treturn sorted(test.upper()) == sorted(original.upper())\n", "def is_anagram(test, original):\n\t(test_dict, original_dict) = ({}, {})\n\tfor i in test.lower():\n\t\ttest_dict[i] = test_dict.get(i, 0) + 1\n\tfor i in original.lower():\n\t\toriginal_dict[i] = original_dict.get(i, 0) + 1\n\treturn test_dict == original_dict\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\tcount = [0] * 26\n\tfor i in range(len(test)):\n\t\tcount[(ord(test[i]) & 31) - 1] += 1\n\t\tcount[(ord(original[i]) & 31) - 1] -= 1\n\treturn not any(count)\n", "def is_anagram(test, original):\n\ta = sorted(test.lower())\n\tb = sorted(original.lower())\n\tc = ''.join(a)\n\td = ''.join(b)\n\tif c == d:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tgo = len(test) == len(original)\n\tarr = []\n\tif go:\n\t\tfor i in test:\n\t\t\tarr.append(i.lower() in original.lower())\n\t\treturn False not in arr\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\tfor l in test.lower():\n\t\tif l not in original.lower():\n\t\t\treturn False\n\treturn True\n", "from operator import eq\nfrom collections import Counter\n\ndef is_anagram(test, original):\n\treturn eq(*map(Counter, map(str.lower, (test, original))))\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\treturn sorted(test.lower()) == sorted(original.lower())\n", "def is_anagram(test, original):\n\tif sorted(test.lower()) == sorted(original.lower()):\n\t\treturn True\n\telse:\n\t\treturn False\n", "is_anagram = lambda t, o: sorted(t.lower()) == sorted(o.lower())\n", "aprime = {'a': 2, 'c': 5, 'b': 3, 'e': 11, 'd': 7, 'g': 17, 'f': 13, 'i': 23, 'h': 19, 'k': 31, 'j': 29, 'm': 41, 'l': 37, 'o': 47, 'n': 43, 'q': 59, 'p': 53, 's': 67, 'r': 61, 'u': 73, 't': 71, 'w': 83, 'v': 79, 'y': 97, 'x': 89, 'z': 101}\n\ndef aprime_sum(str):\n\tstrChList = list(str.lower())\n\treturn sum([aprime[x] for x in strChList])\n\ndef is_anagram(test, original):\n\tif aprime_sum(test) == aprime_sum(original):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\treturn set(original.lower()) == set(test.lower()) if len(test) == len(original) else False\n", "def is_anagram(test, original):\n\ta = list(test.lower())\n\ts = list(original.lower())\n\tif len(a) != len(s):\n\t\treturn False\n\telse:\n\t\tfor i in a:\n\t\t\tcond = False\n\t\t\tk = 0\n\t\t\twhile k != len(s) and cond == False:\n\t\t\t\tif i == s[k]:\n\t\t\t\t\ta.remove(i)\n\t\t\t\t\ts.remove(i)\n\t\t\t\t\tcond = True\n\t\t\t\tk += 1\n\t\t\tif cond == False:\n\t\t\t\treturn False\n\t\tif len(a) != len(s):\n\t\t\treturn False\n\t\telse:\n\t\t\treturn True\n", "def is_anagram(test, original):\n\tflag = 0\n\tif len(test) != len(original):\n\t\treturn False\n\telse:\n\t\tfor i in test.lower():\n\t\t\tif i not in original.lower():\n\t\t\t\tflag = 1\n\t\t\telse:\n\t\t\t\tcontinue\n\t\tif flag == 1:\n\t\t\treturn False\n\t\telse:\n\t\t\treturn True\n", "def is_anagram(test, original):\n\n\tdef to_dict(word):\n\t\tdictionary = {}\n\t\tfor w in word.lower():\n\t\t\tif w not in dictionary:\n\t\t\t\tdictionary[w] = 0\n\t\t\telse:\n\t\t\t\tdictionary[w] += 1\n\t\treturn dictionary\n\treturn to_dict(test) == to_dict(original)\n", "is_anagram = lambda a, b, s=sorted: s(a.lower()) == s(b.lower())\n", "def is_anagram(s, l):\n\tn = len(s)\n\tif len(l) != n:\n\t\treturn False\n\ts = s.lower()\n\tl = l.lower()\n\th = [0 for x in range(26)]\n\tfor i in range(n):\n\t\th[ord(s[i]) - 97] += 1\n\t\th[ord(l[i]) - 97] -= 1\n\treturn h.count(0) == 26\n", "def is_anagram(test: str, original: str) -> bool:\n\treturn all([all([_ in original.lower() for _ in test.lower()]), len(test) == len(original)])\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\ttestcount = 0\n\tfor i in test:\n\t\tif i in original:\n\t\t\ttestcount += 1\n\toriginalcount = 0\n\tfor i in original:\n\t\tif i in test:\n\t\t\toriginalcount += 1\n\tif testcount == originalcount and testcount == len(test) and (originalcount == len(original)):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) == len(original):\n\t\ttest = test.lower()\n\t\toriginal = original.lower()\n\t\tcount = 0\n\t\tfor char in test:\n\t\t\tif char in original:\n\t\t\t\tcount += 1\n\t\tif count == len(test):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest_list = []\n\toriginal_list = []\n\tfor i in test.lower():\n\t\ttest_list.append(i)\n\tfor i in original.lower():\n\t\toriginal_list.append(i)\n\ttest_list.sort()\n\toriginal_list.sort()\n\tprint(test_list)\n\tprint(original_list)\n\tif test_list == original_list:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\tletters = {}\n\tfor i in test.lower():\n\t\tif i in letters:\n\t\t\tletters[i] += 1\n\t\telse:\n\t\t\tletters[i] = 1\n\tfor i in original.lower():\n\t\tif i not in letters:\n\t\t\treturn False\n\t\tif original.lower().count(i) != letters[i]:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(t, o):\n\treturn sorted([*t.lower()]) == sorted([*o.lower()])\n", "def is_anagram(test, original):\n\tx = list(test.lower())\n\ty = list(original.lower())\n\tx = sorted(x)\n\ty = sorted(y)\n\tif x == y:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\ta = sorted(test.lower())\n\tb = sorted(original.lower())\n\tif a == b:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tsorted_test = sorted(list(test.lower()))\n\tsorted_original = sorted(list(original.lower()))\n\treturn sorted_test == sorted_original\n", "def is_anagram(test, original):\n\tletters = [c for c in test.lower()]\n\tfor char in original.lower():\n\t\tif char in letters:\n\t\t\tdel letters[letters.index(char)]\n\t\telse:\n\t\t\treturn False\n\treturn not bool(len(letters))\n", "import collections\n\ndef is_anagram(test, original):\n\treturn collections.Counter([i.lower() for i in sorted(test)]) == collections.Counter([i.lower() for i in sorted(original)])\n", "def is_anagram(test, original):\n\ttest_set = sorted(test.lower())\n\toriginal_set = sorted(original.lower())\n\tif test_set == original_set:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tt = sorted(test.lower())\n\to = sorted(original.lower())\n\tif t == o:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tnew_test = test.lower()\n\tnew_original = original.lower()\n\tsortedTest = sorted(new_test)\n\tsortedOriginal = sorted(new_original)\n\tfor letters in new_test:\n\t\tif letters in new_original and len(new_test) == len(new_original) and (sortedOriginal == sortedTest):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n", "def is_anagram(test, original):\n\ttest_word_freq = {}\n\toriginal_word_freq = {}\n\ttest = test.lower()\n\toriginal = original.lower()\n\tif len(test) == len(original):\n\t\tfor (idx, letter) in enumerate(test):\n\t\t\tif letter not in test_word_freq:\n\t\t\t\ttest_word_freq[letter] = 1\n\t\t\telse:\n\t\t\t\ttest_word_freq[letter] += 1\n\t\tfor (idx, lett) in enumerate(original):\n\t\t\tif lett not in original_word_freq:\n\t\t\t\toriginal_word_freq[lett] = 1\n\t\t\telse:\n\t\t\t\toriginal_word_freq[lett] += 1\n\t\tprint(original_word_freq)\n\t\tprint(test_word_freq)\n\t\tfor (k, v) in list(test_word_freq.items()):\n\t\t\tif k not in original_word_freq:\n\t\t\t\treturn False\n\t\t\tif v != original_word_freq[k]:\n\t\t\t\treturn False\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tfirst = [i.lower() for i in test]\n\tsecond = [i.lower() for i in original]\n\treturn sorted(first) == sorted(second)\n", "def is_anagram(test, original):\n\tlist_test = []\n\tlist_original = []\n\tfor i in test.lower():\n\t\tlist_test += i\n\tfor i in original.lower():\n\t\tlist_original += i\n\tif len(list_test) == len(list_original):\n\t\tlist_test.sort()\n\t\tlist_original.sort()\n\t\tif list_test == list_original:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\treturn True if sorted([letter for letter in test.lower()]) == sorted([letter for letter in original.lower()]) else False\n", "def is_anagram(test, original):\n\tt = list(test.lower())\n\tto = ''.join(sorted(t))\n\to = list(original.lower())\n\too = ''.join(sorted(o))\n\tif to == oo:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tletterCount = dict.fromkeys('abcdefghijklmnopqrstuvwxyz', 0)\n\tfor c in test.lower():\n\t\tletterCount[c] += 1\n\tfor c in original.lower():\n\t\tletterCount[c] -= 1\n\tfor value in list(letterCount.values()):\n\t\tif value != 0:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(a_str, b_str):\n\tif len(a_str) == len(b_str):\n\t\ta_list = list(a_str.lower())\n\t\tb_list = list(b_str.lower())\n\t\tfor char in a_list:\n\t\t\tif char in b_list:\n\t\t\t\tb_list.remove(char)\n\t\tif not b_list:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\telse:\n\t\ttest = test.lower()\n\t\toriginal = original.lower()\n\t\tcounter_original = [0] * 26\n\t\tcounter_test = [0] * 26\n\t\tfor i in test:\n\t\t\tcounter_test[ord(i) - 97] += 1\n\t\tfor i in original:\n\t\t\tcounter_original[ord(i) - 97] += 1\n\treturn counter_test == counter_original\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tnewList = [ord(c) for c in test]\n\tnewList.sort()\n\tnewList2 = [ord(b) for b in original]\n\tnewList2.sort()\n\tif newList == newList2:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tcounterTest = [0] * 255\n\tcounterOri = [0] * 255\n\tfor i in range(len(test)):\n\t\tcounterTest[ord(test[i].lower())] += 1\n\tfor i in range(len(original)):\n\t\tcounterOri[ord(original[i].lower())] += 1\n\tif counterOri == counterTest:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest = test.upper()\n\toriginal = original.upper()\n\tif sorted(test) == sorted(original):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tif len(test) == len(original):\n\t\ttest = test.lower()\n\t\toriginal = original.lower()\n\t\tfor i in test:\n\t\t\tif original.find(i) == -1:\n\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\ttest.replace(i, '')\n\t\t\t\toriginal.replace(i, '')\n\telse:\n\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tcounter1 = [0] * 255\n\tcounter2 = [0] * 255\n\tfor i in range(len(test)):\n\t\tcounter1[ord(test[i].lower())] += 1\n\tfor i in range(len(original)):\n\t\tcounter2[ord(original[i].lower())] += 1\n\treturn counter1 == counter2\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tfor x in range(len(test)):\n\t\tif test.count(test[x]) != original.count(test[x]):\n\t\t\treturn False\n\tfor x in range(len(original)):\n\t\tif test.count(original[x]) != original.count(original[x]):\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tnT = len(test)\n\tnO = len(original)\n\tif nO == nT:\n\t\tcounterT = [0] * (255 + 1)\n\t\tcounterO = [0] * (255 + 1)\n\t\tfor x in range(nT):\n\t\t\tcounterT[ord(test[x])] += 1\n\t\t\tcounterO[ord(original[x])] += 1\n\t\tif counterT == counterO:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tn = len(original)\n\tif n != len(test):\n\t\treturn False\n\tcounterTest = [0] * 255\n\tcounterOrig = [0] * 255\n\tfor i in range(n):\n\t\tcounterTest[ord(test[i].lower())] += 1\n\t\tcounterOrig[ord(original[i].lower())] += 1\n\treturn True if ''.join(map(str, counterTest)) == ''.join(map(str, counterOrig)) else False\n", "def is_anagram(test, original):\n\treturn sorted([n.lower() for n in test]) == sorted([n.lower() for n in original])\n", "def is_anagram(word_o, test_o):\n\tis_anagram = True\n\tword = word_o.lower()\n\ttest = test_o.lower()\n\tif len(word) != len(test):\n\t\tis_anagram = False\n\talist = list(test.lower())\n\tpos1 = 0\n\twhile pos1 < len(word) and is_anagram:\n\t\tpos2 = 0\n\t\tfound = False\n\t\twhile pos2 < len(alist) and (not found):\n\t\t\tif word[pos1] == alist[pos2]:\n\t\t\t\tfound = True\n\t\t\telse:\n\t\t\t\tpos2 = pos2 + 1\n\t\tif found:\n\t\t\talist[pos2] = None\n\t\telse:\n\t\t\tis_anagram = False\n\t\tpos1 = pos1 + 1\n\treturn is_anagram\n", "def is_anagram(test, original):\n\tl1 = list(test.lower())\n\tl2 = list(original.lower())\n\tif len(l1) == len(l2):\n\t\tfor i in l1:\n\t\t\tif i in l2:\n\t\t\t\tl2.remove(i)\n\t\t\telse:\n\t\t\t\treturn False\n\telse:\n\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tfor i in test.lower():\n\t\tif i in original.lower() and len(test) == len(original):\n\t\t\tcontinue\n\t\telse:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\ttest_list = [letter1 for letter1 in test.lower()]\n\torig_list = [letter2 for letter2 in original.lower()]\n\tif sorted(test_list) == sorted(orig_list):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tt = sorted(test.lower())\n\to = sorted(original.lower())\n\tif t == o:\n\t\tprint('true')\n\t\treturn True\n\telse:\n\t\tprint('false')\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest = [i.lower() for i in test]\n\toriginal = [j.lower() for j in original]\n\ttest.sort()\n\toriginal.sort()\n\treturn test == original\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tif len(test) != len(original):\n\t\treturn False\n\tfor x in test:\n\t\tif test.count(x) == original.count(x):\n\t\t\tcontinue\n\t\telse:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tnew_test = list(test)\n\tnew_original = list(original)\n\tnew_test.sort()\n\tnew_original.sort()\n\tif new_test == new_original:\n\t\treturn True\n\treturn False\n\tpass\n", "def is_anagram(test, original):\n\treturn set(test.upper()) == set(original.upper()) and len(test) == len(original)\n", "is_anagram = lambda test, original: True if sorted(original.lower()) == sorted(test.lower()) else False\n", "def is_anagram(test, original):\n\toriginalLower = [val for val in original.lower()]\n\tarr = test.lower()\n\tif len(arr) != len(originalLower):\n\t\treturn False\n\tfor element in arr:\n\t\tif element not in originalLower:\n\t\t\treturn False\n\t\telse:\n\t\t\toriginalLower.remove(element)\n\treturn True\n", "def is_anagram(test, original):\n\tn1 = len(test)\n\tn2 = len(original)\n\tif n1 != n2:\n\t\treturn False\n\tstr1 = sorted(test.lower())\n\tstr2 = sorted(original.lower())\n\tfor i in range(0, n1):\n\t\tif str1[i] != str2[i]:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\ttest_l = list(test.lower())\n\toriginal_l = list(original.lower())\n\ttest_l.sort()\n\toriginal_l.sort()\n\tif test_l == original_l:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest = list(test.lower())\n\toriginal = list(original.lower())\n\tif len(test) != len(original):\n\t\treturn False\n\tfor word in test:\n\t\tfor word2 in original:\n\t\t\tif word == word2:\n\t\t\t\toriginal.remove(word2)\n\t\t\t\tbreak\n\tif len(original) == 0:\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\ta = sorted(list(test.lower()))\n\tb = sorted(list(original.lower()))\n\tif a == b:\n\t\tprint(f'The word {test} is an anagram of {original}')\n\t\treturn True\n\telse:\n\t\tprint(f'Characters do not match for test case {test}, {original}')\n\t\treturn False\n", "def is_anagram(test, original):\n\n\tdef to_list(string):\n\t\tlisted = []\n\t\tfor i in range(len(string)):\n\t\t\tlisted.append(string[i])\n\t\treturn listed\n\treturn str(sorted(to_list(test.lower()))) == str(sorted(to_list(original.lower())))\n", "def is_anagram(test, original):\n\ttest = list(test.lower())\n\ttest.sort()\n\toriginal = list(original.lower())\n\toriginal.sort()\n\tif original != test or len(test) != len(original):\n\t\treturn False\n\telse:\n\t\treturn True\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\ttest = sorted(test.lower())\n\toriginal = sorted(original.lower())\n\tfor i in range(len(test)):\n\t\tif test[i] != original[i]:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tresult = True if len(test) == len(original) else False\n\tfor letter in test.upper():\n\t\tresult = False if letter not in original.upper() else result\n\treturn result\n", "def is_anagram(test, original):\n\tif len(original) != len(test):\n\t\treturn False\n\ttest = test.lower()\n\toriginal = original.lower()\n\tfor letter in original:\n\t\tif original.count(letter) != test.count(letter):\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tif sorted(test.lower()) == sorted(original.lower()):\n\t\treturn True\n\telif test != original:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest_list = sorted(list(test.lower()))\n\toriginal_list = sorted(list(original.lower()))\n\tif test_list == original_list:\n\t\treturn True\n\tif test_list != original_list:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttest = test.lower()\n\toriginal = original.lower()\n\tt = list(test)\n\to = list(original)\n\tt.sort()\n\to.sort()\n\treturn t == o\n", "def is_anagram(test, original):\n\tt = test.lower()\n\to = [*original.lower()]\n\tif len(t) != len(o):\n\t\treturn False\n\tfor c in t:\n\t\tif c in o:\n\t\t\to.remove(c)\n\t\telse:\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tif len(test) > len(original) or len(test) < len(original):\n\t\treturn False\n\tres = ''\n\tcounter = 0\n\tsortedTest = sorted(test.lower())\n\tsortedOriginal = sorted(original.lower())\n\tfor i in range(0, len(sortedTest)):\n\t\tif sortedTest[i] != sortedOriginal[i]:\n\t\t\tres = False\n\t\t\tbreak\n\t\telse:\n\t\t\tres = True\n\treturn res\n", "from collections import Counter as C\n\ndef is_anagram(test, original):\n\treturn C(test.lower()) == C(original.lower())\n", "def is_anagram(test, original):\n\tsort1 = sorted(test.lower())\n\tsort2 = sorted(original.lower())\n\tif ''.join(sort2) == ''.join(sort1):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\ttheTest = test.lower()\n\ttheOriginal = original.lower()\n\tif len(theTest) != len(theOriginal):\n\t\treturn False\n\telse:\n\t\tindex = 0\n\t\tlengthCheck = 0\n\t\tarray = [None] * len(theTest)\n\t\tfor i in theOriginal:\n\t\t\tarray[index] = i\n\t\t\tindex += 1\n\t\tfor j in theTest:\n\t\t\ttestLength = len(theTest)\n\t\t\tif j in array:\n\t\t\t\tlengthCheck += 1\n\t\t\telse:\n\t\t\t\treturn False\n\t\tif lengthCheck == testLength:\n\t\t\treturn True\n", "def is_anagram(tst, org):\n\ttst = tst.lower()\n\torg = org.lower()\n\tif len(tst) != len(org):\n\t\treturn False\n\tfor i in org:\n\t\tif tst.count(i) != org.count(i):\n\t\t\treturn False\n\treturn True\n", "def is_anagram(test, original):\n\tif len(test) != len(original):\n\t\treturn False\n\telif sorted(test.casefold()) == sorted(original.casefold()):\n\t\treturn True\n\telse:\n\t\treturn False\n", "def is_anagram(test, original):\n\tletters_original = sorted(list(original.upper()))\n\tletters_test = sorted(list(test.upper()))\n\treturn letters_original == letters_test\n", "def is_anagram(test, original):\n\treturn len(test) == len(original) and all([i in original.lower() for i in test.lower()])\n", "def is_anagram(test, original):\n\torg1 = [x.lower() for x in original]\n\torg2 = [y.lower() for y in test]\n\torg1.sort()\n\torg2.sort()\n\tif org1 == org2:\n\t\treturn True\n\treturn False\n", "def is_anagram(test, original):\n\toriginal_list = list(original.lower())\n\ttest_list = list(test.lower())\n\toriginal_list.sort()\n\ttest_list.sort()\n\ta = ''.join(test_list)\n\tb = ''.join(original_list)\n\treturn a == b\n", "def is_anagram(test, original):\n\ttest = test.lower().replace(' ', '')\n\toriginal = original.lower().replace(' ', '')\n\tif len(test) != len(original):\n\t\treturn False\n\tfor letter in test:\n\t\tif letter not in original:\n\t\t\treturn False\n\tfor letter in original:\n\t\tif letter not in test:\n\t\t\treturn False\n\treturn True\n"], "starter_code": "def is_anagram(test, original):\n\t", "input_output": {"fn_name": "is_anagram", "inputs": [["foefet", "toffee"], ["Buckethead", "DeathCubeK"], ["Twoo", "WooT"], ["dumble", "bumble"], ["ound", "round"], ["apple", "pale"]], "outputs": [[true], [true], [true], [false], [false], [false]]}, "difficulty": "EASY", "raw_tags": ["Strings", "Fundamentals"], "name": null, "source": "codewars", "tags": ["String algorithms", "Fundamentals"], "skill_types": [], "url": "https://www.codewars.com/kata/529eef7a9194e0cbc1000255", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null}
{"question": "Given a string 's'. The task is to find the smallest window length that contains all the characters of the given string at least one time.\n\nYour Task:  \nYou don't need to read input or print anything. Your task is to complete the function `findSubString()` which takes the string `S` as input and returns the length of the smallest such window of the string.\nExpected Time Complexity: O(256.N)  \nExpected Auxiliary Space: O(256)\n\nConstraints:\n- 1 ≤ |S| ≤ 10⁵\n- String may contain both types of English Alphabets.", "solutions": ["class Solution:\n\n\tdef findSubString(self, str):\n\t\tdict = {}\n\t\tans = float('inf')\n\t\tj = 0\n\t\tfor i in str:\n\t\t\tif i not in dict:\n\t\t\t\tdict[i] = 0\n\t\tlength = len(dict)\n\t\tfor i in range(len(str)):\n\t\t\tdict[str[i]] += 1\n\t\t\tif dict[str[i]] == 1:\n\t\t\t\tlength -= 1\n\t\t\twhile length == 0:\n\t\t\t\tans = min(ans, i - j + 1)\n\t\t\t\tdict[str[j]] -= 1\n\t\t\t\tif dict[str[j]] == 0:\n\t\t\t\t\tlength += 1\n\t\t\t\tj += 1\n\t\treturn ans\n", "from collections import defaultdict\n\nclass Solution:\n\n\tdef findSubString(self, s):\n\t\tn = len(s)\n\t\tdist_count = len(set([x for x in s]))\n\t\tm = defaultdict(int)\n\t\tstart = 0\n\t\tmin_len = float('inf')\n\t\tcount = 0\n\t\tfor j in range(n):\n\t\t\tm[s[j]] += 1\n\t\t\tif m[s[j]] == 1:\n\t\t\t\tcount += 1\n\t\t\tif count == dist_count:\n\t\t\t\twhile m[s[start]] > 1:\n\t\t\t\t\tif m[s[start]] > 1:\n\t\t\t\t\t\tm[s[start]] -= 1\n\t\t\t\t\tstart += 1\n\t\t\t\tlen_window = j - start + 1\n\t\t\t\tif min_len > len_window:\n\t\t\t\t\tmin_len = len_window\n\t\treturn min_len\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tfrom collections import defaultdict\n\t\tn = len(str)\n\t\tif n <= 1:\n\t\t\treturn 1\n\t\tdist_count = len(set([x for x in str]))\n\t\tcurr_count = defaultdict(lambda : 0)\n\t\tcount = 0\n\t\tstart = 0\n\t\tmin_len = n\n\t\tfor j in range(n):\n\t\t\tcurr_count[str[j]] += 1\n\t\t\tif curr_count[str[j]] == 1:\n\t\t\t\tcount += 1\n\t\t\tif count == dist_count:\n\t\t\t\twhile curr_count[str[start]] > 1:\n\t\t\t\t\tif curr_count[str[start]] > 1:\n\t\t\t\t\t\tcurr_count[str[start]] -= 1\n\t\t\t\t\tstart += 1\n\t\t\t\tlen_window = j - start + 1\n\t\t\t\tmin_len = min(min_len, len_window)\n\t\t\t\tstart_index = start\n\t\treturn min_len\n", "class Solution:\n\n\tdef findSubString(self, s):\n\t\tD = {}\n\t\tfor i in s:\n\t\t\tif i in D:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tD[i] = 1\n\t\tn = len(s)\n\t\t(i, j) = (0, 0)\n\t\tcount = len(D)\n\t\tmini = 9999\n\t\twhile j < n:\n\t\t\tif s[j] in D:\n\t\t\t\tD[s[j]] -= 1\n\t\t\t\tif D[s[j]] == 0:\n\t\t\t\t\tcount -= 1\n\t\t\twhile count == 0:\n\t\t\t\tmini = min(mini, j - i + 1)\n\t\t\t\tif s[i] in D:\n\t\t\t\t\tD[s[i]] += 1\n\t\t\t\t\tif D[s[i]] > 0:\n\t\t\t\t\t\tcount += 1\n\t\t\t\ti += 1\n\t\t\tj += 1\n\t\treturn mini\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tmp = {}\n\t\tcnt = 0\n\t\tfor i in range(len(str)):\n\t\t\tif str[i] not in mp:\n\t\t\t\tmp[str[i]] = 0\n\t\t\t\tcnt += 1\n\t\tcnt1 = 0\n\t\tj = 0\n\t\tmn = len(str)\n\t\tfor i in range(len(str)):\n\t\t\tif mp[str[i]] == 0:\n\t\t\t\tmp[str[i]] += 1\n\t\t\t\tcnt1 += 1\n\t\t\telse:\n\t\t\t\tmp[str[i]] += 1\n\t\t\twhile cnt == cnt1:\n\t\t\t\tmn = min(mn, i - j + 1)\n\t\t\t\tif mp[str[j]] == 1:\n\t\t\t\t\tmp[str[j]] -= 1\n\t\t\t\t\tcnt1 -= 1\n\t\t\t\t\tj = j + 1\n\t\t\t\telse:\n\t\t\t\t\tmp[str[j]] -= 1\n\t\t\t\t\tj = j + 1\n\t\treturn mn\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tdict = {}\n\t\ta = 1000000000.0\n\t\tj = 0\n\t\tfor i in str:\n\t\t\tif i not in dict:\n\t\t\t\tdict[i] = 0\n\t\tl = len(dict)\n\t\tfor i in range(len(str)):\n\t\t\tdict[str[i]] += 1\n\t\t\tif dict[str[i]] == 1:\n\t\t\t\tl -= 1\n\t\t\twhile l == 0:\n\t\t\t\ta = min(a, i - j + 1)\n\t\t\t\tdict[str[j]] -= 1\n\t\t\t\tif dict[str[j]] == 0:\n\t\t\t\t\tl += 1\n\t\t\t\tj += 1\n\t\treturn a\n", "class Solution:\n\n\tdef findSubString(self, s):\n\t\tdistinct = len(set(s))\n\t\td = dict()\n\t\tsi = -1\n\t\tLen = 100000.0\n\t\tstart = 0\n\t\tfor i in range(len(s)):\n\t\t\tif s[i] not in d:\n\t\t\t\td[s[i]] = 1\n\t\t\telse:\n\t\t\t\td[s[i]] += 1\n\t\t\tif len(d) == distinct:\n\t\t\t\twhile d[s[start]] > 1:\n\t\t\t\t\td[s[start]] -= 1\n\t\t\t\t\tstart += 1\n\t\t\t\tclen = i - start + 1\n\t\t\t\tif Len > clen:\n\t\t\t\t\tLen = clen\n\t\t\t\t\tsi = start\n\t\treturn len(s[si:si + Len])\n", "from collections import defaultdict\n\nclass Solution:\n\n\tdef findSubString(self, str):\n\t\tleng = len(str)\n\t\t(start, end) = (0, leng - 1)\n\t\tct = 0\n\t\tt_dist = len(set([e for e in str]))\n\t\tchr_map = defaultdict(lambda : 0)\n\t\tmin_wind = leng\n\t\tfor i in range(leng):\n\t\t\tx = str[i]\n\t\t\tchr_map[x] += 1\n\t\t\tif chr_map[x] == 1:\n\t\t\t\tct += 1\n\t\t\tif ct == t_dist:\n\t\t\t\twhile chr_map[str[start]] > 1:\n\t\t\t\t\tchr_map[str[start]] -= 1\n\t\t\t\t\tstart += 1\n\t\t\t\tmin_wind = min(i - start + 1, min_wind)\n\t\treturn min_wind\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tn = len(str)\n\t\t(dic, vic) = ({}, {})\n\t\tfor a in str:\n\t\t\tif a not in dic:\n\t\t\t\tdic[a] = 0\n\t\t\tdic[a] += 1\n\t\t(i, j, ans) = (0, 0, 10000000000)\n\t\twhile j < n:\n\t\t\tif str[j] not in vic:\n\t\t\t\tvic[str[j]] = 0\n\t\t\tvic[str[j]] += 1\n\t\t\tif len(vic) == len(dic):\n\t\t\t\twhile len(vic) == len(dic):\n\t\t\t\t\tvic[str[i]] -= 1\n\t\t\t\t\tif vic[str[i]] == 0:\n\t\t\t\t\t\tdel vic[str[i]]\n\t\t\t\t\ti += 1\n\t\t\t\tans = min(ans, 2 + j - i)\n\t\t\tj += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tdict = {}\n\t\tans = 1000000000.0\n\t\tfor i in str:\n\t\t\tif i not in dict:\n\t\t\t\tdict[i] = 0\n\t\tlength = len(dict)\n\t\tcount = 0\n\t\tj = 0\n\t\tfor i in range(len(str)):\n\t\t\tdict[str[i]] += 1\n\t\t\tif dict[str[i]] == 1:\n\t\t\t\tcount += 1\n\t\t\twhile count == length:\n\t\t\t\tans = min(ans, i - j + 1)\n\t\t\t\tdict[str[j]] -= 1\n\t\t\t\tif dict[str[j]] == 0:\n\t\t\t\t\tcount -= 1\n\t\t\t\tj += 1\n\t\treturn ans\n", "from collections import Counter\n\nclass Solution:\n\n\tdef findSubString(self, str1):\n\t\tlength = len(str1)\n\t\tdict1 = Counter(str1)\n\t\tk = len(dict1)\n\t\tdict2 = dict()\n\t\tcount = 0\n\t\tstart = 0\n\t\tminimum = 99999\n\t\tfor i in range(length):\n\t\t\tif count < k:\n\t\t\t\tj = start\n\t\t\t\twhile j < length:\n\t\t\t\t\tif str1[j] not in dict2:\n\t\t\t\t\t\tdict2[str1[j]] = 1\n\t\t\t\t\t\tcount += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tdict2[str1[j]] += 1\n\t\t\t\t\tif count == k:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tj += 1\n\t\t\tif count == k:\n\t\t\t\tminimum = min(minimum, j - i + 1)\n\t\t\t\tstart = j + 1\n\t\t\tdict2[str1[i]] -= 1\n\t\t\tif dict2[str1[i]] == 0:\n\t\t\t\tdict2.pop(str1[i])\n\t\t\t\tcount -= 1\n\t\treturn minimum\n", "from collections import Counter, defaultdict\n\nclass Solution:\n\n\tdef findSubString(self, str_):\n\t\tset_of_string = set()\n\t\tlen_set_of_string = len(set(str_))\n\t\tanswer = float('inf')\n\t\tleft = 0\n\t\tright = 0\n\t\tfreq = defaultdict(int)\n\t\twhile right < len(str_):\n\t\t\tfreq[str_[right]] += 1\n\t\t\twhile left <= right and len(freq) == len_set_of_string:\n\t\t\t\tanswer = min(answer, right - left + 1)\n\t\t\t\tfreq[str_[left]] -= 1\n\t\t\t\tif freq[str_[left]] == 0:\n\t\t\t\t\tdel freq[str_[left]]\n\t\t\t\tleft += 1\n\t\t\tright += 1\n\t\treturn answer\n", "class Solution:\n\n\tdef findSubString(self, a):\n\t\tdict = {}\n\t\tn = len(set(a))\n\t\tleft = 0\n\t\tright = 0\n\t\tans = len(a)\n\t\twhile right < len(a):\n\t\t\tif a[right] not in dict:\n\t\t\t\tdict[a[right]] = 1\n\t\t\telse:\n\t\t\t\tdict[a[right]] += 1\n\t\t\tif len(dict) == n:\n\t\t\t\twhile dict[a[left]] > 1:\n\t\t\t\t\tdict[a[left]] -= 1\n\t\t\t\t\tleft += 1\n\t\t\t\tans = min(ans, right - left + 1)\n\t\t\tright += 1\n\t\treturn ans\n", "import math\n\nclass Solution:\n\n\tdef findSubString(self, s):\n\t\tdicti = {}\n\t\tmini = math.inf\n\t\tk = len(set(s))\n\t\tn = len(s)\n\t\t(i, j) = (0, 0)\n\t\twhile j < n:\n\t\t\tif s[j] not in dicti:\n\t\t\t\tdicti[s[j]] = 1\n\t\t\telse:\n\t\t\t\tdicti[s[j]] += 1\n\t\t\tif len(dicti) < k:\n\t\t\t\tj += 1\n\t\t\telif len(dicti) == k:\n\t\t\t\twhile len(dicti) == k:\n\t\t\t\t\tmini = min(mini, j - i + 1)\n\t\t\t\t\tif s[i] in dicti:\n\t\t\t\t\t\tdicti[s[i]] -= 1\n\t\t\t\t\t\tif dicti[s[i]] == 0:\n\t\t\t\t\t\t\tdel dicti[s[i]]\n\t\t\t\t\ti += 1\n\t\t\t\tj += 1\n\t\treturn mini\n", "from collections import defaultdict\n\nclass Solution:\n\n\tdef findSubString(self, arr):\n\t\tdic = defaultdict(lambda : 0)\n\t\ti = 0\n\t\tj = 0\n\t\tn = len(set(arr))\n\t\tans = len(arr)\n\t\twhile j < len(arr):\n\t\t\tdic[arr[j]] += 1\n\t\t\tif len(dic) < n:\n\t\t\t\tj += 1\n\t\t\tif len(dic) == n:\n\t\t\t\twhile dic[arr[i]] > 1:\n\t\t\t\t\tdic[arr[i]] -= 1\n\t\t\t\t\ti += 1\n\t\t\t\tans = min(ans, j - i + 1)\n\t\t\t\tj += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\td = {}\n\t\tfor i in str:\n\t\t\td[i] = 0\n\t\ti = 0\n\t\tj = 0\n\t\tans = len(str)\n\t\tcount = len(d)\n\t\ttemp = 0\n\t\twhile j < len(str):\n\t\t\twhile temp < count and j < len(str):\n\t\t\t\tif d[str[j]] == 0:\n\t\t\t\t\ttemp += 1\n\t\t\t\td[str[j]] += 1\n\t\t\t\tj += 1\n\t\t\twhile temp >= count:\n\t\t\t\td[str[i]] -= 1\n\t\t\t\tif d[str[i]] == 0:\n\t\t\t\t\ttemp -= 1\n\t\t\t\ti += 1\n\t\t\tans = min(ans, j - i + 1)\n\t\treturn ans\n", "from collections import deque\n\nclass Solution:\n\n\tdef findSubString(self, stre):\n\t\ts = set(stre)\n\t\tset_len = len(s)\n\t\tj = 0\n\t\tminlen = 1000000000.0\n\t\tmp = {}\n\t\tn = len(stre)\n\t\tfor i in range(n):\n\t\t\tif stre[i] not in mp:\n\t\t\t\tmp[stre[i]] = 1\n\t\t\telse:\n\t\t\t\tmp[stre[i]] += 1\n\t\t\twhile j <= i and len(mp) == set_len:\n\t\t\t\tif minlen > i - j + 1:\n\t\t\t\t\tminlen = i - j + 1\n\t\t\t\tmp[stre[j]] -= 1\n\t\t\t\tif mp[stre[j]] == 0:\n\t\t\t\t\tdel mp[stre[j]]\n\t\t\t\tj += 1\n\t\treturn minlen\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tm = {}\n\t\tn = len(set(str))\n\t\tlength = float('inf')\n\t\tj = 0\n\t\tfor i in range(len(str)):\n\t\t\tm[str[i]] = m.get(str[i], 0) + 1\n\t\t\tif len(m) == n:\n\t\t\t\twhile m[str[j]] > 1:\n\t\t\t\t\tm[str[j]] -= 1\n\t\t\t\t\tj += 1\n\t\t\t\tlength = min(length, i - j + 1)\n\t\treturn length\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tdict = {}\n\t\tans = 1000000000.0\n\t\tfor i in str:\n\t\t\tif i not in dict:\n\t\t\t\tdict[i] = 1\n\t\tdict2 = {}\n\t\tj = 0\n\t\tfor i in range(len(str)):\n\t\t\tif str[i] not in dict2:\n\t\t\t\tdict2[str[i]] = 1\n\t\t\telse:\n\t\t\t\tdict2[str[i]] += 1\n\t\t\twhile len(dict) == len(dict2):\n\t\t\t\tans = min(ans, i - j + 1)\n\t\t\t\tif dict2[str[j]] > 1:\n\t\t\t\t\tdict2[str[j]] -= 1\n\t\t\t\telif dict2[str[j]] == 1:\n\t\t\t\t\tdict2.pop(str[j])\n\t\t\t\tj += 1\n\t\treturn ans\n", "from collections import defaultdict\n\nclass Solution:\n\n\tdef findSubString(self, s):\n\t\ta = set(s)\n\t\ti = 0\n\t\tt = {}\n\t\tmin_len = float('inf')\n\t\tfor j in range(len(s)):\n\t\t\tif s[j] not in t:\n\t\t\t\tt[s[j]] = 0\n\t\t\tt[s[j]] += 1\n\t\t\twhile len(t) == len(a):\n\t\t\t\tmin_len = min(min_len, j - i + 1)\n\t\t\t\tt[s[i]] -= 1\n\t\t\t\tif t[s[i]] == 0:\n\t\t\t\t\tdel t[s[i]]\n\t\t\t\ti += 1\n\t\treturn min_len\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tfrom collections import defaultdict\n\t\tcurr_count = defaultdict(lambda : 0)\n\t\tdist_count = len(set([x for x in str]))\n\t\tif len(str) <= 1:\n\t\t\treturn 1\n\t\tcounter = 0\n\t\tstart = 0\n\t\tmin_len = len(str)\n\t\tfor i in range(len(str)):\n\t\t\tcurr_count[str[i]] += 1\n\t\t\tif curr_count[str[i]] == 1:\n\t\t\t\tcounter += 1\n\t\t\tif counter == dist_count:\n\t\t\t\twhile curr_count[str[start]] > 1:\n\t\t\t\t\tif curr_count[str[start]] > 1:\n\t\t\t\t\t\tcurr_count[str[start]] -= 1\n\t\t\t\t\tstart += 1\n\t\t\t\twindow_len = i - start + 1\n\t\t\t\tif window_len < min_len:\n\t\t\t\t\tmin_len = window_len\n\t\t\t\t\tstart_index = start\n\t\ta = min_len\n\t\treturn a\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\td = {}\n\t\tfor i in str:\n\t\t\tif i not in d:\n\t\t\t\td[i] = 0\n\t\t(i, j) = (0, float('inf'))\n\t\t(count, out) = (0, float('inf'))\n\t\tfor j in range(len(str)):\n\t\t\tif d[str[j]] == 0:\n\t\t\t\tcount += 1\n\t\t\td[str[j]] += 1\n\t\t\tif count == len(d):\n\t\t\t\twhile i < j:\n\t\t\t\t\td[str[i]] -= 1\n\t\t\t\t\tif d[str[i]] == 0:\n\t\t\t\t\t\tout = min(out, j - i + 1)\n\t\t\t\t\t\tcount -= 1\n\t\t\t\t\t\ti += 1\n\t\t\t\t\t\tbreak\n\t\t\t\t\ti += 1\n\t\treturn out if out != float('inf') else 1\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tk = len(set(str))\n\t\tmemo = {}\n\t\tans = len(str)\n\t\t(i, j) = (0, 0)\n\t\twhile j < len(str):\n\t\t\tmemo[str[j]] = memo.get(str[j], 0) + 1\n\t\t\tif len(memo) < k:\n\t\t\t\tj += 1\n\t\t\telif len(memo) == k:\n\t\t\t\twhile len(memo) == k:\n\t\t\t\t\tmemo[str[i]] -= 1\n\t\t\t\t\tif memo[str[i]] == 0:\n\t\t\t\t\t\tdel memo[str[i]]\n\t\t\t\t\ti += 1\n\t\t\t\tans = min(ans, j - i + 2)\n\t\t\t\tj += 1\n\t\t\telif len(memo) > k:\n\t\t\t\twhile len(memo) > k:\n\t\t\t\t\tmemo[str[i]] -= 1\n\t\t\t\t\tif memo[str[i]] == 0:\n\t\t\t\t\t\tdel memo[str[i]]\n\t\t\t\t\ti += 1\n\t\t\t\tj += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tres = 100000\n\t\td = {}\n\t\tfor i in range(len(str)):\n\t\t\tif str[i] not in d:\n\t\t\t\td[str[i]] = 0\n\t\ts1 = set()\n\t\tcount = len(d)\n\t\tl = 0\n\t\tfor i in range(len(str)):\n\t\t\ts1.add(str[i])\n\t\t\td[str[i]] = d[str[i]] + 1\n\t\t\twhile count == len(s1) and d[str[l]] != 0:\n\t\t\t\td[str[l]] = d[str[l]] - 1\n\t\t\t\tif d[str[l]] == 0:\n\t\t\t\t\ts1.remove(str[l])\n\t\t\t\t\tres = min(res, i - l + 1)\n\t\t\t\tl = l + 1\n\t\treturn res\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tans = len(str)\n\t\tN = len(str)\n\t\tn = len(set(str))\n\t\t(i, j) = (0, 0)\n\t\td = {}\n\t\twhile i < N:\n\t\t\tif str[i] not in d:\n\t\t\t\td[str[i]] = 1\n\t\t\telse:\n\t\t\t\td[str[i]] += 1\n\t\t\tif len(d) == n:\n\t\t\t\twhile d[str[j]] > 1:\n\t\t\t\t\td[str[j]] -= 1\n\t\t\t\t\tj += 1\n\t\t\t\tans = min(ans, i - j + 1)\n\t\t\ti += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, s):\n\t\tfreq = {}\n\t\tfor c in s:\n\t\t\tfreq[c] = 0\n\t\tunique_chars = len(freq)\n\t\tleft = 0\n\t\tright = 0\n\t\tcount = 0\n\t\tmin_length = float('inf')\n\t\twhile right < len(s):\n\t\t\tif s[right] in freq:\n\t\t\t\tfreq[s[right]] += 1\n\t\t\t\tif freq[s[right]] == 1:\n\t\t\t\t\tcount += 1\n\t\t\tright += 1\n\t\t\twhile count == unique_chars:\n\t\t\t\tif right - left < min_length:\n\t\t\t\t\tmin_length = right - left\n\t\t\t\tif s[left] in freq:\n\t\t\t\t\tfreq[s[left]] -= 1\n\t\t\t\t\tif freq[s[left]] == 0:\n\t\t\t\t\t\tcount -= 1\n\t\t\t\tleft += 1\n\t\treturn min_length\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\td = {}\n\t\tfor i in str:\n\t\t\tif i not in d:\n\t\t\t\td[i] = 0\n\t\tx = len(d)\n\t\tans = 999999\n\t\ti = 0\n\t\tj = 0\n\t\tc = 0\n\t\twhile i < len(str):\n\t\t\tif d[str[i]] == 0:\n\t\t\t\tc += 1\n\t\t\td[str[i]] += 1\n\t\t\tif c == x:\n\t\t\t\tf = True\n\t\t\t\twhile c == x:\n\t\t\t\t\tans = min(ans, i - j + 1)\n\t\t\t\t\td[str[j]] -= 1\n\t\t\t\t\tif d[str[j]] == 0:\n\t\t\t\t\t\tc -= 1\n\t\t\t\t\tj += 1\n\t\t\ti += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\treslen = len(str)\n\t\ts = set()\n\t\td = dict()\n\t\tfor i in range(len(str)):\n\t\t\ts.add(str[i])\n\t\ti = 0\n\t\tcount = 0\n\t\tfor j in range(len(str)):\n\t\t\td[str[j]] = d.get(str[j], 0) + 1\n\t\t\tif d[str[j]] == 1:\n\t\t\t\tcount += 1\n\t\t\tif count == len(s):\n\t\t\t\twhile d[str[i]] > 1:\n\t\t\t\t\tif d[str[i]] > 1:\n\t\t\t\t\t\td[str[i]] -= 1\n\t\t\t\t\ti += 1\n\t\t\t\tif reslen > j - i + 1:\n\t\t\t\t\treslen = j - i + 1\n\t\treturn reslen\n", "from collections import defaultdict\n\nclass Solution:\n\n\tdef findSubString(self, strr):\n\t\tn = len(strr)\n\t\tdist_count = len(set([x for x in strr]))\n\t\tif n == dist_count:\n\t\t\treturn n\n\t\tcurr_count = dict()\n\t\tcount = 0\n\t\tstart = 0\n\t\tmin_len = n\n\t\tfor i in range(n):\n\t\t\tcurr_count[strr[i]] = curr_count.get(strr[i], 0) + 1\n\t\t\tif curr_count[strr[i]] == 1:\n\t\t\t\tcount += 1\n\t\t\tif count == dist_count:\n\t\t\t\twhile curr_count[strr[start]] > 1:\n\t\t\t\t\tif curr_count[strr[start]] > 1:\n\t\t\t\t\t\tcurr_count[strr[start]] -= 1\n\t\t\t\t\tstart += 1\n\t\t\t\tif min_len > i - start + 1:\n\t\t\t\t\tmin_len = i - start + 1\n\t\treturn min_len\n", "class Solution:\n\n\tdef findSubString(self, s):\n\t\tn = len(s)\n\t\tres = n\n\t\ti = 0\n\t\tuniq = set(list(s))\n\t\tfound = {}\n\t\tfor j in range(n):\n\t\t\tif s[j] in found:\n\t\t\t\tfound[s[j]] += 1\n\t\t\telse:\n\t\t\t\tfound[s[j]] = 1\n\t\t\twhile i < j:\n\t\t\t\tif found[s[i]] > 1:\n\t\t\t\t\tfound[s[i]] -= 1\n\t\t\t\t\ti += 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tif len(found) == len(uniq):\n\t\t\t\tres = min(res, j - i + 1)\n\t\treturn res\n", "from collections import defaultdict\n\nclass Solution:\n\n\tdef findSubString(self, s):\n\t\tn = len(s)\n\t\tif n <= 1:\n\t\t\treturn len(s)\n\t\tdis_char = len(set(list(s)))\n\t\tcurr = defaultdict(lambda : 0)\n\t\tcnt = 0\n\t\tminlen = n\n\t\tstart = 0\n\t\tfor j in range(n):\n\t\t\tcurr[s[j]] += 1\n\t\t\tif curr[s[j]] == 1:\n\t\t\t\tcnt += 1\n\t\t\tif cnt == dis_char:\n\t\t\t\twhile curr[s[start]] > 1:\n\t\t\t\t\tcurr[s[start]] -= 1\n\t\t\t\t\tstart += 1\n\t\t\t\tlength = j - start + 1\n\t\t\t\tif length < minlen:\n\t\t\t\t\tminlen = length\n\t\t\t\t\tstartind = start\n\t\treturn minlen\n", "class Solution:\n\n\tdef findSubString(self, S):\n\t\tdistinct_chars = set(S)\n\t\tn = len(S)\n\t\tleft = 0\n\t\tmin_length = n\n\t\tcount = [0] * 256\n\t\tdistinct = 0\n\t\tfor right in range(n):\n\t\t\tcount[ord(S[right])] += 1\n\t\t\tif count[ord(S[right])] == 1:\n\t\t\t\tdistinct += 1\n\t\t\tif distinct == len(distinct_chars):\n\t\t\t\twhile count[ord(S[left])] > 1:\n\t\t\t\t\tcount[ord(S[left])] -= 1\n\t\t\t\t\tleft += 1\n\t\t\t\tmin_length = min(min_length, right - left + 1)\n\t\t\t\tcount[ord(S[left])] -= 1\n\t\t\t\tleft += 1\n\t\t\t\tdistinct -= 1\n\t\treturn min_length\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tmaxi = len(str)\n\t\tsets = set(str)\n\t\ti = 0\n\t\tj = 0\n\t\tm = {}\n\t\twhile i < len(str):\n\t\t\tm[str[i]] = 1 + m.get(str[i], 0)\n\t\t\tif len(m) >= len(sets):\n\t\t\t\twhile m[str[j]] > 1:\n\t\t\t\t\tm[str[j]] -= 1\n\t\t\t\t\tj += 1\n\t\t\t\tmaxi = min(maxi, i - j + 1)\n\t\t\ti += 1\n\t\treturn maxi\n", "class Solution:\n\n\tdef findSubString(self, input_string):\n\t\tstart = 0\n\t\tend = 1\n\t\talphabet_dict = {}\n\t\tdistinct_list = list(set(input_string))\n\t\tfor i in range(0, len(distinct_list)):\n\t\t\talphabet_dict[distinct_list[i]] = 0\n\t\tn = len(distinct_list)\n\t\tcount = 1\n\t\talphabet_dict[input_string[0]] = 1\n\t\tanswer = len(input_string)\n\t\twhile start <= end < len(input_string):\n\t\t\tif count < n:\n\t\t\t\telement = input_string[end]\n\t\t\t\tif alphabet_dict[element] == 0:\n\t\t\t\t\talphabet_dict[element] = 1\n\t\t\t\t\tcount = count + 1\n\t\t\t\telse:\n\t\t\t\t\talphabet_dict[element] = alphabet_dict[element] + 1\n\t\t\t\tend = end + 1\n\t\t\telif count == n:\n\t\t\t\tanswer = min(answer, end - start)\n\t\t\t\telement = input_string[start]\n\t\t\t\tif element in alphabet_dict and alphabet_dict[element] == 1:\n\t\t\t\t\tcount = count - 1\n\t\t\t\talphabet_dict[element] = alphabet_dict[element] - 1\n\t\t\t\tstart = start + 1\n\t\twhile count == n:\n\t\t\tanswer = min(answer, end - start)\n\t\t\telement = input_string[start]\n\t\t\tif element in alphabet_dict and alphabet_dict[element] == 1:\n\t\t\t\tcount = count - 1\n\t\t\talphabet_dict[element] = alphabet_dict[element] - 1\n\t\t\tstart = start + 1\n\t\treturn answer\n", "from collections import Counter\n\nclass Solution:\n\n\tdef findSubString(self, str):\n\t\tdic1 = Counter(str)\n\t\tdic2 = dict()\n\t\t(i, j) = (0, 0)\n\t\tres = 10000000000\n\t\twhile j < len(str):\n\t\t\tif str[j] in dic2:\n\t\t\t\tdic2[str[j]] += 1\n\t\t\telse:\n\t\t\t\tdic2[str[j]] = 1\n\t\t\tif len(dic1) == len(dic2):\n\t\t\t\twhile len(dic1) == len(dic2):\n\t\t\t\t\tres = min(res, j - i + 1)\n\t\t\t\t\tdic2[str[i]] -= 1\n\t\t\t\t\tif dic2[str[i]] == 0:\n\t\t\t\t\t\tdel dic2[str[i]]\n\t\t\t\t\ti += 1\n\t\t\tj += 1\n\t\treturn res\n", "import math\n\nclass Solution:\n\n\tdef findSubString(self, s):\n\t\tfreq = {}\n\t\tfor c in s:\n\t\t\tfreq[c] = 0\n\t\t(b, d, ans) = (0, 0, math.inf)\n\t\tfor (i, c) in enumerate(s):\n\t\t\twhile d == len(freq.keys()):\n\t\t\t\tfreq[s[b]] -= 1\n\t\t\t\tif freq[s[b]] == 0:\n\t\t\t\t\tans = min(ans, i - b)\n\t\t\t\t\td -= 1\n\t\t\t\tb += 1\n\t\t\tfreq[c] += 1\n\t\t\tif freq[c] == 1:\n\t\t\t\td += 1\n\t\twhile d == len(freq.keys()):\n\t\t\tfreq[s[b]] -= 1\n\t\t\tif freq[s[b]] == 0:\n\t\t\t\tans = min(ans, i - b + 1)\n\t\t\t\td -= 1\n\t\t\tb += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tn = len(str)\n\t\tans = 0\n\t\tlength = n\n\t\ts = list(set(str))\n\t\td = dict()\n\t\tcount = 0\n\t\tstart = 0\n\t\tfor i in range(n):\n\t\t\tif str[i] not in d.keys():\n\t\t\t\td[str[i]] = 1\n\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\td[str[i]] += 1\n\t\t\tif count == len(s):\n\t\t\t\twhile d[str[start]] > 1:\n\t\t\t\t\td[str[start]] -= 1\n\t\t\t\t\tstart += 1\n\t\t\t\tans = i - start + 1\n\t\t\t\tif length > ans:\n\t\t\t\t\tlength = ans\n\t\treturn length\n", "from collections import defaultdict\n\nclass Solution:\n\n\tdef findSubString(self, s):\n\t\tcontrol = set(s)\n\t\tm = len(control)\n\t\tn = len(s)\n\t\ttest = defaultdict(lambda : 0)\n\t\tmini = float('inf')\n\t\ti = 0\n\t\tfor j in range(n):\n\t\t\twhile len(test) < m and i < n:\n\t\t\t\ttest[s[i]] += 1\n\t\t\t\ti += 1\n\t\t\tif len(test) < m:\n\t\t\t\tbreak\n\t\t\tmini = min(mini, i - j)\n\t\t\ttest[s[j]] -= 1\n\t\t\tif test[s[j]] == 0:\n\t\t\t\tdel test[s[j]]\n\t\treturn mini\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\ti = 0\n\t\tj = 0\n\t\ts = len(set(str))\n\t\tn = len(str)\n\t\tans = n\n\t\tdic = {}\n\t\twhile i < n:\n\t\t\tif str[i] not in dic:\n\t\t\t\tdic[str[i]] = 1\n\t\t\telse:\n\t\t\t\tdic[str[i]] += 1\n\t\t\tif len(dic) == s:\n\t\t\t\twhile dic[str[j]] > 1:\n\t\t\t\t\tdic[str[j]] -= 1\n\t\t\t\t\tj += 1\n\t\t\t\tans = min(ans, i - j + 1)\n\t\t\ti += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, s):\n\t\tn = len(s)\n\t\tdistinct_chars = len(set(s))\n\t\tfreq = [0] * 256\n\t\tleft = 0\n\t\tright = 0\n\t\tcount = 0\n\t\tmin_len = n\n\t\twhile right < n:\n\t\t\tch = ord(s[right])\n\t\t\tif freq[ch] == 0:\n\t\t\t\tcount += 1\n\t\t\tfreq[ch] += 1\n\t\t\tright += 1\n\t\t\twhile count == distinct_chars:\n\t\t\t\tmin_len = min(min_len, right - left)\n\t\t\t\tch = ord(s[left])\n\t\t\t\tfreq[ch] -= 1\n\t\t\t\tif freq[ch] == 0:\n\t\t\t\t\tcount -= 1\n\t\t\t\tleft += 1\n\t\treturn min_len\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tnd = len(set(str))\n\t\ti = 0\n\t\tj = 0\n\t\tres = len(str)\n\t\tdic = {}\n\t\twhile i < len(str):\n\t\t\tif str[i] in dic:\n\t\t\t\tdic[str[i]] = dic[str[i]] + 1\n\t\t\telse:\n\t\t\t\tdic[str[i]] = 1\n\t\t\tif len(dic) == nd:\n\t\t\t\twhile dic[str[j]] > 1:\n\t\t\t\t\tdic[str[j]] = dic[str[j]] - 1\n\t\t\t\t\tj = j + 1\n\t\t\t\tres = min(res, i - j + 1)\n\t\t\ti = i + 1\n\t\treturn res\n", "from collections import Counter\n\nclass Solution:\n\n\tdef findSubString(self, str1):\n\t\tdict1 = dict()\n\t\tcount = 0\n\t\tdistinct = len(Counter(str1))\n\t\tn = len(str1)\n\t\tj = 0\n\t\tminimum = n\n\t\tfor i in range(n):\n\t\t\tif count < distinct:\n\t\t\t\twhile j < n:\n\t\t\t\t\tif str1[j] not in dict1:\n\t\t\t\t\t\tdict1[str1[j]] = 1\n\t\t\t\t\t\tcount += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tdict1[str1[j]] += 1\n\t\t\t\t\tif count == distinct:\n\t\t\t\t\t\tj += 1\n\t\t\t\t\t\tbreak\n\t\t\t\t\tj += 1\n\t\t\tif count == distinct:\n\t\t\t\tminimum = min(minimum, j - i)\n\t\t\tdict1[str1[i]] -= 1\n\t\t\tif dict1[str1[i]] == 0:\n\t\t\t\tdict1.pop(str1[i])\n\t\t\t\tcount -= 1\n\t\treturn minimum\n", "class Solution:\n\n\tdef findSubString(self, a):\n\t\ts = ''\n\t\ta1 = {}\n\t\tfor i in a:\n\t\t\ta1[i] = 1\n\t\tc1 = len(a1)\n\t\ti = 0\n\t\tj = 0\n\t\ta2 = {}\n\t\tc = 0\n\t\tres = len(a)\n\t\twhile j < len(a):\n\t\t\tif a[j] not in a2:\n\t\t\t\ta2[a[j]] = 0\n\t\t\t\tc += 1\n\t\t\ta2[a[j]] += 1\n\t\t\twhile i <= j and c == c1:\n\t\t\t\tres = min(res, j - i + 1)\n\t\t\t\ta2[a[i]] -= 1\n\t\t\t\tif a2[a[i]] == 0:\n\t\t\t\t\tdel a2[a[i]]\n\t\t\t\t\tc -= 1\n\t\t\t\ti += 1\n\t\t\tj += 1\n\t\treturn res\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tans_len = len(set(str))\n\t\td = {}\n\t\tws = 0\n\t\tans = 10 ** 6\n\t\tfor we in range(0, len(str)):\n\t\t\td[str[we]] = d.get(str[we], 0) + 1\n\t\t\tif len(d) == ans_len:\n\t\t\t\twhile d[str[ws]] > 1:\n\t\t\t\t\td[str[ws]] -= 1\n\t\t\t\t\tws += 1\n\t\t\t\tans = min(ans, we - ws + 1)\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tunique = set(str)\n\t\tres = len(str)\n\t\tj = 0\n\t\tmap = dict()\n\t\tfor i in range(0, len(str)):\n\t\t\tif str[i] in map.keys():\n\t\t\t\tmap[str[i]] += 1\n\t\t\telse:\n\t\t\t\tmap[str[i]] = 1\n\t\t\tif len(unique) == len(map):\n\t\t\t\twhile map[str[j]] > 1:\n\t\t\t\t\tmap[str[j]] -= 1\n\t\t\t\t\tj += 1\n\t\t\t\tres = min(res, i - j + 1)\n\t\treturn res\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tl = len(str)\n\t\ts = set()\n\t\tfor i in range(len(str)):\n\t\t\ts.add(str[i])\n\t\tn = len(s)\n\t\thead = 0\n\t\ttail = 0\n\t\thmap = {}\n\t\tans = l\n\t\twhile head < l:\n\t\t\tif str[head] in hmap:\n\t\t\t\thmap[str[head]] += 1\n\t\t\telse:\n\t\t\t\thmap[str[head]] = 1\n\t\t\tif len(hmap) == n:\n\t\t\t\twhile hmap[str[tail]] > 1:\n\t\t\t\t\thmap[str[tail]] -= 1\n\t\t\t\t\ttail += 1\n\t\t\t\tans = min(ans, head - tail + 1)\n\t\t\thead += 1\n\t\treturn ans\n", "from collections import defaultdict, Counter\nfrom sys import maxsize\n\nclass Solution:\n\n\tdef findSubString(self, str):\n\t\tcnt = Counter(str)\n\t\tcur = defaultdict(int)\n\t\tk = 0\n\t\tans = maxsize\n\t\ti = 0\n\t\tfor (j, ch) in enumerate(str):\n\t\t\tcur[ch] += 1\n\t\t\tif cur[ch] == 1:\n\t\t\t\tk += 1\n\t\t\tif k == len(cnt):\n\t\t\t\twhile i < j:\n\t\t\t\t\tif cur[str[i]] == 1:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcur[str[i]] -= 1\n\t\t\t\t\ti += 1\n\t\t\t\tans = min(ans, j - i + 1)\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tres = float('inf')\n\t\t(i, j) = (0, 0)\n\t\tmaxLen = len(set(list(str)))\n\t\thashmap = {}\n\t\twhile j < len(str):\n\t\t\tif str[j] not in hashmap:\n\t\t\t\thashmap[str[j]] = 1\n\t\t\telse:\n\t\t\t\thashmap[str[j]] += 1\n\t\t\tj += 1\n\t\t\tif len(hashmap) == maxLen:\n\t\t\t\twhile i < j and hashmap[str[i]] > 1:\n\t\t\t\t\thashmap[str[i]] -= 1\n\t\t\t\t\ti += 1\n\t\t\t\tres = min(res, j - i)\n\t\treturn res\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\td = {}\n\t\tfor ch in str:\n\t\t\tif ch not in d:\n\t\t\t\td[ch] = 1\n\t\tn = len(d)\n\t\td.clear()\n\t\ti = 0\n\t\tj = 0\n\t\tcount = 0\n\t\tmini = len(str)\n\t\twhile j < len(str):\n\t\t\tif str[j] not in d:\n\t\t\t\td[str[j]] = 1\n\t\t\t\tcount = count + 1\n\t\t\telse:\n\t\t\t\td[str[j]] = d[str[j]] + 1\n\t\t\tif count == n:\n\t\t\t\twhile d[str[i]] != 1:\n\t\t\t\t\td[str[i]] = d[str[i]] - 1\n\t\t\t\t\ti = i + 1\n\t\t\t\tmini = min(mini, j - i + 1)\n\t\t\tj = j + 1\n\t\treturn mini\n", "class Solution:\n\n\tdef findSubString(self, s):\n\t\tn = len(s)\n\t\td = {}\n\t\tcount = 0\n\t\tfor i in range(n):\n\t\t\td[s[i]] = 0\n\t\ti = 0\n\t\tj = 0\n\t\tans = n\n\t\twhile i < n:\n\t\t\tif d[s[i]] == 0:\n\t\t\t\tcount += 1\n\t\t\td[s[i]] += 1\n\t\t\tif count == len(d):\n\t\t\t\twhile j < n and d[s[j]] > 1:\n\t\t\t\t\td[s[j]] -= 1\n\t\t\t\t\tj += 1\n\t\t\t\tif ans > i - j + 1:\n\t\t\t\t\tans = i - j + 1\n\t\t\ti += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tp = len(set(str))\n\t\tj = 0\n\t\ti = 0\n\t\td = {}\n\t\tmn = 100000\n\t\twhile j < len(str):\n\t\t\tif str[j] in d:\n\t\t\t\td[str[j]] += 1\n\t\t\telse:\n\t\t\t\td[str[j]] = 1\n\t\t\tif len(d) == p:\n\t\t\t\twhile len(d) == p:\n\t\t\t\t\tmn = min(mn, j - i + 1)\n\t\t\t\t\td[str[i]] -= 1\n\t\t\t\t\tif d[str[i]] == 0:\n\t\t\t\t\t\tdel d[str[i]]\n\t\t\t\t\ti += 1\n\t\t\tj += 1\n\t\treturn mn\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\td = {}\n\t\ti = 0\n\t\tj = 0\n\t\tsw = 100000000\n\t\tn = len(set(str))\n\t\twhile j < len(str):\n\t\t\tif str[j] not in d:\n\t\t\t\td[str[j]] = 1\n\t\t\telse:\n\t\t\t\td[str[j]] += 1\n\t\t\tif len(d) == n:\n\t\t\t\twhile len(d) == n:\n\t\t\t\t\tsw = min(sw, j - i + 1)\n\t\t\t\t\td[str[i]] -= 1\n\t\t\t\t\tif d[str[i]] == 0:\n\t\t\t\t\t\tdel d[str[i]]\n\t\t\t\t\ti += 1\n\t\t\tj += 1\n\t\treturn sw\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\tdict = {}\n\t\tfor i in str:\n\t\t\tif i in dict:\n\t\t\t\tdict[i] += 1\n\t\t\telse:\n\t\t\t\tdict[i] = 1\n\t\tcount = len(list(dict.keys()))\n\t\ti = j = 0\n\t\tans = len(str)\n\t\tc = 0\n\t\tdict = {}\n\t\tfor i in range(len(str)):\n\t\t\tif str[i] in dict:\n\t\t\t\tdict[str[i]] += 1\n\t\t\telse:\n\t\t\t\tdict[str[i]] = 1\n\t\t\t\tc += 1\n\t\t\tif c == count:\n\t\t\t\tans = min(ans, i - j + 1)\n\t\t\t\twhile c == count and j <= i:\n\t\t\t\t\tdict[str[j]] -= 1\n\t\t\t\t\tif dict[str[j]] == 0:\n\t\t\t\t\t\tdel dict[str[j]]\n\t\t\t\t\t\tc -= 1\n\t\t\t\t\tans = min(ans, i - j + 1)\n\t\t\t\t\tj += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef findSubString(self, str):\n\t\ts = set(str)\n\t\tn = len(s)\n\t\tss = set()\n\t\tind = 0\n\t\td = {}\n\t\tmini = 10 ** 9\n\t\tfor i in range(len(str)):\n\t\t\tif str[i] not in ss:\n\t\t\t\tss.add(str[i])\n\t\t\td[str[i]] = d.get(str[i], 0) + 1\n\t\t\tif len(ss) == n:\n\t\t\t\tind = i + 1\n\t\t\t\tmini = min(mini, i + 1)\n\t\t\t\tbreak\n\t\tindex = 0\n\t\twhile d[str[index]] > 1:\n\t\t\td[str[index]] -= 1\n\t\t\tindex += 1\n\t\t\tmini = min(mini, i - index + 1)\n\t\tfor i in range(ind, len(str)):\n\t\t\td[str[i]] = d.get(str[i], 0) + 1\n\t\t\twhile d[str[index]] > 1:\n\t\t\t\td[str[index]] -= 1\n\t\t\t\tindex += 1\n\t\t\t\tmini = min(mini, i - index + 1)\n\t\twhile d[str[index]] > 1:\n\t\t\td[str[index]] -= 1\n\t\t\tindex += 1\n\t\t\tmini = min(mini, i - index + 1)\n\t\treturn mini\n"], "starter_code": "#User function Template for python3\n\n\n\nclass Solution:\n\n    def findSubString(self, str):\n\n        # Your code goes here\n\n    \n\n    \n\n    ", "input_output": {"inputs": ["\"AABBBCBBAC\"", "\"aaab\"", "\"GEEKSGEEKSFOR\""], "outputs": ["3", "2", "8"]}, "difficulty": "MEDIUM", "raw_tags": ["Algorithms", "Hash", "sliding-window", "Strings", "Data Structures", "Arrays"], "name": null, "source": "geeksforgeeks", "tags": ["String algorithms", "Data structures", "Amortized analysis"], "skill_types": ["Amortized analysis", "Data structures"], "url": "https://practice.geeksforgeeks.org/problems/smallest-distant-window3132/1", "Expected Auxiliary Space": "O(256)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(256.N)"}
{"question": "Given an array `arr[]` which contains data of `N` nodes of a Complete Binary tree in level order fashion. The task is to print the level order traversal in sorted order.\n\n**Your Task:**\nYou don't need to read input or print anything. Your task is to complete the function `binTreeSortedLevels()` which takes the array `arr[]` and its size `N` as inputs and returns a 2D array where the i-th array denotes the nodes of the i-th level in sorted order.\n\n**Expected Time Complexity:** O(NlogN).\n\n**Expected Auxiliary Space:** O(N).\n\n**Constraints:**\n- 1 <= N <= 10<sup>4</sup>", "solutions": ["class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tli = []\n\t\ti = 0\n\t\tlevel = 0\n\t\twhile i < n:\n\t\t\tdumm = []\n\t\t\tif level == 0:\n\t\t\t\tli.append([arr[i]])\n\t\t\t\ti += 1\n\t\t\t\tlevel += 1\n\t\t\telse:\n\t\t\t\tsize = 2 ** level\n\t\t\t\tif i + size < n:\n\t\t\t\t\tdumm.extend(arr[i:i + size])\n\t\t\t\t\tdumm.sort()\n\t\t\t\t\tli.append(dumm)\n\t\t\t\t\ti += size\n\t\t\t\t\tlevel += 1\n\t\t\t\telse:\n\t\t\t\t\tdumm.extend(arr[i:])\n\t\t\t\t\tdumm.sort()\n\t\t\t\t\tli.append(dumm)\n\t\t\t\t\tbreak\n\t\treturn li\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tans = []\n\t\tm = 1\n\t\tlevel = []\n\t\tj = 0\n\t\tfor i in range(n):\n\t\t\tif j < m:\n\t\t\t\tlevel.append(arr[i])\n\t\t\t\tj += 1\n\t\t\telse:\n\t\t\t\tlevel.sort()\n\t\t\t\tans.append(level.copy())\n\t\t\t\tlevel.clear()\n\t\t\t\tm += m\n\t\t\t\tj = 1\n\t\t\t\tlevel.append(arr[i])\n\t\tlevel.sort()\n\t\tans.append(level)\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tres = []\n\t\ti = 0\n\t\tls = 1\n\t\twhile i < n:\n\t\t\tt = (1 << ls) - 1\n\t\t\tt = min(t, n)\n\t\t\ttemp = sorted(arr[i:t])\n\t\t\ti = t\n\t\t\tls += 1\n\t\t\tres.append(temp)\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tres = []\n\t\t(i, total) = (0, 0)\n\t\twhile total < n:\n\t\t\ttemp = []\n\t\t\tfor j in range(2 ** i):\n\t\t\t\tif total < n:\n\t\t\t\t\ttemp.append(arr[total])\n\t\t\t\t\ttotal += 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\ttemp.sort()\n\t\t\tres.append(temp)\n\t\t\ti += 1\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tn = len(arr)\n\t\tlist2 = [[arr[0]]]\n\t\tc = 0\n\t\tj = 1\n\t\tlist3 = []\n\t\tfor x in range(1, n):\n\t\t\tif c == 2 ** j - 1:\n\t\t\t\tlist3.append(arr[x])\n\t\t\t\tlist3.sort()\n\t\t\t\tlist2.append(list3)\n\t\t\t\tlist3 = []\n\t\t\t\tj += 1\n\t\t\t\tc = 0\n\t\t\telse:\n\t\t\t\tlist3.append(arr[x])\n\t\t\t\tc += 1\n\t\tif len(list3) != 0:\n\t\t\tlist3.sort()\n\t\t\tlist2.append(list3)\n\t\treturn list2\n", "from collections import deque\n\nclass Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tdq = deque()\n\t\tdq.append(0)\n\t\tres = []\n\t\twhile len(dq) > 0:\n\t\t\tcurrsize = len(dq)\n\t\t\tt = []\n\t\t\tfor i in range(currsize):\n\t\t\t\ttemp = dq.popleft()\n\t\t\t\tt.append(arr[temp])\n\t\t\t\tif 2 * temp + 1 < n:\n\t\t\t\t\tdq.append(2 * temp + 1)\n\t\t\t\tif 2 * temp + 2 < n:\n\t\t\t\t\tdq.append(2 * temp + 2)\n\t\t\tt.sort()\n\t\t\tres.append(t)\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tfinal = []\n\t\tl = [1]\n\t\tfinal.append([arr[0]])\n\t\ti = 0\n\t\twhile True:\n\t\t\tli = len(l)\n\t\t\tl = []\n\t\t\tfor j in range(li):\n\t\t\t\tif 2 * i + 1 < n:\n\t\t\t\t\tl.append(arr[2 * i + 1])\n\t\t\t\tif 2 * i + 2 < n:\n\t\t\t\t\tl.append(arr[2 * i + 2])\n\t\t\t\ti += 1\n\t\t\tif len(l):\n\t\t\t\tfinal.append(sorted(l))\n\t\t\telse:\n\t\t\t\tbreak\n\t\treturn final\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\toutput = []\n\t\ti = 0\n\t\twhile 2 ** i <= n:\n\t\t\tj = 2 ** i\n\t\t\tk = 2 ** (i + 1)\n\t\t\ti += 1\n\t\t\toutput.append(sorted(arr[j - 1:k - 1]))\n\t\treturn output\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\ta1 = {}\n\t\tqueue = [0]\n\t\tqueue1 = [0]\n\t\twhile len(queue) > 0:\n\t\t\tx = queue.pop(0)\n\t\t\ty = queue1.pop(0)\n\t\t\tif y not in a1:\n\t\t\t\ta1[y] = []\n\t\t\ta1[y].append(arr[x])\n\t\t\tif 2 * x + 1 < len(arr):\n\t\t\t\tqueue.append(2 * x + 1)\n\t\t\t\tqueue1.append(y + 1)\n\t\t\tif 2 * x + 2 < len(arr):\n\t\t\t\tqueue.append(2 * x + 2)\n\t\t\t\tqueue1.append(y + 1)\n\t\te = []\n\t\tfor i in range(max(a1) + 1):\n\t\t\te.append(sorted(a1[i]))\n\t\treturn e\n", "from collections import deque\nfrom sortedcontainers import SortedList\n\nclass Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tq = deque([0])\n\t\tres = []\n\t\twhile q:\n\t\t\tt = SortedList()\n\t\t\tfor _ in range(len(q)):\n\t\t\t\tcur = q.popleft()\n\t\t\t\tt.add(arr[cur])\n\t\t\t\tfor i in [2 * cur + 1, 2 * cur + 2]:\n\t\t\t\t\tif i < len(arr):\n\t\t\t\t\t\tq.append(i)\n\t\t\tres.append(t)\n\t\treturn res\n", "from collections import deque\nfrom heapq import heappush, heappop\n\nclass Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tq = deque([0])\n\t\tres = []\n\t\twhile q:\n\t\t\thp = []\n\t\t\tfor _ in range(len(q)):\n\t\t\t\tcur = q.popleft()\n\t\t\t\theappush(hp, arr[cur])\n\t\t\t\tfor i in [2 * cur + 1, 2 * cur + 2]:\n\t\t\t\t\tif i < len(arr):\n\t\t\t\t\t\tq.append(i)\n\t\t\tt = []\n\t\t\twhile hp:\n\t\t\t\tt.append(heappop(hp))\n\t\t\tres.append(t)\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\t(res, start, end, len1) = ([], 0, 1, 1)\n\t\twhile start < n:\n\t\t\tres.append(sorted(arr[start:end]))\n\t\t\tlen1 *= 2\n\t\t\tstart = end\n\t\t\tend = start + len1\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\ti = 1\n\t\tans = []\n\t\twhile len(arr):\n\t\t\tans.append(sorted(arr[:i]))\n\t\t\tarr = arr[i:]\n\t\t\ti <<= 1\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\ti = 0\n\t\tk = 1\n\t\tres = []\n\t\twhile i < n:\n\t\t\ttemp = arr[i:i + k]\n\t\t\ttemp.sort()\n\t\t\tres.append(temp)\n\t\t\ti += k\n\t\t\tk *= 2\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\t_list = []\n\t\ta = 1\n\t\tcurr = 0\n\t\twhile curr < n:\n\t\t\t_list.append(sorted(arr[curr:curr + a]))\n\t\t\tcurr += a\n\t\t\ta *= 2\n\t\treturn _list\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tif n == 1:\n\t\t\treturn [[arr[0]]]\n\t\telse:\n\t\t\tl = [[arr[0]]]\n\t\t\ti = 1\n\t\t\tc = 1\n\t\t\twhile i < n:\n\t\t\t\tsize = 2 ** c\n\t\t\t\tif i + size < n:\n\t\t\t\t\ta = arr[i:i + size]\n\t\t\t\t\ta.sort()\n\t\t\t\t\tl.append(a)\n\t\t\t\t\ti += size\n\t\t\t\t\tc += 1\n\t\t\t\telse:\n\t\t\t\t\ta = arr[i:]\n\t\t\t\t\ta.sort()\n\t\t\t\t\tl.append(a)\n\t\t\t\t\tbreak\n\t\t\treturn l\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tstart = 0\n\t\ti = 0\n\t\tincrement = 2 ** i\n\t\tlist1 = []\n\t\twhile start < n:\n\t\t\tlist1.append(sorted(arr[start:start + increment]))\n\t\t\tstart += increment\n\t\t\ti += 1\n\t\t\tincrement = 2 ** i\n\t\treturn list1\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tres = []\n\t\ti = 0\n\t\tcount = 0\n\t\tlevel = 0\n\t\twhile True:\n\t\t\tcount = 2 ** level\n\t\t\tt = []\n\t\t\twhile count != 0 and i < n:\n\t\t\t\tt.append(arr[i])\n\t\t\t\ti += 1\n\t\t\t\tcount -= 1\n\t\t\tres.append(sorted(t))\n\t\t\tif i >= n:\n\t\t\t\tbreak\n\t\t\tlevel += 1\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tres = []\n\t\tl = 0\n\t\ti = 0\n\t\twhile True:\n\t\t\tcount = int(2 ** l)\n\t\t\ttmp = []\n\t\t\twhile count != 0 and i < n:\n\t\t\t\ttmp.append(arr[i])\n\t\t\t\ti += 1\n\t\t\t\tcount -= 1\n\t\t\tres.append(sorted(tmp))\n\t\t\tif i >= n:\n\t\t\t\tbreak\n\t\t\tl += 1\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\ti = 0\n\t\ta = []\n\t\twhile 2 ** i <= n:\n\t\t\ta.append(sorted(arr[:2 ** i]))\n\t\t\tarr[:] = arr[2 ** i:]\n\t\t\ti = i + 1\n\t\treturn a\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tans = []\n\t\ti = 0\n\t\tlevel = 0\n\t\twhile True:\n\t\t\tcount = int(2 ** level)\n\t\t\ttmp = []\n\t\t\twhile count != 0 and i < n:\n\t\t\t\ttmp.append(arr[i])\n\t\t\t\ti += 1\n\t\t\t\tcount -= 1\n\t\t\tans.append(sorted(tmp))\n\t\t\tif i >= n:\n\t\t\t\tbreak\n\t\t\tlevel += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tfrom math import exp\n\t\tlevel = 0\n\t\tprevLevelEnd = 0\n\t\tout = []\n\t\twhile prevLevelEnd < n:\n\t\t\tnAtLevel = pow(2, level)\n\t\t\tout.append(list(sorted(arr[prevLevelEnd:prevLevelEnd + nAtLevel])))\n\t\t\tprevLevelEnd += nAtLevel\n\t\t\tlevel += 1\n\t\treturn out\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tre = []\n\t\tlevel = 0\n\t\ti = 0\n\t\twhile i < n:\n\t\t\tans = []\n\t\t\tif level == 0:\n\t\t\t\tre.append([arr[i]])\n\t\t\t\ti += 1\n\t\t\t\tlevel += 1\n\t\t\telse:\n\t\t\t\tsize = 2 ** level\n\t\t\t\tif i + size < n:\n\t\t\t\t\tans.extend(arr[i:i + size])\n\t\t\t\t\tans.sort()\n\t\t\t\t\tre.append(ans)\n\t\t\t\t\ti += size\n\t\t\t\t\tlevel += 1\n\t\t\t\telse:\n\t\t\t\t\tans.extend(arr[i:])\n\t\t\t\t\tans.sort()\n\t\t\t\t\tre.append(ans)\n\t\t\t\t\tbreak\n\t\treturn re\n", "import heapq\n\nclass Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tlst = []\n\t\tx = 0\n\t\ty = 1\n\t\twhile True:\n\t\t\tll = []\n\t\t\tfor j in range(x, min(x + y, n)):\n\t\t\t\tll.append(arr[j])\n\t\t\tlst.append(sorted(ll))\n\t\t\tx = x + y\n\t\t\ty = 2 * y\n\t\t\tif x >= n:\n\t\t\t\tbreak\n\t\treturn lst\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, x, n):\n\t\tres = []\n\t\ti = 0\n\t\tj = 1\n\t\twhile i < n:\n\t\t\tres.append(sorted(x[i:i + j]))\n\t\t\ti = i + j\n\t\t\tj = j * 2\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tans = []\n\t\tsi = 0\n\t\tk = 0\n\t\twhile si < n:\n\t\t\tsize = 2 ** k\n\t\t\tk += 1\n\t\t\tif si + size >= n:\n\t\t\t\ttans = arr[si:]\n\t\t\telse:\n\t\t\t\ttans = arr[si:si + size]\n\t\t\ttans.sort()\n\t\t\tans.append(tans)\n\t\t\tsi += size\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tlst = []\n\t\tlevel = 0\n\t\ti = 0\n\t\twhile i < n:\n\t\t\tl = []\n\t\t\tif level == 0:\n\t\t\t\tl.append(arr[i])\n\t\t\t\tlst.append(l)\n\t\t\t\ti = i + 1\n\t\t\t\tlevel = level + 1\n\t\t\telse:\n\t\t\t\tsize = 2 ** level\n\t\t\t\tif i + size < n:\n\t\t\t\t\tl.extend(arr[i:i + size])\n\t\t\t\t\tl.sort()\n\t\t\t\t\tlst.append(l)\n\t\t\t\t\ti = i + size\n\t\t\t\t\tlevel = level + 1\n\t\t\t\telse:\n\t\t\t\t\tl.extend(arr[i:])\n\t\t\t\t\tl.sort()\n\t\t\t\t\tlst.append(l)\n\t\t\t\t\tbreak\n\t\treturn lst\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\ta = [[arr[0]]]\n\t\ti = 1\n\t\twhile i < n:\n\t\t\tb = arr[i:2 * i + 1]\n\t\t\tb.sort()\n\t\t\ta.append(b)\n\t\t\ti = 2 * i + 1\n\t\treturn a\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tc = 0\n\t\ti = 0\n\t\tans = []\n\t\twhile c < n:\n\t\t\tl = []\n\t\t\tx = pow(2, i)\n\t\t\twhile x > 0 and c < n:\n\t\t\t\tl.append(arr[c])\n\t\t\t\tc += 1\n\t\t\t\tx -= 1\n\t\t\ti += 1\n\t\t\tl.sort()\n\t\t\tans.append(l)\n\t\treturn ans\n", "from collections import deque\n\nclass Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tlqc = deque()\n\t\tlqc.append(0)\n\t\tlqn = deque()\n\t\tlsrl = deque()\n\t\trslt = deque()\n\t\twhile len(lqc) > 0:\n\t\t\tidx = lqc.popleft()\n\t\t\tlsrl.append(arr[idx])\n\t\t\tif 2 * idx + 1 < n:\n\t\t\t\tlqn.append(2 * idx + 1)\n\t\t\tif 2 * idx + 2 < n:\n\t\t\t\tlqn.append(2 * idx + 2)\n\t\t\tif len(lqc) == 0:\n\t\t\t\tlqc = lqn.copy()\n\t\t\t\tlqn = deque()\n\t\t\t\tlsrl = list(lsrl)\n\t\t\t\tlsrl.sort()\n\t\t\t\trslt.append(lsrl)\n\t\t\t\tlsrl = deque()\n\t\treturn rslt\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tmm = 0\n\t\tx = 0\n\t\tb = []\n\t\tif n == 1:\n\t\t\treturn [arr]\n\t\t\texit()\n\t\twhile x < n:\n\t\t\te = 2 ** mm\n\t\t\tt = []\n\t\t\tfor k in range(e):\n\t\t\t\tif x < n:\n\t\t\t\t\tt.append(arr[x])\n\t\t\t\tx = x + 1\n\t\t\tt.sort()\n\t\t\tmm = mm + 1\n\t\t\tb.append(t)\n\t\treturn b\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\ti = 0\n\t\tc = 0\n\t\tb = []\n\t\twhile i < n:\n\t\t\te = 2 ** c\n\t\t\tk = []\n\t\t\tfor j in range(e):\n\t\t\t\tif i < n:\n\t\t\t\t\tk.append(arr[i])\n\t\t\t\ti += 1\n\t\t\tk.sort()\n\t\t\tc += 1\n\t\t\tb.append(k)\n\t\treturn b\nt = int(input())\nfor tc in range(t):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tob = Solution()\n\tres = ob.binTreeSortedLevels(arr, n)\n\tfor i in range(len(res)):\n\t\tfor j in range(len(res[i])):\n\t\t\tprint(res[i][j], end=' ')\n\t\tprint()\n", "import heapq\n\nclass Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tif len(arr) == 1:\n\t\t\ttemp = []\n\t\t\ttemp.append([arr[0]])\n\t\t\treturn temp\n\t\tif len(arr) == 2:\n\t\t\ttemp = []\n\t\t\ttemp.append([arr[0]])\n\t\t\ttemp.append([arr[1]])\n\t\t\treturn temp\n\t\tq1 = []\n\t\tindex = 0\n\t\tans = []\n\t\tq1.append([arr[0], 0])\n\t\tq2 = []\n\t\tflag = 1\n\t\twhile True:\n\t\t\ttemp = []\n\t\t\tif flag == 1:\n\t\t\t\theapq.heapify(q1)\n\t\t\t\twhile q1:\n\t\t\t\t\tp = heapq.heappop(q1)\n\t\t\t\t\ttemp.append(p[0])\n\t\t\t\t\tif p[1] * 2 + 1 < n:\n\t\t\t\t\t\tq2.append([arr[p[1] * 2 + 1], p[1] * 2 + 1])\n\t\t\t\t\tif p[1] * 2 + 2 < n:\n\t\t\t\t\t\tq2.append([arr[p[1] * 2 + 2], p[1] * 2 + 2])\n\t\t\t\tflag = 0\n\t\t\t\tans.append(temp)\n\t\t\t\tif len(q2) == 0:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\theapq.heapify(q2)\n\t\t\t\twhile q2:\n\t\t\t\t\tp = heapq.heappop(q2)\n\t\t\t\t\ttemp.append(p[0])\n\t\t\t\t\tif p[1] * 2 + 1 < n:\n\t\t\t\t\t\tq1.append([arr[p[1] * 2 + 1], p[1] * 2 + 1])\n\t\t\t\t\tif p[1] * 2 + 2 < n:\n\t\t\t\t\t\tq1.append([arr[p[1] * 2 + 2], p[1] * 2 + 2])\n\t\t\t\tans.append(temp)\n\t\t\t\tflag = 1\n\t\t\t\tif len(q1) == 0:\n\t\t\t\t\tbreak\n\t\treturn ans\nt = int(input())\nfor tc in range(t):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tob = Solution()\n\tres = ob.binTreeSortedLevels(arr, n)\n\tfor i in range(len(res)):\n\t\tfor j in range(len(res[i])):\n\t\t\tprint(res[i][j], end=' ')\n\t\tprint()\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\ta = []\n\t\ti = p = 0\n\t\twhile i < len(arr):\n\t\t\ta.append(sorted(arr[i:i + 2 ** p]))\n\t\t\ti += 2 ** p\n\t\t\tp += 1\n\t\treturn a\nt = int(input())\nfor tc in range(t):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tob = Solution()\n\tres = ob.binTreeSortedLevels(arr, n)\n\tfor i in range(len(res)):\n\t\tfor j in range(len(res[i])):\n\t\t\tprint(res[i][j], end=' ')\n\t\tprint()\n", "from collections import defaultdict\nimport queue\n\nclass Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tq = queue.deque()\n\t\tdic = defaultdict(list)\n\t\tq.append([arr[0], 0, 0])\n\t\twhile q:\n\t\t\tele = q.popleft()\n\t\t\tdic[ele[1]].append(ele[0])\n\t\t\tval = 2 * ele[2]\n\t\t\tif val + 1 < n:\n\t\t\t\tq.append([arr[val + 1], ele[1] + 1, val + 1])\n\t\t\tif val + 2 < n:\n\t\t\t\tq.append([arr[val + 2], ele[1] + 1, val + 2])\n\t\tfor i in dic:\n\t\t\tdic[i].sort()\n\t\treturn dic\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tl = 0\n\t\tel = 1\n\t\tr = l + el\n\t\tans = []\n\t\twhile r <= len(arr):\n\t\t\tbrr = arr[l:r]\n\t\t\tbrr.sort()\n\t\t\tans.append(brr)\n\t\t\tel *= 2\n\t\t\tif r < len(arr):\n\t\t\t\tl = r\n\t\t\t\tif l + el <= len(arr):\n\t\t\t\t\tr = l + el\n\t\t\t\telse:\n\t\t\t\t\tr = len(arr)\n\t\t\telif r == len(arr):\n\t\t\t\tbreak\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tif not arr:\n\t\t\treturn\n\t\tres = [[arr[0]]]\n\t\tlevel = 1\n\t\ti = 1\n\t\tl = len(arr)\n\t\twhile i < l:\n\t\t\ttmp = []\n\t\t\tj = 0\n\t\t\twhile i < l and j < 2 ** level:\n\t\t\t\ttmp.append(arr[i])\n\t\t\t\ti += 1\n\t\t\t\tj += 1\n\t\t\tlevel += 1\n\t\t\ttmp.sort()\n\t\t\tres.append(tmp)\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tind = 0\n\t\tans = []\n\t\tq = [arr[ind]]\n\t\twhile q:\n\t\t\tb = sorted(q)\n\t\t\tans.append(b)\n\t\t\tnn = len(q)\n\t\t\tfor i in range(nn):\n\t\t\t\tp = q.pop(0)\n\t\t\t\tif ind + 1 < n:\n\t\t\t\t\tq.append(arr[ind + 1])\n\t\t\t\tif ind + 2 < n:\n\t\t\t\t\tq.append(arr[ind + 2])\n\t\t\t\tind += 2\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tlvl = -1\n\t\tans = []\n\t\twhile len(arr) > 0:\n\t\t\tlvl += 1\n\t\t\ts = pow(2, lvl)\n\t\t\tif s > len(arr):\n\t\t\t\ts = len(arr)\n\t\t\tarr[0:s].sort()\n\t\t\tans.append([])\n\t\t\twhile s > 0:\n\t\t\t\tans[lvl].append(arr.pop(0))\n\t\t\t\ts -= 1\n\t\t\tfor i in range(lvl + 1):\n\t\t\t\tans[i].sort()\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tj = 0\n\t\tl = []\n\t\twhile j < n:\n\t\t\ti = 2 * j + 1\n\t\t\tl1 = arr[j:i]\n\t\t\tl1.sort()\n\t\t\tl.append(l1)\n\t\t\tj = i\n\t\treturn l\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tc = 0\n\t\tp = 0\n\t\tl = []\n\t\twhile p < n:\n\t\t\ts = 2 ** c\n\t\t\tk = arr[p:p + s]\n\t\t\tc = c + 1\n\t\t\tp = p + s\n\t\t\tk.sort()\n\t\t\tl.append(k)\n\t\treturn l\n", "from collections import deque\n\nclass Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\t(i, j, k) = (0, 0, 0)\n\t\tans = []\n\t\twhile j < n:\n\t\t\tst = []\n\t\t\ti = 2 ** k\n\t\t\twhile i > 0 and j < n:\n\t\t\t\tst.append(arr[j])\n\t\t\t\tj += 1\n\t\t\t\ti -= 1\n\t\t\tans.append(sorted(st))\n\t\t\tk += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, l, n):\n\t\tstart = 0\n\t\tend = 0\n\t\tcount = 0\n\t\tresult_list = []\n\t\twhile True:\n\t\t\tend = 2 ** count\n\t\t\tif end > len(l):\n\t\t\t\tbreak\n\t\t\tresult_list.append(sorted(l[start:end + start]))\n\t\t\tcount += 1\n\t\t\tstart += end\n\t\treturn result_list\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tans = []\n\t\tif n == 0:\n\t\t\treturn ans\n\t\tsize = 1\n\t\tstart = 0\n\t\twhile True:\n\t\t\tif start + size > n:\n\t\t\t\tlevel = arr[start:n]\n\t\t\t\tif level:\n\t\t\t\t\tans.append(sorted(level))\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tlevel = arr[start:start + size]\n\t\t\t\tans.append(sorted(level))\n\t\t\t\tstart += size\n\t\t\t\tsize *= 2\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tif n == 0:\n\t\t\treturn []\n\t\tans = [[arr[0]]]\n\t\tl = 0\n\t\tr = 1\n\t\twhile r < n:\n\t\t\tl = min(l * 2 + 1, n - 1)\n\t\t\tr = min(r * 2 + 1, n)\n\t\t\tans.append(sorted(arr[l:r]))\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tcurr = 1\n\t\ti = 0\n\t\tj = 0\n\t\tfinal_ans = []\n\t\tans = []\n\t\twhile i < n:\n\t\t\tans.append(arr[i])\n\t\t\ti += 1\n\t\t\tj += 1\n\t\t\tif j == curr:\n\t\t\t\tj = 0\n\t\t\t\tcurr *= 2\n\t\t\t\tans.sort()\n\t\t\t\tfinal_ans.append(ans)\n\t\t\t\tans = []\n\t\tif len(ans):\n\t\t\tans.sort()\n\t\t\tfinal_ans.append(ans)\n\t\treturn final_ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tif not arr:\n\t\t\treturn []\n\t\tres = []\n\t\tq = [arr[0]]\n\t\tpointer = 1\n\t\twhile q:\n\t\t\ttempQ = []\n\t\t\tdata = []\n\t\t\twhile q:\n\t\t\t\tdata.append(q.pop(0))\n\t\t\t\tif pointer < len(arr):\n\t\t\t\t\ttempQ.append(arr[pointer])\n\t\t\t\tpointer += 1\n\t\t\t\tif pointer < len(arr):\n\t\t\t\t\ttempQ.append(arr[pointer])\n\t\t\t\tpointer += 1\n\t\t\tres.append(sorted(data))\n\t\t\tq = tempQ\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tres = []\n\t\ti = 0\n\t\tk = 0\n\t\twhile i < n:\n\t\t\ttmp = []\n\t\t\tlvl = 2 ** k\n\t\t\twhile lvl > 0 and i < n:\n\t\t\t\ttmp.append(arr[i])\n\t\t\t\ti += 1\n\t\t\t\tlvl -= 1\n\t\t\ttmp.sort()\n\t\t\tres.append(tmp)\n\t\t\tk += 1\n\t\treturn res\n", "import math\n\nclass Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tres = []\n\t\t(j, k) = (0, 0)\n\t\twhile j < n:\n\t\t\ttmp = []\n\t\t\tlvl = math.pow(2, k)\n\t\t\twhile lvl > 0 and j < n:\n\t\t\t\ttmp.append(arr[j])\n\t\t\t\tlvl -= 1\n\t\t\t\tj += 1\n\t\t\ttmp.sort()\n\t\t\tres.append(tmp)\n\t\t\tk += 1\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tlevel = 0\n\t\tindex = 0\n\t\tans = list()\n\t\twhile index < n:\n\t\t\tnodesCurrLevel = pow(2, level) - 1\n\t\t\tlastindex = min(index + nodesCurrLevel, n - 1)\n\t\t\tarr = arr[:index] + sorted(arr[index:lastindex + 1]) + arr[lastindex + 1:]\n\t\t\tlst = list()\n\t\t\twhile index <= lastindex:\n\t\t\t\tlst.append(arr[index])\n\t\t\t\tindex += 1\n\t\t\tans.append(lst)\n\t\t\tlevel += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\t(k, i) = (0, 1)\n\t\tans = []\n\t\tz = []\n\t\ttot = 0\n\t\tfor x in arr:\n\t\t\tif k < i:\n\t\t\t\tz.append(x)\n\t\t\t\tk += 1\n\t\t\telse:\n\t\t\t\tans.append(sorted(z))\n\t\t\t\ttot += k\n\t\t\t\tk = 0\n\t\t\t\ti *= 2\n\t\t\t\tz = []\n\t\t\t\tz.append(x)\n\t\t\t\tk += 1\n\t\tif tot != n:\n\t\t\tans.append(sorted(z))\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tans = []\n\t\ti = 1\n\t\twhile i <= n:\n\t\t\ttemp = []\n\t\t\tfor j in range(i):\n\t\t\t\tif not arr:\n\t\t\t\t\tbreak\n\t\t\t\ttemp.append(arr.pop(0))\n\t\t\ttemp.sort()\n\t\t\tans.append(temp)\n\t\t\ti *= 2\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tl = 0\n\t\ti = 0\n\t\ts = []\n\t\twhile i < n:\n\t\t\tcln = 2 ** l\n\t\t\tj = min(i + cln - 1, n - 1)\n\t\t\ts.append(sorted(arr[i:j + 1]))\n\t\t\ti = j + 1\n\t\t\tl += 1\n\t\treturn s\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tans = []\n\t\tc = 0\n\t\ti = 1\n\t\twhile True:\n\t\t\tv = []\n\t\t\tj = 0\n\t\t\twhile j < i and c < n:\n\t\t\t\tv.append(arr[c])\n\t\t\t\tc += 1\n\t\t\t\tj += 1\n\t\t\tans.append(sorted(v))\n\t\t\ti = 2 * i\n\t\t\tif c == n:\n\t\t\t\tbreak\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tans = []\n\t\ti = 0\n\t\twhile arr:\n\t\t\ttemp = []\n\t\t\tc = 0\n\t\t\twhile c < 2 ** i and arr:\n\t\t\t\ttemp.append(arr.pop(0))\n\t\t\t\tc += 1\n\t\t\tans.append(sorted(list(temp)))\n\t\t\ti += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, a, n):\n\t\tl = []\n\t\tq = [0]\n\t\twhile q:\n\t\t\tt = a[q[0]:q[-1] + 1]\n\t\t\tt.sort()\n\t\t\tl.append(t)\n\t\t\tt = q.copy()\n\t\t\tq.clear()\n\t\t\tfor e in t:\n\t\t\t\tr1 = 2 * e + 1\n\t\t\t\tr2 = 2 * e + 2\n\t\t\t\tif r1 < n:\n\t\t\t\t\tq.append(r1)\n\t\t\t\tif r2 < n:\n\t\t\t\t\tq.append(r2)\n\t\treturn l\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tres = []\n\t\tlevel = 0\n\t\ti = 0\n\t\twhile i < len(arr):\n\t\t\tres.append([])\n\t\t\tj = min(len(arr), i + pow(2, level)) - 1\n\t\t\tfor k in range(j, i - 1, -1):\n\t\t\t\tres[-1].append(arr[k])\n\t\t\ti = j + 1\n\t\t\tlevel += 1\n\t\t\tres[-1].sort()\n\t\treturn res\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tans = []\n\t\ti = 0\n\t\tc = 0\n\t\tj = 2 ** c\n\t\twhile i < n and j < n:\n\t\t\tt = arr[i:j]\n\t\t\tans.append(sorted(t))\n\t\t\ti = j\n\t\t\tc += 1\n\t\t\tj = min(n, i + 2 ** c)\n\t\tans.append(sorted(arr[i:j]))\n\t\treturn ans\n", "class Solution:\n\n\tdef binTreeSortedLevels(self, arr, n):\n\t\tj = 0\n\t\tlevel = []\n\t\tresult = []\n\t\tfor i in range(n):\n\t\t\tif len(level) < 2 ** j:\n\t\t\t\tlevel.append(arr[i])\n\t\t\t\tif len(level) == 2 ** j or i == n - 1:\n\t\t\t\t\tresult.append(sorted(level.copy()))\n\t\t\t\t\tlevel.clear()\n\t\t\t\t\tj += 1\n\t\t\t\t\ti += 1\n\t\treturn result\n"], "starter_code": "\nclass Solution:\n    def binTreeSortedLevels (self,arr, n):\n        #code here.", "input_output": {"inputs": ["N = 7\narr[] = {7 6 5 4 3 2 1}", "N = 6\narr[] = {5 6 4 9 2 1}"], "outputs": ["7\n5 6\n1 2 3 4", "5\n4 6\n1 2 9"]}, "difficulty": "MEDIUM", "raw_tags": ["Algorithms", "Tree", "Sorting", "Queue", "Data Structures", "priority-queue"], "name": null, "source": "geeksforgeeks", "tags": ["Tree algorithms", "Sorting", "Data structures"], "skill_types": ["Sorting", "Data structures"], "url": "https://practice.geeksforgeeks.org/problems/print-binary-tree-levels-in-sorted-order3241/1", "Expected Auxiliary Space": "O(N).", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(NlogN)."}
{"question": "You are given the prices of stock for n number of days. every ith day tell the price of the stock on that day. find the maximum profit that you can make by buying and selling stock any number of times as you can't proceed with other transactions if you hold any transaction.\n\nYour Task:\nYou don't have to read input or print anything. Your task is to complete the function maximizeProfit() which takes the integer n and array prices and returns the maximum profit that can earn.\nExpected Time Complexity: O(n)\nExpected Space Complexity: O(n^{2})\nNOTE: can you solve this in less space complexity?\nConstraint:\n1<=n<=10^{5}\n1<=prices[i]<=10^{5}", "solutions": ["class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tn = len(prices)\n\t\tcurr = [0 for i in range(2)]\n\t\tnex = [0 for i in range(2)]\n\t\tprofit = 0\n\t\tfor ind in range(n - 1, -1, -1):\n\t\t\tfor buy in range(0, 2):\n\t\t\t\tif buy:\n\t\t\t\t\tbuynow = -prices[ind] + nex[0]\n\t\t\t\t\tnotbuy = 0 + nex[1]\n\t\t\t\t\tprofit = max(buynow, notbuy)\n\t\t\t\telse:\n\t\t\t\t\tsellnow = prices[ind] + nex[1]\n\t\t\t\t\tnotsell = 0 + nex[0]\n\t\t\t\t\tprofit = max(sellnow, notsell)\n\t\t\t\tcurr[buy] = profit\n\t\t\tnex = curr\n\t\treturn nex[1]\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tans = 0\n\t\tprev = 0\n\t\tfor i in range(1, n):\n\t\t\tif prices[i] > prices[prev]:\n\t\t\t\tans += prices[i] - prices[prev]\n\t\t\tprev = i\n\t\treturn ans\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tMax = 0\n\t\tfor i in range(1, len(prices)):\n\t\t\tif prices[i] > prices[i - 1]:\n\t\t\t\tMax += prices[i] - prices[i - 1]\n\t\treturn Max\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tprofit = 0\n\t\tfor i in range(n - 1):\n\t\t\tx = prices[i + 1] - prices[i]\n\t\t\tif x < 0:\n\t\t\t\tcontinue\n\t\t\tprofit += x\n\t\tif profit < 0:\n\t\t\treturn 0\n\t\treturn profit\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tdp = [[-1 for i in range(2)] for j in range(n + 1)]\n\t\tdp[n][0] = dp[n][1] = 0\n\t\tfor ind in range(n - 1, -1, -1):\n\t\t\tfor buy in range(2):\n\t\t\t\tif buy:\n\t\t\t\t\tprofit = max(-prices[ind] + dp[ind + 1][0], dp[ind + 1][1])\n\t\t\t\telse:\n\t\t\t\t\tprofit = max(prices[ind] + dp[ind + 1][1], dp[ind + 1][0])\n\t\t\t\tdp[ind][buy] = profit\n\t\treturn dp[0][1]\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tprev = [-1 for i in range(2)]\n\t\tfor i in range(1, -1, -1):\n\t\t\tprev[i] = 0\n\t\tfor ind in range(n - 1, -1, -1):\n\t\t\ttemp = [-1 for i in range(2)]\n\t\t\tfor buy in range(1, -1, -1):\n\t\t\t\tif buy == 1:\n\t\t\t\t\ttemp[buy] = max(-prices[ind] + prev[0], 0 + prev[1])\n\t\t\t\telse:\n\t\t\t\t\ttemp[buy] = max(prices[ind] + prev[1], 0 + prev[0])\n\t\t\tprev = temp\n\t\treturn prev[1]\n", "class Solution:\n\n\tdef maximumProfit(self, A, n):\n\t\ti = 0\n\t\tans = 0\n\t\twhile i < n:\n\t\t\twhile i + 1 < n and A[i] >= A[i + 1]:\n\t\t\t\ti += 1\n\t\t\tl = A[i]\n\t\t\twhile i + 1 < n and A[i] <= A[i + 1]:\n\t\t\t\ti += 1\n\t\t\tr = A[i]\n\t\t\tif l == r:\n\t\t\t\treturn ans\n\t\t\tans += r - l\n\t\t\ti += 1\n\t\treturn ans\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tminm = prices[0]\n\t\tprofit = 0\n\t\tfor i in range(1, n):\n\t\t\tif prices[i] > minm:\n\t\t\t\tprofit += prices[i] - minm\n\t\t\t\tminm = prices[i]\n\t\t\telse:\n\t\t\t\tminm = prices[i]\n\t\treturn profit\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tn = len(prices)\n\t\tdp = [[0 for _ in range(3)] for _ in range(n + 1)]\n\t\tfor i in range(n - 1, -1, -1):\n\t\t\tfor buy in range(2):\n\t\t\t\tif buy == 1:\n\t\t\t\t\tdp[i][buy] = max(-prices[i] + dp[i + 1][0], dp[i + 1][1])\n\t\t\t\telse:\n\t\t\t\t\tdp[i][buy] = max(prices[i] + dp[i + 1][1], dp[i + 1][0])\n\t\treturn dp[0][1]\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\t(profit, A) = (0, prices)\n\t\tfor i in range(n - 1):\n\t\t\tif A[i + 1] > A[i]:\n\t\t\t\tprofit += A[i + 1] - A[i]\n\t\treturn profit\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tdp = [[0 for i in range(2)] for i in range(n + 1)]\n\t\tans = 0\n\t\tfor j in range(1, len(prices)):\n\t\t\tif prices[j - 1] < prices[j]:\n\t\t\t\tans += prices[j] - prices[j - 1]\n\t\treturn ans\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tmax_profit = 0\n\t\tfor i in range(1, n):\n\t\t\tif prices[i] > prices[i - 1]:\n\t\t\t\tmax_profit += prices[i] - prices[i - 1]\n\t\treturn max_profit\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tafter = [0 for i in range(2)]\n\t\tfor i in range(2):\n\t\t\tafter[i] = 0\n\t\tfor ind in range(n - 1, -1, -1):\n\t\t\tcurr = [0 for i in range(2)]\n\t\t\tcurr[1] = max(-prices[ind] + after[0], after[1])\n\t\t\tcurr[0] = max(prices[ind] + after[1], after[0])\n\t\t\tafter = curr\n\t\treturn after[1]\n", "class Solution:\n\n\tdef maximumProfit(self, arr, n):\n\t\tdp = [[0 for i in range(2)] for j in range(n + 1)]\n\t\tdp[n][0] = 0\n\t\tdp[n][1] = 0\n\t\tfor idx in range(n - 1, -1, -1):\n\t\t\tfor buy in range(2):\n\t\t\t\tprofit = 0\n\t\t\t\tif buy:\n\t\t\t\t\tp = -arr[idx] + dp[idx + 1][0]\n\t\t\t\t\tnp = 0 + dp[idx + 1][1]\n\t\t\t\t\tprofit = max(profit, max(p, np))\n\t\t\t\telse:\n\t\t\t\t\ts = arr[idx] + dp[idx + 1][1]\n\t\t\t\t\tns = 0 + dp[idx + 1][0]\n\t\t\t\t\tprofit = max(profit, max(s, ns))\n\t\t\t\tdp[idx][buy] = profit\n\t\treturn dp[0][1]\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tprofit = 0\n\t\ti = 1\n\t\twhile i < n:\n\t\t\tbuy = i - 1\n\t\t\twhile i < n and prices[i] > prices[i - 1]:\n\t\t\t\ti += 1\n\t\t\tsell = i - 1\n\t\t\tprofit += prices[sell] - prices[buy]\n\t\t\ti += 1\n\t\treturn profit\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tdp = [[0] * 2 for _ in range(n + 1)]\n\t\tprofit = 0\n\t\tfor i in range(n - 1, -1, -1):\n\t\t\tfor j in range(2):\n\t\t\t\tif j == 0:\n\t\t\t\t\tprofit = max(dp[i + 1][0], dp[i + 1][1] - prices[i])\n\t\t\t\tif j == 1:\n\t\t\t\t\tprofit = max(dp[i + 1][1], dp[i + 1][0] + prices[i])\n\t\t\t\tdp[i][j] = profit\n\t\treturn dp[0][0]\n", "class Solution:\n\n\tdef maximumProfit(self, arr, n):\n\t\ti = 0\n\t\tfinal_ans = []\n\t\twhile i < n - 1:\n\t\t\tif arr[i] <= arr[i + 1]:\n\t\t\t\tans = []\n\t\t\t\tans.append(arr[i])\n\t\t\t\twhile i < n - 1 and arr[i] <= arr[i + 1]:\n\t\t\t\t\ti += 1\n\t\t\t\tans.append(arr[i])\n\t\t\t\tfinal_ans.append(ans)\n\t\t\telse:\n\t\t\t\ti += 1\n\t\tanswer = 0\n\t\tfor res in final_ans:\n\t\t\tanswer = answer + (res[1] - res[0])\n\t\treturn answer\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tans = 0\n\t\tfor i in range(1, n):\n\t\t\tans += max(0, prices[i] - prices[i - 1])\n\t\treturn ans\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tn = len(prices)\n\t\tdp = [[0] * 2 for i in range(n + 1)]\n\t\tdp[n][0] = dp[n][1] = 0\n\t\tfor idx in range(n - 1, -1, -1):\n\t\t\tfor buy in range(0, 2):\n\t\t\t\tprofit = 0\n\t\t\t\tif buy:\n\t\t\t\t\tprofit = max(-prices[idx] + dp[idx + 1][0], 0 + dp[idx + 1][1])\n\t\t\t\telse:\n\t\t\t\t\tprofit = max(prices[idx] + dp[idx + 1][1], 0 + dp[idx + 1][0])\n\t\t\t\tdp[idx][buy] = profit\n\t\treturn dp[0][1]\n", "class Solution:\n\n\tdef maximumProfit(self, A, n):\n\t\tahead = [0, 0]\n\t\tcurr = [0, 0]\n\t\tahead[0] = ahead[1] = 0\n\t\tfor ind in range(n - 1, -1, -1):\n\t\t\tfor buy in range(2):\n\t\t\t\tif buy:\n\t\t\t\t\ttake = -A[ind] + ahead[0]\n\t\t\t\t\tnoTake = 0 + ahead[1]\n\t\t\t\t\tcurr[buy] = max(take, noTake)\n\t\t\t\telse:\n\t\t\t\t\ttake = A[ind] + ahead[1]\n\t\t\t\t\tnoTake = 0 + ahead[0]\n\t\t\t\t\tcurr[buy] = max(take, noTake)\n\t\t\tahead = curr\n\t\treturn ahead[1]\n", "class Solution:\n\n\tdef maximumProfit(self, A, n):\n\t\tdp = [[0 for _ in range(2)] for _ in range(n + 1)]\n\t\t(dp[n][0], dp[n][1]) = (0, 0)\n\t\tfor ind in range(n - 1, -1, -1):\n\t\t\tfor buy in range(2):\n\t\t\t\tif buy:\n\t\t\t\t\ttake = -A[ind] + dp[ind + 1][0]\n\t\t\t\t\tnoTake = 0 + dp[ind + 1][1]\n\t\t\t\t\tdp[ind][buy] = max(take, noTake)\n\t\t\t\telse:\n\t\t\t\t\ttake = A[ind] + dp[ind + 1][1]\n\t\t\t\t\tnoTake = 0 + dp[ind + 1][0]\n\t\t\t\t\tdp[ind][buy] = max(take, noTake)\n\t\treturn dp[0][1]\n", "import sys\nsys.setrecursionlimit(10 ** 8)\nmod = 10 ** 9\n\nclass Solution:\n\n\tdef maximumProfit(self, arr, n):\n\t\tdp = [[0 for j in range(0, 2)] for i in range(0, n + 1)]\n\t\tdp[n][0] = 0\n\t\tdp[n][1] = 0\n\t\tfor i in range(n - 1, -1, -1):\n\t\t\tfor j in range(0, 2):\n\t\t\t\tprofit = 0\n\t\t\t\tif j == 0:\n\t\t\t\t\tbuy = -arr[i] + dp[i + 1][1]\n\t\t\t\t\tnotbuy = dp[i + 1][0]\n\t\t\t\t\tprofit = max(buy, notbuy)\n\t\t\t\telif j == 1:\n\t\t\t\t\tsell = arr[i] + dp[i + 1][0]\n\t\t\t\t\tnotsell = dp[i + 1][1]\n\t\t\t\t\tprofit = max(sell, notsell)\n\t\t\t\tdp[i][j] = profit\n\t\treturn dp[0][0]\n", "class Solution:\n\n\tdef maximumProfit(self, arr, n):\n\t\t(l, r) = (0, 1)\n\t\ttotal = 0\n\t\tprev = 0\n\t\twhile r < n:\n\t\t\tcurr = arr[r] - arr[l]\n\t\t\tif curr > prev:\n\t\t\t\tprev = curr\n\t\t\t\tif r == n - 1:\n\t\t\t\t\ttotal += prev\n\t\t\telif curr < prev:\n\t\t\t\ttotal += prev\n\t\t\t\tprev = 0\n\t\t\t\tl = r\n\t\t\tr += 1\n\t\treturn total\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tahead = [0] * 2\n\t\tahead[0] = 0\n\t\tahead[1] = 0\n\t\tfor ind in range(n - 1, -1, -1):\n\t\t\tcur = [0] * 2\n\t\t\tfor buy in range(2):\n\t\t\t\tif buy:\n\t\t\t\t\tprofit = max(-1 * prices[ind] + ahead[0], ahead[1])\n\t\t\t\telse:\n\t\t\t\t\tprofit = max(prices[ind] + ahead[1], ahead[0])\n\t\t\t\tcur[buy] = profit\n\t\t\tahead = cur\n\t\treturn ahead[1]\n", "import sys\n\nclass Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\tminI = 0\n\t\tres = []\n\t\tfor i in range(n):\n\t\t\tif i == n - 1 or (i < n - 1 and prices[i] > prices[i + 1]):\n\t\t\t\tif i != minI:\n\t\t\t\t\tres.append([minI, i])\n\t\t\t\tminI = i + 1\n\t\tprof = 0\n\t\tfor p in res:\n\t\t\tprof += prices[p[1]] - prices[p[0]]\n\t\treturn prof\n", "class Solution:\n\n\tdef maximumProfit(self, prices, n):\n\t\ttotal_profit = 0\n\t\tbuy = 0\n\t\tsell = 0\n\t\tfor i in range(1, n):\n\t\t\tif prices[i] >= prices[i - 1]:\n\t\t\t\tsell += 1\n\t\t\telse:\n\t\t\t\ttotal_profit += prices[sell] - prices[buy]\n\t\t\t\tbuy = i\n\t\t\t\tsell = i\n\t\ttotal_profit += prices[sell] - prices[buy]\n\t\treturn total_profit\n"], "starter_code": "#User function Template for python3\n\n\n\nclass Solution:\n\n    def maximumProfit(self, prices, n):\n\n        #Code here", "input_output": {"inputs": ["n = 7\nprices = [1,2,3,4,5,6,7]"], "outputs": ["6"]}, "difficulty": "MEDIUM", "raw_tags": [], "name": null, "source": "geeksforgeeks", "tags": [], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/buy-stock-2/1", "Expected Auxiliary Space": "O(n^{2})", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(n)"}
{"question": "Implement a function called `makeAcronym` that returns the first letters of each word in a passed in string.\n\nMake sure the letters returned are uppercase.\n\nIf the value passed in is not a string return `'Not a string'`.\n\nIf the value passed in is a string which contains characters other than spaces and alphabet letters, return `'Not letters'`.\n\nIf the string is empty, just return the string itself: `\"\"`.", "solutions": ["def make_acronym(phrase):\n\ttry:\n\t\treturn ''.join((word[0].upper() if word.isalpha() else 0 for word in phrase.split()))\n\texcept AttributeError:\n\t\treturn 'Not a string'\n\texcept TypeError:\n\t\treturn 'Not letters'\n", "from operator import itemgetter\n\ndef make_acronym(phrase):\n\tif type(phrase) != str:\n\t\treturn 'Not a string'\n\tif not all((c.isalpha() or c.isspace() for c in phrase)):\n\t\treturn 'Not letters'\n\treturn ''.join(map(itemgetter(0), phrase.split())).upper()\n", "def make_acronym(phrase):\n\tif not isinstance(phrase, str):\n\t\treturn 'Not a string'\n\tarr = phrase.split()\n\treturn ''.join((a[0] for a in arr)).upper() if all(map(str.isalpha, arr)) else 'Not letters'\n", "def make_acronym(phrase):\n\tif not isinstance(phrase, str):\n\t\treturn 'Not a string'\n\telif phrase == '':\n\t\treturn ''\n\telif not phrase.replace(' ', '').isalpha():\n\t\treturn 'Not letters'\n\telse:\n\t\treturn ''.join((word[0].upper() for word in phrase.split(' ')))\n", "def make_acronym(phrase):\n\tif isinstance(phrase, str):\n\t\twords = phrase.split()\n\t\tif all((x.isalpha() or x.isspace() for x in words)):\n\t\t\treturn ''.join((x[0] for x in words)).upper()\n\t\telse:\n\t\t\treturn 'Not letters'\n\treturn 'Not a string'\n", "from string import ascii_letters\n\ndef make_acronym(phrase):\n\tacronym = ''\n\tif isinstance(phrase, str):\n\t\twords = phrase.split()\n\t\tfor word in words:\n\t\t\tfor char in word:\n\t\t\t\tif char in ascii_letters:\n\t\t\t\t\tpass\n\t\t\t\telse:\n\t\t\t\t\treturn 'Not letters'\n\t\t\tacronym += word[0].upper()\n\t\treturn acronym\n\treturn 'Not a string'\n", "def make_acronym(phrase):\n\tif not isinstance(phrase, str):\n\t\treturn 'Not a string'\n\twords = phrase.split()\n\tif not all((i.isalpha() for i in words)):\n\t\treturn 'Not letters'\n\treturn ''.join((p[0] for p in words)).upper()\n", "def make_acronym(phrase):\n\timport re\n\tif type(phrase) is not str:\n\t\treturn 'Not a string'\n\tif re.search('[^A-Za-z\\\\s]', phrase):\n\t\treturn 'Not letters'\n\tacronym = ''\n\tfor x in phrase.split():\n\t\tacronym += x[0]\n\treturn acronym.upper()\n"], "starter_code": "def make_acronym(phrase):\n\t", "input_output": {"fn_name": "make_acronym", "inputs": [["My aunt sally"], ["Please excuse my dear aunt Sally"], ["How much wood would a woodchuck chuck if a woodchuck could chuck wood"], ["Unique New York"], ["a42"], ["1111"], [64], [[]], [{}], [""]], "outputs": [["MAS"], ["PEMDAS"], ["HMWWAWCIAWCCW"], ["UNY"], ["Not letters"], ["Not letters"], ["Not a string"], ["Not a string"], ["Not a string"], [""]]}, "difficulty": "EASY", "raw_tags": [], "name": null, "source": "codewars", "tags": [], "skill_types": [], "url": "https://www.codewars.com/kata/557efeb04effce569d000022", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null}
{"question": "A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.)\nWe are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'.\nReturn the minimum number of flips to make S monotone increasing.\n\nNote:\n\n1 <= S.length <= 20000\nS only consists of '0' and '1' characters.", "solutions": ["class Solution:\n\n\tdef minFlipsMonoIncr(self, S: str) -> int:\n\t\tonesSoFar = 0\n\t\tpartial = 0\n\t\tfor n in S:\n\t\t\tif n == '0':\n\t\t\t\tpartial = min(onesSoFar, partial + 1)\n\t\t\telse:\n\t\t\t\tonesSoFar += 1\n\t\treturn partial\n", "class Solution:\n\n\tdef minFlipsMonoIncr(self, S: str) -> int:\n\t\tif not S:\n\t\t\treturn 0\n\t\tn = len(S)\n\t\tif n == 1:\n\t\t\treturn 0\n\t\ttotal_1s = 0\n\t\ttotal_0s = 0\n\t\tfor char in S:\n\t\t\tif char == '1':\n\t\t\t\ttotal_1s += 1\n\t\t\telse:\n\t\t\t\ttotal_0s += 1\n\t\tif total_1s == 0 or total_0s == 0:\n\t\t\treturn 0\n\t\tprefix_sum = 0\n\t\tans = float('inf')\n\t\tfor i in range(n):\n\t\t\tprefix_sum += 1 if S[i] == '1' else 0\n\t\t\tans = min(ans, prefix_sum + (n - i - 1 - (total_1s - prefix_sum)))\n\t\treturn min(ans, total_0s, total_1s)\n", "class Solution:\n\n\tdef minFlipsMonoIncr(self, S: str) -> int:\n\t\tat0 = 0\n\t\tat1 = 0\n\t\tnum0 = 0\n\t\tfor a in S:\n\t\t\tif a == '0':\n\t\t\t\tat1 = min(at1, at0) + 1\n\t\t\telse:\n\t\t\t\tat1 = min(at1, at0)\n\t\t\t\tat0 += 1\n\t\treturn min(at1, at0)\n", "class Solution:\n\n\tdef minFlipsMonoIncr(self, S: str) -> int:\n\t\tstr_len = len(S)\n\t\tcount_arr = [[0, 0] for x in range(str_len)]\n\t\tone_start_idx = -1\n\t\tfor i in range(len(S)):\n\t\t\tif S[i] == '0':\n\t\t\t\tif i == 0:\n\t\t\t\t\tcount_arr[i][0] += 1\n\t\t\t\t\tcount_arr[i][1] = 0\n\t\t\t\telse:\n\t\t\t\t\tcount_arr[i][0] = count_arr[i - 1][0] + 1\n\t\t\t\t\tcount_arr[i][1] = count_arr[i - 1][1]\n\t\t\telse:\n\t\t\t\tif i == 0:\n\t\t\t\t\tcount_arr[i][1] += 1\n\t\t\t\telse:\n\t\t\t\t\tcount_arr[i][1] = count_arr[i - 1][1] + 1\n\t\t\t\t\tcount_arr[i][0] = count_arr[i - 1][0]\n\t\t\t\tif one_start_idx == -1:\n\t\t\t\t\tone_start_idx = i\n\t\ttotal_flips = []\n\t\ttotal_flips.append(min(count_arr[str_len - 1][0], count_arr[str_len - 1][1]))\n\t\tfor i in range(one_start_idx, str_len):\n\t\t\tif i == 0:\n\t\t\t\ttotal_flips.append(count_arr[str_len - 1][0] - count_arr[i][0])\n\t\t\telif i == str_len - 1:\n\t\t\t\ttotal_flips.append(count_arr[str_len - 1][0])\n\t\t\telse:\n\t\t\t\ttotal_flips.append(count_arr[i - 1][1] + count_arr[str_len - 1][0] - count_arr[i][0])\n\t\treturn min(total_flips)\n", "class Solution:\n\n\tdef minFlipsMonoIncr(self, S: str) -> int:\n\t\tdp = 0\n\t\tones = 0\n\t\tfor c in S:\n\t\t\tif c == '0':\n\t\t\t\tdp = min(1 + dp, ones)\n\t\t\telse:\n\t\t\t\tdp = min(dp, 1 + ones)\n\t\t\t\tones += 1\n\t\treturn dp\n", "class Solution:\n\n\tdef minFlipsMonoIncr(self, S: str) -> int:\n\t\t(flip, one) = (0, 0)\n\t\tfor i in S:\n\t\t\tif i == '1':\n\t\t\t\tone += 1\n\t\t\telse:\n\t\t\t\tflip += 1\n\t\t\tflip = min(one, flip)\n\t\treturn flip\n", "class Solution:\n\n\tdef minFlipsMonoIncr(self, S: str) -> int:\n\t\t(n, prefix, total, res) = (len(S), 0, S.count('1'), sys.maxsize)\n\t\tfor i in range(n + 1):\n\t\t\tres = min(res, prefix + len(S) - i - total + prefix)\n\t\t\tif i < n:\n\t\t\t\tprefix += 1 if S[i] == '1' else 0\n\t\treturn res\n"], "starter_code": "class Solution:\n    def minFlipsMonoIncr(self, S: str) -> int:\n        ", "input_output": {"fn_name": "minFlipsMonoIncr", "inputs": [["\"00110\""]], "outputs": [2]}, "difficulty": "MEDIUM_HARD", "raw_tags": ["Dynamic Programming", "String"], "name": null, "source": "leetcode", "tags": ["String algorithms", "Dynamic programming"], "skill_types": ["Dynamic programming"], "url": "https://leetcode.com/problems/flip-string-to-monotone-increasing/", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null}
{"question": "Given two values ‘a’ and ‘b’ that represent coefficients in “ax – by = 0”, find the smallest values of x and y that satisfy the equation. It may also be assumed that x > 0, y > 0, a > 0 and b > 0.\n\nYour Task:\nYou do not need to read input or print anything. Your task is to complete the function findXY() which takes a and b as input parameters and returns the least possible values of x and y to satisfy the equation.\nExpected Time Complexity: O(log(max(a, b)))\nExpected Auxiliary Space: O(1)\nConstraints:\n1 ≤ a, b ≤ 10^{4}", "solutions": ["class Solution:\n\n\tdef findXY(self, a, b):\n\t\timport math\n\t\tn = math.gcd(a, b)\n\t\tx = a / n\n\t\ty = b / n\n\t\tif b / a == y / x:\n\t\t\treturn [int(y), int(x)]\n", "class Solution:\n\n\tdef findXY(self, a, b):\n\t\ti = 2\n\t\tn = min(a, b)\n\t\twhile i != n + 1:\n\t\t\tif a % i == 0 and b % i == 0:\n\t\t\t\ta = a // i\n\t\t\t\tb = b // i\n\t\t\telse:\n\t\t\t\ti += 1\n\t\treturn (b, a)\n", "class Solution:\n\n\tdef findXY(self, a, b):\n\n\t\tdef gcd(m, n):\n\t\t\tif n == 0:\n\t\t\t\treturn m\n\t\t\treturn gcd(n, m % n)\n\t\tresult = a * b // gcd(a, b)\n\t\tx = result // a\n\t\ty = result // b\n\t\treturn (x, y)\n", "import math\n\nclass Solution:\n\n\tdef findXY(self, a, b):\n\t\tl = math.gcd(a, b)\n\t\treturn [b // l, a // l]\n", "class Solution:\n\n\tdef findXY(self, a, b):\n\t\tif a > b:\n\t\t\tgreater = a\n\t\telse:\n\t\t\tgreater = b\n\t\twhile True:\n\t\t\tif greater % a == 0 and greater % b == 0:\n\t\t\t\tlcm = greater\n\t\t\t\tbreak\n\t\t\tgreater += 1\n\t\treturn (lcm // a, lcm // b)\n", "from math import gcd\n\nclass Solution:\n\n\tdef findXY(self, a, b):\n\t\tm = gcd(a, b)\n\t\tl = []\n\t\tl.append(b // m)\n\t\tl.append(a // m)\n\t\treturn l\n", "class Solution:\n\n\tdef findXY(self, a, b):\n\t\tp = max(a, b)\n\t\tq = min(a, b)\n\t\tfor i in range(1, q + 1):\n\t\t\tif p * i % q == 0:\n\t\t\t\tbreak\n\t\tj = int(p * i / q)\n\t\tif p == a:\n\t\t\treturn [i, j]\n\t\telse:\n\t\t\treturn [j, i]\n", "class Solution:\n\n\tdef findXY(self, a, b):\n\t\tr = [0] * 2\n\t\tif a > b:\n\t\t\tsmall = b\n\t\telse:\n\t\t\tsmall = a\n\t\tfor i in range(1, small + 1):\n\t\t\tif a % i == 0 and b % i == 0:\n\t\t\t\tgcd = i\n\t\tlcm = a * b // gcd\n\t\tr[0] = lcm // a\n\t\tr[1] = lcm // b\n\t\treturn r\n", "import math\n\nclass Solution:\n\n\tdef findXY(self, a, b):\n\t\th = math.gcd(a, b)\n\t\tl = a / h * b\n\t\tarr = []\n\t\ta1 = l / a\n\t\tarr.append(int(a1))\n\t\ta2 = l / b\n\t\tarr.append(int(a2))\n\t\treturn arr\n"], "starter_code": "#User function Template for python3\n\n\n\nclass Solution:\n\n    def findXY(self, a, b):\n\n        # code here", "input_output": {"inputs": ["a = 25, b = 35", "a = 3, b = 7"], "outputs": ["7 5", "7 3"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Mathematical"], "name": null, "source": "geeksforgeeks", "tags": ["Mathematics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/find-smallest-values-of-x-and-y-such-that-ax-by-01433/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(log(max(a, b)))"}
{"question": "# Solve For X\n\nYou will be given an equation as a string and you will need to [solve for X](https://www.mathplacementreview.com/algebra/basic-algebra.php#solve-for-a-variable) and return x's value.\n\nNOTES:\n * All numbers will be whole numbers\n * Don't forget about the [order of operations](https://www.mathplacementreview.com/algebra/basic-algebra.php#order-of-operations).\n * If the random tests don't pass the first time, just run them again.", "solutions": ["from itertools import count\n\ndef solve_for_x(equation):\n\treturn next((x for n in count(0) for x in [n, -n] if eval(equation.replace('x', str(x)).replace('=', '=='))))\n", "import re\n\ndef solve_for_x(equation):\n\t(left, right) = equation.split('=')\n\tanswer = False\n\tTrialAndErrorRipMs = -1000\n\twhile answer == False:\n\t\tFinalLeft = re.sub('x', str(TrialAndErrorRipMs), left)\n\t\tFinalRight = re.sub('x', str(TrialAndErrorRipMs), right)\n\t\tif eval(FinalLeft) == eval(FinalRight):\n\t\t\treturn TrialAndErrorRipMs\n\t\tTrialAndErrorRipMs += 1\n", "def solve_for_x(equation):\n\tleft_side = equation.split('=')[0]\n\tright_side = equation.split('=')[1]\n\tfor x in range(-1000, 1000):\n\t\tif eval(left_side) == eval(right_side):\n\t\t\treturn x\n", "def solve_for_x(equation):\n\tfor x in range(-100, 1001):\n\t\tif eval(equation.replace('=', '==')):\n\t\t\treturn x\n", "from itertools import count\n\ndef solve_for_x(equation):\n\tequation = equation.replace('=', '==')\n\tfor x in count():\n\t\tif eval(equation):\n\t\t\treturn x\n\t\tx = -x\n\t\tif eval(equation):\n\t\t\treturn x\n", "def solve_for_x(equation):\n\t(left, right) = equation.split('=')\n\tfor x in range(-1000, 1000):\n\t\tif eval(left) == eval(right):\n\t\t\treturn x\n", "def solve_for_x(equation):\n\tp = equation.split()\n\tfor i in range(0, len(p)):\n\t\tif p[i] == '=':\n\t\t\tp[i] = '=='\n\tt = p.index('x')\n\tfor x in range(-1000, 1000):\n\t\tp[t] = str(x)\n\t\tif eval(''.join(p)):\n\t\t\treturn x\n", "def solve_for_x(s):\n\tfor i in range(-1000, 1000):\n\t\tif eval(s.replace('x', str(i)).replace('=', '==')):\n\t\t\treturn i\n", "class Exp:\n\n\tdef __init__(self, s):\n\t\tself.a = 1\n\t\tself.p = 0\n\t\tif s[-1] == 'x':\n\t\t\tself.p = 1\n\t\t\ts = s[:-1]\n\t\tif 0 < len(s):\n\t\t\tself.a *= int(s)\n\n\tdef __add__(self, other):\n\t\tif self.p == other.p:\n\t\t\tself.a += other.a\n\t\t\treturn self\n\t\telse:\n\t\t\treturn Equ([self, other])\n\n\tdef __sub__(self, other):\n\t\tif self.p == other.p:\n\t\t\tself.a -= other.a\n\t\t\treturn self\n\t\telse:\n\t\t\treturn Equ([self, Exp('-1') * other])\n\n\tdef __mul__(self, other):\n\t\tself.p += other.p\n\t\tself.a *= other.a\n\t\treturn self\n\n\tdef __div__(self, other):\n\t\tself.p -= other.p\n\t\tself.a /= other.a\n\t\treturn self\n\n\tdef __str__(self):\n\t\ts = ''\n\t\tif self.a != 0:\n\t\t\ts += str(self.a)\n\t\tif self.p == 1:\n\t\t\ts += 'x'\n\t\tif s == '':\n\t\t\ts += '0'\n\t\treturn s\n\nclass Equ:\n\n\tdef __init__(self, exp):\n\t\tself.exp = dict()\n\t\tfor e in exp:\n\t\t\tif e.p not in self.exp:\n\t\t\t\tself.exp[e.p] = e\n\t\t\telse:\n\t\t\t\tself.exp[e.p] += e\n\n\tdef __add__(self, other):\n\t\tif type(other) == Exp:\n\t\t\tother = Equ([other])\n\t\tfor p in other.exp:\n\t\t\tif p in self.exp:\n\t\t\t\tself.exp[p] += other.exp[p]\n\t\t\telse:\n\t\t\t\tself.exp[p] = other.exp[p]\n\t\treturn self\n\n\tdef __sub__(self, other):\n\t\tif type(other) == Exp:\n\t\t\tother = Equ([other])\n\t\tfor p in other.exp:\n\t\t\tif p in self.exp:\n\t\t\t\tself.exp[p] -= other.exp[p]\n\t\t\telse:\n\t\t\t\tself.exp[p] = Exp('-1') * other.exp[p]\n\t\treturn self\n\n\tdef __mul__(self, other):\n\t\tif type(other) == Exp:\n\t\t\tother = Equ([other])\n\t\tres = None\n\t\tfor p1 in other.exp:\n\t\t\ttemp_res = []\n\t\t\tfor p2 in self.exp:\n\t\t\t\ttemp_res.append(self.exp[p2] * other.exp[p1])\n\t\t\tif res is None:\n\t\t\t\tres = Equ(temp_res)\n\t\t\telse:\n\t\t\t\tres += Equ(temp_res)\n\t\treturn self\n\n\tdef __div__(self, other):\n\t\tif type(other) == Exp:\n\t\t\tother = Equ([other])\n\t\tres = None\n\t\tfor p1 in other.exp:\n\t\t\ttemp_res = []\n\t\t\tfor p2 in self.exp:\n\t\t\t\ttemp_res.append(self.exp[p2] / other.exp[p1])\n\t\t\tif res is None:\n\t\t\t\tres = Equ(temp_res)\n\t\t\telse:\n\t\t\t\tres += Equ(temp_res)\n\t\treturn self\n\n\tdef __str__(self):\n\t\ts = ''\n\t\tfor p in self.exp:\n\t\t\ts += ' (' + str(self.exp[p]) + ') +'\n\t\treturn s[:-1]\n\n\tdef get_power(self, p):\n\t\treturn self.exp[p] if p in self.exp else Exp('0') if p == 0 else Exp('0x')\n\ndef build1(s):\n\ts = s.replace(' ', '')\n\tstack = []\n\ts += '!'\n\tif s[0] == '-':\n\t\ts = '0' + s\n\tj = 0\n\tfor i in range(len(s)):\n\t\tif s[i] in ['+', '-', '*', '/', '(', ')', '!']:\n\t\t\tif j < i:\n\t\t\t\tstack.append(s[j:i])\n\t\t\tstack.append(s[i])\n\t\t\tj = i + 1\n\tstack.remove('!')\n\tfor (i, x) in enumerate(stack):\n\t\tif x not in ['+', '-', '*', '/', '(', ')', '!']:\n\t\t\tstack[i] = Exp(x)\n\treturn stack\n\ndef build2(s):\n\twhile ')' in s:\n\t\tend = s.index(')')\n\t\tstart = end\n\t\twhile s[start] != '(':\n\t\t\tstart -= 1\n\t\ts = s[:start] + [build2(s[start + 1:end])] + s[end + 1:]\n\top = {'+': lambda x, y: x + y, '-': lambda x, y: x - y, '*': lambda x, y: x * y, '/': lambda x, y: x.__div__(y)}\n\ti = 2\n\tfor order in [0, 1]:\n\t\ti = 2\n\t\twhile i < len(s):\n\t\t\tif order == 0 and s[i - 1] in ['*', '/'] or (order == 1 and s[i - 1] in ['+', '-']):\n\t\t\t\ts[i - 2] = op[s[i - 1]](s[i - 2], s[i])\n\t\t\t\ts.pop(i)\n\t\t\t\ts.pop(i - 1)\n\t\t\telse:\n\t\t\t\ti += 2\n\treturn s[0]\n\ndef build(s):\n\tstack = build1(s)\n\tequ = build2(stack)\n\tif type(equ) == Exp:\n\t\tequ = Equ([equ])\n\treturn equ\n\ndef solve_for_x(equation):\n\t(l, r) = equation.split(' = ')\n\t(l, r) = (build(l), build(r))\n\t(l, r) = (l.get_power(1) - r.get_power(1), r.get_power(0) - l.get_power(0))\n\treturn r.a / l.a\n"], "starter_code": "def solve_for_x(equation):\n\t", "input_output": {"fn_name": "solve_for_x", "inputs": [["x - 5 = 20"], ["5 * x + 5 = 30"], ["20 = 5 * x - 5"], ["24 = 4 + 5 * x"], ["x = 5"], ["x * 100 = 700"], ["2 * x + 5 = 105"], ["2 * x = 198"], ["x - 100 + 2 - 50 = 52"], ["x / 3 = 33"], ["x + 80 = 20"], ["x + 20 = -60"], ["5 * x + 20 - x = 60"], ["x + x + 6 = 10"], ["5 * x = x + 8"], ["x = x / 2 + 25"], ["(5 - 3) * x = x + 2"], ["(x - 30) * 2 = x"]], "outputs": [[25], [5], [5], [4], [5], [7], [50], [99], [200], [99], [-60], [-80], [10], [2], [2], [50], [2], [60]]}, "difficulty": "EASY", "raw_tags": ["Mathematics", "Algorithms", "Fundamentals", "Puzzles"], "name": null, "source": "codewars", "tags": ["Fundamentals", "Mathematics", "Ad-hoc"], "skill_types": [], "url": "https://www.codewars.com/kata/59c2e2a36bddd2707e000079", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null}
{"question": "Write a function that takes an array/list of numbers and returns a number.\n\n**Note:** each array/list will have at least an element and all elements will be valid numbers.", "solutions": ["def total(arr):\n\twhile len(arr) > 1:\n\t\tarr = [x + y for (x, y) in zip(arr, arr[1:])]\n\treturn arr[0]\n", "def total(arr):\n\tfrom math import factorial as fact\n\tchoose = lambda a, b: fact(a) / (fact(a - b) * fact(b))\n\treturn sum((choose(len(arr) - 1, i) * v for (i, v) in enumerate(arr)))\n", "def total(xs):\n\treturn xs[0] if len(xs) == 1 else total([xs[i] + x for (i, x) in enumerate(xs[1:])])\n", "def total(arr):\n\tif len(arr) == 1:\n\t\treturn arr[0]\n\tarr2 = []\n\tfor i in range(len(arr) - 1):\n\t\tarr2.append(arr[i] + arr[i + 1])\n\treturn total(arr2)\n", "def total(arr):\n\twhile len(arr) > 2:\n\t\tarr = [x + y for (x, y) in zip(arr, arr[1:])]\n\treturn sum(arr)\n", "total = lambda a: a[0] if len(a) == 1 else total([a[i] + a[i + 1] for i in range(len(a) - 1)])\n", "from math import factorial as fac\n\ndef C(n, k):\n\treturn fac(n) // (fac(k) * fac(n - k))\n\ndef total(arr):\n\tl = len(arr)\n\treturn sum((arr[i] * C(l - 1, i) for i in range(l)))\n", "def total(arr):\n\ta = arr[:]\n\tfor i in range(len(a), 1, -1):\n\t\tfor j in range(1, i):\n\t\t\ta[j - 1] += a[j]\n\treturn a[0]\n"], "starter_code": "def total(arr):\n\t", "input_output": {"fn_name": "total", "inputs": [[[1, 2, 3, 4, 5]], [[1, 2, 3, 4]], [[1, 2, 3]], [[4, 4, 52, 23, 32, 1, -1]], [[4, 4, 5, -1]], [[-1, -1, -1]], [[-1, -1, -10, 42, 92, 1, 23, 6, -3]], [[-1, 1, -1, 1]], [[42]]], "outputs": [[48], [20], [8], [1753], [30], [-4], [9248], [0], [42]]}, "difficulty": "EASY", "raw_tags": ["Mathematics", "Lists", "Fundamentals", "Logic", "Arrays"], "name": null, "source": "codewars", "tags": ["Fundamentals", "Data structures", "Mathematics"], "skill_types": ["Data structures"], "url": "https://www.codewars.com/kata/559fed8454b12433ff0000a2", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null}
{"question": "A faro shuffle of a deck of playing cards is a shuffle in which the deck is split exactly in half and then the cards in the two halves are perfectly interwoven, such that the original bottom card is still on the bottom and the original top card is still on top.\n\nIf 8 perfect faro shuffles are performed on a deck of 52 playing cards, the deck is restored to its original order.\n\nWrite a function that inputs an integer n and returns an integer representing the number of faro shuffles it takes to restore a deck of n cards to its original order.\n\nAssume n is an even number between 2 and 2000.", "solutions": ["def faro_cycles(n):\n\t(x, cnt) = (2, 1)\n\twhile x != 1 and n > 3:\n\t\tcnt += 1\n\t\tx = x * 2 % (n - 1)\n\treturn cnt\n", "def faro_cycles(deck_size):\n\t(arr, count) = (list(range(deck_size)), 0)\n\toriginal_arr = arr\n\twhile True:\n\t\tarr = arr[0:deck_size:2] + arr[1:deck_size:2]\n\t\tcount += 1\n\t\tif original_arr == arr:\n\t\t\tbreak\n\treturn count\n", "def faro_cycles(size):\n\tdeck = list(range(size))\n\t(cur, count) = (deck[::2] + deck[1::2], 1)\n\twhile cur != deck:\n\t\t(cur, count) = (cur[::2] + cur[1::2], count + 1)\n\treturn count\n", "def faro_cycles(n):\n\toriginal = list(range(1, n + 1))\n\t(duplicate, c) = (original.copy(), 0)\n\twhile 1:\n\t\t(first, bottom) = (duplicate[0], duplicate[-1])\n\t\tfirst_half = duplicate[1:n // 2]\n\t\tsecond_half = duplicate[n // 2:-1]\n\t\tduplicate = []\n\t\tfor (i, j) in zip(first_half, second_half):\n\t\t\tduplicate.extend([j, i])\n\t\tduplicate = [first] + duplicate + [bottom]\n\t\tc += 1\n\t\tif original == duplicate:\n\t\t\treturn c\n", "def faro_cycles(deck_size):\n\tif deck_size == 2:\n\t\treturn 1\n\t(pos, output) = (2, 1)\n\twhile pos != 1:\n\t\tpos = pos * 2 % (deck_size - 1)\n\t\toutput += 1\n\treturn output\n", "def faro_cycles(deck_size):\n\tpos = 1\n\tfor i in range(deck_size):\n\t\tpos = pos * 2 - (0 if pos < deck_size / 2 else deck_size - 1)\n\t\tif pos == 1:\n\t\t\treturn i + 1\n", "def faro(xs):\n\tm = len(xs) // 2\n\treturn [x for xs in zip(xs[:m], xs[m:]) for x in xs]\n\ndef faro_cycles(deck_size):\n\txs = original = list(range(deck_size))\n\tn = 0\n\twhile True:\n\t\tn += 1\n\t\txs = faro(xs)\n\t\tif xs == original:\n\t\t\treturn n\n", "def interv(list1, list2):\n\tout_list = []\n\tfor (el1, el2) in zip(list1, list2):\n\t\tout_list.append(el1)\n\t\tout_list.append(el2)\n\treturn out_list\n\ndef faro_cycles(deck_size):\n\toriginal = [x for x in range(deck_size)]\n\tnew = interv(original[:deck_size // 2], original[deck_size // 2:])\n\tn = 1\n\twhile original != new:\n\t\tnew = interv(new[:deck_size // 2], new[deck_size // 2:])\n\t\tn += 1\n\treturn n\n", "def faro_cycles(deck_size):\n\treturn [None, 1, 2, 4, 3, 6, 10, 12, 4, 8, 18, 6, 11, 20, 18, 28, 5, 10, 12, 36, 12, 20, 14, 12, 23, 21, 8, 52, 20, 18, 58, 60, 6, 12, 66, 22, 35, 9, 20, 30, 39, 54, 82, 8, 28, 11, 12, 10, 36, 48, 30, 100, 51, 12, 106, 36, 36, 28, 44, 12, 24, 110, 20, 100, 7, 14, 130, 18, 36, 68, 138, 46, 60, 28, 42, 148, 15, 24, 20, 52, 52, 33, 162, 20, 83, 156, 18, 172, 60, 58, 178, 180, 60, 36, 40, 18, 95, 96, 12, 196, 99, 66, 84, 20, 66, 90, 210, 70, 28, 15, 18, 24, 37, 60, 226, 76, 30, 29, 92, 78, 119, 24, 162, 84, 36, 82, 50, 110, 8, 16, 36, 84, 131, 52, 22, 268, 135, 12, 20, 92, 30, 70, 94, 36, 60, 136, 48, 292, 116, 90, 132, 42, 100, 60, 102, 102, 155, 156, 12, 316, 140, 106, 72, 60, 36, 69, 30, 36, 132, 21, 28, 10, 147, 44, 346, 348, 36, 88, 140, 24, 179, 342, 110, 36, 183, 60, 156, 372, 100, 84, 378, 14, 191, 60, 42, 388, 88, 130, 156, 44, 18, 200, 60, 108, 180, 204, 68, 174, 164, 138, 418, 420, 138, 40, 60, 60, 43, 72, 28, 198, 73, 42, 442, 44, 148, 224, 20, 30, 12, 76, 72, 460, 231, 20, 466, 66, 52, 70, 180, 156, 239, 36, 66, 48, 243, 162, 490, 56, 60, 105, 166, 166, 251, 100, 156, 508, 9, 18, 204, 230, 172, 260, 522, 60, 40, 253, 174, 60, 212, 178, 210, 540, 180, 36, 546, 60, 252, 39, 36, 556, 84, 40, 562, 28, 54, 284, 114, 190, 220, 144, 96, 246, 260, 12, 586, 90, 196, 148, 24, 198, 299, 25, 66, 220, 303, 84, 276, 612, 20, 154, 618, 198, 33, 500, 90, 72, 45, 210, 28, 84, 210, 64, 214, 28, 323, 290, 30, 652, 260, 18, 658, 660, 24, 36, 308, 74, 60, 48, 180, 676, 48, 226, 22, 68, 76, 156, 230, 30, 276, 40, 58, 700, 36, 92, 300, 708, 78, 55, 60, 238, 359, 51, 24, 140, 121, 486, 56, 244, 84, 330, 246, 36, 371, 148, 246, 318, 375, 50, 60, 756, 110, 380, 36, 24, 348, 384, 16, 772, 20, 36, 180, 70, 252, 52, 786, 262, 84, 60, 52, 796, 184, 66, 90, 132, 268, 404, 270, 270, 324, 126, 12, 820, 411, 20, 826, 828, 92, 168, 332, 90, 419, 812, 70, 156, 330, 94, 396, 852, 36, 428, 858, 60, 431, 172, 136, 390, 132, 48, 300, 876, 292, 55, 882, 116, 443, 21, 270, 414, 356, 132, 140, 104, 42, 180, 906, 300, 91, 410, 60, 390, 153, 102, 420, 180, 102, 464, 126, 310, 40, 117, 156, 940, 220, 36, 946, 36, 316, 68, 380, 140, 204, 155, 318, 96, 483, 72, 194, 138, 60, 488, 110, 36, 491, 196, 138, 154, 495, 30, 396, 332, 36, 60, 232, 132, 468, 504, 42, 92, 84, 84, 1018, 340, 10, 20, 156, 294, 515, 258, 132, 120, 519, 346, 444, 180, 348, 262, 350, 108, 420, 15, 88, 1060, 531, 140, 240, 356, 24, 252, 140, 358, 492, 253, 342, 60, 543, 330, 1090, 364, 36, 274, 156, 366, 29, 24, 180, 1108, 100, 156, 148, 1116, 372, 522, 1122, 300, 231, 564, 84, 510, 452, 378, 264, 162, 42, 76, 180, 382, 575, 288, 60, 132, 180, 126, 166, 116, 388, 249, 1170, 88, 460, 530, 390, 236, 156, 156, 1186, 140, 44, 298, 476, 18, 180, 300, 200, 24, 280, 60, 516, 1212, 324, 152, 572, 180, 611, 420, 204, 1228, 615, 204, 36, 1236, 174, 72, 140, 164, 28, 156, 138, 534, 100, 418, 1258, 48, 420, 220, 180, 414, 20, 198, 40, 1276, 639, 60, 1282, 16, 60, 161, 1290, 86, 36, 648, 72, 1300, 651, 84, 1306, 120, 198, 300, 524, 146, 659, 60, 126, 260, 221, 442, 1210, 70, 44, 285, 204, 444, 312, 268, 224, 630, 96, 20, 540, 638, 30, 680, 644, 12, 683, 1332, 76, 1372, 100, 216, 588, 1380, 460, 92, 18, 462, 636, 99, 60, 70, 233, 466, 660, 140, 66, 704, 328, 156, 188, 36, 70, 84, 237, 180, 1426, 84, 468, 179, 60, 478, 719, 130, 36, 136, 723, 66, 1450, 1452, 48, 115, 486, 486, 90, 292, 162, 84, 245, 490, 580, 210, 56, 370, 1482, 180, 743, 744, 210, 1492, 132, 166, 1498, 234, 498, 84, 340, 502, 755, 88, 100, 180, 105, 156, 1522, 60, 508, 690, 1530, 18, 204, 364, 54, 66, 771, 204, 24, 1548, 230, 194, 620, 516, 779, 111, 260, 156, 783, 522, 1570, 660, 60, 738, 526, 40, 791, 316, 506, 678, 252, 522, 140, 532, 60, 400, 228, 212, 803, 201, 534, 52, 72, 210, 1618, 1620, 540, 300, 542, 180, 87, 385, 36, 1636, 740, 546, 260, 276, 180, 48, 84, 252, 60, 92, 78, 30, 831, 36, 1666, 1668, 556, 357, 660, 84, 99, 820, 120, 84, 24, 562, 198, 1692, 28, 848, 566, 162, 780, 20, 284, 244, 812, 114, 588, 200, 570, 215, 574, 220, 260, 36, 144, 1732, 692, 96, 828, 1740, 246, 348, 1746, 260, 408, 146, 36, 150, 879, 586, 140, 88, 90, 420, 330, 588, 140, 74, 148, 204, 891, 24, 1786, 596, 198, 810, 716, 598, 48, 25, 50, 684, 276, 198, 362, 252, 220, 429, 424, 606, 911, 180, 84, 290, 305, 276, 732, 830, 612, 393, 144, 60, 923, 602, 154, 72, 156, 618, 780, 1860, 594, 372, 1866, 66, 935, 936, 500, 1876, 939, 90, 804, 84, 72, 472, 60, 90, 756, 135, 210, 1900, 860, 28, 1906, 902, 84, 239, 764, 630, 900, 56, 64, 60, 460, 214, 1930, 644, 84, 444, 276, 646, 924, 388, 290, 1948, 975, 30, 88, 306, 652, 468, 60, 260, 210, 890, 18, 1972, 780, 658, 1978, 282, 660, 44, 1986, 24, 180, 996, 36, 1996, 333][deck_size >> 1]\n", "def faro_cycles(deck_size):\n\tif deck_size <= 2:\n\t\treturn 1\n\tk = 1\n\twhile 2 ** k % (deck_size - 1) != 1:\n\t\tk += 1\n\treturn k\n"], "starter_code": "def faro_cycles(deck_size):\n\t", "input_output": {"fn_name": "faro_cycles", "inputs": [[2], [52], [542], [1250], [1954]], "outputs": [[1], [8], [540], [156], [30]]}, "difficulty": "EASY", "raw_tags": ["Fundamentals", "Iterators", "Lists"], "name": null, "source": "codewars", "tags": ["Fundamentals", "Data structures"], "skill_types": ["Data structures"], "url": "https://www.codewars.com/kata/57bc802c615f0ba1e3000029", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null}
{"question": "Given an array A of size N of integers. Your task is to find the sum of minimum and maximum element in the array.\n\nYour Task:  \nYou don't need to read input or print anything. Your task is to complete the function findSum() which takes the array A[] and its size N as inputs and returns the summation of minimum and maximum element of the array.\n\nExpected Time Complexity: O(N)  \nExpected Auxiliary Space: O(1)\n\nConstraints:\n- 1 <= N <= 10^{5}\n- -10^{9} <= A_{i} <= 10^{9}", "solutions": ["class Solution:\n\n\tdef findSum(self, A, N):\n\t\tA.sort()\n\t\treturn A[0] + A[len(A) - 1]\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\treturn max(A) + min(A)\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmaxval = A[0]\n\t\tminval = maxval\n\t\tfor i in range(1, N):\n\t\t\tif A[i] > maxval:\n\t\t\t\tmaxval = A[i]\n\t\t\t\tcontinue\n\t\t\tif A[i] < minval:\n\t\t\t\tminval = A[i]\n\t\t\t\tcontinue\n\t\treturn minval + maxval\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tself.A = A\n\t\tself.N = N\n\t\tmax_val = max(A)\n\t\tmin_val = min(A)\n\t\treturn max_val + min_val\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tA.sort()\n\t\tsum = A[0] + A[N - 1]\n\t\treturn sum\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\ta = min(A)\n\t\tb = max(A)\n\t\treturn a + b\n", "class Solution:\n\n\tdef findSum(self, arr, arr_size):\n\t\tmax = 0\n\t\tmin = 0\n\t\ti = 0\n\t\tif arr_size % 2 == 1:\n\t\t\tmax = arr[0]\n\t\t\tmin = arr[0]\n\t\t\ti = 1\n\t\telse:\n\t\t\tif arr[0] < arr[1]:\n\t\t\t\tmax = arr[1]\n\t\t\t\tmin = arr[0]\n\t\t\telse:\n\t\t\t\tmax = arr[0]\n\t\t\t\tmin = arr[1]\n\t\t\ti = 2\n\t\twhile i < arr_size:\n\t\t\tif arr[i] < arr[i + 1]:\n\t\t\t\tif arr[i] < min:\n\t\t\t\t\tmin = arr[i]\n\t\t\t\tif arr[i + 1] > max:\n\t\t\t\t\tmax = arr[i + 1]\n\t\t\telse:\n\t\t\t\tif arr[i] > max:\n\t\t\t\t\tmax = arr[i]\n\t\t\t\tif arr[i + 1] < min:\n\t\t\t\t\tmin = arr[i + 1]\n\t\t\ti = i + 2\n\t\treturn max + min\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\ta = A[0]\n\t\tb = A[0]\n\t\tfor i in range(N):\n\t\t\tif a > A[i]:\n\t\t\t\ta = A[i]\n\t\t\tif b < A[i]:\n\t\t\t\tb = A[i]\n\t\treturn a + b\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\td = min(A)\n\t\tm = max(A)\n\t\tresult = d + m\n\t\treturn result\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin = 99999999\n\t\tmax = -999999\n\t\tfor i in range(0, N):\n\t\t\tif A[i] < min:\n\t\t\t\tmin = A[i]\n\t\t\tif A[i] > max:\n\t\t\t\tmax = A[i]\n\t\treturn max + min\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin_a = 10 ** 9\n\t\tmax_b = -10 ** 9\n\t\tfor i in range(len(A)):\n\t\t\tif a[i] > max_b:\n\t\t\t\tmax_b = a[i]\n\t\t\tif a[i] < min_a:\n\t\t\t\tmin_a = a[i]\n\t\treturn min_a + max_b\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tlargest_element = A[0]\n\t\tfor i in range(N):\n\t\t\tif A[i] > largest_element:\n\t\t\t\tlargest_element = A[i]\n\t\tsmallest_element = A[0]\n\t\tfor i in range(N):\n\t\t\tif A[i] < smallest_element:\n\t\t\t\tsmallest_element = A[i]\n\t\treturn largest_element + smallest_element\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmaxx = -10000000\n\t\tminn = 10000000\n\t\tfor i in range(N):\n\t\t\tif A[i] > maxx:\n\t\t\t\tmaxx = A[i]\n\t\t\tif A[i] < minn:\n\t\t\t\tminn = A[i]\n\t\treturn maxx + minn\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tAmax = Amin = A[0]\n\t\tfor i in range(1, N):\n\t\t\tif A[i] > Amax:\n\t\t\t\tAmax = A[i]\n\t\t\telif A[i] < Amin:\n\t\t\t\tAmin = A[i]\n\t\treturn Amax + Amin\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tma = -999999999\n\t\tmi = 9999999999\n\t\tfor i in range(N):\n\t\t\tif A[i] < mi:\n\t\t\t\tmi = A[i]\n\t\t\tif ma < A[i]:\n\t\t\t\tma = A[i]\n\t\treturn ma + mi\n", "class Solution:\n\n\tdef findSum(self, arr, n):\n\t\tmaxi = arr[0]\n\t\tmini = arr[0]\n\t\tfor i in range(1, n):\n\t\t\tif arr[i] > maxi:\n\t\t\t\tmaxi = arr[i]\n\t\t\tif arr[i] < mini:\n\t\t\t\tmini = arr[i]\n\t\treturn maxi + mini\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin_elem = A[0]\n\t\tmax_elem = A[0]\n\t\tfor i in range(1, N):\n\t\t\tif A[i] < min_elem:\n\t\t\t\tmin_elem = A[i]\n\t\t\telif A[i] > max_elem:\n\t\t\t\tmax_elem = A[i]\n\t\treturn min_elem + max_elem\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin = A[0]\n\t\tmax = A[0]\n\t\tfor x in A:\n\t\t\tif x < min:\n\t\t\t\tmin = x\n\t\t\telif x > max:\n\t\t\t\tmax = x\n\t\treturn max + min\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmaxi = A[0]\n\t\tmini = A[0]\n\t\tfor i in range(N):\n\t\t\tif A[i] >= maxi:\n\t\t\t\tmaxi = A[i]\n\t\t\tif A[i] <= mini:\n\t\t\t\tmini = A[i]\n\t\treturn mini + maxi\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmax = A[0]\n\t\tmin = A[0]\n\t\tfor i in A:\n\t\t\tif i > max:\n\t\t\t\tmax = i\n\t\tfor i in A:\n\t\t\tif i < min:\n\t\t\t\tmin = i\n\t\treturn max + min\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tindex = 0\n\t\tminimum = A[0]\n\t\tmaximum = A[0]\n\t\twhile index < N:\n\t\t\tif minimum > A[index]:\n\t\t\t\tminimum = A[index]\n\t\t\tif maximum < A[index]:\n\t\t\t\tmaximum = A[index]\n\t\t\tindex += 1\n\t\treturn maximum + minimum\n", "class Solution:\n\n\tdef findSum(self, arr, N):\n\t\tarr.sort()\n\t\treturn arr[0] + arr[N - 1]\n", "class Solution:\n\n\tdef findSum(self, arr, N):\n\t\treturn max(arr) + min(arr)\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin_num = max_num = A[0]\n\t\tfor i in range(1, N):\n\t\t\tif A[i] < min_num:\n\t\t\t\tmin_num = A[i]\n\t\t\telif A[i] > max_num:\n\t\t\t\tmax_num = A[i]\n\t\treturn min_num + max_num\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tnewarray = sorted(A)\n\t\tfirstelement = newarray[0]\n\t\tlastelement = newarray[-1]\n\t\tsumofelement = firstelement + lastelement\n\t\treturn sumofelement\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmax_a = max(A)\n\t\tmin_a = min(A)\n\t\tsum_a = max_a + min_a\n\t\treturn sum_a\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmax1 = max(A)\n\t\tmin1 = min(A)\n\t\treturn max1 + min1\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin_val = max_val = A[0]\n\t\tfor num in A:\n\t\t\tif num < min_val:\n\t\t\t\tmin_val = num\n\t\t\telif num > max_val:\n\t\t\t\tmax_val = num\n\t\treturn min_val + max_val\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\n\t\tdef maxMin(A):\n\t\t\t(max, min) = (float('-inf'), float('inf'))\n\t\t\tfor i in A:\n\t\t\t\tif i > max:\n\t\t\t\t\tmax = i\n\t\t\t\tif i < min:\n\t\t\t\t\tmin = i\n\t\t\treturn [min, max]\n\t\treturn sum(maxMin(A))\n", "import numpy as np\n\nclass Solution:\n\n\tdef findSum(self, A, N):\n\t\tAr = np.array(A)\n\t\tAr.sort()\n\t\treturn Ar[0] + Ar[N - 1]\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin_val = float('inf')\n\t\tmax_val = float('-inf')\n\t\tfor i in range(N):\n\t\t\tif A[i] < min_val:\n\t\t\t\tmin_val = A[i]\n\t\t\tif A[i] > max_val:\n\t\t\t\tmax_val = A[i]\n\t\tsum_val = min_val + max_val\n\t\treturn sum_val\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tx = max(A)\n\t\ty = min(A)\n\t\treturn x + y\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tminimum = A[0]\n\t\tmaximum = A[0]\n\t\tsum = 0\n\t\tfor x in range(0, len(A), +1):\n\t\t\tif A[x] < minimum:\n\t\t\t\tminimum = A[x]\n\t\t\telif A[x] > maximum:\n\t\t\t\tmaximum = A[x]\n\t\t\tsum = maximum + minimum\n\t\treturn sum\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin = A[0]\n\t\tmax = A[0]\n\t\tsum = 0\n\t\tfor x in range(0, len(A), +1):\n\t\t\tif A[x] < min:\n\t\t\t\tmin = A[x]\n\t\t\telif A[x] > max:\n\t\t\t\tmax = A[x]\n\t\tsum = min + max\n\t\treturn sum\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmaximum = max(A)\n\t\tminimum = min(A)\n\t\tSum = minimum + maximum\n\t\treturn Sum\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tm = min(A)\n\t\tn = max(A)\n\t\treturn m + n\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\ts = sorted(A)\n\t\tlow = s[0]\n\t\thigh = s[n - 1]\n\t\tresult = low + high\n\t\treturn result\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tc = max(a)\n\t\td = min(a)\n\t\ts = c + d\n\t\treturn s\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmaxele = -float('inf')\n\t\tfor i in range(N):\n\t\t\tif maxele < A[i]:\n\t\t\t\tmaxele = A[i]\n\t\tminele = float('inf')\n\t\tfor i in range(N):\n\t\t\tif minele > A[i]:\n\t\t\t\tminele = A[i]\n\t\treturn maxele + minele\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin = A[0]\n\t\tmax = A[0]\n\t\tfor i in range(0, len(A)):\n\t\t\tif A[i] < min:\n\t\t\t\tmin = A[i]\n\t\t\tif A[i] > max:\n\t\t\t\tmax = A[i]\n\t\tsum = max + min\n\t\treturn sum\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tif N == 0:\n\t\t\treturn Null\n\t\telse:\n\t\t\treturn min(A) + max(A)\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin_elem = float('inf')\n\t\tmax_elem = float('-inf')\n\t\tfor i in range(N):\n\t\t\tif A[i] < min_elem:\n\t\t\t\tmin_elem = A[i]\n\t\t\tif A[i] > max_elem:\n\t\t\t\tmax_elem = A[i]\n\t\treturn min_elem + max_elem\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\timport math\n\t\tmin = math.inf\n\t\tmax = -math.inf\n\t\tfor i in range(0, len(A)):\n\t\t\tif A[i] < min:\n\t\t\t\tmin = A[i]\n\t\t\tif A[i] > max:\n\t\t\t\tmax = A[i]\n\t\treturn max + min\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\ts = A[0]\n\t\tl = A[0]\n\t\tfor i in range(N):\n\t\t\tif s > A[i]:\n\t\t\t\ts = A[i]\n\t\t\tif l < A[i]:\n\t\t\t\tl = A[i]\n\t\treturn l + s\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tif N == 1:\n\t\t\tsum = A[0] + A[0]\n\t\t\treturn sum\n\t\telse:\n\t\t\t(min, max) = (A[0], A[0])\n\t\t\tfor i in range(N):\n\t\t\t\tif A[i] < min:\n\t\t\t\t\tmin = A[i]\n\t\t\t\telif A[i] > max:\n\t\t\t\t\tmax = A[i]\n\t\t\tsum = min + max\n\t\treturn sum\n", "class Solution:\n\n\tdef findSum(self, a, n):\n\t\te = min(a)\n\t\tb = max(a)\n\t\treturn e + b\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmini = min(A)\n\t\tmaxi = max(A)\n\t\treturn mini + maxi\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tl = min(A)\n\t\tg = max(A)\n\t\ts = 0\n\t\ts = int(l + g)\n\t\treturn s\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tZ = max(A)\n\t\tX = min(A)\n\t\tsum = Z + X\n\t\treturn sum\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmx = max(A)\n\t\tmn = min(A)\n\t\ts = mx + mn\n\t\treturn s\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tl = list(A)\n\t\tmi = min(l)\n\t\tma = max(l)\n\t\tsum = int(mi) + int(ma)\n\t\treturn sum\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tif N == 0:\n\t\t\treturn 0\n\t\tif N == 1:\n\t\t\treturn 2 * A[0]\n\t\tA.sort()\n\t\treturn A[0] + A[-1]\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmin_A = min(A)\n\t\tmax_A = max(A)\n\t\tsum_mm = max_A + min_A\n\t\treturn sum_mm\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tx = min(A)\n\t\tY = max(A)\n\t\treturn x + Y\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tN = len(A)\n\t\tif N % 2 == 0:\n\t\t\tmx = max(A[0], A[1])\n\t\t\tmn = min(A[0], A[1])\n\t\t\ti = 2\n\t\telse:\n\t\t\tmx = mn = A[0]\n\t\t\ti = 1\n\t\twhile i < N - 1:\n\t\t\tif A[i] < A[i + 1]:\n\t\t\t\tmx = max(mx, A[i + 1])\n\t\t\t\tmn = min(mn, A[i])\n\t\t\telse:\n\t\t\t\tmx = max(mx, A[i])\n\t\t\t\tmn = min(mn, A[i + 1])\n\t\t\ti += 2\n\t\treturn mx + mn\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmaxi = -99999\n\t\tmini = 99999\n\t\tfor i in range(N):\n\t\t\tmaxi = max(A[i], maxi)\n\t\t\tmini = min(A[i], mini)\n\t\tsum = maxi + mini\n\t\treturn sum\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tmaxi = float('-inf')\n\t\tmini = float('inf')\n\t\tfor i in A:\n\t\t\tif i > maxi:\n\t\t\t\tmaxi = i\n\t\t\tif i < mini:\n\t\t\t\tmini = i\n\t\treturn maxi + mini\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tA.sort()\n\t\tmini = A[0]\n\t\tmaxi = A[-1]\n\t\treturn mini + maxi\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tminn = 1000000\n\t\tmaxx = -1000000\n\t\tfor i in A:\n\t\t\tif i > maxx:\n\t\t\t\tmaxx = i\n\t\t\tif i < minn:\n\t\t\t\tminn = i\n\t\treturn minn + maxx\n", "class Solution:\n\n\tdef findSum(self, A, N):\n\t\tl = max(A)\n\t\tb = min(A)\n\t\ts = l + b\n\t\treturn s\n"], "starter_code": "class Solution:\n\n    def findSum(self,A,N): \n\n        #code here\n\n", "input_output": {"inputs": ["N = 5\r\nA[] = {-2, 1, -4, 5, 3}", "N = 4\r\nA[]  = {1, 3, 4, 1}"], "outputs": ["1", "5"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Greedy"], "name": null, "source": "geeksforgeeks", "tags": ["Greedy algorithms"], "skill_types": ["Greedy algorithms"], "url": "https://practice.geeksforgeeks.org/problems/max-min/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N)"}
{"question": "Write a method that will search an array of strings for all strings that contain another string, ignoring capitalization. Then return an array of the found strings.\n\nThe method takes two parameters, the query string and the array of strings to search, and returns an array.\n\nIf the string isn't contained in any of the strings in the array, the method returns an array containing a single string: \"Empty\" (or `Nothing` in Haskell, or \"None\" in Python and C)", "solutions": ["def word_search(query, seq):\n\treturn [x for x in seq if query.lower() in x.lower()] or ['None']\n", "def word_search(query, seq):\n\tquery = query.lower()\n\tresult = [x for x in seq if query in x.lower()]\n\treturn result if result else ['None']\n", "import re\n\ndef word_search(query, seq):\n\treturn [w for w in seq if re.search(query, w, re.I)] or ['None']\n", "def word_search(query, seq):\n\tl = [i for i in seq if query.lower() in i.lower()]\n\treturn [l, ['None']][not l]\n", "def word_search(query, seq):\n\tquery = query.lower()\n\treturn [word for word in seq if query in word.lower()] or ['None']\n", "def word_search(q, l):\n\treturn [w for w in l if q.lower() in w.lower()] or ['None']\n", "def word_search(query, seq):\n\tquery = query.lower()\n\treturn [a for a in seq if query in a.lower()] or ['None']\n", "def word_search(query, seq):\n\treturn [i for i in seq if query.lower() in i.lower()] or ['None']\n", "def word_search(query, seq):\n\tarray = []\n\tfor x in seq:\n\t\tif query.lower() in x.lower():\n\t\t\tarray.append(x)\n\t\telse:\n\t\t\tpass\n\tif array != []:\n\t\treturn array\n\telse:\n\t\tarray = ['None']\n\t\treturn array\n"], "starter_code": "def word_search(query, seq):\n\t", "input_output": {"fn_name": "word_search", "inputs": [["ab", ["za", "ab", "abc", "zab", "zbc"]], ["aB", ["za", "ab", "abc", "zab", "zbc"]], ["ab", ["za", "aB", "Abc", "zAB", "zbc"]], ["abcd", ["za", "aB", "Abc", "zAB", "zbc"]]], "outputs": [[["ab", "abc", "zab"]], [["ab", "abc", "zab"]], [["aB", "Abc", "zAB"]], [["None"]]]}, "difficulty": "EASY", "raw_tags": ["Strings", "Fundamentals", "Arrays"], "name": null, "source": "codewars", "tags": ["String algorithms", "Fundamentals", "Data structures"], "skill_types": ["Data structures"], "url": "https://www.codewars.com/kata/54b81566cd7f51408300022d", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null}
{"question": "You're a statistics professor and the deadline for submitting your students' grades is tonight at midnight. Each student's grade is determined by their mean score across all of the tests they took this semester.\n\nYou've decided to automate grade calculation by writing a function `calculate_grade()` that takes a list of test scores as an argument and returns a one character string representing the student's grade calculated as follows:\n\n * 90% <= mean score <= 100%: `\"A\"`,\n * 80% <= mean score < 90%: `\"B\"`,\n * 70% <= mean score < 80%: `\"C\"`,\n * 60% <= mean score < 70%: `\"D\"`,\n * mean score < 60%: `\"F\"`\n\nYour function should handle an input list of any length greater than zero.", "solutions": ["from bisect import bisect\nfrom statistics import mean\n\ndef calculate_grade(scores):\n\treturn 'FDCBA'[bisect([60, 70, 80, 90], mean(scores))]\n", "def calculate_grade(scores):\n\tfor score in scores:\n\t\tmean = sum(scores) / len(scores)\n\t\tif mean >= 90 and mean <= 100:\n\t\t\treturn 'A'\n\t\telif mean >= 80 and mean < 90:\n\t\t\treturn 'B'\n\t\telif mean >= 70 and mean < 80:\n\t\t\treturn 'C'\n\t\telif mean >= 60 and mean < 70:\n\t\t\treturn 'D'\n\t\telse:\n\t\t\treturn 'F'\n", "import statistics\n\ndef calculate_grade(scores):\n\tmean = statistics.mean(scores)\n\tif mean >= 90:\n\t\treturn 'A'\n\tif mean >= 80:\n\t\treturn 'B'\n\tif mean >= 70:\n\t\treturn 'C'\n\tif mean >= 60:\n\t\treturn 'D'\n\treturn 'F'\n", "def calculate_grade(scores):\n\ts = sum(scores) / len(scores)\n\treturn 'ABCDF'[(s < 90) + (s < 80) + (s < 70) + (s < 60)]\n", "def calculate_grade(scores):\n\timport numpy as np\n\tmean_score = np.mean(scores)\n\tif mean_score >= 90:\n\t\treturn 'A'\n\telif mean_score >= 80:\n\t\treturn 'B'\n\telif mean_score >= 70:\n\t\treturn 'C'\n\telif mean_score >= 60:\n\t\treturn 'D'\n\telse:\n\t\treturn 'F'\n", "def calculate_grade(scores):\n\tmean = sum(scores) / len(scores)\n\treturn 'ABCDF'[(mean < 90) + (mean < 80) + (mean < 70) + (mean < 60)]\n", "def calculate_grade(scores):\n\tscore = sum(scores) / len(scores) / 100\n\tgrades = {0.6: 'D', 0.7: 'C', 0.8: 'B', 0.9: 'A'}\n\treturn grades[round(score, 1)] if score > 0.6 else 'F'\n", "def calculate_grade(scores):\n\tavg_grade = sum(scores) / len(scores)\n\tif avg_grade < 60:\n\t\treturn 'F'\n\telif avg_grade < 70:\n\t\treturn 'D'\n\telif avg_grade < 80:\n\t\treturn 'C'\n\telif avg_grade < 90:\n\t\treturn 'B'\n\telse:\n\t\treturn 'A'\n"], "starter_code": "def calculate_grade(scores):\n\t", "input_output": {"fn_name": "calculate_grade", "inputs": [[[92, 94, 99]], [[50, 60, 70, 80, 90]], [[50, 55]]], "outputs": [["A"], ["C"], ["F"]]}, "difficulty": "EASY", "raw_tags": ["Fundamentals"], "name": null, "source": "codewars", "tags": ["Fundamentals"], "skill_types": [], "url": "https://www.codewars.com/kata/586e0dc9b98de0064b000247", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null}
{"question": "Given 2 integers n and r. You task is to calculate ^{n}Cr%1000003.\n\nYour Task:\nYou don't need to read or print anything. Your task is to complete the function nCr() which takes n and r as input parameter and returns nCr modulo 1000003.\n\nExpected Time Complexity: O(m * log_{m}n) where m = 1000003  \nExpected Space Complexity: O(m)\n\nConstraints:\n1 <= n <= r <= 10^{16}", "solutions": ["M = 1000003\n\nclass Solution:\n\n\tdef __init__(self):\n\t\tself.f = [1] * M\n\t\tfor i in range(1, M):\n\t\t\tself.f[i] = self.f[i - 1] * i % M\n\n\tdef nCr(self, n, r):\n\t\tif r > n:\n\t\t\treturn 0\n\t\tif r == 0:\n\t\t\treturn 1\n\t\tif n < M and r < M:\n\t\t\treturn self.f[n] * pow(self.f[r], M - 2, M) * pow(self.f[n - r], M - 2, M) % M\n\t\treturn self.nCr(n // M, r // M) * self.nCr(n % M, r % M) % M\n", "class Solution:\n\n\tdef fact(self, dp, p):\n\t\tdp[0] = 1\n\t\tfor i in range(1, p):\n\t\t\tdp[i] = dp[i - 1] * i % p\n\n\tdef inverse(self, x, p):\n\t\tif not x:\n\t\t\treturn 1\n\t\tfor i in range(1, p):\n\t\t\tif int(x * i % p) == int(1 % p):\n\t\t\t\treturn i\n\n\tdef find(self, n, r, p, dp):\n\t\tif n < r:\n\t\t\treturn 0\n\t\tnum = dp[n]\n\t\tden = dp[n - r] * dp[r] % p\n\t\tval = num * self.inverse(den, p) % p\n\t\treturn val\n\n\tdef lucas(self, n, r, dp, p):\n\t\tif r == 0:\n\t\t\treturn 1\n\t\tni = int(n % p)\n\t\tri = int(r % p)\n\t\treturn self.lucas(n / p, r / p, dp, p) * self.find(ni, ri, p, dp) % p\n\n\tdef nCr(self, n, r):\n\t\tp = 1000003\n\t\tdp = [0] * 1000004\n\t\tself.fact(dp, p)\n\t\treturn self.lucas(n, r, dp, p)\n", "class Solution:\n\n\tdef nCr(self, n, r):\n\t\tmod = 1000003\n\n\t\tdef bin_expo(a, b):\n\t\t\tans = 1\n\t\t\twhile b > 0:\n\t\t\t\tif b & 1:\n\t\t\t\t\tans = ans * a % mod\n\t\t\t\ta = a * a % mod\n\t\t\t\tb = b // 2\n\t\t\treturn ans\n\n\t\tdef mod_inverse(a):\n\t\t\treturn bin_expo(a, mod - 2)\n\n\t\tdef fermat(n, r):\n\t\t\tif n < r:\n\t\t\t\treturn 0\n\t\t\tif r == 0 or n == r:\n\t\t\t\treturn 1\n\t\t\tif r == n - 1 or r == 1:\n\t\t\t\treturn n\n\t\t\tfact = [0] * (n + 1)\n\t\t\tfact[0] = 1\n\t\t\tfor i in range(1, n + 1):\n\t\t\t\tfact[i] = fact[i - 1] * i % mod\n\t\t\ta = fact[n]\n\t\t\tb = mod_inverse(fact[r])\n\t\t\tc = mod_inverse(fact[n - r])\n\t\t\treturn a * b % mod * c % mod % mod\n\n\t\tdef lucas(n, r):\n\t\t\tif r == 0:\n\t\t\t\treturn 1\n\t\t\tni = n % mod\n\t\t\tri = r % mod\n\t\t\treturn lucas(n // mod, r // mod) * fermat(ni, ri) % mod\n\t\treturn lucas(n, r)\n", "class Solution:\n\n\tdef nCrfarment(self, n, r):\n\t\tp = 1000003\n\t\tnum = den = 1\n\t\tfor i in range(r):\n\t\t\tnum = num * (n - i) % p\n\t\t\tden = den * (i + 1) % p\n\t\treturn num * pow(den, p - 2, p) % p\n\n\tdef nCr(self, n, r):\n\t\tp = 1000003\n\t\tif r == 0:\n\t\t\treturn 1\n\t\tni = int(n % p)\n\t\tri = int(r % p)\n\t\treturn self.nCr(int(n / p), int(r / p)) * self.nCrfarment(ni, ri) % p\n", "class Solution:\n\n\tdef nCr(self, n, r):\n\t\tlarge = 1000003\n\t\t(num, den) = self.test(n, r)\n\t\tinv = self.modular_inverse(den, large)\n\t\treturn num * inv % large\n\n\tdef test(self, n, r):\n\t\tif r == 0:\n\t\t\treturn (1, 1)\n\t\tlarge = 1000003\n\t\tr = min(r, n - r)\n\t\tuntil = r % large + large if r > large else r\n\t\tn_i = (n - r) % large\n\t\tr_i = 0\n\t\tnum = 1\n\t\tden = 1\n\t\tzero = 0\n\t\twhile r_i < until:\n\t\t\tn_i = (n_i + 1) % large\n\t\t\tr_i += 1\n\t\t\tif n_i == 0:\n\t\t\t\tzero += 1\n\t\t\t\tif zero > until // large:\n\t\t\t\t\treturn (0, 1)\n\t\t\telse:\n\t\t\t\tnum = num * n_i % large\n\t\t\tif r_i % large > 0:\n\t\t\t\tden = den * (r_i % large) % large\n\t\t(num_1, den_1) = self.test(n // large, r // large)\n\t\tnum = num * num_1 % large\n\t\tden = den * den_1 % large\n\t\treturn (num, den)\n\n\tdef modular_inverse(self, a, n):\n\t\tx1 = 0\n\t\tx2 = 1\n\t\twhile a != 0:\n\t\t\tq = n // a\n\t\t\t(n, a) = (a, n % a)\n\t\t\t(x1, x2) = (x2, x1 - x2 * q)\n\t\treturn x1\n", "class Solution:\n\n\tdef fact(self, dp, p):\n\t\tdp[0] = 1\n\t\tfor i in range(1, p):\n\t\t\tdp[i] = dp[i - 1] * i % p\n\n\tdef inverse(self, x, p):\n\t\tif x == 0:\n\t\t\treturn 1\n\t\tfor i in range(1, p):\n\t\t\tif x * i % p == 1 % p:\n\t\t\t\treturn i\n\n\tdef ncr(self, dp, n, r, p):\n\t\tif n < r:\n\t\t\treturn 0\n\t\tnum = dp[n] % p\n\t\tden = dp[n - r] * dp[r] % p\n\t\treturn num * self.inverse(den, p) % p\n\n\tdef lucas(self, dp, n, r, p):\n\t\tif r == 0:\n\t\t\treturn 1\n\t\tn_ = int(n % p)\n\t\tr_ = int(r % p)\n\t\treturn self.lucas(dp, n / p, r / p, p) * self.ncr(dp, n_, r_, p) % p\n\n\tdef nCr(self, n, r):\n\t\tp = 1000003\n\t\tdp = [0 for _ in range(p + 1)]\n\t\tself.fact(dp, p)\n\t\treturn self.lucas(dp, n, r, p)\n", "M = 1000003\n\ndef lucas(n, r, m):\n\tif r == 0:\n\t\treturn 1\n\tif n < m and r < m:\n\t\t(f, r) = ([1] * (n + 1), min(r, n))\n\t\tfor i in range(1, len(f)):\n\t\t\tf[i] = f[i - 1] * i % m\n\t\treturn f[n] * pow(f[r], m - 2, m) * pow(f[n - r], m - 2, m) % m\n\treturn lucas(n // m, r // m, m) * lucas(n % m, r % m, m) % m\n\nclass Solution:\n\n\tdef nCr(self, n, r):\n\n\t\tdef count(x):\n\t\t\tres = 0\n\t\t\twhile x > 0:\n\t\t\t\tres += x // M\n\t\t\t\tx //= M\n\t\t\treturn res\n\t\tif count(n) > count(r) + count(n - r):\n\t\t\treturn 0\n\t\treturn lucas(n, r, M)\n\n\tdef __init__(self):\n\t\tself.a = [1] * M\n\t\tfor i in range(1, len(self.a)):\n\t\t\tself.a[i] = self.a[i - 1] * i % M\n", "class Solution:\n\n\tdef __init__(self):\n\t\tself.m = 1000003\n\t\tself.fact = [1] * self.m\n\t\tfor i in range(1, self.m):\n\t\t\tself.fact[i] = self.fact[i - 1] * i % self.m\n\n\tdef fast_pow(self, base, exp):\n\t\tres = 1\n\t\twhile exp:\n\t\t\tif exp % 2:\n\t\t\t\tres = res * base % self.m\n\t\t\tbase = base * base % self.m\n\t\t\texp //= 2\n\t\treturn res\n\n\tdef inverse(self, a):\n\t\treturn self.fast_pow(a, self.m - 2)\n\n\tdef small(self, n, r):\n\t\tif r > n:\n\t\t\treturn 0\n\t\treturn self.fact[n] * self.inverse(self.fact[r] * self.fact[n - r] % self.m) % self.m\n\n\tdef nCr(self, n, r):\n\t\tif n == 0 or r == 0:\n\t\t\treturn 1\n\t\treturn self.nCr(n // self.m, r // self.m) * self.small(n % self.m, r % self.m) % self.m\n", "class Solution:\n\n\tdef __init__(self):\n\t\tself.m = 1000003\n\t\tself.fact = [1] * self.m\n\t\tfor i in range(1, self.m):\n\t\t\tself.fact[i] = self.fact[i - 1] * i % self.m\n\n\tdef inverse(self, a):\n\t\treturn pow(a, self.m - 2, self.m)\n\n\tdef small(self, n, r):\n\t\tif r > n:\n\t\t\treturn 0\n\t\treturn self.fact[n] * self.inverse(self.fact[r] * self.fact[n - r] % self.m) % self.m\n\n\tdef nCr(self, n, r):\n\t\tif n == 0 or r == 0:\n\t\t\treturn 1\n\t\treturn self.nCr(n // self.m, r // self.m) * self.small(n % self.m, r % self.m) % self.m\n"], "starter_code": "#User function Template for python3\n\nclass Solution:\n\tdef nCr(self, n, r):\n\t\t# Code here", "input_output": {"inputs": ["n = 5, r = 2", "n = 3, r = 2"], "outputs": ["10", "3"]}, "difficulty": "MEDIUM_HARD", "raw_tags": ["Combinatorial", "Algorithms", "Modular Arithmetic"], "name": null, "source": "geeksforgeeks", "tags": ["Number theory", "Combinatorics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/ncr-mod-m-part-10038/1", "Expected Auxiliary Space": "O(m)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(m * log_{m}n) where m = 1000003"}
{"question": "You probably know the \"like\" system from Facebook and other pages. People can \"like\" blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.\n\nImplement a function `likes :: [String] -> String`, which must take an input array containing the names of people who like an item. It must return the appropriate display text based on the number of names provided.\n\nFor 4 or more names, the number in `and X others` simply increases.", "solutions": ["def likes(names):\n\tn = len(names)\n\treturn {0: 'no one likes this', 1: '{} likes this', 2: '{} and {} like this', 3: '{}, {} and {} like this', 4: '{}, {} and {others} others like this'}[min(4, n)].format(*names[:3], others=n - 2)\n", "def likes(names):\n\tif len(names) == 0:\n\t\treturn 'no one likes this'\n\telif len(names) == 1:\n\t\treturn '%s likes this' % names[0]\n\telif len(names) == 2:\n\t\treturn '%s and %s like this' % (names[0], names[1])\n\telif len(names) == 3:\n\t\treturn '%s, %s and %s like this' % (names[0], names[1], names[2])\n\telse:\n\t\treturn '%s, %s and %s others like this' % (names[0], names[1], len(names) - 2)\n", "def likes(names):\n\tif not names:\n\t\treturn 'no one likes this'\n\tif len(names) == 1:\n\t\tfirst = ''\n\t\tsecond = names[0]\n\telif len(names) == 2:\n\t\tfirst = names[0]\n\t\tsecond = names[1]\n\telif len(names) == 3:\n\t\tfirst = ', '.join(names[:2])\n\t\tsecond = names[-1]\n\telse:\n\t\tfirst = ', '.join(names[:2])\n\t\tsecond = '%d others' % (len(names) - 2)\n\tif first:\n\t\treturn first + ' and ' + second + ' like this'\n\telse:\n\t\treturn second + ' likes this'\n", "def likes(names):\n\tl = len(names)\n\tif l == 0:\n\t\treturn 'no one likes this'\n\tif l == 1:\n\t\treturn '{} likes this'.format(names[0])\n\tif l == 2:\n\t\treturn '{} and {} like this'.format(names[0], names[1])\n\tif l == 3:\n\t\treturn '{}, {} and {} like this'.format(names[0], names[1], names[2])\n\treturn '{}, {} and {} others like this'.format(names[0], names[1], len(names) - 2)\n", "def likes(names):\n\tif not names:\n\t\treturn 'no one likes this'\n\tsize = len(names)\n\tif size == 1:\n\t\treturn '%s likes this' % names[0]\n\tif size == 2:\n\t\treturn '%s and %s like this' % (names[0], names[1])\n\tif size == 3:\n\t\treturn '%s, %s and %s like this' % (names[0], names[1], names[2])\n\tif size >= 4:\n\t\treturn '%s, %s and %s others like this' % (names[0], names[1], len(names[2:]))\n", "def likes(names):\n\tl = len(names)\n\ts = 'no one likes this'\n\tif l == 1:\n\t\ts = names[0] + ' likes this'\n\telif l == 2:\n\t\ts = ' and '.join(names) + ' like this'\n\telif l == 3:\n\t\ts = ', '.join(names[:-1]) + ' and ' + names[-1] + ' like this'\n\telif l != 0:\n\t\ts = ', '.join(names[:2]) + ' and ' + str(l - 2) + ' others like this'\n\treturn s\n"], "starter_code": "def likes(names):\n\t", "input_output": {"fn_name": "likes", "inputs": [[[]], [["Peter"]], [["Jacob", "Alex"]], [["Max", "John", "Mark"]], [["Alex", "Jacob", "Mark", "Max"]]], "outputs": [["no one likes this"], ["Peter likes this"], ["Jacob and Alex like this"], ["Max, John and Mark like this"], ["Alex, Jacob and 2 others like this"]]}, "difficulty": "EASY", "raw_tags": ["Strings", "Fundamentals"], "name": null, "source": "codewars", "tags": ["String algorithms", "Fundamentals"], "skill_types": [], "url": "https://www.codewars.com/kata/5266876b8f4bf2da9b000362", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null}
{"question": "Given 3 characters 'a', 'b', 'c'. Find the number of strings of length n that can be formed from these 3 characters. Given that: we can use ‘a’ as many times as we want, ‘b’ maximum once, and ‘c’ maximum twice.\n\nYour Task:\nYou don't need to read or print anything. Your task is to complete the function no_ofString() which takes n as input parameter and returns the number of total possible strings that can be formed using characters 'a', 'b' and 'c' modulo 10^{9} + 7.\n\nExpected Time Complexity: O(n)\nExpected Space Complexity: O(n)\n\nConstraints:\n1 <= n <= 100000", "solutions": ["class Solution:\n\n\tdef no_ofString(self, n):\n\t\tl = 10 ** 9 + 7\n\t\treturn (1 + n * 2 + n * (n * n - 1) // 2) % l\n", "class Solution:\n\n\tdef no_ofString(self, n):\n\t\tm = 1000000007\n\t\tans = 1 + 2 * (n % m) + n % m * (n % m - 1) * (n % m + 1) // 2\n\t\treturn ans % m\n", "class Solution:\n\n\tdef no_ofString(self, n):\n\t\treturn (n * n * n + (3 * n + 2)) // 2 % 1000000007\n", "class Solution:\n\n\tdef no_ofString(self, n):\n\t\tm = 1000000007\n\t\tans = 1 + 2 * (n % m) + n % m * (n % m - 1) * (n % m + 1) // 2\n\t\treturn ans % m\nif __name__ == '__main__':\n\tT = int(input())\n\tfor i in range(T):\n\t\tn = int(input())\n\t\tob = Solution()\n\t\tans = ob.no_ofString(n)\n\t\tprint(ans)\n", "class Solution:\n\n\tdef no_ofString(self, n):\n\t\tm = 10 ** 9 + 7\n\t\tans = 1 + 2 * (n % m) + n % m * (n % m - 1) * (n % m + 1) // 2\n\t\treturn ans % m\n", "class Solution:\n\n\tdef no_ofString(self, n):\n\t\tif n == 1:\n\t\t\treturn 3\n\t\tmod = int(10 ** 9 + 7)\n\t\ttotal = 1 + n % mod + n * n % mod + n * (n - 1) * (n - 1) // 2 % mod\n\t\treturn total % mod\n", "class Solution:\n\n\tdef no_ofString(self, n):\n\t\tif n == 1:\n\t\t\treturn 3\n\t\ttotal = 0\n\t\tfor i in range(3):\n\t\t\tcombination = 1\n\t\t\tbottom_part = 1\n\t\t\tfor x in range(i):\n\t\t\t\tcombination *= n - x\n\t\t\t\tbottom_part *= x + 1\n\t\t\ttotal = (total + combination // bottom_part) % (10 ** 9 + 7)\n\t\tfor i in range(3):\n\t\t\tcombination = 1\n\t\t\tbottom_part = 1\n\t\t\tfor x in range(i):\n\t\t\t\tcombination *= n - 1 - x\n\t\t\t\tbottom_part *= x + 1\n\t\t\ttotal = (total + n * (combination // bottom_part)) % (10 ** 9 + 7)\n\t\treturn total\n", "def possibilities(x):\n\tcount = 1\n\twhile x > 1:\n\t\tcount *= x\n\t\tx -= 1\n\treturn count\n\nclass Solution:\n\n\tdef no_ofString(self, n):\n\t\tif n == 1:\n\t\t\treturn 3\n\t\tall_a = 1\n\t\tone_b_other_a = n % (10 ** 9 + 7)\n\t\tone_c_other_a = n % (10 ** 9 + 7)\n\t\tone_c_one_b = n % (10 ** 9 + 7)\n\t\tif n > 2:\n\t\t\tone_c_one_b = n * (n - 1) % (10 ** 9 + 7)\n\t\ttwo_c = 1\n\t\tif n > 2:\n\t\t\ttwo_c = int(n * (n - 1) / 2) % (10 ** 9 + 7)\n\t\tone_b_two_c = 0\n\t\tif n > 2:\n\t\t\tone_b_two_c = int(n * (n - 1) * (n - 2) / 2) % (10 ** 9 + 7)\n\t\treturn (all_a + one_b_other_a + one_c_other_a + one_c_one_b + two_c + one_b_two_c) % (10 ** 9 + 7)\n"], "starter_code": "#User function Template for python3\n\nclass Solution:\n\tdef no_ofString(self, n):\n\t\t# Code here", "input_output": {"inputs": ["n = 2", "n = 3"], "outputs": ["8", "19"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Mathematical", "permutation"], "name": null, "source": "geeksforgeeks", "tags": ["Combinatorics", "Mathematics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/total-number-of-strings5726/1", "Expected Auxiliary Space": "O(n)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(n)"}
{"question": "Given a string, find the longest substring which is palindrome in Linear time O(N).\n\n**Input:**\nThe first line of input contains an integer T denoting the number of test cases. Then T test cases follow. The only line of each test case contains a string.\n\n**Output:**\nFor each test case print the Longest Palindromic Substring. If there are multiple such substrings of the same length, print the one which appears first in the input string.\n\n**Constraints:**\n- 1 <= T <= 100\n- 1 <= N <= 50\n", "solutions": ["def manacher_odd(s):\n\tn = len(s)\n\ts = '$' + s + '^'\n\tp = [0] * (n + 2)\n\t(l, r) = (1, 1)\n\tmax_len = 0\n\tpos = -1\n\tfor i in range(1, n + 1):\n\t\tp[i] = max(0, min(r - i, p[l + r - i]))\n\t\twhile s[i - p[i]] == s[i + p[i]]:\n\t\t\tp[i] += 1\n\t\tif p[i] > max_len:\n\t\t\tmax_len = p[i]\n\t\t\tpos = i\n\t\tif i + p[i] > r:\n\t\t\tr = i + p[i]\n\t\t\tl = i - p[i]\n\treturn s[pos - p[pos] + 2:pos + p[pos] - 1]\n\ndef LongestPalindromeSubString(text):\n\ts = '#' + '#'.join(list((c for c in text))) + '#'\n\tans = manacher_odd(s)\n\treturn ''.join(ans.split(sep='#'))\n", "import sys\n\ndef UpdatedString(string):\n\tnewString = ['#']\n\tfor char in string:\n\t\tnewString += [char, '#']\n\treturn ''.join(newString)\n\ndef LongestPalindromeSubString(text):\n\tstring = UpdatedString(text)\n\tLPS = [0 for _ in range(len(string))]\n\tC = 0\n\tR = 0\n\tfor i in range(len(string)):\n\t\tiMirror = 2 * C - i\n\t\tif R > i:\n\t\t\tLPS[i] = min(R - i, LPS[iMirror])\n\t\telse:\n\t\t\tLPS[i] = 0\n\t\ttry:\n\t\t\twhile string[i + 1 + LPS[i]] == string[i - 1 - LPS[i]]:\n\t\t\t\tLPS[i] += 1\n\t\texcept:\n\t\t\tpass\n\t\tif i + LPS[i] > R:\n\t\t\tC = i\n\t\t\tR = i + LPS[i]\n\t(r, c) = (max(LPS), LPS.index(max(LPS)))\n\treturn string[c - r:c + r].replace('#', '')\n", "def LongestPalindromeSubString(s):\n\tpairs = [0 for _ in range(2 * len(text) - 1)]\n\tlongest = 1\n\tindex = 0\n\tbox = 0\n\tmirror = 0\n\tfor i in range(1, len(pairs)):\n\t\tleft_c = (i - 1) // 2\n\t\tright_c = (i + 2) // 2\n\t\tif right_c < box:\n\t\t\tidentical = pairs[mirror - (i - mirror)]\n\t\t\tif right_c + identical > box + 1:\n\t\t\t\tidentical = box + 1 - right_c\n\t\t\tright_c += identical\n\t\t\tpairs[i] = identical\n\t\t\tleft_c -= identical\n\t\t\tif right_c <= box or right_c == len(text):\n\t\t\t\tcontinue\n\t\twhile left_c >= 0 and right_c < len(text) and (text[left_c] == text[right_c]):\n\t\t\tleft_c -= 1\n\t\t\tright_c += 1\n\t\t\tpairs[i] += 1\n\t\tif pairs[i] > 1 and right_c - 1 > box:\n\t\t\tbox = right_c - 1\n\t\t\tmirror = i\n\t\tlength = 2 * pairs[i]\n\t\tif i % 2 == 0:\n\t\t\tlength += 1\n\t\tif length > longest:\n\t\t\tlongest = length\n\t\t\tindex = (i + 1) // 2 - length // 2\n\treturn text[index:index + longest]\n", "def LongestPalindromeSubString(text):\n\tif text == text[::-1]:\n\t\treturn text\n\telif len(text) == 1:\n\t\treturn text\n\toriginal = text[:]\n\ttext = '@#' + '#'.join(text) + '#$'\n\tn = len(text)\n\tC = 0\n\tR = 0\n\tmax = 0\n\tmaxInd = 0\n\tpal = [0] * n\n\tfor i in range(1, n - 1):\n\t\tmirr = 2 * C - i\n\t\tif i < R:\n\t\t\tpal[i] = min(pal[mirr], R - i)\n\t\twhile text[i + (1 + pal[i])] == text[i - (1 + pal[i])]:\n\t\t\tpal[i] += 1\n\t\tif pal[i] > max:\n\t\t\tmax = pal[i]\n\t\t\tmaxInd = i\n\t\tif i + pal[i] > R:\n\t\t\tC = i\n\t\t\tR = i + pal[i]\n\t\tif i + pal[i] == n - 2:\n\t\t\tbreak\n\tif maxInd % 2 == 0:\n\t\thalfLen = (pal[maxInd] - 1) // 2\n\t\tmaxInd = maxInd // 2 - 1\n\t\treturn original[maxInd - halfLen:maxInd + halfLen + 1]\n\telse:\n\t\thalfLen = pal[maxInd] // 2\n\t\tmaxInd = (maxInd - 1) // 2\n\t\treturn original[maxInd - halfLen:maxInd + halfLen]\n", "def LongestPalindromeSubString(text):\n\tN = len(text)\n\tif N <= 1:\n\t\treturn text\n\tN = 2 * N + 1\n\tL = [0] * N\n\tL[0] = 0\n\tL[1] = 1\n\tC = 1\n\tR = 2\n\ti = 0\n\tiMirror = 0\n\tmaxLPSLength = 0\n\tmaxLPSCenterPosition = 0\n\tstart = -1\n\tend = -1\n\tdiff = -1\n\tfor i in range(2, N):\n\t\tiMirror = 2 * C - i\n\t\tL[i] = 0\n\t\tdiff = R - i\n\t\tif diff > 0:\n\t\t\tL[i] = min(L[iMirror], diff)\n\t\ttry:\n\t\t\twhile (i + L[i] < N and i - L[i] > 0) and ((i + L[i] + 1) % 2 == 0 or text[(i + L[i] + 1) // 2] == text[(i - L[i] - 1) // 2]):\n\t\t\t\tL[i] += 1\n\t\texcept Exception as e:\n\t\t\tpass\n\t\tif L[i] > maxLPSLength:\n\t\t\tmaxLPSLength = L[i]\n\t\t\tmaxLPSCenterPosition = i\n\t\tif i + L[i] > R:\n\t\t\tC = i\n\t\t\tR = i + L[i]\n\tstart = (maxLPSCenterPosition - maxLPSLength) // 2\n\tend = start + maxLPSLength - 1\n\tif len(text[start:end + 1]) == 1:\n\t\treturn text[0]\n\treturn text[start:end + 1]\n", "def LongestPalindromeSubString(text):\n\tif text == text[::-1]:\n\t\treturn text\n\tmaxlen = 0\n\tstart = 0\n\tright = 0\n\tbetalen = 2 * len(text) + 1\n\tbetastr = '#'\n\tcentre = 0\n\tp = [0] * betalen\n\tfor i in text:\n\t\tbetastr += i + '#'\n\tfor i in range(1, betalen - 1):\n\t\tif i < right:\n\t\t\tp[i] = min(right - i, p[2 * centre - i])\n\t\twhile betastr[min(betalen - 1, i + p[i] + 1)] == betastr[max(0, i - p[i] - 1)]:\n\t\t\tp[i] += 1\n\t\tif i + p[i] > right:\n\t\t\tright = i + p[i]\n\t\t\tcentre = i\n\t\tif p[i] > maxlen:\n\t\t\tstart = int((i - p[i]) / 2)\n\t\t\tmaxlen = p[i]\n\treturn text[start:start + maxlen]\n", "def LongestPalindromeSubStringNaive(text):\n\tn = len(text)\n\tmax_len = 1\n\tmax_i = 0\n\tprev_indices = [0]\n\tfor i in range(1, n):\n\t\tcurr_indices = []\n\t\tfor prev_index in prev_indices:\n\t\t\tcurr_index = prev_index - 1\n\t\t\tif curr_index > -1 and text[i] == text[curr_index]:\n\t\t\t\tcurr_indices.append(curr_index)\n\t\tif i - 1 > -1 and text[i] == text[i - 1]:\n\t\t\tcurr_indices.append(i - 1)\n\t\tcurr_indices.append(i)\n\t\tprev_indices = curr_indices\n\t\tcurr_len = i - prev_indices[0] + 1\n\t\tif curr_len > max_len:\n\t\t\tmax_len = curr_len\n\t\t\tmax_i = prev_indices[0]\n\treturn text[max_i:max_i + max_len]\n\ndef LongestPalindromeSubString(text):\n\tn = len(text)\n\tN = 2 * n + 1\n\tnew_text = [''] * N\n\tfor i in range(n):\n\t\tnew_text[2 * i] = '#'\n\t\tnew_text[2 * i + 1] = text[i]\n\tnew_text[-1] = '#'\n\tcenter = 0\n\tmax_right = 0\n\tmax_len = 0\n\tP = [0] * N\n\tfor i in range(1, N):\n\t\tif i < max_right:\n\t\t\tP[i] = min(max_right - i, P[2 * center - i])\n\t\tleft_i = i - P[i] - 1\n\t\tright_i = i + P[i] + 1\n\t\twhile left_i > -1 and right_i < N and (new_text[left_i] == new_text[right_i]):\n\t\t\tP[i] += 1\n\t\t\tleft_i = i - P[i] - 1\n\t\t\tright_i = i + P[i] + 1\n\t\tif i + P[i] > max_right:\n\t\t\tcenter = i\n\t\t\tmax_right = i + P[i]\n\t\tif P[i] > max_len:\n\t\t\tstart = (i - P[i]) // 2\n\t\t\tmax_len = P[i]\n\treturn text[start:start + max_len]\n", "def LongestPalindromeSubString(text):\n\tn = len(text)\n\tarr = '#'\n\tfor i in range(n):\n\t\tarr += text[i]\n\t\tarr += '#'\n\tval = [0] * len(arr)\n\tcenter = 0\n\tright = 0\n\tlongestCent = 0\n\tlongestLength = 0\n\tfor i in range(len(arr)):\n\t\tmirror = 2 * center - i\n\t\tif right > i:\n\t\t\tval[i] = min(val[mirror], right - i)\n\t\ta = i - (val[i] + 1)\n\t\tb = i + (val[i] + 1)\n\t\twhile a >= 0 and b < len(arr) and (arr[a] == arr[b]):\n\t\t\ta -= 1\n\t\t\tb += 1\n\t\t\tval[i] += 1\n\t\tif val[i] > longestLength:\n\t\t\tlongestCent = i\n\t\t\tlongestLength = val[i]\n\t\tif i + val[i] > right:\n\t\t\tcenter = i\n\t\t\tright = i + val[i]\n\treturn arr[longestCent - longestLength:longestCent + longestLength].replace('#', '')\n", "def LongestPalindromeSubString(text):\n\tif len(text) == 1:\n\t\treturn text\n\ts = '#'.join('^{}$'.format(text))\n\tn = len(s)\n\tL = [0] * n\n\t(C, R) = (0, 0)\n\tmLen = 0\n\tmLenPos = 0\n\tfor i in range(1, n - 1):\n\t\tL[i] = R > i and min(L[2 * C - i], R - i)\n\t\twhile s[i + L[i] + 1] == s[i - L[i] - 1]:\n\t\t\tL[i] += 1\n\t\tif L[i] > mLen:\n\t\t\tmLen = L[i]\n\t\t\tmLenPos = i\n\t\tif i + L[i] > R:\n\t\t\tC = i\n\t\t\tR = i + L[i]\n\tstart = (mLenPos - mLen) // 2\n\tend = start + mLen\n\treturn text[start:end]\n", "def fastLongestPalindromes(seq):\n\tseqLen = len(seq)\n\tl = []\n\ti = 0\n\tpalLen = 0\n\twhile i < seqLen:\n\t\tif i > palLen and seq[i - palLen - 1] == seq[i]:\n\t\t\tpalLen += 2\n\t\t\ti += 1\n\t\t\tcontinue\n\t\tl.append(palLen)\n\t\ts = len(l) - 2\n\t\te = s - palLen\n\t\tfor j in range(s, e, -1):\n\t\t\td = j - e - 1\n\t\t\tif l[j] == d:\n\t\t\t\tpalLen = d\n\t\t\t\tbreak\n\t\t\tl.append(min(d, l[j]))\n\t\telse:\n\t\t\tpalLen = 1\n\t\t\ti += 1\n\tl.append(palLen)\n\tlLen = len(l)\n\ts = lLen - 2\n\te = s - (2 * seqLen + 1 - lLen)\n\tfor i in range(s, e, -1):\n\t\td = i - e - 1\n\t\tl.append(min(d, l[i]))\n\treturn l\n\ndef LongestPalindromeSubString(text):\n\tl = max(fastLongestPalindromes(text))\n\tfor i in range(len(text) - l + 1):\n\t\tsubstr = text[i:i + l]\n\t\tif substr == substr[::-1]:\n\t\t\treturn substr\n\treturn ''\n", "def LongestPalindromeSubString(text):\n\ts = ['#']\n\tfor i in text:\n\t\ts += [i, '#']\n\ts = ''.join(s)\n\tn = len(s)\n\tlps = [0 for i in range(n)]\n\tc = 0\n\tr = 0\n\tfor i in range(n):\n\t\tim = c - (i - c)\n\t\tif r > i:\n\t\t\tlps[i] = min(r - i, lps[im])\n\t\telse:\n\t\t\tlps[i] = 0\n\t\ttry:\n\t\t\twhile s[i - 1 - lps[i]] == s[i + 1 + lps[i]]:\n\t\t\t\tlps[i] += 1\n\t\texcept:\n\t\t\tpass\n\t\tif r < i + lps[i]:\n\t\t\tc = i\n\t\t\tr = i + lps[i]\n\t(r, c) = (max(lps), lps.index(max(lps)))\n\tk = s[c - r:c + r]\n\treturn k.replace('#', '')\n", "def my_print(*args):\n\tpass\n\ndef LongestPalindromeSubString(text):\n\tn = len(text)\n\tN = 2 * n + 1\n\tmaxLPSlen = 1\n\tmaxLPScenter = 1\n\tL = [0] * N\n\tL[0] = 0\n\tL[1] = 1\n\tC = 1\n\tR = 2\n\tiMirror = 0\n\tfor i in range(2, N):\n\t\tiMirror = 2 * C - i\n\t\tL[i] = 0\n\t\tdiff = R - i\n\t\texpand = True\n\t\tif diff > 0:\n\t\t\tL[i] = min(L[iMirror], diff)\n\t\tif expand:\n\t\t\twhile i + L[i] < 2 * n and i - L[i] > 0:\n\t\t\t\tif (i + L[i] + 1) % 2 == 0:\n\t\t\t\t\tL[i] += 1\n\t\t\t\telif text[(i + L[i] + 1) // 2] == text[(i - L[i] - 2) // 2]:\n\t\t\t\t\tL[i] += 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\tif L[i] > maxLPSlen:\n\t\t\tmaxLPSlen = L[i]\n\t\t\tmaxLPScenter = i\n\t\tif i + L[i] > R:\n\t\t\tC = i\n\t\t\tR = i + L[i]\n\tstart = (maxLPScenter - maxLPSlen) // 2\n\tend = (maxLPScenter + maxLPSlen) // 2 - 1\n\tres = text[start:end + 1]\n\treturn res\n"], "starter_code": "#User function Template for python3\n\ndef LongestPalindromeSubString(text):\n    # code here\n    # return the longest palindrome substring\n", "input_output": {"fn_name": "LongestPalindromeSubString", "inputs": ["2\r\n\nbabcbabcbaccba\r\n\nforgeeksskeegfor"], "outputs": ["abcbabcba\r\ngeeksskeeg"]}, "difficulty": "MEDIUM_HARD", "raw_tags": ["Data Structures", "Strings"], "name": null, "source": "geeksforgeeks", "tags": ["String algorithms", "Data structures"], "skill_types": ["Data structures"], "url": "https://practice.geeksforgeeks.org/problems/longest-palindromic-substring-in-linear-time/1", "Expected Auxiliary Space": "", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": ""}
{"question": "Given a dictionary of words and a pattern. Every character in the pattern is uniquely mapped to a character in the dictionary. Find all such words in the dictionary that match the given pattern.\n\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function `findMatchedWords()` which takes an array of strings `dict[]` consisting of the words in the dictionary and a string, `Pattern` and returns an array of strings consisting of all the words in the `dict[]` that match the given Pattern in lexicographical order.\n\nExpected Time Complexity: O(N*K) (where K is the length of the pattern).\n\nExpected Auxiliary Space: O(N).\n\nConstraints:\n1 <= N <= 10", "solutions": ["def findSpecificPattern(Dict, pattern):\n\tans = []\n\tfor i in Dict:\n\t\tdic = {}\n\t\tdic2 = {}\n\t\tif len(i) == len(pattern):\n\t\t\tflag = True\n\t\t\tfor (j, k) in zip(i, pattern):\n\t\t\t\tif j not in dic and k not in dic2:\n\t\t\t\t\tdic[j] = k\n\t\t\t\t\tdic2[k] = j\n\t\t\t\telif dic.get(j) != k or dic2.get(k) != j:\n\t\t\t\t\tflag = False\n\t\t\tif flag:\n\t\t\t\tans.append(i)\n\treturn ans\n", "def findSpecificPattern(dict, pattern):\n\tlst = []\n\tfor i in dict:\n\t\tif len(set(i)) == len(set(pattern)) == len(set(zip(i, pattern))) and len(i) == len(pattern):\n\t\t\tlst.append(i)\n\treturn lst\n", "def findSpecificPattern(Dict, pattern):\n\td = {}\n\tfor i in pattern:\n\t\tif i in d:\n\t\t\td[i] += 1\n\t\telse:\n\t\t\td[i] = 1\n\tb = list(d.values())\n\tb.sort()\n\ta = []\n\tc = []\n\tfor i in Dict:\n\t\td2 = {}\n\t\tfor j in i:\n\t\t\tif j in d2:\n\t\t\t\td2[j] += 1\n\t\t\telse:\n\t\t\t\td2[j] = 1\n\t\tx = list(d2.values())\n\t\tx.sort()\n\t\ta.append(x)\n\t\tc.append(i)\n\t\td2.clear()\n\td = []\n\tfor i in range(len(a)):\n\t\tif b == a[i]:\n\t\t\td.append(c[i])\n\treturn d\n", "def findSpecificPattern(Dict, pattern):\n\ta = []\n\tfor i in Dict:\n\t\tif len(i) != len(pattern):\n\t\t\tcontinue\n\t\td1 = {}\n\t\td2 = {}\n\t\tfor j in range(len(i)):\n\t\t\tif i[j] not in d1.keys() or pattern[j] not in d2.keys():\n\t\t\t\td1[i[j]] = pattern[j]\n\t\t\t\td2[pattern[j]] = i[j]\n\t\t\telif d1[i[j]] != pattern[j] or d2[pattern[j]] != i[j]:\n\t\t\t\tbreak\n\t\tif len(d1) == len(d2):\n\t\t\ta.append(i)\n\treturn a\n", "def encodeString(Str):\n\tmap = {}\n\tres = ''\n\ti = 0\n\tfor ch in Str:\n\t\tif ch not in map:\n\t\t\tmap[ch] = i\n\t\t\ti += 1\n\t\tres += str(map[ch])\n\treturn res\n\ndef findMatchedWords(dict, pattern):\n\tLen = len(pattern)\n\thash = encodeString(pattern)\n\tres = []\n\tfor word in dict:\n\t\tif len(word) == Len and encodeString(word) == hash:\n\t\t\tres.append(word)\n\treturn res\n\ndef findSpecificPattern(Dict, pattern):\n\treturn findMatchedWords(Dict, pattern)\n", "def findSpecificPattern(Dict, s):\n\ta = []\n\tfor i in s:\n\t\tif i not in a:\n\t\t\ta.append(i)\n\tfor i in range(len(a)):\n\t\ta[i] = s.count(a[i])\n\n\tdef check(m):\n\t\taa = []\n\t\tfor i in m:\n\t\t\tif i not in aa:\n\t\t\t\taa.append(i)\n\t\tfor i in range(len(aa)):\n\t\t\taa[i] = m.count(aa[i])\n\t\treturn aa\n\tfor i in Dict:\n\t\tif check(i) == a:\n\t\t\tprint(i, end=' ')\n\treturn []\n", "def findSpecificPattern(Dict, pattern):\n\tans = []\n\tflag = False\n\tfor stri in Dict:\n\t\tflag = False\n\t\tif len(stri) == len(pattern):\n\t\t\tfor i in range(len(pattern) - 1):\n\t\t\t\tif stri[i] != stri[i + 1] and pattern[i] != pattern[i + 1] or (stri[i] == stri[i + 1] and pattern[i] == pattern[i + 1]):\n\t\t\t\t\tflag = True\n\t\t\t\telse:\n\t\t\t\t\tflag = False\n\t\t\t\t\tbreak\n\t\t\tif flag == True:\n\t\t\t\tdic = {}\n\t\t\t\tpic = {}\n\t\t\t\tfor i in range(len(pattern)):\n\t\t\t\t\tif stri[i] not in dic:\n\t\t\t\t\t\tdic[stri[i]] = 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tdic[stri[i]] += 1\n\t\t\t\t\tif pattern[i] not in pic:\n\t\t\t\t\t\tpic[pattern[i]] = 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tpic[pattern[i]] += 1\n\t\t\t\tfor i in range(len(pattern)):\n\t\t\t\t\tif dic[stri[i]] != pic[pattern[i]]:\n\t\t\t\t\t\tflag = False\n\t\t\t\t\t\tbreak\n\t\t\tif len(stri) == 1 and len(pattern) == 1:\n\t\t\t\tans.append(stri)\n\t\tif flag == True:\n\t\t\tans.append(stri)\n\treturn ans\n", "def findSpecificPattern(Dict, pattern):\n\ta = []\n\tfor i in Dict:\n\t\tif len(set(i)) == len(set(pattern)) and len(i) == len(pattern):\n\t\t\ta.append(i)\n\treturn a\n", "def hash_fn(word):\n\tk = 0\n\tmapper = {}\n\tres = ''\n\tfor i in word:\n\t\tif i not in mapper:\n\t\t\tmapper[i] = k\n\t\t\tk += 1\n\t\tres += str(mapper[i])\n\treturn res\n\ndef findSpecificPattern(Dict, pattern):\n\tptrn_hsh = hash_fn(pattern)\n\tl = len(pattern)\n\tres = []\n\tfor i in Dict:\n\t\tif len(i) == l and hash_fn(i) == ptrn_hsh:\n\t\t\tres.append(i)\n\treturn res\n", "def findSpecificPattern(Dict, pattern):\n\tmatched_words = []\n\tfor word in Dict:\n\t\tif len(word) == len(pattern):\n\t\t\tmatched = True\n\t\t\tpattern_dict = {}\n\t\t\tfor i in range(len(word)):\n\t\t\t\tif word[i] not in pattern_dict:\n\t\t\t\t\tif pattern[i] in pattern_dict.values():\n\t\t\t\t\t\tmatched = False\n\t\t\t\t\t\tbreak\n\t\t\t\t\tpattern_dict[word[i]] = pattern[i]\n\t\t\t\telif pattern_dict[word[i]] != pattern[i]:\n\t\t\t\t\tmatched = False\n\t\t\t\t\tbreak\n\t\t\tif matched:\n\t\t\t\tmatched_words.append(word)\n\tmatched_words.sort()\n\treturn matched_words\n", "def findSpecificPattern(Dict, pattern):\n\tpattern_list = []\n\tfor item in Dict:\n\t\tif len(item) != len(pattern):\n\t\t\tpattern_list.append('')\n\t\t\tcontinue\n\t\tnew_pattern = pattern\n\t\tchar_dict = {}\n\t\ttemp_str = ''\n\t\tfor i in range(len(item)):\n\t\t\tif item[i] in char_dict:\n\t\t\t\ttemp_str = temp_str + char_dict[item[i]]\n\t\t\telif new_pattern != '':\n\t\t\t\tchar_dict[item[i]] = new_pattern[0]\n\t\t\t\tnew_pattern = new_pattern.replace(new_pattern[0], '')\n\t\t\t\ttemp_str = temp_str + char_dict[item[i]]\n\t\tpattern_list.append(temp_str)\n\tfinal_pattern = []\n\tfor i in range(len(pattern_list)):\n\t\tif pattern_list[i] == pattern:\n\t\t\tfinal_pattern.append(Dict[i])\n\treturn final_pattern\n\treturn final_pattern\n", "def findSpecificPattern(Dict, pattern):\n\td = {}\n\tfor (i, char) in enumerate(pattern):\n\t\tif char in d:\n\t\t\td[char].append(i)\n\t\telse:\n\t\t\td[char] = [i]\n\tcontrol = sorted(d.values())\n\toutput = []\n\tfor word in Dict:\n\t\ttemp = {}\n\t\tfor (i, char) in enumerate(word):\n\t\t\tif char in temp:\n\t\t\t\ttemp[char].append(i)\n\t\t\telse:\n\t\t\t\ttemp[char] = [i]\n\t\tif sorted(temp.values()) == control:\n\t\t\toutput.append(word)\n\treturn sorted(output)\n", "def findSpecificPattern(Dict, pattern):\n\tdct = {}\n\tarr = [0] * len(pattern)\n\tj = 0\n\tans = []\n\tfor i in pattern:\n\t\tif i in dct:\n\t\t\tdct[i] += 1\n\t\t\tarr[j] = dct[i]\n\t\telse:\n\t\t\tarr[j] = 1\n\t\t\tdct[i] = 1\n\t\tj += 1\n\tfor p in Dict:\n\t\tarr2 = [0] * len(p)\n\t\tj = 0\n\t\tdct = {}\n\t\tfor i in p:\n\t\t\tif i in dct:\n\t\t\t\tdct[i] += 1\n\t\t\t\tarr2[j] = dct[i]\n\t\t\telse:\n\t\t\t\tarr2[j] = 1\n\t\t\t\tdct[i] = 1\n\t\t\tj += 1\n\t\tif arr == arr2:\n\t\t\tans.append(p)\n\treturn ans\n", "def findSpecificPattern(Dict, pattern):\n\tres = []\n\n\tdef helper(pattern, elem):\n\t\td = {}\n\t\tn = len(pattern)\n\t\tif n != len(elem):\n\t\t\treturn\n\t\tfor i in range(n):\n\t\t\tif pattern[i] in d and elem[i] != d[pattern[i]]:\n\t\t\t\tbreak\n\t\t\telif pattern[i] not in d and elem[i] in d.values():\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\td[pattern[i]] = elem[i]\n\t\telse:\n\t\t\treturn elem\n\tfor x in Dict:\n\t\tif helper(pattern, x):\n\t\t\tres.append(helper(pattern, x))\n\treturn res\n", "def findSpecificPattern(Dict, pattern):\n\tlength = len(pattern)\n\thash = encodeString(pattern)\n\tresult = []\n\tfor word in Dict:\n\t\tif len(word) == length and encodeString(word) == hash:\n\t\t\tresult.append(word)\n\treturn result\n\ndef encodeString(Str):\n\tmap = {}\n\tres = ''\n\ti = 0\n\tfor ch in Str:\n\t\tif ch not in map:\n\t\t\tmap[ch] = i\n\t\t\ti += 1\n\t\tres += str(map[ch])\n\treturn res\n", "def encodeString(string):\n\tmap = {}\n\tres = ''\n\ti = 0\n\tfor ch in string:\n\t\tif ch not in map:\n\t\t\tmap[ch] = i\n\t\t\ti += 1\n\t\tres += str(map[ch])\n\treturn res\n\ndef findSpecificPattern(Dict, pattern):\n\tsize = len(pattern)\n\thash_map = encodeString(pattern)\n\toutput = []\n\tfor word in Dict:\n\t\tif len(word) == size and encodeString(word) == hash_map:\n\t\t\toutput.append(word)\n\treturn output\n", "def findSpecificPattern(Dict, pattern):\n\n\tdef encode(word):\n\t\tm = {}\n\t\ts = ''\n\t\tcounter = 0\n\t\tfor c in word:\n\t\t\tif c not in m:\n\t\t\t\tm[c] = counter\n\t\t\t\tcounter += 1\n\t\t\ts += str(m[c])\n\t\treturn s\n\tpattern_hash = encode(pattern)\n\tresult = []\n\tfor word in Dict:\n\t\tword_hash = encode(word)\n\t\tif pattern_hash == word_hash:\n\t\t\tresult.append(word)\n\treturn result\n", "def findSpecificPattern(Dict, pattern):\n\td = {}\n\tda = []\n\tp = 0\n\ts = set(pattern)\n\tfor i in Dict:\n\t\tif len(set(i)) == len(s):\n\t\t\tda.append(i)\n\tfor i in da:\n\t\tl1 = []\n\t\tl2 = []\n\t\tc = 0\n\t\tp += 1\n\t\tfor j in i:\n\t\t\tif l1 == []:\n\t\t\t\tl1.append(j)\n\t\t\t\tc += 1\n\t\t\telif l1[-1] == j:\n\t\t\t\tl1.append(j)\n\t\t\t\tc += 1\n\t\t\telif l1[-1] != j:\n\t\t\t\tl1.append(j)\n\t\t\t\tl2.append(c)\n\t\t\t\tc = 1\n\t\tif l1[-1] == i[-1]:\n\t\t\tl2.append(c)\n\t\t\tl2.insert(0, p)\n\t\t\tl2.insert(1, i)\n\t\telse:\n\t\t\tl2.append(1)\n\t\t\tl2.insert(0, p)\n\t\t\tl2.insert(1, i)\n\t\tif i not in d:\n\t\t\td[i] = [l2]\n\t\telse:\n\t\t\td[i].append(l2)\n\tk = []\n\tl11 = []\n\tl22 = []\n\tc1 = 0\n\tfor i in pattern:\n\t\tif l11 == []:\n\t\t\tl11.append(i)\n\t\t\tc1 += 1\n\t\telif l11[-1] == i:\n\t\t\tl11.append(i)\n\t\t\tc1 += 1\n\t\telif l11[-1] != i:\n\t\t\tl11.append(i)\n\t\t\tl22.append(c1)\n\t\t\tc1 = 1\n\tif l11[-1] == pattern[-1]:\n\t\tl22.append(c1)\n\telse:\n\t\tl22.append(1)\n\tk.append(l22)\n\tl3 = []\n\tl4 = []\n\tfor i in d:\n\t\tif d[i][0][2:] == k[-1]:\n\t\t\tl3.append(d[i][0] * len(d[i]))\n\tl3.sort()\n\tfor i in l3:\n\t\tl4 += [i[1]] * len(d[i[1]])\n\treturn l4\n", "from collections import OrderedDict\n\ndef findSpecificPattern(Dict, t):\n\tl = []\n\tn = len(t)\n\tfor j in Dict:\n\t\td = {}\n\t\tm = len(j)\n\t\tif m != n:\n\t\t\tcontinue\n\t\tflag = 1\n\t\tfor i in range(m):\n\t\t\tif j[i] not in d and t[i] not in d.values():\n\t\t\t\td[j[i]] = t[i]\n\t\t\telif j[i] in d and d[j[i]] != t[i]:\n\t\t\t\tflag = 0\n\t\t\telif j[i] not in d and t[i] in d.values():\n\t\t\t\tflag = 0\n\t\tif flag:\n\t\t\tl.append(j)\n\treturn l\n", "from collections import OrderedDict\n\ndef findSpecificPattern(Dict, pattern):\n\tl = []\n\tfor i in Dict:\n\t\tif len(i) != len(pattern) and len(set(i)) != len(set(pattern)):\n\t\t\tcontinue\n\t\telse:\n\t\t\ttemp = i\n\t\t\tfor j in list(zip(list(OrderedDict.fromkeys(temp)), list(OrderedDict.fromkeys(pattern)))):\n\t\t\t\ttemp = temp.replace(j[0], j[1])\n\t\t\tif temp == pattern:\n\t\t\t\tl.append(i)\n\treturn l\n", "def findSpecificPattern(Dict, pattern):\n\tlis = []\n\tfor i in range(len(Dict)):\n\t\tword = Dict[i]\n\t\tif len(set(word)) == len(set(pattern)) and len(word) == len(pattern):\n\t\t\tl = {}\n\t\t\tcheck = 1\n\t\t\tfor i in range(len(pattern)):\n\t\t\t\tif pattern[i] in l:\n\t\t\t\t\tif l[pattern[i]] != word[i]:\n\t\t\t\t\t\tcheck = 0\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tl[pattern[i]] = word[i]\n\t\t\tif check == 1:\n\t\t\t\tlis.append(word)\n\treturn lis\n", "def findSpecificPattern(Dict, pattern):\n\tpattern_mapp = {}\n\tpattern_str = ''\n\tfor (idx, char) in enumerate(pattern):\n\t\tif char not in pattern_mapp:\n\t\t\tpattern_mapp[char] = str(idx)\n\t\t\tpattern_str += str(idx)\n\t\telse:\n\t\t\tpattern_str += pattern_mapp[char]\n\thashes = []\n\tfor i in range(len(Dict)):\n\t\tdict_map = {}\n\t\thash = ''\n\t\tfor (idx, char) in enumerate(Dict[i]):\n\t\t\tif char not in dict_map:\n\t\t\t\tdict_map[char] = str(idx)\n\t\t\t\thash += str(idx)\n\t\t\telse:\n\t\t\t\thash += dict_map[char]\n\t\tif hash == pattern_str:\n\t\t\thashes.append(Dict[i])\n\treturn hashes\n", "def Pattern(pattern):\n\tcode = {}\n\tnum = 1\n\ttemp = ''\n\tfor i in range(len(pattern)):\n\t\tif not code.get(pattern[i]):\n\t\t\tcode[pattern[i]] = num\n\t\t\tnum += 1\n\t\telse:\n\t\t\tnum += 1\n\t\t\tcode[pattern[i]] = num\n\tfor i in pattern:\n\t\ttemp += str(code[i])\n\treturn temp\n\ndef findSpecificPattern(Dict, pattern):\n\tchecker = Pattern(pattern)\n\tli = []\n\tfor i in Dict:\n\t\ttemp = Pattern(i)\n\t\tif temp == checker:\n\t\t\tli.append(i)\n\treturn li\n", "def get_hashmap(stra):\n\thash_d = dict()\n\tfor k in range(len(stra)):\n\t\tif hash_d.get(stra[k]):\n\t\t\thash_d[stra[k]].append(k)\n\t\telse:\n\t\t\thash_d[stra[k]] = [k]\n\treturn set((tuple(i) for i in list(hash_d.values())))\n\ndef findSpecificPattern(Dict, pattern):\n\tarray_pat = []\n\thash_vals = get_hashmap(pattern)\n\tfor word in Dict:\n\t\tif get_hashmap(word) == hash_vals:\n\t\t\tarray_pat.append(word)\n\tarray_pat.sort()\n\treturn array_pat\n", "from collections import Counter\n\ndef findSpecificPattern(Dict, pattern):\n\tans = []\n\tdicpat = Counter(pattern)\n\tdicpatv = list(dicpat.values())\n\tfor i in range(0, len(Dict)):\n\t\tif len(Dict[i]) == len(pattern):\n\t\t\tdici = Counter(Dict[i])\n\t\t\tdicv = list(dici.values())\n\t\t\tif len(dicv) == len(dicpatv):\n\t\t\t\tfor j in range(0, len(dicv)):\n\t\t\t\t\tif dicv[j] != dicpatv[j]:\n\t\t\t\t\t\tdici = {}\n\t\t\t\t\t\tdiciv = []\n\t\t\t\t\t\tcontinue\n\t\t\t\tans.append(Dict[i])\n\t\t\t\tdici = {}\n\t\t\t\tdiciv = []\n\treturn ans\n", "def findSpecificPattern(Dict, pattern):\n\n\tdef getPattern(pattern):\n\t\tpatt_str = ''\n\t\tval_m = {}\n\t\tcount = 1\n\t\tfor val in pattern:\n\t\t\tif val in val_m:\n\t\t\t\tpatt_str += str(val_m[val])\n\t\t\telse:\n\t\t\t\tpatt_str += str(count)\n\t\t\t\tval_m[val] = count\n\t\t\t\tcount += 1\n\t\treturn patt_str\n\tresult = []\n\tmatch = getPattern(pattern)\n\tfor val in Dict:\n\t\tp = getPattern(val)\n\t\tif p == match:\n\t\t\tresult.append(val)\n\treturn result\n", "def findSpecificPattern(Dict, pattern):\n\tDict.append(pattern)\n\tres = []\n\tc = 0\n\tp = ''\n\ti = 0\n\tk = 0\n\tj = 0\n\tfor i in Dict:\n\t\twhile j < len(i):\n\t\t\tif j == len(i) - 1:\n\t\t\t\tp += str(c)\n\t\t\t\tj += 1\n\t\t\t\tc += 1\n\t\t\t\tbreak\n\t\t\twhile i[j] == i[j + 1]:\n\t\t\t\tp += str(c)\n\t\t\t\tk = 1\n\t\t\t\tj += 1\n\t\t\t\tif j == len(i) - 1:\n\t\t\t\t\tbreak\n\t\t\tif j == len(i) - 1:\n\t\t\t\tp += str(c)\n\t\t\t\tj += 1\n\t\t\t\tbreak\n\t\t\tp += str(c)\n\t\t\tj += 1\n\t\t\tc += 1\n\t\t\tk = 0\n\t\tres.append(p)\n\t\tp = ''\n\t\tj = 0\n\t\tc = 0\n\tp1 = res[-1]\n\tres1 = []\n\tres.pop()\n\tfor (i, j) in enumerate(res):\n\t\tif j == p1:\n\t\t\tres1.append(Dict[i])\n\treturn res1\n", "def findSpecificPattern(Dict, pattern):\n\tL = []\n\tn = 0\n\te = ''\n\tx = ''\n\tpattern = pattern + '.'\n\tfor i in pattern:\n\t\tif i == e:\n\t\t\tn += 1\n\t\telse:\n\t\t\tx = x + str(n)\n\t\t\tn = 1\n\t\t\te = i\n\tfor i in Dict:\n\t\tn = 0\n\t\te = ''\n\t\ty = ''\n\t\ti = i + '.'\n\t\tfor j in i:\n\t\t\tif j == e:\n\t\t\t\tn += 1\n\t\t\telse:\n\t\t\t\ty = y + str(n)\n\t\t\t\tn = 1\n\t\t\t\te = j\n\t\tif y == x:\n\t\t\tL.append(i[:-1])\n\treturn L\n", "def findSpecificPattern(Dict, pattern):\n\tresult = []\n\tfor word in Dict:\n\t\thash = {}\n\t\tflag = True\n\t\tif len(word) != len(pattern):\n\t\t\tcontinue\n\t\tfor (i, c) in enumerate(pattern):\n\t\t\tif c not in hash:\n\t\t\t\thash[c] = word[i]\n\t\t\telif hash[c] != word[i]:\n\t\t\t\tflag = False\n\t\tif flag:\n\t\t\tresult.append(word)\n\treturn result\n", "def convert(p):\n\tm = {}\n\tr = ''\n\tfor i in p:\n\t\tif i not in m:\n\t\t\tm[i] = 1\n\t\telse:\n\t\t\tm[i] += 1\n\t\tr = r + str(m[i])\n\treturn r\n\ndef findSpecificPattern(Dict, pattern):\n\tans = []\n\tpat = convert(pattern)\n\tfor i in Dict:\n\t\tif convert(i) == pat:\n\t\t\tans.append(i)\n\treturn ans\n", "def findSpecificPattern(Dict, pattern):\n\tfrom collections import defaultdict, OrderedDict\n\t(dnew, dnew2) = (defaultdict(int), defaultdict(int))\n\t(dnew3, dnew4) = (OrderedDict(), OrderedDict())\n\t(L, res) = ([], [])\n\tfor i in Dict:\n\t\tif len(set(i)) == len(set(pattern)):\n\t\t\tL.append(i)\n\tfor i in range(len(pattern)):\n\t\tdnew[pattern[i]] += 1\n\t\tdnew3[pattern[i]] = dnew[pattern[i]]\n\tfor k in L:\n\t\tfor i in range(len(k)):\n\t\t\tdnew2[k[i]] += 1\n\t\t\tdnew4[k[i]] = dnew2[k[i]]\n\t\tif list(dnew4.values()) == list(dnew3.values()):\n\t\t\tres.append(k)\n\t\tdnew2 = defaultdict(int)\n\t\tdnew4 = OrderedDict()\n\treturn res\n", "def findSpecificPattern(dictt, pattern):\n\tres = []\n\n\tdef patterniser(strg):\n\t\td = dict()\n\t\tlst = []\n\t\tpointer = 1\n\t\tfor i in strg:\n\t\t\tif i not in d:\n\t\t\t\td[i] = pointer\n\t\t\t\tpointer += 1\n\t\t\tlst.append(d[i])\n\t\treturn lst\n\n\tdef checker(pat1, pat2):\n\t\tfor i in range(len(pat1)):\n\t\t\tif pat1[i] != pat2[i]:\n\t\t\t\treturn False\n\t\treturn True\n\tpat1 = patterniser(pattern)\n\tfor i in dictt:\n\t\tif len(i) == len(pattern):\n\t\t\tpat2 = patterniser(i)\n\t\t\tif checker(pat1, pat2):\n\t\t\t\tres.append(i)\n\treturn res\n", "def findSpecificPattern(Dict, pattern):\n\ta = {}\n\taa = []\n\tfor i in range(len(pattern)):\n\t\ttry:\n\t\t\tif a[pattern[i]] == 0:\n\t\t\t\tpass\n\t\texcept:\n\t\t\ta[pattern[i]] = 0\n\t\t\taa.append(pattern[i])\n\tpp = ''\n\tp = {}\n\tans = []\n\tfor i in range(len(aa)):\n\t\tp[aa[i]] = i\n\tfor i in range(len(pattern)):\n\t\tpp += str(p[pattern[i]])\n\tfor j in range(len(Dict)):\n\t\ta = {}\n\t\taa = []\n\t\tfor i in range(len(Dict[j])):\n\t\t\ttry:\n\t\t\t\tif a[Dict[j][i]] == 0:\n\t\t\t\t\tpass\n\t\t\texcept:\n\t\t\t\ta[Dict[j][i]] = 0\n\t\t\t\taa.append(Dict[j][i])\n\t\tppp = ''\n\t\tpo = {}\n\t\tfor i in range(len(aa)):\n\t\t\tpo[aa[i]] = i\n\t\tfor i in range(len(Dict[j])):\n\t\t\tppp += str(po[Dict[j][i]])\n\t\tif pp == ppp:\n\t\t\tans.append(Dict[j])\n\treturn ans\n", "def encodeString(Str):\n\tmap = {}\n\tres = ''\n\ti = 0\n\tfor ch in Str:\n\t\tif ch not in map:\n\t\t\tmap[ch] = i\n\t\t\ti += 1\n\t\tres += str(map[ch])\n\treturn res\n\ndef findSpecificPattern(Dict, pattern):\n\tl = []\n\tLen = len(pattern)\n\thash = encodeString(pattern)\n\tfor word in Dict:\n\t\tif len(word) == Len and encodeString(word) == hash:\n\t\t\tprint(word, end=' ')\n\treturn l\n", "def findSpecificPattern(Dict, pattern):\n\tdic1 = {}\n\tcount1 = []\n\tfor i in pattern:\n\t\tif i not in dic1:\n\t\t\tdic1[i] = 1\n\t\t\tcount1.append(dic1[i])\n\t\telse:\n\t\t\tdic1[i] += 1\n\t\t\tcount1.append(dic1[i])\n\tdic2 = {}\n\tcount2 = []\n\toutput = []\n\tfor x in Dict:\n\t\tfor y in x:\n\t\t\tif y not in dic2:\n\t\t\t\tdic2[y] = 1\n\t\t\t\tcount2.append(dic2[y])\n\t\t\telse:\n\t\t\t\tdic2[y] += 1\n\t\t\t\tcount2.append(dic2[y])\n\t\tif count1 == count2:\n\t\t\toutput.append(x)\n\t\tcount2 = []\n\t\tdic2 = {}\n\treturn output\n", "def ispattern(str1, pattern, n, p):\n\tif n != p:\n\t\treturn False\n\td = {}\n\tfor i in range(n):\n\t\tif str1[i] in d:\n\t\t\tval = d[str1[i]]\n\t\t\tif val != pattern[i]:\n\t\t\t\treturn False\n\t\telif pattern[i] not in d.values():\n\t\t\td[str1[i]] = pattern[i]\n\t\telse:\n\t\t\treturn False\n\treturn True\n\ndef findSpecificPattern(Dict, pattern):\n\tans = []\n\tp = len(pattern)\n\tfor i in Dict:\n\t\tif ispattern(i, pattern, len(i), p):\n\t\t\tans.append(i)\n\treturn ans\n", "def findSpecificPattern(Dict, pat):\n\tn = len(pat)\n\tc = 1\n\tl = []\n\tfor i in range(n - 1):\n\t\tif pat[i] == pat[i + 1]:\n\t\t\tc += 1\n\t\telse:\n\t\t\tl.append(c)\n\t\t\tc = 1\n\tl.append(c)\n\th = []\n\tfor i in Dict:\n\t\tc = 1\n\t\tb = []\n\t\tn = len(i)\n\t\tfor j in range(n - 1):\n\t\t\tif i[j] == i[j + 1]:\n\t\t\t\tc += 1\n\t\t\telse:\n\t\t\t\tb.append(c)\n\t\t\t\tc = 1\n\t\tb.append(c)\n\t\tif b == l:\n\t\t\th.append(i)\n\treturn h\n", "def hashmap(Strng):\n\tDic = {}\n\tfor i in Strng:\n\t\tif i not in Dic:\n\t\t\tDic[i] = 1\n\t\telse:\n\t\t\tDic[i] += 1\n\treturn Dic\n\ndef findSpecificPattern(Dict, pattern):\n\tkiss = []\n\tk = 0\n\tcont = 0\n\tptr = {}\n\tfor i in pattern:\n\t\tif i not in ptr:\n\t\t\tptr[i] = 1\n\t\telse:\n\t\t\tptr[i] += 1\n\tlptrn = len(ptr)\n\twhile k < len(Dict):\n\t\tj = hashmap(Dict[k])\n\t\tldic = len(j)\n\t\tif lptrn == ldic:\n\t\t\tif list(ptr.values()) == list(j.values()):\n\t\t\t\tkiss.append(Dict[k])\n\t\tk += 1\n\treturn kiss\n", "def search(s, n):\n\tdp = [1] * n\n\tfor i in range(1, n):\n\t\tif s[i - 1] == s[i]:\n\t\t\tdp[i] = dp[i - 1] + 1\n\treturn dp\n\ndef findSpecificPattern(Dict, pattern):\n\tp_dp = search(pattern, len(pattern))\n\tans = []\n\tfor i in Dict:\n\t\tif search(i, len(i)) == p_dp:\n\t\t\tans.append(i)\n\treturn ans\n", "def findSpecificPattern(Dict, pattern):\n\tn = len(pattern)\n\tdp = [1] * n\n\tfor i in range(1, n):\n\t\tif pattern[i - 1] == pattern[i]:\n\t\t\tdp[i] = dp[i - 1] + 1\n\tans = []\n\tfor i in Dict:\n\t\tp = [1] * len(i)\n\t\tfor j in range(1, len(i)):\n\t\t\tif i[j - 1] == i[j]:\n\t\t\t\tp[j] = p[j - 1] + 1\n\t\tif dp == p:\n\t\t\tans.append(i)\n\treturn ans\n", "def findSpecificPattern(Dict, pattern):\n\tans = []\n\tfor word in Dict:\n\t\tchar1ToChar2 = {}\n\t\tchar2ToChar1 = {}\n\t\tif len(word) == len(pattern):\n\t\t\tfor (c1, c2) in zip(word, pattern):\n\t\t\t\tif c1 in char1ToChar2 and char1ToChar2[c1] != c2:\n\t\t\t\t\tbreak\n\t\t\t\tif c2 in char2ToChar1 and char2ToChar1[c2] != c1:\n\t\t\t\t\tbreak\n\t\t\t\tchar1ToChar2[c1] = c2\n\t\t\t\tchar2ToChar1[c2] = c1\n\t\t\telse:\n\t\t\t\tans.append(word)\n\treturn ans\n", "def findSpecificPattern(Dict, pattern):\n\tans = []\n\tfor word in Dict:\n\t\th = {}\n\t\tflag = 1\n\t\tif len(word) == len(pattern):\n\t\t\tfor (i, j) in zip(pattern, word):\n\t\t\t\tif i not in h:\n\t\t\t\t\th[i] = j\n\t\t\t\telif h[i] != j:\n\t\t\t\t\tflag = 0\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tflag = 0\n\t\tif flag:\n\t\t\tans.append(word)\n\treturn ans\n", "def findSpecificPattern(Dict, pattern):\n\tpattern_map = {}\n\tfor i in range(len(pattern)):\n\t\tif pattern[i] not in pattern_map:\n\t\t\tpattern_map[pattern[i]] = 1\n\t\telse:\n\t\t\tpattern_map[pattern[i]] += 1\n\tpattern_string = ''\n\tvalues = sorted(pattern_map.values())\n\tfor things in values:\n\t\tpattern_string += str(things)\n\tres = []\n\tfor words in Dict:\n\t\tdict_map = {}\n\t\tfor j in range(len(words)):\n\t\t\tif words[j] not in dict_map:\n\t\t\t\tdict_map[words[j]] = 1\n\t\t\telse:\n\t\t\t\tdict_map[words[j]] += 1\n\t\tdict_string = ''\n\t\tvalues2 = sorted(dict_map.values())\n\t\tfor things2 in values2:\n\t\t\tdict_string += str(things2)\n\t\tif len(words) == len(pattern) and pattern_string == dict_string:\n\t\t\tres.append(words)\n\treturn res\n", "def findSpecificPattern(Dict, pattern):\n\tmap_pattern = {}\n\tfor i in range(len(pattern)):\n\t\tif pattern[i] not in map_pattern:\n\t\t\tmap_pattern[pattern[i]] = 1\n\t\telse:\n\t\t\tmap_pattern[pattern[i]] += 1\n\tpattern_string = ''\n\tvalues = sorted(map_pattern.values())\n\tfor things in values:\n\t\tpattern_string += str(things)\n\tres = []\n\tfor element in Dict:\n\t\tdict_map = {}\n\t\tfor i in range(len(element)):\n\t\t\tif element[i] not in dict_map:\n\t\t\t\tdict_map[element[i]] = 1\n\t\t\telse:\n\t\t\t\tdict_map[element[i]] += 1\n\t\tdict_string = ''\n\t\tvalues1 = sorted(dict_map.values())\n\t\tfor things2 in values1:\n\t\t\tdict_string += str(things2)\n\t\tif len(element) == len(pattern) and pattern_string == dict_string:\n\t\t\tres.append(element)\n\treturn res\n", "def get_pattern(s):\n\td = {}\n\tc = 0\n\tunique = []\n\tfor i in range(len(s)):\n\t\tif s[i] not in unique:\n\t\t\tc += 1\n\t\t\tunique.append(s[i])\n\t\t\td[c] = [i]\n\t\telse:\n\t\t\td[c].append(i)\n\treturn d\n\ndef findSpecificPattern(Dict, pattern):\n\tgolden = get_pattern(pattern)\n\tans = []\n\tfor i in Dict:\n\t\ttemp = get_pattern(i)\n\t\tif temp == golden:\n\t\t\tans.append(i)\n\treturn ans\n", "def findSpecificPattern(Dict, pattern):\n\tl = len(pattern)\n\tarr = [0] * l\n\tarr[0] = 1\n\tfor i in range(1, l):\n\t\tif pattern[i] == pattern[i - 1]:\n\t\t\tarr[i] = 1 + arr[i - 1]\n\t\telse:\n\t\t\tarr[i] = 1\n\tlst = []\n\tfor i in range(len(Dict)):\n\t\tif len(Dict[i]) == l:\n\t\t\tb = [0] * l\n\t\t\tb[0] = 1\n\t\t\tfor j in range(1, l):\n\t\t\t\tif Dict[i][j] == Dict[i][j - 1]:\n\t\t\t\t\tb[j] = 1 + b[j - 1]\n\t\t\t\telse:\n\t\t\t\t\tb[j] = 1\n\t\t\tif b == arr:\n\t\t\t\tlst.append(Dict[i])\n\tlst.sort()\n\treturn lst\n", "def check_isomorphic(str1, str2):\n\tif len(str1) != len(str2):\n\t\treturn False\n\tmap = {}\n\tfor i in range(len(str1)):\n\t\tif str1[i] in map:\n\t\t\tif map[str1[i]] != str2[i]:\n\t\t\t\treturn False\n\t\telif str2[i] not in map.values():\n\t\t\tmap[str1[i]] = str2[i]\n\t\telse:\n\t\t\treturn False\n\treturn True\n\ndef findSpecificPattern(Dict, pattern):\n\tres = []\n\tN = len(Dict)\n\tfor i in range(N):\n\t\tif check_isomorphic(Dict[i], pattern):\n\t\t\tres.append(Dict[i])\n\treturn res\n", "from collections import Counter\n\ndef findSpecificPattern(dic, pattern):\n\tn = len(pattern)\n\tmp = [0] * n\n\tmp[0] = 1\n\tfor i in range(1, n):\n\t\tif pattern[i] == pattern[i - 1]:\n\t\t\tmp[i] = 1 + mp[i - 1]\n\t\telse:\n\t\t\tmp[i] = 1\n\tres = []\n\tfor i in range(len(dic)):\n\t\tif len(dic[i]) == n:\n\t\t\tk = [0] * n\n\t\t\tk[0] = 1\n\t\t\tfor j in range(1, n):\n\t\t\t\tif dic[i][j] == dic[i][j - 1]:\n\t\t\t\t\tk[j] = 1 + k[j - 1]\n\t\t\t\telse:\n\t\t\t\t\tk[j] = 1\n\t\t\tif k == mp:\n\t\t\t\tres.append(dic[i])\n\tres.sort()\n\treturn res\n", "def findSpecificPattern(dict, pattern):\n\ttemp = {}\n\ttpat = ''\n\tfor i in range(len(pattern)):\n\t\tif pattern[i] in temp:\n\t\t\ttpat += temp[pattern[i]]\n\t\telse:\n\t\t\ttemp[pattern[i]] = str(len(temp))\n\t\t\ttpat += str(len(temp))\n\tdictp = [''] * len(dict)\n\tfor i in range(len(dict)):\n\t\ttemp = {}\n\t\ttpt = ''\n\t\tfor k in range(len(dict[i])):\n\t\t\tif dict[i][k] in temp:\n\t\t\t\ttpt += temp[dict[i][k]]\n\t\t\telse:\n\t\t\t\ttemp[dict[i][k]] = str(len(temp))\n\t\t\t\ttpt += str(len(temp))\n\t\tdictp[i] = tpt\n\tans = []\n\tfor i in range(len(dict)):\n\t\tif dictp[i] == tpat:\n\t\t\tans.append(dict[i])\n\treturn ans\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def findSpecificPattern(Dict, pattern):\n\td = {}\n\tl = []\n\tfor i in range(len(Dict)):\n\t\tflag = 0\n\t\tfor j in range(len(Dict[i])):\n\t\t\tif len(Dict[i]) != len(pattern):\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\ttry:\n\t\t\t\tif pattern[j] not in d:\n\t\t\t\t\td[pattern[j]] = Dict[i][j]\n\t\t\t\telif d[pattern[j]] != Dict[i][j]:\n\t\t\t\t\tflag = 1\n\t\t\t\t\tbreak\n\t\t\texcept:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\tif flag == 0:\n\t\t\tl.append(Dict[i])\n\t\td = {}\n\tl.sort()\n\treturn l\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "import functools\n\n@functools.lru_cache(maxsize=1000)\ndef is_isomorphic(pattern, word):\n\tn = len(pattern)\n\td1 = {}\n\tfor i in range(n):\n\t\tif pattern[i] not in d1:\n\t\t\td1[pattern[i]] = word[i]\n\t\telif d1[pattern[i]] != word[i]:\n\t\t\treturn False\n\tt1 = ''.join((d1[v] for v in pattern))\n\tif t1 != word:\n\t\treturn False\n\td1 = {}\n\tfor i in range(n):\n\t\tif word[i] not in d1:\n\t\t\td1[word[i]] = pattern[i]\n\t\telif d1[word[i]] != pattern[i]:\n\t\t\treturn False\n\tt1 = ''.join((d1[v] for v in word))\n\tif t1 != pattern:\n\t\treturn False\n\treturn True\n\ndef findSpecificPattern(Dict, pattern):\n\tn = len(pattern)\n\tres = []\n\tfor v in Dict:\n\t\tif len(v) != n:\n\t\t\tcontinue\n\t\telif len(v) == 1:\n\t\t\tres.append(v)\n\t\telif is_isomorphic(pattern, v):\n\t\t\tres.append(v)\n\treturn res\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def findSpecificPattern(a, pat):\n\tl = []\n\tfor i in a:\n\t\tm = {}\n\t\tn = {}\n\t\tif len(i) == len(pat):\n\t\t\tfor j in range(len(pat)):\n\t\t\t\tm[i[j]] = pat[j]\n\t\t\t\tn[pat[j]] = i[j]\n\t\t\tif list(m.keys()) == list(n.values()) and list(n.keys()) == list(m.values()):\n\t\t\t\tl.append(i)\n\treturn l\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def findSpecificPattern(d, p):\n\tl = []\n\tfor i in range(len(d)):\n\t\tf = 0\n\t\tfor j in range(len(p) - 1):\n\t\t\tif p[j] != p[j + 1] and len(d[i]) == len(p):\n\t\t\t\tif d[i][j] == d[i][j + 1]:\n\t\t\t\t\tf = 1\n\t\t\t\t\tbreak\n\t\t\telif p[j] == p[j + 1] and len(d[i]) == len(p):\n\t\t\t\tif d[i][j] != d[i][j + 1]:\n\t\t\t\t\tf = 1\n\t\t\t\t\tbreak\n\t\tif len(d[i]) == len(p):\n\t\t\tif f == 0:\n\t\t\t\tl.append(d[i])\n\treturn l\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def findSpecificPattern(Dict, pattern):\n\tl = []\n\tfor i in Dict:\n\t\tif len(set(i)) == len(set(pattern)) and len(i) == len(pattern):\n\t\t\tl.append(i)\n\treturn l\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def findSpecificPattern(Dict, pattern):\n\td = {}\n\th = {}\n\tres = ''\n\tx = ''\n\tb = []\n\tunique = 0\n\tu = 0\n\tj = 0\n\tk = 0\n\tfor i in range(len(pattern)):\n\t\tif pattern[i] not in d.keys():\n\t\t\td[pattern[i]] = 1\n\t\t\tunique += 1\n\t\t\ta = str(unique)\n\t\t\tres += a\n\t\telse:\n\t\t\ta = str(unique)\n\t\t\tres += a\n\tfor j in range(len(Dict)):\n\t\tif len(Dict[j]) > len(pattern):\n\t\t\tcontinue\n\t\tfor k in range(len(Dict[j])):\n\t\t\tif Dict[j][k] not in h.keys():\n\t\t\t\th[Dict[j][k]] = 1\n\t\t\t\tu += 1\n\t\t\t\ta = str(u)\n\t\t\t\tx += a\n\t\t\telse:\n\t\t\t\ta = str(u)\n\t\t\t\tx += a\n\t\tu = 0\n\t\th = {}\n\t\tif x == res:\n\t\t\tb.append(Dict[j])\n\t\tx = ''\n\tif len(b) >= 1:\n\t\treturn b\n\telse:\n\t\treturn -1\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def findSpecificPattern(Dict, pattern):\n\tl = []\n\tfor i in Dict:\n\t\tif len(i) == len(pattern):\n\t\t\td1 = {}\n\t\t\td2 = {}\n\t\t\ta = 0\n\t\t\tfor j in range(len(i)):\n\t\t\t\tif i[j] not in d1:\n\t\t\t\t\tif pattern[j] not in d2:\n\t\t\t\t\t\td1[i[j]] = pattern[j]\n\t\t\t\t\t\td2[pattern[j]] = i[j]\n\t\t\t\t\telse:\n\t\t\t\t\t\ta = -1\n\t\t\t\t\t\tbreak\n\t\t\t\telif d1[i[j]] != pattern[j]:\n\t\t\t\t\ta = -1\n\t\t\t\t\tbreak\n\t\t\tif a == 0:\n\t\t\t\tl.append(i)\n\tl.sort()\n\treturn l\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def findSpecificPattern(Dict, s):\n\ta = []\n\tfor i in s:\n\t\tif i not in a:\n\t\t\ta.append(i)\n\tfor i in range(len(a)):\n\t\ta[i] = s.count(a[i])\n\n\tdef check(m):\n\t\taa = []\n\t\tfor i in m:\n\t\t\tif i not in aa:\n\t\t\t\taa.append(i)\n\t\tfor i in range(len(aa)):\n\t\t\taa[i] = m.count(aa[i])\n\t\treturn aa\n\tfor i in Dict:\n\t\tif check(i) == a:\n\t\t\tprint(i, end=' ')\n\treturn []\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def findSpecificPattern(arr, p):\n\tl = len(p)\n\tpanku = []\n\tfor i in arr:\n\t\tk = ''\n\t\tfor j in range(1, len(i)):\n\t\t\tif i[j] == i[j - 1]:\n\t\t\t\tk += 's'\n\t\t\telse:\n\t\t\t\tk += 'n'\n\t\tpanku.append(k)\n\treq = ''\n\tans = []\n\tfor i in range(1, l):\n\t\tif p[i] == p[i - 1]:\n\t\t\treq += 's'\n\t\telse:\n\t\t\treq += 'n'\n\tfor i in range(len(arr)):\n\t\tif panku[i] == req:\n\t\t\tans.append(arr[i])\n\treturn ans\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def findSpecificPattern(Dict, pattern):\n\tpatternCount = []\n\tfor i in pattern:\n\t\tif i not in patternCount:\n\t\t\tpatternCount.append(i)\n\tfor i in range(len(patternCount)):\n\t\tpatternCount[i] = pattern.count(patternCount[i])\n\n\tdef checkDictStrCount(string):\n\t\tdictCount = []\n\t\tfor i in string:\n\t\t\tif i not in dictCount:\n\t\t\t\tdictCount.append(i)\n\t\tfor i in range(len(dictCount)):\n\t\t\tdictCount[i] = string.count(dictCount[i])\n\t\treturn dictCount\n\tfor string in Dict:\n\t\tif checkDictStrCount(string) == patternCount:\n\t\t\tprint(string, end=' ')\n\treturn []\n\ndef findSpecificPattern(Dict, pattern):\n\tmatchPatternStr = []\n\tfor i in Dict:\n\t\tif len(set(i)) == len(set(pattern)) and len(i) == len(pattern):\n\t\t\tmatchPatternStr.append(i)\n\treturn matchPatternStr\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "from collections import deque\n\ndef findSpecificPattern(d, p):\n\n\tdef check(p, w):\n\t\tif len(p) != len(w):\n\t\t\treturn False\n\t\tch = [0 for i in range(128)]\n\t\tfor i in range(len(p)):\n\t\t\tif ch[ord(p[i])] == 0:\n\t\t\t\tch[ord(p[i])] = w[i]\n\t\t\telif ch[ord(p[i])] != w[i]:\n\t\t\t\treturn False\n\t\treturn True\n\tres = deque()\n\tfor i in range(len(d)):\n\t\tif check(p, d[i]):\n\t\t\tres.append(d[i])\n\treturn res\n", "def findSpecificPattern(Dict, pattern):\n\tans = []\n\n\tdef counting(Str):\n\t\tmap = {}\n\t\tres = ''\n\t\ti = 0\n\t\tfor ch in Str:\n\t\t\tif ch not in map:\n\t\t\t\tmap[ch] = i\n\t\t\t\ti += 1\n\t\t\tres += str(map[ch])\n\t\treturn res\n\tfor word in Dict:\n\t\tpattern_res = counting(pattern)\n\t\tinitial = counting(word)\n\t\tif initial == pattern_res:\n\t\t\tans.append(word)\n\treturn ans\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def encode(word):\n\thashMap = {}\n\tresult = ''\n\ti = 1\n\tfor ch in word:\n\t\tif ch not in hashMap:\n\t\t\thashMap[ch] = i\n\t\t\ti = i + 1\n\t\tresult += str(hashMap[ch])\n\treturn result\n\ndef findSpecificPattern(Dict, pattern):\n\tfinal = []\n\tfor word in Dict:\n\t\tif len(word) == len(pattern) and encode(word) == encode(pattern):\n\t\t\tfinal.append(word)\n\treturn final\n", "def findSpecificPattern(Dict, pattern):\n\tlist = []\n\tpattern = get_hash(pattern)\n\tfor word in Dict:\n\t\tif get_hash(word) == pattern:\n\t\t\tlist.append(word)\n\treturn list\n\ndef get_hash(word):\n\thash = str()\n\tdict = {}\n\tfor (i, char) in enumerate(word):\n\t\tif not char in dict:\n\t\t\tdict[char] = str(i)\n\t\thash += dict[char]\n\treturn hash\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def getP(lis, pos, st):\n\tfor i in range(len(pos)):\n\t\tif st == lis[i]:\n\t\t\treturn pos[i]\n\ndef encodeString(string):\n\tlis = [-1 for x in range(len(string))]\n\tpos = [-1 for x in range(len(string))]\n\tres = ''\n\tp = 0\n\tk = 0\n\tfor i in string:\n\t\tif i not in lis:\n\t\t\tlis[k] = i\n\t\t\tpos[k] = p\n\t\t\tp += 1\n\t\telse:\n\t\t\tlis[k] = i\n\t\t\tpos[k] = getP(lis, pos, i)\n\t\tk += 1\n\tfor i in pos:\n\t\tres += str(i)\n\treturn res\n\ndef findSpecificPattern(arr, string):\n\tn = len(arr)\n\tres = []\n\ttt = encodeString(string)\n\tl = len(string)\n\tfor i in arr:\n\t\tif len(i) == l and tt == encodeString(i):\n\t\t\tres.append(i)\n\treturn res\nif __name__ == '__main__':\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\tarr = input().strip().split()\n\t\tstring = input().strip()\n\t\tres = findSpecificPattern(arr, string)\n\t\tfor i in res:\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n", "def findSpecificPattern(Dict, pattern):\n\tcount1 = 0\n\tcount2 = 0\n\tfor i in range(len(pattern) - 1):\n\t\tif pattern[i] != pattern[i + 1]:\n\t\t\tcount1 += 1\n\t\telse:\n\t\t\tcount2 += 1\n\ttemp = []\n\tfor i in Dict:\n\t\tcount3 = 0\n\t\tcount4 = 0\n\t\tfor j in range(len(i) - 1):\n\t\t\tif i[j] != i[j + 1]:\n\t\t\t\tcount3 += 1\n\t\t\telse:\n\t\t\t\tcount4 += 1\n\t\tif count1 == count3 and count2 == count4:\n\t\t\ttemp.append(i)\n\treturn temp\n", "from collections import defaultdict\n\ndef findSpecificPattern(Dict, pattern):\n\tres = []\n\tp = len(pattern)\n\tfor s in Dict:\n\t\tif len(s) != p:\n\t\t\tcontinue\n\t\td = defaultdict(str)\n\t\tflag = True\n\t\tfor i in range(p):\n\t\t\tif s[i] not in d.keys() and pattern[i] not in d.values():\n\t\t\t\td[s[i]] = pattern[i]\n\t\t\telif d[s[i]] == pattern[i]:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\tif flag == True:\n\t\t\tres.append(s)\n\treturn res\n", "def encode_helper(word):\n\tcount = 0\n\thelper_map = {}\n\ts = ''\n\tfor character in word:\n\t\tif character not in helper_map:\n\t\t\thelper_map[character] = count\n\t\t\tcount += 1\n\tfor character in word:\n\t\ts = s + str(helper_map[character])\n\treturn s\n\ndef findSpecificPattern(Dict, pattern):\n\tencoded_pattern = encode_helper(pattern)\n\tres = []\n\tfor i in Dict:\n\t\tif encoded_pattern == encode_helper(i):\n\t\t\tres.append(i)\n\treturn res\n", "def encode(word):\n\tcount = 0\n\tdit = {}\n\ts = ''\n\tfor i in word:\n\t\tif i not in dit:\n\t\t\tdit[i] = count\n\t\t\tcount += 1\n\tfor i in word:\n\t\ts = s + str(dit[i])\n\treturn s\n\ndef findSpecificPattern(Dict, pattern):\n\tl = []\n\tk = encode(pattern)\n\tfor i in Dict:\n\t\tans = encode(i)\n\t\tcheck = True\n\t\tif len(k) == len(ans):\n\t\t\tfor j in range(len(k)):\n\t\t\t\tif k[j] != ans[j]:\n\t\t\t\t\tcheck = False\n\t\t\t\t\tbreak\n\t\t\tif check:\n\t\t\t\tl.append(i)\n\treturn l\n", "def findSpecificPattern(Dict, pattern):\n\n\tdef makepattern(word):\n\t\tpr = -1\n\t\td = {}\n\t\tres = []\n\t\tfor c in word:\n\t\t\tif c in d:\n\t\t\t\tind = d[c]\n\t\t\telse:\n\t\t\t\td[c] = pr + 1\n\t\t\t\tpr += 1\n\t\t\tres.append(d[c])\n\t\treturn res\n\tans = []\n\tgiven_pattern = makepattern(pattern)\n\tfor word in Dict:\n\t\tif given_pattern == makepattern(word):\n\t\t\tans.append(word)\n\treturn ans\n"], "starter_code": "#Function should return a list/array containing the required words\n\n''' The function returns a  list of strings \npresent in the dictionary which matches\nthe string pattern.\nYou are required to complete this method '''\n\ndef findSpecificPattern(Dict, pattern):\n    #Code here", "input_output": {"fn_name": "findSpecificPattern", "inputs": ["N = 4\ndict[] = {abb,abc,xyz,xyy}\npattern  = foo"], "outputs": ["abb xyy"]}, "difficulty": "EASY", "raw_tags": ["Data Structures", "Strings", "Hash"], "name": null, "source": "geeksforgeeks", "tags": ["String algorithms", "Data structures"], "skill_types": ["Data structures"], "url": "https://practice.geeksforgeeks.org/problems/match-specific-pattern/1", "Expected Auxiliary Space": "O(N).", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N*K) (where K is the length of the pattern)."}
{"question": "Given a singly linked list, delete the middle of the linked list. If there are even nodes, then there would be two middle nodes, and you need to delete the second middle element. If the input linked list is NULL or has 1 node, then it should return NULL.\n\n**Your Task:**\nThe task is to complete the function `deleteMid()` which should delete the middle element from the linked list and return the head of the modified linked list. If the linked list is empty then it should return NULL.\n\n**Expected Time Complexity:** O(N).\n\n**Expected Auxiliary Space:** O(1).\n\n**Constraints:**\n- 1 <= N <= 1000\n- 1 <= value <= 1000", "solutions": ["def deleteMid(head):\n\ttemp = head\n\tc = 0\n\twhile temp != None:\n\t\tc += 1\n\t\ttemp = temp.next\n\tmid = c // 2 - 1\n\ti = 0\n\ttemp = head\n\twhile i < mid:\n\t\ttemp = temp.next\n\t\ti += 1\n\ttemp.next = temp.next.next\n\treturn head\n", "def deleteMid(head):\n\tif head.next == None or head == None:\n\t\treturn None\n\telif head.next.next == None:\n\t\thead.next = None\n\telse:\n\t\tp = head\n\t\tn = 1\n\t\twhile p.next != None:\n\t\t\tn += 1\n\t\t\tp = p.next\n\t\tm = n // 2\n\t\tn = 1\n\t\tp = head\n\t\twhile n != m:\n\t\t\tn += 1\n\t\t\tp = p.next\n\t\tp.next = p.next.next\n\treturn head\n", "def deleteMid(head):\n\tslow = head\n\tfast = head\n\tprev = None\n\twhile fast and fast.next:\n\t\tprev = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tprev.next = slow.next\n\tslow = None\n\treturn head\n", "def deleteMid(head):\n\ttemp = head\n\tsize = 0\n\twhile temp != None:\n\t\tsize += 1\n\t\ttemp = temp.next\n\treach = size // 2\n\ti = 0\n\ttemp = head\n\tprev = None\n\twhile temp != None and i < reach:\n\t\ti += 1\n\t\tprev = temp\n\t\ttemp = temp.next\n\tprev.next = temp.next\n\treturn head\n", "def deleteMid(head):\n\ttemp = head\n\tcount = 0\n\twhile temp != None:\n\t\tcount += 1\n\t\ttemp = temp.next\n\tif count % 2 == 0:\n\t\ti = 1\n\t\tj = count // 2\n\t\ttemp = head\n\t\tprev = None\n\t\twhile i < j + 1:\n\t\t\tprev = temp\n\t\t\ttemp = temp.next\n\t\t\ti += 1\n\t\tprev.next = temp.next\n\telse:\n\t\ti = 1\n\t\tj = count // 2\n\t\tprev = None\n\t\ttemp = head\n\t\twhile i <= j:\n\t\t\tprev = temp\n\t\t\ttemp = temp.next\n\t\t\ti += 1\n\t\tprev.next = temp.next\n\treturn head\n", "def deleteMid(head):\n\tn = 0\n\tm = head\n\twhile m != None:\n\t\tn += 1\n\t\tm = m.next\n\ta = head\n\tfor i in range(int(n / 2) - 1):\n\t\ta = a.next\n\ta.next = a.next.next\n\treturn head\n", "def deleteMid(head):\n\tif not head.next:\n\t\treturn\n\tslow = head\n\tfast = head.next.next\n\twhile fast and fast.next:\n\t\tfast = fast.next.next\n\t\tslow = slow.next\n\tslow.next = slow.next.next\n\treturn head\n", "def deleteMid(head):\n\tif head == None or head.next == None:\n\t\treturn None\n\tprev = head\n\tslow = head\n\tfast = head\n\twhile fast.next != None and fast.next.next != None:\n\t\tprev = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tif fast.next == None:\n\t\tprev.next = slow.next\n\telse:\n\t\tslow.next = slow.next.next\n\treturn head\n", "def deleteMid(head):\n\tif head == None or head.next == None:\n\t\treturn head\n\tfast_pointer = head\n\tprev_of_slow = None\n\tslow_pointer = head\n\twhile fast_pointer != None and fast_pointer.next != None:\n\t\tprev_of_slow = slow_pointer\n\t\tslow_pointer = slow_pointer.next\n\t\tfast_pointer = fast_pointer.next.next\n\tprev_of_slow.next = slow_pointer.next\n\treturn head\n", "def deleteMid(head):\n\tslow = head\n\tfast = head\n\tprev = head\n\tif fast.next is None:\n\t\treturn None\n\twhile fast and fast.next:\n\t\tprev = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tprev.next = slow.next\n\treturn head\n", "def deleteMid(head):\n\tlength = 0\n\tdummy = head\n\twhile dummy:\n\t\tdummy = dummy.next\n\t\tlength += 1\n\tif not head or length == 1:\n\t\treturn None\n\tdummy = head\n\tk = length // 2\n\twhile k - 1 > 0:\n\t\tdummy = dummy.next\n\t\tk -= 1\n\tx = dummy.next.next\n\tdummy.next = x\n\treturn head\n", "def deleteMid(head):\n\tif head == None:\n\t\treturn None\n\tif head.next == None:\n\t\tdel head\n\t\treturn None\n\ttemp = head\n\tcnt = 0\n\twhile temp:\n\t\ttemp = temp.next\n\t\tcnt = cnt + 1\n\tmid = cnt // 2\n\ttemp = head\n\tk = 1\n\twhile temp:\n\t\tif k == mid:\n\t\t\ttemp.next = temp.next.next\n\t\ttemp = temp.next\n\t\tk = k + 1\n\treturn head\n", "def deleteMid(head):\n\tif head is None or head.next is None:\n\t\treturn None\n\tcount = 0\n\tfast = head\n\twhile fast.next is not None:\n\t\tcount += 1\n\t\tfast = fast.next\n\tfast = head\n\tmid = count / 2\n\tloc = 0\n\twhile loc < mid - 1:\n\t\tloc += 1\n\t\tfast = fast.next\n\ttempNode = None\n\ttempNode = fast.next\n\tif tempNode is None:\n\t\tfast.next = None\n\telse:\n\t\tfast.next = tempNode.next\n\treturn head\n", "def deleteMid(head):\n\tnew = head\n\ti = 1\n\twhile new.next != None:\n\t\ti = i + 1\n\t\tnew = new.next\n\ti = i // 2\n\tj = 1\n\tnew = head\n\twhile j < i:\n\t\tnew = new.next\n\t\tj = j + 1\n\tnew.next = new.next.next\n\treturn head\n", "def deleteMid(head):\n\ttemp = head\n\tcount = 0\n\twhile temp:\n\t\tcount += 1\n\t\ttemp = temp.next\n\ttemp = head\n\tcount = count // 2\n\twhile count:\n\t\tprev = temp\n\t\ttemp = temp.next\n\t\tcount -= 1\n\tprev.next = temp.next\n\treturn head\n", "def deleteMid(head):\n\tif head == None or head.next == None:\n\t\treturn None\n\telse:\n\t\tp = head\n\t\tq = head\n\t\tprev = None\n\t\twhile q and q.next:\n\t\t\tprev = p\n\t\t\tp = p.next\n\t\t\tq = q.next.next\n\t\tif p != None:\n\t\t\tprev.next = p.next\n\t\treturn head\n", "def getmidprev(head):\n\tprev = None\n\t(slow, fast) = (head, head)\n\twhile fast is not None and fast.next is not None:\n\t\tprev = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\treturn prev\n\ndef deleteMid(head):\n\tmidprev = getmidprev(head)\n\tif midprev is None:\n\t\treturn None\n\tmidprev.next = midprev.next.next\n\treturn head\n", "def deleteMid(head):\n\tcur = head\n\tfast = head\n\tprev = Node(0)\n\th = prev\n\tprev.next = cur\n\twhile fast and fast.next:\n\t\tcur = cur.next\n\t\tprev = prev.next\n\t\tfast = fast.next.next\n\tprev.next = cur.next\n\treturn h.next\n", "def deleteMid(head):\n\tslow = head\n\tfast = head.next.next\n\twhile fast and fast.next:\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tslow.next = slow.next.next\n\treturn head\n", "def deleteMid(head):\n\tif head.next is None:\n\t\treturn None\n\ttemp = head\n\tlen = 0\n\twhile temp:\n\t\tlen += 1\n\t\ttemp = temp.next\n\ttemp = head\n\tfor i in range(len // 2 - 1):\n\t\ttemp = temp.next\n\tnode2Del = temp.next\n\ttemp.next = temp.next.next\n\tnode2Del.next = None\n\treturn head\n", "def deleteMid(head):\n\tslow = head\n\tfast = head.next\n\twhile fast.next and fast.next.next:\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\ttemp = slow.next\n\tslow.next = temp.next\n\tdel temp\n\treturn head\n", "def deleteMid(head):\n\tfast = slow = head\n\tpre = None\n\twhile fast and fast.next:\n\t\tpre = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tpre.next = pre.next.next\n\treturn head\n", "def deleteMid(head):\n\tif not head or not head.next:\n\t\treturn None\n\t(ptr1, ptr2) = (head, head.next)\n\twhile ptr2 and ptr2.next:\n\t\tptr1 = ptr1.next\n\t\tptr2 = ptr2.next.next if ptr2.next else ptr2.next\n\tptr1.data = ptr1.data if ptr2 else ptr1.next.data\n\tptr1.next = ptr1.next.next\n\treturn head\n", "def deleteMid(head):\n\tcur = head\n\tcount = n = 0\n\twhile cur:\n\t\tcount = count + 1\n\t\tcur = cur.next\n\tif count == 0 or count == 1:\n\t\treturn NULL\n\tif count % 2 == 0:\n\t\tcur = head\n\t\twhile n != count / 2 - 1:\n\t\t\tn = n + 1\n\t\t\tcur = cur.next\n\t\ttemp = cur.next\n\t\tcur.next = cur.next.next\n\t\tdel temp\n\t\treturn head\n\telse:\n\t\tcur = head\n\t\twhile n != count // 2 - 1:\n\t\t\tn = n + 1\n\t\t\tcur = cur.next\n\t\ttemp = cur.next\n\t\tcur.next = cur.next.next\n\t\tdel temp\n\t\treturn head\n", "class Node:\n\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None\n\ndef deleteMid(head):\n\tif head is None or head.next is None:\n\t\treturn head\n\tslow_ptr = head\n\tfast_ptr = head.next.next\n\twhile fast_ptr is not None and fast_ptr.next is not None:\n\t\tslow_ptr = slow_ptr.next\n\t\tfast_ptr = fast_ptr.next.next\n\ttemp = slow_ptr.next\n\tslow_ptr.next = temp.next\n\ttemp = None\n\treturn head\n", "def deleteMid(head):\n\tif head.next == None:\n\t\treturn None\n\tif head.next.next == None:\n\t\thead.next = head.next.next\n\t\treturn head\n\tfast = head\n\tslow = head\n\twhile fast.next and fast.next.next:\n\t\tfast = fast.next.next\n\t\tslow = slow.next\n\tif fast.next:\n\t\tslow = slow.next\n\tslow.data = slow.next.data\n\tslow.next = slow.next.next\n\treturn head\n", "def deleteMid(head):\n\tif head is None or head.next is None:\n\t\treturn head\n\tcurr = head\n\tprev = head\n\tnext = None\n\twhile curr != None and curr.next != None:\n\t\tcurr = curr.next.next\n\t\tnext = prev\n\t\tprev = prev.next\n\tnext.next = prev.next\n\treturn head\n", "def deleteMid(head):\n\tslow = head\n\tfast = head\n\tdummy = Node(-1)\n\tdummy.next = head\n\tprev = dummy\n\twhile fast and fast.next:\n\t\tprev = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tprev.next = slow.next\n\treturn dummy.next\n", "def deleteMid(head):\n\tl = 0\n\ta = head\n\twhile a != None:\n\t\tl += 1\n\t\ta = a.next\n\tmid = l // 2\n\tl = 0\n\tprev = None\n\tcur = head\n\tfront = head.next\n\twhile l < mid:\n\t\tl += 1\n\t\tprev = cur\n\t\tcur = front\n\t\tfront = front.next\n\tprev.next = front\n\treturn head\n", "def deleteMid(head):\n\tp = head\n\tq = head\n\ttemp = None\n\twhile p and p.next:\n\t\ttemp = q\n\t\tq = q.next\n\t\tp = p.next.next\n\tif temp == None:\n\t\treturn None\n\ttemp.next = temp.next.next\n\treturn head\n", "def deleteMid(head):\n\tc = 0\n\ttemp = head\n\twhile temp:\n\t\tc += 1\n\t\ttemp = temp.next\n\tmid = c // 2\n\ttemp = head\n\tk = 1\n\twhile temp:\n\t\tif k == mid:\n\t\t\ttemp.next = temp.next.next\n\t\ttemp = temp.next\n\t\tk += 1\n\treturn head\n", "def deleteMid(head):\n\tc = 0\n\tcurr = head\n\twhile curr != None:\n\t\tc += 1\n\t\tcurr = curr.next\n\tcurr = head\n\tfor i in range(c // 2 - 1):\n\t\tcurr = curr.next\n\tcurr.next = curr.next.next\n\treturn head\n", "def deleteMid(head):\n\tfast = head\n\tslow = head\n\twhile fast != None and fast.next != None:\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tmid = slow\n\ttemp = head\n\twhile temp.next != mid:\n\t\ttemp = temp.next\n\tval = mid.next\n\ttemp.next = val\n\tmid = None\n\treturn head\n", "def deleteMid(head):\n\tstart = head\n\tlength = 0\n\twhile start != None:\n\t\tlength += 1\n\t\tstart = start.next\n\tmid = int(length / 2) + 1\n\tstart = 1\n\tstart_node = head\n\twhile start < mid - 1:\n\t\tstart += 1\n\t\tstart_node = start_node.next\n\tstart_node.next = start_node.next.next\n\treturn head\n", "def deleteMid(head):\n\tn = head\n\ti = 0\n\twhile n is not None:\n\t\ti = i + 1\n\t\tn = n.next\n\tx = i // 2\n\tif i - x == 1:\n\t\thead.next = None\n\telse:\n\t\tn = head\n\t\tfor i in range(0, x):\n\t\t\tn = n.next\n\t\tn.data = n.next.data\n\t\tn.next = n.next.next\n\treturn head\n", "def deleteMid(head):\n\tslow = fast = head\n\tt = None\n\twhile fast and fast.next:\n\t\ttmp = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\ttmp.next = slow.next\n\treturn head\n", "def deleteMid(head):\n\tpre = None\n\trabbit = head\n\ttortoise = head\n\twhile rabbit and rabbit.next:\n\t\tpre = tortoise\n\t\trabbit = rabbit.next.next\n\t\ttortoise = tortoise.next\n\tpre.next = tortoise.next\n\treturn head\n", "def deleteMid(head):\n\ttemp = head\n\tcount = 0\n\twhile temp:\n\t\tcount += 1\n\t\ttemp = temp.next\n\ttemp = head\n\tfor i in range(count // 2 - 1):\n\t\ttemp = temp.next\n\ttemp.next = temp.next.next\n\treturn head\n", "def deleteMid(head):\n\ttemp = head\n\tcount = 0\n\twhile temp != None:\n\t\tcount += 1\n\t\ttemp = temp.next\n\ttemp = head\n\tcount = count // 2\n\twhile count - 1:\n\t\ttemp = temp.next\n\t\tcount -= 1\n\ttemp.next = temp.next.next\n\treturn head\n", "def deleteMid(head):\n\tif head is None:\n\t\treturn head\n\tif head.next is None:\n\t\treturn None\n\tfast = slow = head\n\tpre = None\n\twhile fast and fast.next:\n\t\tfast = fast.next.next\n\t\tpre = slow\n\t\tslow = slow.next\n\tif pre is not None:\n\t\tpre.next = slow.next\n\treturn head\n", "def deleteMid(head):\n\tcount = 0\n\ttemp = head\n\tif head == None:\n\t\treturn head\n\tif head.next == None:\n\t\treturn None\n\twhile temp:\n\t\tcount += 1\n\t\ttemp = temp.next\n\tmid = count // 2\n\tst = head\n\twhile mid > 1:\n\t\tst = st.next\n\t\tmid = mid - 1\n\ttemp = st.next\n\tst.next = st.next.next\n\tdel temp\n\treturn head\n", "def deleteMid(head):\n\tslow = head\n\tfast = head\n\ttemp = None\n\twhile fast != None and fast.next != None:\n\t\ttemp = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tif temp == None:\n\t\treturn None\n\ttemp.next = temp.next.next\n\treturn head\n", "def deleteMid(head):\n\tif head is None:\n\t\treturn None\n\ttemp = head\n\ttemp2 = head\n\tcount = 0\n\twhile temp is not None:\n\t\tcount = count + 1\n\t\ttemp = temp.next\n\ti = 1\n\twhile i < count // 2:\n\t\ti = i + 1\n\t\ttemp2 = temp2.next\n\ttemp_next = temp2.next\n\ttemp2.next = temp_next.next\n\ttemp_next.next = None\n\treturn head\n", "def deleteMid(head):\n\tp = head\n\tc1 = 0\n\tc2 = 0\n\twhile p:\n\t\tc1 = c1 + 1\n\t\tp = p.next\n\tc3 = c1 // 2 + 1\n\tif c3 <= 1:\n\t\treturn None\n\tp = head\n\tq = None\n\twhile p:\n\t\tc2 = c2 + 1\n\t\tif c2 == c3:\n\t\t\tq.next = p.next\n\t\tq = p\n\t\tp = p.next\n\treturn head\n", "def deleteMid(head):\n\ttemp = head\n\tif head == None:\n\t\treturn head\n\tc = 0\n\twhile temp != None:\n\t\tc += 1\n\t\ttemp = temp.next\n\td = int(c / 2)\n\ttemp = head\n\tfor i in range(d - 1):\n\t\ttemp = temp.next\n\ttemp.next = temp.next.next\n\treturn head\n", "def deleteMid(head):\n\tfast = head\n\tslow = head\n\ttail = None\n\twhile fast != None and fast.next != None:\n\t\ttail = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\ttail.next = slow.next\n\tdel slow\n\treturn head\n", "def deleteMid(head):\n\tif head == None:\n\t\treturn None\n\tif head.next == None:\n\t\tdel head\n\t\treturn None\n\t(temp, count) = (head, 0)\n\twhile temp:\n\t\ttemp = temp.next\n\t\tcount += 1\n\tm = count // 2\n\t(temp, k) = (head, 1)\n\twhile temp:\n\t\tif k == m:\n\t\t\ttemp.next = temp.next.next\n\t\ttemp = temp.next\n\t\tk += 1\n\treturn head\n", "def deleteMid(head):\n\tslow = head\n\tfast = head\n\tnew = head\n\twhile fast.next and fast.next.next:\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tif fast.next:\n\t\tif fast.next.next == None:\n\t\t\tslow.next = slow.next.next\n\telse:\n\t\twhile new.next != slow:\n\t\t\tnew = new.next\n\t\tnew.next = new.next.next\n\treturn head\n", "def deleteMid(head):\n\tslow = head\n\tfast = head\n\tprev = Node(0)\n\twhile fast != None and fast.next != None:\n\t\tprev = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tprev.next = prev.next.next\n\treturn head\n", "def deleteMid(head):\n\tcur = head\n\tans = []\n\twhile cur:\n\t\tans.append(cur.data)\n\t\tcur = cur.next\n\tind = len(ans) // 2\n\tans.pop(ind)\n\tl = Node(0)\n\th = l\n\tfor i in ans:\n\t\tn = Node(i)\n\t\tl.next = n\n\t\tl = l.next\n\treturn h.next\n", "def deleteMid(head):\n\ttemp = head\n\tr = head\n\tcount = 0\n\twhile temp is not None:\n\t\ttemp = temp.next\n\t\tcount += 1\n\tfor i in range(count // 2 - 1):\n\t\thead = head.next\n\thead.next = head.next.next\n\treturn r\n", "def deleteMid(head):\n\tc = a = b = head\n\tb = b.next.next\n\twhile b and b.next:\n\t\ta = a.next\n\t\tb = b.next.next\n\ta.next = a.next.next\n\treturn c\n", "def deleteMid(head):\n\ti = 0\n\tt = head\n\twhile t:\n\t\tt = t.next\n\t\ti += 1\n\tt1 = head\n\tfor j in range(i):\n\t\tif j == i // 2 - 1:\n\t\t\tt1.next = t1.next.next\n\t\t\tbreak\n\t\tt1 = t1.next\n\treturn head\n", "def deleteMid(head):\n\tslow = head\n\tfast = head\n\tptr = None\n\tif head == None:\n\t\treturn None\n\twhile fast and fast.next:\n\t\tptr = slow\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tptr.next = slow.next\n\tslow.next = None\n\treturn head\n", "def deleteMid(head):\n\tcount = 0\n\tcurr = head\n\twhile curr is not None:\n\t\tcount += 1\n\t\tcurr = curr.next\n\tif count <= 1:\n\t\treturn None\n\tnodeToDel = count // 2 + 1\n\tcnt = 0\n\tcurr = head\n\twhile cnt < nodeToDel - 2:\n\t\tcnt += 1\n\t\tcurr = curr.next\n\tcurr.next = curr.next.next\n\treturn head\n", "def deleteMid(head):\n\tlst = []\n\twhile head:\n\t\tlst.append(head.data)\n\t\thead = head.next\n\tdel lst[len(lst) // 2]\n\ta = Node(0)\n\ttemp = a\n\tfor i in lst:\n\t\ttemp.next = Node(i)\n\t\ttemp = temp.next\n\treturn a.next\n", "def deleteMid(head):\n\tif head == None or head.next == None:\n\t\treturn None\n\ttemp = head\n\tlength = 0\n\twhile temp != None:\n\t\tlength += 1\n\t\ttemp = temp.next\n\tlength = length // 2\n\ti = 0\n\ttemp = head\n\tprev = None\n\twhile i < length:\n\t\tprev = temp\n\t\ttemp = temp.next\n\t\ti += 1\n\tprev.next = temp.next\n\ttemp.next = None\n\treturn head\n", "def deleteMid(head):\n\tc = length(head)\n\tmid = c // 2\n\titr = head\n\ti = 0\n\twhile itr:\n\t\tif mid - 1 == i:\n\t\t\titr.next = itr.next.next\n\t\ti += 1\n\t\titr = itr.next\n\treturn head\n\ndef length(head):\n\tc = 0\n\titr = head\n\twhile itr:\n\t\tc += 1\n\t\titr = itr.next\n\treturn c\n", "def deleteMid(head):\n\tif head == None:\n\t\treturn None\n\tif head.next == None:\n\t\tdel head\n\t\treturn None\n\tc = 0\n\tt = head\n\twhile t:\n\t\tc += 1\n\t\tt = t.next\n\tmid = c // 2\n\tt = head\n\tk = 1\n\twhile t:\n\t\tif k == mid:\n\t\t\tt.next = t.next.next\n\t\tt = t.next\n\t\tk += 1\n\treturn head\n", "def deleteMid(head):\n\tfast = slow = head\n\twhile fast and fast.next:\n\t\tfast = fast.next.next\n\t\tslow = slow.next\n\tcurr = head\n\twhile curr.next != slow:\n\t\tcurr = curr.next\n\tif slow.next is None:\n\t\tcurr.next = None\n\telse:\n\t\tcurr.next = slow.next\n\treturn head\n", "import math\n\ndef deleteMid(head):\n\tcount = 1\n\ttemp = head\n\twhile temp.next:\n\t\tcount += 1\n\t\ttemp = temp.next\n\tn = math.floor(count / 2)\n\ttemp1 = head\n\ti = 0\n\twhile i < n - 1:\n\t\ttemp1 = temp1.next\n\t\ti += 1\n\ttemp1.next = temp1.next.next\n\treturn head\n", "def deleteMid(head):\n\tif head is None:\n\t\treturn head\n\tif head.next is None:\n\t\treturn Null\n\ttemp = head\n\tc = 0\n\twhile temp:\n\t\tc += 1\n\t\ttemp = temp.next\n\tb = c // 2\n\ttemp = head\n\ti = 1\n\twhile temp:\n\t\tif i == b:\n\t\t\ttemp.next = temp.next.next\n\t\ttemp = temp.next\n\t\ti += 1\n\treturn head\n", "def deleteMid(head):\n\tstack = [head]\n\tcount = 0\n\twhile len(stack) > 0:\n\t\tcurrent = stack.pop()\n\t\tcount += 1\n\t\tif current.next:\n\t\t\tstack.append(current.next)\n\tif count > 1:\n\t\tstack.append(head)\n\t\tfor i in range(count // 2 - 1):\n\t\t\tcurrent = stack.pop()\n\t\t\tstack.append(current.next)\n\t\tcurrent = stack.pop()\n\t\tcurrent.next = current.next.next\n\t\treturn head\n\telse:\n\t\treturn None\n", "def deleteMid(head):\n\ttemp = head\n\tlength = 1\n\twhile temp.next:\n\t\ttemp = temp.next\n\t\tlength += 1\n\tmid = length // 2\n\ttemp = head\n\tk = 1\n\twhile temp:\n\t\tif k == mid:\n\t\t\ttemp.next = temp.next.next\n\t\ttemp = temp.next\n\t\tk += 1\n\treturn head\n", "def deleteMid(head):\n\tans = Node(123)\n\tp = ans\n\tp.next = head\n\ts = head\n\tf = head.next\n\twhile f and f.next:\n\t\tf = f.next.next\n\t\ts = s.next\n\t\tp = p.next\n\tif f:\n\t\ts.next = s.next.next\n\t\treturn ans.next\n\telif not f:\n\t\tp.next = p.next.next\n\t\treturn ans.next\n", "def deleteMid(head):\n\tdummy = Node(0)\n\tdummy.next = head\n\t(slow, fast) = (dummy, head)\n\twhile fast and fast.next:\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tslow.next = slow.next.next\n\treturn dummy.next\n", "def deleteMid(head):\n\tslow = head\n\tfast = head\n\twhile fast and fast.next:\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\tmid = slow\n\ttemp = head\n\twhile temp.next != mid:\n\t\ttemp = temp.next\n\ttemp.next = mid.next\n\treturn head\n"], "starter_code": "#User function Template for python3\n\n'''\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n'''\ndef deleteMid(head):\n    '''\n    head:  head of given linkedList\n    return: head of resultant llist\n    '''\n    \n    #code here\n", "input_output": {"inputs": ["LinkedList:1->2->3->4->5", "LinkedList:2->4->6->7->5->1"], "outputs": ["1 2 4 5", "2 4 6 5 1"]}, "difficulty": "EASY", "raw_tags": ["Data Structures", "Algorithms", "two-pointer-algorithm", "Linked List"], "name": null, "source": "geeksforgeeks", "tags": ["Data structures", "Amortized analysis"], "skill_types": ["Amortized analysis", "Data structures"], "url": "https://practice.geeksforgeeks.org/problems/delete-middle-of-linked-list/1", "Expected Auxiliary Space": "O(1).", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N)."}

{"requirement": "def kooka_counter(laughing: str) -> int:\n\"\"\"A family of kookaburras are in my backyard.\n\nI can't see them all, but I can hear them!\n\n# How many kookaburras are there?\n\n\n\n\n## Hint \n\nThe trick to counting kookaburras is to listen carefully\n\n* The males go ```HaHaHa```...\n\n* The females go ```hahaha```...\n\n* And they always alternate male/female\n\n\n\n^ Kata Note : No validation is necessary; only valid input will be passed :-)\n\"\"\"", "inputs": [[""], ["hahahahaha"], ["hahahahahaHaHaHa"], ["HaHaHahahaHaHa"], ["hahahahahahahaHaHa"]], "outputs": [[0], [1], [2], [3], [2]], "starter_code": "def kooka_counter(laughing: str) -> int:", "canonical_solution": "import re\n\ndef kooka_counter(laughing):\n    return len(re.findall('(ha)+|(Ha)+', laughing))", "entry_point": "kooka_counter", "task_id": "TACO_lite/54", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['HaHaHa'], ['hahaha'], ['HaHaHahahahaHaHaHa'], ['HaHaHahahahaHaHaHahahaha'], [''], ['Ha'], ['ha'], ['HahAhaHaHa']]", "qwen2.5-coder-32b-instruct": "[['Ha'], ['haha'], ['HaHa'], ['hahahaHaHa'], ['HaHaHaHaHa'], ['hahahaha'], [''], ['HaHaHaHaHaHaHaHa'], ['hahahahaha']]"}}
{"requirement": "from typing import List\n\n\ndef sorter(textbooks: List[str]) -> List[str]:\n\"\"\"HELP! Jason can't find his textbook! It is two days before the test date, and Jason's textbooks are all out of order! Help him sort a list (ArrayList in java) full of textbooks by subject, so he can study before the test.\n\nThe sorting should **NOT** be case sensitive\n\"\"\"", "inputs": [[["Algebra", "History", "Geometry", "English"]], [["Algebra", "history", "Geometry", "english"]], [["Alg#bra", "$istory", "Geom^try", "**english"]]], "outputs": [[["Algebra", "English", "Geometry", "History"]], [["Algebra", "english", "Geometry", "history"]], [["$istory", "**english", "Alg#bra", "Geom^try"]]], "starter_code": "from typing import List\ndef sorter(textbooks: List[str]) -> List[str]:", "canonical_solution": "def sorter(textbooks):\n    return sorted(textbooks, key=str.lower)", "entry_point": "sorter", "task_id": "TACO_lite/60", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[['Physics', 'math', 'Chemistry', 'biology']], [['math', 'physics', 'chemistry', 'biology']], [['PHYSICS', 'MATH', 'CHEMISTRY', 'BIOLOGY']], [['physics', 'MATH', 'chemistry', 'BIOLOGY']], [['math', 'Math', 'MATH', 'mAtH']], [[]], [['SingleSubject']], [['subject1', 'Subject1', 'SUBJECT1', 'sUbJeCt1']]]", "qwen2.5-coder-32b-instruct": "[[['Math', 'science', 'History', 'english']], [['Biology', 'chemistry', 'Physics', 'Geography']], [['math', 'Math', 'MATH', 'MaTh']], [['Art', 'art', 'ART', 'aRT']], [['Zoology', 'botany', 'Ecology', 'Genetics']], [[]], [['SingleSubject']]]"}}
{"requirement": "def beeramid(bonus: int, price: int) -> int:\n\"\"\"Let's pretend your company just hired your friend from college and paid you a referral bonus. Awesome! To celebrate, you're taking your team out to the terrible dive bar next door and using the referral bonus to buy, and build, the largest three-dimensional beer can pyramid you can. And then probably drink those beers, because let's pretend it's Friday too. \n\n\n\nA beer can pyramid will square the number of cans in each level - 1 can in the top level, 4 in the second, 9 in the next, 16, 25... \n\nComplete the beeramid function to return the number of **complete** levels of a beer can pyramid you can make, given the parameters of: \n\n1) your referral bonus, and\n\n2) the price of a beer can\n\nFor example:\n\"\"\"", "inputs": [[9, 2], [10, 2], [11, 2], [21, 1.5], [454, 5], [455, 5], [4, 4], [3, 4], [0, 4], [-1, 4]], "outputs": [[1], [2], [2], [3], [5], [6], [1], [0], [0], [0]], "starter_code": "def beeramid(bonus: int, price: int) -> int:", "canonical_solution": "def beeramid(bonus, price):\n    beers = bonus // price\n    levels = 0\n    while beers >= (levels + 1) ** 2:\n        levels += 1\n        beers -= levels ** 2\n    return levels", "entry_point": "beeramid", "task_id": "TACO_lite/66", "input_output_examples": "[[[1500, 2], [5000, 3]], [[12], [16]]]", "llm_generated_inputs": {"deepseek-v3": "[[10, 2], [0, 5], [100, 0], [55, 5], [1, 1], [100, 10], [50, 15], [100, 100], [1000000, 1], [10, 100]]", "qwen2.5-coder-32b-instruct": "[[100, 2], [5000, 3], [0, 5], [1, 1], [15, 1], [10, 10], [1000, 1], [22, 5], [14, 2], [36, 1]]"}}
{"requirement": "def valid_mersenne(n: int) -> bool:\n\"\"\"A [Mersenne prime](https://en.wikipedia.org/wiki/Mersenne_prime) is a prime number that can be represented as:\nMn = 2^(n) - 1. Therefore, every Mersenne prime is one less than a power of two. \n\nWrite a function that will return whether the given integer `n` will produce a Mersenne prime or not.\n\nThe tests will check random integers up to 2000.\n\"\"\"", "inputs": [[2], [3], [5], [7], [11], [13], [17], [19], [21], [23], [31], [49], [61], [89], [107], [127], [221], [521], [607], [1279]], "outputs": [[true], [true], [true], [true], [false], [true], [true], [true], [false], [false], [true], [false], [true], [true], [true], [true], [false], [true], [true], [true]], "starter_code": "def valid_mersenne(n: int) -> bool:", "canonical_solution": "def valid_mersenne(n):\n    return n in {2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279}", "entry_point": "valid_mersenne", "task_id": "TACO_lite/69", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[2], [3], [5], [7], [13], [4], [6], [1], [0], [-1], [2000]]", "qwen2.5-coder-32b-instruct": "[[2], [3], [5], [7], [13], [17], [19], [31], [61], [89], [107], [127], [521], [607], [1279], [2203], [2281], [3217], [4253], [4423], [9689], [1], [0], [-1], [4], [6], [10], [20], [2000]]"}}
{"requirement": "from typing import List\n\n\ndef mean_vs_median(numbers: List[float]) -> str:\n\"\"\"Your goal is to implement the method **meanVsMedian** which accepts an *odd-length* array of integers and returns one of the following:\n\n* 'mean' - in case **mean** value is **larger than** median value\n* 'median' - in case **median** value is **larger than** mean value\n* 'same' - in case both mean and median share the **same value**\n\nReminder: [Median](https://en.wikipedia.org/wiki/Median)\n\nArray will always be valid (odd-length >= 3)\n\"\"\"", "inputs": [[[1, 1, 1]], [[1, 2, 37]], [[7, 14, -70]], [[-10, 20, 5]]], "outputs": [["same"], ["mean"], ["median"], ["same"]], "starter_code": "from typing import List\ndef mean_vs_median(numbers: List[float]) -> str:", "canonical_solution": "from numpy import mean, median\n\ndef mean_vs_median(numbers):\n    if mean(numbers) > median(numbers):\n        return 'mean'\n    elif mean(numbers) < median(numbers):\n        return 'median'\n    else:\n        return 'same'", "entry_point": "mean_vs_median", "task_id": "TACO_lite/74", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3]], [[1, 3, 5]], [[1, 2, 100]], [[1, 99, 100]], [[10, 20, 30, 40, 50]], [[0, 0, 0, 0, 0]], [[-1, 0, 1]], [[-100, 0, 100]], [[1, 1, 2, 3, 5, 8, 13]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3]], [[3, 1, 2]], [[5, 5, 5]], [[10, 20, 30, 40, 50]], [[1, 1, 1, 1, 99]], [[100, 2, 3, 4, 5]], [[7, 8, 9, 10, 11]], [[1, 3, 3, 6, 7, 8, 9]], [[1, 2, 3, 4, 100]], [[1.5, 2.5, 3.5]]]"}}
{"requirement": "def tops(msg: str) -> str:\n\"\"\"# Task\n\nWrite a function that accepts `msg` string and returns local tops of string from the highest to the lowest.  \nThe string's tops are from displaying the string in the below way:\n\n\n\n```\n\n                                         7891012\n                             TUWvXY      6     3\n                   ABCDE     S    Z      5\n           lmno    z   F     R    1      4\n     abc   k  p    v   G     Q    2      3\n.34..9 d...j  q....x   H.....P    3......2\n125678 efghi  rstuwy   IJKLMNO    45678901\n\n```\nThe next top is always 1 character higher than the previous one. \nFor the above example, the solution for the `123456789abcdefghijklmnopqrstuwyxvzABCDEFGHIJKLMNOPQRSTUWvXYZ123456789012345678910123` input string is `7891012TUWvXYABCDElmnoabc34`. \n\n- When the `msg` string is empty, return an empty string.\n- The input strings may be very long. Make sure your solution has good performance.\n- The (.)dots on the sample dispaly of string are only there to help you to understand the pattern  \n\nCheck the test cases for more samples.\n\n# Series\n\n- [String tops](https://www.codewars.com/kata/59b7571bbf10a48c75000070)\n- [Square string tops](https://www.codewars.com/kata/5aa3e2b0373c2e4b420009af)\n\"\"\"", "inputs": [[""], ["abcde"], ["123456789abcdefghijklmnopqrstuwyxvzABCDEFGHIJKLMNOPQRSTU"], ["123456789abcdefghijklmnopqrstuwyxvzABCDEFGHIJKLMNOPQRSTUWvXYZ123456789012345678910123"]], "outputs": [[""], ["cd"], ["TUABCDElmnoabc34"], ["7891012TUWvXYABCDElmnoabc34"]], "starter_code": "def tops(msg: str) -> str:", "canonical_solution": "def tops(msg):\n    n = len(msg)\n    res, i, j, k = ('', 2, 2, 7)\n    while i < n:\n        res = msg[i:i + j] + res\n        i, j, k = (i + k, j + 1, k + 4)\n    return res", "entry_point": "tops", "task_id": "TACO_lite/81", "input_output_examples": "[[['123456789abcdefghijklmnopqrstuwyxvzABCDEFGHIJKLMNOPQRSTUWvXYZ123456789012345678910123'], ['']], [['7891012TUWvXYABCDElmnoabc34'], ['']]]", "llm_generated_inputs": {"deepseek-v3": "[['123456789abcdefghijklmnopqrstuwyxvzABCDEFGHIJKLMNOPQRSTUWvXYZ123456789012345678910123'], ['abcdefghijklmnopqrstuvwxyz'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZ'], ['1234567890'], ['!@#$%^&*()'], ['a'], ['ab'], ['abc'], ['abcd'], ['abcde'], ['abcdef'], [''], ['Lorem ipsum dolor sit amet, consectetur adipiscing elit.'], ['1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()'], [\"This is a very long string with multiple words and characters to test the function's performance.\"]]", "qwen2.5-coder-32b-instruct": "[[''], ['123456789abcdefghijklmnopqrstuwyxvzABCDEFGHIJKLMNOPQRSTUWvXYZ123456789012345678910123'], ['a'], ['abcdefghijklmnopqrstuvwxyz'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZ'], ['1234567890'], ['..................................................................................'], ['aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'], ['12345678901234567890123456789012345678901234567890'], ['1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ']]"}}
{"requirement": "def sort_string(s: str) -> str:\n\"\"\"# Task\n\nYour task is to sort the characters in a string according to the following rules:\n```\n- Rule1: English alphabets are arranged from A to Z, case insensitive.\n\n\n  ie. \"Type\" --> \"epTy\"\n- Rule2: If the uppercase and lowercase of an English alphabet exist\n  at the same time, they are arranged in the order of oringal input.\n  ie. \"BabA\" --> \"aABb\"\n- Rule3: non English alphabet remain in their original position.\n  ie. \"By?e\" --> \"Be?y\"\n```\n\n# Input/Output\n\n\n`[input]` string `s`\n\nA non empty string contains any characters(English alphabets or non English alphabets).\n\n`[output]` a string\n\nA sorted string according to the rules above.\n\n# Example\n\n\nFor `s = \"cba\"`, the output should be `\"abc\"`.\n\nFor `s = \"Cba\"`, the output should be `\"abC\"`.\n\nFor `s = \"cCBbAa\"`, the output should be `\"AaBbcC\"`.\n\nFor `s = \"c b a\"`, the output should be `\"a b c\"`.\n\nFor `s = \"-c--b--a-\"`, the output should be `\"-a--b--c-\"`.\n\nFor `s = \"Codewars\"`, the output should be `\"aCdeorsw\"`.\n\"\"\"", "inputs": [["a"], ["cba"], ["Cba"], ["cCBbAa"], ["!"], ["c b a"], ["-c--b--a-"], ["cbaCcC"], ["Codewars"], [" MkWD{RB=//k-^ J@,xH Vfi uAz+$ kV _[ }a!}%pSBwn !kKB (b  q PQF +}wS  .kfU r wFNEs#NsR UVMdG"]], "outputs": [["a"], ["abc"], ["abC"], ["AaBbcC"], ["!"], ["a b c"], ["-a--b--c-"], ["abcCcC"], ["aCdeorsw"], [" AaBB{Bb=//D-^ d@,Ef FfF GHi+$ Jk _[ }k!}%kkKkM !MnN (N  p PqQ +}Rr  .RSS s suUUV#VVW wwwxz"]], "starter_code": "def sort_string(s: str) -> str:", "canonical_solution": "def sort_string(s):\n    a = iter(sorted((c for c in s if c.isalpha()), key=str.lower))\n    return ''.join((next(a) if c.isalpha() else c for c in s))", "entry_point": "sort_string", "task_id": "TACO_lite/82", "input_output_examples": "[[['cba'], ['Cba'], ['cCBbAa'], ['c b a'], ['-c--b--a-'], ['Codewars']], [['abc'], ['abC'], ['AaBbcC'], ['a b c'], ['-a--b--c-'], ['aCdeorsw']]]", "llm_generated_inputs": {"deepseek-v3": "[['cba'], ['Cba'], ['cCBbAa'], ['c b a'], ['-c--b--a-'], ['Codewars'], ['Type'], ['BabA'], ['By?e'], ['123abc'], ['a1b2c3'], ['@#$%^&*()'], ['aA'], ['ZzYyXx'], ['Hello, World!'], ['The quick brown fox jumps over the lazy dog']]", "qwen2.5-coder-32b-instruct": "[['cba'], ['Cba'], ['cCBbAa'], ['c b a'], ['-c--b--a-'], ['Codewars'], ['Type'], ['BabA'], ['By?e'], ['123abcXYZ'], ['aA1!bB2@cC3#'], ['zZyYxXwWvVuUtTsSrRqQpPoOnNmMlLkKjJiIhHgGfFeEdDcCbBaA'], ['a'], ['A'], ['!'], ['aA'], ['Aa'], ['a!A'], ['A!a']]"}}
{"requirement": "def problem(a: int) -> int:\n\"\"\"Make a function that returns the value multiplied by 50 and increased by 6. If the value entered is a string it should return \"Error\".\n\nNote: in `C#`, you'll always get the input as a string, so the above applies if the string isn't representing a double value.\n\"\"\"", "inputs": [["hello"], [1], [5], [0], [1.2], [3], ["RyanIsCool"]], "outputs": [["Error"], [56], [256], [6], [66], [156], ["Error"]], "starter_code": "def problem(a: int) -> int:", "canonical_solution": "def problem(a):\n    try:\n        return a * 50 + 6\n    except TypeError:\n        return 'Error'", "entry_point": "problem", "task_id": "TACO_lite/87", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[5], [0], [-3], [10], ['hello'], ['123'], [True], [False], [3.14], ['3.14']]", "qwen2.5-coder-32b-instruct": "[[0], [1], [-1], [123], [-456], [1000], ['0'], ['1'], ['-1'], ['123'], ['-456'], ['1000'], ['abc'], ['12.34'], ['-56.78'], ['   '], [''], ['None'], ['True'], ['False']]"}}
{"requirement": "def shifted_diff(first: str, second: str) -> int:\n\"\"\"Write a function that receives two strings and returns n, where n is equal to the number of characters we should shift the first string forward to match the second.\n\nFor instance, take the strings \"fatigue\" and \"tiguefa\". In this case, the first string has been rotated 5 characters forward to produce the second string, so 5 would be returned.\nIf the second string isn't a valid rotation of the first string, the method returns -1. \n\nExamples:\n```\n\"coffee\", \"eecoff\" => 2\n\"eecoff\", \"coffee\" => 4\n\"moose\", \"Moose\" => -1\n\"isn't\", \"'tisn\" => 2\n\"Esham\", \"Esham\" => 0\n\"dog\", \"god\" => -1\n```\n\nFor Swift, your function should return an Int?. So rather than returning -1 when the second string isn't a valid rotation of the first, return nil.\n\"\"\"", "inputs": [["fatigue", "tiguefa"], ["hoop", "pooh"], ["eecoff", "coffee"], ["Moose", "moose"], ["isn't", "'tisn"], ["Esham", "Esham"], [" ", " "], ["dog", "god"], ["  ", " "], ["doomhouse", "hoodmouse"], ["123456789!@#$%^&*( )qwerty", "9!@#$%^&*( )qwerty12345678"]], "outputs": [[5], [-1], [4], [-1], [2], [0], [0], [-1], [-1], [-1], [18]], "starter_code": "def shifted_diff(first: str, second: str) -> int:", "canonical_solution": "def shifted_diff(first, second):\n    return (second + second).find(first) if len(first) == len(second) else -1", "entry_point": "shifted_diff", "task_id": "TACO_lite/93", "input_output_examples": "[[['coffee', 'eecoff'], ['eecoff', 'coffee'], ['moose', 'Moose'], [\"isn't\", \"'tisn\"], ['Esham', 'Esham'], ['dog', 'god']], [[2], [4], [-1], [2], [0], [-1]]]", "llm_generated_inputs": {"deepseek-v3": "[['fatigue', 'tiguefa'], ['coffee', 'eecoff'], ['eecoff', 'coffee'], ['moose', 'Moose'], [\"isn't\", \"'tisn\"], ['Esham', 'Esham'], ['dog', 'god'], ['hello', 'world'], ['', ''], ['a', 'a'], ['abc', 'cab'], ['xyz', 'zyx'], ['rotation', 'ationrot'], ['abcdef', 'defabc']]", "qwen2.5-coder-32b-instruct": "[['fatigue', 'tiguefa'], ['coffee', 'eecoff'], ['eecoff', 'coffee'], ['moose', 'Moose'], [\"isn't\", \"'tisn\"], ['Esham', 'Esham'], ['dog', 'god'], ['', ''], ['a', 'a'], ['a', 'b'], ['abc', 'cab'], ['abc', 'bca'], ['abc', 'abc'], ['abc', 'acb'], ['abcd', 'dabc'], ['abcd', 'abcd'], ['abcd', 'abdc']]"}}
{"requirement": "def func_or(a: bool, b: bool) -> bool:\n\"\"\"## Task\nYou need to implement two functions, `xor` and `or`, that replicate the behaviour of their respective operators:\n\n- `xor` = Takes 2 values and returns `true` if, and only if, one of them is truthy.\n- `or` = Takes 2 values and returns `true` if either one of them is truthy.\n\nWhen doing so, **you cannot use the or operator: `||`**.\n\n# Input\n- Not all input will be booleans - there will be truthy and falsey values [the latter including also empty strings and empty arrays]\n- There will always be 2 values provided\n\n## Examples\n- `xor(true, true)` should return `false`\n- `xor(false, true)` should return `true`\n- `or(true, false)` should return `true`\n- `or(false, false)` should return `false`\n\"\"\"", "inputs": [[true, true], [true, false], [false, false], [0, 11], [null, []]], "outputs": [[true], [true], [false], [true], [false]], "starter_code": "def func_or(a: bool, b: bool) -> bool:", "canonical_solution": "def func_or(a, b):\n    return not bool(a) == bool(b) == False\n\ndef func_xor(a, b):\n    return not bool(a) == bool(b)", "entry_point": "func_or", "task_id": "TACO_lite/94", "input_output_examples": "[[[True, True], [False, True], [True, False], [False, False]], [[False], [True], [True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[True, True], [True, False], [False, True], [False, False], [1, 0], [0, 1], [[], [1]], ['', 'hello'], [[1, 2], []], [None, False], [True, None], [0, ''], [1, 'hello'], [[], {}], [{'key': 'value'}, None]]", "qwen2.5-coder-32b-instruct": "[[True, True], [False, True], [True, False], [False, False], [1, 0], [0, 1], [0, 0], [1, 1], ['', ''], ['hello', ''], ['', 'world'], ['hello', 'world'], [[1, 2], []], [[], [3, 4]], [[], []], [[5, 6], [7, 8]], [{}, {}], [{'key': 'value'}, {}], [{}, {'key': 'value'}], [{'key': 'value'}, {'another_key': 'another_value'}]]"}}
{"requirement": "def only_duplicates(string: str) -> str:\n\"\"\"Given a string, remove any characters that are unique from the string.\n\n\n\nExample: \n\ninput: \"abccdefee\"\n\noutput: \"cceee\"\n\"\"\"", "inputs": [["abccdefee"], ["hello"], ["colloquial"], ["foundersandcoders"], ["12314256aaeff"]], "outputs": [["cceee"], ["ll"], ["ollol"], ["ondersndoders"], ["1212aaff"]], "starter_code": "def only_duplicates(string: str) -> str:", "canonical_solution": "from collections import Counter\n\ndef only_duplicates(string):\n    cs = Counter(string)\n    return ''.join((c for c in string if cs[c] > 1))", "entry_point": "only_duplicates", "task_id": "TACO_lite/108", "input_output_examples": "[[['abccdefee']], [['cceee']]]", "llm_generated_inputs": {"deepseek-v3": "[['abccdefee'], ['aabbcc'], ['xyz'], ['1122334455'], [''], ['aaaaa'], ['abababab'], ['abcabcabc'], ['a'], ['aa'], ['ab'], ['aab'], ['aabb'], ['aabcc'], ['aabbccdd'], ['aabbccddeeff']]", "qwen2.5-coder-32b-instruct": "[['abccdefee'], ['aabbcc'], ['abcdef'], ['aabbccddee'], ['a'], [''], ['aaabbbccc'], ['abcabcabc'], ['aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz']]"}}
{"requirement": "def plant_doubling(n: int) -> int:\n\"\"\"# Task\n Lonerz got some crazy growing plants and he wants to grow them nice and well.\n \n Initially, the garden is completely barren. \n \n Each morning, Lonerz can put any number of plants into the garden to grow. \n \n And at night, each plant mutates into two plants. \n \n Lonerz really hopes to see `n` plants in his garden.\n\n Your task is to find the minimum number of plants Lonerz has to plant to get `n` plants one day.\n\n# Example\n\n For `n = 5`, the output should be `2`.\n \n Lonerz hopes to see `5` plants. He adds `1` plant on the first morning and on the third morning there would be `4` plants in the garden. He then adds `1` more and sees `5` plants. \n \n So, Lonerz only needs to add 2 plants to his garden.\n \n For `n = 8,` the output should be `1`.\n \n Lonerz hopes to see `8` plants. Thus, he just needs to add `1` plant in the beginning and wait for it to double till 8.\n \n# Input/Output\n\n The number of plant lonerz hopes to see in his garden.\n \n \n - `[input]` integer `n`\n \n   `1 <= n <= 10^7`\n\n\n - `[output]` an integer\n\n The number of plants Lonerz needs to plant.\n\"\"\"", "inputs": [[5], [8], [536870911], [1]], "outputs": [[2], [1], [29], [1]], "starter_code": "def plant_doubling(n: int) -> int:", "canonical_solution": "def plant_doubling(n):\n    return bin(n).count('1')", "entry_point": "plant_doubling", "task_id": "TACO_lite/109", "input_output_examples": "[[[5], [8]], [[2], [1]]]", "llm_generated_inputs": {"deepseek-v3": "[[5], [8], [1], [16], [10], [100], [1023], [1000000], [10000000]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [15], [16], [31], [32], [63], [64], [100], [1023], [1024], [10000], [10000000]]"}}
{"requirement": "def growing_plant(up: int, down: int, h: int) -> int:\n\"\"\"### Task\n Each day a plant is growing by `upSpeed` meters. Each night that plant's height decreases by `downSpeed` meters due to the lack of sun heat. Initially, plant is 0 meters tall. We plant the seed at the beginning of a day. We want to know when the height of the plant will reach a certain level.\n\n### Example\n\n For `upSpeed = 100, downSpeed = 10 and desiredHeight = 910`, the output should be `10`.\n \n ```\n After day 1 --> 100\n After night 1 --> 90\n After day 2 --> 190\n After night 2 --> 180\n After day 3 --> 280\n After night 3 --> 270\n After day 4 --> 370\n After night 4 --> 360\n After day 5 --> 460\n After night 5 --> 450\n After day 6 --> 550\n After night 6 --> 540\n After day 7 --> 640\n After night 7 --> 630\n After day 8 --> 730\n After night 8 --> 720\n After day 9 --> 820\n After night 9 --> 810\n After day 10 --> 910 \n ```\n \n For `upSpeed = 10, downSpeed = 9 and desiredHeight = 4`, the output should be `1`.\n \n Because the plant reach to the desired height at day 1(10 meters).\n \n ```\n After day 1 --> 10\n ```\n\n### Input/Output\n\n```if-not:sql\n - `[input]` integer `upSpeed`\n\n    A positive integer representing the daily growth.\n\n    Constraints: `5 ≤ upSpeed ≤ 100.`\n\n\n - `[input]` integer `downSpeed`\n\n    A positive integer representing the nightly decline.\n\n    Constraints: `2 ≤ downSpeed < upSpeed.`\n\n\n - `[input]` integer `desiredHeight`\n\n    A positive integer representing the threshold.\n\n    Constraints: `4 ≤ desiredHeight ≤ 1000.`\n\n - `[output]` an integer\n\n    The number of days that it will take for the plant to reach/pass desiredHeight (including the last day in the total count).\n```\n```if:sql\n## Input\n\n~~~\n-----------------------------------------\n|     Table     |    Column      | Type |\n|---------------+----------------+------|\n| growing_plant | down_speed     | int  |\n|               | up_speed       | int  |\n|               | desired_height | int  |\n-----------------------------------------\n~~~\n\n### Columns\n* `up_speed`: A positive integer representing the daily growth. Constraints: `5 ≤ up_speed ≤ 100.`\n* `down_speed`: A positive integer representing the nightly decline. Constraints: `2 ≤ down_speed < up_speed.`\n* `desired_height`: A positive integer representing the threshold. Constraints: `4 ≤ desired_height ≤ 1000.`\n\n## Output\n\n~~~\n-------------------\n|  Column  | Type |\n|----------+------|\n| id       | int  |\n| num_days | int  |\n-------------------\n~~~\n\n`num_days` is the number of days that it will take for the plant to reach/pass desiredHeight (including the last day in the total count).\n```\n\"\"\"", "inputs": [[100, 10, 910], [10, 9, 4], [5, 2, 5], [5, 2, 6]], "outputs": [[10], [1], [1], [2]], "starter_code": "def growing_plant(up: int, down: int, h: int) -> int:", "canonical_solution": "from math import ceil\n\ndef growing_plant(up, down, h):\n    return max(ceil((h - down) / (up - down)), 1)", "entry_point": "growing_plant", "task_id": "TACO_lite/115", "input_output_examples": "[[[100, 10, 910], [10, 9, 4]], [[10], [1]]]", "llm_generated_inputs": {"deepseek-v3": "[[100, 10, 910], [10, 9, 4], [5, 2, 10], [100, 99, 100], [50, 25, 100], [10, 5, 50], [100, 1, 1000], [5, 4, 1000], [10, 9, 1], [10, 5, 10]]", "qwen2.5-coder-32b-instruct": "[[100, 10, 910], [10, 9, 4], [5, 2, 5], [10, 3, 10], [100, 99, 100], [10, 2, 100], [50, 10, 500], [8, 2, 30], [9, 3, 15], [100, 1, 1000]]"}}
{"requirement": "def title_to_number(title: str) -> int:\n\"\"\"Write a function \n\n`titleToNumber(title) or title_to_number(title) or titleToNb title ...`\n\n(depending on the language)\n\nthat given a column title as it appears in an Excel sheet, returns its corresponding column number. All column titles will be uppercase.\n\nExamples:\n```\ntitleTonumber('A') === 1\ntitleTonumber('Z') === 26\ntitleTonumber('AA') === 27\n```\n\"\"\"", "inputs": [["A"], ["Z"], ["AA"], ["AZ"], ["BA"], ["CODEWARS"], ["ZZZTOP"], ["OYAJI"], ["LONELINESS"], ["UNFORGIVABLE"]], "outputs": [[1], [26], [27], [52], [53], [28779382963], [321268054], [7294985], [68400586976949], [79089429845931757]], "starter_code": "def title_to_number(title: str) -> int:", "canonical_solution": "def title_to_number(title):\n    ret = 0\n    for i in title:\n        ret = ret * 26 + ord(i) - 64\n    return ret", "entry_point": "title_to_number", "task_id": "TACO_lite/117", "input_output_examples": "[[['A'], ['Z'], ['AA']], [[1], [26], [27]]]", "llm_generated_inputs": {"deepseek-v3": "[['A'], ['Z'], ['AA'], ['AZ'], ['BA'], ['ZZ'], ['AAA'], ['ABC'], ['XYZ'], ['ZY'], ['ZZZ']]", "qwen2.5-coder-32b-instruct": "[['A'], ['Z'], ['AA'], ['AB'], ['ZY'], ['ZZ'], ['AAA'], ['AAB'], ['ABC'], ['XYZ'], ['YZA'], ['ZZZ'], ['AAAA']]"}}
{"requirement": "def sum_circles(*args: float) -> str:\n\"\"\"Write a function that takes as its parameters *one or more numbers which are the diameters of circles.* \n\nThe function should return the *total area of all the circles*, rounded to the nearest integer in a string that says \"We have this much circle: xyz\". \n\nYou don't know how many circles you will be given, but you can assume it will be at least one.\n\nSo: \n```python\nsum_circles(2) == \"We have this much circle: 3\"\nsum_circles(2, 3, 4) == \"We have this much circle: 23\"\n```\n\nTranslations and comments (and upvotes!) welcome!\n\"\"\"", "inputs": [[48, 7, 8, 9, 10], [1], [1, 1, 1, 2, 3, 4, 5], [894, 5778, 4839, 476], [4.5456, 746.5, 98.34, 344.543], [1, 1, 1], [13.58, 14.9, 56.99, 107.321], [56894.04839, 843975.4839, 4.08437403489], [5, 6, 7, 8, 9, 10, 105083, 48839, 4853, 28, 483]], "outputs": [["We have this much circle: 2040"], ["We have this much circle: 1"], ["We have this much circle: 45"], ["We have this much circle: 45417233"], ["We have this much circle: 538519"], ["We have this much circle: 2"], ["We have this much circle: 11916"], ["We have this much circle: 561977165367"], ["We have this much circle: 10564760498"]], "starter_code": "def sum_circles(*args: float) -> str:", "canonical_solution": "import math\n\ndef sum_circles(*args):\n    t = round(sum([math.pi * d ** 2 / 4 for d in args]))\n    return 'We have this much circle: {}'.format(int(t))", "entry_point": "sum_circles", "task_id": "TACO_lite/122", "input_output_examples": "[[[2], [[2, 3, 4]]], [['We have this much circle: 3'], ['We have this much circle: 23']]]", "llm_generated_inputs": {"deepseek-v3": "[[2], [0], [0.0001]]", "qwen2.5-coder-32b-instruct": "[[2], [1], [0], [5.5], [0.1], [100]]"}}
{"requirement": "from typing import List\n\n\ndef get_section_id(scroll: int, sizes: List[int]) -> int:\n\"\"\"Your website is divided vertically in sections, and each can be of different size (height).  \nYou need to establish the section index (starting at `0`) you are at, given the `scrollY` and `sizes` of all sections.  \nSections start with `0`, so if first section is `200` high, it takes `0-199` \"pixels\" and second starts at `200`.\n\n### Example:\n\n`getSectionIdFromScroll( 300, [300,200,400,600,100] )`\n\nwill output number `1` as it's the second section.\n\n`getSectionIdFromScroll( 1600, [300,200,400,600,100] )`\n\nwill output number `-1` as it's past last section.\n\nGiven the `scrollY` integer (always non-negative) and an array of non-negative integers (with at least one element), calculate the index (starting at `0`) or `-1` if `scrollY` falls beyond last section (indication of an error).\n\"\"\"", "inputs": [[1, [300, 200, 400, 600, 100]], [299, [300, 200, 400, 600, 100]], [300, [300, 200, 400, 600, 100]], [1599, [300, 200, 400, 600, 100]], [1600, [300, 200, 400, 600, 100]]], "outputs": [[0], [0], [1], [4], [-1]], "starter_code": "from typing import List\ndef get_section_id(scroll: int, sizes: List[int]) -> int:", "canonical_solution": "def get_section_id(scroll, sizes):\n    c = 0\n    for idx, s in enumerate(sizes):\n        c += s\n        if scroll < c:\n            return idx\n    return -1", "entry_point": "get_section_id", "task_id": "TACO_lite/124", "input_output_examples": "[[[300, [300, 200, 400, 600, 100]], [1600, [300, 200, 400, 600, 100]]], [[1], [-1]]]", "llm_generated_inputs": {"deepseek-v3": "[[300, [300, 200, 400, 600, 100]], [1600, [300, 200, 400, 600, 100]], [0, [100, 200, 300]], [150, [100, 200, 300]], [299, [100, 200, 300]], [300, [100, 200, 300]], [600, [100, 200, 300]], [100, [100]], [200, [100]], [0, [0]], [1, [0]], [500, [200, 300, 0, 100]], [50, [50, 50, 50]], [150, [50, 50, 50]], [200, [50, 50, 50]]]", "qwen2.5-coder-32b-instruct": "[[300, [300, 200, 400, 600, 100]], [1600, [300, 200, 400, 600, 100]], [0, [300, 200, 400, 600, 100]], [599, [600]], [600, [600]], [10, [10, 10, 10, 10, 10]], [5, [1, 1, 1, 1, 1]], [1000, [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]], [999, [1000]], [1000, [1000, 1]]]"}}
{"requirement": "def sum_nested_numbers(a: list, depth: int = 1) -> int:\n\"\"\"Build a function `sumNestedNumbers`/`sum_nested_numbers` that finds the sum of all numbers in a series of nested arrays raised to the power of their respective nesting levels.  Numbers in the outer most array should be raised to the power of 1.\n\nFor example,\n\nshould return `1 + 2*2 + 3 + 4*4 + 5*5*5 === 149`\n\"\"\"", "inputs": [[[0]], [[1, 2, 3, 4, 5]], [[1, [2], 3, [4, [5]]]], [[6, [5], [[4]], [[[3]]], [[[[2]]]], [[[[[1]]]]]]], [[1, [-1], [[1]], [[[-1]]], [[[[1]]]]]]], "outputs": [[0], [15], [149], [209], [5]], "starter_code": "def sum_nested_numbers(a: list, depth: int = 1) -> int:", "canonical_solution": "def sum_nested_numbers(a, depth=1):\n    return sum((sum_nested_numbers(e, depth + 1) if type(e) == list else e ** depth for e in a))", "entry_point": "sum_nested_numbers", "task_id": "TACO_lite/128", "input_output_examples": "[[[[1, 2, [3, 4], [[5]]]]], [[57]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, [2, 3], [4, [5]]], 1], [[1, [2, 3], [4, [5]]], 2], [[1, [2, [3, [4]]]], 3], [[[1, 2], [3, [4, 5]]], 2], [[], 1], [[1, 2, 3], 1], [[[1], [2], [3]], 1], [[[[1]], [[2]], [[3]]], 3], [[1, [2, [3, [4, [5]]]]], 5], [[1, [2, [3, [4, [5]]]]], 0]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, [3, 4, [5]]], 1], [[1, [2, [3, [4, [5]]]]], 1], [[1, [2, [3]], 4], 1], [[1, 2, 3, 4, 5], 1], [[], 1], [[0, [0, [0]]], 1], [[[-1, -2, [-3, -4, [-5]]]], 1], [[1, [2, [3, [4, [5]]]]], 2], [[1, [2, [3, [4, [5]]]]], 3], [[1, [2, [3, [4, [5]]]]], 4], [[1, [2, [3, [4, [5]]]]], 5]]"}}
{"requirement": "def make_negative(number: int) -> int:\n\"\"\"In this simple assignment you are given a number and have to make it negative. But maybe the number is already negative?\n\n**Example:**\n``` c\nmakeNegative(1); // return -1\nmakeNegative(-5); // return -5\nmakeNegative(0); // return 0\n```\n``` cfml\nmakeNegative(1); // return -1\nmakeNegative(-5); // return -5\nmakeNegative(0); // return 0\n```\n``` csharp\nKata.MakeNegative(1); // return -1\nKata.MakeNegative(-5); // return -5\nKata.MakeNegative(0); // return 0\n```\n``` java\nKata.makeNegative(1); // return -1\nKata.makeNegative(-5); // return -5\nKata.makeNegative(0); // return 0\n```\n``` python\nmake_negative(1);  # return -1\nmake_negative(-5); # return -5\nmake_negative(0);  # return 0\n```\n``` javascript\nmakeNegative(1); // return -1\nmakeNegative(-5); // return -5\nmakeNegative(0); // return 0\nmakeNegative(0.12); // return -0.12\n```\n``` typescript\nmakeNegative(1); // return -1\nmakeNegative(-5); // return -5\nmakeNegative(0); // return 0\n```\n``` cpp\nmakeNegative(1); // return -1\nmakeNegative(-5); // return -5\nmakeNegative(0); // return 0\n```\n``` haskell\nmakeNegative    1 -- return -1\nmakeNegative (-5) -- return -5\nmakeNegative    0 -- return 0\nmakeNegative 0.12 -- return -0.12\n```\n``` ruby\nmakeNegative(1); # return -1\nmakeNegative(-5); # return -5\nmakeNegative(0); # return 0\n```\n``` coffeescript\nmakeNegative 1    # return -1\nmakeNegative -5   # return -5\nmakeNegative 0    # return 0\n```\n``` elixir\nmake_negative 1    # return -1\nmake_negative -5   # return -5\nmake_negative 0    # return 0\n```\n``` go\nMakeNegative(1)    # return -1\nMakeNegative(-5)   # return -5\nMakeNegative(0)    # return 0\n```\n``` julia\nKata.makeNegative(1)  # return -1\nKata.makeNegative(-5) # return -5\nKata.makeNegative(0)  # return 0\n```\n``` kotlin\nKata().makeNegative(1)  // return -1\nKata().makeNegative(-5) // return -5\nKata().makeNegative(0)  // return 0\n```\n``` asm\nmake_negative(1);    // return -1\nmake_negative(-5);   // return -5\nmake_negative(0);    // return 0\n```\n``` groovy\nKata.makeNegative(1)    // return -1\nKata.makeNegative(-5)   // return -5\nKata.makeNegative(0)    // return 0\n```\n``` php\nmakeNegative(1)    // return -1\nmakeNegative(-5)   // return -5\nmakeNegative(0)    // return 0\nmakeNegative(0.12) // return -0.12\n```\n```racket\n(make-negative 1)    ; -1\n(make-negative -5)   ; -5\n(make-negative 0)    ; 0\n(make-negative 0.12) ; -0.12\n```\n\n**Notes:**\n\n- The number can be negative already, in which case no change is required.\n- Zero (0) is not checked for any specific sign. Negative zeros make no mathematical sense.\n\"\"\"", "inputs": [[42], [-9], [0], [1], [-1]], "outputs": [[-42], [-9], [0], [-1], [-1]], "starter_code": "def make_negative(number: int) -> int:", "canonical_solution": "def make_negative(number):\n    return -abs(number)", "entry_point": "make_negative", "task_id": "TACO_lite/131", "input_output_examples": "[[[1], [-5], [0], [0.12]], [[-1], [-5], [0], [-0.12]]]", "llm_generated_inputs": {"deepseek-v3": "[[5], [-3], [0], [100], [-100], [0.12], [-0.12]]", "qwen2.5-coder-32b-instruct": "[[1], [-5], [0], [100], [-100], [0.12], [-0.12], [2147483647], [-2147483648]]"}}
{"requirement": "def cup_volume(d1: float, d2: float, h: float) -> float:\n\"\"\"Your job is to return the volume of a cup when given the diameter of the top, the diameter of the bottom and the height.\n\nYou know that there is a steady gradient from the top to the bottom.\n\n\n\nYou want to return the volume rounded to 2 decimal places.\n\nExmples:\n```python\ncup_volume(1, 1, 1)==0.79\n\ncup_volume(10, 8, 10)==638.79\n\ncup_volume(1000, 1000, 1000)==785398163.4\n\ncup_volume(13.123, 123.12, 1)==4436.57\n\ncup_volume(5, 12, 31)==1858.51\n```\n\nYou will only be passed positive numbers.\n\"\"\"", "inputs": [[1, 1, 1], [10, 8, 10], [1000, 1000, 1000], [13.123, 123.12, 1], [5, 12, 31]], "outputs": [[0.79], [638.79], [785398163.4], [4436.57], [1858.51]], "starter_code": "def cup_volume(d1: float, d2: float, h: float) -> float:", "canonical_solution": "from math import pi\n\ndef cup_volume(d1, d2, h):\n    return round(h / 12.0 * pi * (d1 ** 2 + d1 * d2 + d2 ** 2), 2)", "entry_point": "cup_volume", "task_id": "TACO_lite/132", "input_output_examples": "[[[1, 1, 1], [10, 8, 10], [1000, 1000, 1000], [13.123, 123.12, 1], [5, 12, 31]], [[0.79], [638.79], [785398163.4], [4436.57], [1858.51]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 1, 1], [10, 8, 10], [1000, 1000, 1000], [13.123, 123.12, 1], [5, 12, 31], [0.1, 0.1, 0.1], [0.5, 1.5, 2], [1, 2, 3], [2, 1, 3], [0, 0, 0], [1, 1, 0], [0, 1, 1], [1, 0, 1]]", "qwen2.5-coder-32b-instruct": "[[1, 1, 1], [10, 8, 10], [1000, 1000, 1000], [13.123, 123.12, 1], [5, 12, 31], [0.1, 0.1, 0.1], [100, 1, 100], [1, 100, 100], [10, 10, 0.001], [10, 10, 1000]]"}}
{"requirement": "def thirt(n: int) -> int:\n\"\"\"When you divide the successive powers of `10` by `13` you get the following remainders of the integer divisions:  \n\n`1, 10, 9, 12, 3, 4`. \n\nThen the whole pattern repeats.\n\nHence the following method:\nMultiply the right most digit of the number with the left most number \nin the sequence shown above, the second right most digit to the second \nleft most digit of the number in the sequence. The cycle goes on and you sum all these products. Repeat this process until the sequence of sums is stationary.\n\n...........................................................................\n\nExample: What is the remainder when `1234567` is divided by `13`?\n\n`7×1 + 6×10 + 5×9 + 4×12 + 3×3 + 2×4 + 1×1 = 178`\n\nWe repeat the process with 178:\n\n`8x1 + 7x10 + 1x9 = 87`\n\nand again with 87:\n\n`7x1 + 8x10 = 87`\n\n...........................................................................\n\nFrom now on the sequence is stationary and the remainder of `1234567` by `13` is \nthe same as the remainder of `87` by `13`: `9`\n\nCall `thirt` the function which processes this sequence of operations on an integer `n (>=0)`. `thirt` will return the stationary number.\n\n`thirt(1234567)` calculates 178, then 87, then 87 and returns `87`.\n\n`thirt(321)` calculates 48, 48 and returns `48`\n\"\"\"", "inputs": [[8529], [85299258], [5634], [1111111111], [987654321]], "outputs": [[79], [31], [57], [71], [30]], "starter_code": "def thirt(n: int) -> int:", "canonical_solution": "array = [1, 10, 9, 12, 3, 4]\n\ndef thirt(n):\n    total = sum([int(c) * array[i % 6] for i, c in enumerate(reversed(str(n)))])\n    if n == total:\n        return total\n    return thirt(total)", "entry_point": "thirt", "task_id": "TACO_lite/134", "input_output_examples": "[[[1234567], [321]], [[87], [48]]]", "llm_generated_inputs": {"deepseek-v3": "[[1234567], [321], [5], [87], [987654321], [0]]", "qwen2.5-coder-32b-instruct": "[[1234567], [321], [0], [1], [13], [999999999], [111111111], [10], [100], [1000]]"}}
{"requirement": "def find_2nd_largest(arr: list) -> int:\n\"\"\"Find the 2nd largest integer in array\nIf the array has no 2nd largest integer then return nil.\nReject all non integers elements and then find the 2nd largest integer in array\n\nfind_2nd_largest([1,2,3]) => 2\n\nfind_2nd_largest([1,1,1,1,1]) => nil\nbecause all elements are same. Largest no. is 1. and there is no 2nd largest no.\n\nfind_2nd_largest([1,'a','2',3,3,4,5,'b']) => 4\nas after rejecting non integers array will be [1,3,3,4,5]\nLargest no. is 5. and 2nd largest is 4.\n\nReturn nil if there is no 2nd largest integer.\nTake care of big numbers as well\n\"\"\"", "inputs": [[[1, 2, 3]], [[1, 1, 1, 1, 1, 1, 1]], [[1, "a", "2", 3, 3, 4, 5, "b"]], [[1, "a", "2", 3, 3, 3333333333333333333334, 544444444444444444444444444444, "b"]]], "outputs": [[2], [null], [4], [3333333333333333333334]], "starter_code": "def find_2nd_largest(arr: list) -> int:", "canonical_solution": "def find_2nd_largest(arr):\n    arr = sorted((i for i in set(arr) if type(i) == int))\n    return arr[-2] if len(arr) > 1 else None", "entry_point": "find_2nd_largest", "task_id": "TACO_lite/138", "input_output_examples": "[[[[1, 2, 3]], [[1, 1, 1, 1, 1]], [[1, 'a', '2', 3, 3, 4, 5, 'b']]], [[2], ['nil'], [4]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3]], [[1, 1, 1, 1, 1]], [[1, 'a', '2', 3, 3, 4, 5, 'b']], [[10, 20, 30, 40, 50]], [[1000000, 2000000, 3000000, 4000000]], [[-1, -2, -3, -4]], [[0, 0, 0, 0, 0]], [[-10, 0, 10]], [[]], [[1, 'a', 'b', 'c']], [[1, 2, 2, 3, 3, 3]], [[999999999999999999999, 999999999999999999998, 999999999999999999997]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3]], [[1, 1, 1, 1, 1]], [[1, 'a', '2', 3, 3, 4, 5, 'b']], [[10, 20, 30, 40, 50]], [[50, 40, 30, 20, 10]], [[1000000000, 2000000000, 3000000000]], [[1]], [[]], [[1, 2]], [[2, 2, 3, 3, 4, 4, 5, 5]], [[1, 'a', 'b', 'c', 2]], [[1.5, 2.5, 3.5, 4.5]], [[None, True, False, 1, 2, 3]]]"}}
{"requirement": "def tv_remote(words: str) -> int:\n\"\"\"# Background\n\nMy TV remote control has arrow buttons and an `OK` button.\n\nI can use these to move a \"cursor\" on a logical screen keyboard to type words...\n\n# Keyboard\n\nThe screen \"keyboard\" layout looks like this\n\n\n  #tvkb {\n    width : 400px;\n    border: 5px solid gray; border-collapse: collapse;\n  }\n  #tvkb td {\n    color : orange;\n    background-color : black;\n    text-align : center;\n    border: 3px solid gray; border-collapse: collapse;\n  }\n\n\nabcde123\nfghij456\nklmno789\npqrst.@0\nuvwxyz_/\naASP\n\n\n\n* `aA` is the SHIFT key. Pressing this key toggles alpha characters between UPPERCASE and lowercase\n* `SP` is the space character\n* The other blank keys in the bottom row have no function\n\n# Kata task\n\nHow many button presses on my remote are required to type the given `words`?\n\n## Notes\n\n* The cursor always starts on the letter `a` (top left)\n* The alpha characters are initially lowercase (as shown above)\n* Remember to also press `OK` to \"accept\" each letter\n* Take a direct route from one letter to the next\n\n\n* The cursor does not wrap (e.g. you cannot leave one edge and reappear on the opposite edge)\n* Although the blank keys have no function, you may navigate through them if you want to\n* Spaces may occur anywhere in the `words` string.\n* Do not press the SHIFT key until you need to. For example, with the word `e.Z`, the SHIFT change happens **after** the `.` is pressed (not before)\n \n# Example\n\nwords = `Code Wars`\n\n* C => `a`-`f`-`k`-`p`-`u`-`aA`-OK-`U`-`P`-`K`-`F`-`A`-`B`-`C`-OK = 14\n* o => `C`-`H`-`M`-`R`-`W`-`V`-`U`-`aA`-OK-`SP`-`v`-`q`-`l`-`m`-`n`-`o`-OK = 16\n* d => `o`-`j`-`e`-`d`-OK = 4\n* e => `d`-`e`-OK = 2\n* space => `e`-`d`-`c`-`b`-`g`-`l`-`q`-`v`-`SP`-OK = 9\n* W => `SP`-`aA`-OK-`SP`-`V`-`W`-OK = 6\n* a => `W`-`V`-`U`-`aA`-OK-`u`-`p`-`k`-`f`-`a`-OK = 10\n* r => `a`-`f`-`k`-`p`-`q`-`r`-OK = 6\n* s => `r`-`s`-OK = 2\n\nAnswer = 14 + 16 + 4 + 2 + 9 + 6 + 10 + 6 + 2 = 69\n\n\n\n*Good Luck!\nDM.*\n\n\n\nSeries\n* TV Remote\n* TV Remote (shift and space)\n* TV Remote (wrap)\n* TV Remote (symbols)\n\"\"\"", "inputs": [["Code Wars"], ["does"], ["your"], ["solution"], ["work"], ["for"], ["these"], ["words"], ["DOES"], ["YOUR"], ["SOLUTION"], ["WORK"], ["FOR"], ["THESE"], ["WORDS"], ["Does"], ["Your"], ["Solution"], ["Work"], ["For"], ["These"], ["Words"], ["A"], ["AADVARKS"], ["A/A/A/A/"], ["1234567890"], ["MISSISSIPPI"], ["a"], ["aadvarks"], ["a/a/a/a/"], ["mississippi"], ["Xoo ooo ooo"], ["oXo ooo ooo"], ["ooX ooo ooo"], ["ooo Xoo ooo"], ["ooo oXo ooo"], ["ooo ooX ooo"], ["ooo ooo Xoo"], ["ooo ooo oXo"], ["ooo ooo ooX"], ["The Quick Brown Fox Jumps Over A Lazy Dog."], ["Pack My Box With Five Dozen Liquor Jugs."], [""], [" "], ["   "], ["    x   X    "]], "outputs": [[69], [16], [23], [33], [20], [12], [27], [25], [27], [26], [38], [23], [21], [32], [28], [40], [37], [49], [30], [28], [41], [35], [12], [45], [96], [28], [42], [1], [34], [85], [35], [57], [65], [53], [53], [65], [53], [53], [65], [53], [306], [290], [0], [7], [9], [34]], "starter_code": "def tv_remote(words: str) -> int:", "canonical_solution": "import re\nKEYBOARD = 'abcde123fghij456klmno789pqrst.@0uvwxyz_/* '\nMAP = {c: (i // 8, i % 8) for i, c in enumerate(KEYBOARD)}\n\ndef manhattan(*pts):\n    return 1 + sum((abs(z2 - z1) for z1, z2 in zip(*pts)))\n\ndef toggle(m):\n    ups, end = (m.group(1), m.group(2))\n    off = '*' * bool(end)\n    return f'*{ups.lower()}{off}{end}'\n\ndef tv_remote(words):\n    reWords = re.sub('([A-Z][^a-z]*)([a-z]?)', toggle, words)\n    return sum((manhattan(MAP[was], MAP[curr]) for was, curr in zip('a' + reWords, reWords)))", "entry_point": "tv_remote", "task_id": "TACO_lite/145", "input_output_examples": "[[['Code Wars']], [[69]]]", "llm_generated_inputs": {"deepseek-v3": "[['a'], ['A'], [' '], ['hello'], ['Hello World'], ['123'], ['aA'], ['@.'], ['Code Wars'], ['aA_SP'], ['zZ'], ['aAbBcC'], ['1234567890'], ['_/'], ['aA SP']]", "qwen2.5-coder-32b-instruct": "[['Code Wars'], ['hello'], ['HELLO'], ['1234567890'], ['aAaAaA'], ['.'], ['_'], ['/'], [' '], ['abcdefghijklmnopqrstuvwxyz'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZ'], ['ShiftAndSpace'], ['a'], ['z'], ['A'], ['Z'], ['Shift'], ['Space'], ['Shift Space'], ['ShiftShift'], ['SpaceSpace']]"}}
{"requirement": "def which_note(count: int) -> str:\n\"\"\"You're continuing to enjoy your new piano, as described in Piano Kata, Part 1. You're also continuing the exercise where you start on the very first (leftmost, lowest in pitch) key on the 88-key keyboard, which (as shown below) is the note A, with the little finger on your left hand, then the second key, which is the black key A# (\"A sharp\"), with your left ring finger, then the third key, B, with your left middle finger, then the fourth key, C, with your left index finger, and then the fifth key, C#, with your left thumb. Then you play the sixth key, D, with your right thumb, and continue on playing the seventh, eighth, ninth, and tenth keys with the other four fingers of your right hand. Then for the eleventh key you go back to your left little finger, and so on. Once you get to the rightmost/highest, 88th, key, C, you start all over again with your left little finger on the first key. \n\n\n\n(If the Codewars Instructions pane resizes the above piano keyboard image to be too small to read the note labels of the black/sharp keys on your screen, click here to open a copy of the image in a new tab or window.)\n\nThis time, in addition to counting each key press out loud (not starting again at 1 after 88, but continuing on to 89 and so forth) to try to keep a steady rhythm going and to see how far you can get before messing up, you're also saying the name of each note. You wonder whether this may help you develop perfect pitch in addition to learning to just *know* which note is which, and -- as in Piano Kata, Part 1 -- helping you to learn to move smoothly and with uniform pressure on the keys from each finger to the next and back and forth between hands.\n\nThe function you are going to write will explore one of the patterns you're experiencing in your practice: Given the number you stopped on, which note was it? For example, in the description of your piano exercise above, if you stopped at 5, your left thumb would be on the fifth key of the piano, which is C#. Or if you stopped at 92, you would have gone all the way from keys 1 to 88 and then wrapped around, so that you would be on the fourth key, which is C.\n\nYour function will receive an integer between 1 and 10000 (maybe you think that in principle it would be cool to count up to, say, a billion, but considering how many years it would take it is just not possible) and return one of the strings \"A\", \"A#\", \"B\", \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", or \"G#\" indicating which note you stopped on -- here are a few more examples:\n```\n1     \"A\"\n12    \"G#\"\n42    \"D\"\n100   \"G#\"\n2017  \"F\"\n```\nHave fun!\n\"\"\"", "inputs": [[1], [5], [12], [42], [88], [89], [92], [100], [111], [200], [2017]], "outputs": [["A"], ["C#"], ["G#"], ["D"], ["C"], ["A"], ["C"], ["G#"], ["G"], ["G#"], ["F"]], "starter_code": "def which_note(count: int) -> str:", "canonical_solution": "def which_note(count):\n    return 'A A# B C C# D D# E F F# G G#'.split()[(count - 1) % 88 % 12]", "entry_point": "which_note", "task_id": "TACO_lite/148", "input_output_examples": "[[[1], [12], [42], [100], [2017]], [['A'], ['G#'], ['D'], ['G#'], ['F']]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [5], [12], [42], [88], [89], [100], [2017], [10000]]", "qwen2.5-coder-32b-instruct": "[[1], [12], [42], [100], [2017], [88], [89], [176], [10000], [1001], [2], [6], [13], [7], [14]]"}}
{"requirement": "def solve(count: int, ball_number: int) -> int:\n\"\"\"Jack and Jill are playing a game. They have balls numbered from `0` to `n - 1`. Jack looks the other way and asks Jill to reverse the position of the balls, for instance, to change the order from say, `0,1,2,3` to `3,2,1,0`. He further asks Jill to reverse the position of the balls `n` times, each time starting from one position further to the right, till she reaches the last ball. So, Jill has to reverse the positions of the ball starting from position `0`, then from position `1`, then from position `2` and so on. At the end of the game, Jill will ask Jack to guess the final position of any ball numbered `k`. \n\nYou will be given `2` integers, the first will be `n`(balls numbered from `0` to `n-1`) and the second will be `k`. You will return the position of the ball numbered `k` after the rearrangement.\n\n```Perl\nsolve(4,1) = 3. The reversals are [0,1,2,3] -> [3,2,1,0] -> [3,0,1,2] -> [3,0,2,1]. => 1 is in position 3.\n```\n\nMore examples in the test cases. Good luck!\n\"\"\"", "inputs": [[4, 1], [4, 2], [4, 3], [20, 8], [20, 9], [20, 10]], "outputs": [[3], [2], [0], [17], [19], [18]], "starter_code": "def solve(count: int, ball_number: int) -> int:", "canonical_solution": "def solve(count, ball_number):\n    assert isinstance(count, int)\n    assert isinstance(ball_number, int)\n    balls = list(range(count))\n    for idx in range(count):\n        balls = balls[:idx] + balls[idx:][::-1]\n    return balls.index(ball_number)", "entry_point": "solve", "task_id": "TACO_lite/149", "input_output_examples": "[[[4, 1]], [[3]]]", "llm_generated_inputs": {"deepseek-v3": "[[4, 1], [5, 0], [3, 2], [1, 0], [6, 5], [0, 0], [7, 3], [2, 1]]", "qwen2.5-coder-32b-instruct": "[[4, 1], [5, 2], [3, 0], [6, 5], [1, 0], [0, 0], [10, 9], [10, 0], [7, 3], [2, 1]]"}}
{"requirement": "def reindeer(presents: int) -> int:\n\"\"\"Santa puts all the presents into the huge sack. In order to let his reindeers rest a bit, he only takes as many reindeers with him as he is required to do. The others may take a nap.\n\nTwo reindeers are always required for the sleigh and Santa himself. Additionally he needs 1 reindeer per 30 presents. As you know, Santa has 8 reindeers in total, so he can deliver up to 180 presents at once (2 reindeers for Santa and the sleigh + 6 reindeers with 30 presents each).\n\nComplete the function `reindeers()`, which takes a number of presents and returns the minimum numbers of required reindeers. If the number of presents is too high, throw an error.\n\nExamles:\n\n```python\nreindeer(0) # must return 2\nreindeer(1) # must return 3\nreindeer(30) # must return 3\nreindeer(200) # must throw an error\n```\n\"\"\"", "inputs": [[0], [1], [5], [30], [31], [60], [61], [90], [91], [120], [121], [150], [151], [180]], "outputs": [[2], [3], [3], [3], [4], [4], [5], [5], [6], [6], [7], [7], [8], [8]], "starter_code": "def reindeer(presents: int) -> int:", "canonical_solution": "from math import ceil\n\ndef reindeer(presents):\n    if presents > 180:\n        raise ValueError('Too many presents')\n    return ceil(presents / 30.0) + 2", "entry_point": "reindeer", "task_id": "TACO_lite/154", "input_output_examples": "[[[0], [1], [30], [200]], [[2], [3], [3], ['Error']]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [30], [59], [60], [180], [181], [200]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [30], [59], [60], [179], [180], [181], [200], [300]]"}}
{"requirement": "def solve(a: int, b: int) -> bool:\n\"\"\"In this Kata, you will be given two numbers, `a` and `b`, and your task is to determine if the first number `a` is divisible by `all` the prime factors of the second number `b`. For example: `solve(15,12) = False` because `15` is not divisible by all the prime factors of `12` (which include`2`).\n\nSee test cases for more examples. \n\nGood luck!\n\nIf you like this Kata, please try:\n\n[Sub-array division](https://www.codewars.com/kata/59eb64cba954273cd4000099)\n\n[Divisor harmony](https://www.codewars.com/kata/59bf97cd4f98a8b1cd00007e)\n\"\"\"", "inputs": [[2, 256], [2, 253], [9, 243], [15, 12], [21, 2893401], [21, 2893406], [54, 2834352], [54, 2834359], [1000013, 7187761], [1000013, 7187762]], "outputs": [[true], [false], [true], [false], [true], [false], [true], [false], [true], [false]], "starter_code": "def solve(a: int, b: int) -> bool:", "canonical_solution": "from math import gcd\n\ndef solve(a, b):\n    while 1 < gcd(a, b):\n        b = b // gcd(a, b)\n    return b == 1", "entry_point": "solve", "task_id": "TACO_lite/159", "input_output_examples": "[[[15, 12]], [[False]]]", "llm_generated_inputs": {"deepseek-v3": "[[15, 12], [20, 10], [7, 7], [8, 16], [30, 6], [1, 1], [0, 5], [5, 0], [17, 34], [100, 50], [21, 14], [49, 7], [36, 72], [12, 18], [9, 27]]", "qwen2.5-coder-32b-instruct": "[[15, 12], [60, 12], [10, 5], [7, 14], [1, 1], [0, 5], [5, 0], [30, 1], [28, 7], [100, 10], [49, 7], [18, 27], [8, 4]]"}}
{"requirement": "def ackermann(m: int, n: int) -> int:\n\"\"\"The ackermann function is a famous function that played a big role in computability theory as the first example of a total computable function that is not primitive recursive.\n\nSince then the function has been a bit simplified but is still of good use. Due to its definition in terms of extremely deep recursion it can be used as a benchmark of a compiler's ability to optimize recursion. \n\nThe goal of this kata is to code a function which will be given two inputs, m and n, and will return the ackermann number A(m,n) defined by:\n\n```\nA(m,n) = n+1                          if m=0  \nA(m,n) = A(m-1,1)                     if m>0 , n=0\nA(m,n) = A(m-1,A(m,n-1))              if m,n > 0\n```\n\nm,n should be non-negative integers, the function should return null (Javascript), None (Python), or nil (Ruby) for other type, non-integer and negative numbers. In C, input is restricted to integer type.\n\"\"\"", "inputs": [[1, 1], [4, 0], [3, 3]], "outputs": [[3], [13], [61]], "starter_code": "def ackermann(m: int, n: int) -> int:", "canonical_solution": "from numbers import Number\n\ndef ackermann(m, n):\n    if isinstance(n, Number) and isinstance(m, Number):\n        if m >= 0 and n >= 0:\n            return ackermann_Aux(m, n)\n    return None\n\ndef ackermann_Aux(m, n):\n    if m == 0:\n        return n + 1\n    if m > 0:\n        if n == 0:\n            return ackermann_Aux(m - 1, 1)\n        if n > 0:\n            return ackermann_Aux(m - 1, ackermann_Aux(m, n - 1))", "entry_point": "ackermann", "task_id": "TACO_lite/162", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[0, 0], [0, 1], [1, 0], [1, 1], [2, 3], [3, 2], [4, 0], [0, 4], [3, 1], [1, 3], [-1, 2], [2, -1], [1.5, 2], [2, 1.5], ['a', 2], [2, 'a']]", "qwen2.5-coder-32b-instruct": "[[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2], [3, 0], [3, 1], [3, 2], [4, 0], [-1, 0], [0, -1], [-1, -1], [3.5, 2], [2, 3.5], ['3', 2], [2, '3']]"}}
{"requirement": "from typing import List\n\n\ndef dup(arry: List[str]) -> List[str]:\n\"\"\"In this Kata, you will be given an array of strings and your task is to remove all consecutive duplicate letters from each string in the array.\n\nFor example: \n\n  * `dup([\"abracadabra\",\"allottee\",\"assessee\"]) = [\"abracadabra\",\"alote\",\"asese\"]`. \n  \n  * `dup([\"kelless\",\"keenness\"]) = [\"keles\",\"kenes\"]`.\n\nStrings will be lowercase only, no spaces. See test cases for more examples.\n\n~~~if:rust\nFor the sake of simplicity you can use the macro 'vec_of_string' to create a Vec with an array of string literals.\n~~~\n\nGood luck!\n\nIf you like this Kata, please try:\n\n[Alternate capitalization](https://www.codewars.com/kata/59cfc000aeb2844d16000075)\n\n[Vowel consonant lexicon](https://www.codewars.com/kata/59cf8bed1a68b75ffb000026)\n\"\"\"", "inputs": [[["ccooddddddewwwaaaaarrrrsssss", "piccaninny", "hubbubbubboo"]], [["abracadabra", "allottee", "assessee"]], [["kelless", "keenness"]], [["Woolloomooloo", "flooddoorroommoonlighters", "chuchchi"]], [["adanac", "soonness", "toolless", "ppellee"]], [["callalloo", "feelless", "heelless"]], [["putteellinen", "keenness"]], [["kelless", "voorraaddoosspullen", "achcha"]]], "outputs": [[["codewars", "picaniny", "hubububo"]], [["abracadabra", "alote", "asese"]], [["keles", "kenes"]], [["Wolomolo", "flodoromonlighters", "chuchchi"]], [["adanac", "sones", "toles", "pele"]], [["calalo", "feles", "heles"]], [["putelinen", "kenes"]], [["keles", "voradospulen", "achcha"]]], "starter_code": "from typing import List\ndef dup(arry: List[str]) -> List[str]:", "canonical_solution": "from itertools import groupby\n\ndef dup(arry):\n    return [''.join((c for c, grouper in groupby(i))) for i in arry]", "entry_point": "dup", "task_id": "TACO_lite/165", "input_output_examples": "[[[['abracadabra', 'allottee', 'assessee']], [['kelless', 'keenness']]], [[['abracadabra', 'alote', 'asese']], [['keles', 'kenes']]]]", "llm_generated_inputs": {"deepseek-v3": "[[['abracadabra', 'allottee', 'assessee']], [['kelless', 'keenness']], [['hello', 'world']], [['aaaaa', 'bbbbb', 'ccccc']], [['a', 'b', 'c']], [['abc', 'def', 'ghi']], [['aabbcc', 'ddeeff', 'gghhii']], [['']], [['aaabbbccc']], [['aaabbb', 'cccddd', 'eeefff']]]", "qwen2.5-coder-32b-instruct": "[[['abracadabra', 'allottee', 'assessee']], [['kelless', 'keenness']], [['aabbcc', 'abc', 'aabb']], [['']], [['abcd']], [['aaaa', 'bbbb', 'cccc']], [['aabbaa', 'bbccdd', 'aabbcc']], [['a', 'b', 'c', 'd']]]"}}
{"requirement": "def is_triangle(a: int, b: int, c: int) -> bool:\n\"\"\"Implement a method that accepts 3 integer values a, b, c. The method should return true if a triangle can be built with the sides of given length and false in any other case.\n\n(In this case, all triangles must have surface greater than 0 to be accepted).\n\"\"\"", "inputs": [[1, 2, 2], [7, 2, 2], [1, 2, 3], [1, 3, 2], [3, 1, 2], [5, 1, 2], [1, 2, 5], [2, 5, 1], [4, 2, 3], [5, 1, 5], [2, 2, 2], [-1, 2, 3], [1, -2, 3], [1, 2, -3], [0, 2, 3]], "outputs": [[true], [false], [false], [false], [false], [false], [false], [false], [true], [true], [true], [false], [false], [false], [false]], "starter_code": "def is_triangle(a: int, b: int, c: int) -> bool:", "canonical_solution": "def is_triangle(a, b, c):\n    return a < b + c and b < a + c and (c < a + b)", "entry_point": "is_triangle", "task_id": "TACO_lite/166", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[3, 4, 5], [1, 2, 3], [0, 1, 2], [1, 1, 1], [10, 10, 10], [2, 2, 5], [-1, 2, 3], [100, 200, 300], [5, 12, 13], [7, 24, 25], [1, 1, 2], [1, 2, 4], [3, 3, 7], [1000000, 1000000, 1000000], [0, 0, 0]]", "qwen2.5-coder-32b-instruct": "[[3, 4, 5], [1, 2, 3], [5, 5, 5], [0, 0, 0], [10, 1, 1], [7, 10, 5], [1, 1, 2], [-1, -1, -1], [1000, 1000, 1000], [2, 2, 3]]"}}
{"requirement": "def graceful_tipping(bill: float) -> float:\n\"\"\"Adding tip to a restaurant bill in a graceful way can be tricky, thats why you need make a function for it.\n\nThe function will receive the restaurant bill (always a positive number) as an argument. You need to 1) **add at least 15%** in tip, 2) round that number up to an *elegant* value and 3) return it.\n\nWhat is an *elegant* number? It depends on the magnitude of the number to be rounded. Numbers below 10 should simply be rounded to whole numbers. Numbers 10 and above should be rounded like this:\n\n10 - 99.99... ---> Round to number divisible by 5\n\n100 - 999.99... ---> Round to number divisible by 50\n\n1000 - 9999.99... ---> Round to number divisible by 500\n\nAnd so on...\n\nGood luck!\n\n## Examples\n```\n 1  -->    2\n 7  -->    9\n12  -->   15\n86  -->  100\n```\n\"\"\"", "inputs": [[1], [7], [12], [86], [99], [1149], [983212]], "outputs": [[2], [9], [15], [100], [150], [1500], [1500000]], "starter_code": "def graceful_tipping(bill: float) -> float:", "canonical_solution": "from math import ceil, log10\n\ndef graceful_tipping(bill):\n    bill *= 1.15\n    if bill < 10:\n        return ceil(bill)\n    e = int(log10(bill))\n    unit = 10 ** e / 2\n    return ceil(bill / unit) * unit", "entry_point": "graceful_tipping", "task_id": "TACO_lite/169", "input_output_examples": "[[[1.0], [7.0], [12.0], [86.0]], [[2.0], [9.0], [15.0], [100.0]]]", "llm_generated_inputs": {"deepseek-v3": "[[1.0], [7.0], [12.0], [86.0], [0.5], [99.99], [100.0], [999.99], [1000.0], [9999.99], [10000.0], [12345.67], [10.0], [50.0], [200.0], [500.0], [1001.0], [4999.99], [5000.0], [10000.01]]", "qwen2.5-coder-32b-instruct": "[[1], [7], [12], [86], [10], [14], [49], [50], [99], [100], [150], [499], [500], [999], [1000], [1500], [4999], [5000], [9999], [10000], [15000], [49999], [50000], [99999], [100000], [150000]]"}}
{"requirement": "def decrypt(text: str, n: int) -> str:\n\"\"\"For building the encrypted string:Take every 2nd char from the string, then the other chars, that are not every 2nd char, and concat them as new String.\n\n\nDo this n times!\n\nExamples:\n```\n\"This is a test!\", 1 -> \"hsi  etTi sats!\"\n\"This is a test!\", 2 -> \"hsi  etTi sats!\" -> \"s eT ashi tist!\"\n```\n\nWrite two methods:\n```python\ndef encrypt(text, n)\ndef decrypt(encrypted_text, n)\n```\n\n```Fsharp\nlet encrypt (str:string) (n:int) -> string\nlet decrypt (str:string) (n:int) -> string\n```\n\nFor both methods:\nIf the input-string is null or empty return exactly this value!\nIf n is <= 0 then return the input text.\n\nThis kata is part of the Simple Encryption Series:\nSimple Encryption #1 - Alternating Split\nSimple Encryption #2 - Index-Difference\nSimple Encryption #3 - Turn The Bits Around\nSimple Encryption #4 - Qwerty\n\nHave fun coding it and please don't forget to vote and rank this kata! :-)\n\"\"\"", "inputs": [["This is a test!", 0], ["hsi  etTi sats!", 1], ["s eT ashi tist!", 2], [" Tah itse sits!", 3], ["This is a test!", 4], ["This is a test!", -1], ["hskt svr neetn!Ti aai eyitrsig", 1], ["", 0], [null, 0]], "outputs": [["This is a test!"], ["This is a test!"], ["This is a test!"], ["This is a test!"], ["This is a test!"], ["This is a test!"], ["This kata is very interesting!"], [""], [null]], "starter_code": "def decrypt(text: str, n: int) -> str:", "canonical_solution": "def decrypt(text, n):\n    if text in ('', None):\n        return text\n    ndx = len(text) // 2\n    for i in range(n):\n        a = text[:ndx]\n        b = text[ndx:]\n        text = ''.join((b[i:i + 1] + a[i:i + 1] for i in range(ndx + 1)))\n    return text\n\ndef encrypt(text, n):\n    for i in range(n):\n        text = text[1::2] + text[::2]\n    return text", "entry_point": "decrypt", "task_id": "TACO_lite/171", "input_output_examples": "[[['This is a test!', 1], ['This is a test!', 2]], [['hsi  etTi sats!'], ['s eT ashi tist!']]]", "llm_generated_inputs": {"deepseek-v3": "[['hsi  etTi sats!', 1], ['s eT ashi tist!', 2], ['This is a test!', 0], ['This is a test!', -1], ['', 1], [None, 1], ['A', 1], ['1234567890', 3], ['abcdefgh', 2], ['Hello, World!', 1]]", "qwen2.5-coder-32b-instruct": "[['hsi  etTi sats!', 1], ['s eT ashi tist!', 2], ['', 1], ['a', 1], ['ab', 0], ['ab', -1], ['This is a test!', 0], ['This is a test!', -5], ['hsi  etTi sats!', 0], ['s eT ashi tist!', -2]]"}}
{"requirement": "from typing import List\n\n\ndef find(seq: List[int]) -> float:\n\"\"\"If you have not ever heard the term **Arithmetic Progrossion**, refer to: \nhttp://www.codewars.com/kata/find-the-missing-term-in-an-arithmetic-progression/python\n\nAnd here is an unordered version. Try if you can survive lists of **MASSIVE** numbers (which means time limit should be considered). :D\n\nNote: Don't be afraid that the minimum or the maximum element in the list is missing, e.g. [4, 6, 3, 5, 2] is missing 1 or 7, but this case is excluded from the kata.\n\nExample:\n\n```python\nfind([3, 9, 1, 11, 13, 5]) # => 7\n```\n\"\"\"", "inputs": [[[3, 9, 1, 11, 13, 5]], [[5, -1, 0, 3, 4, -3, 2, -2]], [[2, -2, 8, -8, 4, -4, 6, -6]]], "outputs": [[7], [1], [0]], "starter_code": "from typing import List\ndef find(seq: List[int]) -> float:", "canonical_solution": "def find(seq):\n    return (min(seq) + max(seq)) * (len(seq) + 1) / 2 - sum(seq)", "entry_point": "find", "task_id": "TACO_lite/172", "input_output_examples": "[[[[3, 9, 1, 11, 13, 5]]], [[7]]]", "llm_generated_inputs": {"deepseek-v3": "[[[3, 9, 1, 11, 13, 5]], [[10, 20, 30, 50, 40]], [[100, 200, 400, 300]], [[1, 3, 5, 9, 7]], [[15, 5, 10]], [[7, 17, 27, 37, 57, 47]], [[1000, 2000, 4000, 3000]], [[1, 5, 7, 9, 11, 13]], [[2, 4, 8, 10, 6]], [[99, 199, 299, 499, 399]]]", "qwen2.5-coder-32b-instruct": "[[[3, 9, 1, 11, 13, 5]], [[10, 20, 30, 50, 40]], [[1, 3, 5, 9, 7]], [[5, 15, 25, 35, 45, 55, 65, 75, 85, 95, 105, 115, 125, 135, 145, 155, 165, 175, 185, 195]], [[2, 4, 6, 10, 8]], [[100, 200, 300, 500, 400]], [[1, 2, 4, 5]], [[0, 0, 0, 0]], [[1000000, 1000002, 1000004, 1000006, 1000008, 1000010, 1000012, 1000014, 1000016, 1000018, 1000020, 1000022, 1000024, 1000026, 1000028, 1000030, 1000032, 1000034, 1000036, 1000038]]]"}}
{"requirement": "def num_blocks(w: int, l: int, h: int) -> float:\n\"\"\"Consider a pyramid made up of blocks. Each layer of the pyramid is a rectangle of blocks, and the dimensions of these rectangles increment as you descend the pyramid. So, if a layer is a `3x6` rectangle of blocks, then the next layer will be a `4x7` rectangle of blocks. A `1x10` layer will be on top of a `2x11` layer on top of a `3x12` layer, and so on.\n\n## Task\n\nGiven the dimensions of a pyramid's topmost layer `w,l`, and its height `h` (aka the number of layers), return the total number of blocks in the pyramid.\n\n## Examples\n\n`num_blocks(1, 1, 2)` will return `5`. This pyramid starts with a `1x1` layer and has 2 layers total. So, there is 1 block in the first layer, and `2x2=4` blocks in the second. Thus, 5 is the total number of blocks.\n\n`num_blocks(2, 4, 3)` will return `47`. This pyramid has 3 layers: `2x4`, `3x5`, and `4x6`. So, there are `47` blocks total.\n\n## Notes\n\nAll parameters will always be postive nonzero integers.\n\nEfficiency is important. There will be:\n\n* 100 'small' cases with `w`, `l`, and `h` below `20`.\n* 100 'big' cases with `w`, `l`, and `h` between `1e9` and `1e10`.\n\"\"\"", "inputs": [[1, 1, 2], [2, 4, 3], [1, 10, 10], [20, 30, 40]], "outputs": [[5], [47], [880], [83540]], "starter_code": "def num_blocks(w: int, l: int, h: int) -> float:", "canonical_solution": "def num_blocks(w, l, h):\n    return w * l * h + (w + l) * h * (h - 1) / 2 + h * (h - 1) * (2 * h - 1) / 6", "entry_point": "num_blocks", "task_id": "TACO_lite/176", "input_output_examples": "[[[1, 1, 2], [2, 4, 3]], [[5], [47]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 1, 1], [1, 1, 2], [2, 4, 3], [3, 3, 3], [5, 10, 4], [10, 10, 10], [20, 20, 20], [1000000000.0, 1000000000.0, 1000000000.0], [10000000000.0, 10000000000.0, 10000000000.0], [1, 10000000000.0, 1], [10000000000.0, 1, 10000000000.0], [1, 2, 3], [2, 3, 1], [3, 2, 1], [1, 3, 2], [3, 1, 2], [2, 1, 3]]", "qwen2.5-coder-32b-instruct": "[[1, 1, 2], [2, 4, 3], [1, 1, 1], [10, 10, 10], [19, 19, 19], [20, 20, 20], [1000000000.0, 1000000000.0, 1], [1000000000.0, 1000000000.0, 2], [1000000000.0, 10000000000.0, 1000000000.0], [10000000000.0, 10000000000.0, 10000000000.0]]"}}
{"requirement": "from typing import List\n\n\ndef calc(a: List[int]) -> int:\n\"\"\"# Task\n\nJohn won the championship of a TV show. He can get some bonuses.\n\nHe needs to play a game to determine the amount of his bonus.\n\nHere are some cards in a row. A number is written on each card.\n\nIn each turn, John can take a card, but only from the beginning or the end of the row. Then multiply the number on the card by an coefficient 2^(i)(i means the ith turn). The product is John's bonus of current turn.\n\nAfter all the cards are taken away, the game is over. John's final bonus is the sum of all rounds of bonuses.\n\nObviously, the order in which John takes the cards will affect the amount of John's final bonus.\n\nYour task is to help John calculate the maximum amount of bonuses he can get.\n\n# Input\n\n- `cards`: An integer array. Each element represents the number on the card.\n  - `1 <= cards.length <= 30`\n  - `1 <= cards[i] <= 100`\n\n\n- All inputs are valid.\n\n# Output\n\nAn integer. the maximum amount of bonuses John can get.\n\n# Eaxmple\n\nFor `cards=[1,2,5]`, the output should be `50`.\n\n```\nAll possible orders are:\n1->2->5   bonus:1x2+2*4+5*8=50\n1->5->2   bonus:1x2+5*4+2*8=38\n5->1->2   bonus:5*2+1*4+2*8=30\n5->2->1   bonus:5*2+2*4+1*8=26\nThe maximum amount of bonus is 50.\n```\n\"\"\"", "inputs": [[[1, 2, 5]], [[1]], [[1, 1]], [[1, 2, 1]], [[4, 10, 2, 3, 1, 3, 1, 6, 9]]], "outputs": [[50], [2], [6], [22], [6722]], "starter_code": "from typing import List\ndef calc(a: List[int]) -> int:", "canonical_solution": "def calc(a):\n    res = [0] * (len(a) + 1)\n    for k in range(len(a)):\n        res = [2 * max(a[i] + res[i + 1], a[i + k] + res[i]) for i in range(len(a) - k)]\n    return res[0]", "entry_point": "calc", "task_id": "TACO_lite/182", "input_output_examples": "[[[[1, 2, 5]]], [[50]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 5]], [[1]], [[10, 20]], [[3, 1, 5, 8]], [[1, 2, 3, 4, 5]], [[100, 100, 100, 100]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[5, 10, 15, 20, 25, 30, 35, 40, 45, 50]], [[1, 3, 1, 3, 1, 3, 1, 3]], [[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 5]], [[10, 20, 30]], [[1, 1, 1, 1]], [[100]], [[1, 3, 5, 7, 9]], [[30, 20, 10]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]], [[30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]], [[1, 100, 1, 100, 1, 100]]]"}}
{"requirement": "def finance(n: int) -> float:\n\"\"\"I need to save some money to buy a gift. I think I can do something like that:\n\nFirst week (W0) I save nothing on Sunday, 1 on Monday, 2 on Tuesday... 6 on Saturday,\nsecond week (W1) 2 on Monday... 7 on Saturday and so on according to the table below where the days are numbered from 0 to 6.\n\nCan you tell me how much I will have for my gift on Saturday evening after I have saved 12? (Your function finance(6) should return 168 which is the sum of the savings in the table). \n\nImagine now that we live on planet XY140Z-n where the days of the week are numbered from 0 to n (integer n > 0) and where\nI save from week number 0 to week number n included (in the table below n = 6).\n\nHow much money would I have at the end of my financing plan on planet XY140Z-n?\n\n\n\n  -- |Su|Mo|Tu|We|Th|Fr|Sa|\n   --|--|--|--|--|--|--|--|\n  W6 |  |  |  |  |  |  |12|\n  W5 |  |  |  |  |  |10|11|\n  W4 |  |  |  |  |8 |9 |10|\n  W3 |  |  |  |6 |7 |8 |9 |\n  W2 |  |  |4 |5 |6 |7 |8 |\n  W1 |  |2 |3 |4 |5 |6 |7 |\n  W0 |0 |1 |2 |3 |4 |5 |6 |\n  \n#Example:\n```\nfinance(5) --> 105\nfinance(6) --> 168\nfinance(7) --> 252\nfinance(5000) --> 62537505000\n```\n#Hint: \ntry to avoid nested loops\n\"\"\"", "inputs": [[5], [6], [8], [15], [100], [365], [730], [999], [2000], [4000], [5000]], "outputs": [[105], [168], [360], [2040], [515100], [24513765], [195308580], [499999500], [4006002000], [32024004000], [62537505000]], "starter_code": "def finance(n: int) -> float:", "canonical_solution": "def finance(n):\n    return n * (n + 1) * (n + 2) / 2", "entry_point": "finance", "task_id": "TACO_lite/185", "input_output_examples": "[[[5], [6], [7], [5000]], [[105], [168], [252], [62537505000]]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [5], [6], [7], [10], [100], [5000]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [7], [10], [100], [500], [1000], [5000], [10000], [1], [0], [-1]]"}}
{"requirement": "def womens_age(n: int) -> str:\n\"\"\"As you may know, once some people pass their teens, they jokingly only celebrate their 20th or 21st birthday, forever. With some maths skills, that's totally possible - you only need to select the correct number base!\n\nFor example, if they turn 32, that's exactly 20 - in base 16... Already 39? That's just 21, in base 19!\n\nYour task is to translate the given age to the much desired 20 (or 21) years, and indicate the number base, in the format specified below.\n\n**Note:** input will be always > 21\n\n\n### Examples:\n\n```\n32  -->  \"32? That's just 20, in base 16!\"\n39  -->  \"39? That's just 21, in base 19!\"\n```\n\n*Hint: if you don't know (enough) about [numeral systems](https://en.wikipedia.org/wiki/Numeral_system) and [radix](https://en.wikipedia.org/wiki/Radix), just observe the pattern!*\n\n---\n\n## My other katas\n\nIf you enjoyed this kata then please try [my other katas](https://www.codewars.com/collections/katas-created-by-anter69)! :-)\n\n---\n\n### *Translations are welcome!*\n\"\"\"", "inputs": [[32], [39], [22], [65], [83]], "outputs": [["32? That's just 20, in base 16!"], ["39? That's just 21, in base 19!"], ["22? That's just 20, in base 11!"], ["65? That's just 21, in base 32!"], ["83? That's just 21, in base 41!"]], "starter_code": "def womens_age(n: int) -> str:", "canonical_solution": "def womens_age(n):\n    return f\"{n}? That's just {20 + n % 2}, in base {n // 2}!\"", "entry_point": "womens_age", "task_id": "TACO_lite/186", "input_output_examples": "[[[32], [39]], [[\"32? That's just 20, in base 16!\"], [\"39? That's just 21, in base 19!\"]]]", "llm_generated_inputs": {"deepseek-v3": "[[22], [32], [39], [40], [50], [60], [70], [80], [90], [100], [200], [300], [400], [500]]", "qwen2.5-coder-32b-instruct": "[[32], [39], [22], [40], [50], [100], [200], [255]]"}}
{"requirement": "from typing import List\n\n\ndef istree(matrix: List[List[int]]) -> bool:\n\"\"\"In graph theory, a graph is a collection of nodes with connections between them.\nAny node can be connected to any other node exactly once, and can be connected to no nodes, to some nodes, or to every other node.\nNodes cannot be connected to themselves\nA path through a graph is a sequence of nodes, with every node connected to the node following and preceding it.\nA closed path is a path which starts and ends at the same node.\n\nAn open path:\n```\n1 -> 2 -> 3\n```\na closed path:\n```\n1 -> 2 -> 3 -> 1\n```\nA graph is connected if there is a path from every node to every other node.\nA graph is a tree if it is connected and there are no closed paths.\n\n\nYour job is to write a function 'istree', which returns true if a graph is a tree, and false if it is not a tree.\n\nGraphs will be given as an array with each item being an array of integers which are the nodes that node is connected to.\n\nFor example, this graph:\n```\n0--1\n|  |\n2--3--4\n```\nhas array:\n```\n[[1,2], [0,3], [0,3], [1,2,4], [3]]\n```\nNote that it is also not a tree, because it contains closed path:\n```\n0->1->3->2->0\n```\nA node with no connections is an empty array\nNote that if node 0 is connected to node 1, node 1 is also connected to node 0. This will always be true.\nThe order in which each connection is listed for each node also does not matter.\n\nGood luck!\n\"\"\"", "inputs": [[[[], []]], [[[1], [0]]], [[[1, 2], [0, 2], [0, 1]]], [[[1, 2, 3], [0, 2], [1, 2], [0]]], [[[1, 2, 3], [0], [0], [0, 4], [3]]], [[[1, 2, 3], [0], [0], [0, 4], [3], []]], [[[1], [0, 2], [1, 3, 5], [2, 4], [3, 5], [4, 2]]], [[[1], [0, 2, 3, 4], [1], [1], [1]]], [[[1], [0, 2, 3], [1], [1], [5], [4, 6, 7], [5], [5]]], [[[1, 2], [0, 3], [0, 3], [1, 2, 4], [3]]], [[[1, 2], [0, 2], [0, 1], []]], [[[1, 2], [0, 2], [0, 1], [4], [3]]]], "outputs": [[false], [true], [false], [false], [true], [false], [false], [true], [false], [false], [false], [false]], "starter_code": "from typing import List\ndef istree(matrix: List[List[int]]) -> bool:", "canonical_solution": "def istree(matrix):\n    visited_nodes = set([0])\n    crossed_edges = set()\n    agenda = [0]\n    while agenda:\n        node = agenda.pop()\n        for i in matrix[node]:\n            if (node, i) in crossed_edges:\n                continue\n            if i in visited_nodes:\n                return False\n            agenda.append(i)\n            crossed_edges.add((i, node))\n            visited_nodes.add(i)\n    return len(visited_nodes) == len(matrix)", "entry_point": "istree", "task_id": "TACO_lite/188", "input_output_examples": "[[[[[1, 2], [0, 3], [0, 3], [1, 2, 4], [3]]]], [[False]]]", "llm_generated_inputs": {"deepseek-v3": "[[[[1, 2], [0, 3], [0, 3], [1, 2, 4], [3]]], [[[1, 2], [0], [0]]], [[[1], [0, 2], [1]]], [[[], [], []]], [[[1], [0]]], [[[1, 2], [0, 2], [0, 1]]], [[[1, 2, 3], [0, 3], [0, 3], [0, 1, 2]]], [[[1, 2, 3], [0, 3], [0, 3], [0, 1, 2, 4], [3]]], [[[1], [0, 2, 3], [1], [1]]], [[[1, 2], [0, 3], [0, 4], [1], [2]]]]", "qwen2.5-coder-32b-instruct": "[[[[1, 2], [0, 3], [0, 3], [1, 2, 4], [3]]], [[[1], [0], [], []]], [[[1, 2], [0], [0]]], [[[], [], []]], [[[1], [0, 2], [1]]], [[[1, 2, 3], [0, 3], [0], [0, 1]]], [[[1], [0, 2], [1, 3], [2]]], [[[1, 2], [0, 3, 4], [0], [1], [1]]], [[]], [[[1, 2], [0], [0], [4], [3]]]]"}}
{"requirement": "def graytobinary(n: int) -> int:\n\"\"\"Given N in Gray Code, find its binary equivalent. Return the decimal representation of the binary equivalent.\nExample 1:\nInput: N = 4\nOutput: 7\nExplanation:\nGiven 4 representing gray code 110.\nBinary equivalent of gray code 110 is 100.\nReturn 7 representing gray code 100.\nExample 2:\nInput: N = 15\nOutput: 10\nExplanation:\nGiven 15 representing gray code 1000.\nBinary equivalent of gray code 1000 is 1111.\nReturn 10 representing gray code 1111 \nie binary 1010.\nExample 3:\nInput: N = 0\nOutput: 0\nExplanation: \nZero remains the same in all systems.\nYour Task: \nYou don't need to read input or print anything. Your task is to complete the function graytobinary() which accepts an integer n as an input parameter and returns decimal of the binary equivalent of the given gray code. \nExpected Time Complexity: O(log N)\nExpected Auxiliary Space: O(1)\nConstraints:\n0 <= N <= 10^{8}\n\"\"\"", "inputs": [[4], [15], [0]], "outputs": [[7], [10], [0]], "starter_code": "def graytobinary(n: int) -> int:", "canonical_solution": "def graytobinary(n: int) -> int:\n    binary = n\n    while n > 0:\n        n >>= 1\n        binary ^= n\n    return binary", "entry_point": "graytobinary", "task_id": "TACO_lite/189", "input_output_examples": "[[[4], [15], [0]], [[7], [10], [0]]]", "llm_generated_inputs": {"deepseek-v3": "[[4], [15], [0], [1], [7], [10], [255], [100000000], [2], [6]]", "qwen2.5-coder-32b-instruct": "[[4], [15], [0], [1], [2], [3], [255], [1023], [100000000]]"}}
{"requirement": "from typing import List\n\n\ndef switcher(arr: List[str]) -> str:\n\"\"\"Given an array of numbers (in string format), you must return a string. The numbers correspond to the letters of the alphabet in reverse order: a=26, z=1 etc. You should also account for `'!'`, `'?'` and `' '` that are represented by '27', '28' and '29' respectively.\n\nAll inputs will be valid.\n\"\"\"", "inputs": [[["24", "12", "23", "22", "4", "26", "9", "8"]], [["25", "7", "8", "4", "14", "23", "8", "25", "23", "29", "16", "16", "4"]], [["4", "24"]], [["12"]], [["12", "28", "25", "21", "25", "7", "11", "22", "15"]]], "outputs": [["codewars"], ["btswmdsbd kkw"], ["wc"], ["o"], ["o?bfbtpel"]], "starter_code": "from typing import List\ndef switcher(arr: List[str]) -> str:", "canonical_solution": "def switcher(arr):\n    d = {str(i): chr(123 - i) for i in range(1, 27)}\n    d.update({'27': '!'})\n    d.update({'28': '?'})\n    d.update({'29': ' '})\n    d.update({'0': ''})\n    return ''.join([d[str(i)] for i in arr])", "entry_point": "switcher", "task_id": "TACO_lite/190", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[['1', '2', '3']], [['26', '25', '24']], [['27']], [['28']], [['29']], [['1', '27', '26']], [['28', '29', '3']], [['20', '15', '12']], [['29', '29', '29']], [['27', '28', '29']], [['1']], [['26']], [['15', '15', '15']]]", "qwen2.5-coder-32b-instruct": "[[['26']], [['1']], [['27']], [['28']], [['29']], [['15', '22', '5']], [['29', '28', '27']], [['13', '9', '19', '1', '20', '18', '26', '9', '19', '8', '1', '20', '18', '4', '26', '20', '23', '5', '18', '19', '26']], [['26', '25', '24', '23', '22', '21', '20', '19', '18', '17', '16', '15', '14', '13', '12', '11', '10', '9', '8', '7', '6', '5', '4', '3', '2', '1']], [['29', '29', '29']], [['27', '28', '29', '26', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25']]]"}}
{"requirement": "def find_min_num(d: int, n: int = 1) -> int:\n\"\"\"The number ```12``` is the first number in having six divisors, they are: ```1, 2, 3, 4, 6 and 12.```\nYour challenge for this kata is to find the minimum number that has a certain number of divisors.\nFor this purpose we have to create the function \n\n```find_min_num() or findMinNum() or similar in the other languages```\n\nthat receives the wanted number of divisors ```num_div```, and outputs the smallest number having an amount of divisors equals to ```num_div```.\n\nLet's see some cases:\n```\nfind_min_num(10) = 48 # divisors are: 1, 2, 3, 4, 6, 8, 12, 16, 24 and  48\nfind_min_num(12) = 60\n```\nIn this kata all the tests will be with ```numDiv < 80```\n\n(There will be a next kata with numDiv < 10000, Find the First Number Having a Certain Number of Divisors II, should have the help of number theory)\n\nEnjoy it and happy coding!\n(Memoization is advisable)\n\"\"\"", "inputs": [[6], [10], [12], [13]], "outputs": [[12], [48], [60], [4096]], "starter_code": "def find_min_num(d: int, n: int = 1) -> int:", "canonical_solution": "def find_min_num(d, n=1):\n    while div_num(n) != d:\n        n += 1\n    return n\n\ndef div_num(n):\n    s = n ** 0.5\n    return sum((2 for k in range(1, int(s) + 1) if n % k == 0)) - (s % 1 == 0)", "entry_point": "find_min_num", "task_id": "TACO_lite/192", "input_output_examples": "[[[10], [[12]]], [[48], [[60]]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 1], [2, 2], [3, 4], [4, 6], [5, 16], [6, 12], [10, 48], [12, 60], [15, 144], [20, 240], [25, 1296], [30, 720], [40, 5040], [50, 25200], [60, 55440], [70, 720720], [79, 12697650]]", "qwen2.5-coder-32b-instruct": "[[1, 1], [2, 1], [3, 1], [4, 1], [5, 1], [6, 1], [7, 1], [8, 1], [9, 1], [10, 1], [11, 1], [12, 1], [13, 1], [14, 1], [15, 1], [16, 1], [17, 1], [18, 1], [19, 1], [20, 1], [21, 1], [22, 1], [23, 1], [24, 1], [25, 1], [26, 1], [27, 1], [28, 1], [29, 1], [30, 1], [31, 1], [32, 1], [33, 1], [34, 1], [35, 1], [36, 1], [37, 1], [38, 1], [39, 1], [40, 1], [41, 1], [42, 1], [43, 1], [44, 1], [45, 1], [46, 1], [47, 1], [48, 1], [49, 1], [50, 1], [51, 1]]"}}
{"requirement": "def house_of_cards(n: int) -> float:\n\"\"\"You want to build a standard house of cards, but you don't know how many cards you will need. Write a program which will count the minimal number of cards according to the number of floors you want to have. For example, if you want a one floor house, you will need 7 of them (two pairs of two cards on the base floor, one horizontal card and one pair to get the first floor). Here you can see which kind of house of cards I mean:\nhttp://www.wikihow.com/Build-a-Tower-of-Cards\n\n## Note about floors:\nThis kata uses the British numbering system for building floors. If you want your house of cards to have a first floor, it needs a ground floor and then a first floor above that.\n\n### Details (Ruby & JavaScript & Python & R)\nThe input must be an integer greater than 0, for other input raise an error.\n\n### Details (Haskell)\nThe input must be an integer greater than 0, for other input return `Nothing`.\n\"\"\"", "inputs": [[1], [2], [3]], "outputs": [[7], [15], [26]], "starter_code": "def house_of_cards(n: int) -> float:", "canonical_solution": "def house_of_cards(n):\n    if n >= 1:\n        return (n + 1) * n / 2 + (n + 2) * (n + 1)\n    raise ValueError", "entry_point": "house_of_cards", "task_id": "TACO_lite/195", "input_output_examples": "[[[1]], [[7]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [10], [0], [-1], [100], [1000]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [10], [100], [0], [-1], [-5], [0.5], [1.5], ['a'], [[1]], [{'key': 'value'}]]"}}
{"requirement": "def the_biggest_search_keys(*keys: str) -> str:\n\"\"\"You're a programmer in a SEO company. The SEO specialist of your company gets the list of all project keywords everyday, then he looks for the longest keys to analyze them.\n\nYou will get the list with keywords and must write a simple function that returns the biggest search keywords and sorts them in lexicographical order.\n\nFor instance you might get:\n```python\n'key1', 'key2', 'key3', 'key n', 'bigkey2', 'bigkey1'\n```\n\nAnd your function should return:\n```python\n\"'bigkey1', 'bigkey2'\"\n```\n\nDon't forget to rate this kata! Thanks :)\n\"\"\"", "inputs": [["key1", "key22", "key333"], ["coding", "sorting", "tryruby"], ["small keyword", "how to coding?", "very nice kata", "a lot of keys", "I like Ruby!!!"], ["pippi"]], "outputs": [["'key333'"], ["'sorting', 'tryruby'"], ["'I like Ruby!!!', 'how to coding?', 'very nice kata'"], ["'pippi'"]], "starter_code": "def the_biggest_search_keys(*keys: str) -> str:", "canonical_solution": "def the_biggest_search_keys(*keys):\n    L = sorted(keys, key=lambda key: (-len(key), key))\n    i = next((i for i, key in enumerate(L) if len(key) != len(L[0])), None)\n    return str(L[:i])[1:-1] or \"''\"", "entry_point": "the_biggest_search_keys", "task_id": "TACO_lite/197", "input_output_examples": "[[['key1', 'key2', 'key3', 'key n', 'bigkey2', 'bigkey1']], [['bigkey1', 'bigkey2']]]", "llm_generated_inputs": {"deepseek-v3": "[['single_key']]", "qwen2.5-coder-32b-instruct": "[['single']]"}}
{"requirement": "from typing import List\n\n\ndef strange_coach(players: List[str]) -> str:\n\"\"\"# Task\n Mirko has been moving up in the world of basketball. He started as a mere spectator, but has already reached the coveted position of the national team coach!\n\n Mirco is now facing a difficult task: selecting five primary players for the upcoming match against Tajikistan. Since Mirko is incredibly lazy, he doesn't bother remembering players' names, let alone their actual skills. That's why he has settled on selecting five players who share the same first letter of their surnames, so that he can remember them easier. If there are no five players sharing the first letter of their surnames, Mirko will simply forfeit the game!\n\n Your task is to find the first letters Mirko's players' surnames can begin with(In alphabetical order), or return `\"forfeit\"` if Mirko can't gather a team.\n\n# Input/Output\n\n\n - `[input]` string array `players`\n\n  Array of players' surnames, consisting only of lowercase English letters.\n\n \n - `[output]` a string\n\n  A **sorted** string of possible first letters, or \"forfeit\" if it's impossible to gather a team.\n\n\n# Example\n\nFor `players = [\"michael\",\"jordan\",\"lebron\",\"james\",\"kobe\",\"bryant\"]`, the output should be `\"forfeit\"`.\n\n For\n ```\n players = [\"babic\",\"keksic\",\"boric\",\"bukic\",\n              \"sarmic\",\"balic\",\"kruzic\",\"hrenovkic\",\n              \"beslic\",\"boksic\",\"krafnic\",\"pecivic\",\n              \"klavirkovic\",\"kukumaric\",\"sunkic\",\"kolacic\",\n              \"kovacic\",\"prijestolonasljednikovic\"]\n```\nthe output should be \"bk\".\n\"\"\"", "inputs": [[["michael", "jordan", "lebron", "james", "kobe", "bryant"]], [["babic", "keksic", "boric", "bukic", "sarmic", "balic", "kruzic", "hrenovkic", "beslic", "boksic", "krafnic", "pecivic", "klavirkovic", "kukumaric", "sunkic", "kolacic", "kovacic", "prijestolonasljednikovic"]], [["jgztazpytubijfsmjz", "bokvgratzzdibku", "qineboilzoqdqivc", "bfctyltibtkbxq", "vioxcuhqhikxeqwekqkjo", "nrvsdhttr", "eiaoajuwxpwmyliqikzcchid", "bxrwawgor", "gbsqaxotzmblxttj", "kwchrcaconuwaivhvnyf", "neiemapiica", "bppao", "bxujiwivsjfbqrzygpdgkyz", "jnzrhhmcgcpffflpzwmqib", "jhozlevckrrwimdmyzc", "bomojotkqqditelsk", "ywmbheywzfyqjjs", "snwrclyjkbspysjftcmyak", "eelrsgkuhu", "dnyzsvqjjuqoc"]]], "outputs": [["forfeit"], ["bk"], ["b"]], "starter_code": "from typing import List\ndef strange_coach(players: List[str]) -> str:", "canonical_solution": "from collections import Counter\n\ndef strange_coach(players):\n    return ''.join(sorted((i for i, j in Counter(map(lambda x: x[0], players)).most_common() if j >= 5))) or 'forfeit'", "entry_point": "strange_coach", "task_id": "TACO_lite/198", "input_output_examples": "[[[['michael', 'jordan', 'lebron', 'james', 'kobe', 'bryant']], [['babic', 'keksic', 'boric', 'bukic', 'sarmic', 'balic', 'kruzic', 'hrenovkic', 'beslic', 'boksic', 'krafnic', 'pecivic', 'klavirkovic', 'kukumaric', 'sunkic', 'kolacic', 'kovacic', 'prijestolonasljednikovic']]], [['forfeit'], ['bk']]]", "llm_generated_inputs": {"deepseek-v3": "[[['michael', 'jordan', 'lebron', 'james', 'kobe', 'bryant']], [['babic', 'keksic', 'boric', 'bukic', 'sarmic', 'balic', 'kruzic', 'hrenovkic', 'beslic', 'boksic', 'krafnic', 'pecivic', 'klavirkovic', 'kukumaric', 'sunkic', 'kolacic', 'kovacic', 'prijestolonasljednikovic']], [['smith', 'sanders', 'sullivan', 'santiago', 'sanchez', 'scott', 'stewart', 'santos', 'snyder', 'soto']], [['adams', 'baker', 'clark', 'davis', 'evans', 'fisher', 'garcia', 'harris', 'jackson', 'king']], [['a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'c', 'c', 'd', 'd', 'd', 'd', 'd']], [['x', 'y', 'z', 'xx', 'yy', 'zz', 'xxx', 'yyy', 'zzz', 'xxxx', 'yyyy', 'zzzz']], [[]], [['a', 'a', 'a', 'a']], [['a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'c', 'c', 'd', 'd', 'd', 'd', 'e', 'e', 'e', 'e', 'e', 'f', 'f', 'f', 'f', 'f']]]", "qwen2.5-coder-32b-instruct": "[[['michael', 'jordan', 'lebron', 'james', 'kobe', 'bryant']], [['babic', 'keksic', 'boric', 'bukic', 'sarmic', 'balic', 'kruzic', 'hrenovkic', 'beslic', 'boksic', 'krafnic', 'pecivic', 'klavirkovic', 'kukumaric', 'sunkic', 'kolacic', 'kovacic', 'prijestolonasljednikovic']], [['aaaaa', 'aaabb', 'aaacc', 'aadda', 'aeeea']], [['abc', 'bcd', 'cde', 'def', 'efg', 'fgh']], [['a', 'a', 'a', 'a', 'a']], [['z', 'y', 'x', 'w', 'v']], [['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']], [[]], [['same', 'sake', 'sale', 'sane', 'sang']]]"}}
{"requirement": "def get_free_urinals(urinals: str) -> int:\n\"\"\"# How many urinals are free?\nIn men's public toilets with urinals, there is this unwritten rule that you leave at least one urinal free\nbetween you and the next person peeing. \nFor example if there are 3 urinals and one person is already peeing in the left one, you will choose the\nurinal on the right and not the one in the middle.\nThat means that a maximum of 3 people can pee at the same time on public toilets with \n5 urinals when following this rule (Only 2 if the first person pees into urinal 2 or 4).\n\n![Imgur Urinals](https://i.imgur.com/imZE6xm.png)\n\n## Your task:\nYou need to write a function that returns the maximum of free urinals as an integer according to the unwritten rule.\n\n### Input\nA String containing 1s and 0s (Example: `10001`) (1 <= Length <= 20)  \nA one stands for a taken urinal and a zero for a free one. \n\n### Examples\n\n`10001` returns 1 (10101)  \n`1001` returns 0 (1001)  \n`00000` returns 3 (10101)  \n`0000` returns 2 (1001)  \n`01000` returns 1 (01010 or 01001) \n\n### Note\nWhen there is already a mistake in the input string (for example `011`), then return `-1`\n\nHave fun and don't pee into the wrong urinal ;)\n\"\"\"", "inputs": [["10001"], ["1001"], ["00000"], ["0000"], ["01000"], ["00010"], ["10000"], ["1"], ["0"], ["10"], ["110"], ["1011000001"]], "outputs": [[1], [0], [3], [2], [1], [1], [2], [0], [1], [0], [-1], [-1]], "starter_code": "def get_free_urinals(urinals: str) -> int:", "canonical_solution": "def get_free_urinals(urinals):\n    return -1 if '11' in urinals else sum(((len(l) - 1) // 2 for l in f'0{urinals}0'.split('1')))", "entry_point": "get_free_urinals", "task_id": "TACO_lite/199", "input_output_examples": "[[['10001'], ['1001'], ['00000'], ['0000'], ['01000']], [[1], [0], [3], [2], [1]]]", "llm_generated_inputs": {"deepseek-v3": "[['10001'], ['1001'], ['00000'], ['0000'], ['01000'], ['011'], ['1'], ['0'], ['1010101'], ['11111'], ['00000000000000000000'], ['10101010101010101010'], ['01010101010101010101'], ['110'], ['0110'], ['0011'], ['111'], ['000'], ['101'], ['010']]", "qwen2.5-coder-32b-instruct": "[['10001'], ['1001'], ['00000'], ['0000'], ['01000'], ['011'], ['1'], ['0'], ['10'], ['00'], ['10101'], ['11111'], ['01010'], ['10000'], ['00001']]"}}
{"requirement": "def abundant_number(num: int) -> bool:\n\"\"\"An abundant number or excessive number is a number for which the sum of its proper divisors is greater than the number itself. \n\nThe integer 12 is the first abundant number. Its proper divisors are 1, 2, 3, 4 and 6 for a total of 16 (> 12).\n\nDerive function `abundantNumber(num)/abundant_number(num)` which returns `true/True/.true.` if `num` is abundant, `false/False/.false.` if not.\n\"\"\"", "inputs": [[12], [18], [37], [120], [77], [118], [5830], [11410], [14771], [11690]], "outputs": [[true], [true], [false], [true], [false], [false], [true], [true], [false], [true]], "starter_code": "def abundant_number(num: int) -> bool:", "canonical_solution": "def abundant_number(num):\n    return sum([e for e in range(1, num) if num % e == 0]) > num", "entry_point": "abundant_number", "task_id": "TACO_lite/203", "input_output_examples": "[[[12]], [[True]]]", "llm_generated_inputs": {"deepseek-v3": "[[12], [6], [1], [18], [20], [24], [28], [945], [0], [-12]]", "qwen2.5-coder-32b-instruct": "[[12], [18], [20], [24], [30], [1], [2], [6], [28], [0], [-5]]"}}
{"requirement": "def opposite(number: float) -> float:\n\"\"\"Very simple, given a number, find its opposite.\n\nExamples:\n```\n1: -1\n14: -14\n-34: 34\n```\n\n~~~if:sql\nYou will be given a table: `opposite`, with a column: `number`. Return a table with a column: `res`.\n~~~\n\"\"\"", "inputs": [[1], [25.6], [0], [1425.2222], [-3.1458], [-95858588225]], "outputs": [[-1], [-25.6], [0], [-1425.2222], [3.1458], [95858588225]], "starter_code": "def opposite(number: float) -> float:", "canonical_solution": "def opposite(number):\n    return -number", "entry_point": "opposite", "task_id": "TACO_lite/204", "input_output_examples": "[[[1], [14], [-34]], [[-1], [-14], [34]]]", "llm_generated_inputs": {"deepseek-v3": "[[5.0], [-3.0], [0.0], [100.25], [-7.77]]", "qwen2.5-coder-32b-instruct": "[[1], [14], [-34], [0], [-0.0], [123.456], [-987.654], [10000000000.0], [-1e-10]]"}}
{"requirement": "def all_permuted(n: int) -> int:\n\"\"\"We have an array of unique elements. A special kind of permutation is the one that has all of its elements in a different position than the original.\n\nLet's see how many of these permutations may be generated from an array of four elements. We put the original array with square brackets and the wanted permutations with parentheses. \n\n\n```\narr = [1, 2, 3, 4]\n      (2, 1, 4, 3)\n      (2, 3, 4, 1)\n      (2, 4, 1, 3)\n      (3, 1, 4, 2)\n      (3, 4, 1, 2)\n      (3, 4, 2, 1)\n      (4, 1, 2, 3)\n      (4, 3, 1, 2)\n      (4, 3, 2, 1)\n      _____________\nA total of 9 permutations with all their elements in different positions than arr\n```\n\nThe task for this kata would be to create a code to count all these permutations for an array of certain length.\n\nFeatures of the random tests:\n```\nl = length of the array\n10 ≤ l ≤ 5000\n```\n\nSee the example tests.\n\nEnjoy it!\n\"\"\"", "inputs": [[1], [4], [30]], "outputs": [[0], [9], [97581073836835777732377428235481]], "starter_code": "def all_permuted(n: int) -> int:", "canonical_solution": "def all_permuted(n):\n    a, b = (0, 1)\n    for i in range(1, n):\n        a, b = (b, (i + 1) * (a + b))\n    return a", "entry_point": "all_permuted", "task_id": "TACO_lite/206", "input_output_examples": "[[[4]], [[9]]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [2], [3], [4], [5], [10], [50], [100], [5000]]", "qwen2.5-coder-32b-instruct": "[[4], [10], [5000], [11], [12], [20], [100], [500]]"}}
{"requirement": "def convergents_of_e(n: int) -> int:\n\"\"\"# Convergents of e\nThe square root of 2 can be written as an infinite continued fraction.\n![img](http://img0.ph.126.net/x1Hyc4iHQg0Jz2EInmT3ag==/6597639313681841979.png)  \nThe infinite continued fraction can be written, √2 = [1;(2)], (2) indicates that 2 repeats ad infinitum. In a similar way, √23 = [4;(1,3,1,8)].\n\nIt turns out that the sequence of partial values of continued fractions for square roots provide the best rational approximations. Let us consider the convergents for √2.\n![img](http://img1.ph.126.net/xme9gNBQdA7bvQkwIftznQ==/6597819633588793645.png)  \nHence the sequence of the first ten convergents for √2 are:\n\n1, 3/2, 7/5, 17/12, 41/29, 99/70, 239/169, 577/408, 1393/985, 3363/2378, …\n\nWhat is most surprising is that the important mathematical constant,\ne = [2; 1,2,1, 1,4,1, 1,6,1 , … , 1,2k,1, …].\n\nThe first ten terms in the sequence of convergents for e are:\n\n2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, …\n\nThe sum of digits in the numerator of the 10th convergent is 1+4+5+7=17.\n\nFind the sum of digits in the numerator of the mth convergent of the continued fraction for e.\n\n\n- Powered by [Project Euler](https://projecteuler.net/problem=65)\n\"\"\"", "inputs": [[57], [125], [298], [938], [3756], [18287], [2132], [9999], [788], [8787]], "outputs": [[125], [298], [938], [3756], [18287], [108346], [9469], [55534], [3151], [48461]], "starter_code": "def convergents_of_e(n: int) -> int:", "canonical_solution": "e = [1, 2]\nfor n in range(1, 10 ** 4):\n    for f in (1, 2 * n, 1):\n        e.append(f * e[-1] + e[-2])\nconvergents_of_e = lambda n: sum(map(int, str(e[n])))", "entry_point": "convergents_of_e", "task_id": "TACO_lite/207", "input_output_examples": "[[[10]], [[17]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [4], [5], [10], [15], [20], [25], [30]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [5], [10], [20], [50], [100]]"}}
{"requirement": "from typing import Union\n\n\ndef how_much_water(water: float, clothes: int, load: int) -> Union[str, float]:\n\"\"\"My washing machine uses ```water``` amount of water to wash ```clothes``` amount of clothes. You are given a ```load``` amount of clothes to wash.  For each single item of load above the standard amount of clothes, the washing machine will use 10% more water (multiplicative) to clean.\nFor example, if the amount of clothes is ```10```, the amount of water it requires is ```5``` and the load is  ```14```, then you need ```5 * 1.1 ^ (14 - 10)``` amount of water.\n\nWrite a function ```howMuchWater``` (JS)/```how_much_water``` (Python) to work out how much water is needed if you have a ```clothes``` amount of clothes.  The function will accept 3 parameters - ```howMuchWater(water, load, clothes)``` / ```how_much_water(water, load, clothes)```\n\nMy washing machine is an old model that can only handle double the amount of ```load```.  If the amount of ```clothes``` is more than 2 times the standard amount of ```load```, return ```'Too much clothes'```.  The washing machine also cannot handle any amount of clothes less than ```load```.  If that is the case, return ```'Not enough clothes'```.\n\nThe answer should be rounded to the nearest 2 decimal places.\n\"\"\"", "inputs": [[10, 10, 21], [10, 10, 2], [10, 11, 20], [50, 15, 29], [50, 15, 15]], "outputs": [["Too much clothes"], ["Not enough clothes"], [23.58], [189.87], [50]], "starter_code": "from typing import Union\ndef how_much_water(water: float, clothes: int, load: int) -> Union[str, float]:", "canonical_solution": "def how_much_water(water, clothes, load):\n    if load > 2 * clothes:\n        return 'Too much clothes'\n    if load < clothes:\n        return 'Not enough clothes'\n    for i in range(load - clothes):\n        water *= 1.1\n    return round(water, 2)", "entry_point": "how_much_water", "task_id": "TACO_lite/208", "input_output_examples": "[[[5.0, 14, 10], [5.0, 5, 10], [5.0, 25, 10]], [[7.33], ['Not enough clothes'], ['Too much clothes']]]", "llm_generated_inputs": {"deepseek-v3": "[[10.0, 5, 5], [10.0, 5, 6], [10.0, 5, 4], [10.0, 5, 10], [10.0, 5, 11], [10.0, 5, 0], [10.0, 5, 3], [10.0, 5, 7], [10.0, 5, 15], [10.0, 5, 1], [10.0, 5, 2]]", "qwen2.5-coder-32b-instruct": "[[5.0, 10, 10], [5.0, 10, 14], [5.0, 10, 20], [5.0, 10, 9], [10.0, 5, 15], [10.0, 5, 3], [2.5, 2, 5], [2.5, 2, 4], [2.5, 2, 6], [2.5, 2, 1], [7.0, 7, 7], [7.0, 7, 8], [7.0, 7, 15], [7.0, 7, 6]]"}}
{"requirement": "def people_with_age_drink(age: int) -> str:\n\"\"\"- Kids drink toddy.\n- Teens drink coke.\n- Young adults drink beer.\n- Adults drink whisky.\n\nMake a function that receive age, and return what they drink.\n\n**Rules:**\n\n- Children under 14 old.\n- Teens under 18 old.\n- Young under 21 old.\n- Adults have 21 or more.\n\n**Examples:**\n\n```python\npeople_with_age_drink(13) == \"drink toddy\"\npeople_with_age_drink(17) == \"drink coke\"\npeople_with_age_drink(18) == \"drink beer\"\npeople_with_age_drink(20) == \"drink beer\"\npeople_with_age_drink(30) == \"drink whisky\"\n```\n\"\"\"", "inputs": [[13], [0], [17], [15], [14], [20], [18], [22], [21]], "outputs": [["drink toddy"], ["drink toddy"], ["drink coke"], ["drink coke"], ["drink coke"], ["drink beer"], ["drink beer"], ["drink whisky"], ["drink whisky"]], "starter_code": "def people_with_age_drink(age: int) -> str:", "canonical_solution": "def people_with_age_drink(age):\n    if age > 20:\n        return 'drink whisky'\n    if age > 17:\n        return 'drink beer'\n    if age > 13:\n        return 'drink coke'\n    return 'drink toddy'", "entry_point": "people_with_age_drink", "task_id": "TACO_lite/210", "input_output_examples": "[[[13], [17], [18], [20], [30]], [['drink toddy'], ['drink coke'], ['drink beer'], ['drink beer'], ['drink whisky']]]", "llm_generated_inputs": {"deepseek-v3": "[[5], [13], [14], [17], [18], [20], [21], [30], [0], [100]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [13], [14], [15], [17], [18], [20], [21], [30], [99]]"}}
{"requirement": "def get_animals_count(legs: int, heads: int, horns: int) -> dict:\n\"\"\"Farmer Bob have a big farm, where he growths chickens, rabbits and cows. It is very difficult to count the number of animals for each type manually, so he diceded to buy a system to do it. But he bought a cheap system that can count only total number of heads, total number of legs and total number of horns of animals on the farm.\nHelp Bob to figure out how many chickens, rabbits and cows does he have?\n\nAll chickens have 2 legs, 1 head and no horns; all rabbits have 4 legs, 1 head and no horns; all cows have 4 legs, 1 head and 2 horns.\n\nYour task is to write a function \n```Python\nget_animals_count(legs_number, heads_number, horns_number)\n```\n```Csharp\nDictionary get_animals_count(int legs_number, int heads_number, int horns_number)\n```\n, which returns a dictionary \n```python\n{\"rabbits\" : rabbits_count, \"chickens\" : chickens_count, \"cows\" : cows_count}\n``` \n```Csharp\nnew Dictionary(){{\"rabbits\", rabbits_count},{\"chickens\", chickens_count},{\"cows\", cows_count}}\n```\n\nParameters `legs_number, heads_number, horns_number` are integer, all tests have valid input.\n\nExample:\n\n```python\nget_animals_count(34, 11, 6); # Should return {\"rabbits\" : 3, \"chickens\" : 5, \"cows\" : 3}\nget_animals_count(154, 42, 10); # Should return {\"rabbits\" : 30, \"chickens\" : 7, \"cows\" : 5}\n```\n\n```Csharp\nget_animals_count(34, 11, 6); //Should return  Dictionary(){{\"rabbits\", 3},{\"chickens\", 5},{\"cows\", 3}}\nget_animals_count(154, 42, 10); //Should return Dictionary(){{\"rabbits\", 30},{\"chickens\", 7},{\"cows\", 5}}\n```\n\"\"\"", "inputs": [[34, 11, 6], [154, 42, 10], [74, 20, 34], [152, 38, 34], [56, 17, 0]], "outputs": [[{"rabbits": 3, "chickens": 5, "cows": 3}], [{"rabbits": 30, "chickens": 7, "cows": 5}], [{"rabbits": 0, "chickens": 3, "cows": 17}], [{"rabbits": 21, "chickens": 0, "cows": 17}], [{"rabbits": 11, "chickens": 6, "cows": 0}]], "starter_code": "def get_animals_count(legs: int, heads: int, horns: int) -> dict:", "canonical_solution": "def get_animals_count(legs, heads, horns):\n    cows = horns // 2\n    rabbits = legs // 2 - cows - heads\n    chickens = heads - cows - rabbits\n    return dict(cows=cows, rabbits=rabbits, chickens=chickens)", "entry_point": "get_animals_count", "task_id": "TACO_lite/213", "input_output_examples": "[[[34, 11, 6], [154, 42, 10]], [[{'rabbits': 3, 'chickens': 5, 'cows': 3}], [{'rabbits': 30, 'chickens': 7, 'cows': 5}]]]", "llm_generated_inputs": {"deepseek-v3": "[[34, 11, 6], [154, 42, 10], [10, 5, 2], [6, 3, 0], [8, 4, 2], [12, 6, 4], [0, 0, 0], [2, 1, 0], [4, 1, 0], [4, 2, 0], [4, 1, 2], [6, 2, 2], [100, 50, 20], [200, 100, 40], [50, 25, 10], [70, 35, 14], [80, 40, 16], [90, 45, 18], [100, 50, 20], [110, 55, 22]]", "qwen2.5-coder-32b-instruct": "[[34, 11, 6], [154, 42, 10], [0, 0, 0], [2, 1, 0], [4, 1, 2], [8, 2, 0], [12, 3, 4], [100, 25, 10], [10, 3, 0], [16, 4, 4], [18, 5, 2], [20, 6, 0], [24, 6, 4], [30, 7, 0], [32, 8, 4], [36, 9, 0], [40, 10, 4], [44, 11, 0], [48, 12, 4], [52, 13, 0]]"}}
{"requirement": "from typing import List\n\n\ndef bubble(l: List[int]) -> List[List[int]]:\n\"\"\"#Bubbleing around\n\nSince everybody hates chaos and loves sorted lists we should implement some more sorting algorithms. Your task is to implement a Bubble sort (for some help look at https://en.wikipedia.org/wiki/Bubble_sort) and return a list of snapshots after **each change** of the initial list.\n\ne.g. \n\nIf the initial list would be l=[1,2,4,3] my algorithm rotates l[2] and l[3] and after that it adds [1,2,3,4] to the result, which is a list of snapshots.\n```\n[1,2,4,3] should return [ [1,2,3,4] ]\n[2,1,4,3] should return [ [1,2,4,3], [1,2,3,4] ]\n[1,2,3,4] should return []\n```\n\"\"\"", "inputs": [[[]], [[1, 2, 3, 4, 5, 6, 7, 8, 9]], [[1, 2, 3, 3, 4, 7]]], "outputs": [[[]], [[]], [[[1, 3, 3, 4, 7, 2], [1, 3, 3, 4, 2, 7], [1, 3, 3, 2, 4, 7], [1, 3, 2, 3, 4, 7], [1, 2, 3, 3, 4, 7]]]], "starter_code": "from typing import List\ndef bubble(l: List[int]) -> List[List[int]]:", "canonical_solution": "def bubble(l):\n    ret = []\n    for i in range(len(l) - 1, 0, -1):\n        for j in range(i):\n            if l[j] > l[j + 1]:\n                l[j], l[j + 1] = (l[j + 1], l[j])\n                ret.append(l[:])\n    return ret", "entry_point": "bubble", "task_id": "TACO_lite/215", "input_output_examples": "[[[[1, 2, 4, 3]], [[2, 1, 4, 3]], [[1, 2, 3, 4]]], [[[[1, 2, 3, 4]]], [[[1, 2, 4, 3], [1, 2, 3, 4]]], [[]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 4, 3]], [[2, 1, 4, 3]], [[1, 2, 3, 4]], [[4, 3, 2, 1]], [[1]], [[]], [[5, 1, 4, 2, 8]], [[3, 3, 3, 3]], [[9, 7, 5, 3, 1]], [[1, 3, 5, 7, 9]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 4, 3]], [[2, 1, 4, 3]], [[1, 2, 3, 4]], [[5, 4, 3, 2, 1]], [[1]], [[]], [[3, 3, 3, 3]], [[1, 3, 2]], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]]]"}}
{"requirement": "def next_num(n: int) -> int:\n\"\"\"Given a non-negative number, return the next bigger polydivisible number, or an empty value like `null` or `Nothing`.\n\nA number is polydivisible if its first digit is cleanly divisible by `1`, its first two digits by `2`, its first three by `3`, and so on. There are finitely many polydivisible numbers.\n\"\"\"", "inputs": [[0], [10], [11], [1234], [123220], [998], [999], [1234567890], [3608528850368400786036724], [3608528850368400786036725]], "outputs": [[1], [12], [12], [1236], [123252], [1020], [1020], [1236004020], [3608528850368400786036725], [null]], "starter_code": "def next_num(n: int) -> int:", "canonical_solution": "d, polydivisible, arr = (1, [], list(range(1, 10)))\nwhile arr:\n    d += 1\n    polydivisible.extend(arr)\n    arr = [n for x in arr for n in range(-(-x * 10 // d) * d, (x + 1) * 10, d)]\n\ndef next_num(n):\n    from bisect import bisect\n    idx = bisect(polydivisible, n)\n    if idx < len(polydivisible):\n        return polydivisible[idx]", "entry_point": "next_num", "task_id": "TACO_lite/216", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [10], [12], [123], [1232], [12320], [123200], [1232000], [12320000], [123200000], [1232000000]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [12], [123], [1234], [1232], [9999], [325], [324], [3027]]"}}
{"requirement": "def longer(s: str) -> str:\n\"\"\"Create a function `longer` that accepts a string and sorts the words in it based on their respective lengths in an ascending order. If there are two words of the same lengths, sort them alphabetically. Look at the examples below for more details.\n\n```python\nlonger(\"Another Green World\") => Green World Another\nlonger(\"Darkness on the edge of Town\") => of on the Town edge Darkness\nlonger(\"Have you ever Seen the Rain\") => the you Have Rain Seen ever\n```\n\nAssume that only only Alphabets will be entered as the input.\nUppercase characters have priority over lowercase characters. That is,\n```python\nlonger(\"hello Hello\") => Hello hello\n```\n\nDon't forget to rate this kata and leave your feedback!! \nThanks\n\"\"\"", "inputs": [["Another Green World"], ["Darkness on the edge of Town"], ["Have you ever Seen the Rain"], ["Like a Rolling Stone"], ["This will be our Year"], ["hello Hello"]], "outputs": [["Green World Another"], ["of on the Town edge Darkness"], ["the you Have Rain Seen ever"], ["a Like Stone Rolling"], ["be our This Year will"], ["Hello hello"]], "starter_code": "def longer(s: str) -> str:", "canonical_solution": "def longer(s):\n    return ' '.join(sorted(s.split(), key=lambda w: (len(w), w)))", "entry_point": "longer", "task_id": "TACO_lite/219", "input_output_examples": "[[['Another Green World'], ['Darkness on the edge of Town'], ['Have you ever Seen the Rain'], ['hello Hello']], [['Green World Another'], ['of on the Town edge Darkness'], ['the you Have Rain Seen ever'], ['Hello hello']]]", "llm_generated_inputs": {"deepseek-v3": "[['Another Green World'], ['Darkness on the edge of Town'], ['Have you ever Seen the Rain'], ['hello Hello'], ['a A bb BB ccc CCC'], ['The quick brown fox jumps over the lazy dog'], ['Python is fun'], ['Aa Bb Cc Dd Ee Ff Gg'], ['SingleWord'], ['']]", "qwen2.5-coder-32b-instruct": "[['Another Green World'], ['Darkness on the edge of Town'], ['Have you ever Seen the Rain'], ['hello Hello'], ['a A b B c C'], ['singleword'], ['same same same'], ['UPPER lower Middle'], ['short longer shortest longest'], ['equal equal equal equal']]"}}
{"requirement": "def debug(s: str) -> str:\n\"\"\"Take debugging to a whole new level:\n\nGiven a string, remove every *single* bug.\n\nThis means you must remove all instances of the word 'bug' from within a given string, *unless* the word is plural ('bugs').\n\n\n\nFor example, given 'obugobugobuoobugsoo', you should return 'ooobuoobugsoo'.\n\nAnother example: given 'obbugugo', you should return 'obugo'.\n\nNote that all characters will be lowercase.\n\nHappy squishing!\n\"\"\"", "inputs": [["obugobugobuoobugsoo"], ["obbugugo"], ["bugs bunny"], ["bugs buggy"], ["oaiwjefbugoijoijapsbugsdoibugbugjfoijasdfbugsbug"], ["bugbugbugiahweoifuhiaasnoidfhnbugbugs"], ["bugsbugswaoeifhiauwehfoiwubugshefjnviouah"], ["bugbugbugbug"], ["bugsbugsbugsbugs"], ["buggybugs"], ["oaisjdfowjefpoibugsjsofijeo oi bugs o bug f bug poaj sfd s"]], "outputs": [["ooobuoobugsoo"], ["obugo"], ["bugs bunny"], ["bugs gy"], ["oaiwjefoijoijapsbugsdoijfoijasdfbugs"], ["iahweoifuhiaasnoidfhnbugs"], ["bugsbugswaoeifhiauwehfoiwubugshefjnviouah"], [""], ["bugsbugsbugsbugs"], ["gybugs"], ["oaisjdfowjefpoibugsjsofijeo oi bugs o  f  poaj sfd s"]], "starter_code": "def debug(s: str) -> str:", "canonical_solution": "import re\n\ndef debug(s):\n    return re.sub('bug(?!s)', '', s)", "entry_point": "debug", "task_id": "TACO_lite/228", "input_output_examples": "[[['obugobugobuoobugsoo'], ['obbugugo']], [['ooobuoobugsoo'], ['obugo']]]", "llm_generated_inputs": {"deepseek-v3": "[['obugobugobuoobugsoo'], ['obbugugo'], ['bugbugbugbugs'], ['nobugshere'], ['bugbugbugbug'], ['bugsbugbugbugs'], ['bugbugsbugbugs'], ['bug'], ['bugs'], ['']]", "qwen2.5-coder-32b-instruct": "[['obugobugobuoobugsoo'], ['obbugugo'], ['bug'], ['bugs'], ['this is a bug'], ['this is a bugs'], ['bugsbugs'], ['no bugs here'], ['bugbugbug'], ['a'], ['']]"}}
{"requirement": "from typing import List\n\n\ndef odd_ones_out(numbers: List[int]) -> List[int]:\n\"\"\"The town sheriff dislikes odd numbers and wants all odd numbered families out of town! In town crowds can form and individuals are often mixed with other people and families. However you can distinguish the family they belong to by the number on the shirts they wear. As the sheriff's assistant it's your job to find all the odd numbered families and remove them from the town!\n~~~if-not:cpp\nChallenge: You are given a list of numbers. The numbers each repeat a certain number of times. Remove all numbers that repeat an odd number of times while keeping everything else the same.\n~~~\n~~~if:cpp\nChallenge: You are given a vector of numbers. The numbers each repeat a certain number of times. Remove all numbers that repeat an odd number of times while keeping everything else the same.\n~~~\n```python\nodd_ones_out([1, 2, 3, 1, 3, 3]) = [1, 1]\n```\nIn the above example:\n- the number 1 appears twice\n- the number 2 appears once\n- the number 3 appears three times\n\n`2` and `3` both appear an odd number of times, so they are removed from the list. The final result is: `[1,1]`\n\nHere are more examples:\n```python\nodd_ones_out([1, 1, 2, 2, 3, 3, 3]) = [1, 1, 2, 2]\nodd_ones_out([26, 23, 24, 17, 23, 24, 23, 26]) = [26, 24, 24, 26]\nodd_ones_out([1, 2, 3]) = []\nodd_ones_out([1]) = []\n```\n\nAre you up to the challenge?\n\"\"\"", "inputs": [[[1, 2, 3, 1, 3, 3]], [[75, 68, 75, 47, 68]], [[42, 72, 32, 4, 94, 82, 67, 67]], [[100, 100, 5, 5, 100, 50, 68, 50, 68, 50, 68, 5, 100]], [[82, 86, 71, 58, 44, 79, 50, 44, 79, 67, 82, 82, 55, 50]]], "outputs": [[[1, 1]], [[75, 68, 75, 68]], [[67, 67]], [[100, 100, 100, 100]], [[44, 79, 50, 44, 79, 50]]], "starter_code": "from typing import List\ndef odd_ones_out(numbers: List[int]) -> List[int]:", "canonical_solution": "def odd_ones_out(numbers):\n    return [i for i in numbers if numbers.count(i) % 2 == 0]", "entry_point": "odd_ones_out", "task_id": "TACO_lite/244", "input_output_examples": "[[[[1, 2, 3, 1, 3, 3]], [[1, 1, 2, 2, 3, 3, 3]], [[26, 23, 24, 17, 23, 24, 23, 26]], [[1, 2, 3]], [[1]]], [[[1, 1]], [[1, 1, 2, 2]], [[26, 24, 24, 26]], [[]], [[]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 1, 3, 3]], [[1, 1, 2, 2, 3, 3, 3]], [[26, 23, 24, 17, 23, 24, 23, 26]], [[1, 2, 3]], [[1]], [[]], [[10, 10, 20, 20, 20, 30, 30, 30, 30]], [[5, 5, 5, 5, 5, 5, 5, 5, 5]], [[7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 1, 3, 3]], [[1, 1, 2, 2, 3, 3, 3]], [[26, 23, 24, 17, 23, 24, 23, 26]], [[1, 2, 3]], [[1]], [[]], [[2, 2, 2, 2]], [[1, 1, 1, 1, 1, 1]], [[1, 1, 2, 3, 3, 4, 4, 5, 5, 5]], [[7, 7, 7, 8, 8, 9, 9, 9, 9]]]"}}
{"requirement": "def tax_calculator(total: float) -> float:\n\"\"\"Write a function to calculate compound tax using the following table:\n\nFor $10 and under, the tax rate should be 10%.\nFor $20 and under, the tax rate on the first $10 is %10, and the tax on the rest is 7%.\nFor $30 and under, the tax rate on the first $10 is still %10, the rate for the next $10 is still 7%, and everything else is 5%.\nTack on an additional 3% for the portion of the total above $30.\nReturn 0 for invalid input(anything that's not a positive real number).\n\n\nExamples:\n\nAn input of 10, should return 1 (1 is 10% of 10)\nAn input of 21, should return 1.75 (10% of 10 + 7% of 10 + 5% of 1)\n\n* Note that the returned value should be rounded to the nearest penny.\n\"\"\"", "inputs": [[1], [10], [11], [15], [18], [21], [26], [30], [30.49], [35], [100], [1000000], [0], [-3], [null], ["monkey"], [[]], [{}]], "outputs": [[0.1], [1], [1.07], [1.35], [1.56], [1.75], [2], [2.2], [2.21], [2.35], [4.3], [30001.3], [0], [0], [0], [0], [0], [0]], "starter_code": "def tax_calculator(total: float) -> float:", "canonical_solution": "def tax_calculator(total):\n    if not isinstance(total, (int, float)) or total < 0:\n        return 0\n    tax = 0\n    if total > 30:\n        tax = 2.2 + (total - 30) * 0.03\n    elif total > 20:\n        tax = 1.7 + (total - 20) * 0.05\n    elif total > 10:\n        tax = 1 + (total - 10) * 0.07\n    elif total > 0:\n        tax = total / 10.0\n    return round(tax, 2)", "entry_point": "tax_calculator", "task_id": "TACO_lite/245", "input_output_examples": "[[[10], [21]], [[1], [1.75]]]", "llm_generated_inputs": {"deepseek-v3": "[[10], [20], [30], [21], [15], [5], [0], [-5], [100], [10.55], [30.01], [9.99], [20.01], [50.5], [0.01], [None], ['invalid']]", "qwen2.5-coder-32b-instruct": "[[-5], [0], [None], ['ten'], [9.99], [10], [10.01], [19.99], [20], [20.01], [29.99], [30], [30.01], [40], [100]]"}}
{"requirement": "def get_note(pitch: float) -> str:\n\"\"\"In music, if you double (or halve) the pitch of any note you will get to the same note again.\n\n\"Concert A\" is fixed at 440 Hz, and every other note is defined based on that. 880 Hz is also an A, as is 1760 Hz, as is 220 Hz.\n\nThere are 12 notes in Western music: A, A#, B, C, C#, D, D#, E, F, F#, G, G#. You are given a preloaded dictionary with these 12 notes and one of the pitches that creates that note (starting at Concert A).\n\nNow, given a pitch (in Hz), return the corresponding note. (All inputs will be valid notes).\n\nFor reference, the notes dictionary looks like this:\n\n```python\nnotes_dictionary = {\n    440: \"A\",\n    466.16: \"A#\",\n    493.88: \"B\",\n    523.25: \"C\",\n    554.37: \"C#\", \n    587.33: \"D\", \n    622.25: \"D#\", \n    659.25: \"E\", \n    698.46: \"F\", \n    739.99: \"F#\", \n    783.99: \"G\", \n    830.61: \"G#\"\n}\n```\n\nMusicians: all pitches based on equal tempermanent, taken from [here](http://pages.mtu.edu/~suits/notefreqs.html).\n\n\n\"\"\"", "inputs": [[440], [220], [880], [523.25], [261.625], [1046.5]], "outputs": [["A"], ["A"], ["A"], ["C"], ["C"], ["C"]], "starter_code": "def get_note(pitch: float) -> str:", "canonical_solution": "notes = {440: 'A', 466.16: 'A#', 493.88: 'B', 523.25: 'C', 554.37: 'C#', 587.33: 'D', 622.25: 'D#', 659.25: 'E', 698.46: 'F', 739.99: 'F#', 783.99: 'G', 830.61: 'G#'}\n\ndef get_note(pitch):\n    for note in notes:\n        if note >= pitch and note % pitch == 0:\n            return notes[note]\n        elif note < pitch and pitch % note == 0:\n            return notes[note]", "entry_point": "get_note", "task_id": "TACO_lite/246", "input_output_examples": "[[[440], [880], [220], [466.16]], [['A'], ['A'], ['A'], ['A#']]]", "llm_generated_inputs": {"deepseek-v3": "[[440.0], [880.0], [220.0], [466.16], [493.88], [523.25], [554.37], [587.33], [622.25], [659.25], [698.46], [739.99], [783.99], [830.61], [1760.0], [110.0], [932.32]]", "qwen2.5-coder-32b-instruct": "[[440], [466.16], [493.88], [523.25], [554.37], [587.33], [622.25], [659.25], [698.46], [739.99], [783.99], [830.61], [880], [1760], [220], [243.05], [261.63], [277.18], [293.66], [311.13], [329.63], [349.23], [369.99], [392], [415.3], [220.5], [233.08], [246.94], [261.63], [277.18], [293.66], [311.13], [329.63], [349.23], [369.99], [392], [415.3]]"}}
{"requirement": "def reverse_fun(n: str) -> str:\n\"\"\"You are going to be given a string. Your job is to return that string in a certain order that I will explain below:\n\nLet's say you start with this: `012345`\n\nThe first thing you do is reverse it:`543210`  \nThen you will take the string from the 1st position and reverse it again:`501234`  \nThen you will take the string from the 2nd position and reverse it again:`504321`  \nThen you will take the string from the 3rd position and reverse it again:`504123`\n\n\n\nContinue this pattern until you have done every single position, and then you will return the string you have created. For this particular number, you would return:`504132`\n\n#Input:\nA string of length 1 - 1000\n\n#Output:\nA correctly reordered string.\n\"\"\"", "inputs": [["012"], ["012345"], ["0123456789"], ["Hello"]], "outputs": [["201"], ["504132"], ["9081726354"], ["oHlel"]], "starter_code": "def reverse_fun(n: str) -> str:", "canonical_solution": "def reverse_fun(n):\n    for i in range(len(n)):\n        n = n[:i] + n[i:][::-1]\n    return n", "entry_point": "reverse_fun", "task_id": "TACO_lite/247", "input_output_examples": "[[['012345']], [['504132']]]", "llm_generated_inputs": {"deepseek-v3": "[['012345'], ['a'], ['ab'], ['abc'], ['abcd'], ['123456789'], ['!@#$%^&*()'], ['This is a test string'], ['1234567890'], ['A man a plan a canal Panama']]", "qwen2.5-coder-32b-instruct": "[['0'], ['01'], ['012'], ['0123'], ['01234'], ['012345'], ['abcdef'], ['aabbccddeeff'], ['zyxwvutsrqponmlkjihgfedcba'], ['1234567890'], ['0000000000'], ['1111111111'], ['123456789012345678901234567890'], ['abcdefghijklmnopqrstuvwxyz'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZ'], ['!@#$%^&*()'], ['1234567890qwertyuiopasdfghjklzxcvbnm']]"}}
{"requirement": "def spam(number: int) -> str:\n\"\"\"Here we have a function that help us spam our hearty laughter. But is not working! I need you to find out why...\n\nExpected results:\n\n```python\nspam(1)  ==> \"hue\"\nspam(6)  ==> \"huehuehuehuehuehue\"\nspam(14) ==> \"huehuehuehuehuehuehuehuehuehuehuehuehuehue\"\n```\n\"\"\"", "inputs": [[1], [6], [14]], "outputs": [["hue"], ["huehuehuehuehuehue"], ["huehuehuehuehuehuehuehuehuehuehuehuehuehue"]], "starter_code": "def spam(number: int) -> str:", "canonical_solution": "def spam(number):\n    return 'hue' * number", "entry_point": "spam", "task_id": "TACO_lite/251", "input_output_examples": "[[[1], [6], [14]], [['hue'], ['huehuehuehuehuehue'], ['huehuehuehuehuehuehuehuehuehuehuehuehuehue']]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [6], [14], [0], [-1], [100]]", "qwen2.5-coder-32b-instruct": "[[1], [6], [14], [0], [-1], [100]]"}}
{"requirement": "from typing import List\n\n\ndef digitize(n: int) -> List[int]:\n\"\"\"# Convert number to reversed array of digits\n\nGiven a random non-negative number, you have to return the digits of this number within an array in reverse order.\n\n## Example:\n\n```\n348597 => [7,9,5,8,4,3]\n```\n\"\"\"", "inputs": [[35231], [23582357], [984764738], [45762893920], [548702838394]], "outputs": [[[1, 3, 2, 5, 3]], [[7, 5, 3, 2, 8, 5, 3, 2]], [[8, 3, 7, 4, 6, 7, 4, 8, 9]], [[0, 2, 9, 3, 9, 8, 2, 6, 7, 5, 4]], [[4, 9, 3, 8, 3, 8, 2, 0, 7, 8, 4, 5]]], "starter_code": "from typing import List\ndef digitize(n: int) -> List[int]:", "canonical_solution": "def digitize(n):\n    return [int(x) for x in str(n)[::-1]]", "entry_point": "digitize", "task_id": "TACO_lite/252", "input_output_examples": "[[[348597]], [[[7, 9, 5, 8, 4, 3]]]]", "llm_generated_inputs": {"deepseek-v3": "[[348597], [0], [123456789], [1000000000], [987654321], [10], [999999999], [1], [123], [1020304050]]", "qwen2.5-coder-32b-instruct": "[[348597], [0], [123456789], [111111], [9876543210]]"}}
{"requirement": "def is_prime(p: int) -> bool:\n\"\"\"Define a function that takes one integer argument and returns logical value `true` or `false` depending on if the integer is a prime.\n\nPer Wikipedia, a prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n\n## Requirements\n\n* You can assume you will be given an integer input.\n* You can not assume that the integer will be only positive. You may be given negative numbers as well (or `0`).\n* **NOTE on performance**: There are no fancy optimizations required, but still *the* most trivial solutions might time out. Numbers go up to 2^31 (or similar, depends on language version). Looping all the way up to `n`, or `n/2`, will be too slow.\n\n## Example\n```nasm    \nmov edi, 1\ncall is_prime    ; EAX <- 0 (false)\n\nmov edi, 2\ncall is_prime    ; EAX <- 1 (true)\n\nmov edi, -1\ncall is_prime    ; EAX <- 0 (false)\n```\n\"\"\"", "inputs": [[0], [1], [2], [73], [75], [-1]], "outputs": [[false], [false], [true], [true], [false], [false]], "starter_code": "def is_prime(p: int) -> bool:", "canonical_solution": "import random\n\ndef even_odd(n):\n    s, d = (0, n)\n    while d % 2 == 0:\n        s += 1\n        d >>= 1\n    return (s, d)\n\ndef Miller_Rabin(a, p):\n    s, d = even_odd(p - 1)\n    a = pow(a, d, p)\n    if a == 1:\n        return True\n    for i in range(s):\n        if a == p - 1:\n            return True\n        a = pow(a, 2, p)\n    return False\n\ndef is_prime(p):\n    if p == 2:\n        return True\n    if p <= 1 or p % 2 == 0:\n        return False\n    return all((Miller_Rabin(random.randint(2, p - 1), p) for _ in range(40)))", "entry_point": "is_prime", "task_id": "TACO_lite/256", "input_output_examples": "[[[1], [2], [-1]], [[False], [True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[2], [3], [5], [7], [11], [13], [1], [0], [-1], [-2], [4], [6], [9], [15], [997], [1000000007]]", "qwen2.5-coder-32b-instruct": "[[-1], [0], [1], [2], [3], [4], [5], [16], [17], [18], [19], [20], [23], [24], [29], [97], [100], [101], [104729], [104730], [2147483647]]"}}
{"requirement": "def amort(rate: float, bal: int, term: int, num_payments: int) -> str:\n\"\"\"The description is rather long but it tries to explain what a financing plan is. \n\nThe fixed monthly payment for a fixed rate mortgage is the amount paid by the borrower every month that ensures \nthat the loan is paid off in full with interest at the end of its term. \n\nThe monthly payment formula is based on the annuity formula. \nThe monthly payment `c` depends upon:\n\n- `rate` - the monthly interest rate is expressed as a decimal, not a percentage. \nThe monthly rate is simply the **given** yearly percentage rate divided by 100 and then by 12.\n\n- `term` - the number of monthly payments, called the loan's `term`.\n- `principal` - the amount borrowed, known as the loan's principal (or `balance`).\n\nFirst we have to determine `c`.\n\nWe have: `c = n /d` with `n = r * balance` and `d = 1 - (1 + r)**(-term)` where `**` is the `power` function (you can look at the reference below).\n\nThe payment `c` is composed of two parts. The first part pays the interest (let us call it `int`)\ndue for the balance of the given month, the second part repays the balance (let us call this part `princ`) hence for the following month we get a `new balance = old balance - princ` with `c = int + princ`. \n\nLoans are structured so that the amount of principal returned to the borrower starts out small and increases with each mortgage payment. \nWhile the mortgage payments in the first years consist primarily of interest payments, the payments in the final years consist primarily of principal repayment.\n\nA mortgage's amortization schedule provides a detailed look at precisely what portion of each mortgage payment is dedicated to each component.\n\nIn an example of a $100,000, 30-year mortgage with a rate of 6 percents the amortization schedule consists of 360 monthly payments.\nThe partial amortization schedule below shows with 2 decimal floats\nthe balance between principal and interest payments.\n\n--|num_payment|c          |princ      |int        |Balance    |\n--|-----------|-----------|-----------|-----------|-----------|\n--|1          |599.55     |99.55      |500.00     |99900.45   |\n--|...        |599.55     |...        |...        |...        |\n--|12         |599.55     |105.16     |494.39     |98,771.99  |\n--|...        |599.55     |...        |...        |...        |\n--|360        |599.55     |596.57     |2.98       |0.00       |\n\n# Task:\nGiven parameters \n```\nrate: annual rate as percent (don't forgent to divide by 100*12)\nbal: original balance (borrowed amount) \nterm: number of monthly payments\nnum_payment: rank of considered month (from 1 to term)\n\n\n```\nthe function `amort` will return a formatted string:\n\n`\"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\" (with arguments num_payment, c, princ, int, balance`)\n\n# Examples:\n```\namort(6, 100000, 360, 1) ->\n\"num_payment 1 c 600 princ 100 int 500 balance 99900\"\n\namort(6, 100000, 360, 12) ->\n\"num_payment 12 c 600 princ 105 int 494 balance 98772\"\n\n```\n# Ref\n\"\"\"", "inputs": [[7.4, 10215, 24, 20], [7.9, 107090, 48, 41], [6.8, 105097, 36, 4], [3.8, 48603, 24, 10], [1.9, 182840, 48, 18], [1.9, 19121, 48, 2], [2.2, 112630, 60, 11], [5.6, 133555, 60, 53], [9.8, 67932, 60, 34], [3.7, 64760, 36, 24], [4.6, 85591, 36, 5], [7.0, 168742, 48, 16], [9.6, 17897, 60, 23], [5.2, 53521, 60, 51], [6.8, 139308, 60, 38], [5.0, 182075, 24, 9], [8.0, 128263, 36, 26], [7.8, 112414, 60, 37], [4.9, 93221, 36, 5], [1.2, 146157, 48, 20], [3.6, 168849, 24, 11], [9.3, 87820, 60, 14], [8.7, 155744, 36, 31], [6.4, 179023, 36, 11], [8.3, 38495, 36, 15], [9.6, 150614, 24, 19], [2.5, 159363, 48, 19], [4.7, 56245, 48, 11], [1.5, 142777, 36, 32], [9.6, 187340, 60, 28], [2.4, 57707, 24, 14], [3.0, 180678, 36, 31], [2.0, 139586, 24, 13], [5.3, 142498, 60, 46], [9.0, 150309, 48, 29], [7.1, 60232, 60, 56], [8.7, 172214, 36, 14], [9.0, 187174, 60, 12], [9.5, 119722, 60, 23], [9.2, 10536, 36, 15], [1.9, 70139, 24, 13], [4.5, 141454, 36, 23], [4.5, 154486, 24, 7], [2.2, 20254, 36, 35], [3.7, 114512, 36, 23], [8.6, 121685, 48, 24], [1.1, 171542, 48, 25], [1.1, 121991, 48, 20], [8.9, 162862, 60, 46], [1.9, 152921, 60, 19]], "outputs": [["num_payment 20 c 459 princ 445 int 14 balance 1809"], ["num_payment 41 c 2609 princ 2476 int 133 balance 17794"], ["num_payment 4 c 3235 princ 2685 int 550 balance 94447"], ["num_payment 10 c 2106 princ 2009 int 98 balance 28799"], ["num_payment 18 c 3959 princ 3769 int 189 balance 115897"], ["num_payment 2 c 414 princ 384 int 30 balance 18353"], ["num_payment 11 c 1984 princ 1810 int 174 balance 92897"], ["num_payment 53 c 2557 princ 2464 int 93 balance 17571"], ["num_payment 34 c 1437 princ 1153 int 283 balance 33532"], ["num_payment 24 c 1903 princ 1829 int 75 balance 22389"], ["num_payment 5 c 2550 princ 2256 int 294 balance 74397"], ["num_payment 16 c 4041 princ 3335 int 706 balance 117641"], ["num_payment 23 c 377 princ 278 int 98 balance 12025"], ["num_payment 51 c 1015 princ 972 int 43 balance 8939"], ["num_payment 38 c 2745 princ 2411 int 335 balance 56634"], ["num_payment 9 c 7988 princ 7474 int 514 balance 115917"], ["num_payment 26 c 4019 princ 3736 int 283 balance 38758"], ["num_payment 37 c 2269 princ 1942 int 327 balance 48320"], ["num_payment 5 c 2790 princ 2449 int 341 balance 81077"], ["num_payment 20 c 3120 princ 3031 int 89 balance 86109"], ["num_payment 11 c 7302 princ 7002 int 300 balance 92965"], ["num_payment 14 c 1836 princ 1277 int 559 balance 70807"], ["num_payment 31 c 4931 princ 4722 int 209 balance 24127"], ["num_payment 11 c 5479 princ 4771 int 708 balance 127911"], ["num_payment 15 c 1212 princ 1041 int 170 balance 23607"], ["num_payment 19 c 6922 princ 6599 int 323 balance 33796"], ["num_payment 19 c 3492 princ 3281 int 211 balance 98178"], ["num_payment 11 c 1288 princ 1110 int 178 balance 44271"], ["num_payment 32 c 4058 princ 4033 int 25 balance 16183"], ["num_payment 28 c 3944 princ 3032 int 912 balance 110949"], ["num_payment 14 c 2465 princ 2411 int 54 balance 24381"], ["num_payment 31 c 5254 princ 5176 int 78 balance 26076"], ["num_payment 13 c 5938 princ 5821 int 117 balance 64670"], ["num_payment 46 c 2709 princ 2535 int 173 balance 36695"], ["num_payment 29 c 3740 princ 3221 int 519 balance 66007"], ["num_payment 56 c 1196 princ 1161 int 35 balance 4712"], ["num_payment 14 c 5452 princ 4618 int 835 balance 110505"], ["num_payment 12 c 3885 princ 2694 int 1191 balance 156135"], ["num_payment 23 c 2514 princ 1863 int 651 balance 80372"], ["num_payment 15 c 336 princ 284 int 52 balance 6495"], ["num_payment 13 c 2981 princ 2925 int 56 balance 32478"], ["num_payment 23 c 4208 princ 3993 int 215 balance 53292"], ["num_payment 7 c 6743 princ 6304 int 439 balance 110852"], ["num_payment 35 c 582 princ 580 int 2 balance 581"], ["num_payment 23 c 3366 princ 3224 int 142 balance 42823"], ["num_payment 24 c 3005 princ 2514 int 491 balance 66044"], ["num_payment 25 c 3655 princ 3575 int 79 balance 83139"], ["num_payment 20 c 2599 princ 2531 int 68 balance 71813"], ["num_payment 46 c 3373 princ 3019 int 354 balance 44694"], ["num_payment 19 c 2674 princ 2502 int 172 balance 106057"]], "starter_code": "def amort(rate: float, bal: int, term: int, num_payments: int) -> str:", "canonical_solution": "def amort(rate, bal, term, num_payments):\n    monthlyRate = rate / (12 * 100)\n    c = bal * (monthlyRate * (1 + monthlyRate) ** term) / ((1 + monthlyRate) ** term - 1)\n    newBalance = bal\n    for i in range(num_payments):\n        interest = newBalance * monthlyRate\n        princ = c - interest\n        newBalance = newBalance - princ\n    return 'num_payment %s c %.0f princ %.0f int %.0f balance %.0f' % (num_payments, c, princ, interest, newBalance)", "entry_point": "amort", "task_id": "TACO_lite/262", "input_output_examples": "[[[6, 100000, 360, 1], [6, 100000, 360, 12]], [['num_payment 1 c 600 princ 100 int 500 balance 99900'], ['num_payment 12 c 600 princ 105 int 494 balance 98772']]]", "llm_generated_inputs": {"deepseek-v3": "[[6, 100000, 360, 1], [6, 100000, 360, 12], [6, 100000, 360, 360], [0.5, 50000, 120, 60], [15, 200000, 240, 120], [0.1, 1000, 12, 6], [10, 0, 60, 30], [3.5, 150000, 180, 1], [3.5, 150000, 180, 180], [3.5, 150000, 180, 90]]", "qwen2.5-coder-32b-instruct": "[[6, 100000, 360, 1], [6, 100000, 360, 12], [6, 100000, 360, 360], [0, 100000, 360, 1], [12, 100000, 360, 1], [6, 0, 360, 1], [6, 100000, 0, 1], [6, 100000, 360, 0], [6, 100000, 360, 361], [6, 100000, 12, 1], [6, 100000, 12, 12]]"}}
{"requirement": "from typing import List\n\n\ndef cog_rpm(cogs: List[int], n: int) -> List[float]:\n\"\"\"# Kata Task\n\nYou are given a list of cogs in a gear train\n\nEach element represents the number of teeth of that cog\n\ne.g. `[100, 50, 25]` means \n* 1st cog has 100 teeth \n* 2nd cog has 50 teeth\n* 3rd cog has 25 teeth\n\nIf the ``nth`` cog rotates clockwise at 1 RPM what is the RPM of the cogs at each end of the gear train? \n\n**Notes**\n* no two cogs share the same shaft\n* return an array whose two elements are RPM of the first and last cogs respectively\n* use negative numbers for anti-clockwise rotation\n* for convenience `n` is zero-based\n* For C and NASM coders, the returned array will be `free`'d.\n\n---\n\nSeries:\n* Cogs\n* Cogs 2\n\"\"\"", "inputs": [[[100], 0], [[100, 100, 100, 100], 0], [[100, 100, 100, 100], 1], [[100, 100, 100, 100], 2], [[100, 100, 100, 100], 3]], "outputs": [[[1, 1]], [[1, -1]], [[-1, 1]], [[1, -1]], [[-1, 1]]], "starter_code": "from typing import List\ndef cog_rpm(cogs: List[int], n: int) -> List[float]:", "canonical_solution": "def cog_rpm(cogs, n):\n    return [cogs[n] / cogs[0] * (-1 if n % 2 else 1), cogs[n] / cogs[-1] * (1 if (len(cogs) - n) % 2 else -1)]", "entry_point": "cog_rpm", "task_id": "TACO_lite/264", "input_output_examples": "[[[[100, 50, 25], 1], [[60, 30, 15, 5], 2]], [[[0.5, -2.0]], [[0.25, -6.0]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[100, 50, 25], 0], [[100, 50, 25], 1], [[100, 50, 25], 2], [[100, 100, 100], 0], [[100, 100, 100], 1], [[100, 100, 100], 2], [[50, 100, 50], 0], [[50, 100, 50], 1], [[50, 100, 50], 2], [[100], 0], [[100, 50], 0], [[100, 50], 1], [[100, 50, 25, 10], 0], [[100, 50, 25, 10], 2], [[100, 50, 25, 10], 3]]", "qwen2.5-coder-32b-instruct": "[[[100, 50, 25], 1], [[50, 50, 50, 50], 0], [[120, 60, 30, 15], 3], [[10, 20, 30, 40, 50], 2], [[100, 100, 100, 100, 100], 4], [[1, 2, 3, 4, 5], 0], [[5, 4, 3, 2, 1], 4], [[100], 0], [[100, 50], 0], [[50, 100], 1]]"}}
{"requirement": "from typing import List\n\n\ndef find_all(array: List[int], n: int) -> List[int]:\n\"\"\"Given an array (a list in Python) of integers and an integer `n`, find all occurrences of `n` in the given array and return another array containing all the index positions of `n` in the given array.\n\nIf `n` is not in the given array, return an empty array `[]`.\n\nAssume that `n` and all values in the given array will always be integers.\n\nExample:\n```python\nfind_all([6, 9, 3, 4, 3, 82, 11], 3)\n> [2, 4]\n```\n\"\"\"", "inputs": [[[6, 9, 3, 4, 3, 82, 11], 3], [[6, 9, 3, 4, 3, 82, 11], 99], [[10, 16, 20, 6, 14, 11, 20, 2, 17, 16, 14], 16], [[20, 20, 10, 13, 15, 2, 7, 2, 20, 3, 18, 2, 3, 2, 16, 10, 9, 9, 7, 5, 15, 5], 20]], "outputs": [[[2, 4]], [[]], [[1, 9]], [[0, 1, 8]]], "starter_code": "from typing import List\ndef find_all(array: List[int], n: int) -> List[int]:", "canonical_solution": "def find_all(array, n):\n    return [index for index, item in enumerate(array) if item == n]", "entry_point": "find_all", "task_id": "TACO_lite/268", "input_output_examples": "[[[[6, 9, 3, 4, 3, 82, 11], 3]], [[[2, 4]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 3, 5], 3], [[6, 9, 3, 4, 3, 82, 11], 3], [[10, 20, 30, 40], 50], [[], 5], [[1, 1, 1, 1], 1], [[5, 5, 5, 5], 5], [[0, 0, 0, 0], 0], [[7, 8, 9, 7, 8, 9], 7], [[1, 2, 3, 4, 5], 1], [[1, 2, 3, 4, 5], 5]]", "qwen2.5-coder-32b-instruct": "[[[6, 9, 3, 4, 3, 82, 11], 3], [[1, 2, 3, 4, 5], 6], [[5, 5, 5, 5, 5], 5], [[], 1], [[10, 20, 30, 40, 50], 10], [[100, 200, 300, 400, 500], 500], [[1, 1, 2, 2, 3, 3], 2], [[7, 8, 9], 7], [[7, 8, 9], 9]]"}}
{"requirement": "def ldta(n: int) -> int:\n\"\"\"Looking at consecutive powers of `2`, starting with `2^1`:\n\n`2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, ...`\n\nNote that out of all the digits `0-9`, the last one ever to appear is `7`. It only shows up for the first time in the number `32768 (= 2^15)`.\n\nSo let us define LAST DIGIT TO APPEAR as the last digit to be written down when writing down all the powers of `n`, starting with `n^1`.\n\n\n## Your task\n\nYou'll be given a positive integer ```1 =< n <= 10000```, and must return the last digit to appear, as an integer.\n\nIf for any reason there are digits which never appear in the sequence of powers, return `None`/`nil`.\n\nPlease note: The Last digit to appear can be in the same number as the penultimate one. For example for `n = 8`, the last digit to appear is `7`, although `3` appears slightly before it, in the same number:\n`8, 64, 512, 4096, 32768, ...`\n\"\"\"", "inputs": [[100], [2], [3], [8], [1111], [3000]], "outputs": [[null], [7], [0], [7], [9], [5]], "starter_code": "def ldta(n: int) -> int:", "canonical_solution": "digits = lambda x: set(str(x))\n\ndef ldta(n):\n    if digits(n) == digits(n * n):\n        return None\n    seen = []\n    x = n\n    while len(seen) < 10:\n        for d in str(x):\n            if d not in seen:\n                seen.append(d)\n        x *= n\n    return int(seen[-1])", "entry_point": "ldta", "task_id": "TACO_lite/271", "input_output_examples": "[[[8]], [[7]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [8], [10], [16], [100], [1000], [10000]]", "qwen2.5-coder-32b-instruct": "[[2], [8], [10], [5], [9], [7], [3], [1], [100], [10000], [625], [4]]"}}
{"requirement": "from typing import List\n\n\ndef bar_triang(a: List[float], b: List[float], c: List[float]) -> List[float]:\n\"\"\"The medians of a triangle are the segments that unit the vertices with the midpoint of their opposite sides.\nThe three medians of a triangle intersect at the same point, called the barycenter or the centroid.\nGiven a triangle, defined by the cartesian coordinates of its vertices we need to localize its barycenter or centroid.\n\nThe function ```bar_triang() or barTriang or bar-triang```, receives the coordinates of the three vertices ```A, B and C ``` as three different arguments and outputs the coordinates of the barycenter ```O``` in an array ```[xO, yO]```\n\nThis is how our asked function should work:\nthe result of the coordinates should be expressed up to four decimals, (rounded result).\n\nYou know that the coordinates of the barycenter are given by the following formulas.\n\n\n\nFor additional information about this important point of a triangle see at: (https://en.wikipedia.org/wiki/Centroid)\n\nLet's see some cases:\n```python\nbar_triang([4, 6], [12, 4], [10, 10]) ------> [8.6667, 6.6667]\n\nbar_triang([4, 2], [12, 2], [6, 10] ------> [7.3333, 4.6667]\n```\nThe given points form a real or a degenerate triangle but in each case the above formulas can be used.\n\nEnjoy it and happy coding!!\n\"\"\"", "inputs": [[[4, 6], [12, 4], [10, 10]], [[4, 2], [12, 2], [6, 10]], [[4, 8], [8, 2], [16, 6]]], "outputs": [[[8.6667, 6.6667]], [[7.3333, 4.6667]], [[9.3333, 5.3333]]], "starter_code": "from typing import List\ndef bar_triang(a: List[float], b: List[float], c: List[float]) -> List[float]:", "canonical_solution": "def bar_triang(a, b, c):\n    return [round(sum(x) / 3.0, 4) for x in zip(a, b, c)]", "entry_point": "bar_triang", "task_id": "TACO_lite/274", "input_output_examples": "[[[[4, 6], [12, 4], [10, 10]], [[4, 2], [12, 2], [6, 10]]], [[[8.6667, 6.6667]], [[7.3333, 4.6667]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[4, 6], [12, 4], [10, 10]], [[4, 2], [12, 2], [6, 10]], [[0, 0], [0, 0], [0, 0]], [[1, 1], [2, 2], [3, 3]], [[-1, -1], [1, 1], [0, 0]], [[1.5, 2.5], [3.5, 4.5], [5.5, 6.5]], [[0, 0], [1, 0], [0.5, 0.866]], [[1, 1], [1, 1], [1, 1]], [[-1.5, -2.5], [-3.5, -4.5], [-5.5, -6.5]], [[0, 0], [0, 10], [10, 0]]]", "qwen2.5-coder-32b-instruct": "[[[4, 6], [12, 4], [10, 10]], [[4, 2], [12, 2], [6, 10]], [[0, 0], [1, 0], [0, 1]], [[0, 0], [0, 0], [0, 0]], [[1, 1], [1, 1], [1, 1]], [[100, 100], [200, 200], [300, 300]], [[-1, -1], [-2, -2], [-3, -3]], [[1.5, 2.5], [3.5, 4.5], [5.5, 6.5]], [[0, 0], [10, 0], [0, 10]], [[10, 0], [0, 10], [5, 5]]]"}}
{"requirement": "def is_palindrome(string: str) -> bool:\n\"\"\"# Palindrome strings\n\nA palindrome is a word, phrase, number, or other sequence of characters which reads the same backward or forward. This includes capital letters, punctuation, and word dividers.\n\nImplement a function that checks if something is a palindrome.\n\n## Examples\n```\nisPalindrome(\"anna\")   ==> true\nisPalindrome(\"walter\") ==> false\nisPalindrome(12321)    ==> true\nisPalindrome(123456)   ==> false\n```\n\"\"\"", "inputs": [["anna"], ["walter"], [12321], [123456]], "outputs": [[true], [false], [true], [false]], "starter_code": "def is_palindrome(string: str) -> bool:", "canonical_solution": "def is_palindrome(string):\n    return str(string)[::-1] == str(string)", "entry_point": "is_palindrome", "task_id": "TACO_lite/282", "input_output_examples": "[[['anna'], ['walter'], [12321], [123456]], [[True], [False], [True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[['anna'], ['walter'], [12321], [123456], ['A man, a plan, a canal, Panama'], ['racecar'], ['12321'], ['123456'], [''], ['a'], ['abba'], ['abcdcba'], ['No lemon, no melon'], ['Was it a car or a cat I saw?'], ['1234321'], ['12344321'], ['123454321'], ['12345654321']]", "qwen2.5-coder-32b-instruct": "[['anna'], ['walter'], ['12321'], ['123456'], ['A man, a plan, a canal, Panama'], ['No lemon, no melon'], ['Was it a car or a cat I saw?'], [''], ['a'], ['1221'], ['123321'], ['Not a palindrome'], ['Madam'], ['racecar'], ['1234321'], ['!@#$%^&*()'], ['!@#$%^&*()^&*($#@!']]"}}
{"requirement": "from typing import List\n\n\ndef bubblesort_once(l: List[int]) -> List[int]:\n\"\"\"# Bubblesort Algorithm\n\n## Overview\n\nThe Bubblesort Algorithm is one of many algorithms used to sort a list of similar items (e.g. all numbers or all letters) into either ascending order or descending order.  Given a list (e.g.):\n\n```python\n[9, 7, 5, 3, 1, 2, 4, 6, 8]\n```\n\nTo sort this list in ascending order using Bubblesort, you first have to compare the first two terms of the list.  If the first term is larger than the second term, you perform a swap.  The list then becomes:\n\n```python\n[7, 9, 5, 3, 1, 2, 4, 6, 8] # The \"9\" and \"7\" have been swapped because 9 is larger than 7 and thus 9 should be after 7\n```\n\nYou then proceed by comparing the 2nd and 3rd terms, performing a swap *when necessary*, and then the 3rd and 4th term, then the 4th and 5th term, etc. etc.  When you reach the end of the list, it is said that you have completed **1 complete pass**.\n\n## Task\n\nGiven an array of integers, your function `bubblesortOnce`/`bubblesort_once`/`BubblesortOnce` (or equivalent, depending on your language's naming conventions) should return a *new* array equivalent to performing exactly **1 complete pass** on the original array.  Your function should be pure, i.e. it should **not** mutate the input array.\n\"\"\"", "inputs": [[[9, 7, 5, 3, 1, 2, 4, 6, 8]], [[1, 2]], [[2, 1]], [[1, 3]], [[3, 1]], [[24, 57]], [[89, 36]], [[1, 2, 3]], [[2, 4, 1]], [[17, 5, 11]], [[25, 16, 9]], [[103, 87, 113]], [[1032, 3192, 2864]], [[1, 2, 3, 4]], [[2, 3, 4, 1]], [[3, 4, 1, 2]], [[4, 1, 2, 3]], [[7, 5, 3, 1]], [[5, 3, 7, 7]], [[3, 1, 8, 5]], [[1, 9, 5, 5]], [[6, 3, 4, 9, 1, 2, 7, 8, 5]], [[6, 3, 4, 15, 14, 9, 1, 2, 7, 8, 5, 14, 11, 15, 17, 19]], [[42]], [[]]], "outputs": [[[7, 5, 3, 1, 2, 4, 6, 8, 9]], [[1, 2]], [[1, 2]], [[1, 3]], [[1, 3]], [[24, 57]], [[36, 89]], [[1, 2, 3]], [[2, 1, 4]], [[5, 11, 17]], [[16, 9, 25]], [[87, 103, 113]], [[1032, 2864, 3192]], [[1, 2, 3, 4]], [[2, 3, 1, 4]], [[3, 1, 2, 4]], [[1, 2, 3, 4]], [[5, 3, 1, 7]], [[3, 5, 7, 7]], [[1, 3, 5, 8]], [[1, 5, 5, 9]], [[3, 4, 6, 1, 2, 7, 8, 5, 9]], [[3, 4, 6, 14, 9, 1, 2, 7, 8, 5, 14, 11, 15, 15, 17, 19]], [[42]], [[]]], "starter_code": "from typing import List\ndef bubblesort_once(l: List[int]) -> List[int]:", "canonical_solution": "def bubblesort_once(l):\n    l = l[:]\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]:\n            l[i], l[i + 1] = (l[i + 1], l[i])\n    return l", "entry_point": "bubblesort_once", "task_id": "TACO_lite/283", "input_output_examples": "[[[[9, 7, 5, 3, 1, 2, 4, 6, 8]]], [[[7, 9, 5, 3, 1, 2, 4, 6, 8]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[9, 7, 5, 3, 1, 2, 4, 6, 8]], [[1, 2, 3, 4, 5]], [[5, 4, 3, 2, 1]], [[1]], [[]], [[3, 1, 4, 1, 5, 9, 2, 6, 5]], [[10, -1, 3, -5, 8]], [[0, 0, 0, 0]], [[2, 2, 1, 1, 3, 3]]]", "qwen2.5-coder-32b-instruct": "[[[9, 7, 5, 3, 1, 2, 4, 6, 8]], [[1, 2, 3, 4, 5, 6, 7, 8, 9]], [[9, 8, 7, 6, 5, 4, 3, 2, 1]], [[5]], [[]], [[3, 3, 2, 2, 1, 1]], [[1, 3, 2]], [[10, -1, 7, 8]]]"}}
{"requirement": "def direction_in_grid(n: int, m: int) -> str:\n\"\"\"# Task\n You're standing at the top left corner of an `n × m` grid and facing towards the `right`. \n \n Then you start walking one square at a time in the direction you are facing. \n \n If you reach the border of the grid or if the next square you are about to visit has already been visited, you turn right. \n \n You stop when all the squares in the grid are visited. What direction will you be facing when you stop?\n\n You can see the example of your long walk in the image below. The numbers denote the order in which you visit the cells.\n\n ![](https://i.gyazo.com/2fc5884d2c227a0ddeca503e6a0261be.png)\n\n Given two integers n and m, denoting the number of rows and columns respectively, find out the direction you will be facing at the end. \n \n Output `\"L\"` for left, `\"R\"` for right, `\"U\"` for up, and `\"D\"` for down.\n\n# Example:\n\n For `n = 3, m = 3`, the output should be `\"R\"`.\n\n This example refers to the picture given in the description. At the end of your walk you will be standing in the middle of the grid facing right.\n\n# Input/Output\n\n\n - `[input]` integer `n`\n \n number of rows.\n\n `1 <= n <= 1000`\n\n\n - `[input]` integer `m`\n \n number of columns.\n\n `1 <= m <= 1000`\n \n \n - `[output]` a string\n\n The final direction.\n\"\"\"", "inputs": [[1, 1], [2, 2], [2, 3], [2, 4], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6], [100, 100]], "outputs": [["R"], ["L"], ["L"], ["L"], ["D"], ["U"], ["R"], ["R"], ["R"], ["U"], ["D"], ["L"], ["L"], ["L"], ["U"], ["R"], ["R"], ["L"]], "starter_code": "def direction_in_grid(n: int, m: int) -> str:", "canonical_solution": "def direction_in_grid(n, m):\n    return 'LR'[n % 2] if m >= n else 'UD'[m % 2]", "entry_point": "direction_in_grid", "task_id": "TACO_lite/285", "input_output_examples": "[[[3, 3]], [['R']]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 1], [1, 2], [2, 1], [2, 2], [3, 3], [3, 4], [4, 3], [1000, 1000], [5, 5], [5, 7]]", "qwen2.5-coder-32b-instruct": "[[1, 1], [2, 2], [3, 3], [1, 2], [2, 1], [1, 1000], [1000, 1], [4, 5], [5, 4], [10, 10], [1000, 1000]]"}}
{"requirement": "def encrypter(strng: str) -> str:\n\"\"\"You have been recruited by an unknown organization for your cipher encrypting/decrypting skills.  \nBeing new to the organization they decide to test your skills.  \nYour first test is to write an algorithm that encrypts the given string in the following steps.\n\n1. The first step of the encryption is a standard ROT13 cipher.\nThis is a special case of the caesar cipher where the letter is encrypted with its key that is thirteen letters down the alphabet,  \ni.e. `A => N, B => O, C => P, etc..`\n\n1. Part two of the encryption is to take the ROT13 output and replace each letter with its exact opposite. `A => Z, B => Y, C => X`.  \nThe return value of this should be the encrypted message.\n\n\nDo not worry about capitalization or punctuation. All encrypted messages should be lower case and punctuation free.  \nAs an example, the string `\"welcome to our organization\"` should return `\"qibkyai ty ysv yvgmzenmteyz\"`.\n\nGood luck, and congratulations on the new position.\n\"\"\"", "inputs": [["amz"], ["welcome to the organization"], ["hello"], ["my name is"], ["goodbye"]], "outputs": [["man"], ["qibkyai ty tfi yvgmzenmteyz"], ["fibby"], ["ao zmai eu"], ["gyyjloi"]], "starter_code": "def encrypter(strng: str) -> str:", "canonical_solution": "def encrypter(strng):\n    return ''.join((c if c == ' ' else chr(122 - (ord(c) - 97 + 13) % 26) for c in strng))", "entry_point": "encrypter", "task_id": "TACO_lite/288", "input_output_examples": "[[['welcome to our organization']], [['qibkyai ty ysv yvgmzenmteyz']]]", "llm_generated_inputs": {"deepseek-v3": "[['welcome to our organization'], ['hello world'], ['abcdefghijklmnopqrstuvwxyz'], ['the quick brown fox jumps over the lazy dog'], ['12345'], ['!@#$%^&*()'], [''], ['A'], ['Z'], ['a'], ['z'], ['This is a test string with mixed CASE and punctuation!']]", "qwen2.5-coder-32b-instruct": "[['welcome to our organization'], ['hello world'], ['abc xyz'], ['python programming'], ['a b c d e f g h i j k l m n o p q r s t u v w x y z'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZ'], ['1234567890'], ['!@#$%^&*()_+'], [''], [' '], ['a'], ['z']]"}}
{"requirement": "from typing import List\nfrom typing import Union\n\n\ndef explode(arr: List[Union[int, str]]) -> Union[List[List[Union[int, str]]], str]:\n\"\"\"You are given an initial 2-value array (x). You will use this to calculate a score.\n\nIf both values in (x) are numbers, the score is the sum of the two. If only one is a number, the score is that number. If neither is a number, return 'Void!'.\n\n\nOnce you have your score, you must return an array of arrays. Each sub array will be the same as (x) and the number of sub arrays should be equal to the score.\n\nFor example:\n\nif (x) == ['a', 3]  you should return [['a', 3], ['a', 3], ['a', 3]].\n\"\"\"", "inputs": [[[9, 3]], [["a", 3]], [[6, "c"]], [["a", "b"]], [[1, 0]]], "outputs": [[[[9, 3], [9, 3], [9, 3], [9, 3], [9, 3], [9, 3], [9, 3], [9, 3], [9, 3], [9, 3], [9, 3], [9, 3]]], [[["a", 3], ["a", 3], ["a", 3]]], [[[6, "c"], [6, "c"], [6, "c"], [6, "c"], [6, "c"], [6, "c"]]], ["Void!"], [[[1, 0]]]], "starter_code": "from typing import List\nfrom typing import Union\ndef explode(arr: List[Union[int, str]]) -> Union[List[List[Union[int, str]]], str]:", "canonical_solution": "def explode(arr):\n    return [arr] * sum((v for v in arr if isinstance(v, int))) or 'Void!'", "entry_point": "explode", "task_id": "TACO_lite/291", "input_output_examples": "[[[['a', 3]]], [[[['a', 3], ['a', 3], ['a', 3]]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2]], [['a', 3]], [[4, 'b']], [['c', 'd']], [[0, 5]], [[-1, 6]], [[7, 7]], [['e', 'f']], [[8, 'g']], [['h', 9]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2]], [[5, 'b']], [['c', 7]], [['x', 'y']], [[0, 0]], [[0, 'z']], [['m', 0]], [[100, 200]], [[1, '1']], [['1', 1]]]"}}
{"requirement": "from typing import List\n\n\ndef step(g: int, m: int, n: int) -> List[int]:\n\"\"\"The prime numbers are not regularly spaced. For example from `2` to `3` the step is `1`.\nFrom `3` to `5` the step is `2`. From `7` to `11` it is `4`.\nBetween 2 and 50 we have the following pairs of 2-steps primes:\n\n`3, 5 - 5, 7, - 11, 13, - 17, 19, - 29, 31, - 41, 43`\n\nWe will write a function `step` with parameters:\n\n- `g` (integer >= 2) which indicates the step we are looking for,\n\n- `m` (integer >= 2) which gives the start of the search (m inclusive),\n\n- `n` (integer >= m) which gives the end of the search (n inclusive)\n\nIn the example above `step(2, 2, 50)` will return `[3, 5]` which is the first pair between 2 and 50 with a 2-steps.\n\nSo this function should return the **first** pair of the two prime numbers spaced with a step of `g`\nbetween the limits `m`, `n` if these g-steps prime numbers exist otherwise `nil` or `null` or `None` or `Nothing` or `[]` or `\"0, 0\"` or `{0, 0}` or `0 0`(depending on the language). \n\n\n#Examples:\n\n- \n\n\n`step(2, 5, 7) --> [5, 7] or (5, 7) or {5, 7} or \"5 7\"`\n\n`step(2, 5, 5) --> nil or ... or [] in Ocaml or {0, 0} in C++`\n\n`step(4, 130, 200) --> [163, 167] or (163, 167) or {163, 167}`\n\n- **See more examples for your language in \"RUN\"**\n\n\n- Remarks:\n\n([193, 197] is also such a 4-steps primes between 130 and 200 but it's not the first pair).\n\n`step(6, 100, 110) --> [101, 107]` though there is a prime between 101 and 107 which is 103; the pair 101-103 is a 2-step.\n\n\n#Notes: \nThe idea of \"step\" is close to that of \"gap\" but it is not exactly the same. For those interested they can have a look\nat . \n\nA \"gap\" is more restrictive: there must be no primes in between \n(101-107 is a \"step\" but not a \"gap\". Next kata will be about \"gaps\":-).\n\nFor Go: nil slice is expected when there are no `step` between m and n.\nExample: step(2,4900,4919) --> nil\n\"\"\"", "inputs": [[2, 100, 110], [4, 100, 110], [6, 100, 110], [8, 300, 400], [10, 300, 400], [4, 30000, 100000], [6, 30000, 100000], [8, 30000, 100000], [11, 30000, 100000], [16, 5, 20], [2, 10000000, 11000000], [52, 1300, 15000], [10, 4900, 5000], [30, 4900, 5000], [2, 4900, 5000], [2, 104000, 105000], [2, 4900, 4919], [7, 4900, 4919], [4, 30115, 100000], [4, 30140, 100000], [4, 30000, 30325]], "outputs": [[[101, 103]], [[103, 107]], [[101, 107]], [[359, 367]], [[307, 317]], [[30109, 30113]], [[30091, 30097]], [[30089, 30097]], [null], [null], [[10000139, 10000141]], [[1321, 1373]], [[4909, 4919]], [[4903, 4933]], [[4931, 4933]], [[104087, 104089]], [null], [null], [[30133, 30137]], [[30319, 30323]], [[30109, 30113]]], "starter_code": "from typing import List\ndef step(g: int, m: int, n: int) -> List[int]:", "canonical_solution": "import math\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            return False\n    return True\n\ndef step(g, m, n):\n    if m >= n:\n        return []\n    else:\n        for i in range(m, n + 1 - g):\n            if isPrime(i) and isPrime(i + g):\n                return [i, i + g]", "entry_point": "step", "task_id": "TACO_lite/293", "input_output_examples": "[[[2, 2, 50], [2, 5, 7], [2, 5, 5], [4, 130, 200], [6, 100, 110], [2, 4900, 4919]], [[[3, 5]], [[5, 7]], [[]], [[163, 167]], [[101, 107]], [[]]]]", "llm_generated_inputs": {"deepseek-v3": "[[2, 2, 50], [2, 5, 7], [2, 5, 5], [4, 130, 200], [6, 100, 110], [2, 4900, 4919], [3, 10, 20], [5, 50, 100], [1, 2, 10], [10, 100, 200]]", "qwen2.5-coder-32b-instruct": "[[2, 5, 7], [2, 5, 5], [4, 130, 200], [6, 100, 110], [2, 2, 50], [2, 100, 102], [8, 300, 400], [10, 500, 600], [2, 4900, 4919], [2, 1, 2], [2, 2, 2], [3, 10, 20], [5, 50, 100]]"}}
{"requirement": "def solve(a: int, b: int) -> int:\n\"\"\"The sum of divisors of `6` is `12` and the sum of divisors of `28` is `56`. You will notice that `12/6 = 2` and `56/28 = 2`. We shall say that `(6,28)` is a pair with a ratio of `2`.  Similarly, `(30,140)` is also a pair but with a ratio of `2.4`. These ratios are simply decimal representations of fractions.\n\n`(6,28)` and `(30,140)` are the only pairs in which `every member of a pair is 0 <= n < 200`. The sum of the lowest members of each pair is `6 + 30 = 36`. \n\nYou will be given a `range(a,b)`, and your task is to group the numbers into pairs with the same ratios. You will return the sum of the lowest member of each pair in the range. If there are no pairs. return `nil` in Ruby, `0` in python. Upper limit is `2000`.\n\n```Haskell\nsolve(0,200) = 36\n```\n\nGood luck!\n\nif you like this Kata, please try:\n\n[Simple division](https://www.codewars.com/kata/59ec2d112332430ce9000005)\n\n[Sub-array division](https://www.codewars.com/kata/59eb64cba954273cd4000099)\n\"\"\"", "inputs": [[1, 100], [1, 200], [1, 300], [200, 1000], [1, 1000], [100, 1000], [800, 2000]], "outputs": [[6], [36], [252], [1104], [2619], [2223], [2352]], "starter_code": "def solve(a: int, b: int) -> int:", "canonical_solution": "from collections import defaultdict\nfrom fractions import Fraction\nfrom bisect import bisect_left as bisect\nharmonic = [0] + [Fraction(sum({y for x in range(1, int(n ** 0.5) + 1) for y in [x, n // x] if not n % x}), n) for n in range(1, 7001)]\nharmonicity = defaultdict(set)\nfor n, h in enumerate(harmonic):\n    harmonicity[h].add(n)\nHARMO_GROUPS = {h: sorted(s) for h, s in harmonicity.items() if len(s) > 1}\nHARMO_RATIOS = {n: h for h, lst in HARMO_GROUPS.items() for n in lst}\nHARMO_NUM = sorted(HARMO_RATIOS.keys())\n\ndef solve(a, b):\n    seens, s = (set(), 0)\n    n1, n2 = (bisect(HARMO_NUM, a), bisect(HARMO_NUM, b))\n    for n in HARMO_NUM[n1:n2]:\n        if n not in seens:\n            grp = [x for x in HARMO_GROUPS[HARMO_RATIOS[n]] if a <= x < b]\n            if len(grp) > 1:\n                seens |= set(grp)\n                s += grp[0]\n    return s", "entry_point": "solve", "task_id": "TACO_lite/308", "input_output_examples": "[[[0, 200]], [[36]]]", "llm_generated_inputs": {"deepseek-v3": "[[0, 200], [0, 10], [10, 50], [100, 200], [200, 500], [500, 1000], [1000, 2000], [1500, 2000], [0, 2000], [0, 0], [200, 200], [199, 200], [0, 1], [1, 2], [2, 3]]", "qwen2.5-coder-32b-instruct": "[[0, 200], [0, 1000], [100, 200], [0, 2000], [0, 1], [1999, 2000], [200, 400], [500, 1500], [1000, 2000], [0, 0]]"}}
{"requirement": "def greet_jedi(first: str, last: str) -> str:\n\"\"\"You just took a contract with the Jedi council. They need you to write a function, `greet_jedi()`, which takes two arguments (a first name and a last name), works out the corresponding *Jedi name*, and returns a string greeting the Jedi.\n\nA person's *Jedi name* is the first three letters of their last name followed by the first two letters of their first name. For example:\n```python\n>>> greet_jedi('Beyonce', 'Knowles')\n'Greetings, master KnoBe'\n```\nNote the capitalization: the first letter of each name is capitalized. Your input may or may not be capitalized. Your function should handle it and return the Jedi name in the correct case no matter what case the input is in:\n```python\n>>> greet_jedi('grae', 'drake')\n'Greetings, master DraGr'\n```\nYou can trust that your input names will always be at least three characters long.\n\nIf you're stuck, check out the [python.org tutorial](https://docs.python.org/3/tutorial/introduction.html#strings) section on strings and search \"slice\".\n\"\"\"", "inputs": [["Beyonce", "Knowles"], ["Chris", "Angelico"], ["grae", "drake"]], "outputs": [["Greetings, master KnoBe"], ["Greetings, master AngCh"], ["Greetings, master DraGr"]], "starter_code": "def greet_jedi(first: str, last: str) -> str:", "canonical_solution": "def greet_jedi(first, last):\n    return 'Greetings, master {}{}'.format(last[:3].capitalize(), first[:2].capitalize())", "entry_point": "greet_jedi", "task_id": "TACO_lite/310", "input_output_examples": "[[['Beyonce', 'Knowles'], ['grae', 'drake']], [['Greetings, master KnoBe'], ['Greetings, master DraGr']]]", "llm_generated_inputs": {"deepseek-v3": "[['Beyonce', 'Knowles'], ['grae', 'drake'], ['LUKE', 'SKYWALKER'], ['anakin', 'skywalker'], ['obiwan', 'kenobi'], ['padme', 'amidala'], ['LEIA', 'ORGANA'], ['mace', 'windu'], ['quiGON', 'jinn'], ['ahsoka', 'tano']]", "qwen2.5-coder-32b-instruct": "[['Beyonce', 'Knowles'], ['grae', 'drake'], ['Leia', 'Organa'], ['luke', 'skywalker'], ['ANAKIN', 'Skywalker'], ['padme', 'AMIDALA'], ['obiwan', 'KENOBI'], ['Yoda', 'Master'], ['aLpHa', 'bEtA'], ['abcdefghijklmnopqrstuvwxyz', 'zyxwvutsrqponmlkjihgfedcba']]"}}
{"requirement": "from typing import List\n\n\ndef solve(arr: List[int]) -> List[int]:\n\"\"\"In this Kata, you will be given an array of unique elements, and your task is to rerrange the values so that the first max value is followed by the first minimum, followed by second max value then second min value, etc. \n\nFor example:\nThe first max is `15` and the first min is `7`. The second max is `12` and the second min is `10` and so on. \n\nMore examples in the test cases. \n\nGood luck!\n\"\"\"", "inputs": [[[15, 11, 10, 7, 12]], [[91, 75, 86, 14, 82]], [[84, 79, 76, 61, 78]], [[52, 77, 72, 44, 74, 76, 40]], [[1, 6, 9, 4, 3, 7, 8, 2]], [[78, 79, 52, 87, 16, 74, 31, 63, 80]]], "outputs": [[[15, 7, 12, 10, 11]], [[91, 14, 86, 75, 82]], [[84, 61, 79, 76, 78]], [[77, 40, 76, 44, 74, 52, 72]], [[9, 1, 8, 2, 7, 3, 6, 4]], [[87, 16, 80, 31, 79, 52, 78, 63, 74]]], "starter_code": "from typing import List\ndef solve(arr: List[int]) -> List[int]:", "canonical_solution": "def solve(arr):\n    arr = sorted(arr, reverse=True)\n    res = []\n    while len(arr):\n        res.append(arr.pop(0))\n        if len(arr):\n            res.append(arr.pop())\n    return res", "entry_point": "solve", "task_id": "TACO_lite/311", "input_output_examples": "[[[[15, 7, 12, 10, 11, 9]]], [[[15, 7, 12, 10, 11, 9]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 5]], [[10, 7, 12, 3, 15]], [[9]], [[5, 1, 3, 2, 4]], [[100, 50, 200, 150, 300]], [[]], [[20, 10, 30, 40, 50, 60]], [[0, 0, 0, 0]]]", "qwen2.5-coder-32b-instruct": "[[[15, 12, 10, 7]], [[1, 2, 3, 4, 5]], [[10, 20, 30, 40, 50, 60]], [[5, 3, 1, 2, 4]], [[9, 8, 7, 6, 5, 4, 3, 2, 1]], [[1]], [[]], [[100, 200]]]"}}
{"requirement": "from typing import List\n\n\ndef find_a(lst: List[int], n: int) -> int:\n\"\"\"In an infinite array with two rows, the numbers in the top row are denoted\n\n`. . . , A[−2], A[−1], A[0], A[1], A[2], . . .`\n\nand the numbers in the bottom row are denoted\n\n`. . . , B[−2], B[−1], B[0], B[1], B[2], . . .`\n\nFor each integer `k`, the entry `A[k]` is directly above\nthe entry `B[k]` in the array, as shown:\n\n\n...|A[-2]|A[-1]|A[0]|A[1]|A[2]|...\n...|B[-2]|B[-1]|B[0]|B[1]|B[2]|...\n\n\n\nFor each integer `k`, `A[k]` is the average of the entry to its left, the entry to its right,\nand the entry below it; similarly, each entry `B[k]` is the average of the entry to its\nleft, the entry to its right, and the entry above it.\n\n\nGiven `A[0], A[1], A[2] and A[3]`, determine the value of `A[n]`. (Where range of n is -1000 Inputs and Outputs in BigInt!** \n\nAdapted from 2018 Euclid Mathematics Contest.\nhttps://www.cemc.uwaterloo.ca/contests/past_contests/2018/2018EuclidContest.pdf\n\"\"\"", "inputs": [[[1, 2, 3, 4], 2], [[38, 200, -18, 45], 1], [[1, 0, 0, 1], 5], [[0, 2, 0, 3], -2], [[-20, 1, -3, 14], -5], [[1, 2, 3, 5], 100], [[0, 4, 6, 13], 100]], "outputs": [[3], [200], [20], [-126], [-44402], [60560100487003612846322657690093088848428068520476594299], [335254562473098582210532865941148591672699700764231400858]], "starter_code": "from typing import List\ndef find_a(lst: List[int], n: int) -> int:", "canonical_solution": "def find_a(lst, n):\n    if n < 0:\n        return find_a(lst[::-1], 3 - n)\n    if n < 4:\n        return lst[n]\n    a, b, c, d = lst\n    for _ in range(n - 3):\n        a, b, c, d = (b, c, d, 6 * d - 10 * c + 6 * b - a)\n    return d", "entry_point": "find_a", "task_id": "TACO_lite/312", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4], 5], [[1, 2, 3, 4], -1], [[1, 2, 3, 4], 0], [[1, 2, 3, 4], 1], [[1, 2, 3, 4], 2], [[1, 2, 3, 4], 3], [[1, 2, 3, 4], 100], [[1, 2, 3, 4], -100], [[0, 0, 0, 0], 10], [[10, 20, 30, 40], -5], [[-1, -2, -3, -4], 7], [[1, 1, 1, 1], 50], [[5, 10, 15, 20], -10]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 4], 0], [[1, 2, 3, 4], 1], [[1, 2, 3, 4], 2], [[1, 2, 3, 4], 3], [[1, 2, 3, 4], 4], [[1, 2, 3, 4], -1], [[1, 2, 3, 4], -2], [[1, 2, 3, 4], 10], [[1, 2, 3, 4], -10], [[0, 0, 0, 0], 5], [[1, 1, 1, 1], -5], [[10, 20, 30, 40], 100], [[10, 20, 30, 40], -100], [[1, -1, 1, -1], 1000], [[1, -1, 1, -1], -1000]]"}}
{"requirement": "from typing import List\n\n\ndef solve(arr: List[int]) -> int:\n\"\"\"In this Kata, you will be given an array of integers and your task is to return the number of arithmetic progressions of size `3` that are possible from that list. In each progression, the differences between the elements must be the same.\n\n```\n[1, 2, 3, 5, 7, 9] ==> 5\n// [1, 2, 3], [1, 3, 5], [1, 5, 9], [3, 5, 7], and [5, 7, 9]\n```\n\nAll inputs will be sorted. More examples in test cases. \n\nGood luck!\n\"\"\"", "inputs": [[[1, 2, 3, 4, 5]], [[1, 2, 3, 5, 7, 9]], [[0, 5, 8, 9, 11, 13, 14, 16, 17, 19]], [[0, 1, 2, 3, 5, 6, 7, 11, 13, 15, 17, 19]], [[0, 1, 4, 5, 7, 9, 10, 13, 15, 16, 18, 19]], [[0, 1, 2, 3, 5, 8, 11, 13, 14, 16, 18, 19]]], "outputs": [[4], [5], [10], [17], [15], [13]], "starter_code": "from typing import List\ndef solve(arr: List[int]) -> int:", "canonical_solution": "def solve(arr):\n    return sum((y - x == z - y for i, x in enumerate(arr[:-2]) for j, y in enumerate(arr[i + 1:-1]) for _, z in enumerate(arr[j + 1:])))", "entry_point": "solve", "task_id": "TACO_lite/316", "input_output_examples": "[[[[1, 2, 3, 5, 7, 9]]], [[5]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 5, 7, 9]], [[1, 2, 3, 4, 5]], [[10, 20, 30, 40, 50, 60]], [[1, 1, 1, 1, 1]], [[1, 3, 5, 7, 9, 11, 13]], [[5]], [[2, 4, 6, 8, 10, 12, 14, 16]], [[1, 5, 9, 13, 17, 21]], [[0, 0, 0, 0, 0, 0, 0]], [[3, 6, 9, 12, 15, 18, 21]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 5, 7, 9]], [[1, 3, 5, 7, 9]], [[1, 2, 4, 8, 16]], [[5, 7, 9]], [[1, 2, 3]], [[10, 20, 30, 40, 50]], [[1, 2]], [[1]], [[]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]"}}
{"requirement": "def luck_check(string: str) -> bool:\n\"\"\"In some countries of former Soviet Union there was a belief about lucky tickets. A transport ticket of any sort was believed to posess luck if sum of digits on the left half of its number was equal to the sum of digits on the right half. Here are examples of such numbers:\n```\n003111    #             3 = 1 + 1 + 1\n813372    #     8 + 1 + 3 = 3 + 7 + 2\n17935     #         1 + 7 = 3 + 5  // if the length is odd, you should ignore the middle number when adding the halves.\n56328116  # 5 + 6 + 3 + 2 = 8 + 1 + 1 + 6\n```\nSuch tickets were either eaten after being used or collected for bragging rights.\n\nYour task is to write a funtion ```luck_check(str)```, which returns ```true/True``` if argument is string decimal representation of a lucky ticket number, or ```false/False``` for all other numbers. It should throw errors for empty strings or strings which don't represent a decimal number.\n\"\"\"", "inputs": [["5555"], ["003111"], ["543970707"], ["439924"], ["943294329932"], ["000000"], ["454319"], ["1233499943"], ["935336"]], "outputs": [[true], [true], [false], [false], [false], [true], [true], [false], [false]], "starter_code": "def luck_check(string: str) -> bool:", "canonical_solution": "def luck_check(string):\n    e0, b1 = (len(string) // 2, (len(string) + 1) // 2)\n    return sum(map(int, string[:e0])) == sum(map(int, string[b1:]))", "entry_point": "luck_check", "task_id": "TACO_lite/318", "input_output_examples": "[[['003111'], ['813372'], ['17935'], ['56328116']], [[True], [True], [True], [True]]]", "llm_generated_inputs": {"deepseek-v3": "[['003111'], ['813372'], ['17935'], ['56328116'], ['123456'], ['0000'], ['123'], ['12345a'], [''], ['1']]", "qwen2.5-coder-32b-instruct": "[['003111'], ['813372'], ['17935'], ['56328116'], ['123456'], ['123321'], ['1'], ['12'], ['123'], ['22'], ['0'], ['1111'], ['2468642'], ['987654321'], ['4321234'], ['11111111'], ['22222222'], ['12345678987654321'], ['123abc'], ['']]"}}
{"requirement": "def poohbear(s: str) -> str:\n\"\"\"Create a function that interprets code in the esoteric language **Poohbear**\n\n## The Language\n\nPoohbear is a stack-based language largely inspired by Brainfuck. It has a maximum integer value of 255, and 30,000 cells. The original intention of Poohbear was to be able to send messages that would, to most, be completely indecipherable: \nPoohbear Wiki\n\n* For the purposes of this kata, you will make a version of Poohbear that has **infinite** memory cells in **both directions** (so you do not need to limit cells to 30,000)\n* Cells have a default value of 0\n* Each cell can hold one byte of data.  Once a cell's value goes above 255, it wraps around to 0.  If a cell's value goes below 0, it wraps to 255.\n* If the result of an operation isn't an int, round the result down to the nearest one.\n* Your interpreter should ignore any non-command characters in the code.\n* If you come to a `W` in the code and the current cell is equal to 0, jump to the corresponding `E`.\n* If you come to an `E` in the code and the current cell is **not** 0, jump back to the corresponding `W`.\n\nHere are the Poohbear commands: \n\n| Command | Definition\n|---| -------------------------\n| + | Add 1 to the current cell\n| - | Subtract 1 from the current cell\n| > | Move the cell pointer 1 space to the right\n| < | Move the cell pointer 1 space to the left\n| c | \"Copy\" the current cell\n| p | Paste the \"copied\" cell into the current cell\n| W | While loop - While the current cell is not equal to 0\n| E | Closing character for loops\n| P | Output the current cell's value as ascii\n| N | Output the current cell's value as an integer\n| T | Multiply the current cell by 2\n| Q | Square the current cell\n| U | Square root the current cell's value\n| L | Add 2 to the current cell\n| I | Subtract 2 from the current cell\n| V | Divide the current cell by 2\n| A | Add the copied value to the current cell's value\n| B | Subtract the copied value from the current cell's value\n| Y | Multiply the current cell's value by the copied value\n| D | Divide the current cell's value by the copied value.\n\"\"\"", "inputs": [["LQTcQAP>pQBBTAI-PA-PPL+P<BVPAL+T+P>PL+PBLPBP<DLLLT+P"], ["LLQT+P >LLLc+QIT-P AAAP P"], ["LLQT>+WN+<P>E"], ["cW>LQQT+P<pE"], ["+W>LQQT+P<-E"], ["+LTQII>+WN<P>+E"], ["+LTQIITTIWP-E"], ["LILcABNBpYDYYYYLLL+P-+W-EQNW-ELLQUTTTT+P"], ["++W-NE"], ["W>UQLIPNPPP45vSDFJLLIPNPqwVMT<E"], ["LLILQQLcYYD"], ["NNN++-NTTTTT+PN"], ["LQQT+P+P+P+P+P+P"], ["+-<>LcIpIL+TQYDABANPAPIIIITUNNQV+++P"], ["+c BANANA BANANA BANANA BANANA BANANA"], ["L       sfdg           ghjk                         kl                                LQTT++++P                        tt                                W                  w                    -                                      E           wewewe                N"]], "outputs": [["Hello World!"], ["!]oo"], ["1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 "], [""], ["!"], ["1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 "], ["~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"! \u001f\u001e\u001d\u001c\u001b\u001a\u0019\u0018\u0017\u0016\u0015\u0014\u0013\u0012\u0011\u0010\u000f\u000e\r\f\u000b\n\t\b\u0007\u0006\u0005\u0004\u0003\u0002\u0001"], ["2'0A"], ["10"], [""], [""], ["0001!33"], ["!\"#$%&"], ["38&(88#"], ["12345678910"], ["D0"]], "starter_code": "def poohbear(s: str) -> str:", "canonical_solution": "from operator import add, mul, floordiv as fdiv, pow\n\ndef poohbear(s):\n\n    def updateMem(func, v):\n        mem[p] = func(mem.get(p, 0), v) % 256\n    braces, stack = ({}, [])\n    for i, c in enumerate(s):\n        if c == 'W':\n            stack.append(i)\n        if c == 'E':\n            braces[i] = stack[-1]\n            braces[stack.pop()] = i\n    mem, copy, output = ({}, 0, [])\n    p, i = (0, 0)\n    while i < len(s):\n        cmd = s[i]\n        if cmd == '>':\n            p += 1\n        elif cmd == '<':\n            p -= 1\n        elif cmd == 'p':\n            mem[p] = copy\n        elif cmd == 'c':\n            copy = mem.get(p, 0)\n        elif cmd == 'W':\n            i = i if bool(mem.get(p, 0)) else braces[i]\n        elif cmd == 'E':\n            i = braces[i] if mem.get(p, 0) else i\n        elif cmd == 'P':\n            output.append(chr(mem.get(p, 0)))\n        elif cmd == 'N':\n            output.append(str(mem.get(p, 0)))\n        elif cmd == '+':\n            updateMem(add, 1)\n        elif cmd == '-':\n            updateMem(add, -1)\n        elif cmd == 'L':\n            updateMem(add, 2)\n        elif cmd == 'I':\n            updateMem(add, -2)\n        elif cmd == 'T':\n            updateMem(mul, 2)\n        elif cmd == 'V':\n            updateMem(fdiv, 2)\n        elif cmd == 'Q':\n            updateMem(pow, 2)\n        elif cmd == 'U':\n            updateMem(lambda a, b: int(pow(a, b)), 0.5)\n        elif cmd == 'A':\n            updateMem(add, copy)\n        elif cmd == 'B':\n            updateMem(add, -copy)\n        elif cmd == 'Y':\n            updateMem(mul, copy)\n        elif cmd == 'D':\n            updateMem(fdiv, copy)\n        i += 1\n    return ''.join(output)", "entry_point": "poohbear", "task_id": "TACO_lite/324", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['+++P'], ['+++N'], ['+>++<P'], ['+c>pP'], ['WT+E'], ['+QPN'], ['+UPN'], ['+LPN'], ['+IPN'], ['+VPN'], ['+cA>pPN'], ['+cB>pPN'], ['+cY>pPN'], ['+cD>pPN'], ['+W+E'], ['Hello+WorldP'], ['+255+P'], ['-1+P']]", "qwen2.5-coder-32b-instruct": "[['+'], ['-'], ['>'], ['<'], ['c'], ['p'], ['P'], ['N'], ['T'], ['Q'], ['U'], ['L'], ['I'], ['V'], ['A'], ['B'], ['Y'], ['D'], ['WEP'], ['WE'], ['WEN'], ['WET'], ['WEQ'], ['WEU'], ['WEL'], ['WEI'], ['WEV'], ['WEA'], ['WEB'], ['WEY'], ['WED'], ['WEEWEP'], ['W+W+W+W+W+W+W+W+W+W+'], ['W-W-W-W-W-W-W-W-W-W-'], ['W>L>L>L>L>L>L>L>L>L>L'], ['W<I<I<I<I<I<I<I<I<I<I'], ['W>T>T>T>T>T>T>T>T>T>T'], ['W<Q<Q<Q<Q<Q<Q<Q<Q<Q<Q'], ['W>U>U>U>U>U>U>U>U>U'], ['W>W>W>W>W>W>W>W>W>W+'], ['W<W<W<W<W<W<W<W<W<W-'], ['W>L>L>L>L>L>L>L>L>L>L'], ['W<I<I<I<I<I<I<I<I<I<I'], ['W>T>T>T>T>T>T>T>T>T>T'], ['W<Q<Q<Q<Q<Q<Q<Q<Q<Q<Q'], ['W>U>U>U>U>U>U>U>U>U'], ['W>A>A>A>A>A>A>A>A>A>A'], ['W>B>B>B>B>B>B>B>B>B>B'], ['W>Y>Y>Y>Y>Y>Y>Y>Y>Y>Y'], ['W>D>D>D>D>D>D>D>D>D>D'], ['WEPWEPWEPWEPWEPWEPWEP']]"}}
{"requirement": "def check_alive(health: int) -> bool:\n\"\"\"## If/else syntax debug\n\nWhile making a game, your partner, Greg, decided to create a function to check if the user is still alive called `checkAlive`/`CheckAlive`/`check_alive`. Unfortunately, Greg made some errors while creating the function.\n\n`checkAlive`/`CheckAlive`/`check_alive` should return true if the player's health is greater than 0 or false if it is 0 or below. \n\n```if-not:csharp\nThe function receives one parameter `health` which will always be a whole number between -10 and 10.\n```\n\"\"\"", "inputs": [[5], [0], [-5]], "outputs": [[true], [false], [false]], "starter_code": "def check_alive(health: int) -> bool:", "canonical_solution": "def check_alive(health: int):\n    return health > 0", "entry_point": "check_alive", "task_id": "TACO_lite/325", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[5], [0], [-3], [10], [-10], [1]]", "qwen2.5-coder-32b-instruct": "[[10], [5], [1], [0], [-1], [-5], [-10]]"}}
{"requirement": "def solve(n: int) -> int:\n\"\"\"In this Kata, you will be given an integer `n` and your task will be to return `the largest integer that is <= n and has the highest digit sum`.\n\nFor example:\n```\nsolve(100) = 99. Digit Sum for 99 = 9 + 9 = 18. No other number <= 100 has a higher digit sum.\nsolve(10) = 9\nsolve(48) = 48. Note that 39 is also an option, but 48 is larger.\n```\n\nInput range is `0 < n < 1e11`\n\nMore examples in the test cases.\n\nGood luck!\n\"\"\"", "inputs": [[79320], [99004], [99088], [99737], [29652], [100], [48], [521], [1], [2], [3], [39188], [5], [10], [1000], [10000], [999999999992], [59195], [19930], [110], [1199], [120], [18], [2090], [72694]], "outputs": [[78999], [98999], [98999], [98999], [28999], [99], [48], [499], [1], [2], [3], [38999], [5], [9], [999], [9999], [999999999989], [58999], [19899], [99], [999], [99], [18], [1999], [69999]], "starter_code": "def solve(n: int) -> int:", "canonical_solution": "def solve(n):\n    x = str(n)\n    res = [x] + [str(int(x[:i]) - 1) + '9' * (len(x) - i) for i in range(1, len(x))]\n    return int(max(res, key=lambda x: (sum(map(int, x)), int(x))))", "entry_point": "solve", "task_id": "TACO_lite/328", "input_output_examples": "[[[100], [10], [48]], [[99], [9], [48]]]", "llm_generated_inputs": {"deepseek-v3": "[[100], [10], [48], [1], [9], [99], [123], [1000], [9999999999], [10000000000], [123456789], [987654321], [101], [111], [100000000], [999999999]]", "qwen2.5-coder-32b-instruct": "[[100], [10], [48], [999], [1], [123456789], [987654321], [111111111], [1000000000], [999999999]]"}}
{"requirement": "from typing import List\n\n\ndef duplicates(arr: List[int]) -> int:\n\"\"\"You are given array of integers, your task will be to count all pairs in that array and return their count.\n\n**Notes:**\n   \n* Array can be empty or contain only one value; in this case return `0` \n* If there are more pairs of a certain number, count each pair only once. E.g.: for `[0, 0, 0, 0]` the return value is `2` (= 2 pairs of `0`s)\n* Random tests: maximum array length is 1000, range of values in array is between 0 and 1000\n\n\n## Examples\n\n```\n[1, 2, 5, 6, 5, 2]  -->  2\n```\n...because there are 2 pairs: `2` and `5`\n\n\n```\n[1, 2, 2, 20, 6, 20, 2, 6, 2]  -->  4\n```\n\n...because there are 4 pairs: `2`, `20`, `6` and `2` (again)\n\"\"\"", "inputs": [[[1, 2, 2, 20, 6, 20, 2, 6, 2]], [[1000, 1000]], [[]], [[54]]], "outputs": [[4], [1], [0], [0]], "starter_code": "from typing import List\ndef duplicates(arr: List[int]) -> int:", "canonical_solution": "def duplicates(arr):\n    return sum((arr.count(i) // 2 for i in set(arr)))", "entry_point": "duplicates", "task_id": "TACO_lite/335", "input_output_examples": "[[[[1, 2, 5, 6, 5, 2]], [[1, 2, 2, 20, 6, 20, 2, 6, 2]]], [[2], [4]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 5, 6, 5, 2]], [[1, 2, 2, 20, 6, 20, 2, 6, 2]], [[0, 0, 0, 0]], [[]], [[42]], [[10, 10, 10, 10, 10, 10, 10, 10, 10, 10]], [[1, 1, 2, 2, 3, 3, 4, 4, 5, 5]], [[1000, 1000, 1000]], [[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]", "qwen2.5-coder-32b-instruct": "[[[]], [[1]], [[1, 2]], [[1, 1]], [[1, 2, 3, 4, 5]], [[1, 2, 2, 3, 3, 3]], [[1, 2, 5, 6, 5, 2]], [[1, 2, 2, 20, 6, 20, 2, 6, 2]], [[0, 0, 0, 0]], [[1000, 1000, 1000, 1000, 1000, 1000]], [[1, 1, 2, 2, 3, 3, 4, 4, 5, 5]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]"}}
{"requirement": "def base64_to_base10(string: str) -> int:\n\"\"\"# Base64 Numeric Translator\n\nOur standard numbering system is (Base 10). That includes 0 through 9. Binary is (Base 2), only 1’s and 0’s.  And Hexadecimal is (Base 16) (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F). A hexadecimal “F” has a (Base 10) value of 15. (Base 64) has 64 individual characters which translate in value in (Base 10) from between 0 to 63.\n\n####Write a method that will convert a string from (Base 64) to it's (Base 10) integer value.\n\nThe (Base 64) characters from least to greatest will be\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\n```\nWhere 'A' is equal to 0 and '/' is equal to 63.\n\nJust as in standard (Base 10) when you get to the highest individual integer 9 the next number adds an additional place and starts at the beginning 10; so also (Base 64) when you get to the 63rd digit '/' and the next number adds an additional place and starts at the beginning \"BA\".\n\nExample:\n```\nbase64_to_base10(\"/\") # => 63\nbase64_to_base10(\"BA\") # => 64\nbase64_to_base10(\"BB\") # => 65\nbase64_to_base10(\"BC\") # => 66\n```\n\nWrite a method `base64_to_base10` that will take a string (Base 64) number and output it's (Base 10) value as an integer.\n\"\"\"", "inputs": [["WIN"], ["b64"], ["B64"], ["/+/"], ["HelloWorld"]], "outputs": [[90637], [114360], [7864], [262079], [134710352538679645]], "starter_code": "def base64_to_base10(string: str) -> int:", "canonical_solution": "DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\ndef base64_to_base10(string):\n    return sum((DIGITS.index(digit) * 64 ** i for i, digit in enumerate(string[::-1])))", "entry_point": "base64_to_base10", "task_id": "TACO_lite/342", "input_output_examples": "[[['/'], ['BA'], ['BB'], ['BC']], [[63], [64], [65], [66]]]", "llm_generated_inputs": {"deepseek-v3": "[['A'], ['/'], ['BA'], ['BB'], ['BC'], ['B/'], ['CA'], ['Z'], ['a'], ['z'], ['0'], ['9'], ['+'], ['//'], ['AAA'], ['AA/'], ['A/B'], ['BAA'], ['ZZZ']]", "qwen2.5-coder-32b-instruct": "[['A'], ['Z'], ['a'], ['z'], ['0'], ['9'], ['+'], ['/'], ['BA'], ['BB'], ['BC'], ['B+'], ['B/'], ['CA'], ['CZ'], ['Ca'], ['Cz'], ['C0'], ['C9'], ['C+'], ['C/'], ['AA'], ['AB'], ['AZ'], ['Aa'], ['Az'], ['A0'], ['A9'], ['A+'], ['A/'], ['//'], ['BAA'], ['BAAA'], ['AAAA'], ['////'], [''], ['B']]"}}
{"requirement": "from typing import List\n\n\ndef transpose_two_strings(arr: List[str]) -> str:\n\"\"\"You will be given an array that contains two strings. Your job is to create a function that will take those two strings and transpose them, so that the strings go from top to bottom instead of left to right.\nA few things to note:\n\n1. There should be one space in between the two characters\n2. You don't have to modify the case (i.e. no need to change to upper or lower)\n3. If one string is longer than the other, there should be a space where the character would be\n\"\"\"", "inputs": [[["Hello", "World"]], [["joey", "louise"]], [["a", "cat"]], [["cat", ""]], [["!a!a!", "?b?b"]]], "outputs": [["H W\ne o\nl r\nl l\no d"], ["j l\no o\ne u\ny i\n  s\n  e"], ["a c\n  a\n  t"], ["c  \na  \nt  "], ["! ?\na b\n! ?\na b\n!  "]], "starter_code": "from typing import List\ndef transpose_two_strings(arr: List[str]) -> str:", "canonical_solution": "import itertools\n\ndef transpose_two_strings(arr):\n    return '\\n'.join((' '.join(elt) for elt in itertools.zip_longest(arr[0], arr[1], fillvalue=' ')))", "entry_point": "transpose_two_strings", "task_id": "TACO_lite/343", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[['Hello', 'World']], [['Python', 'Code']], [['Short', 'Longer']], [['One', 'TwoThree']], [['', 'Empty']], [['Single', '']], [['', '']], [['A', 'B']], [['Multiple Words', 'In Strings']]]", "qwen2.5-coder-32b-instruct": "[[['abc', '123']], [['hello', 'world']], [['short', 'longerstring']], [['abcd', '']], [['', '']], [['single', 'one']], [['a', 'b']], [['same', 'size']], [['longerstring', 'short']]]"}}
{"requirement": "def word_square(ls: str) -> bool:\n\"\"\"A [Word Square](https://en.wikipedia.org/wiki/Word_square) is a set of words written out in a square grid, such that the same words can be read both horizontally and vertically. The number of words, equal to the number of letters in each word, is known as the *order* of the square.\n\nFor example, this is an *order* `5` square found in the ruins of Herculaneum:\n\n![](https://i.gyazo.com/e226262e3ada421d4323369fb6cf66a6.jpg)\n\nGiven a string of various uppercase `letters`, check whether a *Word Square* can be formed from it. \n\nNote that you should use each letter from `letters` the exact number of times it occurs in the string. If a *Word Square* can be formed, return `true`, otherwise return `false`.\n\n__Example__\n\n  * For `letters = \"SATORAREPOTENETOPERAROTAS\"`, the output should be\n  `WordSquare(letters) = true`.\n    It is possible to form a *word square* in the example above.\n\n  * For `letters = \"AAAAEEEENOOOOPPRRRRSSTTTT\"`, (which is sorted form of `\"SATORAREPOTENETOPERAROTAS\"`), the output should also be\n  `WordSquare(letters) = true`.\n\n  * For `letters = \"NOTSQUARE\"`, the output should be\n  `WordSquare(letters) = false`.\n  \n__Input/Output__\n\n* [input] string letters\n\n  A string of uppercase English letters.\n  \n  Constraints: `3 ≤ letters.length ≤ 100`.\n\n\n* [output] boolean\n\n  `true`, if a Word Square can be formed;\n  \n  `false`, if a Word Square cannot be formed.\n\"\"\"", "inputs": [["SATORAREPOTENETOPERAROTAS"], ["NOTSQUARE"], ["BITICETEN"], ["CARDAREAREARDART"], ["CODEWARS"], ["AAAAACEEELLRRRTT"], ["AAACCEEEEHHHMMTT"], ["AAACCEEEEHHHMMTTXXX"], ["ABCD"], ["GHBEAEFGCIIDFHGG"], ["AAHHFDKIHHFCXZBFDERRRTXXAA"], ["AABBCCDDEEFFGGGG"], ["ABCABCABC"], ["FRACTUREOUTLINEDBLOOMINGSEPTETTE"], ["GLASSESRELAPSEIMITATESMEAREDTANNERY"], ["LIMBAREACORKKNEE"], ["DESCENDANTECHENEIDAESHORTCOATSCERBERULUSENTEROMERENECROLATERDIOUMABANAADALETABATNATURENAMETESSERATED"], ["CONGRATUALATIONS"], ["HEARTEMBERABUSERESINTREND"], ["OHLOLWHAT"]], "outputs": [[true], [false], [true], [true], [false], [true], [true], [false], [false], [true], [false], [true], [true], [false], [false], [false], [true], [false], [true], [true]], "starter_code": "def word_square(ls: str) -> bool:", "canonical_solution": "from collections import Counter\n\ndef word_square(ls):\n    n = int(len(ls) ** 0.5)\n    return n * n == len(ls) and sum((i % 2 for i in list(Counter(ls).values()))) <= n", "entry_point": "word_square", "task_id": "TACO_lite/352", "input_output_examples": "[[['SATORAREPOTENETOPERAROTAS'], ['AAAAEEEENOOOOPPRRRRSSTTTT'], ['NOTSQUARE']], [[True], [True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[['SATORAREPOTENETOPERAROTAS'], ['AAAAEEEENOOOOPPRRRRSSTTTT'], ['NOTSQUARE'], ['AAAABBBB'], ['ABCDEFGH'], ['AABBC'], ['AAAA'], ['ABAB'], ['ABCD'], ['A'], ['AA'], ['AAA'], ['ABCDEF'], ['AABBCC'], ['AABBCD'], ['AAAAA'], ['ABCABC'], ['XYZXYZ'], ['XXYYZZ'], ['XXYYZZA']]", "qwen2.5-coder-32b-instruct": "[['SATORAREPOTENETOPERAROTAS'], ['AAAAEEEENOOOOPPRRRRSSTTTT'], ['NOTSQUARE'], ['AABBCC'], ['AAABBBCCC'], ['A'], ['AB'], ['AAA'], ['ABCDEF'], ['AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYZ'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZ'], ['AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA']]"}}
{"requirement": "def black_or_white_key(key_press_count: int) -> str:\n\"\"\"## Your Story\n\"A *piano* in the home meant something.\" - *Fried Green Tomatoes at the Whistle Stop Cafe*\n\nYou've just realized a childhood dream by getting a beautiful and beautiful-sounding upright piano from a friend who was leaving the country. You immediately started doing things like playing \"Heart and Soul\" over and over again, using one finger to pick out any melody that came into your head, requesting some sheet music books from the library, signing up for some MOOCs like Developing Your Musicianship, and wondering if you will think of any good ideas for writing piano-related katas and apps. \n\nNow you're doing an exercise where you play the very first (leftmost, lowest in pitch) key on the 88-key keyboard, which (as shown below) is white, with the little finger on your left hand, then the second key, which is black, with the ring finger on your left hand, then the third key, which is white, with the middle finger on your left hand, then the fourth key, also white, with your left index finger, and then the fifth key, which is black, with your left thumb. Then you play the sixth key, which is white, with your right thumb, and continue on playing the seventh, eighth, ninth, and tenth keys with the other four fingers of your right hand. Then for the eleventh key you go back to your left little finger, and so on. Once you get to the rightmost/highest, 88th, key, you start all over again with your left little finger on the first key. Your thought is that this will help you to learn to move smoothly and with uniform pressure on the keys from each finger to the next and back and forth between hands.\n\n\n\nYou're not saying the names of the notes while you're doing this, but instead just counting each key press out loud (not starting again at 1 after 88, but continuing on to 89 and so forth) to try to keep a steady rhythm going and to see how far you can get before messing up. You move gracefully and with flourishes, and between screwups you hear, see, and feel that you are part of some great repeating progression between low and high notes and black and white keys. \n\n## Your Function\nThe function you are going to write is not actually going to help you with your piano playing, but just explore one of the patterns you're experiencing: Given the number you stopped on, was it on a black key or a white key? For example, in the description of your piano exercise above, if you stopped at 5, your left thumb would be on the fifth key of the piano, which is black. Or if you stopped at 92, you would have gone all the way from keys 1 to 88 and then wrapped around, so that you would be on the fourth key, which is white.\n\nYour function will receive an integer between 1 and 10000 (maybe you think that in principle it would be cool to count up to, say, a billion, but considering how many years it would take it is just not possible) and return the string \"black\" or \"white\" -- here are a few more examples:\n```\n1     \"white\"\n12    \"black\"\n42    \"white\"\n100   \"black\"\n2017  \"white\"\n```\nHave fun! And if you enjoy this kata, check out the sequel: Piano Kata, Part 2\n\"\"\"", "inputs": [[1], [5], [12], [42], [88], [89], [92], [100], [111], [200], [2017]], "outputs": [["white"], ["black"], ["black"], ["white"], ["white"], ["white"], ["white"], ["black"], ["white"], ["black"], ["white"]], "starter_code": "def black_or_white_key(key_press_count: int) -> str:", "canonical_solution": "def black_or_white_key(key_press_count):\n    return 'black' if (key_press_count - 1) % 88 % 12 in [1, 4, 6, 9, 11] else 'white'", "entry_point": "black_or_white_key", "task_id": "TACO_lite/357", "input_output_examples": "[[[1], [12], [42], [100], [2017]], [['white'], ['black'], ['white'], ['black'], ['white']]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [5], [12], [42], [88], [89], [100], [2017], [10000], [176], [177], [200], [5000], [9999], [10001]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [42], [88], [89], [100], [2017], [10000], [8800], [8801]]"}}
{"requirement": "from typing import List\n\n\ndef crashing_weights(weights: List[List[int]]) -> List[int]:\n\"\"\"You are stacking some boxes containing gold weights on top of each other. If a box contains more weight than the box below it, it will crash downwards and combine their weights. e.g. If we stack [2] on top of [1], it will crash downwards and become a single box of weight [3]\n```\n[2]\n[1] --> [3]\n```\nGiven an array of arrays, return the bottom row (i.e. the last array) after all crashings are complete.\n```\ncrashing_weights([[1, 2, 3],  --> [[1, 2,  ],      [[1,  ,  ]],\n                  [2, 3, 1],  -->  [2, 3, 4],  -->  [2, 2,  ],\n                  [3, 1, 2]])      [3, 1, 2]]  -->  [3, 4, 6]]\n\ntherefore return [3, 4, 6]\n```\n\n## More details\n\nboxes can be stacked to any height, and the crashing effect can snowball:\n```\n[3]\n[2]     [5]\n[4] --> [4] --> [9]\n```\nCrashing should always start from as high up as possible -- this can alter the outcome! e.g.\n```\n[3]                      [3]\n[2]     [5]              [2]     [3]\n[1] --> [1] --> [6], not [1] --> [3] \n```\nWeights will always be integers. The matrix (array of arrays) may have any height or width > 1, and may not be square, but it will always be \"nice\" (all rows will have the same number of columns, etc).\n\"\"\"", "inputs": [[[[1]]], [[[1, 2]]], [[[2], [1]]]], "outputs": [[[1]], [[1, 2]], [[3]]], "starter_code": "from typing import List\ndef crashing_weights(weights: List[List[int]]) -> List[int]:", "canonical_solution": "from functools import reduce\n\ndef crashing_weights(weights):\n    return reduce(lambda a, b: [a1 + b1 if a1 > b1 else b1 for a1, b1 in zip(a, b)], weights)", "entry_point": "crashing_weights", "task_id": "TACO_lite/362", "input_output_examples": "[[[[[1, 2, 3], [2, 3, 1], [3, 1, 2]]]], [[[3, 4, 6]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[[1, 2, 3], [2, 3, 1], [3, 1, 2]]], [[[3], [2], [1]]], [[[4, 5], [2, 3]]], [[[1], [2], [3], [4], [5]]], [[[10, 20], [5, 10]]], [[[7, 8, 9], [6, 7, 8], [5, 6, 7]]], [[[1, 1, 1], [1, 1, 1], [1, 1, 1]]], [[[9, 8, 7], [6, 5, 4], [3, 2, 1]]], [[[2, 3], [1, 2], [3, 1]]], [[[100], [200], [300]]]]", "qwen2.5-coder-32b-instruct": "[[[[1, 2, 3], [2, 3, 1], [3, 1, 2]]], [[[3], [2], [1]]], [[[1, 2], [2, 1]]], [[[1, 2, 3, 4], [4, 3, 2, 1], [1, 2, 3, 4]]], [[[5, 5, 5], [5, 5, 5], [5, 5, 5]]], [[[10, 20, 30], [5, 5, 5]]], [[[1], [1], [1], [1]]], [[[100, 200], [50, 50], [25, 25]]], [[[1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3]]], [[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]]]"}}
{"requirement": "def validate_ean(code: str) -> bool:\n\"\"\"A lot of goods have an  International Article Number (formerly known as \"European Article Number\") abbreviated \"EAN\". EAN is a 13-digits barcode consisting of 12-digits data followed by a single-digit checksum (EAN-8 is not considered in this kata).\n\n\nThe single-digit checksum is calculated as followed (based upon the 12-digit data):\n\nThe digit at the first, third, fifth, etc. position (i.e. at the odd position) has to be multiplied with \"1\". \nThe digit at the second, fourth, sixth, etc. position (i.e. at the even position) has to be multiplied with \"3\".\nSum these results. \n\nIf this sum is dividable by 10, the checksum is 0. Otherwise the checksum has the following formula:\n\n  checksum = 10 - (sum mod 10)\n\nFor example, calculate the checksum for \"400330101839\" (= 12-digits data):\n\n4·1 + 0·3 + 0·1 + 3·3 + 3·1 + 0·3 + 1·1 + 0·3 + 1·1 + 8·3 + 3·1 + 9·3\n= 4 + 0 + 0 + 9 + 3 + 0 + 1 + 0 + 1 + 24 + 3 + 27 \n= 72\n10 - (72 mod 10) = 8 ⇒ Checksum: 8\n\nThus, the EAN-Code is 4003301018398 (= 12-digits data followed by single-digit checksum).\n \nYour Task\nValidate a given EAN-Code. Return true if the given EAN-Code is valid, otherwise false.\n\nAssumption\nYou can assume the given code is syntactically valid, i.e. it only consists of numbers and it exactly has a length of 13 characters.\n\nExamples\n\n```python\nvalidate_ean(\"4003301018398\") # => True\nvalidate_ean(\"4003301018392\") # => False\n```\n\nGood Luck and have fun.\n\"\"\"", "inputs": [["9783815820865"], ["9783815820864"], ["9783827317100"]], "outputs": [[true], [false], [true]], "starter_code": "def validate_ean(code: str) -> bool:", "canonical_solution": "validate_ean = lambda code: (sum(map(int, code[0::2])) + sum(map(int, code[1::2])) * 3) % 10 == 0", "entry_point": "validate_ean", "task_id": "TACO_lite/377", "input_output_examples": "[[['4003301018398'], ['4003301018392']], [[True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[['4003301018398'], ['4003301018392'], ['1234567890128'], ['1234567890123'], ['0000000000000'], ['9999999999993'], ['1111111111116'], ['2222222222224'], ['0123456789012'], ['0123456789018']]", "qwen2.5-coder-32b-instruct": "[['4003301018398'], ['4003301018392'], ['0000000000000'], ['9780201310054'], ['1234567890128'], ['1234567890123'], ['1111111111113'], ['2222222222224'], ['3333333333335'], ['4444444444446'], ['5555555555557'], ['6666666666668'], ['7777777777779'], ['8888888888880'], ['9999999999991']]"}}
{"requirement": "def is_kiss(words: str) -> str:\n\"\"\"KISS stands for Keep It Simple Stupid.\nIt is a design principle for keeping things simple rather than complex.\n\nYou are the boss of Joe.\n\nJoe is submitting words to you to publish to a blog. He likes to complicate things.\n\nDefine a function that determines if Joe's work is simple or complex.\n\nInput will be non emtpy strings with no punctuation.\n\nIt is simple if:\n``` the length of each word does not exceed the amount of words in the string ```\n(See example test cases)\n\nOtherwise it is complex.\n\nIf complex:\n```python\nreturn \"Keep It Simple Stupid\"\n```\nor if it was kept simple:\n```python\nreturn \"Good work Joe!\"\n```\n\nNote: Random test are random and nonsensical. Here is a silly example of a random test:\n```python\n\"jump always mostly is touchy dancing choice is pineapples mostly\"\n```\n\"\"\"", "inputs": [["Joe had a bad day"], ["Joe had some bad days"], ["Joe is having no fun"], ["Sometimes joe cries for hours"], ["Joe is having lots of fun"], ["Joe is working hard a lot"], ["Joe listened to the noise and it was an onamonapia"], ["Joe listened to the noises and there were some onamonapias"]], "outputs": [["Good work Joe!"], ["Good work Joe!"], ["Keep It Simple Stupid"], ["Keep It Simple Stupid"], ["Good work Joe!"], ["Keep It Simple Stupid"], ["Good work Joe!"], ["Keep It Simple Stupid"]], "starter_code": "def is_kiss(words: str) -> str:", "canonical_solution": "def is_kiss(words):\n    wordsL = words.split(' ')\n    l = len(wordsL)\n    for word in wordsL:\n        if len(word) > l:\n            return 'Keep It Simple Stupid'\n    return 'Good work Joe!'", "entry_point": "is_kiss", "task_id": "TACO_lite/378", "input_output_examples": "[[['Joe likes to complicate things a lot'], ['Simpler is better']], [['Keep It Simple Stupid'], ['Good work Joe!']]]", "llm_generated_inputs": {"deepseek-v3": "[['hello world'], ['this is a simple test'], ['keep it simple stupid'], ['a'], ['longword short'], ['jump always mostly is touchy dancing choice is pineapples mostly'], ['one'], ['two words'], ['three word test'], ['this string has more words than the length of each individual word'], ['supercalifragilisticexpialidocious'], ['a b c d e f g h i j k l m n o p q r s t u v w x y z']]", "qwen2.5-coder-32b-instruct": "[['jump'], ['jump always'], ['jump always mostly'], ['jump always mostly is'], ['jump always mostly is touchy'], ['jump always mostly is touchy dancing'], ['jump always mostly is touchy dancing choice'], ['jump always mostly is touchy dancing choice is'], ['jump always mostly is touchy dancing choice is pineapples'], ['jump always mostly is touchy dancing choice is pineapples mostly'], ['a'], ['ab cd'], ['abc def ghi'], ['abcd efgh ijkl mnop'], ['a b c d e f g h i j k l m n o p q r s t u v w x y z'], ['one two three four five six seven eight nine ten eleven'], ['simple'], ['simple words'], ['these are some simplewords'], ['this is a verylongwordthatwillmakethiscomplex']]"}}
{"requirement": "from typing import List\n\n\ndef reverse_invert(lst: List[int]) -> List[int]:\n\"\"\"Reverse and invert all integer values in a given list. \n\nPython:\n\n    reverse_invert([1,12,'a',3.4,87,99.9,-42,50,5.6]) = [-1,-21,-78,24,-5]\n    \nIgnore all other types than integer.\n\"\"\"", "inputs": [[[1, 2, 3, 4, 5]], [[-10]], [[-9, -18, 99]], [[1, 12, "a", 3.4, 87, 99.9, -42, 50, 5.6]], [[]]], "outputs": [[[-1, -2, -3, -4, -5]], [[1]], [[9, 81, -99]], [[-1, -21, -78, 24, -5]], [[]]], "starter_code": "from typing import List\ndef reverse_invert(lst: List[int]) -> List[int]:", "canonical_solution": "from math import copysign as sign\n\ndef reverse_invert(lst):\n    return [-int(sign(int(str(abs(x))[::-1]), x)) for x in lst if isinstance(x, int)]", "entry_point": "reverse_invert", "task_id": "TACO_lite/384", "input_output_examples": "[[[[1, 12, 'a', 3.4, 87, 99.9, -42, 50, 5.6]]], [[[-1, -21, -78, 24, -5]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 12, 'a', 3.4, 87, 99.9, -42, 50, 5.6]], [[123, -456, 789]], [[0, 0, 100, -100]], [[10, -20, 30, -40, 50]], [[]], [['abc', 12.34, True, False, None]], [[1000000, -999999, 123456789]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[-1, -2, -3, -4, -5]], [[1, '1', 2, '2', 3, '3']]]", "qwen2.5-coder-32b-instruct": "[[[1, 12, 'a', 3.4, 87, 99.9, -42, 50, 5.6]], [[1, 2, 3, 4, 5]], [[-1, -2, -3, -4, -5]], [[0, 100, 200, 300]], [[0, -100, 200, -300]], [[]], [[10, 'string', 20.5, None, True, False, {}, [], ()]], [[111, 222, 333]], [[-111, -222, -333]]]"}}
{"requirement": "from typing import List\n\n\ndef race(v1: int, v2: int, g: int) -> List[int]:\n\"\"\"Two tortoises named ***A*** and ***B*** must run a race. ***A*** starts with an average speed of ```720 feet per hour```.\nYoung ***B*** knows she runs faster than ***A***, and furthermore has not finished her cabbage.\n\nWhen she starts, at last, she can see that ***A*** has a `70 feet lead` but ***B***'s speed is `850 feet per hour`.\nHow long will it take ***B*** to catch ***A***?\n\nMore generally:\ngiven two speeds `v1` (***A***'s speed, integer > 0) and `v2` (***B***'s speed, integer > 0) and a lead `g` (integer > 0)\nhow long will it take ***B*** to catch ***A***? \n\nThe result will be an array ```[hour, min, sec]``` which is the time needed in hours, minutes and seconds (round down to the nearest second)\nor a string in some languages.\n\nIf `v1 >= v2` then return `nil`, `nothing`, `null`, `None` or `{-1, -1, -1}` for C++, C, Go, Nim, `[]` for Kotlin or \"-1 -1 -1\".\n\n## Examples:\n(form of the result depends on the language)\n```\nrace(720, 850, 70) => [0, 32, 18] or \"0 32 18\"\nrace(80, 91, 37)   => [3, 21, 49] or \"3 21 49\"\n```\n\n** Note: \n\n- See other examples in \"Your test cases\".\n\n- In Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.\n\n** Hints for people who don't know how to convert to hours, minutes, seconds:\n\n- Tortoises don't care about fractions of seconds\n\n- Think of calculation by hand using only integers (in your code use or simulate integer division)\n\n- or Google: \"convert decimal time to hours minutes seconds\"\n\"\"\"", "inputs": [[720, 850, 70], [80, 91, 37], [80, 100, 40], [720, 850, 37], [720, 850, 370], [120, 850, 37], [820, 850, 550], [820, 81, 550]], "outputs": [[[0, 32, 18]], [[3, 21, 49]], [[2, 0, 0]], [[0, 17, 4]], [[2, 50, 46]], [[0, 3, 2]], [[18, 20, 0]], [null]], "starter_code": "from typing import List\ndef race(v1: int, v2: int, g: int) -> List[int]:", "canonical_solution": "import math\n\ndef race(v1, v2, g):\n    if v2 < v1:\n        return None\n    seconds = 0.1\n    while v1 / 3600 * seconds + g >= v2 / 3600 * seconds:\n        seconds += 0.05\n    hours = seconds / 3600\n    hoursRest = seconds % 3600\n    minutes = hoursRest / 60\n    seconds = hoursRest % 60\n    return [math.floor(hours), math.floor(minutes), math.floor(seconds)]", "entry_point": "race", "task_id": "TACO_lite/390", "input_output_examples": "[[[720, 850, 70], [80, 91, 37]], [[[0, 32, 18]], [[3, 21, 49]]]]", "llm_generated_inputs": {"deepseek-v3": "[[720, 850, 70], [80, 91, 37], [100, 100, 50], [500, 1000, 200], [10, 20, 5], [100, 200, 50], [300, 400, 100], [50, 100, 25], [1000, 2000, 500], [720, 720, 70], [0, 850, 70], [720, 0, 70], [720, 850, 0], [-720, 850, 70], [720, -850, 70], [720, 850, -70]]", "qwen2.5-coder-32b-instruct": "[[720, 850, 70], [80, 91, 37], [100, 100, 10], [100, 90, 10], [1, 2, 1], [1000, 2000, 500], [50, 100, 1], [500, 1000, 100], [10, 20, 5]]"}}
{"requirement": "def starting_mark(height: float) -> float:\n\"\"\"For a pole vaulter, it is very important to begin the approach run at the best possible starting mark. This is affected by numerous factors and requires fine-tuning in practice. But there is a guideline that will help a beginning vaulter start at approximately the right location for the so-called \"three-step approach,\" based on the vaulter's body height.\n\nThis guideline was taught to me in feet and inches, but due to the international nature of Codewars, I am creating this kata to use metric units instead.\n\nYou are given the following two guidelines to begin with:\n(1) A vaulter with a height of 1.52 meters should start at 9.45 meters on the runway.\n(2) A vaulter with a height of 1.83 meters should start at 10.67 meters on the runway.\n\nYou will receive a vaulter's height in meters (which will always lie in a range between a minimum of 1.22 meters and a maximum of 2.13 meters). Your job is to return the best starting mark in meters, rounded to two decimal places.\n\nHint: Based on the two guidelines given above, you will want to account for the change in starting mark per change in body height. This involves a linear relationship. But there is also a constant offset involved. If you can determine the rate of change described above, you should be able to determine that constant offset.\n\"\"\"", "inputs": [[1.52], [1.83], [1.22], [2.13], [1.75]], "outputs": [[9.45], [10.67], [8.27], [11.85], [10.36]], "starter_code": "def starting_mark(height: float) -> float:", "canonical_solution": "def starting_mark(height):\n    return round(9.45 + (10.67 - 9.45) / (1.83 - 1.52) * (height - 1.52), 2)", "entry_point": "starting_mark", "task_id": "TACO_lite/392", "input_output_examples": "[[[1.52], [1.83]], [[9.45], [10.67]]]", "llm_generated_inputs": {"deepseek-v3": "[[1.52], [1.83], [1.22], [2.13], [1.6], [1.75], [1.9]]", "qwen2.5-coder-32b-instruct": "[[1.52], [1.83], [1.22], [2.13], [1.67], [1.75], [1.9], [2.0]]"}}
{"requirement": "def special_number(n: int) -> str:\n\"\"\"# Definition \n\nA number is a **_Special Number_** *if it’s digits only consist 0, 1, 2, 3, 4 or 5*\n\n**_Given_** a number *determine if it special number or not* .  \n\n\n\n# Warm-up (Highly recommended)\n\n# [Playing With Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n___\n\n# Notes \n\n* **_The number_** passed will be **_positive_** (N > 0) .\n\n* All **single-digit numbers** with in the interval **_[0:5]_** are considered as **_special number_**. \n___\n\n# Input >> Output Examples\n\n```\nspecialNumber(2) ==> return \"Special!!\"\n```\n## Explanation: \n\nIt's **_a single-digit number_** within the interval **_[0:5]_** . \n\n```\nspecialNumber(9) ==> return \"NOT!!\"\n```\n## Explanation:\n\nAlthough, it's a single-digit number but **_Outside the interval [0:5]_** .\n\n```\nspecialNumber(23) ==> return \"Special!!\"\n```\n## Explanation: \n\nAll **_the number's digits_** formed from the interval **_[0:5]_** digits .\n\n\n\n```\nspecialNumber(39) ==> return \"NOT!!\"\n```\n## Explanation: \n\nAlthough, *there is a digit (3) Within the interval* **_But_** **_the second digit is not (Must be ALL The Number's Digits )_** .\n\n```\nspecialNumber(59) ==> return \"NOT!!\"\n```\n## Explanation:  \n\nAlthough, *there is a digit (5) Within the interval* **_But_** **_the second digit is not (Must be ALL The Number's Digits )_** .\n\n```\nspecialNumber(513) ==> return \"Special!!\"\n```\n___\n```\nspecialNumber(709) ==> return \"NOT!!\"\n```\n___\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)          \n\n### ALL translation are welcomed\n\n## Enjoy Learning !!\n# Zizou\n\"\"\"", "inputs": [[2], [3], [5], [9], [7], [23], [79], [32], [39], [55], [11350224]], "outputs": [["Special!!"], ["Special!!"], ["Special!!"], ["NOT!!"], ["NOT!!"], ["Special!!"], ["NOT!!"], ["Special!!"], ["NOT!!"], ["Special!!"], ["Special!!"]], "starter_code": "def special_number(n: int) -> str:", "canonical_solution": "def special_number(n):\n    return 'Special!!' if max(str(n)) <= '5' else 'NOT!!'", "entry_point": "special_number", "task_id": "TACO_lite/395", "input_output_examples": "[[[2], [9], [23], [39], [59], [513], [709]], [['Special!!'], ['NOT!!'], ['Special!!'], ['NOT!!'], ['NOT!!'], ['Special!!'], ['NOT!!']]]", "llm_generated_inputs": {"deepseek-v3": "[[2], [9], [23], [39], [59], [513], [709], [0], [5], [10], [55], [12345], [67890], [11111], [22222], [33333], [44444], [55555], [123456], [123450]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [2], [3], [4], [5], [6], [7], [8], [9], [23], [39], [59], [513], [709], [0], [12345], [543210], [11111], [22222], [33333], [44444], [55555], [501234], [102030405], [1122334455], [5555555555], [9876543210]]"}}
{"requirement": "def is_letter(s: str) -> bool:\n\"\"\"Complete the code which should return `true` if the given object is a single ASCII letter (lower or upper case), `false` otherwise.\n\"\"\"", "inputs": [[""], ["a"], ["X"], ["7"], ["_"], ["ab"], ["a\n"]], "outputs": [[false], [true], [true], [false], [false], [false], [false]], "starter_code": "def is_letter(s: str) -> bool:", "canonical_solution": "def is_letter(s):\n    return len(s) == 1 and s.isalpha()", "entry_point": "is_letter", "task_id": "TACO_lite/401", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['a'], ['Z'], ['1'], ['@'], ['ab'], [''], [' '], ['A'], ['z'], ['$'], ['aa'], ['0'], ['9'], ['!'], ['\\n'], ['\\t'], ['é'], ['ß'], ['π'], ['𐍈']]", "qwen2.5-coder-32b-instruct": "[['a'], ['Z'], ['1'], [' '], ['!'], ['ab'], [''], ['abc'], ['\\n'], ['\\t']]"}}
{"requirement": "from typing import List\n\n\ndef well(x: List[str]) -> str:\n\"\"\"For every good kata idea there seem to be quite a few bad ones!\n\nIn this kata you need to check the provided array (x) for good ideas 'good' and bad ideas 'bad'. If there are one or two good ideas, return 'Publish!', if there are more than 2 return 'I smell a series!'. If there are no good ideas, as is often the case, return 'Fail!'.\n\n~~~if:c\nFor C: do not dynamically allocate memory,\n      instead return a string literal\n~~~\n\"\"\"", "inputs": [[["bad", "bad", "bad"]], [["good", "bad", "bad", "bad", "bad"]], [["good", "bad", "bad", "bad", "bad", "good", "bad", "bad", "good"]]], "outputs": [["Fail!"], ["Publish!"], ["I smell a series!"]], "starter_code": "from typing import List\ndef well(x: List[str]) -> str:", "canonical_solution": "def well(x):\n    c = x.count('good')\n    return 'I smell a series!' if c > 2 else 'Publish!' if c else 'Fail!'", "entry_point": "well", "task_id": "TACO_lite/403", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[['bad', 'bad', 'bad']], [['good', 'bad', 'bad']], [['good', 'good', 'bad']], [['good', 'good', 'good']], [[]], [['good']], [['good', 'good']], [['good', 'good', 'good', 'good']], [['bad', 'good', 'bad', 'good', 'bad']], [['bad', 'bad', 'good', 'bad', 'good', 'good']]]", "qwen2.5-coder-32b-instruct": "[[['good', 'bad', 'bad', 'good', 'bad']], [['good', 'good']], [['good']], [['bad', 'bad', 'bad']], [[]], [['bad', 'good', 'bad', 'good']], [['bad', 'bad', 'good', 'good', 'good']]]"}}
{"requirement": "from typing import List\n\n\ndef solution(a: List[int]) -> int:\n\"\"\"## Description\n\nGiven an array X of positive integers, its elements are to be transformed by running the following operation on them as many times as required:\n\n```if X[i] > X[j] then X[i] = X[i] - X[j]```\n\nWhen no more transformations are possible, return its sum (\"smallest possible sum\").\n\nFor instance, the successive transformation of the elements of input X = [6, 9, 21] is detailed below:\n```\nX_1 = [6, 9, 12] # -> X_1[2] = X[2] - X[1] = 21 - 9\nX_2 = [6, 9, 6]  # -> X_2[2] = X_1[2] - X_1[0] = 12 - 6\nX_3 = [6, 3, 6]  # -> X_3[1] = X_2[1] - X_2[0] = 9 - 6\nX_4 = [6, 3, 3]  # -> X_4[2] = X_3[2] - X_3[1] = 6 - 3\nX_5 = [3, 3, 3]  # -> X_5[1] = X_4[0] - X_4[1] = 6 - 3\n```\nThe returning output is the sum of the final transformation (here 9).\n\n## Example\n\n## Solution steps:\n\n## Additional notes:\n\nThere are performance tests consisted of very big numbers and arrays of size at least 30000. Please write an efficient algorithm to prevent timeout.\n\"\"\"", "inputs": [[[6, 9, 21]], [[9]], [[30, 12]], [[11, 22]], [[1, 21, 55]], [[4, 16, 24]], [[3, 13, 23, 7, 83]], [[60, 12, 96, 48, 60, 24, 72, 36, 72, 72, 48]], [[71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71]]], "outputs": [[9], [9], [12], [22], [3], [12], [5], [132], [923]], "starter_code": "from typing import List\ndef solution(a: List[int]) -> int:", "canonical_solution": "def solution(a):\n    a_len = len(a)\n    a = set(a)\n    while len(a) != 1:\n        b = max(a)\n        a.remove(b)\n        a.add(b - max(a))\n    return max(a) * a_len", "entry_point": "solution", "task_id": "TACO_lite/408", "input_output_examples": "[[[[6, 9, 21]]], [[9]]]", "llm_generated_inputs": {"deepseek-v3": "[[[6, 9, 21]], [[1, 1, 1]], [[10, 20, 30]], [[2, 4, 8]], [[3, 6, 9]], [[1]], [[100, 200, 300, 400]], [[7, 14, 21, 28]], [[5, 10, 15, 20, 25]], [[2, 3, 5, 7, 11]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[1000000000, 2000000000]], [[17, 34, 51, 68, 85]], [[999999999, 999999999, 999999999]], [[123456789, 987654321]]]", "qwen2.5-coder-32b-instruct": "[[[6, 9, 21]], [[1, 2, 3, 4, 5]], [[10, 10, 10, 10]], [[100, 200, 300]], [[1]], [[1000000, 1000000, 1000000]], [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], [[7, 14, 28, 56]], [[3, 6, 9, 12, 15]], [[5, 10, 15, 20, 25, 30]]]"}}
{"requirement": "def get_last_digit(index: int) -> int:\n\"\"\"As you probably know, Fibonacci sequence are the numbers in the following integer sequence:\n1, 1, 2, 3, 5, 8, 13...\nWrite a method that takes the index as an argument and returns last digit from fibonacci number. Example:\n\n\n  getLastDigit(15) - 610. Your method must return 0 because the last digit of 610 is 0.\nFibonacci sequence grows very fast and value can take very big numbers (bigger than integer type can contain), so, please, be careful with overflow.\n\n[Hardcore version of this kata](http://www.codewars.com/kata/find-last-fibonacci-digit-hardcore-version), no bruteforce will work here ;)\n\"\"\"", "inputs": [[193150], [300], [20001], [800], [1001], [100], [260], [1111], [1234], [99999], [10], [234], [193241], [79], [270]], "outputs": [[5], [0], [6], [5], [1], [5], [5], [9], [7], [6], [5], [2], [1], [1], [0]], "starter_code": "def get_last_digit(index: int) -> int:", "canonical_solution": "def get_last_digit(index):\n    a, b = (0, 1)\n    for _ in range(index):\n        a, b = (b, (a + b) % 10)\n    return a", "entry_point": "get_last_digit", "task_id": "TACO_lite/413", "input_output_examples": "[[[15]], [[0]]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [2], [5], [10], [15], [20], [50], [100]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [2], [3], [4], [5], [10], [15], [20], [50], [100], [1000], [10000], [-1], [-5]]"}}
{"requirement": "def pre_fizz(n: int) -> list:\n\"\"\"This is the first step to understanding FizzBuzz.  \n\nYour inputs:\na positive integer, n, greater than or equal to one.\nn is provided, you have NO CONTROL over its value.\n\nYour expected output is an array of positive integers from 1 to n (inclusive).\n\nYour job is to write an algorithm that gets you from the input to the output.\n\"\"\"", "inputs": [[1], [2], [3], [4], [5]], "outputs": [[[1]], [[1, 2]], [[1, 2, 3]], [[1, 2, 3, 4]], [[1, 2, 3, 4, 5]]], "starter_code": "def pre_fizz(n: int) -> list:", "canonical_solution": "def pre_fizz(n):\n    return list(range(1, n + 1))", "entry_point": "pre_fizz", "task_id": "TACO_lite/415", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [5], [10], [100]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [5], [10], [20], [100]]"}}
{"requirement": "from typing import List\nfrom typing import Dict\nfrom typing import Tuple\n\n\ndef optimum_location(students: List[Tuple[int, int]], locations: List[Dict[str, int]]) -> str:\n\"\"\"### Preface\nYou are currently working together with a local community to build a school teaching children how to code. First plans have been made and the community wants to decide on the best location for the coding school.\nIn order to make this decision data about the location of students and potential locations is collected. \n\n### Problem\nIn order to be able to attract and teach as many students as possible we want to minimize the total traveling distance for potential students. The streets system is organized in a traditional grid system and students can only travel horizontally or vertically (not diagonal).\n\nThe locations of interested students is given as an array with the first value of each entry presenting the x coordinate and the second value presenting the y coordinate:\n```python\nstudents = [[3,7],[2,2],[14,1], ...];\n```\nPotential locations are passed as an array of objects with an unique id, a x and y coordinate:\n```python\nlocations = [{\"id\": 1, \"x\": 3, \"y\": 4}, {\"id\": 2, \"x\": 8, \"y\": 2}, ...];\n```\n\nYour task is now to evaluate which of the school locations would be best to minimize the distance for all potential students to the school.\n\nThe desired output should consist of a string indicating the ID of the best suitable location and the x and y coordinates in the following form:\n\n```\n\"The best location is number 1 with the coordinates x = 3 and y = 4\"\n```\n\"\"\"", "inputs": [[[[3, 7], [2, 2], [14, 1]], [{"id": 1, "x": 3, "y": 4}, {"id": 2, "x": 8, "y": 2}]], [[[54, 7], [1, 211], [14, 44], [12, 5], [14, 7]], [{"id": 1, "x": 44, "y": 55}, {"id": 2, "x": 12, "y": 57}, {"id": 3, "x": 23, "y": 66}]], [[[152, 7], [1, 211], [14, 56], [12, 4], [142, 7]], [{"id": 1, "x": 63, "y": 55}, {"id": 2, "x": 55, "y": 21}, {"id": 3, "x": 144, "y": 12}]], [[[152, 742], [466, 2211], [1412, 564], [142, 444], [142, 744]], [{"id": 1, "x": 1263, "y": 525}, {"id": 2, "x": 55, "y": 21}, {"id": 3, "x": 537, "y": 1244}]], [[[7, 66], [71, 7], [0, 94], [16, 93], [33, 49], [49, 81], [17, 2], [95, 71], [32, 14], [31, 41], [92, 72], [12, 79]], [{"y": 38, "x": 32, "id": 1}, {"y": 49, "x": 73, "id": 2}, {"y": 85, "x": 50, "id": 3}, {"y": 2, "x": 79, "id": 4}, {"y": 20, "x": 44, "id": 5}, {"y": 56, "x": 17, "id": 6}, {"y": 43, "x": 26, "id": 7}, {"y": 61, "x": 89, "id": 8}, {"y": 18, "x": 15, "id": 9}, {"y": 34, "x": 41, "id": 10}, {"y": 27, "x": 99, "id": 11}]]], "outputs": [["The best location is number 1 with the coordinates x = 3 and y = 4"], ["The best location is number 2 with the coordinates x = 12 and y = 57"], ["The best location is number 2 with the coordinates x = 55 and y = 21"], ["The best location is number 3 with the coordinates x = 537 and y = 1244"], ["The best location is number 6 with the coordinates x = 17 and y = 56"]], "starter_code": "from typing import List\nfrom typing import Dict\nfrom typing import Tuple\ndef optimum_location(students: List[Tuple[int, int]], locations: List[Dict[str, int]]) -> str:", "canonical_solution": "def optimum_location(students, locations):\n    m = min(locations, key=lambda loc: sum((abs(loc['x'] - s[0]) + abs(loc['y'] - s[1]) for s in students)))\n    return 'The best location is number %d with the coordinates x = %d and y = %d' % (m['id'], m['x'], m['y'])", "entry_point": "optimum_location", "task_id": "TACO_lite/420", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[(3, 7), (2, 2), (14, 1)], [{'id': 1, 'x': 3, 'y': 4}, {'id': 2, 'x': 8, 'y': 2}]], [[(1, 1), (2, 2), (3, 3)], [{'id': 1, 'x': 2, 'y': 2}]], [[(0, 0)], [{'id': 1, 'x': 0, 'y': 0}, {'id': 2, 'x': 1, 'y': 1}]], [[(10, 10), (20, 20)], [{'id': 1, 'x': 15, 'y': 15}, {'id': 2, 'x': 10, 'y': 10}]], [[(5, 5), (5, 5)], [{'id': 1, 'x': 5, 'y': 5}, {'id': 2, 'x': 6, 'y': 6}]], [[(1, 2), (3, 4), (5, 6)], [{'id': 1, 'x': 3, 'y': 4}, {'id': 2, 'x': 1, 'y': 2}, {'id': 3, 'x': 5, 'y': 6}]], [[(0, 0), (0, 1), (0, 2)], [{'id': 1, 'x': 0, 'y': 1}, {'id': 2, 'x': 0, 'y': 0}]]]", "qwen2.5-coder-32b-instruct": "[[[[3, 7], [2, 2], [14, 1]], [{'id': 1, 'x': 3, 'y': 4}, {'id': 2, 'x': 8, 'y': 2}]], [[[1, 1], [1, 1], [1, 1]], [{'id': 1, 'x': 1, 'y': 1}]], [[[5, 5]], [{'id': 1, 'x': 5, 'y': 5}, {'id': 2, 'x': 6, 'y': 6}]], [[], [{'id': 1, 'x': 3, 'y': 4}]], [[[3, 7], [2, 2], [14, 1]], []], [[[0, 0], [10, 10]], [{'id': 1, 'x': 5, 'y': 5}]], [[[3, 7], [2, 2], [14, 1]], [{'id': 1, 'x': 3, 'y': 4}, {'id': 2, 'x': 8, 'y': 2}, {'id': 3, 'x': 10, 'y': 10}]]]"}}
{"requirement": "def select(memory: str) -> str:\n\"\"\"_A mad sociopath scientist just came out with a brilliant invention! He extracted his own memories to forget all the people he hates! Now there's a lot of information in there, so he needs your talent as a developer to automatize that task for him._\n\n> You are given the memories as a string containing people's surname and name (comma separated). The scientist marked one occurrence of each of the people he hates by putting a '!' right before their name.\n\n**Your task is to destroy all the occurrences of the marked people.\nOne more thing ! Hate is contagious, so you also need to erase any memory of the person that comes after any marked name!**\n\n---\nExamples\n---\n---\nInput:\n```\n\"Albert Einstein, !Sarah Connor, Marilyn Monroe, Abraham Lincoln, Sarah Connor, Sean Connery, Marilyn Monroe, Bjarne Stroustrup, Manson Marilyn, Monroe Mary\"\n```\nOutput:\n```\n\"Albert Einstein, Abraham Lincoln, Sean Connery, Bjarne Stroustrup, Manson Marilyn, Monroe Mary\"\n```\n=> We must remove every memories of Sarah Connor because she's marked, but as a side-effect we must also remove all the memories about Marilyn Monroe that comes right after her! Note that we can't destroy the memories of Manson Marilyn or Monroe Mary, so be careful!\n\"\"\"", "inputs": [["Bryan Joubert"], ["Jesse Cox, !Selena Gomez"], ["!Eleena Daru, Obi-Wan Kenobi, Eleena Daru, Jar-Jar Binks"], ["Digital Daggers, !Kiny Nimaj, Rack Istley, Digital Daggers, Digital Daggers"], ["Albert Einstein, !Sarah Connor, Marilyn Monroe, Abraham Lincoln, Sarah Connor, Sean Connery, Marilyn Monroe, Bjarne Stroustrup, Manson Marilyn, Monroe Mary"], ["!Partha Ashanti, !Mindaugas Burton, Stacy Thompson, Amor Hadrien, !Ahtahkakoop Sothy, Partha Ashanti, Uzi Griffin, Partha Ashanti, !Serhan Eutimio, Amor Hadrien, Noor Konstantin"], ["!Code Wars, !Doug Smith, !Cyril Lemaire, !Codin Game"]], "outputs": [["Bryan Joubert"], ["Jesse Cox"], ["Jar-Jar Binks"], ["Digital Daggers, Digital Daggers, Digital Daggers"], ["Albert Einstein, Abraham Lincoln, Sean Connery, Bjarne Stroustrup, Manson Marilyn, Monroe Mary"], ["Uzi Griffin, Noor Konstantin"], [""]], "starter_code": "def select(memory: str) -> str:", "canonical_solution": "def select(memory):\n    lst = memory.split(', ')\n    bad = {who.strip('!') for prev, who in zip([''] + lst, lst + ['']) if who.startswith('!') or prev.startswith('!')}\n    return ', '.join((who for who in map(lambda s: s.strip('!'), lst) if who not in bad))", "entry_point": "select", "task_id": "TACO_lite/423", "input_output_examples": "[[['Albert Einstein, !Sarah Connor, Marilyn Monroe, Abraham Lincoln, Sarah Connor, Sean Connery, Marilyn Monroe, Bjarne Stroustrup, Manson Marilyn, Monroe Mary']], [['Albert Einstein, Abraham Lincoln, Sean Connery, Bjarne Stroustrup, Manson Marilyn, Monroe Mary']]]", "llm_generated_inputs": {"deepseek-v3": "[['Albert Einstein, !Sarah Connor, Marilyn Monroe, Abraham Lincoln, Sarah Connor, Sean Connery, Marilyn Monroe, Bjarne Stroustrup, Manson Marilyn, Monroe Mary'], ['John Doe, !Jane Doe, Jane Doe, !Alice Smith, Bob Johnson, Alice Smith, Carol Williams'], ['!Alice Smith, Bob Johnson, Alice Smith, Carol Williams'], ['Alice Smith, Bob Johnson, !Carol Williams, David Brown'], ['!Alice Smith'], ['Alice Smith, !Bob Johnson, !Carol Williams, David Brown'], ['!Alice Smith, !Bob Johnson, Carol Williams, David Brown'], ['Alice Smith, Bob Johnson, Carol Williams, !David Brown'], ['!Alice Smith, Bob Johnson, Carol Williams, David Brown'], ['Alice Smith, Bob Johnson, Carol Williams, David Brown']]", "qwen2.5-coder-32b-instruct": "[['Albert Einstein, !Sarah Connor, Marilyn Monroe, Abraham Lincoln, Sarah Connor, Sean Connery, Marilyn Monroe, Bjarne Stroustrup, Manson Marilyn, Monroe Mary'], ['!John Doe, Jane Smith, John Doe, !Jane Smith, John Doe'], ['Alice Wonderland, Bob Builder, !Charlie Chaplin, David Copperfield, !Eve Adam, Frank Herbert'], ['!First Last, Second Third, Fourth Fifth, !Sixth Seventh, Eighth Ninth'], ['SingleEntry'], ['!OnlyHated'], ['HatedFirst, !HatedSecond, NotHated'], ['NotHated, !HatedLast'], ['!First, Second, !Third, Fourth, !Fifth'], ['NoHateHere, JustNormalPeople, LivingTheirLives'], ['!Alone'], ['A B, C D, E F, G H, I J, K L, M N, O P, Q R, S T, U V, W X, Y Z, !Z Y, X W, V U, T S, R Q, P O, N M, L K, J I, H G, F E, D C, B A']]"}}
{"requirement": "def blocks_to_collect(level: int) -> dict:\n\"\"\"Just another day in the world of Minecraft, Steve is working on his new project -- building a beacon pyramid in front of his house.\n\n![Beacon pyramid](http://www.minecraft101.net/reference/images/beacon_pyramid_thb.jpg)\n\nSteve has already obtained the beacon (the glass wrapped blue thingy on the top), he just needs to build the pyramid. Each level of the pyramid is built using one of the following four kinds of block: gold, diamond, emerald, and iron. Since these four kinds of blocks are relatively hard to collect, Steve needs to know exactly how many of each kind is required to build a pyramid of level N.\n\nAssume that the top level of the pyramid uses gold blocks, the second level uses diamond blocks, the third level uses emerald blocks, the fourth level uses iron blocks, and the fifth level uses gold blocks, etc. (if you are a Minecraft player, you know it's not neccessary the right way to build the pyramid. Let's just assume it is for the sake of this kata ;-))\n\nImplement a function that takes one argument which is the number of levels of the pyramid, and returns an object of the form: `{total: 9, gold: 9, diamond: 0, emerald: 0, iron: 0}`.\n\n---\n\nTo all the Minecraft players out there: \nfeel free to expand this series or let me know if you have any ideas related to Minecraft that can be turned into codewars puzzles. Some ideas I have that might potentially be turned into katas:\n\n* distance traveled in real world vs. in Nether\n* shortest path problems related to mining diamonds/gold/goodies that appears in different levels under ground\n* growth of animal population from breeding\n\n\n* redstone stuff?!\n\nIf you do end up expanding this series, please send me a link of your kata so I can check it out and include a link to your kata here :-)\n\n* [Minecraft Series #2: Minimum amount of fuel needed to get some iron ingots](https://www.codewars.com/kata/minecraft-series-number-2-minimum-amount-of-fuel-needed-to-get-some-iron-ingots/ruby)\n* [Minecraft Series #3: Lava is amazing! ](https://www.codewars.com/kata/583a23d40cf946ec380002c2)\n* [Minecraft Series #4: Lava is amazing, however...](https://www.codewars.com/kata/583a6b0b171f3a3c3f0003e3)\n\"\"\"", "inputs": [[1], [2], [3]], "outputs": [[{"total": 9, "gold": 9, "diamond": 0, "emerald": 0, "iron": 0}], [{"total": 34, "gold": 9, "diamond": 25, "emerald": 0, "iron": 0}], [{"total": 83, "gold": 9, "diamond": 25, "emerald": 49, "iron": 0}]], "starter_code": "def blocks_to_collect(level: int) -> dict:", "canonical_solution": "def blocks_to_collect(level):\n    answer = {'total': sum([(i + 3 + i) ** 2 for i in range(level)]), 'gold': sum([(i + 3 + i) ** 2 for i in range(0, level, 4)]), 'diamond': sum([(i + 3 + i) ** 2 for i in range(1, level, 4)]), 'emerald': sum([(i + 3 + i) ** 2 for i in range(2, level, 4)]), 'iron': sum([(i + 3 + i) ** 2 for i in range(3, level, 4)])}\n    return answer", "entry_point": "blocks_to_collect", "task_id": "TACO_lite/425", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [4], [5], [6], [0], [10]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [10], [0], [-1], [100]]"}}
{"requirement": "def reverse(st: str) -> str:\n\"\"\"You need to write a function that reverses the words in a given string. A word can also fit an empty string. If this is not clear enough, here are some examples:\n\nAs the input may have trailing spaces, you will also need to ignore unneccesary whitespace.\n\n```python\nreverse('Hello World') == 'World Hello'\nreverse('Hi There.') == 'There. Hi'\n```\n\nHappy coding!\n\"\"\"", "inputs": [["I am an expert at this"], ["This is so easy"], ["no one cares"]], "outputs": [["this at expert an am I"], ["easy so is This"], ["cares one no"]], "starter_code": "def reverse(st: str) -> str:", "canonical_solution": "def reverse(st):\n    return ' '.join(reversed(st.split())).strip()", "entry_point": "reverse", "task_id": "TACO_lite/426", "input_output_examples": "[[['Hello World'], ['Hi There.']], [['World Hello'], ['There. Hi']]]", "llm_generated_inputs": {"deepseek-v3": "[['Hello World'], ['Hi There.'], ['   Leading spaces'], ['Trailing spaces   '], ['   Multiple   spaces   '], [''], ['SingleWord'], ['   '], ['123 456 789'], ['Special!@# Characters$%^']]", "qwen2.5-coder-32b-instruct": "[['Hello World'], ['Hi There.'], ['  Leading and trailing spaces  '], ['Multiple    spaces between words'], ['SingleWord'], ['   '], ['']]"}}
{"requirement": "def cost(mins: int) -> int:\n\"\"\"Fast & Furious Driving School's (F&F) charges for lessons are as below: \n\n\n\nTime\nCost\n\n\nUp to 1st hour\n$30\n\n\nEvery subsequent half hour**\n$10\n\n\n** Subsequent charges are calculated by rounding up to nearest half hour.\n\n\nFor example, if student X has a lesson for 1hr 20 minutes, he will be charged $40 (30+10) for 1 hr 30 mins and if he has a lesson for 5 minutes, he will be charged $30 for the full hour. \n\nOut of the kindness of its heart, F&F also provides a 5 minutes grace period. So, if student X were to have a lesson for 65 minutes or 1 hr 35 mins, he will only have to pay for an hour or 1hr 30 minutes respectively. \n\nFor a given lesson time in minutes (min) , write a function price to calculate how much the lesson costs.\n\"\"\"", "inputs": [[45], [63], [84], [102], [273]], "outputs": [[30], [30], [40], [50], [100]], "starter_code": "def cost(mins: int) -> int:", "canonical_solution": "import math\n\ndef cost(mins):\n    return 30 + 10 * math.ceil(max(0, mins - 60 - 5) / 30)", "entry_point": "cost", "task_id": "TACO_lite/429", "input_output_examples": "[[[80], [5], [65], [95]], [[40], [30], [30], [40]]]", "llm_generated_inputs": {"deepseek-v3": "[[5], [30], [60], [65], [90], [95], [120], [125], [150], [155], [180], [185]]", "qwen2.5-coder-32b-instruct": "[[0], [5], [10], [15], [30], [35], [40], [59], [60], [65], [70], [89], [90], [95], [100], [120], [125], [130], [150], [180], [240], [250], [270], [300]]"}}
{"requirement": "from typing import List\nfrom typing import Union\n\n\ndef find_spaceship(astromap: str) -> Union[List[int], str]:\n\"\"\"Late last night in the Tanner household, ALF was repairing his spaceship so he might get back to Melmac. Unfortunately for him, he forgot to put on the parking brake, and the spaceship took off during repair. Now it's hovering in space.\n\nALF has the technology to bring the spaceship home if he can lock on to its location.\n\nGiven a map:\n\n````\n..........\n..........\n..........\n.......X..\n..........\n..........\n````\n\nThe map will be given in the form of a string with \\n separating new lines. The bottom left of the map is [0, 0]. X is ALF's spaceship.\n\nIn this example:\n\nIf you cannot find the spaceship, the result should be\n\n```\n\"Spaceship lost forever.\"\n```\n\nCan you help ALF?\n\n\nCheck out my other 80's Kids Katas:\n\n\n80's Kids #1: How Many Licks Does It Take\n80's Kids #2: Help Alf Find His Spaceship\n80's Kids #3: Punky Brewster's Socks\n80's Kids #4: Legends of the Hidden Temple\n80's Kids #5: You Can't Do That on Television\n80's Kids #6: Rock 'Em, Sock 'Em Robots\n80's Kids #7: She's a Small Wonder\n80's Kids #8: The Secret World of Alex Mack\n80's Kids #9: Down in Fraggle Rock \n80's Kids #10: Captain Planet\n\"\"\"", "inputs": [["X"], ["X\n."], [".X\n.."], ["..\n.X"], ["..\nX."], [".......\nX......."], ["..........\n..........\n.......X..\n..........\n.........."], ["..........\n..........\n..........\n........X.\n.........."], ["........................"], ["\n\n\n\n"]], "outputs": [[[0, 0]], [[0, 1]], [[1, 1]], [[1, 0]], [[0, 0]], [[0, 0]], [[7, 2]], [[8, 1]], ["Spaceship lost forever."], ["Spaceship lost forever."]], "starter_code": "from typing import List\nfrom typing import Union\ndef find_spaceship(astromap: str) -> Union[List[int], str]:", "canonical_solution": "def find_spaceship(astromap):\n    lines = astromap.splitlines()\n    for y, line in enumerate(lines):\n        x = line.find('X')\n        if x != -1:\n            return [x, len(lines) - 1 - y]\n    return 'Spaceship lost forever.'", "entry_point": "find_spaceship", "task_id": "TACO_lite/434", "input_output_examples": "[[['..........\\n..........\\n..........\\n.......X..\\n..........\\n..........'], ['..........\\n..........\\n..........\\n..........\\n..........\\n..........']], [[[3, 7]], ['Spaceship lost forever.']]]", "llm_generated_inputs": {"deepseek-v3": "[['........\\n........\\n........\\n.......X\\n........\\n........'], ['........\\n........\\n........\\n........\\n........\\n........'], ['X.......\\n........\\n........\\n........\\n........\\n........'], ['........\\n........\\n........\\n........\\n........\\n.......X'], ['........\\n........\\n........\\n...X....\\n........\\n........'], ['........\\n........\\n........\\n........\\n........\\n........\\n........'], ['........\\n........\\n........\\n........\\n........\\n........\\n.......X'], ['........\\n........\\n........\\n........\\n........\\n........\\nX.......'], ['........\\n........\\n........\\n........\\n........\\n........\\n...X....'], ['X'], ['']]", "qwen2.5-coder-32b-instruct": "[['..........\\n..........\\n..........\\n.......X..\\n..........\\n..........'], ['..........\\n..........\\n..........\\n..........\\n..........\\n..........'], ['X.........\\n..........\\n..........\\n..........\\n..........\\n..........'], ['..........\\n..........\\n..........\\n..........\\n..........\\n.........X'], ['X.........\\n..........\\n..........\\n..........\\n..........\\n.........X'], ['..........\\n..........\\n..........\\n....X.....\\n..........\\n..........'], ['..........\\n..........\\n..........\\n..........\\n....X.....\\n..........'], ['..........\\n..........\\n..........\\n..........\\n..........\\n....X.....'], ['..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n..........\\n.......X..'], ['X']]"}}
{"requirement": "def center_of(chars: str) -> str:\n\"\"\"# Task\n\nChristmas is coming. In the [previous kata](https://www.codewars.com/kata/5a405ba4e1ce0e1d7800012e), we build a custom Christmas tree with the specified characters and the specified height.\n\nNow, we are interested in the center of the Christmas tree. \n\nPlease imagine that we build a Christmas tree with `chars = \"abc\" and n = Infinity`, we got:\n```\n          a\n         b c\n        a b c\n       a b c a\n      b c a b c\n     a b c a b c\n    a b c a b c a\n   b c a b c a b c\n  a b c a b c a b a\n b c a b c a b a b c\na b c a b a b c a b c\n. . . . . . . . . . .\n. . . . . . . . . . .\n. . . . . . . . . . .\n. . . . . . . . . . .\n          |\n          |\n          .\n          .\n```\nIf we keep only the center part of leaves, we will got:\n```\n          a\n            \n          b  \n              \n          a    \n                \n          a        \n                    \n          b        \n                    \n          a          \n          .\n          \n          .\n          \n          .\n```\nAs you can see, it's a infinite string, but it has a repeat substring \"aba\"(spaces will be removed). If we join them together, it looks like:`\"abaabaabaabaaba......\"`.\n\nSo, your task is to find the repeat substring of the center part of leaves.\n\n# Inputs:\n\n- `chars`: the specified characters. In this kata, they always be lowercase letters.\n\n# Output:\n\n- The repeat substring that satisfy the above conditions.\n\nStill not understand the task? Look at the following example ;-)\n\n# Examples\n\n\nFor `chars = \"abc\"`,the output should be `\"aba\"`\n```\ncenter leaves sequence: \"abaabaabaabaabaaba.....\"\n```\nFor `chars = \"abab\"`,the output should be `a`\n```\ncenter leaves sequence: \"aaaaaaaaaa.....\"\n```\nFor `chars = \"abcde\"`,the output should be `aecea`\n```\ncenter leaves sequence: \"aeceaaeceaaecea.....\"\n```\nFor `chars = \"aaaaaaaaaaaaaa\"`,the output should be `a`\n```\ncenter leaves sequence: \"aaaaaaaaaaaaaa.....\"\n```\nFor `chars = \"abaabaaab\"`,the output should be `aba`\n```\ncenter leaves sequence: \"abaabaabaaba.....\"\n```\n\"\"\"", "inputs": [[""], ["a"], ["ab"], ["abc"], ["abab"], ["abcde"], ["aaaaaaaaaaaaaa"], ["abaabaaab"], ["dbdbebedbddbedededeeddbbdeddbeddeebdeddeebbbb"], ["vttussvutvuvvtustsvsvtvu"]], "outputs": [[""], ["a"], ["a"], ["aba"], ["a"], ["aecea"], ["a"], ["aba"], ["deededebddeebeddeddeddbddeddeddebeeddbededeed"], ["vsvvtvvtvvsv"]], "starter_code": "def center_of(chars: str) -> str:", "canonical_solution": "def center_of(chars):\n    if not chars:\n        return ''\n    total = 0\n    res = []\n    for i in range(1, len(chars) * 2 + 1):\n        if i % 2 == 1:\n            res.append((i + 1) // 2 + total)\n            res[-1] = chars[(res[-1] - 1) % len(chars)]\n        total += i\n    res = ''.join(res)\n    for i in range(len(res) // 2 + 1):\n        if len(res) % len(res[:i + 1]) != 0:\n            continue\n        if res[:i + 1] * (len(res) // len(res[:i + 1])) == res:\n            return res[:i + 1]\n    return res", "entry_point": "center_of", "task_id": "TACO_lite/435", "input_output_examples": "[[['abc'], ['abab'], ['abcde'], ['aaaaaaaaaaaaaa'], ['abaabaaab']], [['aba'], ['a'], ['aecea'], ['a'], ['aba']]]", "llm_generated_inputs": {"deepseek-v3": "[['abc'], ['abab'], ['abcde'], ['aaaaaaaaaaaaaa'], ['abaabaaab'], ['a'], ['ab'], ['abcabc'], ['xyz'], ['xxyyzz']]", "qwen2.5-coder-32b-instruct": "[['abc'], ['abab'], ['abcde'], ['aaaaaaaaaaaaaa'], ['abaabaaab'], ['a'], ['abcd'], ['abcabcabc'], ['xyz'], ['xyzyx']]"}}
{"requirement": "def change_count(change: str) -> str:\n\"\"\"You've been collecting change all day, and it's starting to pile up in your pocket, but you're too lazy to see how much you've found.\n\nGood thing you can code!\n\nCreate ```change_count()``` to return a dollar amount of how much change you have!\n\nValid types of change include:\n```\npenny: 0.01\nnickel: 0.05\ndime: 0.10\nquarter: 0.25\ndollar: 1.00\n```\n\n```if:python\nThese amounts are already preloaded as floats into the `CHANGE` dictionary for you to use!\n```\n```if:ruby\nThese amounts are already preloaded as floats into the `CHANGE` hash for you to use!\n```\n```if:javascript\nThese amounts are already preloaded as floats into the `CHANGE` object for you to use!\n```\n```if:php\nThese amounts are already preloaded as floats into the `CHANGE` (a constant) associative array for you to use!\n```\n\nYou should return the total in the format ```$x.xx```.\n\nExamples:\n\n```python\nchange_count('nickel penny dime dollar') == '$1.16'\nchange_count('dollar dollar quarter dime dime') == '$2.45'\nchange_count('penny') == '$0.01'\nchange_count('dime') == '$0.10'\n```\n\nWarning, some change may amount to over ```$10.00```!\n\"\"\"", "inputs": [["dime penny dollar"], ["dime penny nickel"], ["quarter quarter"], ["dollar penny dollar"], ["dollar dollar dollar dollar dollar dollar dollar dollar dollar dollar penny"]], "outputs": [["$1.11"], ["$0.16"], ["$0.50"], ["$2.01"], ["$10.01"]], "starter_code": "def change_count(change: str) -> str:", "canonical_solution": "def change_count(change):\n    money = {'penny': 0.01, 'nickel': 0.05, 'dime': 0.1, 'quarter': 0.25, 'dollar': 1.0}\n    count = 0\n    for coin in change.split():\n        count += money[coin]\n    result = '%.2f' % count\n    return '$' + result", "entry_point": "change_count", "task_id": "TACO_lite/447", "input_output_examples": "[[['nickel penny dime dollar'], ['dollar dollar quarter dime dime'], ['penny'], ['dime']], [['$1.16'], ['$2.45'], ['$0.01'], ['$0.10']]]", "llm_generated_inputs": {"deepseek-v3": "[['nickel penny dime dollar'], ['dollar dollar quarter dime dime'], ['penny'], ['dime'], ['quarter quarter quarter quarter'], ['dollar dollar dollar dollar dollar dollar dollar dollar dollar dollar dollar'], ['nickel nickel nickel nickel nickel'], ['penny penny penny penny penny penny penny penny penny penny'], ['dime dime dime dime dime dime dime dime dime dime'], ['quarter dollar nickel dime penny'], [''], ['invalid'], ['dollar invalid penny']]", "qwen2.5-coder-32b-instruct": "[['nickel penny dime dollar'], ['dollar dollar quarter dime dime'], ['penny'], ['dime'], ['penny penny penny penny penny penny penny penny penny penny penny penny penny penny penny penny penny penny penny penny'], ['quarter quarter quarter quarter quarter quarter quarter quarter quarter quarter quarter quarter quarter quarter quarter quarter'], ['dollar dollar dollar dollar dollar dollar dollar dollar dollar dollar'], ['penny nickel dime quarter'], [''], ['half dollar'], ['penny quarter dime nickel dollar penny quarter dime nickel dollar']]"}}
{"requirement": "def last(*args: Any) -> Any:\n\"\"\"Find the last element of the given argument(s).\n\n## Examples\n\n```python\nlast([1, 2, 3, 4]) ==>  4\nlast(\"xyz\")        ==> \"z\"\nlast(1, 2, 3, 4)   ==>  4\n```\nIn **javascript** and **CoffeeScript** a **list** will be an `array`, a `string` or the list of `arguments`.\n\n(courtesy of [haskell.org](http://www.haskell.org/haskellwiki/99_questions/1_to_10))\n\"\"\"", "inputs": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [["a", "b", "c", "k", "x", "y", "z"]], ["abckxyz"], ["a", "b", "c", "z"]], "outputs": [[10], [10], ["z"], ["z"], ["z"]], "starter_code": "def last(*args: Any) -> Any:", "canonical_solution": "def last(*args):\n    return args[-1] if not hasattr(args[-1], '__getitem__') else args[-1][-1]", "entry_point": "last", "task_id": "TACO_lite/451", "input_output_examples": "[[[[1, 2, 3, 4]], ['xyz'], [[1, 2, 3, 4]]], [[4], ['z'], [4]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4]], ['xyz'], [[]], [''], [(1, 2, 3)], [['a', 'b', 'c']], [{'a': 1, 'b': 2}], [None]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 4]], ['xyz'], [[1]], ['a'], [42], [[]], [''], [None], [(1, 2, 3)], [{'key': 'value'}]]"}}
{"requirement": "def convert_num(number: int, base: str) -> str:\n\"\"\"Poor Cade has got his number conversions mixed up again!\n\nFix his ```convert_num()``` function so it correctly converts a base-10 ```int```eger, \nto the selected of ```bin```ary or ```hex```adecimal.\n\n```#The output should be a string at all times```\n\n```python\nconvert_num(number, base):\n    if 'base' = hex:\n        return int(number, 16)\n    if 'base' = bin:\n        return int(number, 2)\n    return (Incorrect base input)\n```\nPlease note, invalid ```number``` or ```base``` inputs will be tested.\nIn the event of an invalid ```number/base``` you should return:\n```python\n\"Invalid number input\"\nor\n\"Invalid base input\"\n```\nFor each respectively.\n\nGood luck coding! :D\n\"\"\"", "inputs": [[122, "bin"], ["dog", "bin"], [0, "hex"], [123, "lol"]], "outputs": [["0b1111010"], ["Invalid number input"], ["0x0"], ["Invalid base input"]], "starter_code": "def convert_num(number: int, base: str) -> str:", "canonical_solution": "def convert_num(number, base):\n    try:\n        if base == 'hex':\n            return hex(number)\n        if base == 'bin':\n            return bin(number)\n    except:\n        return 'Invalid number input'\n    return 'Invalid base input'", "entry_point": "convert_num", "task_id": "TACO_lite/462", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[10, 'bin'], [255, 'hex'], [16, 'hex'], [0, 'bin'], [-5, 'bin'], [1024, 'oct'], ['abc', 'bin'], [10, 'binary'], [None, 'hex'], [10, None]]", "qwen2.5-coder-32b-instruct": "[[10, 'bin'], [10, 'hex'], [255, 'bin'], [255, 'hex'], [-10, 'bin'], [-10, 'hex'], [0, 'bin'], [0, 'hex'], [10, 'oct'], [10, 'dec'], ['abc', 'bin'], ['abc', 'hex'], [None, 'bin'], [None, 'hex'], [10, None], [10, '']]"}}
{"requirement": "def count_me(data: str) -> str:\n\"\"\"Given a string of integers, count how many times that integer repeats itself, then return a string showing the count and the integer.\n\n\nExample: `countMe('1123')` (`count_me` in Ruby)\n\n- Here 1 comes twice so `` will be `\"21\"`\n- then 2 comes once so `` will be `\"12\"`\n- then 3 comes once so `` will be `\"13\"`\n\nhence output string will be `\"211213\"`.\n\n\nSimilarly `countMe('211213')` will return `'1221121113'`\n(1 time 2, 2 times 1, 1 time 2, 1 time 1, 1 time 3)\n\n\nReturn `\"\"` for empty, nil or non numeric strings\n\"\"\"", "inputs": [["1123"], ["1"], ["11"], ["a"], ["a123"], ["21"], ["1211"], ["12322212223443"], [""], ["123a"]], "outputs": [["211213"], ["11"], ["21"], [""], [""], ["1211"], ["111221"], ["111213321132132413"], [""], [""]], "starter_code": "def count_me(data: str) -> str:", "canonical_solution": "def count_me(data):\n    if not data.isdigit():\n        return ''\n    result = []\n    count = 1\n    last = data[0]\n    for char in data[1:]:\n        if char == last:\n            count += 1\n        else:\n            result.append(str(count) + last)\n            last = char\n            count = 1\n    result.append(str(count) + last)\n    return ''.join(result)", "entry_point": "count_me", "task_id": "TACO_lite/467", "input_output_examples": "[[['1123'], ['211213'], ['']], [['211213'], ['1221121113'], ['']]]", "llm_generated_inputs": {"deepseek-v3": "[['1123'], ['211213'], [''], ['a1b2c3'], ['1234567890'], ['1111111111'], ['123123123'], ['0000000000'], ['9876543210'], ['11223344556677889900']]", "qwen2.5-coder-32b-instruct": "[['1123'], ['211213'], ['1111'], ['1234567890'], ['1'], [''], ['abc'], ['123a'], ['0000'], ['101010']]"}}
{"requirement": "def numericals(s: str) -> str:\n\"\"\"You are given an input string.\n\nFor each symbol in the string if it's the first character occurrence, replace it with a '1', else replace it with the amount of times you've already seen it...\n      \nBut will your code be **performant enough**?\n\n___\n\n## Examples:\n\n```\ninput   =  \"Hello, World!\"\nresult  =  \"1112111121311\"\n\ninput   =  \"aaaaaaaaaaaa\"\nresult  =  \"123456789101112\"\n```\n\nThere might be some non-ascii characters in the string.\n\n~~~if:java\nNote: there will be no int domain overflow (character occurrences will be less than 2 billion).\n~~~\n~~~if:c\n(this does not apply to the C language translation)\n~~~\n\"\"\"", "inputs": [["Hello, World!"], ["Hello, World! It's me, JomoPipi!"], ["hello hello"], ["Hello"], ["11111"], ["hope you 123456789 expected numbers in the string"], ["In this string, I'll make sure the amounts of a character go over 9"]], "outputs": [["1112111121311"], ["11121111213112111131224132411122"], ["11121122342"], ["11121"], ["12345"], ["1111112121111111113212311414121151151262267232231"], ["11111112221221132112411115312263237221234482193101343525441123124155131"]], "starter_code": "def numericals(s: str) -> str:", "canonical_solution": "def numericals(s):\n    dictio = {}\n    t = ''\n    for i in s:\n        dictio[i] = dictio.get(i, 0) + 1\n        t += str(dictio[i])\n    return t", "entry_point": "numericals", "task_id": "TACO_lite/475", "input_output_examples": "[[['Hello, World!'], ['aaaaaaaaaaaa']], [['1112111121311'], ['123456789101112']]]", "llm_generated_inputs": {"deepseek-v3": "[['Hello, World!'], ['aaaaaaaaaaaa'], [''], ['a'], ['abababab'], ['1234512345'], ['😊😊😊😊'], ['aAaaA'], ['ππππ'], ['a😊a😊a😊']]", "qwen2.5-coder-32b-instruct": "[['Hello, World!'], ['aaaaaaaaaaaa'], ['abcABC'], ['1234567890'], ['!!@@##$$%%^^&&'], ['a'], [''], ['AaAaAa'], ['!@#$%^&*()'], ['nonascii: ñ, ü, ç, é, à']]"}}
{"requirement": "from typing import List\n\n\ndef diagonal(m: List[List[int]]) -> str:\n\"\"\"**Principal Diagonal** -- The principal diagonal in a matrix identifies those elements of the matrix running from North-West to South-East.\n\n**Secondary Diagonal** -- the secondary diagonal of a matrix identifies those elements of the matrix running from North-East to South-West.\n\nFor example:\n```\nmatrix:             [1, 2, 3]\n                    [4, 5, 6]\n                    [7, 8, 9]\n\nprincipal diagonal: [1, 5, 9]\nsecondary diagonal: [3, 5, 7]\n\n```\n\n## Task\nYour task is to find which diagonal is \"larger\": which diagonal has a bigger sum of their elements.\n\n* If the principal diagonal is larger, return `\"Principal Diagonal win!\"`\n* If the secondary diagonal is larger, return `\"Secondary Diagonal win!\"`\n* If they are equal, return `\"Draw!\"`\n\n**Note:** You will always receive matrices of the same dimension.\n\"\"\"", "inputs": [[[[2, 2, 2], [4, 2, 6], [8, 8, 2]]], [[[7, 2, 2], [4, 2, 6], [1, 8, 1]]], [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], [[[1, 2, 2, 5, 1], [4, 1, 6, 1, 1], [1, 8, 5, 6, 2], [1, 5, 2, 1, 2], [1, 8, 2, 6, 1]]], [[[88, 2, 2, 5, 1, 1, 2, 2, 5, 1], [4, 1, 6, 1, 1, 1, 2, 2, 7, 1], [1, 8, 1, 6, 2, 1, 2, 1, 5, 1], [1, 5, 2, 7, 2, 1, 1, 2, 5, 1], [1, 8, 2, 6, 1, 1, 2, 2, 5, 1], [1, 2, 2, 5, 1, 1, 2, 2, 5, 1], [1, 2, 2, 1, 1, 1, 1, 2, 5, 1], [1, 2, 1, 5, 1, 1, 2, 1, 5, 1], [1, 1, 2, 5, 1, 1, 2, 2, 1, 1], [88, 2, 2, 5, 1, 1, 2, 2, 5, 1]]], [[[2, 2, 2], [4, 2, 6], [1, 8, 5]]], [[[1, 2, 2, 5, 104], [4, 1, 6, 4, 1], [1, 8, 5, 6, 2], [1, 1, 2, 1, 2], [1, 8, 2, 6, 1]]], [[[1, 2, 2, 5, 1, 1, 2, 2, 5, 15], [4, 1, 6, 1, 1, 1, 2, 2, 1, 1], [1, 8, 1, 6, 2, 1, 2, 1, 5, 1], [1, 5, 2, 1, 2, 1, 1, 2, 5, 1], [1, 8, 2, 6, 1, 1, 2, 2, 5, 1], [1, 2, 2, 5, 1, 1, 2, 2, 5, 1], [1, 2, 2, 1, 1, 1, 1, 2, 5, 1], [1, 2, 1, 5, 1, 1, 2, 1, 5, 1], [1, 1, 2, 5, 1, 1, 2, 2, 1, 1], [1, 2, 2, 5, 1, 1, 2, 2, 5, 15]]], [[[0, 2, 2, 5, 1], [4, 0, 6, 1, 1], [1, 8, 5, 6, 2], [1, 7, 2, 1, 2], [1, 8, 2, 6, 1]]], [[[1, 2, 2, 5, 1, 1, 2, 2, 5, 1], [4, 8, 6, 1, 1, 1, 2, 2, 1, 1], [1, 8, 1, 6, 2, 1, 2, 6, 5, 1], [1, 5, 2, 1, 2, 1, 1, 2, 5, 1], [1, 8, 2, 6, 1, 1, 2, 2, 5, 1], [1, 2, 2, 5, 1, 1, 2, 2, 5, 1], [1, 2, 2, 1, 1, 1, 1, 2, 5, 1], [1, 2, 8, 5, 1, 1, 2, 6, 5, 1], [1, 1, 2, 5, 1, 1, 2, 2, 1, 1], [1, 2, 2, 5, 1, 1, 2, 2, 5, 1]]]], "outputs": [["Secondary Diagonal win!"], ["Principal Diagonal win!"], ["Draw!"], ["Secondary Diagonal win!"], ["Draw!"], ["Principal Diagonal win!"], ["Secondary Diagonal win!"], ["Draw!"], ["Secondary Diagonal win!"], ["Draw!"]], "starter_code": "from typing import List\ndef diagonal(m: List[List[int]]) -> str:", "canonical_solution": "def diagonal(m):\n    P = sum((m[i][i] for i in range(len(m))))\n    S = sum((m[i][-i - 1] for i in range(len(m))))\n    if P > S:\n        return 'Principal Diagonal win!'\n    elif S > P:\n        return 'Secondary Diagonal win!'\n    else:\n        return 'Draw!'", "entry_point": "diagonal", "task_id": "TACO_lite/477", "input_output_examples": "[[[[[1, 2, 3], [4, 5, 6], [7, 8, 9]]]], [['Draw!']]]", "llm_generated_inputs": {"deepseek-v3": "[[[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], [[[3, 2, 1], [4, 5, 6], [9, 8, 7]]], [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], [[[1, 0, 1], [0, 1, 0], [1, 0, 1]]], [[[10]]], [[[1, 2], [2, 1]]], [[[5, 0], [0, 5]]], [[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]], [[[-1, -2], [-3, -1]]], [[[100, 200], [300, 100]]]]", "qwen2.5-coder-32b-instruct": "[[[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], [[[5, 5, 5], [5, 5, 5], [5, 5, 5]]], [[[10, 2, 3], [4, 20, 6], [7, 8, 30]]], [[[1, 2, 3], [6, 5, 4], [7, 8, 9]]], [[[1]]], [[[3, 1], [1, 3]]], [[[0, 0, 0], [0, 0, 0], [0, 0, 0]]], [[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]], [[[-1, 2, -3], [4, -5, 6], [-7, 8, -9]]]]"}}
{"requirement": "from typing import List\n\n\ndef peak(arr: List[int]) -> int:\n\"\"\"Given an array of ints, return the index such that the sum of the elements to the right of that index equals the sum of the elements to the left of that index. If there is no such index, return `-1`. If there is more than one such index, return the left-most index.\n\nFor example: \n```\npeak([1,2,3,5,3,2,1]) = 3, because the sum of the elements at indexes 0,1,2 == sum of elements at indexes 4,5,6. We don't sum index 3.\npeak([1,12,3,3,6,3,1]) = 2\npeak([10,20,30,40]) = -1\n```\n\nThe special case of an array of zeros (for instance `[0,0,0,0]`) will not be tested. \n\nMore examples in the test cases. \n\nGood luck!\n\nPlease also try [Simple time difference](https://www.codewars.com/kata/5b76a34ff71e5de9db0000f2)\n\"\"\"", "inputs": [[[1, 2, 3, 5, 3, 2, 1]], [[1, 12, 3, 3, 6, 3, 1]], [[10, 20, 30, 40]]], "outputs": [[3], [2], [-1]], "starter_code": "from typing import List\ndef peak(arr: List[int]) -> int:", "canonical_solution": "def peak(arr):\n    for i, val in enumerate(arr):\n        if sum(arr[:i]) == sum(arr[i + 1:]):\n            return i\n    return -1", "entry_point": "peak", "task_id": "TACO_lite/480", "input_output_examples": "[[[[1, 2, 3, 5, 3, 2, 1]], [[1, 12, 3, 3, 6, 3, 1]], [[10, 20, 30, 40]]], [[3], [2], [-1]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 5, 3, 2, 1]], [[1, 12, 3, 3, 6, 3, 1]], [[10, 20, 30, 40]], [[1, 1, 1, 1, 1, 1, 1]], [[0, 0, 0, 0]], [[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]], [[1, 2, 3, 4, 5, 15, 1, 2, 3, 4, 5]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 55]], [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], [[100, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 100]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 5, 3, 2, 1]], [[1, 12, 3, 3, 6, 3, 1]], [[10, 20, 30, 40]], [[0, 0, 0, 0, 0]], [[1, 1, 1, 1, 1, 1, 1]], [[1, 2, 3, 4, 5]], [[5, 4, 3, 2, 1]], [[1]], [[]], [[1, 2, 3, 4, 6, 2, 3]], [[2, 3, 4, 1, 2, 3, 4]]]"}}
{"requirement": "from typing import List\n\n\ndef sum_times_tables(table: List[int], a: int, b: int) -> int:\n\"\"\"Write a function `sumTimesTables` which sums the result of the sums of the elements specified in `tables` multiplied by all the numbers in between `min` and `max` including themselves.\n\nFor example, for `sumTimesTables([2,5],1,3)` the result should be the same as\n```\n2*1 + 2*2 + 2*3 +\n5*1 + 5*2 + 5*3\n```\ni.e. the table of two from 1 to 3 plus the table of five from 1 to 3\n\nAll the numbers are integers but you must take in account:\n\n* `tables` could be empty.\n* `min` could be negative.\n* `max` could be really big.\n\"\"\"", "inputs": [[[2, 3], 1, 3], [[1, 3, 5], 1, 1], [[1, 3, 5], 1, 10], [[], 1, 10], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1, 10], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 1, 10], [[5, 4, 7, 8, 9, 6, 3, 2, 10, 1], 1, 10], [[-2], -1, 3], [[-2, 2], -1, 3], [[-2, 3], -1, 3], [[2, -3], -1, 3], [[2, 4, 7], -100, 100], [[2, 4, 7], 1, 100], [[2, 4, 7], 1, 101]], "outputs": [[30], [9], [495], [0], [3025], [3025], [3025], [-10], [0], [5], [-5], [0], [65650], [66963]], "starter_code": "from typing import List\ndef sum_times_tables(table: List[int], a: int, b: int) -> int:", "canonical_solution": "def sum_times_tables(table, a, b):\n    return sum(table) * (a + b) * (b - a + 1) // 2", "entry_point": "sum_times_tables", "task_id": "TACO_lite/485", "input_output_examples": "[[[[2, 5], 1, 3]], [[36]]]", "llm_generated_inputs": {"deepseek-v3": "[[[2, 5], 1, 3], [[1, 3, 5], 0, 0], [[], -1, 1], [[10, 20, 30], -2, 2], [[7], 1000000, 1000002], [[4, 8, 15, 16, 23, 42], -5, 5], [[0], 1, 10], [[1, -1], -3, 3], [[2, 3, 5, 7], 10, 10], [[9, 8, 7, 6], 0, 100]]", "qwen2.5-coder-32b-instruct": "[[[2, 5], 1, 3], [[2, 5], -1, 3], [[2, 5], 0, 0], [[2, 5], 3, 1], [[2, 5], 1, 1000], [[], 1, 3], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], -5, 5], [[10], -10, 10], [[100], 0, 1], [[1, 1, 1], 1, 1]]"}}
{"requirement": "from typing import List\n\n\ndef sum_even_numbers(seq: List[int]) -> int:\n\"\"\"# Task\n\nWrite a function named `sumEvenNumbers`, taking a sequence of numbers as single parameter. Your function must return the sum of **the even values** of this sequence.\n\nOnly numbers without decimals like `4` or `4.0` can be even. \n\n## Input\n* sequence of numbers: those numbers could be integers and/or floats. \n\n\nFor example, considering this input value : `[4,3,1,2,5,10,6,7,9,8]`, then your function should return `30` (because `4 + 2 + 10 + 6 + 8 = 30`).\n\"\"\"", "inputs": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[]], [[1337, 374, 849, 22.5, 19, 16, 0, 0, 16, 32]], [[-16, -32, 20, 21, 41, 42]], [[15397, 12422, 10495, 22729, 23921, 18326, 27955, 24073, 23690, 15002, 11615, 15682, 24346, 16725, 17252, 20467, 20493, 17807, 13041, 25861, 22471, 22747, 24082, 18979, 28543, 26488, 10002, 24740, 17950, 26573, 25851, 19446, 22584, 14857, 17387, 29310, 28265, 19497, 11394, 28111, 20957, 17201, 26647, 26885, 27297, 17252, 25961, 12409, 22858, 27869, 19832, 13906, 11256, 11304, 24186, 28783, 16647, 23073, 11105, 13327, 17102, 10172, 21104, 23001, 24108, 16166, 21690, 14218, 11903, 10286, 19116, 18585, 25511, 18273, 11862, 17166, 13456, 28562, 16262, 11100, 22806, 14748, 17362, 11633, 17165, 16390, 24580, 22498, 26121, 16170, 18917, 26963, 17605, 20839, 22487, 12187, 23752, 12444, 14392, 28313]]], "outputs": [[30], [0], [438], [14], [870822]], "starter_code": "from typing import List\ndef sum_even_numbers(seq: List[int]) -> int:", "canonical_solution": "def sum_even_numbers(seq):\n    return sum((n for n in seq if not n % 2))", "entry_point": "sum_even_numbers", "task_id": "TACO_lite/493", "input_output_examples": "[[[[4, 3, 1, 2, 5, 10, 6, 7, 9, 8]]], [[30]]]", "llm_generated_inputs": {"deepseek-v3": "[[[4, 3, 1, 2, 5, 10, 6, 7, 9, 8]], [[1, 3, 5, 7, 9]], [[2, 4, 6, 8, 10]], [[0, -2, -4, -6, -8]], [[1.0, 2.0, 3.0, 4.0, 5.0]], [[-1.0, -2.0, -3.0, -4.0, -5.0]], [[0]], [[]], [[3.5, 4.5, 5.5, 6.5]], [[2, 2.0, 3, 3.0, 4, 4.0]]]", "qwen2.5-coder-32b-instruct": "[[[4, 3, 1, 2, 5, 10, 6, 7, 9, 8]], [[1, 3, 5, 7, 9]], [[2, 4, 6, 8, 10]], [[0]], [[]], [[4.0, 2.0, 6.0]], [[4.5, 2.2, 6.1]], [[2, 3.0, 4.0, 5, 6]], [[-2, -4, -6, -8]], [[-3, -2, -1, 0, 1, 2, 3]]]"}}
{"requirement": "def circular_prime(n: int) -> bool:\n\"\"\"_Based on [Project Euler problem 35](https://projecteuler.net/problem=35)_\n\nA circular prime is a prime in which every circular permutation of that number is also prime. Circular permutations are created by rotating the digits of the number, for example: `197, 971, 719`. One-digit primes are circular primes by definition.\n\nComplete the function that dertermines if a number is a circular prime.\n\nThere are 100 random tests for numbers up to 10000.\n\"\"\"", "inputs": [[197], [179], [971], [222], [9377], [7], [213], [35], [1]], "outputs": [[true], [false], [true], [false], [true], [true], [false], [false], [false]], "starter_code": "def circular_prime(n: int) -> bool:", "canonical_solution": "def circular_permutations(n):\n    n = str(n)\n    return [int(n[i:] + n[:i]) for i in range(len(n))]\n\ndef is_prime(n):\n    return n > 1 and all((n % i != 0 for i in range(2, int(n ** 0.5) + 1)))\n\ndef circular_prime(n):\n    return all((is_prime(x) for x in circular_permutations(n)))", "entry_point": "circular_prime", "task_id": "TACO_lite/497", "input_output_examples": "[[[197], [101], [37], [23], [97]], [[True], [False], [True], [True], [True]]]", "llm_generated_inputs": {"deepseek-v3": "[[2], [13], [197], [23], [71], [991], [193939], [999999], [1], [0], [97], [100], [113]]", "qwen2.5-coder-32b-instruct": "[[2], [3], [5], [7], [11], [13], [17], [19], [23], [37], [79], [113], [197], [199], [311], [337], [373], [719], [733], [919], [971], [1193], [1931], [3119], [3779], [7793], [7937], [9311], [9377], [1117], [19937], [193939], [1111111], [199933], [10], [4], [6], [8], [9], [20], [22], [25], [27], [30], [32], [33], [35], [38], [39], [40], [41]]"}}
{"requirement": "from typing import List\n\n\ndef matrix_mult(a: List[List[int]], b: List[List[int]]) -> List[List[int]]:\n\"\"\"Write a function that accepts two square (`NxN`) matrices (two dimensional arrays), and returns the product of the two. Only square matrices will be given.\n\nHow to multiply two square matrices: \n\nWe are given two matrices, A and B, of size 2x2 (note: tests are not limited to 2x2). Matrix C, the solution, will be equal to the product of A and B. To fill in cell `[0][0]` of matrix C, you need to compute: `A[0][0] * B[0][0] + A[0][1] * B[1][0]`.\n\nMore general: To fill in cell `[n][m]` of matrix C, you need to first multiply the elements in the nth row of matrix A by the elements in the mth column of matrix B, then take the sum of all those products. This will give you the value for cell `[m][n]` in matrix C. \n\n## Example\n```\n  A         B          C\n|1 2|  x  |3 2|  =  | 5 4|\n|3 2|     |1 1|     |11 8|\n```\n\nDetailed calculation:\n```\nC[0][0] = A[0][0] * B[0][0] + A[0][1] * B[1][0] = 1*3 + 2*1 =  5\nC[0][1] = A[0][0] * B[0][1] + A[0][1] * B[1][1] = 1*2 + 2*1 =  4\nC[1][0] = A[1][0] * B[0][0] + A[1][1] * B[1][0] = 3*3 + 2*1 = 11\nC[1][1] = A[1][0] * B[0][1] + A[1][1] * B[1][1] = 3*2 + 2*1 =  8\n```\nLink to Wikipedia explaining matrix multiplication (look at the square matrix example): \nhttp://en.wikipedia.org/wiki/Matrix_multiplication\n\nA more visual explanation of matrix multiplication: http://matrixmultiplication.xyz\n\n~~~if:c\n**Note:** In **C**, the dimensions of both square matrices `n` will be passed into your function.  However, since the dimensions of your returned \"matrix\" is expected to be the same as that of the inputs, you will not need to keep track of the dimensions of your matrix in another variable.\n~~~\n\"\"\"", "inputs": [[[[1, 2], [3, 2]], [[3, 2], [1, 1]]], [[[9, 7], [0, 1]], [[1, 1], [4, 12]]], [[[1, 2, 3], [3, 2, 1], [2, 1, 3]], [[4, 5, 6], [6, 5, 4], [4, 6, 5]]]], "outputs": [[[[5, 4], [11, 8]]], [[[37, 93], [4, 12]]], [[[28, 33, 29], [28, 31, 31], [26, 33, 31]]]], "starter_code": "from typing import List\ndef matrix_mult(a: List[List[int]], b: List[List[int]]) -> List[List[int]]:", "canonical_solution": "from numpy import matrix\n\ndef matrix_mult(a, b):\n    return (matrix(a) * matrix(b)).tolist()", "entry_point": "matrix_mult", "task_id": "TACO_lite/504", "input_output_examples": "[[[[[1, 2], [3, 2]], [[3, 2], [1, 1]]]], [[[[5, 4], [11, 8]]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[[1, 2], [3, 2]], [[3, 2], [1, 1]]], [[[1, 0], [0, 1]], [[1, 0], [0, 1]]], [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[9, 8, 7], [6, 5, 4], [3, 2, 1]]], [[[1]], [[2]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]], [[[1, 0, 0], [0, 1, 0], [0, 0, 1]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]]], [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]]", "qwen2.5-coder-32b-instruct": "[[[[1, 2], [3, 2]], [[3, 2], [1, 1]]], [[[1, 0], [0, 1]], [[1, 2], [3, 4]]], [[[2, 0, 0], [0, 2, 0], [0, 0, 2]], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[[0, 0], [0, 0]], [[1, 2], [3, 4]]], [[[1]], [[1]]], [[[3, -2, 4], [2, 0, 1], [-1, 5, 3]], [[4, 2, 0], [3, 0, 1], [-1, 3, 7]]]]"}}
{"requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef find_the_ball(start: int, swaps: List[Tuple[int, int]]) -> int:\n\"\"\"\"The Shell Game\" involves cups upturned on a playing surface, with a ball placed underneath one of them.  The index of the cups are swapped around multiple times. After that the players will try to find which cup contains the ball.\n\nYour task is as follows.  Given the cup that the ball starts under, and list of swaps, return the location of the ball at the end.  Cups are given like array/list indices.\n\nFor example, given the starting position `0` and the swaps `[(0, 1), (1, 2), (1, 0)]`:\n\n * The first swap moves the ball from `0` to `1`\n * The second swap moves the ball from `1` to `2`\n * The final swap doesn't affect the position of the ball.\n \n So\n\n```python\nfind_the_ball(0, [(0, 1), (2, 1), (0, 1)]) == 2\n```\n\nThere aren't necessarily only three cups in this game, but there will be at least two.  You can assume all swaps are valid, and involve two distinct indices.\n\"\"\"", "inputs": [[5, []], [0, []], [9, []], [0, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [15, 16], [16, 17], [17, 18], [18, 19], [19, 20], [20, 21], [21, 22], [22, 23], [23, 24], [24, 25], [25, 26], [26, 27], [27, 28], [28, 29], [29, 30], [30, 31], [31, 32], [32, 33], [33, 34], [34, 35], [35, 36], [36, 37], [37, 38], [38, 39], [39, 40], [40, 41], [41, 42], [42, 43], [43, 44], [44, 45], [45, 46], [46, 47], [47, 48], [48, 49], [49, 50], [50, 51], [51, 52], [52, 53], [53, 54], [54, 55], [55, 56], [56, 57], [57, 58], [58, 59], [59, 60], [60, 61], [61, 62], [62, 63], [63, 64], [64, 65], [65, 66], [66, 67], [67, 68], [68, 69], [69, 70], [70, 71], [71, 72], [72, 73], [73, 74], [74, 75], [75, 76], [76, 77], [77, 78], [78, 79], [79, 80], [80, 81], [81, 82], [82, 83], [83, 84], [84, 85], [85, 86], [86, 87], [87, 88], [88, 89], [89, 90], [90, 91], [91, 92], [92, 93], [93, 94], [94, 95], [95, 96], [96, 97], [97, 98], [98, 99], [99, 100], [100, 101]]], [0, [[1, 0], [2, 1], [3, 2], [4, 3], [5, 4], [6, 5], [7, 6], [8, 7], [9, 8], [10, 9], [11, 10], [12, 11], [13, 12], [14, 13], [15, 14], [16, 15], [17, 16], [18, 17], [19, 18], [20, 19], [21, 20], [22, 21], [23, 22], [24, 23], [25, 24], [26, 25], [27, 26], [28, 27], [29, 28], [30, 29], [31, 30], [32, 31], [33, 32], [34, 33], [35, 34], [36, 35], [37, 36], [38, 37], [39, 38], [40, 39], [41, 40], [42, 41], [43, 42], [44, 43], [45, 44], [46, 45], [47, 46], [48, 47], [49, 48], [50, 49], [51, 50], [52, 51], [53, 52], [54, 53], [55, 54], [56, 55], [57, 56], [58, 57], [59, 58], [60, 59], [61, 60], [62, 61], [63, 62], [64, 63], [65, 64], [66, 65], [67, 66], [68, 67], [69, 68], [70, 69], [71, 70], [72, 71], [73, 72], [74, 73], [75, 74], [76, 75], [77, 76], [78, 77], [79, 78], [80, 79], [81, 80], [82, 81], [83, 82], [84, 83], [85, 84], [86, 85], [87, 86], [88, 87], [89, 88], [90, 89], [91, 90], [92, 91], [93, 92], [94, 93], [95, 94], [96, 95], [97, 96], [98, 97], [99, 98], [100, 99], [101, 100]]]], "outputs": [[5], [0], [9], [101], [101]], "starter_code": "from typing import List\nfrom typing import Tuple\ndef find_the_ball(start: int, swaps: List[Tuple[int, int]]) -> int:", "canonical_solution": "def find_the_ball(start, swaps):\n    pos = start\n    for a, b in swaps:\n        if a == pos:\n            pos = b\n        elif b == pos:\n            pos = a\n    return pos", "entry_point": "find_the_ball", "task_id": "TACO_lite/510", "input_output_examples": "[[[0, [(0, 1), (1, 2), (1, 0)]]], [[2]]]", "llm_generated_inputs": {"deepseek-v3": "[[0, [(0, 1), (1, 2), (1, 0)]], [2, [(0, 1), (2, 3), (3, 4)]], [1, [(1, 2), (2, 3), (3, 4), (4, 0)]], [3, [(3, 2), (2, 1), (1, 0)]], [0, [(0, 1)]], [5, [(5, 4), (4, 3), (3, 2)]], [0, [(1, 2), (3, 4), (5, 6)]], [10, [(10, 9), (8, 7), (6, 5)]], [0, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]], [7, [(7, 6), (6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (1, 0)]]]", "qwen2.5-coder-32b-instruct": "[[0, [(0, 1), (1, 2), (1, 0)]], [1, [(0, 1), (2, 1), (0, 1)]], [2, [(0, 1), (2, 1), (0, 1)]], [0, [(0, 2), (1, 2), (0, 1)]], [1, [(0, 2), (1, 2), (0, 1)]], [2, [(0, 2), (1, 2), (0, 1)]], [0, []], [1, []], [0, [(0, 1)]], [1, [(0, 1)]], [0, [(0, 1), (1, 0)]], [1, [(0, 1), (1, 0)]], [0, [(0, 1), (1, 2), (2, 0)]], [1, [(0, 1), (1, 2), (2, 0)]], [2, [(0, 1), (1, 2), (2, 0)]]]"}}
{"requirement": "from typing import List\n\n\ndef covered_pawns(pawns: List[str]) -> int:\n\"\"\"Given a list of white pawns on a chessboard (any number of them, meaning from 0 to 64 and with the possibility to be positioned everywhere), determine how many of them have their backs covered by another. \nPawns attacking upwards since we have only white ones.\n\nPlease remember that a pawn attack(and defend as well) only the 2 square on the sides in front of him. https://en.wikipedia.org/wiki/Pawn_(chess)#/media/File:Pawn_(chess)_movements.gif\n\nThis is how the chess board coordinates are defined:\nABCDEFGH8♜♞♝♛♚♝♞♜7♟♟♟♟♟♟♟♟65432♙♙♙♙♙♙♙♙1♖♘♗♕♔♗♘♖\n\"\"\"", "inputs": [[["f7", "b1", "h1", "c7", "h7"]], [["e5", "b2", "b4", "g4", "a1", "a5"]], [["a2", "b1", "c2"]], [["a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "g1", "g2", "g3", "g4", "g5", "g6", "g7", "g8", "h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8"]], [[]]], "outputs": [[0], [2], [2], [56], [0]], "starter_code": "from typing import List\ndef covered_pawns(pawns: List[str]) -> int:", "canonical_solution": "def covered_pawns(pawns):\n    pawns = set(pawns)\n    return len({p for p in pawns for x, y in [map(ord, p)] if {chr(x - 1) + chr(y - 1), chr(x + 1) + chr(y - 1)} & pawns})", "entry_point": "covered_pawns", "task_id": "TACO_lite/511", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[]], [['a2', 'b2']], [['c3', 'd4', 'e5']], [['h7', 'g6', 'f5']], [['a1', 'b2', 'c3', 'd4', 'e5', 'f6', 'g7', 'h8']], [['a8', 'b7', 'c6', 'd5', 'e4', 'f3', 'g2', 'h1']], [['b2', 'c3', 'd4', 'e5', 'f6', 'g7', 'h8']], [['a2', 'b3', 'c4', 'd5', 'e6', 'f7', 'g8']], [['a2', 'c2', 'e2', 'g2']], [['b1', 'd3', 'f5', 'h7']], [['a1', 'h1', 'a8', 'h8']], [['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']], [['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']], [['a2', 'c3', 'e4', 'g5', 'b6', 'd7', 'f8']], [['a2', 'b3', 'c2', 'd3', 'e2', 'f3', 'g2', 'h3']]]", "qwen2.5-coder-32b-instruct": "[[[]], [['a1']], [['a2', 'b4']], [['e5', 'd6', 'f6']], [['c5', 'b6', 'd6', 'c7']], [['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']], [['a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8']], [['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']], [['a2', 'b3', 'c4', 'd5', 'e6', 'f7', 'g8']], [['h2', 'g3', 'f4', 'e5', 'd6', 'c7', 'b8']], [['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2', 'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3']]]"}}
{"requirement": "from typing import List\n\n\ndef strings_crossover(arr: List[str], result: str) -> int:\n\"\"\"# Task\n Define crossover operation over two equal-length strings A and B as follows:\n\n the result of that operation is a string of the same length as the input strings result[i] is chosen at random between A[i] and B[i]. \n \n Given array of strings `arr` and a string result, find for how many pairs of strings from `arr` the result of the crossover operation over them may be equal to result.\n\n Note that (A, B) and (B, A) are the same pair. Also note that the pair cannot include the same element of the array twice (however, if there are two equal elements in the array, they can form a pair).\n\n# Example\n\n For `arr = [\"abc\", \"aaa\", \"aba\", \"bab\"]` and `result = \"bbb\"`, the output should be `2`.\n\n ```\n\"abc\" and \"bab\" can crossover to \"bbb\"\n\"aba\" and \"bab\" can crossover to \"bbb\"\n```\n# Input/Output\n\n\n - `[input]` string array `arr`\n\n   A non-empty array of equal-length strings.\n\n   Constraints: `2 ≤ arr.length ≤ 10, 1 ≤ arr[i].length ≤ 10.`\n\n\n - `[input]` string `result`\n\n   A string of the same length as each of the arr elements.\n\n   Constraints: `result.length = arr[i].length.`\n\n\n - `[output]` an integer\n\"\"\"", "inputs": [[["abc", "aaa", "aba", "bab"], "bbb"], [["aacccc", "bbcccc"], "abdddd"], [["a", "b", "c", "d", "e"], "c"], [["aa", "ab", "ba"], "bb"], [["a", "b", "c", "d", "e"], "f"], [["aaa", "aaa"], "aaa"]], "outputs": [[2], [0], [4], [1], [0], [1]], "starter_code": "from typing import List\ndef strings_crossover(arr: List[str], result: str) -> int:", "canonical_solution": "from itertools import combinations\n\ndef strings_crossover(arr, result):\n    return sum((1 for s1, s2 in combinations(arr, 2) if all((r in (x, y) for x, y, r in zip(s1, s2, result)))))", "entry_point": "strings_crossover", "task_id": "TACO_lite/515", "input_output_examples": "[[[['abc', 'aaa', 'aba', 'bab'], 'bbb']], [[2]]]", "llm_generated_inputs": {"deepseek-v3": "[[['abc', 'aaa', 'aba', 'bab'], 'bbb'], [['xyz', 'xzy', 'zxy', 'yxz'], 'xyz'], [['ab', 'ba'], 'aa'], [['abcd', 'abdc', 'acbd', 'adcb'], 'aaaa'], [['111', '222', '333'], '123'], [['a', 'b'], 'c'], [['xy', 'yx'], 'zz'], [['abc', 'def', 'ghi'], 'xyz'], [['aa', 'bb', 'cc'], 'ac'], [['pqr', 'prq', 'rqp'], 'ppp']]", "qwen2.5-coder-32b-instruct": "[[['abc', 'aaa', 'aba', 'bab'], 'bbb'], [['abc', 'abc', 'abc'], 'abc'], [['xyz', 'zyx', 'zzz'], 'zzz'], [['a', 'b'], 'a'], [['ab', 'ba', 'aa'], 'aa'], [['aaa', 'bbb', 'ccc'], 'abc'], [['aaaa', 'bbbb', 'cccc'], 'abac'], [['same', 'same', 'diff'], 'same'], [['one', 'two', 'three'], 'two'], [['aaaaa', 'bbbbb', 'ccccc', 'ddddd'], 'abcde']]"}}
{"requirement": "def how_many_times(annual_price: float, individual_price: float) -> int:\n\"\"\"Lot of museum allow you to be a member, for a certain amount `amount_by_year` you can have unlimitted acces to the museum. \n\nIn this kata you should complete a function in order to know after how many visit it will be better to take an annual pass. The function take 2 arguments `annual_price` and `individual_price`.\n\"\"\"", "inputs": [[40, 15], [30, 10], [80, 15]], "outputs": [[3], [3], [6]], "starter_code": "def how_many_times(annual_price: float, individual_price: float) -> int:", "canonical_solution": "from math import ceil\nfrom operator import truediv\n\ndef how_many_times(annual_price, individual_price):\n    return int(ceil(truediv(annual_price, individual_price)))", "entry_point": "how_many_times", "task_id": "TACO_lite/518", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[50.0, 10.0], [100.0, 20.0], [0.0, 10.0], [50.0, 0.0], [50.0, 50.0], [50.0, 100.0], [100.0, 100.0], [0.0, 0.0]]", "qwen2.5-coder-32b-instruct": "[[100.0, 10.0], [50.0, 15.0], [200.0, 5.0], [0.0, 10.0], [100.0, 0.0], [100.0, 100.0], [1.0, 0.5], [1000.0, 100.0], [10.0, 10.0], [99.99, 33.34]]"}}
{"requirement": "def year_days(year: int) -> str:\n\"\"\"A variation of determining leap years, assuming only integers are used and years can be negative and positive.\n\nWrite a function which will return the days in the year and the year entered in a string.  For example 2000, entered as an integer, will return as a string 2000 has 366 days\n\nThere are a few assumptions we will accept the year 0, even though there is no year 0 in the Gregorian Calendar.\n\nAlso the basic rule for validating a leap year are as follows\n\nMost years that can be divided evenly by 4 are leap years. \n\nException: Century years are NOT leap years UNLESS they can be evenly divided by 400.\n\nSo the years 0, -64 and 2016 will return 366 days.\nWhilst 1974, -10 and 666 will return 365 days.\n\"\"\"", "inputs": [[0], [-64], [2016], [1974], [-10], [666], [1857], [2000], [-300], [-1]], "outputs": [["0 has 366 days"], ["-64 has 366 days"], ["2016 has 366 days"], ["1974 has 365 days"], ["-10 has 365 days"], ["666 has 365 days"], ["1857 has 365 days"], ["2000 has 366 days"], ["-300 has 365 days"], ["-1 has 365 days"]], "starter_code": "def year_days(year: int) -> str:", "canonical_solution": "def year_days(year):\n    days = 365\n    if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n        days += 1\n    return '%d has %d days' % (year, days)", "entry_point": "year_days", "task_id": "TACO_lite/536", "input_output_examples": "[[[2000], [0], [-64], [2016], [1974], [-10], [666]], [['2000 has 366 days'], ['0 has 366 days'], ['-64 has 366 days'], ['2016 has 366 days'], ['1974 has 365 days'], ['-10 has 365 days'], ['666 has 365 days']]]", "llm_generated_inputs": {"deepseek-v3": "[[2000], [1900], [2016], [1974], [0], [-64], [-10], [666], [1600], [1700], [1800], [2004], [2020], [2100], [2400]]", "qwen2.5-coder-32b-instruct": "[[2000], [-64], [2016], [1974], [-10], [666], [0], [100], [400], [1800], [2100], [2400]]"}}
{"requirement": "def fit_in(a: int, b: int, m: int, n: int) -> bool:\n\"\"\"Mr. Square is going on a holiday. He wants to bring 2 of his favorite squares with him, so he put them in his rectangle suitcase.\n\nWrite a function that, given the size of the squares and the suitcase, return whether the squares can fit inside the suitcase.\n```Python\nfit_in(a,b,m,n)\na,b are the sizes of the 2 squares\nm,n are the sizes of the suitcase\n```\n\n# Example\n```Python\nfit_in(1,2,3,2) should return True\nfit_in(1,2,2,1) should return False\nfit_in(3,2,3,2) should return False\nfit_in(1,2,1,2) should return False\n```\n\"\"\"", "inputs": [[1, 2, 3, 2], [1, 2, 2, 1], [3, 2, 3, 2], [1, 2, 1, 2], [6, 5, 8, 7], [6, 6, 12, 6], [7, 1, 7, 8], [10, 10, 11, 11], [7, 2, 9, 7], [7, 2, 8, 7], [4, 1, 5, 3], [1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], [3, 2, 1, 4], [3, 2, 4, 1], [3, 1, 2, 4], [3, 1, 4, 2], [3, 4, 2, 1], [3, 4, 1, 2], [4, 2, 3, 1], [4, 2, 1, 3], [4, 3, 2, 1], [4, 3, 1, 2], [4, 1, 2, 3], [4, 1, 3, 2]], "outputs": [[true], [false], [false], [false], [false], [true], [true], [false], [true], [false], [false], [true], [true], [false], [false], [false], [false], [true], [true], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false]], "starter_code": "def fit_in(a: int, b: int, m: int, n: int) -> bool:", "canonical_solution": "def fit_in(a, b, m, n):\n    return max(a, b) <= min(m, n) and a + b <= max(m, n)", "entry_point": "fit_in", "task_id": "TACO_lite/537", "input_output_examples": "[[[1, 2, 3, 2], [1, 2, 2, 1], [3, 2, 3, 2], [1, 2, 1, 2]], [[True], [False], [False], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 2, 3, 2], [1, 2, 2, 1], [3, 2, 3, 2], [1, 2, 1, 2], [2, 2, 4, 4], [2, 3, 5, 3], [1, 1, 1, 1], [0, 0, 0, 0], [2, 2, 3, 3], [3, 3, 2, 2], [4, 2, 5, 3], [2, 4, 3, 5], [1, 3, 4, 3], [3, 1, 3, 4], [5, 5, 10, 10], [5, 5, 5, 5]]", "qwen2.5-coder-32b-instruct": "[[1, 2, 3, 2], [1, 2, 2, 1], [3, 2, 3, 2], [1, 2, 1, 2], [1, 1, 1, 1], [2, 2, 4, 4], [2, 2, 3, 3], [2, 2, 2, 3], [5, 5, 10, 10], [5, 5, 9, 9], [0, 0, 1, 1], [1, 0, 1, 1], [0, 1, 1, 1], [1, 1, 0, 0], [1, 1, -1, -1], [-1, -1, 1, 1]]"}}
{"requirement": "from typing import List\nfrom typing import List\n\n\ndef shades_of_grey(n: int) -> List[str]:\n\"\"\"Why would we want to stop to only 50 shades of grey? Let's see to how many we can go. \n\nWrite a function that takes a number n as a parameter and return an array containing n shades of grey in hexadecimal code (`#aaaaaa` for example). The array should be sorted in ascending order starting with `#010101`, `#020202`, etc. (using lower case letters).\n\n```python\ndef shades_of_grey(n: int) -> List[str]:\n  return '''n shades of grey in an array'''\n```\n\nAs a reminder, the grey color is composed by the same number of red, green and blue: `#010101`, `#aeaeae`, `#555555`, etc. Also, `#000000` and `#ffffff` are not accepted values.\n\nWhen n is negative, just return an empty array.\nIf n is higher than 254, just return an array of 254 elements.\n\nHave fun\n\"\"\"", "inputs": [[-1], [0], [1], [254], [5000]], "outputs": [[[]], [[]], [["#010101"]], [["#010101", "#020202", "#030303", "#040404", "#050505", "#060606", "#070707", "#080808", "#090909", "#0a0a0a", "#0b0b0b", "#0c0c0c", "#0d0d0d", "#0e0e0e", "#0f0f0f", "#101010", "#111111", "#121212", "#131313", "#141414", "#151515", "#161616", "#171717", "#181818", "#191919", "#1a1a1a", "#1b1b1b", "#1c1c1c", "#1d1d1d", "#1e1e1e", "#1f1f1f", "#202020", "#212121", "#222222", "#232323", "#242424", "#252525", "#262626", "#272727", "#282828", "#292929", "#2a2a2a", "#2b2b2b", "#2c2c2c", "#2d2d2d", "#2e2e2e", "#2f2f2f", "#303030", "#313131", "#323232", "#333333", "#343434", "#353535", "#363636", "#373737", "#383838", "#393939", "#3a3a3a", "#3b3b3b", "#3c3c3c", "#3d3d3d", "#3e3e3e", "#3f3f3f", "#404040", "#414141", "#424242", "#434343", "#444444", "#454545", "#464646", "#474747", "#484848", "#494949", "#4a4a4a", "#4b4b4b", "#4c4c4c", "#4d4d4d", "#4e4e4e", "#4f4f4f", "#505050", "#515151", "#525252", "#535353", "#545454", "#555555", "#565656", "#575757", "#585858", "#595959", "#5a5a5a", "#5b5b5b", "#5c5c5c", "#5d5d5d", "#5e5e5e", "#5f5f5f", "#606060", "#616161", "#626262", "#636363", "#646464", "#656565", "#666666", "#676767", "#686868", "#696969", "#6a6a6a", "#6b6b6b", "#6c6c6c", "#6d6d6d", "#6e6e6e", "#6f6f6f", "#707070", "#717171", "#727272", "#737373", "#747474", "#757575", "#767676", "#777777", "#787878", "#797979", "#7a7a7a", "#7b7b7b", "#7c7c7c", "#7d7d7d", "#7e7e7e", "#7f7f7f", "#808080", "#818181", "#828282", "#838383", "#848484", "#858585", "#868686", "#878787", "#888888", "#898989", "#8a8a8a", "#8b8b8b", "#8c8c8c", "#8d8d8d", "#8e8e8e", "#8f8f8f", "#909090", "#919191", "#929292", "#939393", "#949494", "#959595", "#969696", "#979797", "#989898", "#999999", "#9a9a9a", "#9b9b9b", "#9c9c9c", "#9d9d9d", "#9e9e9e", "#9f9f9f", "#a0a0a0", "#a1a1a1", "#a2a2a2", "#a3a3a3", "#a4a4a4", "#a5a5a5", "#a6a6a6", "#a7a7a7", "#a8a8a8", "#a9a9a9", "#aaaaaa", "#ababab", "#acacac", "#adadad", "#aeaeae", "#afafaf", "#b0b0b0", "#b1b1b1", "#b2b2b2", "#b3b3b3", "#b4b4b4", "#b5b5b5", "#b6b6b6", "#b7b7b7", "#b8b8b8", "#b9b9b9", "#bababa", "#bbbbbb", "#bcbcbc", "#bdbdbd", "#bebebe", "#bfbfbf", "#c0c0c0", "#c1c1c1", "#c2c2c2", "#c3c3c3", "#c4c4c4", "#c5c5c5", "#c6c6c6", "#c7c7c7", "#c8c8c8", "#c9c9c9", "#cacaca", "#cbcbcb", "#cccccc", "#cdcdcd", "#cecece", "#cfcfcf", "#d0d0d0", "#d1d1d1", "#d2d2d2", "#d3d3d3", "#d4d4d4", "#d5d5d5", "#d6d6d6", "#d7d7d7", "#d8d8d8", "#d9d9d9", "#dadada", "#dbdbdb", "#dcdcdc", "#dddddd", "#dedede", "#dfdfdf", "#e0e0e0", "#e1e1e1", "#e2e2e2", "#e3e3e3", "#e4e4e4", "#e5e5e5", "#e6e6e6", "#e7e7e7", "#e8e8e8", "#e9e9e9", "#eaeaea", "#ebebeb", "#ececec", "#ededed", "#eeeeee", "#efefef", "#f0f0f0", "#f1f1f1", "#f2f2f2", "#f3f3f3", "#f4f4f4", "#f5f5f5", "#f6f6f6", "#f7f7f7", "#f8f8f8", "#f9f9f9", "#fafafa", "#fbfbfb", "#fcfcfc", "#fdfdfd", "#fefefe"]], [["#010101", "#020202", "#030303", "#040404", "#050505", "#060606", "#070707", "#080808", "#090909", "#0a0a0a", "#0b0b0b", "#0c0c0c", "#0d0d0d", "#0e0e0e", "#0f0f0f", "#101010", "#111111", "#121212", "#131313", "#141414", "#151515", "#161616", "#171717", "#181818", "#191919", "#1a1a1a", "#1b1b1b", "#1c1c1c", "#1d1d1d", "#1e1e1e", "#1f1f1f", "#202020", "#212121", "#222222", "#232323", "#242424", "#252525", "#262626", "#272727", "#282828", "#292929", "#2a2a2a", "#2b2b2b", "#2c2c2c", "#2d2d2d", "#2e2e2e", "#2f2f2f", "#303030", "#313131", "#323232", "#333333", "#343434", "#353535", "#363636", "#373737", "#383838", "#393939", "#3a3a3a", "#3b3b3b", "#3c3c3c", "#3d3d3d", "#3e3e3e", "#3f3f3f", "#404040", "#414141", "#424242", "#434343", "#444444", "#454545", "#464646", "#474747", "#484848", "#494949", "#4a4a4a", "#4b4b4b", "#4c4c4c", "#4d4d4d", "#4e4e4e", "#4f4f4f", "#505050", "#515151", "#525252", "#535353", "#545454", "#555555", "#565656", "#575757", "#585858", "#595959", "#5a5a5a", "#5b5b5b", "#5c5c5c", "#5d5d5d", "#5e5e5e", "#5f5f5f", "#606060", "#616161", "#626262", "#636363", "#646464", "#656565", "#666666", "#676767", "#686868", "#696969", "#6a6a6a", "#6b6b6b", "#6c6c6c", "#6d6d6d", "#6e6e6e", "#6f6f6f", "#707070", "#717171", "#727272", "#737373", "#747474", "#757575", "#767676", "#777777", "#787878", "#797979", "#7a7a7a", "#7b7b7b", "#7c7c7c", "#7d7d7d", "#7e7e7e", "#7f7f7f", "#808080", "#818181", "#828282", "#838383", "#848484", "#858585", "#868686", "#878787", "#888888", "#898989", "#8a8a8a", "#8b8b8b", "#8c8c8c", "#8d8d8d", "#8e8e8e", "#8f8f8f", "#909090", "#919191", "#929292", "#939393", "#949494", "#959595", "#969696", "#979797", "#989898", "#999999", "#9a9a9a", "#9b9b9b", "#9c9c9c", "#9d9d9d", "#9e9e9e", "#9f9f9f", "#a0a0a0", "#a1a1a1", "#a2a2a2", "#a3a3a3", "#a4a4a4", "#a5a5a5", "#a6a6a6", "#a7a7a7", "#a8a8a8", "#a9a9a9", "#aaaaaa", "#ababab", "#acacac", "#adadad", "#aeaeae", "#afafaf", "#b0b0b0", "#b1b1b1", "#b2b2b2", "#b3b3b3", "#b4b4b4", "#b5b5b5", "#b6b6b6", "#b7b7b7", "#b8b8b8", "#b9b9b9", "#bababa", "#bbbbbb", "#bcbcbc", "#bdbdbd", "#bebebe", "#bfbfbf", "#c0c0c0", "#c1c1c1", "#c2c2c2", "#c3c3c3", "#c4c4c4", "#c5c5c5", "#c6c6c6", "#c7c7c7", "#c8c8c8", "#c9c9c9", "#cacaca", "#cbcbcb", "#cccccc", "#cdcdcd", "#cecece", "#cfcfcf", "#d0d0d0", "#d1d1d1", "#d2d2d2", "#d3d3d3", "#d4d4d4", "#d5d5d5", "#d6d6d6", "#d7d7d7", "#d8d8d8", "#d9d9d9", "#dadada", "#dbdbdb", "#dcdcdc", "#dddddd", "#dedede", "#dfdfdf", "#e0e0e0", "#e1e1e1", "#e2e2e2", "#e3e3e3", "#e4e4e4", "#e5e5e5", "#e6e6e6", "#e7e7e7", "#e8e8e8", "#e9e9e9", "#eaeaea", "#ebebeb", "#ececec", "#ededed", "#eeeeee", "#efefef", "#f0f0f0", "#f1f1f1", "#f2f2f2", "#f3f3f3", "#f4f4f4", "#f5f5f5", "#f6f6f6", "#f7f7f7", "#f8f8f8", "#f9f9f9", "#fafafa", "#fbfbfb", "#fcfcfc", "#fdfdfd", "#fefefe"]]], "starter_code": "from typing import List\ndef shades_of_grey(n: int) -> List[str]:", "canonical_solution": "def shades_of_grey(n):\n    if n > 254:\n        n = 254\n    return ['#%02x%02x%02x' % (i, i, i) for i in range(1, n + 1)]", "entry_point": "shades_of_grey", "task_id": "TACO_lite/539", "input_output_examples": "[[[1], [3], [255], [-1]], [[['#010101']], [['#010101', '#020202', '#030303']], [['#010101', '#020202', '#030303', '#040404', '#050505', '#060606', '#070707', '#080808', '#090909', '#0a0a0a', '#0b0b0b', '#0c0c0c', '#0d0d0d', '#0e0e0e', '#0f0f0f', '#101010', '#111111', '#121212', '#131313', '#141414', '#151515', '#161616', '#171717', '#181818', '#191919', '#1a1a1a', '#1b1b1b', '#1c1c1c', '#1d1d1d', '#1e1e1e', '#1f1f1f', '#202020', '#212121', '#222222', '#232323', '#242424', '#252525', '#262626', '#272727', '#282828', '#292929', '#2a2a2a', '#2b2b2b', '#2c2c2c', '#2d2d2d', '#2e2e2e', '#2f2f2f', '#303030', '#313131', '#323232', '#333333', '#343434', '#353535', '#363636', '#373737', '#383838', '#393939', '#3a3a3a', '#3b3b3b', '#3c3c3c', '#3d3d3d', '#3e3e3e', '#3f3f3f', '#404040', '#414141', '#424242', '#434343', '#444444', '#454545', '#464646', '#474747', '#484848', '#494949', '#4a4a4a', '#4b4b4b', '#4c4c4c', '#4d4d4d', '#4e4e4e', '#4f4f4f', '#505050', '#515151', '#525252', '#535353', '#545454', '#555555', '#565656', '#575757', '#585858', '#595959', '#5a5a5a', '#5b5b5b', '#5c5c5c', '#5d5d5d', '#5e5e5e', '#5f5f5f', '#606060', '#616161', '#626262', '#636363', '#646464', '#656565', '#666666', '#676767', '#686868', '#696969', '#6a6a6a', '#6b6b6b', '#6c6c6c', '#6d6d6d', '#6e6e6e', '#6f6f6f', '#707070', '#717171', '#727272', '#737373', '#747474', '#757575', '#767676', '#777777', '#787878', '#797979', '#7a7a7a', '#7b7b7b', '#7c7c7c', '#7d7d7d', '#7e7e7e', '#7f7f7f', '#808080', '#818181', '#828282', '#838383', '#848484', '#858585', '#868686', '#878787', '#888888', '#898989', '#8a8a8a', '#8b8b8b', '#8c8c8c', '#8d8d8d', '#8e8e8e', '#8f8f8f', '#909090', '#919191', '#929292', '#939393', '#949494', '#959595', '#969696', '#979797', '#989898', '#999999', '#9a9a9a', '#9b9b9b', '#9c9c9c', '#9d9d9d', '#9e9e9e', '#9f9f9f', '#a0a0a0', '#a1a1a1', '#a2a2a2', '#a3a3a3', '#a4a4a4', '#a5a5a5', '#a6a6a6', '#a7a7a7', '#a8a8a8', '#a9a9a9', '#aaaaaa', '#ababab', '#acacac', '#adadad', '#aeaeae', '#afafaf', '#b0b0b0', '#b1b1b1', '#b2b2b2', '#b3b3b3', '#b4b4b4', '#b5b5b5', '#b6b6b6', '#b7b7b7', '#b8b8b8', '#b9b9b9', '#bababa', '#bbbbbb', '#bcbcbc', '#bdbdbd', '#bebebe', '#bfbfbf', '#c0c0c0', '#c1c1c1', '#c2c2c2', '#c3c3c3', '#c4c4c4', '#c5c5c5', '#c6c6c6', '#c7c7c7', '#c8c8c8', '#c9c9c9', '#cacaca', '#cbcbcb', '#cccccc', '#cdcdcd', '#cecece', '#cfcfcf', '#d0d0d0', '#d1d1d1', '#d2d2d2', '#d3d3d3', '#d4d4d4', '#d5d5d5', '#d6d6d6', '#d7d7d7', '#d8d8d8', '#d9d9d9', '#dadada', '#dbdbdb', '#dcdcdc', '#dddddd', '#dedede', '#dfdfdf', '#e0e0e0', '#e1e1e1', '#e2e2e2', '#e3e3e3', '#e4e4e4', '#e5e5e5', '#e6e6e6', '#e7e7e7', '#e8e8e8', '#e9e9e9', '#eaeaea', '#ebebeb', '#ececec', '#ededed', '#eeeeee', '#efefef', '#f0f0f0', '#f1f1f1', '#f2f2f2', '#f3f3f3', '#f4f4f4', '#f5f5f5', '#f6f6f6', '#f7f7f7', '#f8f8f8', '#f9f9f9', '#fafafa', '#fbfbfb', '#fcfcfc', '#fdfdfd', '#fefefe']], [[]]]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [5], [254], [255], [-1], [10], [100], [300]]", "qwen2.5-coder-32b-instruct": "[[-5], [0], [1], [2], [10], [253], [254], [255], [300]]"}}
{"requirement": "from typing import List\n\n\ndef count_paths(n: int, c: List[int]) -> int:\n\"\"\"Happy traveller [Part 1]\n\nThere is a play grid NxN; Always square! \n\n   0  1  2  3\n0 [o, o, o, X]\n1 [o, o, o, o]\n2 [o, o, o, o]\n3 [o, o, o, o]\n\n\nYou start from a random point. I mean, you are given the coordinates of your start position in format (row, col). \n\nAnd your TASK is to define the number of unique paths to reach position X (always in the top right corner).\n\n\nFrom any point you can go only UP or RIGHT.\n\n\nImplement a function count_paths(N, (row, col)) which returns int; \nAssume input params are always valid.\n\n\nExample:\n\ncount_paths(1, (0, 0))\ngrid 1x1:\n\n[X]\n You are already in the target point, so return 0\n\n\ncount_paths(2, (1, 0))\ngrid 2x2:\n\n[o, X]\n[@, o]\n You are at point @; you can move UP-RIGHT or RIGHT-UP, and there are 2 possible unique paths here\n\ncount_paths(2, (1, 1))\ngrid 2x2:\n\n[o, X]\n[o, @]\n You are at point @; you can move only UP, so there is 1 possible unique path here\n\ncount_paths(3, (1, 0))\ngrid 3x3:\n\n[o, o, X]\n[@, o, o]\n[o, o, o]\n You are at point @; you can move UP-RIGHT-RIGHT or RIGHT-UP-RIGHT, or RIGHT-RIGHT-UP, and there are 3 possible unique paths here\n\n\nI think it's pretty clear =)\n\nbtw. you can use preloaded Grid class, which constructs 2d array for you. It's very very basic and simple. You can use numpy instead or any other way to produce the correct answer =)\n grid = Grid(2, 2, 0) \nsamegrid = Grid.square(2) will give you a grid[2][2], which you can print easily to console. \n\nprint(grid)\n\n\n[0, 0]\n[0, 0]\n\n\nEnjoy!\n\nYou can continue adventures:\nHappy traveller [Part 2]\n\"\"\"", "inputs": [[1, [0, 0]], [2, [1, 0]], [2, [1, 1]], [3, [1, 0]], [5, [4, 0]], [6, [5, 0]], [7, [6, 0]]], "outputs": [[0], [2], [1], [3], [70], [252], [924]], "starter_code": "from typing import List\ndef count_paths(n: int, c: List[int]) -> int:", "canonical_solution": "from math import factorial as f\ncount_paths = lambda n, c: f(c[0] + abs(n - c[1] - 1)) // (f(abs(n - c[1] - 1)) * f(c[0])) if n != 1 else 0", "entry_point": "count_paths", "task_id": "TACO_lite/545", "input_output_examples": "[[[1, [0, 0]], [2, [1, 0]], [2, [1, 1]], [3, [1, 0]]], [[0], [2], [1], [3]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, (0, 0)], [2, (1, 0)], [2, (1, 1)], [3, (1, 0)], [3, (0, 1)], [4, (0, 0)], [4, (2, 2)], [4, (3, 0)], [5, (4, 4)], [5, (2, 3)]]", "qwen2.5-coder-32b-instruct": "[[1, (0, 0)], [2, (1, 0)], [2, (1, 1)], [3, (1, 0)], [3, (2, 0)], [3, (2, 1)], [4, (3, 0)], [4, (3, 1)], [4, (3, 2)], [5, (4, 0)], [5, (4, 1)], [5, (4, 2)], [5, (4, 3)], [6, (5, 0)], [6, (5, 1)], [6, (5, 2)], [6, (5, 3)], [6, (5, 4)], [10, (9, 0)], [10, (9, 1)], [10, (9, 2)], [10, (9, 3)], [10, (9, 4)], [10, (9, 5)], [10, (9, 6)], [10, (9, 7)], [10, (9, 8)]]"}}
{"requirement": "from typing import List\n\n\ndef symmetric_point(p: List[int], q: List[int]) -> List[int]:\n\"\"\"\"Point reflection\" or \"point symmetry\" is a basic concept in geometry where a given point, P, at a given position relative to a mid-point, Q has a corresponding point, P1, which is the same distance from Q but in the opposite direction.\n\n## Task\n\nGiven two points P and Q, output the symmetric point of point P about Q.\nEach argument is a two-element array of integers representing the point's X and Y coordinates.  Output should be in the same format, giving the X and Y coordinates of point P1.  You do not have to validate the input.\n\nThis kata was inspired by the Hackerrank challenge [Find Point](https://www.hackerrank.com/challenges/find-point)\n\"\"\"", "inputs": [[[0, 0], [1, 1]], [[2, 6], [-2, -6]], [[10, -10], [-10, 10]], [[1, -35], [-12, 1]], [[1000, 15], [-7, -214]], [[0, 0], [0, 0]]], "outputs": [[[2, 2]], [[-6, -18]], [[-30, 30]], [[-25, 37]], [[-1014, -443]], [[0, 0]]], "starter_code": "from typing import List\ndef symmetric_point(p: List[int], q: List[int]) -> List[int]:", "canonical_solution": "def symmetric_point(p, q):\n    return [2 * q[0] - p[0], 2 * q[1] - p[1]]", "entry_point": "symmetric_point", "task_id": "TACO_lite/550", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 1], [2, 2]], [[0, 0], [0, 0]], [[-3, -4], [1, 1]], [[5, 7], [-2, -3]], [[10, 20], [5, 10]], [[-1, -1], [1, 1]], [[100, 200], [50, 100]], [[0, 0], [1, 1]], [[3, 4], [3, 4]], [[-5, -5], [0, 0]]]", "qwen2.5-coder-32b-instruct": "[[[0, 0], [1, 1]], [[2, 3], [5, 5]], [[1, 1], [1, 1]], [[0, 0], [0, 0]], [[-1, -1], [0, 0]], [[10, 10], [-10, -10]], [[100, 200], [50, 50]], [[1, 2], [3, 4]], [[5, 6], [3, 3]], [[7, 8], [7, 8]]]"}}
{"requirement": "from typing import List\nfrom typing import Union\n\n\ndef find_slope(points: List[int]) -> Union[str, int]:\n\"\"\"Given an array of 4 integers  \n```[a,b,c,d]``` representing two points ```(a, b)``` and ```(c, d)```, return a string representation of the slope of the line joining these two points. \n\nFor an undefined slope (division by 0), return  ```undefined```  . Note that the \"undefined\" is case-sensitive.\n```\n   a:x1\n   b:y1\n   c:x2\n   d:y2\n```\n   \nAssume that ```[a,b,c,d]``` and the answer are all integers \n(no floating numbers!).\nSlope:\n\"\"\"", "inputs": [[[12, -18, -15, -18]], [[3, -20, 5, 8]], [[17, -3, 17, 8]], [[1, -19, -2, -7]], [[19, 3, 20, 3]], [[6, -12, 15, -3]], [[15, -3, 15, -3]], [[9, 3, 19, -17]], [[3, 6, 4, 10]], [[2, 7, 4, -7]], [[1, 24, 2, 88]], [[4, 384, 8, 768]], [[4, 16, 4, 18]], [[7, 28, 9, 64]], [[18, -36, 12, 36]], [[36, 580, 42, 40]], [[1, 2, 2, 6]], [[-6, 57, -6, 84]], [[92, 12, 96, 64]], [[90, 54, 90, 2]], [[3, 6, 4, 9]], [[-2, -5, 2, 3]], [[3, 3, 2, 0]]], "outputs": [["0"], ["14"], ["undefined"], ["-4"], ["0"], ["1"], ["undefined"], ["-2"], ["4"], ["-7"], ["64"], ["96"], ["undefined"], ["18"], ["-12"], ["-90"], ["4"], ["undefined"], ["13"], ["undefined"], ["3"], ["2"], ["3"]], "starter_code": "from typing import List\nfrom typing import Union\ndef find_slope(points: List[int]) -> Union[str, int]:", "canonical_solution": "def find_slope(points):\n    x1, y1, x2, y2 = points\n    if x2 - x1 == 0:\n        return 'undefined'\n    return str((y2 - y1) // (x2 - x1))", "entry_point": "find_slope", "task_id": "TACO_lite/552", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4]], [[2, 3, 2, 5]], [[0, 0, 0, 0]], [[-1, -2, -3, -4]], [[5, 10, 15, 20]], [[1, 1, 2, 2]], [[10, 20, 10, 30]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 4]], [[0, 0, 1, 1]], [[1, 1, 1, 1]], [[1, 2, 1, 3]], [[2, 3, 5, 3]], [[-1, -2, -3, -4]], [[0, 0, 0, 0]], [[10, 20, 30, 40]], [[5, 5, 10, 10]]]"}}
{"requirement": "def search_substr(full_text: str, search_text: str, allow_overlap: bool = True) -> int:\n\"\"\"Complete the solution so that it returns the number of times the search_text is found within the full_text.\n\n```python\nsearch_substr( fullText, searchText, allowOverlap = true )\n```\n\nso that overlapping solutions are (not) counted. If the searchText is empty, it should return `0`. Usage examples:\n\n```python\nsearch_substr('aa_bb_cc_dd_bb_e', 'bb') # should return 2 since bb shows up twice\nsearch_substr('aaabbbcccc', 'bbb') # should return 1\nsearch_substr( 'aaa', 'aa' ) # should return 2\nsearch_substr( 'aaa', '' ) # should return 0\nsearch_substr( 'aaa', 'aa', false ) # should return 1\n```\n\"\"\"", "inputs": [["aa_bb_cc_dd_bb_e", "bb"], ["aaabbbcccc", "bbb"], ["aaacccbbbcccc", "cc"], ["aaa", "aa"], ["aaa", "aa", false], ["aaabbbaaa", "bb", false], ["a", ""], ["", "a"], ["", ""], ["", "", false]], "outputs": [[2], [1], [5], [2], [1], [1], [0], [0], [0], [0]], "starter_code": "def search_substr(full_text: str, search_text: str, allow_overlap: bool = True) -> int:", "canonical_solution": "import re\n\ndef search_substr(full_text, search_text, allow_overlap=True):\n    if not full_text or not search_text:\n        return 0\n    return len(re.findall(f'(?=({search_text}))' if allow_overlap else search_text, full_text))", "entry_point": "search_substr", "task_id": "TACO_lite/554", "input_output_examples": "[[[['aa_bb_cc_dd_bb_e', 'bb']], ['aaabbbcccc', 'bbb'], ['aaa', 'aa'], [['aaa', '']], ['aaa', 'aa', False]], [[2], [1], [2], [[0]], [1]]]", "llm_generated_inputs": {"deepseek-v3": "[['aa_bb_cc_dd_bb_e', 'bb', True], ['aaabbbcccc', 'bbb', True], ['aaa', 'aa', True], ['aaa', '', True], ['aaa', 'aa', False], ['abababab', 'aba', True], ['abababab', 'aba', False], ['', 'abc', True], ['abcabcabc', 'abc', True], ['abcabcabc', 'abc', False], ['xyzxyzxyz', 'xyz', True], ['xyzxyzxyz', 'xyz', False], ['aaaaa', 'aa', True], ['aaaaa', 'aa', False], ['aabbcc', 'bb', True], ['aabbcc', 'bb', False]]", "qwen2.5-coder-32b-instruct": "[['aa_bb_cc_dd_bb_e', 'bb', True], ['aaabbbcccc', 'bbb', True], ['aaa', 'aa', True], ['aaa', '', True], ['aaa', 'aa', False], ['aaaa', 'aa', True], ['aaaa', 'aa', False], ['abc', 'd', True], ['abc', 'd', False], ['', 'a', True], ['', 'a', False], ['abcabcabc', 'abc', True], ['abcabcabc', 'abc', False], ['ababababa', 'aba', True], ['ababababa', 'aba', False]]"}}
{"requirement": "def mn_lcm(m: int, n: int) -> int:\n\"\"\"# Task\n Your task is to find the smallest number which is evenly divided by all numbers between `m` and `n` (both inclusive).\n\n# Example\n\n For `m = 1, n = 2`, the output should be `2`.\n \n For `m = 2, n = 3`, the output should be `6`.\n \n For `m = 3, n = 2`, the output should be `6` too.\n \n For `m = 1, n = 10`, the output should be `2520`.\n\n# Input/Output\n\n\n - `[input]` integer `m`\n\n  `1 ≤ m ≤ 25`\n\n\n - `[input]` integer `n`\n\n  `1 ≤ n ≤ 25`\n\n\n - `[output]` an integer\n\"\"\"", "inputs": [[1, 2], [1, 5], [5, 1], [1, 10], [2, 3], [3, 5], [10, 20], [1, 25], [24, 25]], "outputs": [[2], [60], [60], [2520], [6], [60], [232792560], [26771144400], [600]], "starter_code": "def mn_lcm(m: int, n: int) -> int:", "canonical_solution": "def gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\ndef mn_lcm(m, n):\n    if n < m:\n        m, n = (n, m)\n    ans = m\n    for i in range(m, n + 1):\n        ans = i * ans / gcd(i, ans)\n    return ans", "entry_point": "mn_lcm", "task_id": "TACO_lite/579", "input_output_examples": "[[[1, 2], [2, 3], [3, 2], [1, 10]], [[2], [6], [6], [2520]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 2], [2, 3], [3, 2], [1, 10], [5, 5], [1, 1], [10, 20], [20, 10], [15, 25], [25, 15]]", "qwen2.5-coder-32b-instruct": "[[1, 2], [2, 3], [3, 2], [1, 10], [10, 1], [5, 5], [2, 5], [1, 1], [20, 25], [15, 20]]"}}
{"requirement": "from typing import List\n\n\ndef array_plus_array(arr1: List[int], arr2: List[int]) -> int:\n\"\"\"I'm new to coding and now I want to get the sum of two arrays...actually the sum of all their elements. I'll appreciate for your help.\n\nP.S. Each array includes only integer numbers. Output is a number too.\n\"\"\"", "inputs": [[[1, 2, 3], [4, 5, 6]], [[-1, -2, -3], [-4, -5, -6]], [[0, 0, 0], [4, 5, 6]], [[100, 200, 300], [400, 500, 600]]], "outputs": [[21], [-21], [15], [2100]], "starter_code": "from typing import List\ndef array_plus_array(arr1: List[int], arr2: List[int]) -> int:", "canonical_solution": "def array_plus_array(arr1, arr2):\n    return sum(arr1 + arr2)", "entry_point": "array_plus_array", "task_id": "TACO_lite/588", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3], [4, 5, 6]], [[-1, -2, -3], [-4, -5, -6]], [[0, 0, 0], [0, 0, 0]], [[10], [20]], [[], [1, 2, 3]], [[1, 2, 3], []], [[], []], [[1000000, 2000000], [3000000, 4000000]], [[-1, 1], [1, -1]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3], [4, 5, 6]], [[0, 0, 0], [0, 0, 0]], [[-1, -2, -3], [-4, -5, -6]], [[100, 200, 300], [400, 500, 600]], [[1], [1]], [[], []], [[10], [-10]], [[1000000], [1000000]]]"}}
{"requirement": "from typing import List\n\n\ndef bits_battle(nums: List[int]) -> str:\n\"\"\"The odd and even numbers are fighting against each other!\n\nYou are given a list of positive integers. The odd numbers from the list will fight using their `1` bits from their binary representation, while the even numbers will fight using their `0` bits. If present in the list, number `0` will be neutral, hence not fight for either side.\n\nYou should return:\n\n* `odds win` if number of `1`s from odd numbers is larger than `0`s from even numbers\n* `evens win` if number of `1`s from odd numbers is smaller than `0`s from even numbers\n* `tie` if equal, including if list is empty\n\nPlease note that any prefix that might appear in the binary representation, e.g. `0b`, should not be counted towards the battle.\n\n### Example:\nFor an input list of `[5, 3, 14]`:\n\n* odds: `5` and `3` => `101` and `11` => four `1`s\n* evens: `14` => `1110` => one `0`\n\nResult: `odds win` the battle with 4-1\n\nIf you enjoyed this kata, you can find a nice variation of it [here](https://www.codewars.com/kata/world-bits-war).\n\"\"\"", "inputs": [[[5, 3, 14]], [[3, 8, 22, 15, 78]], [[]], [[1, 13, 16]]], "outputs": [["odds win"], ["evens win"], ["tie"], ["tie"]], "starter_code": "from typing import List\ndef bits_battle(nums: List[int]) -> str:", "canonical_solution": "def bits_battle(nums):\n    binary = '{:b}'.format\n    evens = odds = 0\n    for num in nums:\n        if num % 2:\n            odds += binary(num).count('1')\n        else:\n            evens += binary(num).count('0')\n    if odds == evens:\n        return 'tie'\n    return '{} win'.format('odds' if odds > evens else 'evens')", "entry_point": "bits_battle", "task_id": "TACO_lite/592", "input_output_examples": "[[[[5, 3, 14]]], [['odds win']]]", "llm_generated_inputs": {"deepseek-v3": "[[[5, 3, 14]], [[1, 2, 3, 4, 5]], [[0, 1, 2, 3, 4, 5]], [[2, 4, 6, 8]], [[1, 3, 5, 7]], [[0, 0, 0]], [[]], [[10, 11, 12, 13]], [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[255, 256, 257]]]", "qwen2.5-coder-32b-instruct": "[[[5, 3, 14]], [[2, 4, 6, 8]], [[1, 1, 1, 1]], [[0, 0, 0]], [[]], [[7, 11, 13]], [[10, 12, 15]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[31, 15, 7, 3, 1]], [[16, 32, 64, 128]]]"}}
{"requirement": "def nba_extrap(ppg: float, mpg: float) -> float:\n\"\"\"An NBA game runs 48 minutes (Four 12 minute quarters). Players do not typically play the full game, subbing in and out as necessary. Your job is to extrapolate a player's points per game if they played the full 48 minutes.\n\nWrite a function that takes two arguments, ppg (points per game) and mpg (minutes per game) and returns a straight extrapolation of ppg per 48 minutes rounded to the nearest tenth. Return 0 if 0.\n\nExamples:\n```python\nnba_extrap(12, 20) # 28.8\nnba_extrap(10, 10) # 48\nnba_extrap(5, 17) # 14.1\nnba_extrap(0, 0) # 0\n```\n\nNotes:\nAll inputs will be either be an integer or float.\nFollow your dreams!\n\"\"\"", "inputs": [[2, 5], [3, 9], [16, 27], [11, 19], [14, 33], [1, 7.5], [6, 13]], "outputs": [[19.2], [16.0], [28.4], [27.8], [20.4], [6.4], [22.2]], "starter_code": "def nba_extrap(ppg: float, mpg: float) -> float:", "canonical_solution": "def nba_extrap(ppg, mpg):\n    return round(48.0 / mpg * ppg, 1) if mpg > 0 else 0", "entry_point": "nba_extrap", "task_id": "TACO_lite/595", "input_output_examples": "[[[12, 20], [10, 10], [5, 17], [0, 0]], [[28.8], [48], [14.1], [0]]]", "llm_generated_inputs": {"deepseek-v3": "[[12, 20], [10, 10], [5, 17], [0, 0], [0, 48], [48, 48], [24, 12], [36, 18], [12.5, 25], [7.3, 14.6], [100, 10], [0.1, 1]]", "qwen2.5-coder-32b-instruct": "[[12, 20], [10, 10], [5, 17], [0, 0], [22, 30], [30, 48], [15, 0], [0, 25], [1.5, 1.5], [48, 48]]"}}
{"requirement": "from typing import List\n\n\ndef absolute_values_sum_minimization(a: List[int]) -> int:\n\"\"\"# Task\n Given a sorted array of integers `A`, find such an integer x that the value of `abs(A[0] - x) + abs(A[1] - x) + ... + abs(A[A.length - 1] - x)`\nis the smallest possible (here abs denotes the `absolute value`).\n\n If there are several possible answers, output the smallest one.\n\n# Example\n\n For `A = [2, 4, 7]`, the output should be `4`.\n\n# Input/Output\n\n\n - `[input]` integer array `A`\n\n    A non-empty array of integers, sorted in ascending order.\n\n    Constraints:\n\n    `1 ≤ A.length ≤ 200,`\n\n    `-1000000 ≤ A[i] ≤ 1000000.`\n\n\n - `[output]` an integer\n\"\"\"", "inputs": [[[2, 4, 7]], [[1, 1, 3, 4]], [[23]], [[-10, -10, -10, -10, -10, -9, -9, -9, -8, -8, -7, -6, -5, -4, -3, -2, -1, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]], [[-4, -1]], [[0, 7, 9]], [[-1000000, -10000, -10000, -1000, -100, -10, -1, 0, 1, 10, 100, 1000, 10000, 100000, 1000000]]], "outputs": [[4], [1], [23], [15], [-4], [7], [0]], "starter_code": "from typing import List\ndef absolute_values_sum_minimization(a: List[int]) -> int:", "canonical_solution": "from statistics import median_low as absolute_values_sum_minimization", "entry_point": "absolute_values_sum_minimization", "task_id": "TACO_lite/599", "input_output_examples": "[[[[2, 4, 7]]], [[4]]]", "llm_generated_inputs": {"deepseek-v3": "[[[2, 4, 7]], [[1, 3, 6, 7]], [[1]], [[0, 0, 0, 0]], [[-1000000, 0, 1000000]], [[-5, -3, -1, 1, 3, 5]], [[10, 20, 30, 40, 50]], [[-10, -20, -30, -40, -50]], [[1, 2, 2, 3, 3, 3, 4]], [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]]", "qwen2.5-coder-32b-instruct": "[[[2, 4, 7]], [[1, 2, 3, 4, 5]], [[1, 1, 1, 1, 1]], [[-10, -5, 0, 5, 10]], [[1]], [[0]], [[-1, 1]], [[-3, -2, -1, 0, 1, 2, 3]], [[1000000]], [[-1000000]], [[-1000000, 1000000]]]"}}
{"requirement": "def self_descriptive(num: int) -> bool:\n\"\"\"A number is self-descriptive when the n'th digit describes the amount n appears in the number.\n\nE.g. 21200:\n\nThere are two 0's in the number, so the first digit is 2.\n\nThere is one 1 in the number, so the second digit is 1.\n\nThere are two 2's in the number, so the third digit is 2.\n\nThere are no 3's in the number, so the fourth digit is 0.\n\nThere are no 4's in the number, so the fifth digit is 0\n\n\nNumbers can be of any length up to 9 digits and are only full integers. For a given number derive a function ```selfDescriptive(num)``` that returns; ```true``` if the number is self-descriptive or ```false``` if the number is not.\n\"\"\"", "inputs": [[21200], [3211000], [42101000], [21230], [11200], [1210], [51120111], [2020], [11201], [6210001000]], "outputs": [[true], [true], [true], [false], [false], [true], [false], [true], [false], [true]], "starter_code": "def self_descriptive(num: int) -> bool:", "canonical_solution": "from collections import Counter\n\ndef self_descriptive(num):\n    s = [int(a) for a in str(num)]\n    cnt = Counter(s)\n    return all((cnt[i] == b for i, b in enumerate(s)))", "entry_point": "self_descriptive", "task_id": "TACO_lite/601", "input_output_examples": "[[[21200]], [[True]]]", "llm_generated_inputs": {"deepseek-v3": "[[21200], [1210], [2020], [3211000], [6210001000], [123456789], [0], [1], [10], [22], [100000000]]", "qwen2.5-coder-32b-instruct": "[[21200], [1210], [2020], [6210001000], [1111111111], [0], [202000], [121000], [122000], [210000], [1000000000], [9876543210], [1234567890]]"}}
{"requirement": "def number2words(n: int) -> str:\n\"\"\"Create a function that transforms any positive number to a string representing the number in words.  The function should work for all numbers between 0 and 999999.\n\n### Examples\n\n```\nnumber2words(0)  ==>  \"zero\"\nnumber2words(1)  ==>  \"one\"\nnumber2words(9)  ==>  \"nine\"\nnumber2words(10)  ==>  \"ten\"\nnumber2words(17)  ==>  \"seventeen\"\nnumber2words(20)  ==>  \"twenty\"\nnumber2words(21)  ==>  \"twenty-one\"\nnumber2words(45)  ==>  \"forty-five\"\nnumber2words(80)  ==>  \"eighty\"\nnumber2words(99)  ==>  \"ninety-nine\"\nnumber2words(100)  ==>  \"one hundred\"\nnumber2words(301)  ==>  \"three hundred one\"\nnumber2words(799)  ==>  \"seven hundred ninety-nine\"\nnumber2words(800)  ==>  \"eight hundred\"\nnumber2words(950)  ==>  \"nine hundred fifty\"\nnumber2words(1000)  ==>  \"one thousand\"\nnumber2words(1002)  ==>  \"one thousand two\"\nnumber2words(3051)  ==>  \"three thousand fifty-one\"\nnumber2words(7200)  ==>  \"seven thousand two hundred\"\nnumber2words(7219)  ==>  \"seven thousand two hundred nineteen\"\nnumber2words(8330)  ==>  \"eight thousand three hundred thirty\"\nnumber2words(99999)  ==>  \"ninety-nine thousand nine hundred ninety-nine\"\nnumber2words(888888)  ==>  \"eight hundred eighty-eight thousand eight hundred eighty-eight\"\n```\n\"\"\"", "inputs": [[0], [1], [8], [5], [9], [10], [19], [20], [22], [54], [80], [98], [100], [301], [793], [800], [650], [1000], [1003], [3052], [7300], [7217], [8340], [99997], [888887]], "outputs": [["zero"], ["one"], ["eight"], ["five"], ["nine"], ["ten"], ["nineteen"], ["twenty"], ["twenty-two"], ["fifty-four"], ["eighty"], ["ninety-eight"], ["one hundred"], ["three hundred one"], ["seven hundred ninety-three"], ["eight hundred"], ["six hundred fifty"], ["one thousand"], ["one thousand three"], ["three thousand fifty-two"], ["seven thousand three hundred"], ["seven thousand two hundred seventeen"], ["eight thousand three hundred forty"], ["ninety-nine thousand nine hundred ninety-seven"], ["eight hundred eighty-eight thousand eight hundred eighty-seven"]], "starter_code": "def number2words(n: int) -> str:", "canonical_solution": "words = 'zero one two three four five six seven eight nine' + ' ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty' + ' thirty forty fifty sixty seventy eighty ninety'\nwords = words.split(' ')\n\ndef number2words(n):\n    if n < 20:\n        return words[n]\n    elif n < 100:\n        return words[18 + n // 10] + ('' if n % 10 == 0 else '-' + words[n % 10])\n    elif n < 1000:\n        return number2words(n // 100) + ' hundred' + (' ' + number2words(n % 100) if n % 100 > 0 else '')\n    elif n < 1000000:\n        return number2words(n // 1000) + ' thousand' + (' ' + number2words(n % 1000) if n % 1000 > 0 else '')", "entry_point": "number2words", "task_id": "TACO_lite/603", "input_output_examples": "[[[0], [1], [9], [10], [17], [20], [21], [45], [80], [99], [100], [301], [799], [800], [950], [1000], [1002], [3051], [7200], [7219], [8330], [99999], [888888]], [['zero'], ['one'], ['nine'], ['ten'], ['seventeen'], ['twenty'], ['twenty-one'], ['forty-five'], ['eighty'], ['ninety-nine'], ['one hundred'], ['three hundred one'], ['seven hundred ninety-nine'], ['eight hundred'], ['nine hundred fifty'], ['one thousand'], ['one thousand two'], ['three thousand fifty-one'], ['seven thousand two hundred'], ['seven thousand two hundred nineteen'], ['eight thousand three hundred thirty'], ['ninety-nine thousand nine hundred ninety-nine'], ['eight hundred eighty-eight thousand eight hundred eighty-eight']]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [9], [10], [17], [20], [21], [45], [80], [99], [100], [301], [799], [800], [950], [1000], [1002], [3051], [7200], [7219], [8330], [99999], [888888], [999999]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [9], [10], [17], [20], [21], [45], [80], [99], [100], [301], [799], [800], [950], [1000], [1002], [3051], [7200], [7219], [8330], [99999], [999999], [100000], [50000], [11111], [22222], [33333], [44444], [55555], [66666], [77777], [88888], [99999]]"}}
{"requirement": "from typing import List\n\n\ndef missing(nums: List[int], s: str) -> str:\n\"\"\"Jenny is 9 years old. She is the youngest detective in North America. Jenny is a 3rd grader student, so when a new mission comes up, she gets a code to decipher in a form of a sticker (with numbers) in her math notebook and a comment (a sentence) in her writing notebook. All she needs to do is to figure out one word, from there she already knows what to do. \nAnd here comes your role - you can help Jenny find out what the word is! \n\nIn order to find out what the word is, you should use the sticker (array of 3 numbers) to retrive 3 letters from the comment (string) that create the word.\n\n- Each of the numbers in the array refers to the position of a letter in the string, in increasing order.\n- Spaces are not places, you need the actual letters. No spaces.\n- The returned word should be all lowercase letters.\n- if you can't find one of the letters using the index numbers, return \"No mission today\". Jenny would be very sad, but that's life... :( \n\nExample:\ninput: [5, 0, 3], \"I Love You\"\noutput: \"ivy\"\n(0 = \"i\", 3 = \"v\", 5 = \"y\")\n\"\"\"", "inputs": [[[0, 3, 5], "I love you"], [[7, 10, 1], "see you later"], [[29, 31, 8], "The quick brown fox jumps over the lazy dog"], [[12, 4, 6], "Good Morning"], [[1, 16, 21], "A purple pig and a green donkey flew a kite in the middle of the night"], [[35, 8, 20], "A song can make or ruin your day if you let it get to you"], [[20, 3, 27], "I love eating toasted cheese and tuna"], [[50, 4, 6], "Hi everybody"], [[8, 31, 28], "If I do not like something I will stay away from it"], [[12, 22, 28], "Where do random thoughts come from"], [[41, 7, 18], "The tape got stuck on my lips so I could not talk anymore"], [[33, 8, 12], "My turtle Jim got out of his cage and ate a banana"], [[18, 25, 45], "are you going to have a funnel birthday cake for your next birthday"], [[5, 25, 31], "all moms and dads sat around drinking coffee"], [[24, 36, 8], "My pen broke and now I have blue ink all over my dress"]], "outputs": [["ivy"], ["ear"], ["bay"], ["No mission today"], ["pen"], ["mug"], ["vet"], ["No mission today"], ["law"], ["mom"], ["gym"], ["job"], ["fix"], ["mic"], ["key"]], "starter_code": "from typing import List\ndef missing(nums: List[int], s: str) -> str:", "canonical_solution": "def missing(nums, s):\n    ans = []\n    s = s.replace(' ', '')\n    try:\n        for i in sorted(nums):\n            ans.append(s[i])\n        return ''.join(ans).lower()\n    except IndexError:\n        return 'No mission today'", "entry_point": "missing", "task_id": "TACO_lite/608", "input_output_examples": "[[[[5, 0, 3], 'I Love You']], [['ivy']]]", "llm_generated_inputs": {"deepseek-v3": "[[[0, 1, 2], 'abc'], [[5, 0, 3], 'I Love You'], [[10, 20, 30], 'This is a long string with many letters'], [[0, 4, 8], 'Hello World'], [[2, 3, 5], 'Python'], [[1, 2, 3], 'a b c'], [[0, 1, 2], '  abc  '], [[5, 10, 15], 'This is a test string'], [[100, 200, 300], 'Short string'], [[0, 1, 2], ''], [[-1, 0, 1], 'abc'], [[0, 1, 2], 'a'], [[0, 1, 2], 'ab'], [[0, 1, 2], 'abcde'], [[0, 1, 2], 'a b c d e']]", "qwen2.5-coder-32b-instruct": "[[[5, 0, 3], 'I Love You'], [[1, 2, 4], 'hello world'], [[0, 1, 2], 'abc'], [[0, 2, 4], 'abcdefg'], [[3, 1, 0], 'Jenny'], [[10, 11, 12], 'short string'], [[0, 1, 2], 'hi'], [[0, 0, 0], 'repeat'], [[5, 5, 5], 'same index'], [[2, 3, 4], 'spaces are not places ']]"}}
{"requirement": "def triangle(row: str) -> str:\n\"\"\"If you finish this kata, you can try [Insane Coloured Triangles](http://www.codewars.com/kata/insane-coloured-triangles) by Bubbler, which is a ***much*** harder version of this one.\n\nA coloured triangle is created from a row of colours, each of which is red, green or blue. Successive rows, each containing one fewer colour than the last, are generated by considering the two touching colours in the previous row. If these colours are identical, the same colour is used in the new row. If they are different, the missing colour is used in the new row. This is continued until the final row, with only a single colour, is generated.\n\nThe different possibilities are:\n```\nColour here:        G G        B G        R G        B R\nBecomes colour:      G          R          B          G\n```\n\nWith a bigger example:\n```\nR R G B R G B B\n R B R G B R B\n  G G B R G G\n   G R G B G\n    B B R R\n     B G R\n      R B\n       G\n```\n  \nYou will be given the first row of the triangle as a string and its your job to return the final colour which would appear in the bottom row as a string. In the case of the example above, you would the given `RRGBRGBB` you should return `G`.\n\n* The input string will only contain the uppercase letters `R, G, B` and there will be at least one letter so you do not have to test for invalid input.\n* If you are only given one colour as the input, return that colour. \n\n\n*Adapted from the 2017 British Informatics Olympiad*\n\"\"\"", "inputs": [["GB"], ["RRR"], ["RGBG"], ["RBRGBRB"], ["RBRGBRBGGRRRBGBBBGG"], ["B"]], "outputs": [["R"], ["R"], ["B"], ["G"], ["G"], ["B"]], "starter_code": "def triangle(row: str) -> str:", "canonical_solution": "COLORS = set('RGB')\n\ndef triangle(row):\n    while len(row) > 1:\n        row = ''.join((a if a == b else (COLORS - {a, b}).pop() for a, b in zip(row, row[1:])))\n    return row", "entry_point": "triangle", "task_id": "TACO_lite/610", "input_output_examples": "[[['RRGBRGBB']], [['G']]]", "llm_generated_inputs": {"deepseek-v3": "[['G'], ['R'], ['B'], ['GG'], ['GB'], ['RG'], ['RB'], ['BG'], ['BR'], ['RRGBRGBB'], ['RRRRRRRR'], ['GGGGGGGG'], ['BBBBBBBB'], ['RGBRGBRGB'], ['BRGBRGBRG'], ['GRBGRBGRB'], ['RRRRGGGG'], ['BBBBRRRR'], ['GGGGBBBB'], ['RGBRGBRGBRGBRGBRGBRGBRGB']]", "qwen2.5-coder-32b-instruct": "[['R'], ['G'], ['B'], ['RG'], ['RB'], ['GR'], ['GB'], ['BR'], ['BG'], ['RR'], ['GG'], ['BB'], ['RGB'], ['RGG'], ['RRG'], ['RRGB'], ['RRGBRGBB'], ['RRRRRRRR'], ['GGGGGGGG'], ['BBBBBBBB'], ['RGBRGBRGB']]"}}
{"requirement": "def to_camel_case(text: str) -> str:\n\"\"\"Complete the method/function so that it converts dash/underscore delimited words into camel casing. The first word within the output should be capitalized **only** if the original word was capitalized (known as Upper Camel Case, also often referred to as Pascal case). \n\n## Examples\n\n```python\nto_camel_case(\"the-stealth-warrior\") # returns \"theStealthWarrior\"\n\nto_camel_case(\"The_Stealth_Warrior\") # returns \"TheStealthWarrior\"\n```\n\"\"\"", "inputs": [[""], ["the_stealth_warrior"], ["The-Stealth-Warrior"], ["A-B-C"]], "outputs": [[""], ["theStealthWarrior"], ["TheStealthWarrior"], ["ABC"]], "starter_code": "def to_camel_case(text: str) -> str:", "canonical_solution": "def to_camel_case(text):\n    removed = text.replace('-', ' ').replace('_', ' ').split()\n    if len(removed) == 0:\n        return ''\n    return removed[0] + ''.join([x.capitalize() for x in removed[1:]])", "entry_point": "to_camel_case", "task_id": "TACO_lite/617", "input_output_examples": "[[['the-stealth-warrior'], ['The_Stealth_Warrior']], [['theStealthWarrior'], ['TheStealthWarrior']]]", "llm_generated_inputs": {"deepseek-v3": "[['the-stealth-warrior'], ['The_Stealth_Warrior'], ['the_stealth_warrior'], ['The-Stealth-Warrior'], ['theStealthWarrior'], ['theStealth_Warrior'], ['the-stealth_warrior'], ['the_Stealth-Warrior'], ['The_Stealth_Warrior_Extra'], ['the-stealth-warrior-extra'], ['the_stealth_warrior_extra'], ['theStealthWarriorExtra'], ['the_Stealth-Warrior-Extra'], ['The_Stealth_Warrior-Extra'], ['the-Stealth-Warrior_Extra'], ['the-Stealth-Warrior-Extra'], ['the_Stealth_Warrior-Extra'], ['the_Stealth-Warrior_Extra'], ['the_Stealth-Warrior-Extra'], ['the_Stealth_Warrior_Extra']]", "qwen2.5-coder-32b-instruct": "[['the-stealth-warrior'], ['The_Stealth_Warrior'], ['alreadyCamelCase'], ['multiple---dashes'], ['under_scores'], ['mixed-Dashes_and_Underscores'], [''], ['singleword'], ['SingleWord'], ['with--multiple---dashes'], ['with__multiple___underscores'], ['leading-and-trailing-_'], ['-leading-and-trailing']]"}}
{"requirement": "from typing import List\n\n\ndef shuffled_array(s: List[int]) -> List[int]:\n\"\"\"# Task\n A noob programmer was given two simple tasks: sum and sort the elements of the given array `arr` = [a1, a2, ..., an]. \n \n He started with summing and did it easily, but decided to store the sum he found in some random position of the original array which was a bad idea. Now he needs to cope with the second task, sorting the original array arr, and it's giving him trouble since he modified it.\n\n Given the array `shuffled`, consisting of elements a1, a2, ..., an, and their sumvalue in random order, return the sorted array of original elements a1, a2, ..., an.\n\n# Example\n\n For `shuffled = [1, 12, 3, 6, 2]`, the output should be `[1, 2, 3, 6]`.\n\n `1 + 3 + 6 + 2 = 12`, which means that 1, 3, 6 and 2 are original elements of the array.\n\n For `shuffled = [1, -3, -5, 7, 2]`, the output should be `[-5, -3, 2, 7]`.\n\n# Input/Output\n\n\n - `[input]` integer array `shuffled`\n\n    Array of at least two integers. It is guaranteed that there is an index i such that shuffled[i] = shuffled[0] + ... + shuffled[i - 1] + shuffled[i + 1] + ... + shuffled[n].\n\n    Constraints:\n\n    `2 ≤ shuffled.length ≤ 30,`\n\n    `-300 ≤ shuffled[i] ≤ 300.`\n\n\n - `[output]` an integer array\n\n    A `sorted` array of shuffled.length - 1 elements.\n\"\"\"", "inputs": [[[1, 12, 3, 6, 2]], [[1, -3, -5, 7, 2]], [[2, -1, 2, 2, -1]], [[-3, -3]]], "outputs": [[[1, 2, 3, 6]], [[-5, -3, 2, 7]], [[-1, -1, 2, 2]], [[-3]]], "starter_code": "from typing import List\ndef shuffled_array(s: List[int]) -> List[int]:", "canonical_solution": "def shuffled_array(s):\n    result = sorted(s)\n    result.remove(sum(result) // 2)\n    return result", "entry_point": "shuffled_array", "task_id": "TACO_lite/619", "input_output_examples": "[[[[1, 12, 3, 6, 2]], [[1, -3, -5, 7, 2]]], [[[1, 2, 3, 6]], [[-5, -3, 2, 7]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 12, 3, 6, 2]], [[1, -3, -5, 7, 2]], [[10, 50, 20, 30, 40]], [[0, 0, 0, 0, 0]], [[5, 15, 10]], [[100, 200, 300, 600]], [[-1, -2, -3, -6]], [[1, 2, 3, 4, 5, 15]], [[-10, 10, 0, 0]], [[7, 14, 21, 42]]]", "qwen2.5-coder-32b-instruct": "[[[1, 12, 3, 6, 2]], [[1, -3, -5, 7, 2]], [[5, 10, 5]], [[0, 0, 0, 0]], [[10, -10, 0]], [[1, 2, 3, 6, 12]], [[300, 150, 150]], [[-300, 150, -150]], [[299, 1, -1, 299]], [[2, 3, 5, 10]]]"}}
{"requirement": "def converter(mpg: float) -> float:\n\"\"\"Sometimes, I want to quickly be able to convert miles per imperial gallon into kilometers per liter.\n\nCreate an application that will display the number of kilometers per liter (output) based on the number of miles per imperial gallon (input).\n\nMake sure to round off the result to two decimal points. If the answer ends with a 0, it should be rounded off without the 0. So instead of 5.50, we should get 5.5.\n\nSome useful associations relevant to this kata:\n1 Imperial Gallon = 4.54609188 litres\n1 Mile = 1.609344 kilometres\n\"\"\"", "inputs": [[10], [20], [30], [24], [36]], "outputs": [[3.54], [7.08], [10.62], [8.5], [12.74]], "starter_code": "def converter(mpg: float) -> float:", "canonical_solution": "def converter(mpg):\n    kpl = round(mpg * 1.609344 / 4.54609188, 2)\n    return kpl", "entry_point": "converter", "task_id": "TACO_lite/624", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[0.0], [1.0], [10.0], [100.0], [22.3], [30.0], [40.0], [50.0], [123.456], [999.999]]", "qwen2.5-coder-32b-instruct": "[[30.0], [0.0], [100.0], [1.0], [25.5], [60.3], [15.75]]"}}
{"requirement": "def checkered_board(n: int) -> str:\n\"\"\"Write a function which takes one parameter representing the dimensions of a checkered board. The board will always be square, so 5 means you will need a 5x5 board.\n\nThe dark squares will be represented by a unicode white square, while the light squares will be represented by a unicode black square (the opposite colours ensure the board doesn't look reversed on code wars' dark background). It should return a string of the board with a space in between each square and taking into account new lines. \n\nAn even number should return a board that begins with a dark square. An odd number should return a board that begins with a light square.\n\nThe input is expected to be a whole number that's at least two, and returns false otherwise (Nothing in Haskell).\n\nExamples:\n\n```python\ncheckered_board(5)\n```\n\nreturns the string\n```\n■ □ ■ □ ■\n□ ■ □ ■ □\n■ □ ■ □ ■\n□ ■ □ ■ □\n■ □ ■ □ ■\n```\n\n**There should be no trailing white space at the end of each line, or new line characters at the end of the string.**\n\n**Note**   \nDo not use HTML entities for the squares (e.g. `□` for white square) as the code doesn't consider it a valid square. A good way to check is if your solution prints a correct checker board on your local terminal.  \n\n**Ruby note:**\nCodeWars has encoding issues with rendered unicode in Ruby.\nYou'll need to use unicode source code (e.g. \"\\u25A0\") instead of rendered unicode (e.g \"■\").\n\"\"\"", "inputs": [[1], [0], [-1], ["test"], [null], [[]], [2]], "outputs": [[false], [false], [false], [false], [false], [false], ["□ ■\n■ □"]], "starter_code": "def checkered_board(n: int) -> str:", "canonical_solution": "def checkered_board(n):\n    return isinstance(n, int) and n > 1 and '\\n'.join((' '.join(('■' if (x + y) % 2 ^ n % 2 else '□' for y in range(n))) for x in range(n)))", "entry_point": "checkered_board", "task_id": "TACO_lite/627", "input_output_examples": "[[[5]], [['\"■ □ ■ □ ■\\n□ ■ □ ■ □\\n■ □ ■ □ ■\\n□ ■ □ ■ □\\n■ □ ■ □ ■\"']]]", "llm_generated_inputs": {"deepseek-v3": "[[2], [3], [5], [6], [1], [0], [-1], [10], [9]]", "qwen2.5-coder-32b-instruct": "[[2], [3], [4], [5], [6], [7], [8], [9], [10], [1], [0], [-1], [-5]]"}}
{"requirement": "def words_to_object(s: str) -> str:\n\"\"\"You're given a string containing a sequence of words separated with whitespaces. Let's say it is a sequence of patterns: a name and a corresponding number - like this:\n\n```\"red 1 yellow 2 black 3 white 4\"```\n\nYou want to turn it into a different **string** of objects you plan to work with later on - like this:\n\n```\"[{name : 'red', id : '1'}, {name : 'yellow', id : '2'}, {name : 'black', id : '3'}, {name : 'white', id : '4'}]\"```\n\nDoing this manually is a pain. So you've decided to write a short function that would make the computer do the job for you. Keep in mind, the pattern isn't necessarily a word and a number. Consider anything separeted by a whitespace, just don't forget: an array of objects with two elements: name and id.\n\nAs a result you'll have a string you may just copy-paste whenever you feel like defining a list of objects - now without the need to put in names, IDs, curly brackets, colon signs, screw up everything, fail searching for a typo and begin anew. This might come in handy with large lists.\n\"\"\"", "inputs": [["red 1 yellow 2 black 3 white 4"], ["1 red 2 white 3 violet 4 green"], ["1 1 2 2 3 3 4 4"], ["#@&fhds 123F3f 2vn2# 2%y6D @%fd3 @!#4fs W@R^g WE56h%"], [""]], "outputs": [["[{name : 'red', id : '1'}, {name : 'yellow', id : '2'}, {name : 'black', id : '3'}, {name : 'white', id : '4'}]"], ["[{name : '1', id : 'red'}, {name : '2', id : 'white'}, {name : '3', id : 'violet'}, {name : '4', id : 'green'}]"], ["[{name : '1', id : '1'}, {name : '2', id : '2'}, {name : '3', id : '3'}, {name : '4', id : '4'}]"], ["[{name : '#@&fhds', id : '123F3f'}, {name : '2vn2#', id : '2%y6D'}, {name : '@%fd3', id : '@!#4fs'}, {name : 'W@R^g', id : 'WE56h%'}]"], ["[]"]], "starter_code": "def words_to_object(s: str) -> str:", "canonical_solution": "import re\n\ndef words_to_object(s):\n    return '[' + re.sub('([^ ]+) ([^ ]+)', \"{name : '\\\\1', id : '\\\\2'},\", s).strip(',') + ']'", "entry_point": "words_to_object", "task_id": "TACO_lite/629", "input_output_examples": "[[['red 1 yellow 2 black 3 white 4']], [[\"[{name : 'red', id : '1'}, {name : 'yellow', id : '2'}, {name : 'black', id : '3'}, {name : 'white', id : '4'}]\"]]]", "llm_generated_inputs": {"deepseek-v3": "[['red 1 yellow 2 black 3 white 4'], ['apple 5 banana 6 cherry 7'], ['cat 10 dog 20 bird 30'], ['123 abc 456 def 789 ghi'], ['single 99'], ['one 1'], ['  leading 1 space 2  '], ['multiple    spaces 1 between 2 words 3'], [''], ['onlyOneWord'], ['odd 1 number 2 of 3 words']]", "qwen2.5-coder-32b-instruct": "[['red 1 yellow 2 black 3 white 4'], ['apple 10 banana 20 cherry 30'], ['one 1 two 2 three 3'], ['a 1 b 2 c 3 d 4 e 5'], ['singleword 1'], [' '], [''], ['no numbers here'], ['123 456 789 0'], ['special!@# 1 chars$%^ 2 everywhere&*() 3']]"}}
{"requirement": "def arithmetic_sequence_sum(a: int, r: int, n: int) -> float:\n\"\"\"In your class, you have started lessons about \"arithmetic progression\". Because you are also a programmer, you have decided to write a function.\n\nThis function, arithmetic_sequence_sum(a, r, n), should return the sum of the first (n) elements of a sequence in which each element is the sum of the given integer (a), and a number of occurences of the given integer (r), based on the element's position within the sequence.\n\nFor example:\n\narithmetic_sequence_sum(2, 3, 5) should return 40:\n\n```\n1     2        3          4            5\na + (a+r) + (a+r+r) + (a+r+r+r) + (a+r+r+r+r) \n2 + (2+3) + (2+3+3) + (2+3+3+3) + (2+3+3+3+3) = 40\n```\n\"\"\"", "inputs": [[3, 2, 20], [2, 2, 10], [1, -2, 10]], "outputs": [[440], [110], [-80]], "starter_code": "def arithmetic_sequence_sum(a: int, r: int, n: int) -> float:", "canonical_solution": "def arithmetic_sequence_sum(a, r, n):\n    return n * (a + a + (n - 1) * r) / 2", "entry_point": "arithmetic_sequence_sum", "task_id": "TACO_lite/630", "input_output_examples": "[[[2, 3, 5]], [[40]]]", "llm_generated_inputs": {"deepseek-v3": "[[2, 3, 5], [1, 1, 10], [10, -2, 4], [0, 5, 3], [-1, -1, 5], [100, 0, 10], [5, 2, 1], [0, 0, 0], [-3, 4, 7]]", "qwen2.5-coder-32b-instruct": "[[2, 3, 5], [1, 1, 1], [0, 0, 10], [5, -2, 4], [-3, 2, 6], [10, 5, 0], [7, 0, 3], [-1, -1, 5], [100, 50, 1], [1, 1, 100]]"}}
{"requirement": "def f(n: int) -> int:\n\"\"\"We have a set of consecutive numbers from ```1``` to ```n```.\n\n\nWe want to count all the subsets that do not contain consecutive numbers.\nE.g.\n\nIf our set ```S1``` is equal to ```[1,2,3,4,5]```\nThe subsets that fulfill these property are:\n```\n[1],[2],[3],[4],[5],[1,3],[1,4],[1,5],[2,4],[2,5],[3,5],[1,3,5]\n```\nA total of      ```12   ``` subsets.\n\nFrom the set ```S2``` equals to```[1,2,3]```, it is obvious that we have only ```4``` subsets and are:\n```\n[1],[2],[3],[1,3]\n```\nMake a code that may give the amount of all these subsets for any integer       ```n >= 2       ```.\n\nFeatures of the random tests:\n```\nnumber of tests = 100 \n10 <= n <= 120\n```\n\"\"\"", "inputs": [[5], [3], [2], [20]], "outputs": [[12], [4], [2], [17710]], "starter_code": "def f(n: int) -> int:", "canonical_solution": "def f(n):\n    a, b = (0, 1)\n    for _ in range(n):\n        a, b = (b, a + b + 1)\n    return a", "entry_point": "f", "task_id": "TACO_lite/636", "input_output_examples": "[[[5], [3]], [[12], [4]]]", "llm_generated_inputs": {"deepseek-v3": "[[2], [3], [4], [5], [10], [15], [20], [50], [100], [120]]", "qwen2.5-coder-32b-instruct": "[[2], [3], [4], [5], [10], [11], [12], [13], [14], [15], [20], [30], [40], [50], [60], [70], [80], [90], [100], [110], [120], [1000]]"}}
{"requirement": "def calculate(num1: float, operation: str, num2: float) -> float:\n\"\"\"Write a function called calculate that takes 3 values. The first and third values are numbers. The second value is a character. If the character is \"+\" , \"-\", \"*\", or \"/\", the function will return the result of the corresponding mathematical function on the two numbers. If the string is not one of the specified characters, the function should return null (throw an `ArgumentException` in C#).\n\nKeep in mind, you cannot divide by zero. If an attempt to divide by zero is made, return null (throw an `ArgumentException` in C#)/(None in Python).\n\"\"\"", "inputs": [[3.2, "+", 8], [3.2, "-", 8], [3.2, "/", 8], [3.2, "*", 8], [-3, "+", 0], [-3, "-", 0], [-2, "/", -2], [-3, "*", 0], [-3, "/", 0], [-3, "w", 0], [-3, "w", 1]], "outputs": [[11.2], [-4.8], [0.4], [25.6], [-3], [-3], [1], [0], [null], [null], [null]], "starter_code": "def calculate(num1: float, operation: str, num2: float) -> float:", "canonical_solution": "def calculate(num1, operation, num2):\n    try:\n        return eval('{} {} {}'.format(num1, operation, num2))\n    except (ZeroDivisionError, SyntaxError):\n        return None", "entry_point": "calculate", "task_id": "TACO_lite/647", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[5.0, '+', 3.0], [10.0, '-', 4.0], [6.0, '*', 2.0], [8.0, '/', 2.0], [7.0, '/', 0.0], [5.0, '%', 2.0], [-3.0, '+', 5.0], [0.0, '*', 10.0], [15.0, '-', 15.0], [12.0, '&', 4.0], [9.0, '/', 3.0], [0.0, '/', 5.0], [100.0, '*', 0.0], [-10.0, '-', -5.0], [7.0, '^', 3.0]]", "qwen2.5-coder-32b-instruct": "[[5.0, '+', 3.0], [10.0, '-', 4.0], [6.0, '*', 7.0], [8.0, '/', 2.0], [5.0, '+', -3.0], [-10.0, '-', -4.0], [6.0, '*', -7.0], [-8.0, '/', -2.0], [0.0, '+', 0.0], [0.0, '-', 0.0], [0.0, '*', 0.0], [0.0, '/', 1.0], [1.0, '/', 0.0], [5.0, '^', 3.0], [5.0, 'a', 3.0]]"}}
{"requirement": "def swap(st: str) -> str:\n\"\"\"When provided with a String, capitalize all vowels\n\nFor example:\n\nInput : \"Hello World!\"\n\nOutput : \"HEllO WOrld!\"\n\nNote: Y is not a vowel in this kata.\n\"\"\"", "inputs": [["HelloWorld!"], ["Sunday"], ["Codewars"], ["Monday"], ["Friday"], ["abracadabra"]], "outputs": [["HEllOWOrld!"], ["SUndAy"], ["COdEwArs"], ["MOndAy"], ["FrIdAy"], ["AbrAcAdAbrA"]], "starter_code": "def swap(st: str) -> str:", "canonical_solution": "def swap(st):\n    tr = str.maketrans('aeiou', 'AEIOU')\n    return st.translate(tr)", "entry_point": "swap", "task_id": "TACO_lite/650", "input_output_examples": "[[['Hello World!']], [['HEllO WOrld!']]]", "llm_generated_inputs": {"deepseek-v3": "[['Hello World!'], ['aeiou'], ['bcdfghjklmnpqrstvwxyz'], ['YyYyY'], ['AaAaAa'], ['12345!@#$%^&*()'], [''], ['The quick brown fox jumps over the lazy dog'], ['Programming is fun!']]", "qwen2.5-coder-32b-instruct": "[['Hello World!'], ['python'], ['AEIOUaeiou'], ['bcd'], ['yYy'], [''], ['A quick brown fox jumps over the lazy dog']]"}}
{"requirement": "def f(n: int) -> int:\n\"\"\"Mutual Recursion allows us to take the fun of regular recursion (where a function calls itself until a terminating condition) and apply it to multiple functions calling each other! \n\nLet's use the Hofstadter Female and Male sequences to demonstrate this technique. You'll want to create two functions `F` and `M` such that the following equations are true: \n\n```\nF(0) = 1\nM(0) = 0\nF(n) = n - M(F(n - 1))\nM(n) = n - F(M(n - 1))\n```\n\nDon't worry about negative numbers, `n` will always be greater than or equal to zero.\n\n~~~if:php,csharp\nYou *do* have to worry about performance though, mutual recursion uses up a lot of stack space (and is highly inefficient) so you may have to find a way to make your solution consume less stack space (and time).  Good luck :)\n~~~\n\nHofstadter Wikipedia Reference http://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences\n\"\"\"", "inputs": [[0], [5], [10], [15], [25]], "outputs": [[1], [3], [6], [9], [16]], "starter_code": "def f(n: int) -> int:", "canonical_solution": "def f(n):\n    return n - m(f(n - 1)) if n else 1\n\ndef m(n):\n    return n - f(m(n - 1)) if n else 0", "entry_point": "f", "task_id": "TACO_lite/652", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [2], [3], [4], [5], [10], [15], [20]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [2], [3], [4], [5], [10], [20], [50], [100]]"}}
{"requirement": "def multiples(m: int, n: int) -> list:\n\"\"\"Implement a function, `multiples(m, n)`, which returns an array of the first `m` multiples of the real number `n`. Assume that `m` is a positive integer.\n\nEx.\n```\nmultiples(3, 5.0)\n```\nshould return\n```\n[5.0, 10.0, 15.0]\n```\n\"\"\"", "inputs": [[3, 5], [1, 3.14], [5, -1]], "outputs": [[[5, 10, 15]], [[3.14]], [[-1, -2, -3, -4, -5]]], "starter_code": "def multiples(m: int, n: int) -> list:", "canonical_solution": "def multiples(m, n):\n    return [i * n for i in range(1, m + 1)]", "entry_point": "multiples", "task_id": "TACO_lite/658", "input_output_examples": "[[[3, 5.0]], [[[5.0, 10.0, 15.0]]]]", "llm_generated_inputs": {"deepseek-v3": "[[3, 5.0], [1, 10.0], [5, 2.5], [0, 7.0], [4, 0.0], [2, -3.0], [10, 1.5], [3, -2.0]]", "qwen2.5-coder-32b-instruct": "[[3, 5.0], [1, 10], [5, -2], [0, 7], [4, 0], [10, 1.1], [2, 1000000], [3, 3.333]]"}}
{"requirement": "def freq_seq(s: str, sep: str) -> str:\n\"\"\"Return an output string that translates an input string `s`/`$s` by replacing each character in `s`/`$s` with a number representing the number of times that character occurs in `s`/`$s` and separating each number with the character(s) `sep`/`$sep`.\n\"\"\"", "inputs": [["hello world", "-"], ["19999999", ":"], ["^^^**$", "x"]], "outputs": [["1-1-3-3-2-1-1-2-1-3-1"], ["1:7:7:7:7:7:7:7"], ["3x3x3x2x2x1"]], "starter_code": "def freq_seq(s: str, sep: str) -> str:", "canonical_solution": "def freq_seq(s, sep):\n    return sep.join([str(s.count(i)) for i in s])", "entry_point": "freq_seq", "task_id": "TACO_lite/663", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['hello', '-'], ['banana', '**'], ['aabbbcccc', ','], ['zzz', ' '], ['', '-'], ['abc', ''], ['AaA', '-'], ['12345', ';'], ['!@#$', '|']]", "qwen2.5-coder-32b-instruct": "[['hello', ','], ['mississippi', '-'], ['1234567890', ':'], ['aabbcc', ' '], ['', ','], ['aaaa', ','], ['abcdef', ','], ['a,b,c', ','], ['hello world', ' '], ['freq_seq', '_']]"}}
{"requirement": "def parseboolexpr(expression: str) -> bool:\n\"\"\"Return the result of evaluating a given boolean expression, represented as a string.\nAn expression can either be:\n\n\"t\", evaluating to True;\n\"f\", evaluating to False;\n\"!(expr)\", evaluating to the logical NOT of the inner expression expr;\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;\n\"|(expr1,expr2,...)\", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...\n\n \nExample 1:\nInput: expression = \"!(f)\"\nOutput: true\n\nExample 2:\nInput: expression = \"|(f,t)\"\nOutput: true\n\nExample 3:\nInput: expression = \"&(t,f)\"\nOutput: false\n\nExample 4:\nInput: expression = \"|(&(t,f,t),!(t))\"\nOutput: false\n\n \nConstraints:\n\n1 <= expression.length <= 20000\nexpression[i] consists of characters in {'(', ')', '&', '|', '!', 't', 'f', ','}.\nexpression is a valid expression representing a boolean, as given in the description.\n\"\"\"", "inputs": [["!(f)"], ["|(f,t)"], ["&(t,f)"], ["|(&(t,f,t),!(t))"]], "outputs": [[true], [true], [false], [false]], "starter_code": "def parseboolexpr(expression: str) -> bool:", "canonical_solution": "def parseboolexpr(expression: str) -> bool:\n    if expression == 'f':\n        return False\n    if expression == 't':\n        return True\n    if expression[0] == '!':\n        return not parseboolexpr(expression[2:-1])\n    if expression[0] == '|':\n        cursor = 2\n        while cursor < len(expression) - 1:\n            end_of_next = getNextExpr(expression, cursor)\n            if parseboolexpr(expression[cursor:end_of_next]):\n                return True\n            cursor = end_of_next + 1\n        return False\n    if expression[0] == '&':\n        cursor = 2\n        while cursor < len(expression) - 1:\n            end_of_next = getNextExpr(expression, cursor)\n            if not parseboolexpr(expression[cursor:end_of_next]):\n                return False\n            cursor = end_of_next + 1\n        return True\n\ndef getNextExpr(expression, start):\n    if expression[start] == '!' or expression[start] == '|' or expression[start] == '&':\n        open_count = 1\n        close_count = 0\n        start += 1\n        while open_count > close_count:\n            start += 1\n            if expression[start] == '(':\n                open_count += 1\n            if expression[start] == ')':\n                close_count += 1\n        return start + 1\n    else:\n        return start + 1", "entry_point": "parseboolexpr", "task_id": "TACO_lite/667", "input_output_examples": "[[['!(f)'], ['|(f,t)'], ['&(t,f)'], ['|(&(t,f,t),!(t))']], [[True], [True], [False], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[['t'], ['f'], ['!(t)'], ['!(f)'], ['&(t,f)'], ['&(t,t)'], ['|(t,f)'], ['|(f,f)'], ['&(t,f,t)'], ['|(f,t,f)'], ['|(&(t,f,t),!(t))'], ['&(|(t,f),!(f))'], ['!(&(t,|(f,t)))'], ['!(|(&(t,f),!(t)))'], ['&(t,&(f,|(t,f)))'], ['|(f,&(t,!(f)))']]", "qwen2.5-coder-32b-instruct": "[['t'], ['f'], ['!(f)'], ['!(t)'], ['|(f,t)'], ['&(t,f)'], ['&(t,t)'], ['|(f,f)'], ['|(&(t,f,t),!(t))'], ['&(|(t,f),&(f,t))'], ['!(&(|(t,f),&(f,t)))'], ['|(!(f),&(t,t))'], ['&(|(f,t),|(f,t))'], ['|(|(t,f),&(t,f))'], ['&(|(&(t,f),t),!(f))'], ['!(|(t,&(f,f)))'], ['|(|(|(t,f),f),&(t,t))'], ['&(|(|(t,f),f),&(t,t))'], ['!(&(|(|(t,f),f),&(t,t)))'], ['|(|(|(|(t,f),f),f),&(t,t))']]"}}
{"requirement": "def divide(weight: int) -> bool:\n\"\"\"# It's too hot, and they can't even…\n\nOne hot summer day Pete and his friend Billy decided to buy watermelons. They chose the biggest crate. They rushed home, dying of thirst, and decided to divide their loot, however they faced a hard problem.\n\nPete and Billy are great fans of even numbers, that's why they want to divide the number of watermelons in such a way that each of the two parts consists of an even number of watermelons. However, it is not obligatory that the parts are equal. \n\nExample: the boys can divide a stack of 8 watermelons into 2+6 melons, or 4+4 melons.\n\nThe boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, whether they can divide the fruits in the way they want. For sure, each of them should get a part of positive weight.\n\n# Task\nGiven an integral number of watermelons `w` (`1 ≤ w ≤ 100`; `1 ≤ w` in Haskell), check whether Pete and Billy can divide the melons so that each of them gets an even amount.\n\n## Examples\n\"\"\"", "inputs": [[4], [2], [5], [88], [100], [67], [90], [10], [99], [32]], "outputs": [[true], [false], [false], [true], [true], [false], [true], [true], [false], [true]], "starter_code": "def divide(weight: int) -> bool:", "canonical_solution": "def divide(weight):\n    return weight > 2 and weight % 2 == 0", "entry_point": "divide", "task_id": "TACO_lite/670", "input_output_examples": "[[[8]], [[True]]]", "llm_generated_inputs": {"deepseek-v3": "[[8], [4], [2], [1], [100], [99], [3], [10]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [100]]"}}
{"requirement": "def get_participants(h: int) -> int:\n\"\"\"Johnny is a farmer and he annually holds a beet farmers convention \"Drop the beet\".\n\nEvery year he takes photos of farmers handshaking. Johnny knows that no two farmers handshake more than once. He also knows that some of the possible handshake combinations may not happen.\n\nHowever, Johnny would like to know the minimal amount of people that participated this year just by counting all the handshakes.\n\nHelp Johnny by writing a function, that takes the amount of handshakes and returns the minimal amount of people needed to perform these handshakes (a pair of farmers handshake only once).\n\"\"\"", "inputs": [[0], [1], [3], [6], [7]], "outputs": [[1], [2], [3], [4], [5]], "starter_code": "def get_participants(h: int) -> int:", "canonical_solution": "from math import ceil\n\ndef get_participants(h):\n    return int(ceil(0.5 + (0.25 + 2 * h) ** 0.5))", "entry_point": "get_participants", "task_id": "TACO_lite/682", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [2], [3], [6], [10], [15], [21], [28], [100]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [3], [6], [10], [15], [21], [28], [36], [45], [55], [100], [1000]]"}}
{"requirement": "def detect_operator(num: int) -> str:\n\"\"\"When a warrior wants to talk with another one about peace or war he uses a smartphone.  In one distinct  country warriors who spent all time in training kata not always have enough money. So if they call some number they want to know which operator serves  this number. \n\nWrite a function which **accepts number and return name of operator or string \"no info\"**, if operator can't be defined. number always looks like 8yyyxxxxxxx, where yyy corresponds to operator.\n\nHere is short list of operators:\n\n* 039 xxx xx xx - Golden Telecom\n* 050 xxx xx xx - MTS\n* 063 xxx xx xx - Life:)\n* 066 xxx xx xx - MTS\n* 067 xxx xx xx - Kyivstar\n* 068 xxx xx xx - Beeline\n* 093 xxx xx xx - Life:)\n* 095 xxx xx xx - MTS\n* 096 xxx xx xx - Kyivstar\n* 097 xxx xx xx - Kyivstar\n* 098 xxx xx xx - Kyivstar\n* 099 xxx xx xx - MTS Test [Just return \"MTS\"]\n\"\"\"", "inputs": [["80661111841"], ["80671991111"], ["80631551111"], ["80931551111"], ["80111551111"]], "outputs": [["MTS"], ["Kyivstar"], ["Life:)"], ["Life:)"], ["no info"]], "starter_code": "def detect_operator(num: int) -> str:", "canonical_solution": "OPERATORS = {'039': 'Golden Telecom', '050': 'MTS', '063': 'Life:)', '066': 'MTS', '067': 'Kyivstar', '068': 'Beeline', '093': 'Life:)', '095': 'MTS', '096': 'Kyivstar', '097': 'Kyivstar', '098': 'Kyivstar', '099': 'MTS'}\n\ndef detect_operator(num):\n    return OPERATORS.get(str(num)[1:4], 'no info')", "entry_point": "detect_operator", "task_id": "TACO_lite/694", "input_output_examples": "[[[80501234567], [80934567890], [80991234567], [80781234567], [80981234567]], [['MTS'], ['Life:)'], ['MTS'], ['no info'], ['Kyivstar']]]", "llm_generated_inputs": {"deepseek-v3": "[[80391234567], [80501234567], [80631234567], [80661234567], [80671234567], [80681234567], [80931234567], [80951234567], [80961234567], [80971234567], [80981234567], [80991234567], [80001234567], [81001234567], [8], [8039]]", "qwen2.5-coder-32b-instruct": "[[80391234567], [80501234567], [80631234567], [80661234567], [80671234567], [80681234567], [80931234567], [80951234567], [80961234567], [80971234567], [80981234567], [80991234567], [81231234567], [80001234567]]"}}
{"requirement": "def count_zeros_n_double_fact(n: int) -> int:\n\"\"\"Define n!! as\n\nn!! = 1 \\* 3 \\* 5 \\* ... \\* n  if n is odd, \n\nn!! = 2 \\* 4 \\* 6 \\* ... \\* n  if n is even. \n\nHence 8!! = 2 \\* 4 \\* 6 \\* 8 = 384, there is no zero at the end. \n30!! has 3 zeros at the end. \n\nFor a positive integer n, please count how many zeros are there at \nthe end of n!!. \n\nExample: \n\ncount\\_zeros\\_n\\_double\\_fact(30) should return 3\n\"\"\"", "inputs": [[8], [30], [487], [500]], "outputs": [[0], [3], [0], [62]], "starter_code": "def count_zeros_n_double_fact(n: int) -> int:", "canonical_solution": "def count_zeros_n_double_fact(n):\n    if n % 2 != 0:\n        return 0\n    k = 0\n    while n >= 10:\n        k += n // 10\n        n //= 5\n    return k", "entry_point": "count_zeros_n_double_fact", "task_id": "TACO_lite/696", "input_output_examples": "[[[30]], [[3]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [5], [8], [10], [15], [20], [25], [30], [35], [40], [45], [50], [0], [-1]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [10], [15], [20], [25], [30], [35], [40], [45], [50], [55], [60], [65], [70], [75], [80], [85], [90], [95], [100], [0], [-1], [-5]]"}}
{"requirement": "def color_probability(color: str, texture: str) -> str:\n\"\"\"You're playing a game with a friend involving a bag of marbles. In the bag are ten marbles:\n\n* 1 smooth red marble\n* 4 bumpy red marbles\n* 2 bumpy yellow marbles\n* 1 smooth yellow marble\n* 1 bumpy green marble\n* 1 smooth green marble\n\nYou can see that the probability of picking a smooth red marble from the bag is `1 / 10` or `0.10` and the probability of picking a bumpy yellow marble is `2 / 10` or `0.20`.\n\nThe game works like this: your friend puts her hand in the bag, chooses a marble (without looking at it) and tells you whether it's bumpy or smooth. Then you have to guess which color it is before she pulls it out and reveals whether you're correct or not.\n\nYou know that the information about whether the marble is bumpy or smooth changes the probability of what color it is, and you want some help with your guesses.\n\nWrite a function `color_probability()` that takes two arguments: a color (`'red'`, `'yellow'`, or `'green'`) and a texture (`'bumpy'` or `'smooth'`) and returns the probability as a decimal fraction accurate to two places.\n\nThe probability should be a string and should discard any digits after the 100ths place. For example, `2 / 3` or `0.6666666666666666` would become the string `'0.66'`. Note this is different from rounding.\n\nAs a complete example, `color_probability('red', 'bumpy')` should return the string `'0.57'`.\n\"\"\"", "inputs": [["red", "bumpy"], ["green", "bumpy"], ["yellow", "smooth"], ["red", "smooth"], ["green", "smooth"], ["yellow", "bumpy"]], "outputs": [["0.57"], ["0.14"], ["0.33"], ["0.33"], ["0.33"], ["0.28"]], "starter_code": "def color_probability(color: str, texture: str) -> str:", "canonical_solution": "def color_probability(color, texture):\n    marbles = {'smooth': {'red': 1, 'yellow': 1, 'green': 1, 'total': 3}, 'bumpy': {'red': 4, 'yellow': 2, 'green': 1, 'total': 7}}\n    return '{}'.format(marbles[texture][color] / marbles[texture]['total'])[:4]", "entry_point": "color_probability", "task_id": "TACO_lite/698", "input_output_examples": "[[['red', 'bumpy']], [['0.57']]]", "llm_generated_inputs": {"deepseek-v3": "[['red', 'bumpy'], ['red', 'smooth'], ['yellow', 'bumpy'], ['yellow', 'smooth'], ['green', 'bumpy'], ['green', 'smooth'], ['red', 'unknown'], ['unknown', 'bumpy'], ['unknown', 'smooth']]", "qwen2.5-coder-32b-instruct": "[['red', 'bumpy'], ['red', 'smooth'], ['yellow', 'bumpy'], ['yellow', 'smooth'], ['green', 'bumpy'], ['green', 'smooth'], ['red', ''], ['', 'bumpy'], ['', ''], ['blue', 'bumpy'], ['red', 'shiny']]"}}
{"requirement": "from typing import List\n\n\ndef goldbach_partitions(n: int) -> List[str]:\n\"\"\"German mathematician Christian Goldbach (1690-1764) [conjectured](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture) that every even number greater than 2 can be represented by the sum of two prime numbers. For example, `10` can be represented as `3+7` or `5+5`.\n\nYour job is to make the function return a list containing all unique possible representations of `n` in an increasing order if `n` is an even integer; if `n` is odd, return an empty list. Hence, the first addend must always be less than or equal to the second to avoid duplicates.\n\nConstraints : `2 < n < 32000` and `n` is even\n\n\n## Examples\n```\n26  -->  ['3+23', '7+19', '13+13']\n\n100 -->  ['3+97', '11+89', '17+83', '29+71', '41+59', '47+53']\n\n7   -->  [] \n```\n\"\"\"", "inputs": [[15], [393], [31133], [4], [100], [594], [1500]], "outputs": [[[]], [[]], [[]], [["2+2"]], [["3+97", "11+89", "17+83", "29+71", "41+59", "47+53"]], [["7+587", "17+577", "23+571", "31+563", "37+557", "47+547", "53+541", "71+523", "73+521", "103+491", "107+487", "127+467", "131+463", "137+457", "151+443", "163+431", "173+421", "193+401", "197+397", "211+383", "227+367", "241+353", "257+337", "263+331", "277+317", "281+313", "283+311"]], [["7+1493", "11+1489", "13+1487", "17+1483", "19+1481", "29+1471", "41+1459", "47+1453", "53+1447", "61+1439", "67+1433", "71+1429", "73+1427", "101+1399", "127+1373", "139+1361", "173+1327", "179+1321", "181+1319", "193+1307", "197+1303", "199+1301", "211+1289", "223+1277", "241+1259", "251+1249", "263+1237", "269+1231", "271+1229", "277+1223", "283+1217", "307+1193", "313+1187", "337+1163", "347+1153", "349+1151", "383+1117", "397+1103", "409+1091", "431+1069", "439+1061", "449+1051", "461+1039", "467+1033", "479+1021", "487+1013", "491+1009", "503+997", "509+991", "523+977", "547+953", "563+937", "571+929", "593+907", "613+887", "617+883", "619+881", "641+859", "643+857", "647+853", "661+839", "673+827", "677+823", "691+809", "727+773", "739+761", "743+757"]]], "starter_code": "from typing import List\ndef goldbach_partitions(n: int) -> List[str]:", "canonical_solution": "import math\n\ndef goldbach_partitions(n):\n\n    def is_prime(x):\n        for i in range(2, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                return False\n        return True\n    if n % 2:\n        return []\n    ret = []\n    for first in range(2, n // 2 + 1):\n        if is_prime(first):\n            second = n - first\n            if is_prime(second):\n                ret.append('%d+%d' % (first, second))\n    return ret", "entry_point": "goldbach_partitions", "task_id": "TACO_lite/700", "input_output_examples": "[[[26], [100], [7]], [[['3+23', '7+19', '13+13']], [['3+97', '11+89', '17+83', '29+71', '41+59', '47+53']], [[]]]]", "llm_generated_inputs": {"deepseek-v3": "[[4], [6], [10], [26], [100], [7], [1], [32000], [31998]]", "qwen2.5-coder-32b-instruct": "[[26], [100], [7], [4], [32000], [10], [14], [28], [2], [31998]]"}}
{"requirement": "def fold_to(distance: float, thickness: float = 0.0001, folds: int = 0) -> int:\n\"\"\"Have you heard about the myth that [if you fold a paper enough times, you can reach the moon with it](http://scienceblogs.com/startswithabang/2009/08/31/paper-folding-to-the-moon/)? Sure you have, but exactly how many? Maybe it's time to write a program to figure it out.\n\nYou know that a piece of paper has a thickness of `0.0001m`. Given `distance` in units of meters, calculate how many times you have to fold the paper to make the paper reach this distance.  \n(If you're not familiar with the concept of folding a paper: Each fold doubles its total thickness.)\n\nNote: Of course you can't do half a fold. You should know what this means ;P\n\nAlso, if somebody is giving you a negative distance, it's clearly bogus and you should yell at them by returning `null` (or whatever equivalent in your language. In Shell please return `None`).\n\"\"\"", "inputs": [[384000000], [5e-05], [1e-07], [0], [-1]], "outputs": [[42], [0], [0], [0], [null]], "starter_code": "def fold_to(distance: float, thickness: float = 0.0001, folds: int = 0) -> int:", "canonical_solution": "def fold_to(distance, thickness=0.0001, folds=0):\n    if distance < 0:\n        return\n    while thickness < distance:\n        thickness *= 2\n        folds += 1\n    return folds", "entry_point": "fold_to", "task_id": "TACO_lite/701", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[384400000, 0.0001, 0], [1, 0.0001, 0], [0.0001, 0.0001, 0], [5e-05, 0.0001, 0], [1000000, 0.0001, 0], [-1, 0.0001, 0], [0, 0.0001, 0], [0.0003, 0.0001, 0], [0.0002, 0.0001, 0], [0.0004, 0.0001, 0], [0.00015, 0.0001, 0]]", "qwen2.5-coder-32b-instruct": "[[0.0001, 0.0001, 0], [0.0002, 0.0001, 0], [1, 0.0001, 0], [1000000, 0.0001, 0], [-1, 0.0001, 0], [0, 0.0001, 0], [0.0001, 0.0002, 0], [0.0001, 0.0001, 1], [0.0004, 0.0001, 2]]"}}
{"requirement": "def count_red_beads(nb: int) -> int:\n\"\"\"Two red beads are placed between every two blue beads. There are N blue beads. After looking at the arrangement below work out the number of red beads.\n\n@\n@@\n@\n@@\n@\n@@\n@\n@@\n@\n@@\n@\n\nImplement count_red_beads(n) (in PHP count_red_beads($n); in Java, Javascript, TypeScript, C, C++ countRedBeads(n)) so that it returns the number of red beads.\nIf there are less than 2 blue beads return 0.\n\"\"\"", "inputs": [[0], [1], [3], [5]], "outputs": [[0], [0], [4], [8]], "starter_code": "def count_red_beads(nb: int) -> int:", "canonical_solution": "def count_red_beads(nb):\n    return max(0, 2 * (nb - 1))", "entry_point": "count_red_beads", "task_id": "TACO_lite/711", "input_output_examples": "[[[5], [3], [1], [0]], [[8], [4], [0], [0]]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [2], [3], [4], [5], [10]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [5], [10], [0], [-1]]"}}
{"requirement": "from typing import List\n\n\ndef side_len(x: int, y: int) -> List[int]:\n\"\"\"**DESCRIPTION:**\n\n  Your strict math teacher is teaching you about right triangles, and the Pythagorean Theorem --> a^2 + b^2 = c^2 whereas a and b are the legs of the right triangle and c is the hypotenuse of the right triangle. On the test however, the question asks: What are the possible integer lengths for the other side of the triangle, but since you never learned anything about that in class, you realize she meant What are the possible integer lengths for the other side of the right triangle. Because you want to address the fact that she asked the wrong question and the fact that you're smart at math, you've decided to answer all the possible values for the third side EXCLUDING the possibilities for a right triangle in increasing order.\n  \n**EXAMPLES:**\n\n```\nside_len(1, 1) --> [1]\nside_len(3, 4) --> [2, 3, 4, 6]\nside_len(4, 6) --> [3, 4, 5, 6, 7, 8, 9]\n```\n**RETURN:**\n\n  Return your answer as a list of all the possible third side lengths of the triangle without the right triangles in increasing order.\n  \nBy the way, after finishing this kata, please try some of my other katas: [Here](https://www.codewars.com/collections/tonylicodings-authored-katas)\n\nNOTE:\n  \n  When given side_len(x, y), y will always be greater than or equal to x. Also, if a right triangle's legs are passed in, exclude the hypotenuse. If a right triangle's leg and hypotenuse are passed in, exclude the other leg.\n\"\"\"", "inputs": [[1, 1], [3, 4], [4, 6], [5, 12], [8, 10]], "outputs": [[[1]], [[2, 3, 4, 6]], [[3, 4, 5, 6, 7, 8, 9]], [[8, 9, 10, 11, 12, 14, 15, 16]], [[3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]]], "starter_code": "from typing import List\ndef side_len(x: int, y: int) -> List[int]:", "canonical_solution": "def side_len(x, y):\n    return [z for z in range(abs(x - y) + 1, x + y) if z * z not in (abs(x * x - y * y), x * x + y * y)]", "entry_point": "side_len", "task_id": "TACO_lite/714", "input_output_examples": "[[[1, 1], [3, 4], [4, 6]], [[[1]], [[2, 3, 4, 6]], [[3, 4, 5, 6, 7, 8, 9]]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 1], [3, 4], [4, 6], [5, 12], [7, 24], [8, 15], [9, 40], [10, 24], [12, 16], [13, 84]]", "qwen2.5-coder-32b-instruct": "[[1, 1], [3, 4], [4, 6], [5, 12], [8, 15], [7, 24], [6, 8], [9, 12], [1, 2], [2, 2], [5, 5], [0, 0], [10, 25]]"}}
{"requirement": "from typing import Union\n\n\ndef build_a_wall(x: int = 0, y: int = 0) -> Union[str, None]:\n\"\"\"In this Kata you are a builder and you are assigned a job of building a wall with a specific size (God knows why...).\n\nCreate a function called `build_a_wall` (or `buildAWall` in JavaScript) that takes `x` and `y` as integer arguments (which represent the number of rows of bricks for the wall and the number of bricks in each row respectively) and outputs the wall as a string with the following symbols:\n\n`■■` => One full brick (2 of `■`)\n\n`■` => Half a brick\n\n`|` => Mortar (between bricks on same row)\n\nThere has to be a `|` between every two bricks on the same row. For more stability each row's bricks cannot be aligned vertically with the bricks of the row above it or below it meaning at every 2 rows you will have to make the furthest brick on both sides of the row at the size of half a brick (`■`) while the first row from the bottom will only consist of full bricks. Starting from the top, every new row is to be represented with `\\n` except from the bottom row. See the examples for a better understanding.\n\nIf one or both of the arguments aren't valid (less than 1, isn't integer, isn't given...etc) return `None` in Python.\n\nIf the number of bricks required to build the wall is greater than 10000 return `\"Naah, too much...here's my resignation.\"`\n\nExamples, based on Python:\n```\nbuild_a_wall(5,5) => '■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■'\n\nbuild_a_wall(10,7) => '■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■'\n\nbuild_a_wall(\"eight\",[3]) => None  }\n                                   }> Invalid input\nbuild_a_wall(12,-4) => None        }\n\nbuild_a_wall(123,987) => \"Naah, too much...here's my resignation.\"\n123 * 987 = 121401 > 10000\n```\n\"\"\"", "inputs": [[4, 5], [10, 7], ["eight", [3]], [12, -4], [0, 9], [123, 987]], "outputs": [["■|■■|■■|■■|■■|■\n■■|■■|■■|■■|■■\n■|■■|■■|■■|■■|■\n■■|■■|■■|■■|■■"], ["■|■■|■■|■■|■■|■■|■■|■\n■■|■■|■■|■■|■■|■■|■■\n■|■■|■■|■■|■■|■■|■■|■\n■■|■■|■■|■■|■■|■■|■■\n■|■■|■■|■■|■■|■■|■■|■\n■■|■■|■■|■■|■■|■■|■■\n■|■■|■■|■■|■■|■■|■■|■\n■■|■■|■■|■■|■■|■■|■■\n■|■■|■■|■■|■■|■■|■■|■\n■■|■■|■■|■■|■■|■■|■■"], [null], [null], [null], ["Naah, too much...here's my resignation."]], "starter_code": "from typing import Union\ndef build_a_wall(x: int = 0, y: int = 0) -> Union[str, None]:", "canonical_solution": "def build_a_wall(x=0, y=0):\n    if type(x) != int or type(y) != int or x < 1 or (y < 1):\n        return\n    if x * y > 10000:\n        return \"Naah, too much...here's my resignation.\"\n    res = [['■■'] * y if i & 1 ^ x & 1 else ['■'] + ['■■'] * (y - 1) + ['■'] for i in range(x)]\n    return '\\n'.join(map('|'.join, res))", "entry_point": "build_a_wall", "task_id": "TACO_lite/715", "input_output_examples": "[[[5, 5], [10, 7], ['eight', [3]], [12, -4], [123, 987]], [['■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■'], ['■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■'], [None], [None], [\"Naah, too much...here's my resignation.\"]]]", "llm_generated_inputs": {"deepseek-v3": "[[5, 5], [10, 7], [1, 1], [0, 5], [5, 0], [-1, 5], [5, -1], [123, 987], ['eight', [3]], [12, -4], [2, 2], [3, 3], [4, 4], [100, 100], [101, 101]]", "qwen2.5-coder-32b-instruct": "[[5, 5], [10, 7], ['eight', [3]], [12, -4], [123, 987], [0, 0], [1, 1], [1, 2], [2, 1], [100, 100], [10000, 1], [1, 10000], [5, 100], [100, 5], [3, 3], [4, 4]]"}}
{"requirement": "def solve(s: str, k: int) -> int:\n\"\"\"Consider the string `\"1 2 36 4 8\"`. Lets take pairs of these numbers, concatenate each pair and determine how many of them of divisible by `k`. \n\n```Pearl \nIf k = 3, we get following numbers ['12', '18', '21', '24', '42', '48', '81', '84'], all divisible by 3.   \nNote:\n-- 21 and 12 are different pairs. \n-- Elements must be from different indices, so '3636` is not a valid. \n\n\n```\n\nGiven a string of numbers and an integer `k`, return the number of pairs that when concatenated, are divisible by `k`.\n\n```\nsolve(\"1 2 36 4 8\", 3) = 8, because they are ['12', '18', '21', '24', '42', '48', '81', '84']\nsolve(\"1 3 6 3\", 3) = 6. They are ['36', '33', '63', '63', '33', '36']\n```\n\nMore examples in test cases. Good luck!\n\nPlease also try [Simple remove duplicates](https://www.codewars.com/kata/5ba38ba180824a86850000f7)\n\"\"\"", "inputs": [["1 2 36 4 8", 2], ["1 2 36 4 8", 3], ["1 2 36 4 8", 4], ["1 2 36 4 8", 8]], "outputs": [[16], [8], [11], [4]], "starter_code": "def solve(s: str, k: int) -> int:", "canonical_solution": "from itertools import permutations\n\ndef solve(s, k):\n    return sum((not v % k for v in map(int, map(''.join, permutations(s.split(), 2)))))", "entry_point": "solve", "task_id": "TACO_lite/718", "input_output_examples": "[[['1 2 36 4 8', 3], ['1 3 6 3', 3]], [[8], [6]]]", "llm_generated_inputs": {"deepseek-v3": "[['1 2 36 4 8', 3], ['1 3 6 3', 3], ['5 10 15', 5], ['0 0 0', 1], ['7 14 21', 7], ['123 456 789', 3], ['1 2 3 4 5', 10], ['9 9 9', 3], ['', 2], ['10 20', 0]]", "qwen2.5-coder-32b-instruct": "[['1 2 36 4 8', 3], ['1 3 6 3', 3], ['5 10 15 20', 5], ['7 14 21 28', 7], ['9 18 27 36', 9], ['0 0 0 0', 1], ['1 2 3 4 5 6 7 8 9', 2], ['11 22 33 44 55', 11], ['100 200 300 400', 100], ['123 234 345 456', 3], ['1 1 1 1 1', 1], ['', 5], ['1', 1], ['1 2', 2]]"}}
{"requirement": "def palindrome(num: int) -> int:\n\"\"\"A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward. Examples of numerical palindromes are: \n\n2332\n110011\n54322345\n\nFor a given number ```num```, return its closest numerical palindrome which can either be smaller or larger than ```num```. If there are 2 possible values, the larger value should be returned. If ```num``` is a numerical palindrome itself, return it. \n\nFor this kata, single digit numbers will NOT be considered numerical palindromes. \n\nAlso, you know the drill - be sure to return \"Not valid\" if the input is not an integer or is less than 0.\n\n```\npalindrome(8) => 11\npalindrome(281) => 282 \npalindrome(1029) => 1001\npalindrome(1221) => 1221\npalindrome(\"1221\") => \"Not valid\"\n\n```\n\n```Haskell\nIn Haskell the function should return a Maybe Int with Nothing for cases where the argument is less than zero.\n```\nOther Kata in this Series:\nNumerical Palindrome #1\nNumerical Palindrome #1.5\nNumerical Palindrome #2\nNumerical Palindrome #3\nNumerical Palindrome #3.5\nNumerical Palindrome #4\nNumerical Palindrome #5\n\"\"\"", "inputs": [[8], [281], [1029], [1221], ["BGHHGB"], ["11029"], [-1029]], "outputs": [[11], [282], [1001], [1221], ["Not valid"], ["Not valid"], ["Not valid"]], "starter_code": "def palindrome(num: int) -> int:", "canonical_solution": "def palindrome(num):\n    if type(num) is not int or num < 0:\n        return 'Not valid'\n    else:\n        c = 0\n        for i in range(num, num ** 2):\n            if is_pal(i):\n                return i\n            elif is_pal(i - c):\n                return i - c\n            else:\n                c += 2\n\ndef is_pal(n):\n    return n > 10 and n == int(str(n)[::-1])", "entry_point": "palindrome", "task_id": "TACO_lite/723", "input_output_examples": "[[[8], [281], [1029], [1221], ['1221']], [[11], [282], [1001], [1221], ['Not valid']]]", "llm_generated_inputs": {"deepseek-v3": "[[8], [281], [1029], [1221], ['1221'], [-5], [0], [123456789], [999], [100], [12321], [12345], [54322345], [110011], [2332]]", "qwen2.5-coder-32b-instruct": "[[8], [281], [1029], [1221], ['1221'], [-1], [0], [9], [10], [11], [99], [100], [101], [1001], [12321], [123321], [1234321], [123454321], [12345654321], [1234567654321], [123456787654321], [12345678987654321], [98765432123456789]]"}}
{"requirement": "from typing import List\n\n\ndef isvalid(formula: List[int]) -> bool:\n\"\"\"Now we will confect a reagent. There are eight materials to choose from, numbered 1,2,..., 8 respectively.\n\nWe know the rules of confect:\n```\nmaterial1 and material2 cannot be selected at the same time\nmaterial3 and material4 cannot be selected at the same time\nmaterial5 and material6 must be selected at the same time\nmaterial7 or  material8 must be selected(at least one, or both)\n```\n\n# Task\n\nYou are given a integer array `formula`. Array contains only digits 1-8 that represents material 1-8. Your task is to determine if the formula is valid. Returns `true` if it's valid, `false` otherwise.\n\n\n# Example\n\nFor `formula = [1,3,7]`, The output should be `true`.\n\nFor `formula = [7,1,2,3]`, The output should be `false`.\n\nFor `formula = [1,3,5,7]`, The output should be `false`.\n\nFor `formula = [1,5,6,7,3]`, The output should be `true`.\n\nFor `formula = [5,6,7]`, The output should be `true`.\n\nFor `formula = [5,6,7,8]`, The output should be `true`.\n\nFor `formula = [6,7,8]`, The output should be `false`.\n\nFor `formula = [7,8]`, The output should be `true`.\n\n\n# Note\n\n- All inputs are valid. Array contains at least 1 digit. Each digit appears at most once. \n\n- Happy Coding `^_^`\n\"\"\"", "inputs": [[[1, 3, 7]], [[7, 1, 2, 3]], [[1, 3, 5, 7]], [[1, 5, 6, 7, 3]], [[5, 6, 7]], [[5, 6, 7, 8]], [[6, 7, 8]], [[7, 8]]], "outputs": [[true], [false], [false], [true], [true], [true], [false], [true]], "starter_code": "from typing import List\ndef isvalid(formula: List[int]) -> bool:", "canonical_solution": "def isvalid(formula):\n    return not (1 in formula and 2 in formula or (3 in formula and 4 in formula) or (5 in formula and (not 6 in formula)) or (not 5 in formula and 6 in formula) or (not 7 in formula and (not 8 in formula)))", "entry_point": "isvalid", "task_id": "TACO_lite/724", "input_output_examples": "[[[[1, 3, 7]], [[7, 1, 2, 3]], [[1, 3, 5, 7]], [[1, 5, 6, 7, 3]], [[5, 6, 7]], [[5, 6, 7, 8]], [[6, 7, 8]], [[7, 8]]], [[True], [False], [False], [True], [True], [True], [False], [True]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 3, 7]], [[7, 1, 2, 3]], [[1, 3, 5, 7]], [[1, 5, 6, 7, 3]], [[5, 6, 7]], [[5, 6, 7, 8]], [[6, 7, 8]], [[7, 8]], [[1]], [[2]], [[3]], [[4]], [[5]], [[6]], [[7]], [[8]], [[1, 2]], [[3, 4]], [[5, 6]], [[7, 8]], [[1, 3, 5]], [[2, 4, 6]], [[1, 7, 8]], [[2, 7, 8]], [[3, 7, 8]], [[4, 7, 8]], [[5, 7, 8]], [[6, 7, 8]], [[1, 2, 3, 4, 5, 6, 7, 8]], [[1, 3, 5, 7, 8]], [[2, 4, 6, 7, 8]], [[1, 3, 5, 6, 7, 8]], [[2, 4, 5, 6, 7, 8]], [[1, 2, 3, 4, 5, 6, 7]], [[1, 2, 3, 4, 5, 6, 8]], [[1, 2, 3, 4, 7, 8]], [[1, 2, 5, 6, 7, 8]], [[3, 4, 5, 6, 7, 8]], [[1, 3, 4, 5, 6, 7, 8]], [[2, 3, 4, 5, 6, 7, 8]]]", "qwen2.5-coder-32b-instruct": "[[[1, 3, 7]], [[7, 1, 2, 3]], [[1, 3, 5, 7]], [[1, 5, 6, 7, 3]], [[5, 6, 7]], [[5, 6, 7, 8]], [[6, 7, 8]], [[7, 8]], [[1, 4, 5, 6]], [[2, 3, 7, 8]], [[1, 2, 3, 4, 5, 6, 7, 8]], [[5, 6]], [[7]], [[8]], [[1]], [[2]], [[3]], [[4]], [[1, 4, 7, 8]], [[2, 3, 5, 6]]]"}}
{"requirement": "def meeting_time(Ta: float, Tb: float, r: float) -> str:\n\"\"\"Two moving objects A and B are moving accross the same orbit (those can be anything: two planets, two satellites, two spaceships,two flying saucers, or spiderman with batman if you prefer).\nIf the two objects start to move from the same point and the orbit is circular, write a function that gives the time the two objects will meet again, given the time the objects A and B need to go through a full orbit, Ta and Tb respectively, and the radius of the orbit r. \n\n\nAs there can't be negative time, the sign of Ta and Tb, is an indication of the direction in which the object moving: positive for clockwise and negative for anti-clockwise.\n\nThe function will return a string that gives the time, in two decimal points.\nTa and Tb will have the same unit of measurement so you should not expect it in the solution. \n\nHint: Use angular velocity \"w\" rather than the classical \"u\".\n\"\"\"", "inputs": [[12, 15, 5], [12, -15, 6], [-14, -5, 5], [23, 16, 5], [0, 0, 7], [12, 0, 10], [0, 15, 17], [-24, 0, 10], [0, -18, 14], [32, -14, 14]], "outputs": [["60.00"], ["6.67"], ["7.78"], ["52.57"], ["0.00"], ["12.00"], ["15.00"], ["24.00"], ["18.00"], ["9.74"]], "starter_code": "def meeting_time(Ta: float, Tb: float, r: float) -> str:", "canonical_solution": "def meeting_time(Ta, Tb, r):\n    if Ta == 0:\n        return '{:.2f}'.format(abs(Tb))\n    elif Tb == 0:\n        return '{:.2f}'.format(abs(Ta))\n    else:\n        return '{:.2f}'.format(abs(Ta * Tb / (Tb - Ta)))", "entry_point": "meeting_time", "task_id": "TACO_lite/734", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[10.0, 20.0, 5.0], [-10.0, -20.0, 5.0], [10.0, -20.0, 5.0], [10.0, 10.0, 5.0], [0.0, 10.0, 5.0], [10.0, 0.0, 5.0], [0.0, 0.0, 5.0], [-10.0, 10.0, 5.0], [10.0, -10.0, 5.0], [10.0, 20.0, 0.0], [10.0, 20.0, -5.0]]", "qwen2.5-coder-32b-instruct": "[[10.0, 5.0, 100.0], [5.0, 10.0, 100.0], [7.5, 7.5, 100.0], [-10.0, -5.0, 100.0], [-5.0, -10.0, 100.0], [-7.5, 7.5, 100.0], [7.5, -7.5, 100.0], [0.0, 5.0, 100.0], [5.0, 0.0, 100.0], [0.0, 0.0, 100.0], [10.0, 5.0, 0.0], [10.0, 5.0, -100.0]]"}}
{"requirement": "def aks_test(p: int) -> bool:\n\"\"\"The AKS algorithm for testing whether a number is prime is a polynomial-time test based on the following theorem: \n\nA number p is prime if and only if all the coefficients of the polynomial expansion of `(x − 1)^p − (x^p − 1)` are divisible by `p`.\n\nFor example, trying `p = 3`:\n\n     (x − 1)^3 − (x^3 − 1) = (x^3 − 3x^2 + 3x − 1) − (x^3 − 1) = − 3x^2 + 3x \n    \nAnd all the coefficients are divisible by 3, so 3 is prime.\n\nYour task is to code the test function, wich will be given an integer and should return true or false based on the above theorem. You should efficiently calculate every coefficient one by one and stop when a coefficient is not divisible by p to avoid pointless calculations. The easiest way to calculate coefficients is to take advantage of binomial coefficients: http://en.wikipedia.org/wiki/Binomial_coefficient and pascal triangle: http://en.wikipedia.org/wiki/Pascal%27s_triangle . \n\nYou should also take advantage of the symmetry of binomial coefficients. You can look at these kata: http://www.codewars.com/kata/pascals-triangle and http://www.codewars.com/kata/pascals-triangle-number-2\n\nThe kata here only use the simple theorem. The general AKS test is way more complex.  The simple approach is a good exercie but impractical. The general AKS test will be the subject of another kata as it is one of the best performing primality test algorithms.\n\nThe main problem of this algorithm is the big numbers emerging from binomial coefficients in the polynomial expansion. As usual Javascript reach its limit on big integer very fast. (This simple algorithm is far less performing than a trivial algorithm here). You can compare the results with those of this kata: http://www.codewars.com/kata/lucas-lehmer-test-for-mersenne-primes Here, javascript can barely treat numbers bigger than 50, python can treat M13 but not M17.\n\n\n\"\"\"", "inputs": [[3], [4], [5], [7], [10], [33], [101], [1], [2], [11213], [8191], [8192]], "outputs": [[true], [false], [true], [true], [false], [false], [true], [false], [true], [true], [true], [false]], "starter_code": "def aks_test(p: int) -> bool:", "canonical_solution": "def aks_test(p):\n    lst = []\n    for i in range(2, p + 1):\n        for j in lst:\n            if i % j == 0:\n                break\n        else:\n            lst.append(i)\n    if p in lst:\n        return True\n    else:\n        return False", "entry_point": "aks_test", "task_id": "TACO_lite/740", "input_output_examples": "[[[3]], [[True]]]", "llm_generated_inputs": {"deepseek-v3": "[[2], [3], [5], [7], [11], [13], [17], [19], [23], [29], [1], [4], [6], [8], [9], [10], [12], [14], [15], [16], [18], [20], [21], [22], [24], [25], [26], [27], [28], [30], [0], [-1], [-2], [-3]]", "qwen2.5-coder-32b-instruct": "[[2], [3], [4], [5], [10], [11], [13], [17], [19], [20], [23], [24], [29], [31], [37], [41], [43], [47], [53], [59], [61], [67], [71], [73], [79], [83], [89], [97], [100], [101], [103], [107], [109], [113], [1], [0], [-1], [-5], [1000], [10000]]"}}
{"requirement": "from typing import List\n\n\ndef clonewars(k: int) -> List[int]:\n\"\"\"*It seemed a good idea at the time...*\n\n# Why I did it?\n\nAfter a year on **Codewars** I really needed a holiday...\n\nBut not wanting to drift backwards in the honour rankings while I was away, I hatched a cunning plan!\n\n# The Cunning Plan\n\nSo I borrowed my friend's \"Clone Machine\" and cloned myself :-)\n\nNow my clone can do my Kata solutions for me and I can relax!\n\nBrilliant!!\n\n\n\nFurthermore, at the end of the day my clone can re-clone herself...\n\nDouble brilliant!!\n\n\n\nI wonder why I didn't think to do this earlier?\n\n\n\nSo as I left for the airport I gave my clone instructions to:\n\n* do my Kata solutions for me\n* feed the cat\n* try to keep the house tidy and not eat too much\n* sleep\n* clone yourself\n* repeat same next day\n\n# The Flaw\n\nWell, how was I supposed to know that cloned DNA is faulty?\n\n:-(\n\nEvery time they sleep they wake up with decreased ability - they get slower... they get dumber... they are only able to solve 1 less Kata than they could the previous day.\n\nFor example, if they can solve 10 Kata today, then tomorrow they can solve only 9 Kata, then 8, 7, 6... Eventually they can't do much more than sit around all day playing video games.\n\nAnd (unlike me), when the clone cannot solve any more Kata they are no longer clever enough to operate the clone machine either!\n\n# The Return Home\n\nI suspected something was wrong when I noticed my **Codewars** honour had stopped rising.\n\nI made a hasty return home...\n\n...and found 100s of clones scattered through the house. Mostly they sit harmlessly mumbling to themselves. The largest group have made a kind of nest in my loungeroom where they sit catatonic in front of the PlayStation.\n\nThe whole place needs fumigating.\n\nThe fridge and pantry are empty.\n\nAnd I can't find the cat.\n\n# Kata Task\n\nWrite a method to predict the final outcome where:\n\nInput:\n\n* `kata-per-day` is the number of Kata I can solve per day\n\nOutput:\n\n* ```[number-of-clones, number-of-kata-solved-by-clones]```\n\"\"\"", "inputs": [[0], [1], [5], [10]], "outputs": [[[1, 0]], [[1, 1]], [[16, 57]], [[512, 2036]]], "starter_code": "from typing import List\ndef clonewars(k: int) -> List[int]:", "canonical_solution": "def clonewars(k):\n    return [2 ** max(k - 1, 0), 2 ** (k + 1) - k - 2]", "entry_point": "clonewars", "task_id": "TACO_lite/750", "input_output_examples": "[[[10], [3]], [[[10, 55]], [[3, 6]]]]", "llm_generated_inputs": {"deepseek-v3": "[[5], [1], [0], [10], [-1]]", "qwen2.5-coder-32b-instruct": "[[10], [1], [0], [5], [20], [100], [3]]"}}
{"requirement": "from typing import List\n\n\ndef counting_triangles(v: List[int]) -> int:\n\"\"\"# Task\nGiven some sticks by an array `V` of positive integers, where V[i] represents the length of the sticks, find the number of ways we can choose three of them to form a triangle.\n\n# Example\n\n For `V = [2, 3, 7, 4]`, the result should be `1`.\n\n There is only `(2, 3, 4)` can form a triangle.\n \n For `V = [5, 6, 7, 8]`, the result should be `4`.\n \n `(5, 6, 7), (5, 6, 8), (5, 7, 8), (6, 7, 8)` \n\n# Input/Output\n\n\n - `[input]` integer array `V`\n\n stick lengths\n \n `3 <= V.length <= 100`\n \n `0 < V[i] <=100`\n\n\n - `[output]` an integer\n\n number of ways we can choose 3 sticks to form a triangle.\n\"\"\"", "inputs": [[[2, 3, 4, 7]], [[5, 6, 7, 8]], [[2, 2, 2, 2]], [[1, 2, 5]], [[1, 2, 3, 4, 10, 20, 30]], [[1, 2, 3]]], "outputs": [[1], [4], [4], [0], [1], [0]], "starter_code": "from typing import List\ndef counting_triangles(v: List[int]) -> int:", "canonical_solution": "from itertools import combinations\n\ndef counting_triangles(v):\n    v.sort()\n    return sum((a + b > c for a, b, c in combinations(v, 3)))", "entry_point": "counting_triangles", "task_id": "TACO_lite/771", "input_output_examples": "[[[[2, 3, 7, 4]], [[5, 6, 7, 8]]], [[1], [4]]]", "llm_generated_inputs": {"deepseek-v3": "[[[2, 3, 7, 4]], [[5, 6, 7, 8]], [[1, 2, 3]], [[4, 4, 4, 4]], [[10, 20, 30, 40, 50]], [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], [[100, 100, 100]], [[3, 4, 5, 6, 7, 8, 9, 10]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[10, 15, 20, 25, 30, 35, 40, 45, 50]]]", "qwen2.5-coder-32b-instruct": "[[[2, 3, 7, 4]], [[5, 6, 7, 8]], [[1, 2, 3]], [[10, 10, 10]], [[1, 1, 2, 2, 3, 3]], [[3, 3, 3, 3, 3]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[100, 99, 98, 97, 96, 95, 94, 93, 92, 91]], [[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]], [[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]]]"}}
{"requirement": "def count_subsequences(needle: str, haystack: str) -> int:\n\"\"\"With your birthday coming up soon, your eccentric friend sent you a message to say \"happy birthday\":\n\n    hhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu\n    hhapppyyyy biirtttthdaaay too youuu\n    happy birrrthdayy to youuu\n    happpyyyy birrtthdaaay tooooo youu\n\nAt first it looks like a song, but upon closer investigation, you realize that your friend hid the phrase \"happy birthday\" thousands of times inside his message. In fact, it contains it more than 2 million times! To thank him, you'd like to reply with exactly how many times it occurs.\n\nTo count all the occurences, the procedure is as follows: look through the paragraph and find a `'h'`; then find an `'a'` later in the paragraph; then find an `'p'` after that, and so on. Now count the number of ways in which you can choose letters in this way to make the full phrase.\n\nMore precisely, given a text string, you are to determine how many times the search string appears as a sub-sequence of that string.\n\nWrite a function called `countSubsequences` that takes two arguments: `needle`, the string to be search for and `haystack`, the string to search in. In our example, `\"happy birthday\"` is the needle and the birthday message is the haystack. The function should return the number of times `needle` occurs as a sub-sequence of `haystack`.  Spaces are also considered part of the needle.\n\nSince the answers can be very large, return only the last 8 digits of the answer in case it exceeds 8 digits. The answers to the test cases will all be shorter than 8 digits.\n\"\"\"", "inputs": [["happy birthday", "appyh appy birth day"], ["happy birthday", "hhaappyy bbiirrtthhddaayy"], ["happy birthday", "happy holidays"], ["happy birthday", "happy birthday"], ["happy", "hhhappy"], ["happy birthday", "hhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu"]], "outputs": [[1], [2048], [0], [1], [3], [7680]], "starter_code": "def count_subsequences(needle: str, haystack: str) -> int:", "canonical_solution": "def count_subsequences(needle, haystack):\n    count = [1] + [0] * len(needle)\n    for a in haystack:\n        count = [1] + [count[i] + count[i - 1] * (a == b) for i, b in enumerate(needle, 1)]\n    return count[-1] % 10 ** 8", "entry_point": "count_subsequences", "task_id": "TACO_lite/775", "input_output_examples": "[[['happy birthday', 'hhhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu hhapppyyyy biirtttthdaaay too youuu happy birrrthdayy to youuu happpyyyy birrtthdaaay tooooo youu'], ['happy birthday', 'happy birthday happy birthday happy birthday']], [[23928345], [3]]]", "llm_generated_inputs": {"deepseek-v3": "[['happy birthday', 'hhappyyyy biirrrrrthddaaaayyyyyyy to youuuu hhapppyyyy biirtttthdaaay too youuu happy birrrthdayy to youuu happpyyyy birrtthdaaay tooooo youu'], ['abc', 'ababcabc'], ['abc', 'def'], ['a', 'aaaa'], ['', 'any string'], ['any string', ''], ['xyz', 'xyxzyzxyzz'], ['hello', 'hello world hello'], ['spaces', 's p a c e s'], ['longneedle', 'longlonglonglonglonglonglonglonglonglong'], ['repeat', 'rrepeaatt'], ['case', 'CaSeSeNsItIvE'], ['123', '112233'], ['123', '321'], [' ', '  ']]", "qwen2.5-coder-32b-instruct": "[['happy', 'ahpppy'], ['abc', 'abracadabra'], ['a', 'aaaaaa'], ['', 'anything'], ['anything', ''], ['abc', 'xyz'], ['happy birthday', 'hhhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu'], ['happy birthday', 'happpyyyy birrtthdaaay tooooo youu'], [' ', ' a b c '], ['abc def', 'aabbccddeeff']]"}}
{"requirement": "from typing import List\n\n\ndef berserk_rater(synopsis: List[str]) -> str:\n\"\"\"In case you might be unlucky enough not to know the best dark fantasy franchise ever, Berserk tells the story of a man that, hating gratuitous violence, decided to become a mercenary (thus one who sells violence, no gratuity anymore!) and starts an epic struggle against apparently unsormountable odds, unsure if he really wants to pursue a path of vengeance or to try to focus on his remaining and new loved ones.\n\n*The main character, Gatsu,ready to start yet another Tuesday*\n\nOk, the first part was a joke, but you can read more about the tale of the main character, a \"Byronic hero\" for wikipedia, in other pages like [here](https://en.wikipedia.org/wiki/Berserk_(manga%29).\n\nAfter an insanely long waiting, finally fans got the [follow up](https://en.wikipedia.org/wiki/Berserk_(2016_TV_series%29) of [the acclaimed 90s show](https://en.wikipedia.org/wiki/Berserk_(1997_TV_series%29).\n\nRegrettably, while the first adaption was considerably shortened, the latter was quite butchered, missing entire parts, like the \"lost children\" arc, but that would have actual children butchered and thus you might get why it was decided to skip it. And fan could somehow cope with it, if it was not for the very meager use of CG (Computer Graphic).\n\nLuckily, I am a simple man and every time Gatsu swings his humongous sword, that is enough to make me forget about everything else.\n\nYour goal is to build a Berserk Rater function that takes an array/list of events of each episode (as strings) and calculate a rating based on that: you start with a score of 0 (hey, it's a work from Miura-sensei, I have great expectations to satisfy!) and you have to:\n\n* subtract 2 each time \"CG\" is mentioned (case insensitive);\n* add 5 every time \"Clang\" is mentioned (case insensitive);\n* if a sentence has both \"Clang\" and \"CG\", \"Clang\" wins (add 5);\n* remove 1 every time neither is mentioned (I get bored easily, you know, particularly if you remove important parts and keep side character whining for half an episode).\n\nYou should then return a string, structured like this:\n\n* if the finale score is less than 0: \"worstest episode ever\";\n* if the score is between 0 and 10: the score itself, as a string;\n* if the finale score is more than 10: \"bestest episode ever\".\n\nExamples:\n```python\nberserk_rater([\"is this the CG from a P2 game?\",\"Hell, no! Even the CG in the Dreamcast game was more fluid than this!\",\"Well, at least Gatsu does his clang even against a mere rabbit\", \"Hey, Cosette was not in this part of the story!\", \"Ops, everybody dead again! Well, how boring...\"])==\"worstest episode ever\"\nberserk_rater([\"missing the Count arc\",\"lame CG\",\"Gatsu doing its clang against a few henchmen\", \"even more lame CG\"])==\"0\"\nberserk_rater([\"Farnese unable to shut the fuck up\",\"awful CG dogs assaulting everybody\", \"Gatsu clanging the pig apostle!\"])==\"2\"\nberserk_rater([\"spirits of the dead attacking Gatsu and getting clanged for good\", \"but the wheel spirits where really made with bad CG\", \"Isidoro trying to steal the dragon Slayer and getting a sort of clang on his face\", \"Gatsu vs. the possessed horse: clang!\", \"Farnese whining again...\",\"a shame the episode ends with that scrappy CG\"])==\"10\"\nberserk_rater([\"Holy chain knights being dicks\", \"Serpico almost getting clanged by Gatsu, but without losing his composure\",\"lame CG\",\"Luka getting kicked\",\"Gatsu going clang against the angels\", \"Gatsu clanging vs Mozgus, big time!\"])==\"bestest episode ever\"\n```\n\nExtra cookies if you manage to solve it all using a `reduce/inject` approach.\n\nOh, and in case you might want a taste of clang to fully understand it, [click](https://www.youtube.com/watch?v=IZgxH8MJFno) (one of the least gory samples I managed to find).\n\"\"\"", "inputs": [[["is this the CG from a P2 game?", "Hell, no! Even the CG in the Dreamcast game was more fluid than this!", "Well, at least Gatsu does his clang even against a mere rabbit", "Hey, Cosette was not in this part of the story!", "Ops, everybody dead again! Well, how boring..."]], [["missing the Count arc", "lame CG", "Gatsu doing its clang against a few henchmen", "even more lame CG"]], [["Farnese unable to shut the fuck up", "awful CG dogs assaulting everybody", "Gatsu clanging the pig apostle!"]], [["spirits of the dead attacking Gatsu and getting clanged for good", "but the wheel spirits where really made with bad CG", "Isidoro trying to steal the dragon Slayer and getting a sort of clang on his face", "Gatsu vs. the possessed horse: clang!", "Farnese whining again...", "a shame the episode ends with that scrappy CG"]], [["Holy chain knights being dicks", "Serpico almost getting clanged by Gatsu, but without losing his composure", "lame CG", "Luka getting kicked", "Gatsu going clang against the angels", "Gatsu clanging vs Mozgus, big time!"]]], "outputs": [["worstest episode ever"], ["0"], ["2"], ["10"], ["bestest episode ever"]], "starter_code": "from typing import List\ndef berserk_rater(synopsis: List[str]) -> str:", "canonical_solution": "def berserk_rater(synopsis):\n    n = sum([score(s.upper()) for s in synopsis])\n    return 'worstest episode ever' if n < 0 else 'bestest episode ever' if n > 10 else str(n)\n\ndef score(s):\n    return 5 if 'CLANG' in s else -2 if 'CG' in s else -1", "entry_point": "berserk_rater", "task_id": "TACO_lite/782", "input_output_examples": "[[[['is this the CG from a P2 game?', 'Hell, no! Even the CG in the Dreamcast game was more fluid than this!', 'Well, at least Gatsu does his clang even against a mere rabbit', 'Hey, Cosette was not in this part of the story!', 'Ops, everybody dead again! Well, how boring...']], [['missing the Count arc', 'lame CG', 'Gatsu doing its clang against a few henchmen', 'even more lame CG']], [['Farnese unable to shut the fuck up', 'awful CG dogs assaulting everybody', 'Gatsu clanging the pig apostle!']], [['spirits of the dead attacking Gatsu and getting clanged for good', 'but the wheel spirits where really made with bad CG', 'Isidoro trying to steal the dragon Slayer and getting a sort of clang on his face', 'Gatsu vs. the possessed horse: clang!', 'Farnese whining again...', 'a shame the episode ends with that scrappy CG']], [['Holy chain knights being dicks', 'Serpico almost getting clanged by Gatsu, but without losing his composure', 'lame CG', 'Luka getting kicked', 'Gatsu going clang against the angels', 'Gatsu clanging vs Mozgus, big time!']]], [['worstest episode ever'], ['0'], ['2'], ['10'], ['bestest episode ever']]]", "llm_generated_inputs": {"deepseek-v3": "[[['is this the CG from a P2 game?', 'Hell, no! Even the CG in the Dreamcast game was more fluid than this!', 'Well, at least Gatsu does his clang even against a mere rabbit', 'Hey, Cosette was not in this part of the story!', 'Ops, everybody dead again! Well, how boring...']], [['missing the Count arc', 'lame CG', 'Gatsu doing its clang against a few henchmen', 'even more lame CG']], [['Farnese unable to shut the fuck up', 'awful CG dogs assaulting everybody', 'Gatsu clanging the pig apostle!']], [['spirits of the dead attacking Gatsu and getting clanged for good', 'but the wheel spirits where really made with bad CG', 'Isidoro trying to steal the dragon Slayer and getting a sort of clang on his face', 'Gatsu vs. the possessed horse: clang!', 'Farnese whining again...', 'a shame the episode ends with that scrappy CG']], [['Holy chain knights being dicks', 'Serpico almost getting clanged by Gatsu, but without losing his composure', 'lame CG', 'Luka getting kicked', 'Gatsu going clang against the angels', 'Gatsu clanging vs Mozgus, big time!']], [[]], [['No CG or Clang here']], [['CG and Clang both present', 'Just CG', 'Just Clang']], [['CG CG CG', 'Clang Clang Clang', 'Neither CG nor Clang']], [['cg', 'clang', 'cG', 'ClAnG', 'neither cg nor clang']]]", "qwen2.5-coder-32b-instruct": "[[['is this the CG from a P2 game?', 'Hell, no! Even the CG in the Dreamcast game was more fluid than this!', 'Well, at least Gatsu does his clang even against a mere rabbit', 'Hey, Cosette was not in this part of the story!', 'Ops, everybody dead again! Well, how boring...']], [['missing the Count arc', 'lame CG', 'Gatsu doing its clang against a few henchmen', 'even more lame CG']], [['Farnese unable to shut the fuck up', 'awful CG dogs assaulting everybody', 'Gatsu clanging the pig apostle!']], [['spirits of the dead attacking Gatsu and getting clanged for good', 'but the wheel spirits where really made with bad CG', 'Isidoro trying to steal the dragon Slayer and getting a sort of clang on his face', 'Gatsu vs. the possessed horse: clang!', 'Farnese whining again...', 'a shame the episode ends with that scrappy CG']], [['Holy chain knights being dicks', 'Serpico almost getting clanged by Gatsu, but without losing his composure', 'lame CG', 'Luka getting kicked', 'Gatsu going clang against the angels', 'Gatsu clanging vs Mozgus, big time!']], [['Clang']], [['CG']], [['Clang', 'CG']], [[]], [['Something unrelated']], [['clang', 'cg', 'Clang', 'CG', 'Something unrelated']]]"}}
{"requirement": "from typing import List\nfrom typing import Union\n\n\ndef args_to_string(args: List[Union[str, List[str]]]) -> str:\n\"\"\"Given an array of arguments, representing system call arguments keys and values, join it into a single, space-delimited string. You don't need to care about the application name -- your task is only about parameters.\n\nEach element of the given array can be:\n* a single string,\n* a single string array,\n* an array of two strings\n\nIn the last case (array of two strings) the first string should have a `\"--\"` prefix if it is more than one character long; or a `\"-\"` prefix otherwise; e.g.:\n  * `[\"foo\", \"bar\"]` becomes `\"--foo bar\"`\n  * `[\"f\", \"bar\"]` becomes `\"-f bar\"`\n\nYou may assume that all strings are non-empty and have no spaces.\n\n## Examples\n\n```python\n[\"foo\", \"bar\"]                    #  \"foo bar\"\n[[\"foo\", \"bar\"]]                  #  \"--foo bar\"\n[[\"f\", \"bar\"]]                    #  \"-f bar\"\n[[\"foo\", \"bar\"], \"baz\"]           #  \"--foo bar baz\"\n[[\"foo\"], [\"bar\", \"baz\"], \"qux\"]  #  \"foo --bar baz qux\"\n```\n\"\"\"", "inputs": [[["foo"]], [["f"]], [[["f"]]], [[["foo", "bar"]]], [[["f", "bar"]]], [[["foo", "bar"], ["baz", "qux"]]], [[["foo"], "bar", ["baz", "qux"], ["xyzzy", "a"], "a", ["a"], ["a", "plugh"]]], [[]], [[["---"], "---", ["---", "---"], ["-----", "-"], "-", ["-"], ["-", "-----"]]]], "outputs": [["foo"], ["f"], ["f"], ["--foo bar"], ["-f bar"], ["--foo bar --baz qux"], ["foo bar --baz qux --xyzzy a a a -a plugh"], [""], ["--- --- ----- --- ------- - - - -- -----"]], "starter_code": "from typing import List\nfrom typing import Union\ndef args_to_string(args: List[Union[str, List[str]]]) -> str:", "canonical_solution": "def args_to_string(args):\n    L = []\n    for arg in args:\n        if isinstance(arg, str):\n            L.append(arg)\n        elif len(arg) == 1:\n            L.append(arg[0])\n        elif len(arg[0]) == 1:\n            L.append('-' + ' '.join(arg))\n        else:\n            L.append('--' + ' '.join(arg))\n    return ' '.join(L)", "entry_point": "args_to_string", "task_id": "TACO_lite/784", "input_output_examples": "[[[['foo', 'bar']], [[['foo', 'bar']]], [[['f', 'bar']]], [[['foo', 'bar'], 'baz']], [[['foo'], ['bar', 'baz'], 'qux']]], [['foo bar'], ['--foo bar'], ['-f bar'], ['--foo bar baz'], ['foo --bar baz qux']]]", "llm_generated_inputs": {"deepseek-v3": "[[['foo', 'bar']], [[['foo', 'bar']]], [[['f', 'bar']]], [[['foo', 'bar'], 'baz']], [[['foo'], ['bar', 'baz'], 'qux']], [['single']], [[['only', 'one']]], [[['a', 'b'], ['c', 'd'], 'e']], [[['longkey', 'value'], ['short', 'value2'], 'last']], [[['x', 'y'], ['z', 'w'], ['a', 'b'], ['c', 'd']]]]", "qwen2.5-coder-32b-instruct": "[[['foo', 'bar']], [[['foo', 'bar']]], [[['f', 'bar']]], [[['foo', 'bar'], 'baz']], [[['foo'], ['bar', 'baz'], 'qux']], [[['a', 'value'], ['longname', 'anotherValue'], 'single']], [[['x', 'y'], ['z', 'w']]], [[['abc', 'def']]], [[['a', 'b'], 'c', ['d', 'e']]], [[]], [['single']], [[['s', 'short'], 'middle', ['longername', 'longervalue']]]]"}}
{"requirement": "def routes(n: int) -> int:\n\"\"\"Given a side length `n`, traveling only right and down how many ways are there to get from the top left corner to the bottom right corner of an `n by n` grid?\n\n\n\nYour mission is to write a program to do just that!\n\nAdd code to `route(n)` that returns the number of routes for a grid `n by n` (if n is less than 1 return 0).\n\nExamples:\n    \n    -100 -> 0\n    \n    1 -> 2\n     \n    2 -> 6\n     \n    20 -> 137846528820\n    \nNote: \nyou're traveling on the edges of the squares in the grid not the squares themselves.\n\nPS.If anyone has any suggestions of how to improve this kata please let me know.\n\"\"\"", "inputs": [[156], [106], [108], [126], [165], [125], [103]], "outputs": [[376594020312425061595746241557406711201605603899894320577733841460621358204120168599683135056], [360262512886894560870925723424985925545493469115736766525399280], [5710703280600670271749409312650477833283445281465962347881848400], [363385715856739898597174879118845755433251497432024467186246395557048813504], [95995892383488599901870820732368671856306475542669347911637204757217297906428740013991568571288240], [91208366928185711600087718663295946582847985411225264672245111235434562752], [5710294458198606715524045745816008575257432967999860738082400]], "starter_code": "def routes(n: int) -> int:", "canonical_solution": "from math import factorial\n\ndef routes(n):\n    return n > 0 and factorial(2 * n) // factorial(n) ** 2", "entry_point": "routes", "task_id": "TACO_lite/794", "input_output_examples": "[[[-100], [1], [2], [20]], [[0], [2], [6], [137846528820]]]", "llm_generated_inputs": {"deepseek-v3": "[[-100], [0], [1], [2], [20], [100]]", "qwen2.5-coder-32b-instruct": "[[-100], [0], [1], [2], [3], [5], [10], [20]]"}}
{"requirement": "from typing import List\nfrom typing import Union\n\n\ndef decompose(n: int) -> Union[List[int], None]:\n\"\"\"My little sister came back home from school with the following task:\ngiven a squared sheet of paper she has to cut it in pieces\nwhich, when assembled, give squares the sides of which form\nan increasing sequence of numbers.\nAt the beginning it was lot of fun but little by little we were tired of seeing the pile of torn paper.\nSo we decided to write a program that could help us and protects trees.\n\n## Task\n\nGiven a positive integral number n, return a **strictly increasing** sequence (list/array/string depending on the language) of numbers, so that the sum of the squares is equal to n².\n\nIf there are multiple solutions (and there will be), return as far as possible the result with the largest possible values:\n\n## Examples\n\n`decompose(11)` must return `[1,2,4,10]`. Note that there are actually two ways to decompose 11²,\n11² = 121 = 1 + 4 + 16 + 100 = 1² + 2² + 4² + 10² but don't return `[2,6,9]`, since 9 is smaller than 10.\n\nFor `decompose(50)` don't return `[1, 1, 4, 9, 49]` but `[1, 3, 5, 8, 49]` since `[1, 1, 4, 9, 49]`\ndoesn't form a strictly increasing sequence.\n\n## Note\nNeither `[n]` nor `[1,1,1,…,1]` are valid solutions. If no valid solution exists, return `nil`, `null`, `Nothing`, `None` (depending on the language) or `\"[]\"` (C) ,`{}` (C++), `[]` (Swift, Go).\n\nThe function \"decompose\" will take a positive integer n \nand return the decomposition of N = n² as:\n\n- [x1 ... xk]\nor\n- \"x1 ... xk\"\nor\n- Just [x1 ... xk]\nor\n- Some [x1 ... xk]\nor\n- {x1 ... xk}\nor\n- \"[x1,x2, ... ,xk]\"\n\ndepending on the language (see \"Sample tests\")\n\n# Note for Bash\n```\ndecompose 50 returns \"1,3,5,8,49\"\ndecompose 4  returns \"Nothing\"\n```\n# Hint\n\nVery often `xk` will be `n-1`.\n\"\"\"", "inputs": [[12], [6], [50], [44], [625], [5], [7100], [123456], [1234567], [7654321], [4], [7654322]], "outputs": [[[1, 2, 3, 7, 9]], [null], [[1, 3, 5, 8, 49]], [[2, 3, 5, 7, 43]], [[2, 5, 8, 34, 624]], [[3, 4]], [[2, 3, 5, 119, 7099]], [[1, 2, 7, 29, 496, 123455]], [[2, 8, 32, 1571, 1234566]], [[6, 10, 69, 3912, 7654320]], [null], [[1, 4, 11, 69, 3912, 7654321]]], "starter_code": "from typing import List\nfrom typing import Union\ndef decompose(n: int) -> Union[List[int], None]:", "canonical_solution": "def decompose(n):\n    total = 0\n    answer = [n]\n    while len(answer):\n        temp = answer.pop()\n        total += temp ** 2\n        for i in range(temp - 1, 0, -1):\n            if total - i ** 2 >= 0:\n                total -= i ** 2\n                answer.append(i)\n                if total == 0:\n                    return sorted(answer)\n    return None", "entry_point": "decompose", "task_id": "TACO_lite/801", "input_output_examples": "[[[11], [50], [4]], [[[1, 2, 4, 10]], [[1, 3, 5, 8, 49]], [None]]]", "llm_generated_inputs": {"deepseek-v3": "[[11], [50], [2], [1], [3], [4], [7], [12], [13], [20]]", "qwen2.5-coder-32b-instruct": "[[11], [50], [1], [2], [10], [100], [12], [15], [20], [25]]"}}
{"requirement": "def calculate(s: str) -> int:\n\"\"\"Given a string of words and numbers. Extract the expression including: \n1. the operator: either addition or subtraction\n2. the two numbers that we are operating on\n\nReturn the result of the calculation.\n\nExample:\n\n\"Panda has 48 apples and loses 4\" returns 44\n\n\"Jerry has 34 apples and gains 6\" returns 40\n\n\"loses\" and \"gains\" are the only two words describing operators.\n\nShould be a nice little kata for you :)\n\nNote:\nNo fruit debts nor bitten apples = The numbers are integers and no negatives\n\"\"\"", "inputs": [["Panda has 48 apples and loses 4"], ["Jerry has 34 apples and gains 6"], ["Tom has 20 apples and gains 15"], ["Fred has 110 bananas and loses 50"], ["Pippi has 20 tunas and gains 0"]], "outputs": [[44], [40], [35], [60], [20]], "starter_code": "def calculate(s: str) -> int:", "canonical_solution": "def calculate(s):\n    x = [int(i) for i in s.split() if i.isdigit()]\n    return sum(x) if 'gains' in s.split() else x[0] - x[1]", "entry_point": "calculate", "task_id": "TACO_lite/804", "input_output_examples": "[[['Panda has 48 apples and loses 4'], ['Jerry has 34 apples and gains 6']], [[44], [40]]]", "llm_generated_inputs": {"deepseek-v3": "[['Panda has 48 apples and loses 4'], ['Jerry has 34 apples and gains 6'], ['Tom has 100 apples and loses 20'], ['Alice has 50 apples and gains 10'], ['Bob has 0 apples and loses 0'], ['Charlie has 1 apple and gains 1'], ['David has 999 apples and loses 1'], ['Eve has 123 apples and gains 456'], ['Frank has 7 apples and loses 7'], ['Grace has 10 apples and gains 0']]", "qwen2.5-coder-32b-instruct": "[['Panda has 48 apples and loses 4'], ['Jerry has 34 apples and gains 6'], ['Tommy has 100 oranges and loses 50'], ['Anna has 23 bananas and gains 77'], ['Bob has 0 cookies and gains 1'], ['Sara has 1 cookie and loses 1'], ['There are 99 balloons and gains 1'], ['There are 1 balloons and loses 1'], ['Sam has 5 apples and gains 5 apples'], ['Max has 100 apples and loses 100 apples']]"}}
{"requirement": "from typing import List\n\n\ndef sequence_classifier(arr: List[int]) -> int:\n\"\"\"A series or sequence of numbers is usually the product of a function and can either be infinite or finite.\n\nIn this kata we will only consider finite series and you are required to return a code according to the type of sequence:\n\n|Code|Type|Example|\n|-|-|-|\n|`0`|`unordered`|`[3,5,8,1,14,3]`|\n|`1`|`strictly increasing`|`[3,5,8,9,14,23]`|\n|`2`|`not decreasing`|`[3,5,8,8,14,14]`|\n|`3`|`strictly decreasing`|`[14,9,8,5,3,1]`|\n|`4`|`not increasing`|`[14,14,8,8,5,3]`|\n|`5`|`constant`|`[8,8,8,8,8,8]`|\n\nYou can expect all the inputs to be non-empty and completely numerical arrays/lists - no need to validate the data; do not go for sloppy code, as rather large inputs might be tested.\n\nTry to achieve a good solution that runs in linear time; also, do it functionally, meaning you need to build a *pure* function or, in even poorer words, do NOT modify the initial input!\n\"\"\"", "inputs": [[[3, 5, 8, 1, 14, 3]], [[3, 5, 8, 9, 14, 23]], [[3, 5, 8, 8, 14, 14]], [[14, 9, 8, 5, 3, 1]], [[14, 14, 8, 8, 5, 3]], [[8, 8, 8, 8, 8, 8]], [[8, 9]], [[8, 8, 8, 8, 8, 9]], [[9, 8]], [[9, 9, 9, 8, 8, 8]], [[3, 5, 8, 1, 14, 2]]], "outputs": [[0], [1], [2], [3], [4], [5], [1], [2], [3], [4], [0]], "starter_code": "from typing import List\ndef sequence_classifier(arr: List[int]) -> int:", "canonical_solution": "def sequence_classifier(arr):\n    if all((arr[i] == arr[i + 1] for i in range(len(arr) - 1))):\n        return 5\n    if all((arr[i] < arr[i + 1] for i in range(len(arr) - 1))):\n        return 1\n    if all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1))):\n        return 2\n    if all((arr[i] > arr[i + 1] for i in range(len(arr) - 1))):\n        return 3\n    if all((arr[i] >= arr[i + 1] for i in range(len(arr) - 1))):\n        return 4\n    return 0", "entry_point": "sequence_classifier", "task_id": "TACO_lite/807", "input_output_examples": "[[[[3, 5, 8, 1, 14, 3]], [[3, 5, 8, 9, 14, 23]], [[3, 5, 8, 8, 14, 14]], [[14, 9, 8, 5, 3, 1]], [[14, 14, 8, 8, 5, 3]], [[8, 8, 8, 8, 8, 8]]], [[0], [1], [2], [3], [4], [5]]]", "llm_generated_inputs": {"deepseek-v3": "[[[3, 5, 8, 1, 14, 3]], [[3, 5, 8, 9, 14, 23]], [[3, 5, 8, 8, 14, 14]], [[14, 9, 8, 5, 3, 1]], [[14, 14, 8, 8, 5, 3]], [[8, 8, 8, 8, 8, 8]], [[1]], [[1, 2, 3, 3, 2, 1]], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]], [[1, 1, 1, 2, 2, 3, 3, 3]], [[5, 4, 4, 3, 3, 2, 2, 1]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]", "qwen2.5-coder-32b-instruct": "[[[3, 5, 8, 1, 14, 3]], [[3, 5, 8, 9, 14, 23]], [[3, 5, 8, 8, 14, 14]], [[14, 9, 8, 5, 3, 1]], [[14, 14, 8, 8, 5, 3]], [[8, 8, 8, 8, 8, 8]], [[1]], [[1, 2]], [[2, 1]], [[1, 1]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]], [[1, 1, 1, 2, 2, 2, 3, 3, 3]], [[3, 3, 3, 2, 2, 2, 1, 1, 1]], [[1, 3, 2]], [[2, 1, 3]], [[1, 1, 2, 2, 1, 1]]]"}}
{"requirement": "def hot_singles(arr1: list, arr2: list) -> list:\n\"\"\"Write a function that takes two arguments, and returns a new array populated with the elements **that only appear once, in either one array or the other, taken only once**; display order should follow what appears in arr1 first, then arr2: \n\n```python\nhot_singles([1, 2, 3, 3], [3, 2, 1, 4, 5]) # [4, 5]\nhot_singles([\"tartar\", \"blanket\", \"cinnamon\"], [\"cinnamon\", \"blanket\", \"domino\"]) # [\"tartar\", \"domino\"]\nhot_singles([77, \"ciao\"], [78, 42, \"ciao\"]) # [77, 78, 42]\nhot_singles([1, 2, 3, 3], [3, 2, 1, 4, 5, 4]) # [4,5]\n```\n\nSPECIAL THANKS: @JulianKolbe !\n\"\"\"", "inputs": [[["tartar", "blanket", "domino"], ["blanket"]], [[77, "basketweave"], [78, 42, "basketweave"]], [[100, 45, "ciao"], [100, 2, 3, 45, 5]], [[10, 200, 30], [10, 20, 3, 4, 5, 5, 5, 200]], [[1, 2, 3, 3], [3, 2, 1, 4, 5, 4]]], "outputs": [[["tartar", "domino"]], [[77, 78, 42]], [["ciao", 2, 3, 5]], [[30, 20, 3, 4, 5]], [[4, 5]]], "starter_code": "def hot_singles(arr1: list, arr2: list) -> list:", "canonical_solution": "def hot_singles(arr1, arr2):\n    a = []\n    for x in arr1 + arr2:\n        if x in set(arr1) ^ set(arr2) and x not in a:\n            a.append(x)\n    return a", "entry_point": "hot_singles", "task_id": "TACO_lite/813", "input_output_examples": "[[[[1, 2, 3, 3], [3, 2, 1, 4, 5]], [['tartar', 'blanket', 'cinnamon'], ['cinnamon', 'blanket', 'domino']], [[77, 'ciao'], [78, 42, 'ciao']], [[1, 2, 3, 3], [3, 2, 1, 4, 5, 4]]], [[[4, 5]], [['tartar', 'domino']], [[77, 78, 42]], [[4, 5]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 3], [3, 2, 1, 4, 5]], [['tartar', 'blanket', 'cinnamon'], ['cinnamon', 'blanket', 'domino']], [[77, 'ciao'], [78, 42, 'ciao']], [[1, 2, 3, 3], [3, 2, 1, 4, 5, 4]], [[], [1, 2, 3]], [[1, 2, 3], []], [[], []], [[1, 1, 1], [2, 2, 2]], [[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [3, 4, 5]], [['a', 'b', 'c'], ['c', 'd', 'e']], [[None, 1, 2], [2, None, 3]], [[True, False], [False, True]], [[[1, 2], [3, 4]], [[3, 4], [5, 6]]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 3], [3, 2, 1, 4, 5]], [['tartar', 'blanket', 'cinnamon'], ['cinnamon', 'blanket', 'domino']], [[77, 'ciao'], [78, 42, 'ciao']], [[1, 2, 3, 3], [3, 2, 1, 4, 5, 4]], [[], []], [[1, 2, 3], []], [[], [1, 2, 3]], [[1, 1, 1], [1, 1, 1]], [[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [3, 2, 1]], [[1, 2, 2, 3], [3, 3, 2, 1]]]"}}
{"requirement": "def summation(num: int) -> int:\n\"\"\"# Summation\n\nWrite a program that finds the summation of every number from 1 to num. The number will always be a positive integer greater than 0.\n\n\n\nFor example:\n```if-not:racket\n~~~\nsummation(2) -> 3\n1 + 2\n\nsummation(8) -> 36\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8\n~~~\n```\n```if:racket\n~~~racket\n(summation 2) ; 3  (+ 1 2)\n(summation 8) ; 36 (+ 1 2 3 4 5 6 7 8)\n~~~\n```\n\"\"\"", "inputs": [[1], [8], [22], [100], [213]], "outputs": [[1], [36], [253], [5050], [22791]], "starter_code": "def summation(num: int) -> int:", "canonical_solution": "def summation(num):\n    return sum(range(num + 1))", "entry_point": "summation", "task_id": "TACO_lite/814", "input_output_examples": "[[[2], [8]], [[3], [36]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [5], [10], [100], [0], [-1], [1000]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [8], [100], [500]]"}}
{"requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef pair_of_shoes(a: List[Tuple[int, int]]) -> bool:\n\"\"\"# Task\n Yesterday you found some shoes in your room. Each shoe is described by two values:\n```\ntype indicates if it's a left or a right shoe;\nsize is the size of the shoe.\n```\n Your task is to check whether it is possible to pair the shoes you found in such a way that each pair consists of a right and a left shoe of an equal size.\n\n# Example\n\n For:\n```\nshoes = [[0, 21], \n         [1, 23], \n         [1, 21], \n         [0, 23]]\n         ```\nthe output should be `true;`\n\n For:\n```\nshoes = [[0, 21], \n         [1, 23], \n         [1, 21], \n         [1, 23]]\n         ```\nthe output should be `false.`\n\n# Input/Output\n\n - `[input]` 2D integer array `shoes`\n\n Array of shoes. Each shoe is given in the format [type, size], where type is either 0 or 1 for left and right respectively, and size is a positive integer.\n\n Constraints: `2 ≤ shoes.length ≤ 50,  1 ≤ shoes[i][1] ≤ 100.`\n\n - `[output]` a boolean value\n\n   `true` if it is possible to pair the shoes, `false` otherwise.\n\"\"\"", "inputs": [[[[0, 21], [1, 23], [1, 21], [0, 23]]], [[[0, 21], [1, 23], [1, 21], [1, 23]]], [[[0, 23], [1, 21], [1, 23], [0, 21], [1, 22], [0, 22]]], [[[0, 23], [1, 21], [1, 23], [0, 21]]], [[[0, 23], [1, 21], [1, 22], [0, 21]]], [[[0, 23]]], [[[0, 23], [1, 23]]], [[[0, 23], [1, 23], [1, 23], [0, 23]]], [[[0, 23], [1, 22]]], [[[0, 23], [1, 23], [1, 23], [0, 23], [0, 23], [0, 23]]]], "outputs": [[true], [false], [true], [true], [false], [false], [true], [true], [false], [false]], "starter_code": "from typing import List\nfrom typing import Tuple\ndef pair_of_shoes(a: List[Tuple[int, int]]) -> bool:", "canonical_solution": "def pair_of_shoes(a):\n    return sorted((s for lr, s in a if lr == 1)) == sorted((s for lr, s in a if lr == 0))", "entry_point": "pair_of_shoes", "task_id": "TACO_lite/815", "input_output_examples": "[[[[[0, 21], [1, 23], [1, 21], [0, 23]]], [[[0, 21], [1, 23], [1, 21], [1, 23]]]], [[True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[[[0, 21], [1, 23], [1, 21], [0, 23]]], [[[0, 21], [1, 23], [1, 21], [1, 23]]], [[[0, 10], [1, 10]]], [[[0, 10], [0, 10]]], [[[1, 10], [1, 10]]], [[[0, 15], [1, 15], [0, 20], [1, 20]]], [[[0, 15], [1, 15], [0, 20], [1, 21]]], [[[0, 5], [1, 5], [0, 5], [1, 5]]], [[[0, 5], [1, 5], [0, 5]]], [[[0, 5], [1, 5], [1, 5]]], [[[0, 30], [1, 30], [0, 30], [1, 30], [0, 40], [1, 40]]], [[[0, 30], [1, 30], [0, 30], [1, 30], [0, 40], [1, 41]]], [[[0, 100], [1, 100]]], [[[0, 1], [1, 1]]]]", "qwen2.5-coder-32b-instruct": "[[[[0, 21], [1, 23], [1, 21], [0, 23]]], [[[0, 21], [1, 23], [1, 21], [1, 23]]], [[[0, 21], [1, 21]]], [[[0, 21], [0, 21], [1, 21], [1, 21]]], [[[0, 21], [1, 22], [0, 22], [1, 21]]], [[[0, 21], [1, 21], [0, 21], [1, 21], [0, 22], [1, 22]]], [[[0, 1], [1, 100], [0, 50], [1, 50]]], [[[0, 50], [1, 50], [0, 50], [1, 50], [0, 50], [1, 50]]], [[[0, 21]]], [[]]]"}}
{"requirement": "def hofstadter_q(n: int) -> int:\n\"\"\"Hofstadter sequences are a family of related integer sequences, among which the first ones were described by an American professor Douglas Hofstadter in his book Gödel, Escher, Bach. \n\n### Task\nToday we will be implementing the rather chaotic recursive sequence of integers called Hofstadter Q.\nThe Hofstadter Q is defined as:\n\nAs the author states in the aforementioned book:It is reminiscent of the Fibonacci definition in that each new value is a sum of two\nprevious values-but not of the immediately previous two values. Instead, the two\nimmediately previous values tell how far to count back to obtain the numbers to be added\nto make the new value.\nThe function produces the starting sequence:  \n`1, 1, 2, 3, 3, 4, 5, 5, 6 . . .`  \nTest info: 100 random tests, n is always positive\nGood luck!\n\"\"\"", "inputs": [[1], [3], [7], [10], [100], [1000]], "outputs": [[1], [2], [5], [6], [56], [502]], "starter_code": "def hofstadter_q(n: int) -> int:", "canonical_solution": "def hofstadter_q(n):\n    q = [1, 1]\n    while len(q) < n:\n        q.append(q[-q[-1]] + q[-q[-2]])\n    return q[-1]", "entry_point": "hofstadter_q", "task_id": "TACO_lite/816", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [4], [5], [10], [20], [50], [100], [1000]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [20], [50], [100]]"}}
{"requirement": "def unused_digits(*args: int) -> str:\n\"\"\"Given few numbers, you need to print out the digits that are not being used.\n\nExample:\n\n```python\nunused_digits(12, 34, 56, 78) # \"09\"\nunused_digits(2015, 8, 26) # \"3479\"\n```\n\nNote:\n\n- Result string should be sorted\n- The test case won't pass Integer with leading zero\n\"\"\"", "inputs": [[12, 34, 56, 78], [2015, 8, 26], [276, 575], [643], [864, 896, 744], [364, 500, 715, 730], [93, 10, 11, 40], [1, 11, 111, 1111, 11111], [9, 87, 654, 3210]], "outputs": [["09"], ["3479"], ["013489"], ["0125789"], ["01235"], ["289"], ["25678"], ["023456789"], [""]], "starter_code": "def unused_digits(*args: int) -> str:", "canonical_solution": "def unused_digits(*args):\n    return ''.join((number for number in '0123456789' if number not in str(args)))", "entry_point": "unused_digits", "task_id": "TACO_lite/821", "input_output_examples": "[[[[12, 34, 56, 78]], [[2015, 8, 26]]], [['09'], ['3479']]]", "llm_generated_inputs": {"deepseek-v3": "[[1234567890], [0], [987654321], [1020304050], [9999999999], [1000000000]]", "qwen2.5-coder-32b-instruct": "[[9876543210], [0], [9], [123456789]]"}}
{"requirement": "from typing import List\n\n\ndef pete_talk(speech: str, ok: List[str] = []) -> str:\n\"\"\"Our friendly friend Pete is really a nice person, but he tends to be rather... Inappropriate.\n\nAnd possibly loud, if given enough ethanol and free rein, so we ask you to write a function that should take its not always \"clean\" speech and cover as much as possible of it, in order not to offend some more sensible spirits.\n\nFor example, given an input like\n```\nWhat the hell am I doing here? And where is my wallet? PETE SMASH!\n```\nYou are expected to turn it into something like:\n```\nW**t t*e h**l am i d***g h**e? A*d w***e is my w****t? P**e s***h!\n```\nIn case you didn't figure out the rules yet: any words longer than 2 characters need to have its \"inside\" (meaning every character which is not the first or the last) changed into `*`;  as we do not want Pete to scream too much, every uppercase letter which is not at the beginning of the string or coming after a punctuation mark among [\".\",\"!\",\"?\"] needs to be put to lowercase; spaces and other punctuation marks can be ignored.\n\nConversely, you need to be sure that the start of each sentence has a capitalized word at the beginning. Sentences are divided by the aforementioned punctuation marks.\n\nFinally, the function will take an additional parameter consisting of an array/list of allowed words (upper or lower case) which are not to be replaced (the match has to be case insensitive).\n\nExtra cookies if you can do it all in some efficient way and/or using our dear regexes ;)\n\n**Note:** Absolutely not related to [a certain codewarrior I know](http://www.codewars.com/users/petegarvin1) :p\n\"\"\"", "inputs": [["I want to punch someone in the face"], ["uh!"], ["What the hell am I doing here? And where is my wallet? PETE SMASH!"], ["I want to punch someone in the face", ["someone", "face"]], ["I want to punch someone in the face", ["drink", "job", "girls"]]], "outputs": [["I w**t to p***h s*****e in t*e f**e"], ["Uh!"], ["W**t t*e h**l am i d***g h**e? A*d w***e is my w****t? P**e s***h!"], ["I w**t to p***h someone in t*e face"], ["I w**t to p***h s*****e in t*e f**e"]], "starter_code": "from typing import List\ndef pete_talk(speech: str, ok: List[str] = []) -> str:", "canonical_solution": "import re\nPATTERN = re.compile('(?P<first>(?:(?<=[.!?] )|^)\\\\w+)|(?P<other>\\\\w+)')\n\ndef pete_talk(speech, ok=[]):\n\n    def watchYourMouth(m):\n        w = (m.group('first') or m.group('other')).lower()\n        if w not in ok and len(w) > 1:\n            w = w[0] + '*' * (len(w) - 2) + w[-1]\n        if m.group('first'):\n            w = w.capitalize()\n        return w\n    ok = set(map(str.lower, ok))\n    return PATTERN.sub(watchYourMouth, speech)", "entry_point": "pete_talk", "task_id": "TACO_lite/827", "input_output_examples": "[[[]], [[]]]", "llm_generated_inputs": {"deepseek-v3": "[['What the hell am I doing here? And where is my wallet? PETE SMASH!', ['hell', 'SMASH']], ['Hello world! This is a TEST.', ['TEST']], ['This is a simple test.', []], ['No changes needed.', ['No', 'changes', 'needed']], ['UPPERCASE lowercase MiXeDcase.', ['MiXeDcase']], ['', []], ['Short.', []], ['This sentence has no punctuation', []], ['multiple    spaces', []], ['What the hell am I doing here? And where is my wallet? PETE SMASH!', []], ['What the hell am I doing here? And where is my wallet? PETE SMASH!', ['PETE', 'SMASH']], ['What the hell am I doing here? And where is my wallet? PETE SMASH!', ['what', 'the', 'am', 'i', 'doing', 'here', 'and', 'where', 'is', 'my', 'wallet']], ['What the hell am I doing here? And where is my wallet? PETE SMASH!', ['what', 'the', 'am', 'i', 'doing', 'here', 'and', 'where', 'is', 'my', 'wallet', 'PETE', 'SMASH']]]", "qwen2.5-coder-32b-instruct": "[['What the hell am I doing here? And where is my wallet? PETE SMASH!', []], ['HELLO WORLD! THIS IS A TEST.', ['hello', 'is']], ['pete loves to eat pizza.', ['pete', 'pizza']], ['SHOUTING IN ALL CAPS CAN BE ANNOYING.', ['shouting', 'caps']], ['Short words.', ['short']], ['', []], ['A!', []], ['Multiple... Punctuation!!! Marks?', []], ['Allowed words: Pete, Smash.', ['pete', 'smash']], ['Edge CASE edge case.', ['edge', 'case']]]"}}
{"requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef get_neighbourhood(typ: str, arr: List[List[int]], coordinates: Tuple[int, int]) -> List[int]:\n\"\"\"This kata is the second part of a series: [Neighbourhood kata collection](https://www.codewars.com/collections/5b2f4db591c746349d0000ce). If this one is to easy you can try out the harder Katas.;)\n\n___\nThe neighbourhood of a cell (in a matrix) are cells that are near to it. There are two popular types:\n- The [Moore neighborhood](https://en.wikipedia.org/wiki/Moore_neighborhood) are eight cells which surround a given cell.\n- The [Von Neumann neighborhood](https://en.wikipedia.org/wiki/Von_Neumann_neighborhood) are four cells which share a border with the given cell.\n\n___\n\n# Task\nGiven a neighbourhood type (`\"moore\"` or `\"von_neumann\"`), a 2D matrix (a list of lists) and a pair of coordinates, return the list of neighbours of the given cell.\n\nNotes:\n- The order of the elements in the output list is not important. \n- If the input indexes are outside the matrix, return an empty list.\n- If the the matrix is empty, return an empty list.\n- Order of the indices: The first index should be applied for the outer/first matrix layer. The last index for the most inner/last layer. `coordinates = (m, n)` should be apllied like `mat[m][n]`\n\n___\n\n## Examples\n```\n\\ n   0    1    2    3    4\nm  --------------------------\n0  |  0 |  1 |  2 |  3 |  4 |\n1  |  5 |  6 |  7 |  8 |  9 |\n2  | 10 | 11 | 12 | 13 | 14 |\n3  | 15 | 16 | 17 | 18 | 19 |\n4  | 20 | 21 | 22 | 23 | 24 |\n   --------------------------\n\nget_neighborhood(\"moore\", mat, (1,1)) == [0, 1, 2, 5, 7, 10, 11, 12]\nget_neighborhood(\"moore\", mat, (0,0)) == [1, 6, 5]\nget_neighborhood(\"moore\", mat, (4,2)) == [21, 16, 17, 18, 23]\nget_neighborhood(\"von_neumann\", mat, (1,1)) == [1, 5, 7, 11]\nget_neighborhood(\"von_neumann\", mat, (0,0)) == [1, 5]\nget_neighborhood(\"von_neumann\", mat, (4,2)) == [21, 17, 23]\n```\n___\n\nTranslations are appreciated.^^\n\nIf you like chess take a look at [Chess Aesthetics](https://www.codewars.com/kata/5b574980578c6a6bac0000dc)\n\nIf you like puzzles and take a look at [Rubik's cube](https://www.codewars.com/kata/5b3bec086be5d8893000002e)\n\"\"\"", "inputs": [["moore", [[]], [0, 0]], ["von_neumann", [[]], [0, 0]], ["moore", [[], [], []], [0, 0]], ["von_neumann", [[], [], []], [0, 0]]], "outputs": [[[]], [[]], [[]], [[]]], "starter_code": "from typing import List\nfrom typing import Tuple\ndef get_neighbourhood(typ: str, arr: List[List[int]], coordinates: Tuple[int, int]) -> List[int]:", "canonical_solution": "def get_neighbourhood(typ, arr, coordinates):\n\n    def isInside(x, y):\n        return 0 <= x < len(arr) and 0 <= y < len(arr[0])\n    x, y = coordinates\n    if not isInside(x, y):\n        return []\n    neigh = [(dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if (dx, dy) != (0, 0)] if typ == 'moore' else [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    return [arr[a][b] for a, b in ((x + dx, y + dy) for dx, dy in neigh) if isInside(a, b)]", "entry_point": "get_neighbourhood", "task_id": "TACO_lite/829", "input_output_examples": "[[['moore', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (1, 1)], ['moore', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (0, 0)], ['moore', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (4, 2)], ['von_neumann', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (1, 1)], ['von_neumann', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (0, 0)], ['von_neumann', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (4, 2)]], [[[0, 1, 2, 5, 7, 10, 11, 12]], [[1, 6, 5]], [[21, 16, 17, 18, 23]], [[1, 5, 7, 11]], [[1, 5]], [[21, 17, 23]]]]", "llm_generated_inputs": {"deepseek-v3": "[['moore', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (1, 1)], ['von_neumann', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (1, 1)], ['moore', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (0, 0)], ['von_neumann', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (0, 0)], ['moore', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (2, 2)], ['von_neumann', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (2, 2)], ['moore', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (2, 0)], ['von_neumann', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (2, 0)], ['moore', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (0, 2)], ['von_neumann', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (0, 2)], ['moore', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (3, 3)], ['von_neumann', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (3, 3)], ['moore', [], (0, 0)], ['von_neumann', [], (0, 0)], ['moore', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (-1, -1)], ['von_neumann', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (-1, -1)], ['moore', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (1, 3)], ['von_neumann', [[0, 1, 2], [3, 4, 5], [6, 7, 8]], (1, 3)]]", "qwen2.5-coder-32b-instruct": "[['moore', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (1, 1)], ['moore', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (0, 0)], ['moore', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (4, 2)], ['von_neumann', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (1, 1)], ['von_neumann', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (0, 0)], ['von_neumann', [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]], (4, 2)], ['moore', [], (0, 0)], ['von_neumann', [], (0, 0)], ['moore', [[1, 2], [3, 4]], (-1, -1)], ['von_neumann', [[1, 2], [3, 4]], (-1, -1)], ['moore', [[1, 2], [3, 4]], (2, 2)], ['von_neumann', [[1, 2], [3, 4]], (2, 2)], ['moore', [[1, 2], [3, 4]], (0, 1)], ['von_neumann', [[1, 2], [3, 4]], (0, 1)]]"}}
{"requirement": "from typing import List\n\n\ndef longest_collatz(input_array: List[int]) -> int:\n\"\"\"##Background - the Collatz Conjecture:\n\nImagine you are given a positive integer, `n`, then:\n\n* if `n` is even, calculate: `n / 2`\n* if `n` is odd, calculate: `3 * n + 1`\n\nRepeat until your answer is `1`. The Collatz conjecture states that performing this operation repeatedly, you will always eventually reach `1`.\n\nYou can try creating Collatz sequences with [this](http://www.codewars.com/kata/5286b2e162056fd0cb000c20) kata. For further information, see the [wiki page](https://en.wikipedia.org/wiki/Collatz_conjecture).\n\n##Now! Your task:\n\n**Given an array of positive integers, return the integer whose Collatz sequence is the longest.**\n\nExample:\n\n```python\nlongest_collatz([2, 4, 3])==3\n```\n\nExplanation: The Collatz sequence for `2` has a length of `1`, the sequence for `4` has a length of `2`, and the sequence for `3` has a length of `7`. So from our array, the integer `3` is the one with the longest Collatz sequence.\n\nHence, your function should return `3`.\n\n##Note:\n\nThere may be more than one answer, i.e. two or more integers produce the longest Collatz sequence, because they happen to have sequences of the same length. **In this case, your function should return the integer that appears first in the array.**\n\nExample:\nGiven an array: `[2, 5, 32]`, both `5` and `32` have Collatz sequences of length 5. These are also the longest sequences from our array.\n\nIn this case, our function returns `5`, because `5` comes before `32` in our array.\n\"\"\"", "inputs": [[[1, 5, 27, 4]], [[64, 64, 27, 64]], [[75, 226, 113, 340]], [[340, 113, 226, 75]], [[75, 113, 226, 75]]], "outputs": [[27], [27], [75], [75], [75]], "starter_code": "from typing import List\ndef longest_collatz(input_array: List[int]) -> int:", "canonical_solution": "def collatz(n, t=1):\n    return t if n == 1 else collatz(n / 2 if n % 2 == 0 else 3 * n + 1, t + 1)\n\ndef longest_collatz(input_array):\n    return sorted(list(zip(list(map(collatz, input_array)), input_array)))[-1][1]", "entry_point": "longest_collatz", "task_id": "TACO_lite/832", "input_output_examples": "[[[[2, 4, 3]], [[2, 5, 32]]], [[3], [5]]]", "llm_generated_inputs": {"deepseek-v3": "[[[2, 4, 3]], [[2, 5, 32]], [[1]], [[10, 20, 30, 40]], [[7, 15, 23]], [[1, 2, 3, 4, 5]], [[1000000]], [[16, 8, 4, 2]], [[27]], [[3, 6, 9, 12]]]", "qwen2.5-coder-32b-instruct": "[[[2, 4, 3]], [[2, 5, 32]], [[1, 2, 3, 4, 5]], [[6, 7, 8, 9, 10]], [[11, 12, 13, 14, 15]], [[16, 17, 18, 19, 20]], [[100]], [[1]], [[77]], [[27, 54, 108]], [[5, 5, 5, 5]], [[1, 1, 1, 1]]]"}}
{"requirement": "from typing import List\n\n\ndef owned_cat_and_dog(cy: int, dy: int) -> List[int]:\n\"\"\"This is related to my other Kata about cats and dogs.\n\n# Kata Task\n\nI have a cat and a dog which I got as kitten / puppy.\n\nI forget when that was, but I do know their current ages as `catYears` and `dogYears`.\n\nFind how long I have owned each of my pets and return as a list [`ownedCat`, `ownedDog`]\n\nNOTES:\n* Results are truncated whole numbers of \"human\" years\n\n## Cat Years\n\n* `15` cat years for first year\n* `+9` cat years for second year\n* `+4` cat years for each year after that\n\n## Dog Years\n\n* `15` dog years for first year\n* `+9` dog years for second year\n* `+5` dog years for each year after that\n\n\n\n**References**\n\n* http://www.catster.com/cats-101/calculate-cat-age-in-cat-years\n* http://www.slate.com/articles/news_and_politics/explainer/2009/05/a_dogs_life.html\n\"\"\"", "inputs": [[9, 7], [15, 15], [18, 21], [19, 17], [24, 24], [25, 25], [26, 26], [27, 27], [56, 64]], "outputs": [[[0, 0]], [[1, 1]], [[1, 1]], [[1, 1]], [[2, 2]], [[2, 2]], [[2, 2]], [[2, 2]], [[10, 10]]], "starter_code": "from typing import List\ndef owned_cat_and_dog(cy: int, dy: int) -> List[int]:", "canonical_solution": "def owned_cat_and_dog(cy, dy):\n    cat = 0 if cy < 15 else 1 if cy < 24 else 2 + (cy - 24) // 4\n    dog = 0 if dy < 15 else 1 if dy < 24 else 2 + (dy - 24) // 5\n    return [cat, dog]", "entry_point": "owned_cat_and_dog", "task_id": "TACO_lite/836", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[0, 0], [15, 15], [24, 24], [28, 29], [32, 34], [1, 1], [14, 14], [16, 16], [25, 25], [100, 100], [-1, -1], [1000, 1000]]", "qwen2.5-coder-32b-instruct": "[[15, 15], [24, 24], [28, 33], [0, 0], [1, 1], [2, 2], [3, 3], [100, 100], [16, 16], [23, 23], [32, 42]]"}}
{"requirement": "from typing import List\n\n\ndef amazon_check_mate(king: str, amazon: str) -> List[int]:\n\"\"\"# Task\n An `amazon` (also known as a queen+knight compound) is an imaginary chess piece that can move like a `queen` or a `knight` (or, equivalently, like a `rook`, `bishop`, or `knight`). The diagram below shows all squares which the amazon attacks from e4 (circles represent knight-like moves while crosses correspond to queen-like moves).\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/amazonCheckmate/img/amazon.png?_tm=1473934566013)\n\n Recently you've come across a diagram with only three pieces left on the board: a `white amazon`, `white king` and `black king`. \n \n It's black's move. You don't have time to determine whether the game is over or not, but you'd like to figure it out in your head. \n \n Unfortunately, the diagram is smudged and you can't see the position of the `black king`, so it looks like you'll have to check them all.\n\n Given the positions of white pieces on a standard chessboard, determine the number of possible black king's positions such that: \n\n* It's a checkmate (i.e. black's king is under amazon's \n attack and it cannot make a valid move);\n\n* It's a check (i.e. black's king is under amazon's attack \n but it can reach a safe square in one move);\n\n* It's a stalemate (i.e. black's king is on a safe square \n but it cannot make a valid move);\n\n* Black's king is on a safe square and it can make a valid move.\n\nNote that two kings cannot be placed on two adjacent squares (including two diagonally adjacent ones).\n\n# Example\n\n For `king = \"d3\" and amazon = \"e4\"`, the output should be `[5, 21, 0, 29]`.\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/amazonCheckmate/img/example1.png?_tm=1473934566299)\n\n `Red crosses` correspond to the `checkmate` positions, `orange pluses` refer to `checks` and `green circles` denote `safe squares`.\n\n For `king = \"a1\" and amazon = \"g5\"`, the output should be `[0, 29, 1, 29]`.\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/amazonCheckmate/img/example2.png?_tm=1473934566670)\n\n `Stalemate` position is marked by a `blue square`.\n\n# Input\n\n\n - String `king`\n\nPosition of white's king in chess notation.\n\n\n - String `amazon`\n\nPosition of white's amazon in the same notation.\n\nConstraints: `amazon ≠ king.`\n\n# Output\n\nAn array of four integers, each equal to the number of black's king positions corresponding to a specific situation. The integers should be presented in the same order as the situations were described, `i.e. 0 for checkmates, 1 for checks, etc`.\n\"\"\"", "inputs": [["a1", "g5"], ["a3", "e4"], ["f3", "f2"], ["b7", "a8"], ["f7", "d3"], ["g2", "c3"], ["f3", "c1"], ["d4", "h8"], ["h6", "a7"], ["a6", "g3"], ["e1", "b4"], ["f4", "c4"], ["c3", "e8"], ["b5", "e5"], ["c8", "g8"], ["a6", "b5"], ["b3", "e2"], ["b7", "c3"], ["b5", "b3"], ["a4", "a6"], ["h2", "a5"], ["b7", "c1"], ["e6", "e7"], ["a2", "c6"], ["a6", "e1"], ["e8", "g7"], ["f5", "f7"], ["h3", "d8"], ["b1", "f8"], ["c7", "a2"], ["f1", "a5"], ["g6", "f3"], ["g2", "c6"], ["d1", "e1"], ["h6", "b5"], ["e4", "e8"], ["b6", "d5"], ["b4", "h8"], ["e5", "b4"], ["g1", "g6"], ["a3", "a5"], ["g4", "g3"], ["c4", "e7"], ["d3", "a3"], ["a2", "e6"], ["f2", "f3"], ["g4", "b4"], ["a5", "g2"], ["b7", "b4"], ["a4", "a7"], ["h7", "a8"], ["a7", "d7"], ["e4", "a6"], ["e2", "g1"], ["e7", "b2"], ["e5", "f6"], ["b8", "b2"], ["c7", "e8"], ["e7", "e5"], ["a5", "b4"], ["d4", "e8"], ["g7", "h3"], ["a3", "b5"], ["f5", "e7"], ["d3", "b7"], ["h1", "e8"], ["g6", "g1"], ["e6", "c8"], ["c5", "c8"], ["f4", "b1"], ["g3", "b8"], ["e2", "a3"], ["c3", "c6"], ["f1", "c7"], ["a5", "e1"], ["b7", "g8"], ["g5", "e8"], ["e4", "f2"], ["b1", "a4"], ["h3", "e4"], ["g6", "b2"], ["a7", "c2"], ["e2", "f8"], ["h5", "d1"], ["h1", "f3"], ["e5", "f2"], ["f2", "a7"], ["e4", "g5"], ["d6", "b3"], ["g4", "a4"], ["a5", "d6"], ["a8", "d6"], ["a6", "h1"], ["f4", "c8"], ["d4", "g3"], ["e7", "a8"], ["g3", "c8"], ["b2", "h2"], ["a3", "h1"], ["g6", "e8"], ["e7", "d3"], ["f4", "g6"], ["h2", "d6"], ["a8", "e5"], ["c4", "d8"], ["c4", "b6"], ["d4", "a6"], ["c6", "d8"]], "outputs": [[[0, 29, 1, 29]], [[1, 32, 1, 23]], [[6, 11, 0, 38]], [[0, 10, 0, 45]], [[4, 28, 1, 21]], [[9, 21, 0, 24]], [[4, 18, 0, 32]], [[0, 18, 0, 36]], [[0, 22, 0, 35]], [[3, 26, 1, 27]], [[0, 27, 2, 28]], [[3, 24, 0, 27]], [[0, 25, 0, 29]], [[0, 30, 0, 24]], [[1, 19, 0, 37]], [[5, 19, 1, 33]], [[0, 24, 1, 29]], [[9, 21, 0, 24]], [[3, 17, 0, 34]], [[2, 16, 0, 39]], [[0, 25, 0, 32]], [[2, 20, 0, 32]], [[3, 14, 1, 37]], [[9, 24, 0, 24]], [[0, 24, 0, 33]], [[0, 22, 0, 35]], [[3, 16, 0, 35]], [[0, 24, 0, 33]], [[2, 23, 0, 32]], [[2, 22, 0, 30]], [[0, 24, 0, 33]], [[7, 21, 0, 26]], [[7, 23, 0, 24]], [[2, 16, 0, 40]], [[0, 27, 1, 29]], [[1, 19, 0, 34]], [[0, 28, 0, 26]], [[0, 22, 0, 32]], [[0, 24, 1, 29]], [[3, 24, 1, 29]], [[0, 19, 0, 38]], [[6, 12, 0, 37]], [[0, 26, 1, 27]], [[2, 15, 0, 37]], [[3, 28, 0, 26]], [[7, 18, 0, 30]], [[0, 26, 1, 27]], [[0, 27, 0, 30]], [[0, 24, 1, 29]], [[0, 18, 0, 39]], [[0, 21, 0, 36]], [[0, 25, 0, 32]], [[3, 21, 0, 30]], [[0, 17, 0, 37]], [[0, 26, 0, 28]], [[12, 10, 0, 33]], [[0, 25, 0, 32]], [[0, 18, 0, 36]], [[0, 28, 0, 26]], [[5, 19, 1, 33]], [[1, 21, 0, 32]], [[4, 18, 0, 32]], [[0, 24, 2, 31]], [[0, 22, 1, 31]], [[1, 25, 0, 28]], [[0, 25, 0, 34]], [[0, 20, 1, 33]], [[3, 15, 0, 36]], [[2, 15, 0, 37]], [[0, 22, 0, 32]], [[0, 21, 0, 33]], [[4, 18, 0, 32]], [[7, 20, 0, 27]], [[3, 26, 1, 27]], [[0, 23, 0, 34]], [[0, 21, 0, 33]], [[0, 22, 1, 31]], [[3, 19, 0, 32]], [[0, 21, 0, 36]], [[0, 31, 0, 26]], [[0, 25, 0, 29]], [[3, 26, 0, 28]], [[2, 20, 0, 32]], [[0, 23, 0, 34]], [[4, 25, 0, 30]], [[3, 21, 0, 30]], [[0, 21, 0, 33]], [[0, 22, 1, 31]], [[3, 23, 0, 28]], [[0, 22, 0, 32]], [[3, 26, 0, 28]], [[3, 28, 0, 28]], [[0, 22, 0, 35]], [[2, 21, 0, 31]], [[3, 21, 0, 30]], [[2, 18, 0, 34]], [[2, 21, 0, 31]], [[0, 21, 0, 33]], [[1, 22, 0, 34]], [[2, 18, 0, 34]], [[4, 26, 0, 24]], [[3, 19, 0, 32]], [[3, 28, 0, 26]], [[0, 34, 0, 25]], [[1, 21, 0, 32]], [[3, 19, 0, 32]], [[2, 20, 0, 32]], [[0, 18, 0, 36]]], "starter_code": "from typing import List\ndef amazon_check_mate(king: str, amazon: str) -> List[int]:", "canonical_solution": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef amazon_check_mate(*args):\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for z, dz in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for dx, dy in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    K, Q = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in args]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for dx, dy in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts", "entry_point": "amazon_check_mate", "task_id": "TACO_lite/845", "input_output_examples": "[[['d3', 'e4'], ['a1', 'g5']], [[[5, 21, 0, 29]], [[0, 29, 1, 29]]]]", "llm_generated_inputs": {"deepseek-v3": "[['d3', 'e4'], ['a1', 'g5'], ['h8', 'h1'], ['a8', 'h1'], ['e5', 'e5'], ['c4', 'c4'], ['b2', 'b2'], ['g7', 'a1'], ['f6', 'c3'], ['h8', 'a8']]", "qwen2.5-coder-32b-instruct": "[['d3', 'e4'], ['a1', 'g5'], ['h8', 'a1'], ['e5', 'e5'], ['b1', 'c3'], ['f8', 'f1'], ['d4', 'd4'], ['g1', 'h3'], ['a8', 'h1'], ['e4', 'd2']]"}}
{"requirement": "from typing import List\n\n\ndef get_new_notes(salary: int, bills: List[int]) -> int:\n\"\"\"The new £5 notes have been recently released in the UK and they've certainly became a sensation! Even those of us who haven't been carrying any cash around for a while, having given in to the convenience of cards, suddenly like to have some of these in their purses and pockets. But how many of them could you get with what's left from your salary after paying all bills? The programme that you're about to write will count this for you!\n\nGiven a salary and the array of bills, calculate your disposable income for a month and return it as a number of new £5 notes you can get with that amount. If the money you've got (or do not!) doesn't allow you to get any £5 notes return 0.\n\n£££ GOOD LUCK! £££\n\"\"\"", "inputs": [[2000, [500, 160, 400]], [1260, [500, 50, 100]], [3600, [1800, 350, 460, 500, 15]], [1995, [1500, 19, 44]], [10000, [1800, 500, 1200, 655, 150]], [2300, [590, 1500, 45, 655, 150]], [5300, [1190, 1010, 1045, 55, 10, 19, 55]], [2000, [500, 495, 100, 900]], [2000, [500, 496, 100, 900]], [2000, [500, 494, 100, 900]]], "outputs": [[188], [122], [95], [86], [1139], [0], [383], [1], [0], [1]], "starter_code": "from typing import List\ndef get_new_notes(salary: int, bills: List[int]) -> int:", "canonical_solution": "def get_new_notes(salary, bills):\n    return max(salary - sum(bills), 0) // 5", "entry_point": "get_new_notes", "task_id": "TACO_lite/847", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[2000, [300, 500, 200]], [1500, [1000, 200, 100]], [1000, [1200, 300]], [500, [500]], [0, [100, 200]], [2500, []], [100, [150, 50]], [3000, [1000, 1000, 1000]], [50, [50]], [100, [100, 50]]]", "qwen2.5-coder-32b-instruct": "[[100, [20, 30, 10]], [50, [5, 10, 15]], [20, [5, 5, 5, 5]], [0, [10, 20, 30]], [100, []], [25, [5, 5, 5, 5]], [5, [1, 2, 1]], [120, [30, 40, 20, 10]], [500, [100, 100, 100, 100, 100]], [2, [1]]]"}}
{"requirement": "def find_codwars(url: str) -> bool:\n\"\"\"A marine themed rival site to Codewars has started. Codwars is advertising their website all over the internet using subdomains to hide or obfuscate their domain to trick people into clicking on their site.\n\nYour task is to write a function that accepts a URL as a string and determines if it would result in an http request to codwars.com.\n\nFunction should return true for all urls in the codwars.com domain. All other URLs should return false.\n\nThe urls are all valid but may or may not contain http://, https:// at the beginning or subdirectories or querystrings at the end.\n\nFor additional confusion, directories in can be named \"codwars.com\" in a url with the codewars.com domain and vise versa. Also, a querystring may contain codewars.com or codwars.com for any other domain - it should still return true or false based on the domain of the URL and not the domain in the querystring. Subdomains can also add confusion: for example `http://codwars.com.codewars.com` is a valid URL in the codewars.com domain in the same way that `http://mail.google.com` is a valid URL within google.com\n\nUrls will not necessarily have either codewars.com or codwars.com in them. The folks at Codwars aren't very good about remembering the contents of their paste buffers.\n\nAll urls contain domains with a single TLD; you need not worry about domains like company.co.uk.\n\n```\nfindCodwars(\"codwars.com\"); // true\nfindCodwars(\"https://subdomain.codwars.com/a/sub/directory?a=querystring\"); // true\nfindCodwars(\"codewars.com\"); // false\nfindCodwars(\"https://subdomain.codwars.codewars.com/a/sub/directory/codwars.com?a=querystring\"); // false\n```\n\"\"\"", "inputs": [["codwars.com"], ["http://codwars.com"], ["http://kcodwars.com"], ["https://www.codwars.com"], ["https://www.codwars.com/kata"], ["codewars.com.codwars.com"], ["https://www.codwars.com/kata?this=is&a=querystring"], ["https://this.is.an.unneccesarily.long.subdomain.codwars.com/katas.are.really.fun.codewars.com/"], ["http://codwars.com?impersonate=codewars.com"], ["codewars.com"], ["codwars.comp"], ["codwarsecom"], ["codwars.com.com"], ["codwarss.com"], ["ecodwars.comp"], ["codwars.com.codwars.comp"], ["codwars.com.ecodwars.comp"], ["www.codewars.com/codwars"], ["http://codewars.com"], ["https://www.codewars.com"], ["https://www.codewars.com/kata"], ["http://codewars.com?impersonate=codwars.com"], ["https://www.codewars.com/kata?this=is&a=querystring"], ["https://this.is.an.unneccesarily.long.subdomain.codewars.com/katas.are.really.fun.codwars.com/"], ["https://this.is.an.unneccesarily.long.subdomain.codwars.comp/katas.are.really.fun.codwars.com/"], ["hotmail.com"]], "outputs": [[true], [true], [false], [true], [true], [true], [true], [true], [true], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false]], "starter_code": "def find_codwars(url: str) -> bool:", "canonical_solution": "import re\n\ndef find_codwars(url):\n    return bool(re.match('^(https?://)?([a-z]+\\\\.)*codwars\\\\.com([/?].*)?$', url))", "entry_point": "find_codwars", "task_id": "TACO_lite/850", "input_output_examples": "[[['codwars.com'], ['https://subdomain.codwars.com/a/sub/directory?a=querystring'], ['codewars.com'], ['https://subdomain.codwars.codewars.com/a/sub/directory/codwars.com?a=querystring']], [[True], [True], [False], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[['codwars.com'], ['https://subdomain.codwars.com/a/sub/directory?a=querystring'], ['codewars.com'], ['https://subdomain.codwars.codewars.com/a/sub/directory/codwars.com?a=querystring'], ['http://codwars.com'], ['https://codwars.com'], ['https://codwars.com/path/to/resource'], ['https://codwars.com?query=codwars.com'], ['https://codwars.com/codwars.com/path'], ['https://codwars.com.codewars.com'], ['https://codwars.com.codewars.com/path'], ['https://codwars.com.codewars.com?query=codwars.com'], ['https://codwars.com/codewars.com/path'], ['https://codwars.com/codewars.com?query=codwars.com'], ['https://codwars.com/path/to/codewars.com'], ['https://codwars.com?query=codewars.com'], ['https://codwars.com/path/to/codwars.com?query=codwars.com'], ['https://codwars.com/path/to/codwars.com/codwars.com'], ['https://codwars.com/path/to/codwars.com/codwars.com?query=codwars.com']]", "qwen2.5-coder-32b-instruct": "[['codwars.com'], ['https://subdomain.codwars.com/a/sub/directory?a=querystring'], ['codewars.com'], ['https://subdomain.codwars.codewars.com/a/sub/directory/codwars.com?a=querystring'], ['http://codwars.com'], ['https://codwars.com'], ['http://www.codwars.com'], ['https://www.codwars.com'], ['http://subdomain.codwars.com'], ['https://subdomain.codwars.com/'], ['http://codwars.com.codewars.com'], ['https://codwars.com.codewars.com'], ['http://otherdomain.com/codwars.com'], ['https://otherdomain.com/codwars.com'], ['http://otherdomain.com?query=codwars.com'], ['https://otherdomain.com?query=codwars.com'], ['http://otherdomain.com/path/to/codwars.com'], ['https://otherdomain.com/path/to/codwars.com'], ['ftp://codwars.com'], ['codwars.co.uk'], ['codewarscom'], ['http://.codwars.com'], ['http://codwars.com.']]"}}
{"requirement": "from typing import List\n\n\ndef same(arr_a: List[List[int]], arr_b: List[List[int]]) -> bool:\n\"\"\"Given two arrays, the purpose of this Kata is to check if these two arrays are the same. \"The same\" in this Kata means the two arrays contains arrays of 2 numbers which are same and not necessarily sorted the same way. i.e. [[2,5], [3,6]] is same as [[5,2], [3,6]] or [[6,3], [5,2]] or [[6,3], [2,5]] etc\n\n[[2,5], [3,6]] is NOT the same as [[2,3], [5,6]]\nTwo empty arrays [] are the same\n[[2,5], [5,2]] is the same as [[2,5], [2,5]] but NOT the same as [[2,5]]\n[[2,5], [3,5], [6,2]] is the same as [[2,6], [5,3], [2,5]] or [[3,5], [6,2], [5,2]], etc\nAn array can be empty or contain a minimun of one array of 2 integers and up to 100 array of 2 integers \n\n\nNote:\n1. [[]] is not applicable because if the array of array are to contain anything, there have to be two numbers.\n2. 100 randomly generated tests that can contains either \"same\" or \"not same\" arrays.\n\"\"\"", "inputs": [[[[2, 5], [3, 6]], [[5, 2], [3, 6]]], [[[2, 5], [3, 6]], [[6, 3], [5, 2]]], [[[2, 5], [3, 6]], [[6, 3], [2, 5]]], [[[2, 5], [3, 5], [6, 2]], [[2, 6], [5, 3], [2, 5]]], [[[2, 5], [3, 5], [6, 2]], [[3, 5], [6, 2], [5, 2]]], [[], []], [[[2, 3], [3, 4]], [[4, 3], [2, 4]]], [[[2, 3], [3, 2]], [[2, 3]]]], "outputs": [[true], [true], [true], [true], [true], [true], [false], [false]], "starter_code": "from typing import List\ndef same(arr_a: List[List[int]], arr_b: List[List[int]]) -> bool:", "canonical_solution": "def same(arr_a, arr_b):\n    return sorted(map(sorted, arr_a)) == sorted(map(sorted, arr_b))", "entry_point": "same", "task_id": "TACO_lite/851", "input_output_examples": "[[[[[[2, 5], [3, 6]], [[5, 2], [3, 6]]]], [[[[2, 5], [3, 6]], [[2, 3], [5, 6]]]], [[[[2, 5], [5, 2]], [[2, 5], [2, 5]]]], [[[[2, 5], [5, 2]], [[2, 5]]]], [[[[2, 5], [3, 5], [6, 2]], [[2, 6], [5, 3], [2, 5]]]], [[[], []]]], [[True], [False], [True], [False], [True], [True]]]", "llm_generated_inputs": {"deepseek-v3": "[[[[2, 5], [3, 6]], [[5, 2], [3, 6]]], [[[2, 5], [3, 6]], [[6, 3], [5, 2]]], [[[2, 5], [3, 6]], [[2, 3], [5, 6]]], [[[2, 5], [5, 2]], [[2, 5], [2, 5]]], [[[2, 5], [5, 2]], [[2, 5]]], [[[2, 5], [3, 5], [6, 2]], [[2, 6], [5, 3], [2, 5]]], [[[2, 5], [3, 5], [6, 2]], [[3, 5], [6, 2], [5, 2]]], [[], []], [[[1, 2]], [[2, 1]]], [[[1, 2], [3, 4]], [[4, 3], [2, 1]]], [[[1, 2], [3, 4]], [[1, 2], [3, 4], [5, 6]]], [[[1, 2], [3, 4]], [[1, 2]]], [[[1, 2], [3, 4]], [[1, 3], [2, 4]]], [[[1, 2], [2, 1]], [[1, 2]]], [[[1, 2], [2, 1]], [[1, 2], [2, 1], [3, 4]]], [[[1, 2], [2, 1]], [[1, 2], [3, 4]]], [[[1, 2], [2, 1]], [[1, 2], [2, 1], [3, 4], [4, 3]]], [[[1, 2], [2, 1]], [[1, 2], [2, 1], [3, 4], [4, 3], [5, 6], [6, 5]]], [[[1, 2], [2, 1]], [[1, 2], [2, 1], [3, 4], [4, 3], [5, 6], [6, 5], [7, 8], [8, 7]]], [[[1, 2], [2, 1]], [[1, 2], [2, 1], [3, 4], [4, 3], [5, 6], [6, 5], [7, 8], [8, 7], [9, 10], [10, 9]]]]", "qwen2.5-coder-32b-instruct": "[[[[]], [[]]], [[[2, 5], [3, 6]], [[5, 2], [3, 6]]], [[[2, 5], [3, 6]], [[6, 3], [5, 2]]], [[[2, 5], [3, 6]], [[6, 3], [2, 5]]], [[[2, 5], [3, 6]], [[2, 3], [5, 6]]], [[], []], [[[2, 5], [5, 2]], [[2, 5], [2, 5]]], [[[2, 5], [5, 2]], [[2, 5]]], [[[2, 5], [3, 5], [6, 2]], [[2, 6], [5, 3], [2, 5]]], [[[2, 5], [3, 5], [6, 2]], [[3, 5], [6, 2], [5, 2]]], [[[1, 2], [3, 4], [5, 6]], [[6, 5], [4, 3], [2, 1]]], [[[1, 2], [3, 4], [5, 6]], [[1, 2], [4, 3], [6, 5]]], [[[10, 20], [30, 40]], [[20, 10], [40, 30]]], [[[10, 20], [30, 40]], [[30, 40], [20, 10]]], [[[10, 20], [30, 40]], [[20, 10], [30, 40]]], [[[1, 1], [2, 2]], [[1, 1], [2, 2]]], [[[1, 1], [2, 2]], [[2, 2], [1, 1]]], [[[1, 1], [2, 2]], [[1, 2], [1, 2]]], [[[99, 100]], [[100, 99]]], [[[1, 2], [2, 3], [3, 4], [4, 5]], [[5, 4], [4, 3], [3, 2], [2, 1]]], [[[1, 2], [2, 3], [3, 4], [4, 5]], [[2, 1], [3, 2], [4, 3], [5, 4]]], [[[1, 2], [2, 3], [3, 4], [4, 5]], [[1, 2], [3, 2], [4, 3], [5, 4]]], [[[1, 2], [2, 3], [3, 4], [4, 5]], [[1, 2], [2, 3], [4, 3], [5, 4]]], [[[1, 2], [2, 3], [3, 4], [4, 5]], [[1, 2], [2, 3], [3, 4], [4, 6]]], [[[1, 2]], [[2, 1]]], [[[1, 2]], [[1, 2]]], [[[1, 2]], [[2, 3]]], [[[1, 2], [3, 4]], [[2, 1], [4, 3]]], [[[1, 2], [3, 4]], [[4, 3], [2, 1]]], [[[1, 2], [3, 4]], [[2, 1], [3, 4]]], [[[1, 2], [3, 4]], [[1, 2], [4, 3]]], [[[1, 2], [3, 4]], [[1, 2], [3, 4]]], [[[1, 2], [3, 4]], [[1, 3], [2, 4]]], [[[1, 2], [3, 4], [5, 6]], [[6, 5], [4, 3], [2, 1]]], [[[1, 2], [3, 4], [5, 6]], [[1, 2], [4, 3], [6, 5]]], [[[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4], [6, 5]]], [[[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4], [5, 7]]], [[[1, 2], [3, 4], [5, 6], [7, 8]], [[8, 7], [6, 5], [4, 3], [2, 1]]], [[[1, 2], [3, 4], [5, 6], [7, 8]], [[1, 2], [4, 3], [6, 5], [8, 7]]], [[[1, 2], [3, 4], [5, 6], [7, 8]], [[1, 2], [3, 4], [6, 5], [8, 7]]], [[[1, 2], [3, 4], [5, 6], [7, 8]], [[1, 2], [3, 4], [5, 6], [8, 9]]], [[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]], [[10, 9], [8, 7], [6, 5], [4, 3], [2, 1]]], [[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]], [[1, 2], [4, 3], [6, 5], [8, 7], [10, 9]]], [[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]], [[1, 2], [3, 4], [6, 5], [8, 7], [10, 9]]], [[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]], [[1, 2], [3, 4], [5, 6], [8, 7], [10, 9]]], [[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]], [[1, 2], [3, 4], [5, 6], [7, 8], [11, 10]]]]"}}
{"requirement": "def check_password(s: str) -> str:\n\"\"\"Your users passwords were all stole in the Yahoo! hack, and it turns out they have been lax in creating secure passwords.  Create a function that checks their new password (passed as a string) to make sure it meets the following requirements:\n\n\nBetween 8 - 20 characters\n\nContains only the following characters: (and at least one character from each category): uppercase letters, lowercase letters, digits, and the special characters !@#$%^&*?\n\n\n\n\n\n\nReturn \"valid\" if passed or else \"not valid\"\n\"\"\"", "inputs": [[""], ["password"], ["P1@p"], ["P1@pP1@p"], ["P1@pP1@pP1@pP1@pP1@pP1@p"]], "outputs": [["not valid"], ["not valid"], ["not valid"], ["valid"], ["not valid"]], "starter_code": "def check_password(s: str) -> str:", "canonical_solution": "import re\n\ndef check_password(s):\n    if re.search('^(?=.*?[a-z])(?=.*?[A-Z])(?=.*?\\\\d)(?=.*?[!@#$%^&*?])[a-zA-Z\\\\d!@#$%^&*?]{8,20}$', s):\n        return 'valid'\n    else:\n        return 'not valid'", "entry_point": "check_password", "task_id": "TACO_lite/852", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['ValidPass1!'], ['short'], ['ThisPasswordIsWayTooLongToBeValid123!'], ['NoDigitsOrSpecialChars'], ['nouppercase1!'], ['NOLOWERCASE1!'], ['MissingSpecialChar1'], ['12345678'], ['!@#$%^&*?'], ['ValidPass1!ValidPass1!'], ['ValidPass1!'], ['ValidPass1!ValidPass1!ValidPass1!'], ['ValidPass1!ValidPass1!ValidPass1!ValidPass1!'], ['ValidPass1!ValidPass1!ValidPass1!ValidPass1!ValidPass1!']]", "qwen2.5-coder-32b-instruct": "[['Valid1!'], ['short1@'], ['TOOLONGPASSWORD123456789!'], ['ValidPassword1'], ['ValidPassword1!'], ['validpassword1!'], ['VALIDPASSWORD1!'], ['Valid1234567890!'], ['Valid1@'], ['ValidPassword!'], ['ValidPassword123'], ['ValidPassword123!'], ['ValidPassword1234567890'], ['ValidPassword1234567890!'], ['ValidPassword1234567890!@#$%^&*?'], ['NoDigitsOrSpecial!'], ['NODIGITSORSPECIAL1'], ['nodigitsorspecial1!'], ['Valid1234567890!@#$%^&*?Aa']]"}}
{"requirement": "def grille(msg: str, code: int) -> str:\n\"\"\"# Introduction \n\nA grille cipher was a technique for encrypting a plaintext by writing it onto a sheet of paper through a pierced sheet (of paper or cardboard or similar). The earliest known description is due to the polymath Girolamo Cardano in 1550. His proposal was for a rectangular stencil allowing single letters, syllables, or words to be written, then later read, through its various apertures. The written fragments of the plaintext could be further disguised by filling the gaps between the fragments with anodyne words or letters. This variant is also an example of steganography, as are many of the grille ciphers. \nWikipedia Link \n\n![Tangiers1](https://upload.wikimedia.org/wikipedia/commons/8/8a/Tangiers1.png)\n![Tangiers2](https://upload.wikimedia.org/wikipedia/commons/b/b9/Tangiers2.png)\n\n# Task\n\nWrite a function that accepts two inputs: `message` and `code` and returns hidden message decrypted from `message` using the `code`.   \n\n\nThe `code` is a nonnegative integer and it decrypts in binary the `message`.\n\"\"\"", "inputs": [["abcdef", 5], ["", 5], ["abcd", 1], ["0abc", 2], ["ab", 255], ["ab", 256], ["abcde", 32], ["tcddoadepwweasresd", 77098]], "outputs": [["df"], [""], ["d"], ["b"], ["ab"], [""], [""], ["codewars"]], "starter_code": "def grille(msg: str, code: int) -> str:", "canonical_solution": "def grille(msg, code):\n    return ''.join((msg[-1 - i] for i, c in enumerate(bin(code)[::-1]) if c == '1' and i < len(msg)))[::-1]", "entry_point": "grille", "task_id": "TACO_lite/859", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['hello world', 42], ['secret message', 0], ['test', 255], ['', 123], ['grille cipher', 1], ['python programming', 1023], ['binary code', 511]]", "qwen2.5-coder-32b-instruct": "[['HELLO', 5], ['PYTHON', 3], ['SECRETMESSAGE', 15], ['', 0], ['A', 1], ['LONGERMESSAGE', 0], ['SINGLELETTER', 31], ['MULTIPLEWORDSHERE', 7], ['BINARYCODE', 255]]"}}
{"requirement": "from typing import List\n\n\ndef square_sum(numbers: List[int]) -> int:\n\"\"\"Complete the square sum function so that it squares each number passed into it and then sums the results together.\n\nFor example, for `[1, 2, 2]` it should return `9` because `1^2 + 2^2 + 2^2 = 9`.\n\n```if:racket\nIn Racket, use a list instead of an array, so '(1 2 3) should return 9.\n```\n\"\"\"", "inputs": [[[1, 2]], [[0, 3, 4, 5]], [[]], [[-1, -2]], [[-1, 0, 1]]], "outputs": [[5], [50], [0], [5], [2]], "starter_code": "from typing import List\ndef square_sum(numbers: List[int]) -> int:", "canonical_solution": "def square_sum(numbers):\n    return sum((x ** 2 for x in numbers))", "entry_point": "square_sum", "task_id": "TACO_lite/863", "input_output_examples": "[[[[1, 2, 2]]], [[9]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 2]], [[0, 0, 0]], [[1]], [[-1, -2, -3]], [[10, 20, 30, 40]], [[]], [[5, -5, 5, -5]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 2]], [[0, 0, 0]], [[-1, -2, -3]], [[10, 20, 30]], [[5]], [[]], [[100, -100]]]"}}
{"requirement": "from typing import List\n\n\ndef find_deleted_number(arr: List[int], mixed_arr: List[int]) -> int:\n\"\"\"An ordered sequence of numbers from 1 to N is given. One number might have deleted from it, then the remaining numbers were mixed. Find the number that was deleted.\n\nExample: \n - The starting array sequence is `[1,2,3,4,5,6,7,8,9]`\n - The mixed array with one deleted number is `[3,2,4,6,7,8,1,9]`\n - Your function should return the int `5`.\n\nIf no number was deleted from the array and no difference with it, your function should return the int `0`.\n\nNote that N may be 1 or less (in the latter case, the first array will be `[]`).\n\"\"\"", "inputs": [[[1, 2, 3, 4, 5, 6, 7, 8, 9], [5, 7, 9, 4, 8, 1, 2, 3]], [[1, 2, 3, 4, 5, 6, 7], [2, 3, 6, 1, 5, 4, 7]], [[1, 2, 3, 4, 5, 6, 7, 8, 9], [5, 7, 6, 9, 4, 8, 1, 2, 3]], [[1], []], [[], []]], "outputs": [[6], [0], [0], [1], [0]], "starter_code": "from typing import List\ndef find_deleted_number(arr: List[int], mixed_arr: List[int]) -> int:", "canonical_solution": "def find_deleted_number(arr, mixed_arr):\n    return sum(arr) - sum(mixed_arr)", "entry_point": "find_deleted_number", "task_id": "TACO_lite/869", "input_output_examples": "[[[[1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 2, 4, 6, 7, 8, 1, 9]], [[], []]], [[5], [0]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 2, 4, 6, 7, 8, 1, 9]], [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1]], [[1, 2, 3], [3, 1]], [[1], []], [[], []], [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]], [[1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2]], [[1, 2, 3, 4, 5, 6, 7], [7, 6, 5, 4, 3, 1]], [[1, 2, 3, 4, 5, 6, 7, 8], [8, 7, 6, 5, 4, 3, 2]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 2, 4, 6, 7, 8, 1, 9]], [[1, 2, 3], [3, 1, 2]], [[1], []], [[], []], [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1]], [[10, 20, 30, 40, 50], [10, 30, 40, 50]], [[5], [5]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 10]]]"}}
{"requirement": "from typing import List\n\n\ndef num_obj(s: List[int]) -> List[dict[str, str]]:\n\"\"\"You will be given an array of numbers.\n\nFor each number in the array you will need to create an object. \n\nThe object key will be the number, as a string. The value will be the corresponding character code, as a string.\n\nReturn an array of the resulting objects.\n\nAll inputs will be arrays of numbers. All character codes are valid lower case letters. The input array will not be empty.\n\"\"\"", "inputs": [[[118, 117, 120]], [[101, 121, 110, 113, 113, 103]], [[118, 103, 110, 109, 104, 106]], [[107, 99, 110, 107, 118, 106, 112, 102]], [[100, 100, 116, 105, 117, 121]]], "outputs": [[[{"118": "v"}, {"117": "u"}, {"120": "x"}]], [[{"101": "e"}, {"121": "y"}, {"110": "n"}, {"113": "q"}, {"113": "q"}, {"103": "g"}]], [[{"118": "v"}, {"103": "g"}, {"110": "n"}, {"109": "m"}, {"104": "h"}, {"106": "j"}]], [[{"107": "k"}, {"99": "c"}, {"110": "n"}, {"107": "k"}, {"118": "v"}, {"106": "j"}, {"112": "p"}, {"102": "f"}]], [[{"100": "d"}, {"100": "d"}, {"116": "t"}, {"105": "i"}, {"117": "u"}, {"121": "y"}]]], "starter_code": "from typing import List\ndef num_obj(s: List[int]) -> List[dict[str, str]]:", "canonical_solution": "def num_obj(s):\n    return [{str(i): chr(i)} for i in s]", "entry_point": "num_obj", "task_id": "TACO_lite/871", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[97]], [[98, 99, 100]], [[120, 121, 122]], [[97, 98, 99, 100, 101]], [[97, 97, 97]], [[122]], [[97, 122]], [[100, 101, 102, 103]], [[110, 111, 112, 113]], [[97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]]]", "qwen2.5-coder-32b-instruct": "[[[97]], [[97, 98, 99]], [[122]], [[97, 100, 105, 116, 121]], [[104, 101, 108, 108, 111]], [[115, 111, 109, 101, 32, 110, 117, 109, 98, 101, 114, 115]]]"}}
{"requirement": "from typing import Union\n\n\ndef egged(year: int, span: int) -> Union[int, str]:\n\"\"\"Ronald's uncle left him 3 fertile chickens in his will. When life gives you chickens, you start a business selling chicken eggs which is exactly what Ronald decided to do. \n\nA chicken lays 300 eggs in its first year. However, each chicken's egg production decreases by 20% every following year (rounded down) until when it dies (after laying its quota of eggs). \n\nAfter his first successful year of business, Ronald decides to buy 3 more chickens at the start of each year.  \n\n\nYour Task: \n\nFor a given year, and life span of chicken span,  calculate how many eggs Ronald's chickens will lay him that year, whereby year=1 is when Ronald first got his inheritance and span>0.\n\nIf year=0, make sure to return \"No chickens yet!\".\n\n\nNote: \n1. All chickens have the same life span regardless of when they are bought. \n2. Let's assume all calculations are made at the end of the year so don't bother taking eggs laid per month into consideration. \n3. Each chicken's egg production goes down by 20% each year, NOT the total number of eggs produced by each 'batch' of chickens. While this might appear to be the same thing, it doesn't once non-integers come into play so take care that this is reflected in your kata!\n\"\"\"", "inputs": [[0, 5], [2, 1], [4, 8], [74, 10], [1, 15]], "outputs": [["No chickens yet!"], [900], [2655], [3984], [900]], "starter_code": "from typing import Union\ndef egged(year: int, span: int) -> Union[int, str]:", "canonical_solution": "def egged(year, span):\n    total = 0\n    eggs_per_chicken = 300\n    for i in range(min(span, year)):\n        total += 3 * eggs_per_chicken\n        eggs_per_chicken = int(eggs_per_chicken * 0.8)\n    return total or 'No chickens yet!'", "entry_point": "egged", "task_id": "TACO_lite/881", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[0, 5], [1, 3], [2, 4], [3, 2], [5, 1], [10, 10], [1, 1], [4, 3], [7, 7], [2, 1]]", "qwen2.5-coder-32b-instruct": "[[0, 5], [1, 5], [2, 5], [3, 5], [4, 5], [5, 5], [6, 5], [1, 1], [1, 2], [10, 10], [10, 1]]"}}
{"requirement": "def to_twos_complement(binary: str, bits: int) -> int:\n\"\"\"The goal is to write a pair of functions the first of which will take a string of binary along with a specification of bits, which will return a numeric, signed complement in two's complement format. The second will do the reverse. It will take in an integer along with a number of bits, and return a binary string. \n\nhttps://en.wikipedia.org/wiki/Two's_complement\n\nThus, to_twos_complement should take the parameters binary = \"0000 0001\", bits = 8 should return 1. And, binary = \"11111111\", bits = 8 should return -1 . While, from_twos_complement should return \"00000000\" from the parameters n = 0, bits = 8 . And, \"11111111\" from n = -1, bits = 8. \n\n\n\nYou should account for some edge cases.\n\"\"\"", "inputs": [["00000001", 8], ["00000010", 8], ["01111110", 8], ["01111111", 8], ["11111111", 8], ["11111110", 8], ["10000010", 8], ["1000 0000", 8], ["1010 1010 0010 0010 1110 1010 0010 1110", 32], ["1000 0000 1110 1111 0011 0100 1100 1010", 32], ["10110001000100000101100011111000", 32]], "outputs": [[1], [2], [126], [127], [-1], [-2], [-126], [-128], [-1440552402], [-2131807030], [-1324328712]], "starter_code": "def to_twos_complement(binary: str, bits: int) -> int:", "canonical_solution": "def to_twos_complement(binary, bits):\n    return int(binary.replace(' ', ''), 2) - 2 ** bits * int(binary[0])\n\ndef from_twos_complement(n, bits):\n    return '{:0{}b}'.format(n & 2 ** bits - 1, bits)", "entry_point": "to_twos_complement", "task_id": "TACO_lite/885", "input_output_examples": "[[['0000 0001', 8], ['11111111', 8], [0, 8], [-1, 8]], [[1], [-1], ['00000000'], ['11111111']]]", "llm_generated_inputs": {"deepseek-v3": "[['0000 0001', 8], ['11111111', 8], ['10000000', 8], ['01111111', 8], ['00000000', 8], ['11111111', 16], ['1000000000000000', 16], ['0111111111111111', 16], ['0000000000000000', 16], ['1', 1], ['0', 1], ['10', 2], ['11', 2], ['01', 2], ['00', 2], ['11111111111111111111111111111111', 32], ['10000000000000000000000000000000', 32], ['01111111111111111111111111111111', 32], ['00000000000000000000000000000000', 32]]", "qwen2.5-coder-32b-instruct": "[['00000001', 8], ['11111111', 8], ['00000000', 8], ['10000000', 8], ['01111111', 8], ['11111110', 8], ['00000010', 8], ['10000001', 8], ['00000001', 16], ['1111111111111111', 16], ['0000000000000000', 16], ['1000000000000000', 16], ['0111111111111111', 16], ['1111111111111110', 16], ['0000000000000010', 16], ['1000000000000001', 16], ['00000001', 1], ['1', 1], ['0', 1]]"}}
{"requirement": "def highlight(code: str) -> str:\n\"\"\"# RoboScript #1 - Implement Syntax Highlighting\n\n## Disclaimer\n\nThe story presented in this Kata Series is purely fictional; any resemblance to actual programming languages, products, organisations or people should be treated as purely coincidental.\n\n## About this Kata Series\n\nThis Kata Series is based on a fictional story about a computer scientist and engineer who owns a firm that sells a toy robot called MyRobot which can interpret its own (esoteric) programming language called RoboScript.  Naturally, this Kata Series deals with the software side of things (I'm afraid Codewars cannot test your ability to build a physical robot!).\n\n## Story\n\nYou are a computer scientist and engineer who has recently founded a firm which sells a toy product called MyRobot which can move by receiving a set of instructions by reading a file containing a script.  Initially you have planned the robot to be able to interpret JavaScript files for its movement instructions but you later decided that it would make MyRobot too hard to operate for most customers out there who aren't even computer programmers in the first place.  For this reason, you have decided to invent a new (esoteric) scripting language called RoboScript which has a much simpler syntax so non-computer programmers can easily learn how to write scripts in this language which would enable them to properly operate MyRobot.  However, you are currently at the initial stage of inventing this new Esolang.  The first step to popularize this (esoteric) scripting language is naturally to invent a new editor for it which provides syntax highlighting for this language so your customers feel like they are writing a proper program when they are writing scripts for MyRobot.\n\n## Task\n\nYour MyRobot-specific (esoteric) scripting language called RoboScript only ever contains the following characters: `F`, `L`, `R`, the digits `0-9` and brackets (`(` and `)`).  Your goal is to write a function `highlight` which accepts 1 required argument `code` which is the RoboScript program passed in as a string and returns the script with syntax highlighting.  The following commands/characters should have the following colors:\n\n- `F` - Wrap this command around `` and `` tags so that it is highlighted pink in our editor\n- `L` - Wrap this command around `` and `` tags so that it is highlighted red in our editor\n- `R` - Wrap this command around `` and `` tags so that it is highlighted green in our editor\n- Digits from `0` through `9` - Wrap these around `` and `` tags so that they are highlighted orange in our editor\n\n\n- Round Brackets - Do not apply any syntax highlighting to these characters\n\nFor example:\n\nAnd for multiple characters with the same color, simply wrap them with a **single** `` tag of the correct color:\n\nNote that the use of `` tags must be **exactly** the same format as demonstrated above.  Even if your solution produces the same visual result as the expected answers, if you miss a space betwen `\"color:\"` and `\"green\"`, for example, you will fail the tests.\n\n## Kata in this Series\n\n1. **RoboScript #1 - Implement Syntax Highlighting**\n2. [RoboScript #2 - Implement the RS1 Specification](https://www.codewars.com/kata/5870fa11aa0428da750000da)\n3. [RoboScript #3 - Implement the RS2 Specification](https://www.codewars.com/kata/58738d518ec3b4bf95000192)\n4. [RoboScript #4 - RS3 Patterns to the Rescue](https://www.codewars.com/kata/594b898169c1d644f900002e)\n5. [RoboScript #5 - The Final Obstacle (Implement RSU)](https://www.codewars.com/kata/5a12755832b8b956a9000133)\n\"\"\"", "inputs": [["F3RF5LF7"], ["FFFR345F2LL"], ["RRRRRF45L3F2"], ["RRRRR(F45L3)F2"], ["FF(LF6(RF3)2)3"]], "outputs": [["<span style=\"color: pink\">F</span><span style=\"color: orange\">3</span><span style=\"color: green\">R</span><span style=\"color: pink\">F</span><span style=\"color: orange\">5</span><span style=\"color: red\">L</span><span style=\"color: pink\">F</span><span style=\"color: orange\">7</span>"], ["<span style=\"color: pink\">FFF</span><span style=\"color: green\">R</span><span style=\"color: orange\">345</span><span style=\"color: pink\">F</span><span style=\"color: orange\">2</span><span style=\"color: red\">LL</span>"], ["<span style=\"color: green\">RRRRR</span><span style=\"color: pink\">F</span><span style=\"color: orange\">45</span><span style=\"color: red\">L</span><span style=\"color: orange\">3</span><span style=\"color: pink\">F</span><span style=\"color: orange\">2</span>"], ["<span style=\"color: green\">RRRRR</span>(<span style=\"color: pink\">F</span><span style=\"color: orange\">45</span><span style=\"color: red\">L</span><span style=\"color: orange\">3</span>)<span style=\"color: pink\">F</span><span style=\"color: orange\">2</span>"], ["<span style=\"color: pink\">FF</span>(<span style=\"color: red\">L</span><span style=\"color: pink\">F</span><span style=\"color: orange\">6</span>(<span style=\"color: green\">R</span><span style=\"color: pink\">F</span><span style=\"color: orange\">3</span>)<span style=\"color: orange\">2</span>)<span style=\"color: orange\">3</span>"]], "starter_code": "def highlight(code: str) -> str:", "canonical_solution": "import re\n\ndef highlight(code):\n    code = re.sub('(F+)', '<span style=\"color: pink\">\\\\g<1></span>', code)\n    code = re.sub('(L+)', '<span style=\"color: red\">\\\\g<1></span>', code)\n    code = re.sub('(R+)', '<span style=\"color: green\">\\\\g<1></span>', code)\n    code = re.sub('(\\\\d+)', '<span style=\"color: orange\">\\\\g<1></span>', code)\n    return code", "entry_point": "highlight", "task_id": "TACO_lite/888", "input_output_examples": "[[['F'], ['L'], ['R'], ['123'], ['(123)'], ['FRL(123)']], [['<span style=\"color: pink\">F</span>'], ['<span style=\"color: red\">L</span>'], ['<span style=\"color: green\">R</span>'], ['<span style=\"color: orange\">123</span>'], ['(<span style=\"color: orange\">123</span>)'], ['<span style=\"color: pink\">F</span><span style=\"color: red\">L</span><span style=\"color: green\">R</span>(<span style=\"color: orange\">123</span>)']]]", "llm_generated_inputs": {"deepseek-v3": "[['F'], ['L'], ['R'], ['3'], ['(F)'], ['F3L2R1'], ['FFLLRR123'], ['(F3L2)R1'], ['F(L)R'], ['FLR0123456789'], [''], ['()'], ['F(F)L(R)3'], ['F(LR)3(F)'], ['F(L(R))']]", "qwen2.5-coder-32b-instruct": "[['F'], ['L'], ['R'], ['0'], ['('], [')'], ['FLR0()'], ['FFFF'], ['LLLL'], ['RRRR'], ['0123456789'], ['F0L1R2'], ['(F0L1R2)'], ['F(L(R0))'], ['F0L1R2(F0L1R2)'], ['F0L1R2(F0L1R2(F0L1R2))'], [''], ['()'], ['(())'], ['((()))'], ['F(L(R0(F(L(R0)))))']]"}}
{"requirement": "def happy_g(s: str) -> bool:\n\"\"\"# Task\n Let's say that `\"g\" is happy` in the given string, if there is another \"g\" immediately to the right or to the left of it.\n \n Find out if all \"g\"s in the given string are happy.\n\n# Example\n For `str = \"gg0gg3gg0gg\"`, the output should be `true`.\n \n For `str = \"gog\"`, the output should be `false`.\n\n# Input/Output\n\n\n - `[input]` string `str`\n\n  A random string of lower case letters, numbers and spaces.\n\n\n - `[output]` a boolean value\n\n  `true` if all `\"g\"`s are happy, `false` otherwise.\n\"\"\"", "inputs": [["gg0gg3gg0gg"], ["gog"], ["ggg ggg g ggg"], ["A half of a half is a quarter."], ["good grief"], ["bigger is ggooder"], ["gggggggggg"]], "outputs": [[true], [false], [false], [true], [false], [true], [true]], "starter_code": "def happy_g(s: str) -> bool:", "canonical_solution": "import re\n\ndef happy_g(s):\n    return not re.search('(?<!g)g(?!g)', s)", "entry_point": "happy_g", "task_id": "TACO_lite/899", "input_output_examples": "[[['gg0gg3gg0gg'], ['gog']], [[True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[['gg0gg3gg0gg'], ['gog'], ['g'], ['gg'], ['g g'], ['ggg'], ['g gg'], ['gg g'], ['gggg'], ['g0g'], ['g g g'], ['g1g2g3g4g'], ['ggg ggg'], ['g g g g'], ['ggg0ggg'], ['g gg g'], ['gg g gg'], ['ggg ggg ggg'], ['g ggg g'], ['ggg g ggg']]", "qwen2.5-coder-32b-instruct": "[['gg0gg3gg0gg'], ['gog'], ['g'], ['gg'], ['abc'], ['agbg'], ['g g'], ['g1g2g3'], ['ggg'], ['g abc g']]"}}
{"requirement": "def maxlen(s1: float, s2: float) -> float:\n\"\"\"Imagine that you are given two sticks. You want to end up with three sticks of equal length. You are allowed to cut either or both of the sticks to accomplish this, and can throw away leftover pieces.\n\nWrite a function, maxlen, that takes the lengths of the two sticks (L1 and L2, both positive values), that will return the maximum length you can make the three sticks.\n\"\"\"", "inputs": [[5, 12], [12, 5], [5, 17], [17, 5], [7, 12], [12, 7]], "outputs": [[5], [5], [5.666666666666667], [5.666666666666667], [6.0], [6.0]], "starter_code": "def maxlen(s1: float, s2: float) -> float:", "canonical_solution": "def maxlen(s1, s2):\n    sm, lg = sorted((s1, s2))\n    return min(max(lg / 3, sm), lg / 2)", "entry_point": "maxlen", "task_id": "TACO_lite/908", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[10.0, 20.0], [15.0, 15.0], [30.0, 10.0], [1.0, 1.0], [0.5, 1.5], [100.0, 50.0], [0.0, 10.0], [10.0, 0.0], [0.0, 0.0], [7.5, 7.5]]", "qwen2.5-coder-32b-instruct": "[[6.0, 9.0], [10.0, 10.0], [5.5, 11.0], [7.2, 3.6], [1.0, 1.0], [0.1, 0.2], [100.0, 200.0], [15.0, 5.0]]"}}
{"requirement": "def grader(x: float) -> str:\n\"\"\"Create a function that takes a number as an argument and returns a grade based on that number.\n\nScore                                    | Grade\n-----------------------------------------|-----\nAnything greater than 1 or less than 0.6 | \"F\"\n0.9 or greater                           | \"A\"\n0.8 or greater                           | \"B\"\n0.7 or greater                           | \"C\"\n0.6 or greater                           | \"D\"\n\nExamples:\n```\ngrader(0)   should be \"F\"\ngrader(1.1) should be \"F\"\ngrader(0.9) should be \"A\"\ngrader(0.8) should be \"B\"\ngrader(0.7) should be \"C\"\ngrader(0.6) should be \"D\"\n```\n\"\"\"", "inputs": [[1], [1.01], [0.2], [0.7], [0.8], [0.9], [0.6], [0.5], [0]], "outputs": [["A"], ["F"], ["F"], ["C"], ["B"], ["A"], ["D"], ["F"], ["F"]], "starter_code": "def grader(x: float) -> str:", "canonical_solution": "def grader(x):\n    if 0.9 <= x <= 1:\n        return 'A'\n    elif 0.8 <= x < 0.9:\n        return 'B'\n    elif 0.7 <= x < 0.8:\n        return 'C'\n    elif 0.6 <= x < 0.7:\n        return 'D'\n    else:\n        return 'F'", "entry_point": "grader", "task_id": "TACO_lite/918", "input_output_examples": "[[[0], [1.1], [0.9], [0.8], [0.7], [0.6]], [['F'], ['F'], ['A'], ['B'], ['C'], ['D']]]", "llm_generated_inputs": {"deepseek-v3": "[[1.1], [-0.1], [0.6], [0.7], [0.8], [0.9], [0.85], [0.75], [0.65], [0.0], [1.0]]", "qwen2.5-coder-32b-instruct": "[[0], [1.1], [0.9], [0.8], [0.7], [0.6], [0.59], [0.95], [0.85], [0.75], [0.65], [1], [0.6000000000000001]]"}}
{"requirement": "from typing import List\n\n\ndef squares(x: int, n: int) -> List[int]:\n\"\"\"Complete the function that returns an array of length `n`, starting with the given number `x` and the squares of the previous number. If `n` is negative or zero, return an empty array/list.\n\n## Examples\n\n```\n2, 5  -->  [2, 4, 16, 256, 65536]\n3, 3  -->  [3, 9, 81]\n```\n\"\"\"", "inputs": [[2, 5], [3, 3], [5, 3], [10, 4], [2, 0], [2, -4]], "outputs": [[[2, 4, 16, 256, 65536]], [[3, 9, 81]], [[5, 25, 625]], [[10, 100, 10000, 100000000]], [[]], [[]]], "starter_code": "from typing import List\ndef squares(x: int, n: int) -> List[int]:", "canonical_solution": "def squares(x, n):\n    return [x ** 2 ** i for i in range(n)]", "entry_point": "squares", "task_id": "TACO_lite/919", "input_output_examples": "[[[2, 5], [3, 3]], [[[2, 4, 16, 256, 65536]], [[3, 9, 81]]]]", "llm_generated_inputs": {"deepseek-v3": "[[2, 5], [3, 3], [1, 1], [0, 5], [5, 0], [-1, 5], [2, -3], [10, 2], [100, 4], [0, 0]]", "qwen2.5-coder-32b-instruct": "[[2, 5], [3, 3], [1, 0], [1, -1], [0, 5], [-2, 3], [-3, 2]]"}}
{"requirement": "from typing import List\n\n\ndef mystery(n: int) -> List[int]:\n\"\"\"No Story\n\nNo Description\n\nOnly by Thinking and Testing\n\nLook at the results of the testcases, and guess the code!\n\n---\n\n## Series:\n\n01. [A and B?](http://www.codewars.com/kata/56d904db9963e9cf5000037d)\n02. [Incomplete string](http://www.codewars.com/kata/56d9292cc11bcc3629000533)\n03. [True or False](http://www.codewars.com/kata/56d931ecc443d475d5000003)\n04. [Something capitalized](http://www.codewars.com/kata/56d93f249c844788bc000002)\n05. [Uniq or not Uniq](http://www.codewars.com/kata/56d949281b5fdc7666000004)\n06. [Spatiotemporal index](http://www.codewars.com/kata/56d98b555492513acf00077d)\n07. [Math of Primary School](http://www.codewars.com/kata/56d9b46113f38864b8000c5a)\n08. [Math of Middle school](http://www.codewars.com/kata/56d9c274c550b4a5c2000d92)\n09. [From nothingness To nothingness](http://www.codewars.com/kata/56d9cfd3f3928b4edd000021)\n10. [Not perfect? Throw away!](http://www.codewars.com/kata/56dae2913cb6f5d428000f77)\n11. [Welcome to take the bus](http://www.codewars.com/kata/56db19703cb6f5ec3e001393)\n12. [A happy day will come](http://www.codewars.com/kata/56dc41173e5dd65179001167)\n13. [Sum of 15(Hetu Luosliu)](http://www.codewars.com/kata/56dc5a773e5dd6dcf7001356)\n14. [Nebula or Vortex](http://www.codewars.com/kata/56dd3dd94c9055a413000b22)\n15. [Sport Star](http://www.codewars.com/kata/56dd927e4c9055f8470013a5)\n16. [Falsetto Rap Concert](http://www.codewars.com/kata/56de38c1c54a9248dd0006e4)\n17. [Wind whispers](http://www.codewars.com/kata/56de4d58301c1156170008ff)\n18. [Mobile phone simulator](http://www.codewars.com/kata/56de82fb9905a1c3e6000b52)\n19. [Join but not join](http://www.codewars.com/kata/56dfce76b832927775000027)\n20. [I hate big and small](http://www.codewars.com/kata/56dfd5dfd28ffd52c6000bb7)\n21. [I want to become diabetic ;-)](http://www.codewars.com/kata/56e0e065ef93568edb000731)\n22. [How many blocks?](http://www.codewars.com/kata/56e0f1dc09eb083b07000028)\n23. [Operator hidden in a string](http://www.codewars.com/kata/56e1161fef93568228000aad)\n24. [Substring Magic](http://www.codewars.com/kata/56e127d4ef93568228000be2)\n25. [Report about something](http://www.codewars.com/kata/56eccc08b9d9274c300019b9)\n26. [Retention and discard I](http://www.codewars.com/kata/56ee0448588cbb60740013b9)\n27. [Retention and discard II](http://www.codewars.com/kata/56eee006ff32e1b5b0000c32)\n28. [How many \"word\"?](http://www.codewars.com/kata/56eff1e64794404a720002d2)\n29. [Hail and Waterfall](http://www.codewars.com/kata/56f167455b913928a8000c49)\n30. [Love Forever](http://www.codewars.com/kata/56f214580cd8bc66a5001a0f)\n31. [Digital swimming pool](http://www.codewars.com/kata/56f25b17e40b7014170002bd)\n32. [Archery contest](http://www.codewars.com/kata/56f4202199b3861b880013e0)\n33. [The repair of parchment](http://www.codewars.com/kata/56f606236b88de2103000267)\n34. [Who are you?](http://www.codewars.com/kata/56f6b4369400f51c8e000d64)\n35. [Safe position](http://www.codewars.com/kata/56f7eb14f749ba513b0009c3)\n\n---\n \n## Special recommendation\n\nAnother series, innovative and interesting, medium difficulty. People who like challenges, can try these kata:\n    \n* [Play Tetris : Shape anastomosis](http://www.codewars.com/kata/56c85eebfd8fc02551000281)\n* [Play FlappyBird : Advance Bravely](http://www.codewars.com/kata/56cd5d09aa4ac772e3000323)\n\"\"\"", "inputs": [[-1], [0], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10]], "outputs": [[[]], [[]], [[1]], [[1]], [[1, 3]], [[1]], [[1, 5]], [[1, 3]], [[1, 7]], [[1]], [[1, 3, 9]], [[1, 5]]], "starter_code": "from typing import List\ndef mystery(n: int) -> List[int]:", "canonical_solution": "def mystery(n):\n    return [i for i in range(1, n + 1, 2) if n % i == 0]", "entry_point": "mystery", "task_id": "TACO_lite/930", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [5], [-1], [10], [100], [-5], [2], [3], [4]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [-1], [10], [-10], [100], [-100], [1000], [-1000]]"}}
{"requirement": "def get_real_floor(n: int) -> int:\n\"\"\"Americans are odd people: in their buildings, the first floor is actually the ground floor and there is no 13th floor (due to superstition).\n\nWrite a function that given a floor in the american system returns the floor in the european system.\n\nWith the 1st floor being replaced by the ground floor and the 13th floor being removed, the numbers move down to take their place. In case of above 13, they move down by two because there are two omitted numbers below them.\n\nBasements (negatives) stay the same as the universal level.\n\n[More information here](https://en.wikipedia.org/wiki/Storey#European_scheme)\n\n## Examples\n\n```\n1  =>  0 \n0  =>  0\n5  =>  4\n15  =>  13\n-3  =>  -3\n```\n\"\"\"", "inputs": [[1], [0], [5], [10], [12], [14], [15], [37], [200], [-2], [-5]], "outputs": [[0], [0], [4], [9], [11], [12], [13], [35], [198], [-2], [-5]], "starter_code": "def get_real_floor(n: int) -> int:", "canonical_solution": "def get_real_floor(n):\n    if n <= 0:\n        return n\n    if n < 13:\n        return n - 1\n    if n > 13:\n        return n - 2", "entry_point": "get_real_floor", "task_id": "TACO_lite/934", "input_output_examples": "[[[1], [0], [5], [15], [-3]], [[0], [0], [4], [13], [-3]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [0], [5], [15], [-3], [13], [14], [20], [-1], [2]]", "qwen2.5-coder-32b-instruct": "[[1], [0], [5], [15], [-3], [12], [13], [14], [20], [-1]]"}}
{"requirement": "from typing import List\n\n\ndef pay_cheese(arr: List[int]) -> str:\n\"\"\"Mr Leicester's cheese factory is the pride of the East Midlands, but he's feeling a little blue. It's the time of the year when **the taxman is coming round to take a slice of his cheddar** - and the final thing he has to work out is how much money he's spending on his staff. Poor Mr Leicester can barely sleep he's so stressed. Can you help? \n\n- Mr Leicester **employs 4 staff**, who together make **10 wheels of cheese every 6 minutes**.\n- Worker pay is calculated on **how many wheels of cheese they produce in a day**. \n- Mr Leicester pays his staff according to the UK living wage, which is currently **£8.75p an hour**. There are **100 pence (p) to the UK pound (£)**. \n\nThe input for function payCheese will be provided as an array of five integers, one for each amount of cheese wheels produced each day.\n\nWhen the workforce don't work a nice integer number of minutes - much to the chagrin of the company accountant - Mr Leicester very generously **rounds up to the nearest hour** at the end of the week (*not the end of each day*). Which means if the workers make 574 wheels on each day of the week, they're each paid 29 hours for the week (28.699 hours rounded up) and not 30 (6 hours a day rounded up * 5).\n\nThe return value should be a string (with the £ included) of the **total £ of staff wages for that week.**\n\"\"\"", "inputs": [[[750, 750, 750, 750, 600]], [[700, 750, 700, 750, 600]], [[574, 574, 574, 574, 574]], [[1, 1, 1, 1, 1]], [[0, 0, 0, 0, 0]]], "outputs": [["L1260"], ["L1225"], ["L1015"], ["L35"], ["L0"]], "starter_code": "from typing import List\ndef pay_cheese(arr: List[int]) -> str:", "canonical_solution": "from math import ceil\n\ndef pay_cheese(arr):\n    return f'L{ceil(sum(arr) / 100) * 35}'", "entry_point": "pay_cheese", "task_id": "TACO_lite/937", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[100, 100, 100, 100, 100]], [[574, 574, 574, 574, 574]], [[0, 0, 0, 0, 0]], [[10, 20, 30, 40, 50]], [[1000, 2000, 3000, 4000, 5000]], [[1, 1, 1, 1, 1]], [[999, 999, 999, 999, 999]], [[500, 500, 500, 500, 500]]]", "qwen2.5-coder-32b-instruct": "[[[10, 10, 10, 10, 10]], [[0, 0, 0, 0, 0]], [[574, 574, 574, 574, 574]], [[1, 2, 3, 4, 5]], [[100, 200, 300, 400, 500]], [[15, 15, 15, 15, 15]], [[6, 6, 6, 6, 6]], [[9, 9, 9, 9, 9]], [[11, 11, 11, 11, 11]]]"}}
{"requirement": "def mod256_without_mod(number: int) -> int:\n\"\"\"# MOD 256 without the MOD operator\n\nThe MOD-operator % (aka mod/modulus/remainder):\n```\nReturns the remainder of a division operation.\nThe sign of the result is the same as the sign of the first operand.\n(Different behavior in Python!)\n```\n\nThe short unbelievable mad story for this kata:\nI wrote a program and needed the remainder of the division by 256. And then it happened: The \"5\"/\"%\"-Key did not react. It must be broken! So I needed a way to:\n```\nCalculate the remainder of the division by 256 without the %-operator.\n```\n\nAlso here some examples:\n```\nInput 254  -> Result 254\nInput 256  -> Result 0\nInput 258  -> Result 2 \nInput -258 -> Result -2 (in Python: Result: 254!)\n```\nIt is always expected the behavior of the MOD-Operator of the language!\n\nThe input number will always between -10000 and 10000.\n\nFor some languages the %-operator will be blocked. If it is not blocked and you know how to block it, tell me and I will include it.\n\nFor all, who say, this would be a duplicate: No, this is no duplicate! There are two katas, in that you have to write a general method for MOD without %. But this kata is only for MOD 256. And so you can create also other specialized solutions. ;-)\n\nOf course you can use the digit \"5\" in your solution. :-)\n\nI'm very curious for your solutions and the way you solve it. I found several interesting \"funny\" ways.\n\nHave fun coding it and please don't forget to vote and rank this kata! :-) \n\nI have also created other katas. Take a look if you enjoyed this kata!\n\"\"\"", "inputs": [[254], [256], [258], [-254], [-256], [-258]], "outputs": [[254], [0], [2], [2], [0], [254]], "starter_code": "def mod256_without_mod(number: int) -> int:", "canonical_solution": "def mod256_without_mod(number):\n    return number & 255", "entry_point": "mod256_without_mod", "task_id": "TACO_lite/939", "input_output_examples": "[[[254], [256], [258], [-258]], [[254], [0], [2], [-2]]]", "llm_generated_inputs": {"deepseek-v3": "[[254], [256], [258], [-258], [0], [1], [-1], [255], [257], [-255], [-257], [10000], [-10000], [512], [-512], [513], [-513]]", "qwen2.5-coder-32b-instruct": "[[254], [256], [258], [-258], [0], [10000], [-10000], [1], [-1], [128], [-128], [512], [-512]]"}}
{"requirement": "def is_digit(n: str) -> bool:\n\"\"\"Implement `String#digit?` (in Java `StringUtils.isDigit(String)`), which should return `true` if given object is a digit (0-9), `false` otherwise.\n\"\"\"", "inputs": [[""], ["7"], [" "], ["a"], ["a5"], ["14"], ["!"], ["\""], ["#"], ["$"], ["%"], ["&"], ["'"], ["("], [")"], ["*"], ["+"], [","], ["-"], ["."], ["/"], ["0"], ["1"], ["2"], ["3"], ["4"], ["5"], ["6"], ["8"], ["9"], [":"], [";"], ["<"], ["="], [">"], ["?"], ["@"], ["A"], ["B"], ["C"], ["D"], ["E"], ["F"], ["G"], ["H"], ["I"], ["J"], ["K"], ["L"], ["M"], ["N"], ["O"], ["P"], ["Q"], ["R"], ["S"], ["T"], ["U"], ["V"], ["W"], ["X"], ["Y"], ["Z"], ["["], ["\\"], ["]"], ["^"], ["_"], ["`"], ["b"], ["c"], ["d"], ["e"], ["f"], ["g"], ["h"], ["i"], ["j"], ["k"], ["l"], ["m"], ["n"], ["o"], ["p"], ["q"], ["r"], ["s"], ["t"], ["u"], ["v"], ["w"], ["x"], ["y"], ["z"], ["{"], ["|"], ["}"], ["~"], ["1\n0"], ["1\n"], ["1 "], [" 1"]], "outputs": [[false], [true], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [true], [true], [true], [true], [true], [true], [true], [true], [true], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false]], "starter_code": "def is_digit(n: str) -> bool:", "canonical_solution": "def is_digit(n):\n    return n.isdigit() and len(n) == 1", "entry_point": "is_digit", "task_id": "TACO_lite/948", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['0'], ['9'], ['5'], ['a'], ['A'], ['12'], [''], ['@'], [' '], ['123'], ['1.23'], ['-1'], ['+1']]", "qwen2.5-coder-32b-instruct": "[['0'], ['9'], ['5'], ['a'], [' '], ['A'], ['+'], ['-'], ['.'], ['10'], ['']]"}}
{"requirement": "def encoder(s: str) -> str:\n\"\"\"In this kata, you need to make a (simplified) LZ78 encoder and decoder.\n[LZ78](https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ78) is a dictionary-based compression method created in 1978. You will find a  detailed explanation about how it works below.\n\nThe input parameter will always be a non-empty string of upper case alphabetical characters. The maximum decoded string length is 1000 characters.\n\n\n# Instructions\n\n*If anyone has any ideas on how to make the instructions shorter / clearer, that would be greatly appreciated.*\n\nIf the below explanation is too confusing, just leave a comment and I'll be happy to help.\n\n---\n\nThe input is looked at letter by letter.\nEach letter wants to be matched with the longest dictionary substring at that current time.\n\nThe output is made up of tokens.\nEach token is in the format ``\nwhere `index` is the index of the longest dictionary value that matches the current substring\nand `letter` is the current letter being looked at.\n\n\nHere is how the string `'ABAABABAABAB'` is encoded:\n\n\n* First, a dictionary is initialised with the 0th item pointing to an empty string:\n\n```md\nDictionary      Input             Output\n0  |  ''        ABAABABAABAB\n```\n\n* The first letter is `A`. As it doesn't appear in the dictionary, we add `A` to the next avaliable index.\nThe token `<0, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A>\n1  |  A         ^\n```\n\n* The second letter is `B`. It doesn't appear in the dictionary, so we add `B` to the next avaliable index.\nThe token `<0, B>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B>\n1  |  A          ^\n2  |  B\n```\n\n* The third letter is `A` again: it already appears in the dictionary at position `1`. We add the next letter which is also `A`. `AA` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<1, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A>\n1  |  A           ^^\n2  |  B\n3  |  AA\n```\n\n* The next letter is `B` again: it already appears in the dictionary at position `2`. We add the next letter which is `A`. `BA` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<2, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A> <2, A>\n1  |  A             ^^\n2  |  B\n3  |  AA\n4  |  BA\n```\n\n* The next letter is `B`: it already appears in the dictionary and at position `2`. We add the next letter which is `A`. `BA` already appears in the dictionary at position `4`. We add the next letter which is `A`. `BAA` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<4, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A> <2, A> <4, A>\n1  |  A               ^^^\n2  |  B\n3  |  AA\n4  |  BA\n5  |  BAA\n```\n\n* The next letter is `B`. It already appears in the dictionary at position `2`. We add the next letter which is `A`. `BA` already appears in the dictionary at position `4`. We add the next letter which is `B`. `BAB` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<4, B>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A> <2, A> <4, A> <4, B>\n1  |  A                  ^^^\n2  |  B\n3  |  AA\n4  |  BA\n5  |  BAA\n6  |  BAB\n```\n\n* We have now reached the end of the string. We have the output tokens: `<0, A> <0, B> <1, A> <2, A> <4, A> <4, B>`.\nNow we just return the tokens without the formatting: `'0A0B1A2A4A4B'`\n\n**Note:**\n\nIf the string ends with a match in the dictionary, the last token should only contain the index of the dictionary. For example, `'ABAABABAABABAA'` (same as the example but with `'AA'` at the end) should return `'0A0B1A2A4A4B3'` (note the final `3`).\n\nTo decode, it just works the other way around.\n\n\n# Examples\n\nSome more examples:\n```\nDecoded                               Encoded\n\nABBCBCABABCAABCAABBCAA                0A0B2C3A2A4A6B6\nAAAAAAAAAAAAAAA                       0A1A2A3A4A\nABCABCABCABCABCABC                    0A0B0C1B3A2C4C7A6\nABCDDEFGABCDEDBBDEAAEDAEDCDABC        0A0B0C0D4E0F0G1B3D0E4B2D10A1E4A10D9A2C\n```\n\n\nGood luck :)\n\"\"\"", "inputs": [["ABAABABAABAB"], ["ABAABABAABABAA"], ["ABBCBCABABCAABCAABBCAA"], ["AAAAAAAAAAAAAAA"], ["ABCABCABCABCABCABC"], ["ABCDDEFGABCDEDBBDEAAEDAEDCDABC"]], "outputs": [["0A0B1A2A4A4B"], ["0A0B1A2A4A4B3"], ["0A0B2C3A2A4A6B6"], ["0A1A2A3A4A"], ["0A0B0C1B3A2C4C7A6"], ["0A0B0C0D4E0F0G1B3D0E4B2D10A1E4A10D9A2C"]], "starter_code": "def encoder(s: str) -> str:", "canonical_solution": "import re\n\ndef encoder(s):\n    d, out, it = ({}, [], iter(s))\n    for c in it:\n        i, k = (0, c)\n        while k in d:\n            i, c = (d[k], next(it, ''))\n            if not c:\n                break\n            k += c\n        d[k] = len(d) + 1\n        out.append(f'{i}{c}')\n    return ''.join(out)\n\ndef decoder(s):\n    d = ['']\n    for m in re.finditer('(\\\\d+)(\\\\D?)', s):\n        d.append(d[int(m[1])] + m[2])\n    return ''.join(d)", "entry_point": "encoder", "task_id": "TACO_lite/949", "input_output_examples": "[[['ABAABABAABAB'], ['ABAABABAABABAA'], ['ABBCBCABABCAABCAABBCAA'], ['AAAAAAAAAAAAAAA'], ['ABCABCABCABCABCABC'], ['ABCDDEFGABCDEDBBDEAAEDAEDCDABC']], [['0A0B1A2A4A4B'], ['0A0B1A2A4A4B3'], ['0A0B2C3A2A4A6B6'], ['0A1A2A3A4A'], ['0A0B0C1B3A2C4C7A6'], ['0A0B0C0D4E0F0G1B3D0E4B2D10A1E4A10D9A2C']]]", "llm_generated_inputs": {"deepseek-v3": "[['ABAABABAABAB'], ['ABAABABAABABAA'], ['ABBCBCABABCAABCAABBCAA'], ['AAAAAAAAAAAAAAA'], ['ABCABCABCABCABCABC'], ['ABCDDEFGABCDEDBBDEAAEDAEDCDABC'], ['A'], ['AA'], ['AB'], ['ABC'], ['AAAAA'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZ'], ['AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ']]", "qwen2.5-coder-32b-instruct": "[['ABAABABAABAB'], ['ABBCBCABABCAABCAABBCAA'], ['AAAAAAAAAAAAAAA'], ['ABCABCABCABCABCABC'], ['ABCDDEFGABCDEDBBDEAAEDAEDCDABC'], ['A'], ['AA'], ['ABC'], ['ABACABA'], ['ZZZZZZZZZZ'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZ']]"}}
{"requirement": "def seven_ate9(str_: str) -> str:\n\"\"\"Write a function that removes every lone 9 that is inbetween 7s.\n\n```python\nseven_ate9('79712312') => '7712312'\nseven_ate9('79797') => '777'\n```\n\nInput: String\nOutput: String\n\"\"\"", "inputs": [["165561786121789797"], ["797"], ["7979797"], ["16797"], ["77"], ["7927"], ["1779"], ["a779"], ["17797a"], ["797 9 7"]], "outputs": [["16556178612178977"], ["77"], ["7777"], ["1677"], ["77"], ["7927"], ["1779"], ["a779"], ["1777a"], ["77 9 7"]], "starter_code": "def seven_ate9(str_: str) -> str:", "canonical_solution": "def seven_ate9(str_):\n    while str_.find('797') != -1:\n        str_ = str_.replace('797', '77')\n    return str_", "entry_point": "seven_ate9", "task_id": "TACO_lite/950", "input_output_examples": "[[['79712312'], ['79797']], [['7712312'], ['777']]]", "llm_generated_inputs": {"deepseek-v3": "[['79712312'], ['79797'], ['777'], ['979'], ['7997'], ['7997979'], ['123456789'], ['7979797979'], ['999'], ['777777'], ['797979'], ['79979797'], ['797797797'], ['797'], ['9797'], ['7979']]", "qwen2.5-coder-32b-instruct": "[['797'], ['79712312'], ['79797'], ['123456'], ['79'], ['979'], ['777'], ['7979797'], ['7997'], ['77977'], ['9779'], ['7979'], ['7'], ['9'], ['']]"}}
{"requirement": "from typing import List\n\n\ndef zozonacci(pattern: List[str], n: int) -> List[int]:\n\"\"\"# History\n\nThis kata is a sequel of my [Mixbonacci](https://www.codewars.com/kata/mixbonacci/python) kata. Zozonacci is a special integer sequence named after [**ZozoFouchtra**](https://www.codewars.com/users/ZozoFouchtra), who came up with this kata idea in the [Mixbonacci discussion](https://www.codewars.com/kata/mixbonacci/discuss/python). \n\nThis sequence combines the rules for computing the n-th elements of fibonacci, jacobstal, pell, padovan, tribonacci and tetranacci sequences according to a given pattern.\n\n# Task\n\nCompute the first `n` elements of the Zozonacci sequence for a given pattern `p`.\n\n## Rules\n\n1. `n` is given as integer and `p` is given as a list of as abbreviations as strings (e.g. `[\"fib\", \"jac\", \"pad\"]`)\n2. When `n` is 0 or `p` is empty return an empty list.\n3. The first four elements of the sequence are determined by the first abbreviation in the pattern (see the table below).\n4. Compute the fifth element using the formula corespoding to the first element of the pattern, the sixth element using the formula for the second element and so on. (see the table below and the examples)\n5. If `n` is more than the length of `p` repeat the pattern.\n\n\n```\n+------------+--------------+------------------------------------------+---------------------+\n|  sequence  | abbreviation |         formula for n-th element         | first four elements |\n+------------|--------------+------------------------------------------|---------------------|\n| fibonacci  |     fib      | a[n] = a[n-1] + a[n-2]                   |     0, 0, 0, 1      |\n| jacobsthal |     jac      | a[n] = a[n-1] + 2 * a[n-2]               |     0, 0, 0, 1      |\n| padovan    |     pad      | a[n] = a[n-2] + a[n-3]                   |     0, 1, 0, 0      |\n| pell       |     pel      | a[n] = 2 * a[n-1] + a[n-2]               |     0, 0, 0, 1      |\n| tetranacci |     tet      | a[n] = a[n-1] + a[n-2] + a[n-3] + a[n-4] |     0, 0, 0, 1      |\n| tribonacci |     tri      | a[n] = a[n-1] + a[n-2] + a[n-3]          |     0, 0, 0, 1      |\n+------------+--------------+------------------------------------------+---------------------+\n```\n\n## Example\n\n```\nzozonacci([\"fib\", \"tri\"], 7) == [0, 0, 0, 1, 1, 2, 3]\n\nExplanation: \n\n          b     d\n       /-----\\/----\\\n[0, 0, 0, 1, 1, 2, 3]\n \\--------/  \n     | \\--------/\n     a     c\n\na - [0, 0, 0, 1] as \"fib\" is the first abbreviation\nb - 5th element is 1 as the 1st element of the pattern is \"fib\": 1 = 0 + 1\nc - 6th element is 2 as the 2nd element of the pattern is \"tri\": 2 = 0 + 1 + 1\nd - 7th element is 3 as the 3rd element of the pattern is \"fib\" (see rule no. 5): 3 = 2 + 1\n```\n\n## Sequences\n\n* [fibonacci](https://oeis.org/A000045) : 0, 1, 1, 2, 3 ...\n* [padovan](https://oeis.org/A000931): 1, 0, 0, 1, 0 ...\n* [jacobsthal](https://oeis.org/A001045): 0, 1, 1, 3, 5 ...\n* [pell](https://oeis.org/A000129): 0, 1, 2, 5, 12 ...\n* [tribonacci](https://oeis.org/A000073): 0, 0, 1, 1, 2 ...\n* [tetranacci](https://oeis.org/A000078): 0, 0, 0, 1, 1 ...\n\"\"\"", "inputs": [[["fib"], 0], [[], 10], [["fib"], 10], [["tri"], 10], [["tet"], 10], [["pad"], 10], [["pel"], 10], [["jac"], 10], [["fib", "tri"], 10], [["tri", "fib"], 10], [["pad", "fib"], 10], [["tri", "tet"], 10], [["fib", "pel", "tri"], 10], [["tet", "jac"], 10]], "outputs": [[[]], [[]], [[0, 0, 0, 1, 1, 2, 3, 5, 8, 13]], [[0, 0, 0, 1, 1, 2, 4, 7, 13, 24]], [[0, 0, 0, 1, 1, 2, 4, 8, 15, 29]], [[0, 1, 0, 0, 1, 0, 1, 1, 1, 2]], [[0, 0, 0, 1, 2, 5, 12, 29, 70, 169]], [[0, 0, 0, 1, 1, 3, 5, 11, 21, 43]], [[0, 0, 0, 1, 1, 2, 3, 6, 9, 18]], [[0, 0, 0, 1, 1, 2, 4, 6, 12, 18]], [[0, 1, 0, 0, 1, 1, 1, 2, 2, 4]], [[0, 0, 0, 1, 1, 2, 4, 8, 14, 28]], [[0, 0, 0, 1, 1, 3, 5, 8, 21, 34]], [[0, 0, 0, 1, 1, 3, 5, 11, 20, 42]]], "starter_code": "from typing import List\ndef zozonacci(pattern: List[str], n: int) -> List[int]:", "canonical_solution": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef zozonacci(pattern, n):\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for f, _ in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]", "entry_point": "zozonacci", "task_id": "TACO_lite/952", "input_output_examples": "[[[['fib', 'tri'], 7]], [[[0, 0, 0, 1, 1, 2, 3]]]]", "llm_generated_inputs": {"deepseek-v3": "[[['fib', 'tri'], 7], [['jac', 'pel'], 5], [['pad', 'tet'], 6], [['pel', 'fib'], 4], [['tet', 'jac'], 8], [['tri', 'pad'], 10], [[], 5], [['fib', 'jac'], 0], [['pad', 'pel', 'tet'], 12], [['fib', 'tri', 'jac', 'pad', 'pel', 'tet'], 15]]", "qwen2.5-coder-32b-instruct": "[[['fib', 'tri'], 7], [[], 5], [['fib'], 0], [['fib'], 1], [['fib'], 4], [['fib'], 5], [['jac'], 7], [['pad'], 7], [['pel'], 7], [['tet'], 7], [['tri'], 7], [['fib', 'jac', 'pad', 'pel', 'tet', 'tri'], 12], [['fib', 'fib', 'fib'], 10], [['tri', 'tri', 'tri'], 10], [['pad', 'pad', 'pad'], 10], [['pel', 'pel', 'pel'], 10], [['tet', 'tet', 'tet'], 10], [['jac', 'jac', 'jac'], 10]]"}}
{"requirement": "def fire_and_fury(tweet: str) -> str:\n\"\"\"# The President's phone is broken\n\nHe is not very happy.\n\nThe only letters still working are uppercase ```E```, ```F```, ```I```, ```R```, ```U```, ```Y```.\n\nAn angry tweet is sent to the department responsible for presidential phone maintenance.\n\n\n# Kata Task\n\nDecipher the tweet by looking for words with known meanings.\n\n\n* ```FIRE``` = *\"You are fired!\"*\n* ```FURY``` = *\"I am furious.\"*\n\nIf no known words are found, or unexpected letters are encountered, then it must be a *\"Fake tweet.\"*\n\n# Notes\n\n* The tweet reads left-to-right.\n* Any letters not spelling words ```FIRE``` or ```FURY``` are just ignored\n* If multiple of the same words are found in a row then plural rules apply -\n * ```FIRE``` x 1 = *\"You are fired!\"*\n * ```FIRE``` x 2 = *\"You and you are fired!\"*\n * ```FIRE``` x 3 = *\"You and you and you are fired!\"*\n * etc...\n * ```FURY``` x 1 = *\"I am furious.\"*\n * ```FURY``` x 2 = *\"I am really furious.\"*\n * ```FURY``` x 3 = *\"I am really really furious.\"*\n * etc...\n\n# Examples\n\n* ex1. FURYYYFIREYYFIRE = *\"I am furious. You and you are fired!\"*\n* ex2. FIREYYFURYYFURYYFURRYFIRE = *\"You are fired! I am really furious. You are fired!\"*\n* ex3. FYRYFIRUFIRUFURE = *\"Fake tweet.\"*\n\n\n----\nDM :-)\n\"\"\"", "inputs": [["FURYYYFIREYYFIRE"], ["FIREYYFURYYFURYYFURRYFIRE"], ["FYRYFIRUFIRUFURE"], [""], ["FURYFURYFURY"], ["FURYFURYFURYFURY"], ["FURYFURYFURYFURYFURY"], ["FIRE"], ["FIREFIRE"], ["FIREFIREFIRE"], ["FIREFIREFIREFIRE"], ["FIREFIREFIREFIREFIRE"]], "outputs": [["I am furious. You and you are fired!"], ["You are fired! I am really furious. You are fired!"], ["Fake tweet."], ["Fake tweet."], ["I am really really furious."], ["I am really really really furious."], ["I am really really really really furious."], ["You are fired!"], ["You and you are fired!"], ["You and you and you are fired!"], ["You and you and you and you are fired!"], ["You and you and you and you and you are fired!"]], "starter_code": "def fire_and_fury(tweet: str) -> str:", "canonical_solution": "import re\nfrom itertools import groupby\nCONFIG = {'FURY': ' really', 'FIRE': ' and you', 'FAKE': 'Fake tweet.', 'FURY_f': 'I am{} furious.', 'FIRE_f': 'You{} are fired!'}\n\ndef fire_and_fury(tweet):\n    if re.findall('[^FURYIE]', tweet):\n        return CONFIG['FAKE']\n    lst = []\n    for k, g in groupby(re.findall('FURY|FIRE', tweet)):\n        lst += [CONFIG[k + '_f'].format(CONFIG[k] * (len(list(g)) - 1))]\n    return ' '.join(lst) or CONFIG['FAKE']", "entry_point": "fire_and_fury", "task_id": "TACO_lite/954", "input_output_examples": "[[['FURYYYFIREYYFIRE'], ['FIREYYFURYYFURYYFURRYFIRE'], ['FYRYFIRUFIRUFURE']], [['I am furious. You and you are fired!'], ['You are fired! I am really furious. You are fired!'], ['Fake tweet.']]]", "llm_generated_inputs": {"deepseek-v3": "[['FIRE'], ['FURY'], ['FIREFIRE'], ['FURYYYFIREYYFIRE'], ['FIREYYFURYYFURYYFURRYFIRE'], ['FYRYFIRUFIRUFURE'], ['FIREFURYFIREFURY'], ['FURYFURYFURY'], ['FIREFIREFIRE'], ['FURYFIREFURYFIRE'], ['FIREandFURY'], ['FIRE123FURY'], ['FIREFUR'], ['FURFIRE'], ['FIREFURYFIREFURYFIRE'], ['FURYFIREFURYFIREFURY'], ['FIREFIREFURYFURY'], ['FURYFURYFIREFIRE'], ['FIREFURYFURYFIRE'], ['FURYFIREFIREFURY']]", "qwen2.5-coder-32b-instruct": "[['FIRE'], ['FURY'], ['FURYYYFIREYYFIRE'], ['FIREYYFURYYFURYYFURRYFIRE'], ['FYRYFIRUFIRUFURE'], ['FIREFIRE'], ['FURYFURY'], ['FIREFIREFIRE'], ['FURYFURYFURY'], ['FIREFURYFIRE'], ['FURYFIREFURY'], ['EFIRYFIRE'], ['FIREXYFURY'], ['FURYFIREXFURY'], [''], ['EFFFFRRRRUUUIIIYYYYY'], ['FIREFIREFIREFIREFIREFIREFIREFIREFIREFIRE'], ['FURYFURYFURYFURYFURYFURYFURYFURYFURYFURY']]"}}
{"requirement": "def alan_annoying_kid(phrase: str) -> str:\n\"\"\"Alan's child can be annoying at times.\n\nWhen Alan comes home and tells his kid what he has accomplished today, his kid never believes him. \n\nBe that kid.\n\nYour function 'AlanAnnoyingKid' takes as input a sentence spoken by Alan (a string). The sentence contains the following structure:\n\n    \"Today I \" + [action_verb] + [object] + \".\"\n\n    (e.g.: \"Today I played football.\")\n\n\nYour function will return Alan's kid response, which is another sentence with the following structure:\n\n    \"I don't think you \" + [action_performed_by_alan] + \" today, I think you \" + [\"did\" OR \"didn't\"] + [verb_of _action_in_present_tense] + [\" it!\" OR \" at all!\"]\n\n    (e.g.:\"I don't think you played football today, I think you didn't play at all!\")\n\n\nNote the different structure depending on the presence of a negation in Alan's first sentence (e.g., whether Alan says \"I dind't play football\", or \"I played football\").\n\n! Also note: Alan's kid is young and only uses simple, regular verbs that use a simple \"ed\" to make past tense. \nThere are random test cases.\n\nSome more examples:\n\n    input  = \"Today I played football.\"\n    output = \"I don't think you played football today, I think you didn't play at all!\"\n    \n    input  = \"Today I didn't attempt to hardcode this Kata.\"\n    output = \"I don't think you didn't attempt to hardcode this Kata today, I think you did attempt it!\"\n          \n    input  = \"Today I didn't play football.\"\n    output = \"I don't think you didn't play football today, I think you did play it!\"\n          \n    input  = \"Today I cleaned the kitchen.\"\n    output = \"I don't think you cleaned the kitchen today, I think you didn't clean at all!\"\n\"\"\"", "inputs": [["Today I played football."], ["Today I didn't play football."], ["Today I didn't attempt to hardcode this Kata."], ["Today I cleaned the kitchen."], ["Today I learned to code like a pro."]], "outputs": [["I don't think you played football today, I think you didn't play at all!"], ["I don't think you didn't play football today, I think you did play it!"], ["I don't think you didn't attempt to hardcode this Kata today, I think you did attempt it!"], ["I don't think you cleaned the kitchen today, I think you didn't clean at all!"], ["I don't think you learned to code like a pro today, I think you didn't learn at all!"]], "starter_code": "def alan_annoying_kid(phrase: str) -> str:", "canonical_solution": "OUTPUT = \"I don't think you {} today, I think you {} {} {}!\".format\n\ndef alan_annoying_kid(phrase):\n    words = phrase.split()\n    action = ' '.join(words[2:]).rstrip('.')\n    if \"didn't\" in phrase:\n        return OUTPUT(action, 'did', words[3], 'it')\n    return OUTPUT(action, \"didn't\", words[2][:-2], 'at all')", "entry_point": "alan_annoying_kid", "task_id": "TACO_lite/956", "input_output_examples": "[[['Today I played football.'], [\"Today I didn't attempt to hardcode this Kata.\"], [\"Today I didn't play football.\"], ['Today I cleaned the kitchen.']], [[\"I don't think you played football today, I think you didn't play at all!\"], [\"I don't think you didn't attempt to hardcode this Kata today, I think you did attempt it!\"], [\"I don't think you didn't play football today, I think you did play it!\"], [\"I don't think you cleaned the kitchen today, I think you didn't clean at all!\"]]]", "llm_generated_inputs": {"deepseek-v3": "[['Today I played football.'], [\"Today I didn't attempt to hardcode this Kata.\"], [\"Today I didn't play football.\"], ['Today I cleaned the kitchen.'], ['Today I watched a movie.'], [\"Today I didn't finish my homework.\"], ['Today I cooked dinner.'], [\"Today I didn't go to the gym.\"], ['Today I read a book.'], [\"Today I didn't call my friend.\"], ['Today I wrote a letter.'], [\"Today I didn't clean my room.\"], ['Today I played the piano.'], [\"Today I didn't eat breakfast.\"], ['Today I painted a picture.'], [\"Today I didn't take a shower.\"], ['Today I danced in the rain.'], [\"Today I didn't buy groceries.\"], ['Today I sang a song.'], [\"Today I didn't walk the dog.\"]]", "qwen2.5-coder-32b-instruct": "[['Today I played football.'], [\"Today I didn't attempt to hardcode this Kata.\"], [\"Today I didn't play football.\"], ['Today I cleaned the kitchen.'], ['Today I read a book.'], [\"Today I didn't read a book.\"], ['Today I baked a cake.'], [\"Today I didn't bake a cake.\"], ['Today I went to the park.'], [\"Today I didn't go to the park.\"], ['Today I wrote a letter.'], [\"Today I didn't write a letter.\"], ['Today I cooked dinner.'], [\"Today I didn't cook dinner.\"], ['Today I ran in the race.'], [\"Today I didn't run in the race.\"]]"}}
{"requirement": "def snail(column: int, day: int, night: int) -> int:\n\"\"\"The snail crawls up the column. During the day it crawls up some distance. During the night she sleeps, so she slides down for some distance (less than crawls up during the day).\n\nYour function takes three arguments:\n1. The height of the column (meters)\n2. The distance that the snail crawls during the day (meters)\n3. The distance that the snail slides down during the night (meters)\n\nCalculate number of day when the snail will reach the top of the column.\n\"\"\"", "inputs": [[3, 2, 1], [10, 3, 1], [10, 3, 2], [100, 20, 5], [5, 10, 3]], "outputs": [[2], [5], [8], [7], [1]], "starter_code": "def snail(column: int, day: int, night: int) -> int:", "canonical_solution": "from math import ceil\n\ndef snail(column, day, night):\n    return max(ceil((column - night) / (day - night)), 1)", "entry_point": "snail", "task_id": "TACO_lite/959", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[10, 3, 2], [5, 5, 1], [10, 1, 9], [100, 50, 25], [10, 10, 0], [10, 0, 5], [10, 5, 0], [1, 1, 0], [10, 9, 1], [10, 11, 1]]", "qwen2.5-coder-32b-instruct": "[[10, 3, 1], [5, 2, 1], [7, 5, 2], [100, 10, 5], [1, 1, 0], [10, 10, 9], [10, 1, 0], [0, 0, 0], [10, 0, 1], [10, 5, 5]]"}}
{"requirement": "from typing import List\n\n\ndef land_perimeter(arr: List[str]) -> str:\n\"\"\"Task:\nGiven an array arr of strings complete the function landPerimeter by calculating the total perimeter of all the islands. Each piece of land will be marked with 'X' while the water fields are represented as 'O'. Consider each tile being a perfect 1 x 1piece of land. Some examples for better visualization:\n\n['XOOXO',\n  'XOOXO',\n  'OOOXO',\n  'XXOXO',\n  'OXOOO'] \n\nor \n\n\nshould return:\n\"Total land perimeter: 24\",\n\nwhile\n\n\n['XOOO',\n  'XOXO',\n  'XOXO',\n  'OOXX',\n  'OOOO']\n\n\n\nshould return: \"Total land perimeter: 18\"\nGood luck!\n\"\"\"", "inputs": [[["OXOOOX", "OXOXOO", "XXOOOX", "OXXXOO", "OOXOOX", "OXOOOO", "OOXOOX", "OOXOOO", "OXOOOO", "OXOOXX"]], [["OXOOO", "OOXXX", "OXXOO", "XOOOO", "XOOOO", "XXXOO", "XOXOO", "OOOXO", "OXOOX", "XOOOO", "OOOXO"]], [["XXXXXOOO", "OOXOOOOO", "OOOOOOXO", "XXXOOOXO", "OXOXXOOX"]], [["XOOOXOO", "OXOOOOO", "XOXOXOO", "OXOXXOO", "OOOOOXX", "OOOXOXX", "XXXXOXO"]], [["OOOOXO", "XOXOOX", "XXOXOX", "XOXOOO", "OOOOOO", "OOOXOO", "OOXXOO"]], [["X"]]], "outputs": [["Total land perimeter: 60"], ["Total land perimeter: 52"], ["Total land perimeter: 40"], ["Total land perimeter: 54"], ["Total land perimeter: 40"], ["Total land perimeter: 4"]], "starter_code": "from typing import List\ndef land_perimeter(arr: List[str]) -> str:", "canonical_solution": "def land_perimeter(arr):\n    I, J = (len(arr), len(arr[0]))\n    P = 0\n    for i in range(I):\n        for j in range(J):\n            if arr[i][j] == 'X':\n                if i == 0 or arr[i - 1][j] == 'O':\n                    P += 1\n                if i == I - 1 or arr[i + 1][j] == 'O':\n                    P += 1\n                if j == 0 or arr[i][j - 1] == 'O':\n                    P += 1\n                if j == J - 1 or arr[i][j + 1] == 'O':\n                    P += 1\n    return 'Total land perimeter: ' + str(P)", "entry_point": "land_perimeter", "task_id": "TACO_lite/963", "input_output_examples": "[[[['XOOXO', 'XOOXO', 'OOOXO', 'XXOXO', 'OXOOO']], [['XOOO', 'XOXO', 'XOXO', 'OOXX', 'OOOO']]], [['Total land perimeter: 24'], ['Total land perimeter: 18']]]", "llm_generated_inputs": {"deepseek-v3": "[[['XOOXO', 'XOOXO', 'OOOXO', 'XXOXO', 'OXOOO']], [['XOOO', 'XOXO', 'XOXO', 'OOXX', 'OOOO']], [['X']], [['O']], [['XXXXX', 'XXXXX', 'XXXXX', 'XXXXX', 'XXXXX']], [['OOO', 'OXO', 'OOO']], [['XOX', 'OXO', 'XOX']], [['XX', 'XX']], [['XO', 'OX']], [['X', 'O', 'X']], [[]]]", "qwen2.5-coder-32b-instruct": "[[['XOOXO', 'XOOXO', 'OOOXO', 'XXOXO', 'OXOOO']], [['XOOO', 'XOXO', 'XOXO', 'OOXX', 'OOOO']], [['XXXX', 'XXXX', 'XXXX', 'XXXX']], [['OOOO', 'OOOO', 'OOOO', 'OOOO']], [['XOXO', 'OXOX', 'XOXO', 'OXOX']], [['X']], [['O']], [['XOXOXO', 'OXOXOX', 'XOXOXO', 'OXOXOX']], [['XOOOOX', 'OOOOOO', 'OOOOOO', 'XOOOOX']], [['X', 'X', 'X', 'X']], [['O', 'O', 'O', 'O']]]"}}
{"requirement": "def isleapyear(year: int) -> bool:\n\"\"\"In this kata you should simply determine, whether a given year is a leap year or not. In case you don't know the rules, here they are:\n\n* years divisible by 4 are leap years\n* but years divisible by 100 are **not** leap years\n* but years divisible by 400 are leap years\n\nAdditional Notes:\n\n* Only valid years (positive integers) will be tested, so you don't have to validate them\n\nExamples can be found in the test fixture.\n\"\"\"", "inputs": [[1984], [2000], [2004], [8], [0], [1234], [1100], [1194]], "outputs": [[true], [true], [true], [true], [true], [false], [false], [false]], "starter_code": "def isleapyear(year: int) -> bool:", "canonical_solution": "def isleapyear(year):\n    return year % 100 != 0 and year % 4 == 0 or year % 400 == 0", "entry_point": "isleapyear", "task_id": "TACO_lite/964", "input_output_examples": "[[[2000], [1900], [2020], [2019]], [[True], [False], [True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[2000], [1900], [2020], [2021], [1600], [1700], [2400], [2004], [2100], [1], [400], [100], [4]]", "qwen2.5-coder-32b-instruct": "[[2000], [1900], [2004], [2001], [400], [100], [1], [4], [500], [800]]"}}
{"requirement": "def permutation_average(n: int) -> int:\n\"\"\"A number is simply made up of digits.  \nThe number 1256 is made up of the digits 1, 2, 5, and 6.  \nFor 1256 there are 24 distinct permutations of the digits:  \n1256, 1265, 1625, 1652, 1562, 1526, 2156, 2165, 2615, 2651, 2561, 2516,   \n5126, 5162, 5216, 5261, 5621, 5612, 6125, 6152, 6251, 6215, 6521, 6512.\n  \nYour goal is to write a program that takes a number, n, and returns the average value of all distinct permutations of the digits in n.  Your answer should be rounded to the nearest integer. For the example above the return value would be 3889. * \n  \n  n will never be negative\n  \nA few examples:\n```python\npermutation_average(2)\nreturn 2\n\npermutation_average(25)\n>>> 25 + 52 = 77\n>>> 77 / 2 = 38.5\nreturn 39 *\n\npermutation_average(20)\n>>> 20 + 02 = 22\n>>> 22 / 2 = 11\nreturn 11\n\npermutation_average(737)\n>>> 737 + 377 + 773 = 1887\n>>> 1887 / 3 = 629\nreturn 629\n\n```\n\nNote: Your program should be able to handle numbers up to 6 digits long\n~~~if:python\n\\* Python version 3 and above uses Banker Rounding so the expected values for those tests would be 3888 and 38 respectively\n~~~\n~~~if-not:python\n\\* ignore these marks, they're for Python only\n~~~\n\"\"\"", "inputs": [[2], [25], [737]], "outputs": [[2], [38], [629]], "starter_code": "def permutation_average(n: int) -> int:", "canonical_solution": "from itertools import permutations\n\ndef permutation_average(n):\n    perms = [float(''.join(e)) for e in permutations(str(n))]\n    return int(round(sum(perms) / len(perms)))", "entry_point": "permutation_average", "task_id": "TACO_lite/965", "input_output_examples": "[[[2], [25], [20], [737]], [[2], [39], [11], [629]]]", "llm_generated_inputs": {"deepseek-v3": "[[2], [25], [20], [737], [1234], [11111], [123456], [100000]]", "qwen2.5-coder-32b-instruct": "[[2], [25], [20], [737], [123], [111], [999999], [123456], [1000], [0]]"}}
{"requirement": "def wheres_wally(string: str) -> int:\n\"\"\"Write a function that returns the index of the first occurence of the word \"Wally\".  \"Wally\" must not be part of another word, but it can be directly followed by a punctuation mark.  If no such \"Wally\" exists, return -1.\n\n\nExamples:\n\n\"Wally\" => 0\n\n\"Where's Wally\" => 8\n\n\"Where's Waldo\" => -1\n\n\"DWally Wallyd .Wally\" => -1\n\n\"Hi Wally.\" => 3\n\n\"It's Wally's.\" => 5\n\n\"Wally Wally\" => 0\n\n\"'Wally Wally\" => 7\n\"\"\"", "inputs": [[""], ["WAlly"], ["wAlly"], ["DWally"], [".Wally"], ["Wallyd"], ["wally mollyWally Wallybrolly 'Wally"], ["Walley ,Wally -Wally ;Wally +Wally :Wally"], ["Walley Wally, Wally- Wally: Wally+ Wally:"], ["12Wally Wally01 W.ally"], ["Where's Waldo"], ["Wally"], ["Wally Wally"], ["W ally Wally"], ["Where's Wally"], ["Hi Wally."], ["It's Wally's."], ["'Wally Wally"], ["Hello Wally my name is Dolly"]], "outputs": [[-1], [-1], [-1], [-1], [-1], [-1], [-1], [-1], [7], [-1], [-1], [0], [0], [7], [8], [3], [5], [7], [6]], "starter_code": "def wheres_wally(string: str) -> int:", "canonical_solution": "from re import compile\n\ndef wheres_wally(string):\n    m = compile(\"(^|.*[\\\\s])(Wally)([\\\\.,\\\\s']|$)\").match(string)\n    return m.start(2) if m else -1", "entry_point": "wheres_wally", "task_id": "TACO_lite/976", "input_output_examples": "[[['Wally'], [\"Where's Wally\"], [\"Where's Waldo\"], ['DWally Wallyd .Wally'], ['Hi Wally.'], [\"It's Wally's.\"], ['Wally Wally'], [\"'Wally Wally\"]], [[0], [8], [-1], [-1], [3], [5], [0], [7]]]", "llm_generated_inputs": {"deepseek-v3": "[['Wally'], [\"Where's Wally\"], [\"Where's Waldo\"], ['DWally Wallyd .Wally'], ['Hi Wally.'], [\"It's Wally's.\"], ['Wally Wally'], [\"'Wally Wally\"], ['Wally'], ['Wally.'], ['Wally,'], ['Wally!'], ['Wally?'], ['Wally:'], ['Wally;'], [\"Wally's\"], [\"Wally's Wally\"], [\"Wally Wally's\"], ['WallyWally'], ['Wally WallyWally'], ['Wally Wally Wally'], [' Wally'], ['  Wally'], ['Wally '], ['Wally  '], ['WallyWally'], ['WallyWallyWally'], ['WallyWally Wally'], ['Wally WallyWally'], ['WallyWallyWallyWally'], ['WallyWallyWally Wally'], ['Wally WallyWallyWally'], ['WallyWally WallyWally'], ['WallyWally Wally WallyWally'], ['WallyWallyWally Wally WallyWally'], ['WallyWally WallyWally WallyWally'], ['WallyWallyWally WallyWally WallyWally'], ['WallyWallyWallyWally WallyWally WallyWally'], ['WallyWallyWallyWally WallyWallyWally WallyWally'], ['WallyWallyWallyWally WallyWallyWally WallyWallyWally'], ['WallyWallyWallyWally WallyWallyWally WallyWallyWallyWally'], ['WallyWallyWallyWally WallyWallyWallyWally WallyWallyWallyWally'], ['WallyWallyWallyWally WallyWallyWallyWally WallyWallyWallyWallyWally'], ['WallyWallyWallyWally WallyWallyWallyWally WallyWallyWallyWallyWallyWally'], ['WallyWallyWallyWally WallyWallyWallyWally WallyWallyWallyWallyWallyWallyWally'], ['WallyWallyWallyWally WallyWallyWallyWally WallyWallyWallyWallyWallyWallyWallyWally'], ['WallyWallyWallyWally WallyWallyWallyWally WallyWallyWallyWallyWallyWallyWallyWallyWally'], ['WallyWallyWallyWally WallyWallyWallyWally WallyWallyWallyWallyWallyWallyWallyWallyWallyWally'], ['WallyWallyWallyWally WallyWallyWallyWally WallyWallyWallyWallyWallyWallyWallyWallyWallyWallyWally'], ['WallyWallyWallyWally WallyWallyWallyWally WallyWallyWallyWallyWallyWallyWallyWallyWallyWallyWallyWally'], ['WallyWallyWallyWally WallyWallyWallyWally WallyWallyWallyWallyWallyWallyWallyWallyWallyWallyWallyWallyWally']]", "qwen2.5-coder-32b-instruct": "[['Wally'], [\"Where's Wally\"], [\"Where's Waldo\"], ['DWally Wallyd .Wally'], ['Hi Wally.'], [\"It's Wally's.\"], ['Wally Wally'], [\"'Wally Wally\"], ['Wally,'], ['Wally!'], ['Wally?'], ['Wally;'], ['Wally:'], ['Wally.'], ['Wally!'], ['Wally'], [' Wally'], ['Wally '], ['Wally Wally Wally'], ['No Wally here'], ['WallyWally'], ['Wally-Wally'], ['Wally_Wally'], ['Wally+Wally'], ['Wally=Wally'], ['Wally/Wally'], ['Wally\\\\Wally'], ['Wally@Wally'], ['Wally#Wally'], ['Wally$Wally'], ['Wally%Wally'], ['Wally^Wally'], ['Wally&Wally'], ['Wally*Wally'], ['Wally(Wally)'], ['Wally{Wally}'], ['Wally[Wally]'], ['Wally<Wally>'], [''], ['NoWally']]"}}
{"requirement": "from typing import List\n\n\ndef range_parser(string: str) -> List[int]:\n\"\"\"In this Kata you are to implement a function that parses a string which is composed from tokens of the form 'n1-n2,n3,n4-n5:n6' where 'nX' is a positive integer. Each token represent a different range:\n\n'n1-n2' represents the range n1 to n2 (inclusive in both ends).\n'n3' represents the single integer n3.\n'n4-n5:n6' represents the range n4 to n5 (inclusive in both ends) but only includes every other n6 integer.\n\nNotes:\n1. The input string doesn't not have to include all the token types.\n2. All integers are assumed to be positive.\n3. Tokens may be separated by `','`, `', '` or ` , `.\n\nSome examples:\n\n'1-10,14, 20-25:2' -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 20, 22, 24]\n\n'5-10' -> [5, 6, 7, 8, 9, 10]\n\n'2' -> [2]\n\nThe output should be a list of integers.\n\"\"\"", "inputs": [["1-10,14, 20-25:2"], ["5-10"], ["2"], ["1-10,3"], ["1-10:5"]], "outputs": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 20, 22, 24]], [[5, 6, 7, 8, 9, 10]], [[2]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 3]], [[1, 6]]], "starter_code": "from typing import List\ndef range_parser(string: str) -> List[int]:", "canonical_solution": "def range_parser(string):\n    res = []\n    for range_ in string.split(','):\n        first_last, _, step = range_.partition(':')\n        first, _, last = first_last.partition('-')\n        res += range(int(first), int(last or first) + 1, int(step or 1))\n    return res", "entry_point": "range_parser", "task_id": "TACO_lite/978", "input_output_examples": "[[['1-10,14, 20-25:2'], ['5-10'], ['2']], [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 20, 22, 24]], [[5, 6, 7, 8, 9, 10]], [[2]]]]", "llm_generated_inputs": {"deepseek-v3": "[['1-10,14, 20-25:2'], ['5-10'], ['2'], ['1-5,6,7-10:3'], ['10-15, 20, 25-30:2'], ['1-1'], ['100-105:5'], ['1,2,3,4,5'], ['1-10:1'], ['1, 2, 3, 4, 5, 6, 7, 8, 9, 10'], ['1-10,11-20:2'], ['1-10, 11-20, 21-30:3'], ['1-10,11-20:1,21-30:2'], ['1-10,11-20:1,21-30:2,31-40:3'], ['1-10,11-20:1,21-30:2,31-40:3,41-50:4'], ['1-10,11-20:1,21-30:2,31-40:3,41-50:4,51-60:5'], ['1-10,11-20:1,21-30:2,31-40:3,41-50:4,51-60:5,61-70:6'], ['1-10,11-20:1,21-30:2,31-40:3,41-50:4,51-60:5,61-70:6,71-80:7'], ['1-10,11-20:1,21-30:2,31-40:3,41-50:4,51-60:5,61-70:6,71-80:7,81-90:8'], ['1-10,11-20:1,21-30:2,31-40:3,41-50:4,51-60:5,61-70:6,71-80:7,81-90:8,91-100:9']]", "qwen2.5-coder-32b-instruct": "[['1-10,14, 20-25:2'], ['5-10'], ['2'], ['1-5, 7-10'], ['1-10:2'], ['10-1:-1'], ['1-5, 5-10, 10-15:2'], ['1-1'], ['10-10'], ['1-5, 6-10, 11-15:3'], ['1-20:3, 25-30'], ['1-100:10'], ['100-1:-10'], ['1, 2, 3, 4, 5'], ['1-3, 5-7, 9-11:2'], ['5-5, 10-10, 15-15'], ['1-10, 12-20:2, 22-30:3'], ['1-5, 6-10, 11-15:2, 16-20:3'], ['1-10, 10-1:-1']]"}}
{"requirement": "def cat_mouse(x: str, j: int) -> str:\n\"\"\"You will be given a string (x) featuring a cat 'C', a dog 'D' and a mouse 'm'. The rest of the string will be made up of '.'. \n\nYou need to find out if the cat can catch the mouse from it's current position. The cat can jump (j) characters. \n\n\n\nAlso, the cat cannot jump over the dog.\n\nSo:\n\nif j = 5:\n\n```..C.....m.``` returns 'Caught!'  <-- not more than j characters between\n\n```.....C............m......``` returns 'Escaped!'  <-- as there are more than j characters between the two, the cat can't jump far enough\n\nif j = 10:\n\n```...m.........C...D``` returns 'Caught!' <--Cat can jump far enough and jump is not over dog\n\n```...m....D....C.......``` returns 'Protected!' <-- Cat can jump far enough, but dog is in the way, protecting the mouse\n\nFinally, if all three animals are not present, return 'boring without all three'\n\"\"\"", "inputs": [["..D.....C.m", 2], ["............C.............D..m...", 8], ["m.C...", 5], [".CD......m.", 10], [".CD......m.", 1]], "outputs": [["Caught!"], ["Escaped!"], ["boring without all three"], ["Protected!"], ["Escaped!"]], "starter_code": "def cat_mouse(x: str, j: int) -> str:", "canonical_solution": "def cat_mouse(x, j):\n    d, c, m = (x.find('D'), x.find('C'), x.find('m'))\n    if -1 in [d, c, m]:\n        return 'boring without all three'\n    if abs(c - m) <= j:\n        return 'Protected!' if c < d < m or m < d < c else 'Caught!'\n    return 'Escaped!'", "entry_point": "cat_mouse", "task_id": "TACO_lite/989", "input_output_examples": "[[['..C.....m.', 5], ['.....C............m......', 5], ['...m.........C...D', 10], ['...m....D....C.......', 10]], [['Caught!'], ['Escaped!'], ['Caught!'], ['Protected!']]]", "llm_generated_inputs": {"deepseek-v3": "[['..C.....m.', 5], ['.....C............m......', 5], ['...m.........C...D', 10], ['...m....D....C.......', 10], ['...C....m....D....', 10], ['....D....C....m....', 10], ['...m....C....D....', 10], ['................', 5], ['...C...D...m...', 3], ['...m...D...C...', 3], ['...C...m...D...', 3], ['...D...m...C...', 3], ['...C...m...', 3], ['...m...C...', 3], ['...D...C...m...', 3], ['...D...m...C...', 3], ['...C...m...D...', 3], ['...m...C...D...', 3]]", "qwen2.5-coder-32b-instruct": "[['..C.....m.', 5], ['.....C............m......', 5], ['...m.........C...D', 10], ['...m....D....C.......', 10], ['...C...m...', 3], ['...C.......m...', 8], ['...C...D...m...', 5], ['...m...D...C...', 5], ['Cm', 1], ['mC', 1], ['C.D.m', 2], ['m.D.C', 2], ['...', 1], ['C..D..m', 4], ['m..D..C', 4], ['C.....m.D', 6], ['D.C.....m', 6]]"}}
{"requirement": "def solve(s: str) -> str:\n\"\"\"You will be given a string and you task is to check if it is possible to convert that string into a palindrome by removing a single character. If the string is already a palindrome, return `\"OK\"`. If it is not, and we can convert it to a palindrome by removing one character, then return `\"remove one\"`, otherwise return `\"not possible\"`. The order of the characters should not be changed.\n\nFor example:\n```Haskell\nsolve(\"abba\") = \"OK\". -- This is a palindrome\nsolve(\"abbaa\") = \"remove one\". -- remove the 'a' at the extreme right. \nsolve(\"abbaab\") = \"not possible\". \n```\n\nMore examples in the test cases. \n\nGood luck!\n\nIf you like this Kata, please try [Single Character Palindromes II](https://www.codewars.com/kata/5a66ea69e6be38219f000110)\n\"\"\"", "inputs": [["abba"], ["abbaa"], ["abbaab"], ["madmam"], ["raydarm"], ["hannah"], ["baba"], ["babab"], ["bababa"], ["abcbad"], ["abcdba"], ["dabcba"], ["abededba"], ["abdcdeba"], ["abcdedba"], ["abbcdedba"]], "outputs": [["OK"], ["remove one"], ["not possible"], ["remove one"], ["not possible"], ["OK"], ["remove one"], ["OK"], ["remove one"], ["remove one"], ["remove one"], ["remove one"], ["remove one"], ["remove one"], ["remove one"], ["not possible"]], "starter_code": "def solve(s: str) -> str:", "canonical_solution": "def solve(s):\n    isOK = lambda x: x == x[::-1]\n    return 'OK' if isOK(s) else 'remove one' if any((isOK(s[:i] + s[i + 1:]) for i in range(len(s)))) else 'not possible'", "entry_point": "solve", "task_id": "TACO_lite/996", "input_output_examples": "[[['abba'], ['abbaa'], ['abbaab']], [['OK'], ['remove one'], ['not possible']]]", "llm_generated_inputs": {"deepseek-v3": "[['abba'], ['abbaa'], ['abbaab'], ['racecar'], ['racecbr'], ['racecba'], ['a'], ['aa'], ['ab'], ['abc'], ['abca'], ['abbc'], ['abcd'], ['madam'], ['madame'], ['madamimadam'], ['madamimadame'], ['madamimadamm']]", "qwen2.5-coder-32b-instruct": "[['abba'], ['abbaa'], ['abbaab'], ['a'], ['aa'], ['abc'], ['racecar'], ['racecarr'], ['abcdefg'], ['aabbaa'], ['aabba'], ['aabbaab'], ['bbaa'], ['bb'], ['b'], ['abac'], ['abca']]"}}
{"requirement": "from typing import List\n\n\ndef create_array(n: int) -> List[int]:\n\"\"\"### Unfinished Loop - Bug Fixing #1\n\nOh no, Timmy's created an infinite loop! Help Timmy find and fix the bug in his unfinished for loop!\n\"\"\"", "inputs": [[1], [2], [3], [4], [5], [6], [7], [8], [9], [10]], "outputs": [[[1]], [[1, 2]], [[1, 2, 3]], [[1, 2, 3, 4]], [[1, 2, 3, 4, 5]], [[1, 2, 3, 4, 5, 6]], [[1, 2, 3, 4, 5, 6, 7]], [[1, 2, 3, 4, 5, 6, 7, 8]], [[1, 2, 3, 4, 5, 6, 7, 8, 9]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]], "starter_code": "from typing import List\ndef create_array(n: int) -> List[int]:", "canonical_solution": "def create_array(n):\n    res = []\n    i = 1\n    while i <= n:\n        res += [i]\n        i += 1\n    return res", "entry_point": "create_array", "task_id": "TACO_lite/999", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[5], [0], [-1], [1], [10]]", "qwen2.5-coder-32b-instruct": "[[5], [0], [-3], [1], [10]]"}}
{"requirement": "from typing import Union\n\n\ndef palindrome(num: int) -> Union[str, bool]:\n\"\"\"A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward. Examples of numerical palindromes are: \n\n2332\n110011\n54322345\n\nFor this kata, single digit numbers will not be considered numerical palindromes. \n\nFor a given number ```num```, write a function to test if the number contains a numerical palindrome or not and return a boolean (true if it does and false if does not). Return \"Not valid\" if the input is not an integer or is less than 0. \n\nNote: Palindromes should be found without permutating ```num```. \n\n```\npalindrome(5) => false\npalindrome(1221) => true\npalindrome(141221001) => true\npalindrome(1215) => true \npalindrome(1294) => false \npalindrome(\"109982\") => \"Not valid\"\n```\n\"\"\"", "inputs": [[868], [1321], [1215], [2], [123322367], [1551], [13598], ["ACCDDCCA"], ["1551"], [-4505], [22.22]], "outputs": [[true], [false], [true], [false], [true], [true], [false], ["Not valid"], ["Not valid"], ["Not valid"], ["Not valid"]], "starter_code": "from typing import Union\ndef palindrome(num: int) -> Union[str, bool]:", "canonical_solution": "def palindrome(num):\n    if type(num) != int or num < 0:\n        return 'Not valid'\n    s = str(num)\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2]:\n            return True\n    return len(s) != 1 and s[-1] == s[-2]", "entry_point": "palindrome", "task_id": "TACO_lite/1001", "input_output_examples": "[[[5], [1221], [141221001], [1215], [1294], ['109982']], [[False], [True], [True], [True], [False], ['Not valid']]]", "llm_generated_inputs": {"deepseek-v3": "[[5], [1221], [141221001], [1215], [1294], ['109982'], [-123], [12321], [123456], [1234321], [123454321], [123456789], [123321], [1234567890], [12345654321], [12345678987654321], [123456789876543210], [123456789876543211], [123456789876543212]]", "qwen2.5-coder-32b-instruct": "[[5], [1221], [141221001], [1215], [1294], ['109982'], [-1221], [0], [1], [12321], [123321], [10], [1001], [1234321], [98789], [111], [22], [333], [4444], [55555], [666666], [7777777], [88888888], [99999999], [1000000001]]"}}
{"requirement": "def rad_ladies(name: str) -> str:\n\"\"\"Comprised of a team of five incredibly brilliant women, \"The ladies of ENIAC\" were the first “computors” working at the University of Pennsylvania’s Moore School of Engineering (1945). Through their contributions, we gained the first software application and the first programming classes! The ladies of ENIAC were inducted into the WITI Hall of Fame in 1997!\n\nWrite a function which reveals \"The ladies of ENIAC\" names, so that you too can add them to your own hall of tech fame!\n\nTo keep: only alpha characters, space characters and exclamation marks.  \nTo remove: numbers and these characters: ```%$&/£?@```\n\nResult should be all in uppercase.\n\"\"\"", "inputs": [["k?%35a&&/y@@@5599 m93753&$$$c$n///79u??@@%l?975$t?%5y%&$3$1!"], ["9?9?9?m335%$@a791%&$r$$$l@53$&y&n%$5@ $5577w&7e931%s$c$o%%%f351f??%!%%"], ["%&$557f953//1/$@%r%935$$a@3111$@???%n???5 $%157b%///$i%55&31@l?%&$$a%@$s5757!$$%%%%53"], ["///$%&$553791r357%??@$%u?$%@7993111@$%t$h3% 3$l$311i3%@?&c3h%&t&&?%11e%$?@11957r79%&m$$a55n1!111%%"], ["??@%&a5d15??e599713%l%%e%75913 1$%&@g@%o&$@13l5d11s$%&t15i9n&5%%@%e@$!%$"]], "outputs": [["KAY MCNULTY!"], ["MARLYN WESCOFF!"], ["FRAN BILAS!"], ["RUTH LICHTERMAN!"], ["ADELE GOLDSTINE!"]], "starter_code": "def rad_ladies(name: str) -> str:", "canonical_solution": "import re\n\ndef rad_ladies(name):\n    return ''.join(re.findall('[A-Z\\\\s!]+', name.upper()))", "entry_point": "rad_ladies", "task_id": "TACO_lite/1002", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['Kathleen McNulty'], ['Jean Jennings!'], ['Betty Holberton123'], ['Marlyn Wescoff%$&'], ['Ruth Teitelbaum@£?/@'], ['Frances Spence 1945'], ['ENIAC!!'], ['1234567890'], ['%$&/£?@'], ['     '], ['!Alpha!Beta!Gamma!'], ['aBcDeFgHiJkLmNoPqRsTuVwXyZ']]", "qwen2.5-coder-32b-instruct": "[['Kathleen McNulty'], ['marlyn Wescoff!'], ['sibylLSeymour123'], ['FrancesBoltzmann!!'], ['Ruth Teitelbaum$%&'], ['!@#$%^&*()'], ['1234567890'], ['ENIAC%Team/'], ['LADIES OF ENIAC!!!']]"}}
{"requirement": "def search_permmult(nMax: int, k: int) -> int:\n\"\"\"The number `1035` is the smallest integer that exhibits a non frequent property: one its multiples, `3105 = 1035 * 3`, has its same digits but in different order, in other words, `3105`, is one of the permutations of `1035`.\n\nThe number `125874` is the first integer that has this property when the multiplier is `2`, thus: `125874 * 2 = 251748`\n\nMake the function `search_permmult()`, that receives an upper bound, nMax and a factor k and will output the amount of pairs bellow nMax that are permuted when an integer of this range is multiplied by `k`. The pair will be counted if the multiple is less than `nMax`, too\n\nLet'see some cases:\n```python\nsearch_permmult(10000, 7) === 1 # because we have the pair 1359, 9513\nsearch_permmult(5000, 7) === 0 # no pairs found, as 9513 > 5000\n\nsearch_permmult(10000, 4) === 2 # we have two pairs (1782, 7128) and (2178, 8712)\nsearch_permmult(8000, 4) === 1 # only the pair (1782, 7128) \n\nsearch_permmult(5000, 3) === 1 # only the pair (1035, 3105)\nsearch_permmult(10000, 3) === 2 # found pairs (1035, 3105) and (2475, 7425)\n```\nFeatures of the random Tests:\n```\n10000 <= nMax <= 100000\n3 <= k <= 7\n```\nEnjoy it and happy coding!!\n\"\"\"", "inputs": [[10000, 7], [5000, 7], [10000, 4], [8000, 4], [5000, 3], [10000, 3]], "outputs": [[1], [0], [2], [1], [1], [2]], "starter_code": "def search_permmult(nMax: int, k: int) -> int:", "canonical_solution": "from bisect import bisect\nmemo = {3: [3105, 7425, 30105, 31050, 37125, 42741, 44172, 71253, 72441, 74142, 74250, 74628, 74925, 82755, 85725], 4: [7128, 8712, 67128, 70416, 71208, 71280, 71328, 71928, 72108, 78912, 79128, 80712, 86712, 87120, 87132, 87192, 87912, 95832], 5: [], 6: [8316, 83160, 83916, 84510, 89154, 91152], 7: [9513, 81816, 83181, 90321, 91203, 93513, 94143, 95130, 95193, 95613]}\n\ndef search_permmult(nMax, k):\n    return bisect(memo[k], nMax)", "entry_point": "search_permmult", "task_id": "TACO_lite/1006", "input_output_examples": "[[[10000, 7], [5000, 7], [10000, 4], [8000, 4], [5000, 3], [10000, 3]], [[1], [0], [2], [1], [1], [2]]]", "llm_generated_inputs": {"deepseek-v3": "[[10000, 7], [5000, 7], [10000, 4], [8000, 4], [5000, 3], [10000, 3], [100000, 5], [20000, 6], [15000, 3], [30000, 4]]", "qwen2.5-coder-32b-instruct": "[[10000, 7], [5000, 7], [10000, 4], [8000, 4], [5000, 3], [10000, 3], [10000, 6], [10000, 5], [100000, 7], [100000, 3], [10000, 8], [9999, 3], [10000, 2], [10000, 1]]"}}
{"requirement": "def nth_even(n: int) -> int:\n\"\"\"Return the Nth Even Number\n\nThe input will not be 0.\n\"\"\"", "inputs": [[1], [2], [3], [100], [1298734]], "outputs": [[0], [2], [4], [198], [2597466]], "starter_code": "def nth_even(n: int) -> int:", "canonical_solution": "def nth_even(n):\n    return 2 * (n - 1)", "entry_point": "nth_even", "task_id": "TACO_lite/1010", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [10], [100], [999]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [10], [100], [-1], [-10]]"}}
{"requirement": "from typing import List\n\n\ndef solution(n: int, d: int) -> List[int]:\n\"\"\"Your job is to write function last_digits(n,d) which return the last `d` digits of an integer `n` as a list.\n`n` will be from 0 to 10^10\n\nExamples:\n\n`last_digits(1,1)     --> [1]`\n\n`last_digits(1234,2)   --> [3,4]`\n\n`last_digits(637547,6) --> [6,3,7,5,4,7]`\n\nSpecial cases:\n\nIf `d` > the number of digits, just return the number's digits as a list.\n\nIf `d` <= 0, then return an empty list.\n\nThis is the first kata I have made, so please report any issues.\n\"\"\"", "inputs": [[1, 1], [123767, 4], [0, 1], [34625647867585, 10], [1234, 0], [24134, -4], [1343, 5]], "outputs": [[[1]], [[3, 7, 6, 7]], [[0]], [[5, 6, 4, 7, 8, 6, 7, 5, 8, 5]], [[]], [[]], [[1, 3, 4, 3]]], "starter_code": "from typing import List\ndef solution(n: int, d: int) -> List[int]:", "canonical_solution": "def solution(n, d):\n    return [int(c) for c in str(n)[-d:]] if d > 0 else []", "entry_point": "solution", "task_id": "TACO_lite/1022", "input_output_examples": "[[[1, 1], [1234, 2], [637547, 6]], [[[1]], [[3, 4]], [[6, 3, 7, 5, 4, 7]]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 1], [1234, 2], [637547, 6], [1234567890, 15], [987654321, 0], [0, 1], [100, 3], [123456789, -1], [9999999999, 10], [12345, 3]]", "qwen2.5-coder-32b-instruct": "[[1, 1], [1234, 2], [637547, 6], [1234567890, 5], [1234567890, 15], [0, 1], [0, 0], [0, -1], [987654321, 9], [987654321, 0], [987654321, -5]]"}}
{"requirement": "def last_fib_digit(n: int) -> int:\n\"\"\"Just like in the [\"father\" kata](http://www.codewars.com/kata/find-fibonacci-last-digit/), you will have to return the last digit of the nth element in the Fibonacci sequence (starting with 1,1, to be extra clear, not with 0,1 or other numbers).\n\nYou will just get much bigger numbers, so good luck bruteforcing your way through it ;)\n```python\nlast_fib_digit(1) == 1\nlast_fib_digit(2) == 1\nlast_fib_digit(3) == 2\nlast_fib_digit(1000) == 5\nlast_fib_digit(1000000) == 5\n```\n``` haskell\nlastFibDigit       1 == 1\nlastFibDigit       2 == 1\nlastFibDigit       3 == 2\nlastFibDigit    1000 == 5\nlastFibDigit 1000000 == 5\n```\n\"\"\"", "inputs": [[1], [21], [302], [4003], [50004], [600005], [7000006], [80000007], [900000008], [1000000009]], "outputs": [[1], [6], [1], [7], [8], [5], [3], [8], [1], [9]], "starter_code": "def last_fib_digit(n: int) -> int:", "canonical_solution": "def last_fib_digit(n):\n    return [0, 1, 1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7, 0, 7, 7, 4, 1, 5, 6, 1, 7, 8, 5, 3, 8, 1, 9, 0, 9, 9, 8, 7, 5, 2, 7, 9, 6, 5, 1, 6, 7, 3, 0, 3, 3, 6, 9, 5, 4, 9, 3, 2, 5, 7, 2, 9, 1][n % 60]", "entry_point": "last_fib_digit", "task_id": "TACO_lite/1029", "input_output_examples": "[[[1], [2], [3], [1000], [1000000]], [[1], [1], [2], [5], [5]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [10], [100], [1000], [1000000], [0], [-1]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [10], [50], [100], [1000], [10000], [100000], [1000000], [0], [-1], [123456789]]"}}
{"requirement": "def solution(pairs: dict) -> str:\n\"\"\"Complete the solution so that it takes the object (JavaScript/CoffeeScript) or hash (ruby) passed in and generates a human readable string from its key/value pairs. \n\n\n\nThe format should be \"KEY = VALUE\". Each key/value pair should be separated by a comma except for the last pair.\n\n**Example:**\n```python\nsolution({\"a\": 1, \"b\": '2'}) # should return \"a = 1,b = 2\"\n```\n\"\"\"", "inputs": [[{"a": 1, "b": 2}], [{"a": "b", "b": "a"}], [{"0": "a", "b": 2}], [{"b": 1, "c": 2, "e": 3}], [{}]], "outputs": [["a = 1,b = 2"], ["a = b,b = a"], ["0 = a,b = 2"], ["b = 1,c = 2,e = 3"], [""]], "starter_code": "def solution(pairs: dict) -> str:", "canonical_solution": "def solution(pairs):\n    return ','.join(sorted(('{} = {}'.format(k, pairs[k]) for k in pairs)))", "entry_point": "solution", "task_id": "TACO_lite/1030", "input_output_examples": "[[[{'a': 1, 'b': '2'}]], [['a = 1,b = 2']]]", "llm_generated_inputs": {"deepseek-v3": "[[{'a': 1, 'b': 2}], [{'name': 'Alice', 'age': 25, 'city': 'Wonderland'}], [{'key1': 'value1', 'key2': 'value2', 'key3': 'value3', 'key4': 'value4'}], [{'single_key': 'single_value'}], [{'empty_value': ''}], [{'number': 123, 'boolean': True, 'none': None}], [{}]]", "qwen2.5-coder-32b-instruct": "[[{'a': 1, 'b': '2'}], [{'name': 'John', 'age': 30}], [{}], [{'single': 'value'}], [{'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}], [{'number': 123, 'boolean': True, 'none': None}]]"}}
{"requirement": "def are_coprime(n: int, m: int) -> bool:\n\"\"\"Write a program to determine if two numbers are coprime. A pair of numbers are coprime if their greatest shared factor is 1. For example:\n```\n20 and 27\nFactors of 20: 1, 2, 4, 5, 10, 20\nFactors of 27: 1, 3, 9, 27\nGreatest shared factor: 1\n20 and 27 are coprime```\nAn example of two numbers that are not coprime:\n```\n12 and 39\nFactors of 12: 1, 2, 3, 4, 6, 12\nFactors of 39: 1, 3, 13, 39\nGreatest shared factor: 3\n12 and 39 are not coprime```\nIf the two inputs are coprime, your program should return true. If they are not coprime, your program should return false.\n\nThe inputs will always be two positive integers between 2 and 99.\n\"\"\"", "inputs": [[20, 27], [12, 39], [17, 34], [34, 17], [35, 10], [64, 27]], "outputs": [[true], [false], [false], [false], [false], [true]], "starter_code": "def are_coprime(n: int, m: int) -> bool:", "canonical_solution": "def are_coprime(n, m):\n    while m > 0:\n        n, m = (m, n % m)\n    return n == 1", "entry_point": "are_coprime", "task_id": "TACO_lite/1034", "input_output_examples": "[[[20, 27], [12, 39]], [[True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[20, 27], [12, 39], [1, 1], [2, 3], [99, 98], [17, 19], [36, 49], [15, 25], [99, 99], [50, 51]]", "qwen2.5-coder-32b-instruct": "[[20, 27], [12, 39], [7, 11], [15, 20], [8, 9], [2, 3], [49, 77], [97, 98], [50, 100], [65, 130]]"}}
{"requirement": "from typing import List\n\n\ndef unique_digit_products(nums: List[int]) -> int:\n\"\"\"# Task\n Let's call `product(x)` the product of x's digits. Given an array of integers a, calculate `product(x)` for each x in a, and return the number of distinct results you get.\n\n# Example\n\n For `a = [2, 8, 121, 42, 222, 23]`, the output should be `3`.\n\n Here are the products of the array's elements:\n```\n2: product(2) = 2;\n8: product(8) = 8;\n121: product(121) = 1 * 2 * 1 = 2;\n42: product(42) = 4 * 2 = 8;\n222: product(222) = 2 * 2 * 2 = 8;\n23: product(23) = 2 * 3 = 6.```\nAs you can see, there are only `3` different products: `2, 6 and 8.`\n\n# Input/Output\n\n\n - `[input]` integer array `a`\n\n    Constraints:\n\n    `1 ≤ a.length ≤ 10000,`\n\n    `1 ≤ a[i] ≤ 1000000000.`\n\n\n - `[output]` an integer\n\n    The number of different digit products in `a`.\n\"\"\"", "inputs": [[[2, 8, 121, 42, 222, 23]], [[239]], [[100, 101, 111]], [[100, 23, 42, 239, 22339, 9999999, 456, 78, 228, 1488]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]]], "outputs": [[3], [1], [2], [10], [10]], "starter_code": "from typing import List\ndef unique_digit_products(nums: List[int]) -> int:", "canonical_solution": "from operator import mul\nfrom functools import reduce\n\ndef unique_digit_products(nums):\n    return len({reduce(mul, (int(a) for a in str(num))) for num in nums})", "entry_point": "unique_digit_products", "task_id": "TACO_lite/1036", "input_output_examples": "[[[[2, 8, 121, 42, 222, 23]]], [[3]]]", "llm_generated_inputs": {"deepseek-v3": "[[[2, 8, 121, 42, 222, 23]], [[1]], [[1111111111]], [[123, 321, 132, 213, 312, 231]], [[10, 100, 1000, 10000]], [[123456789, 987654321]], [[2, 2, 2, 2, 2]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[1000000000]], [[11, 22, 33, 44, 55, 66, 77, 88, 99]], [[123, 456, 789, 101112]]]", "qwen2.5-coder-32b-instruct": "[[[2, 8, 121, 42, 222, 23]], [[1, 10, 100, 1000]], [[9, 99, 999, 9999]], [[111, 222, 333, 444]], [[123, 321, 213, 132]], [[7, 14, 21, 28, 35, 42, 49, 56, 63, 70]], [[111111111, 222222222, 333333333, 444444444]], [[1001, 1010, 1100, 10001]], [[6, 36, 216, 1296]], [[5, 25, 125, 625, 3125]]]"}}
{"requirement": "from typing import List\n\n\ndef find_missing_number(a: List[int]) -> int:\n\"\"\"# Background:\n\nYou're working in a number zoo, and it seems that one of the numbers has gone missing!\n\nZoo workers have no idea what number is missing, and are too incompetent to figure it out, so they're hiring you to do it for them.\n\nIn case the zoo loses another number, they want your program to work regardless of how many numbers there are in total.\n\n___\n\n## Task:\n\nWrite a function that takes a shuffled list of unique numbers from `1` to `n` with one element missing (which can be any number including `n`). Return this missing number.\n\n**Note**: huge lists will be tested.\n\n## Examples:\n\n```\n[1, 3, 4]  =>  2\n[1, 2, 3]  =>  4\n[4, 2, 3]  =>  1\n```\n\"\"\"", "inputs": [[[2, 3, 4]], [[1, 3, 4]], [[1, 2, 4]], [[1, 2, 3]], [[]], [[1]], [[2]]], "outputs": [[1], [2], [3], [4], [1], [2], [1]], "starter_code": "from typing import List\ndef find_missing_number(a: List[int]) -> int:", "canonical_solution": "def find_missing_number(a):\n    n = len(a) + 1\n    return n * (n + 1) // 2 - sum(a)", "entry_point": "find_missing_number", "task_id": "TACO_lite/1042", "input_output_examples": "[[[[1, 3, 4]], [[1, 2, 3]], [[4, 2, 3]]], [[2], [4], [1]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 3, 4]], [[1, 2, 3]], [[4, 2, 3]], [[2, 3, 4]], [[1]], [[]], [[2, 1]], [[5, 3, 2, 1]], [[10, 9, 8, 7, 6, 5, 4, 3, 2]], [[100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]]]", "qwen2.5-coder-32b-instruct": "[[[1, 3, 4]], [[1, 2, 3]], [[4, 2, 3]], [[2, 3, 4, 5, 6]], [[1]], [[]], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]], [[1, 2, 4, 5, 6, 7, 8, 9, 10]], [[2, 1]]]"}}
{"requirement": "def greatest(x: int, y: int, n: int) -> int:\n\"\"\"Given an `x` and `y` find the smallest and greatest numbers **above** and **below** a given `n` that are divisible by both `x` and `y`.\n\n### Examples\n```python\ngreatest(2, 3, 20) => 18   # 18 is the greatest number under 20 that is divisible by both 2 and 3\nsmallest(2, 3, 20) => 24   # 24 is the smallest number above 20 that is divisible by both 2 and 3\n\ngreatest(5, 15, 100) => 90\nsmallest(5, 15, 100) => 105\n\ngreatest(123, 456, 789) => 0   # there are no numbers under 789 that are divisible by both 123 and 456\nsmallest(123, 456, 789) => 18696\n```\n\n**Notes:** \n\n1. you should never return `n` even if it is divisible by `x` and `y` always the number above or below it\n2. `greatest` should return 0 if there are no numbers under `n` that are divisible by both `x` and `y`\n3. and all arguments will be valid (integers greater than 0).\n\n### Note for Haskell users\n\n>Please take a look at [bkaes comment](http://www.codewars.com/kata/when-greatest-is-less-than-smallest/discuss#56418f0fbf1f44834d000050) and give us your opinion\n\"\"\"", "inputs": [[2, 3, 20], [13, 17, 100], [10, 100, 100], [1000000007, 1000000009, 10000000000000000000]], "outputs": [[18], [0], [0], [9000000144000000567]], "starter_code": "def greatest(x: int, y: int, n: int) -> int:", "canonical_solution": "from math import gcd\n\ndef greatest(x, y, n):\n    z = x * y // gcd(x, y)\n    return (n - 1) // z * z\n\ndef smallest(x, y, n):\n    z = x * y // gcd(x, y)\n    return (n + z) // z * z", "entry_point": "greatest", "task_id": "TACO_lite/1048", "input_output_examples": "[[[2, 3, 20], [5, 15, 100], [123, 456, 789]], [[18], [90], [0]]]", "llm_generated_inputs": {"deepseek-v3": "[[2, 3, 20], [5, 15, 100], [123, 456, 789], [1, 1, 10], [10, 20, 50], [3, 5, 15], [7, 11, 77], [4, 6, 10], [2, 4, 8], [100, 200, 300]]", "qwen2.5-coder-32b-instruct": "[[2, 3, 20], [5, 15, 100], [123, 456, 789], [1, 1, 10], [7, 11, 77], [10, 20, 100], [13, 17, 200], [2, 2, 1], [3, 5, 15], [4, 6, 24]]"}}
{"requirement": "def square_it(digits: int) -> str:\n\"\"\"Given an integer, if the length of it's digits is a perfect square, return a square block of sqroot(length) * sqroot(length). If not, simply return \"Not a perfect square!\".\n\nExamples:\n\n1212 returns:\n\n>1212  \n\nNote: 4 digits so 2 squared (2x2 perfect square). 2 digits on each line.\n\n123123123 returns: \n>123123123\n\nNote: 9 digits so 3 squared (3x3 perfect square). 3 digits on each line.\n\"\"\"", "inputs": [[4547286933343749825161701915681956276108219454705210545289005317346009798484488964285906487], [9018987725957078211722188614464713335111946432316299656655295101074026824905754970818508819399112278447656752418265593323370113912723744584574073240943516323447784157358066092725631468888079671657521335087128381310107575132275431269414916925617425285409687690324310817072898257287148156522711461254908286693274093166279425870512628259566052377124447775880617008644341998746986570027517216466097888155908023911535694848614750960689828130978885144920557763252158285694], [86944626044962750893534726099077851607577335767202198413905320614766659748364345816282449751421191528303747833087523204475945395615335662967952361843822778179782534229212354192766209101375850315231183316855108630259118370451501106726058591717002344389591653085033833236689532101017425569425492431762890540540645195910526551635374784218170167918075478628057193286792692701314469372732153188925881538275813979439196157430902387134890159958261181685069901759092686904538755192529613909917467094292318710873628653279220559015423372110997750862147320862231779563551729774657668133341636540639233469168833443041451311309861633762303390764633929024267773690571925364608910758854305428352902695976922784455202485957119205640624939864200327568164194501735991452995146901328501091017231051289479797848015864711532046471816582619920267032716030287179684236523018307324753992553839464574190017623960523381733982030049622126434122566807847653275684002445260738060662286241040272634704353], [5487892858879877643396793078525642632149239559785808760636930989515855486661211795183967525147757709490732794011843466499555712375096229341969695168412873121001844961860227193295627788828111780259269647536464984167079270856604487225524837251837447697922688876262266435148965870044026466559448743690885162205135860343719742854147928159742799611503678305806250947453657091583992635298056202878376799208259327781739104669372179210843577231140906173509397011323468885735016324645686720216973583077332045434113551566718129665778044514049925362514005989583748088842470616209603774273275067040443822785260624141265429788301302500663699985427], [2996853592120074932323599076537440675191592783802843420116639371441227025982183317503494156495615710126506510824251242050156692982079889720533680791629396272751860071160620843485175720297361631384443136240929436940801963018332389767307597276035928358627356253045476913712860377527694404333542690859678872777370034665142003613161200932559118362748881510326906652687132342340527448109318762235849757983704946604335870028975244210860752289753874], [61623994694367406920275473124326262399997068103062276651287629121996165209190603692582417093426619805057156397610032968372969960416259921569116736232424069317189416109828331535861188061832794169191906898784860753478141455270151856574519413583157768412734994585562127513716893178007831118780637796989705215042407997309882918123266910649066303562751008502694003181495791092715743109706147326005107920996881772521844206788909395004699706724356868900576617716948950149160756011934842209680414554069742087547126242609356796319744527789135141634828875552837625569], [31998569100033603295351806729179483788025526781868899036690925565122323937159187305246281520942122551102764687551579575344606179776981155828031361615338373826922486957238998884726413385743295751745896710566999055431241089194743100070386439484197320274447899752784123170454481115017645957610828061295115398605497727025066096731567798675099405613855154109962644132151813617911462445065058226586864209855379579242639695854961778226710996234631299022847180531623104361775182301727072397952351965072991833864408277116182060823054316115390031520935152932303191016649842226578941105578354572628384942742509849272336306470832912083191689053382217266198201183385384895668800378669171583287555352592956816891069887627914473847546318573204759001215867816223225101674172640323107629717954694733518011959254203041317566087624313286877117727206934390307301345377909314491840], [1073892091986587756947644786065984399079168056228427081500975638408799210562552994484059631650080196436110033434965741006509367469156021616519394438264964152154669037006512944686876634114572135464211269031114920791219834639034223839883929647808120881935919585148296723984978970886017928183072995678362453802909511184023490031193765320760311971419814173242061803783490547626618474924990037771281345073824408224707425326689802963927874186823077291117139799415935649937839750676377745754391565380656607705917286011054485192983202182046892826923123103727067081130648743839401042473069120409277625770646313013063240773726971982145977877820842212073929635753980517670830117202802259050814774880895101529345882673951877070812586936561421970761399911589977291178871882885092078672291675015006913608699473919350626012306660177636291473909378021960092468740679907626949402685234109793348106428476079600535563673012533196481207912789], [91061513305897952802351011512], [56541297102910209008941129279927481112423764494572293712036375940901547800992423589422853377453094524928542177985944217087310470648907312719781813062937237598612883825500706630155087663429633610471881829250191059464341535384821859360745931957471152752735053522333368999439697059065633105172768060674131308150284008788857546955919970937281673997817793900618507735189938455212052391173072632730611600100809835802397145198518384034694524326707741469089720430257291003611250300209556975111786753110768682504221215799506013497034906012196213217193830244175247628410755938488891073035518442346906331659199078466348681576118899285135159473415309220959206036492484295976136150018240881966861550217973197452007688279646], [58097074744292797705439489575860298668973727306007380087112881005567153669184046846074112087052113419874006561833629122965089613375892851123606203366018944260030751956431021529227421077950362253281395894265342820712740779638571235321401449444837680519734451504779220913572428032511158272910397509508235290552609709994767174104907468167205616669169998083839835319642962811130179043787671243743871238152568294007619960324915982801520144503673507704675702792386714252552649845513176297804877338193292601420167234081175425577351517732889798238422323654188896787832184496511029987167987255128713604703327651464358038272228385836053761807544512014956494267244514513982830874685998941096377247858195461344872996528971779787077841767905940760149905250636278658058075206150508618252820976179495882999771591828057658548414162279099992900881671696134019195551756383004013726823599663836926897246377448415908468809866795016453741564009443138189327623231263872590441761], [11051737777908605797728660812177389455613770883022529976680544853542699931470207518423193582358615442099633692409142446033402664009208942000924072171772422568819318848390610796810965003476705400169228001042018218331931020864548528177229081832974201122771271390723965066107283513540752650511712489536984056521276518210152114896472352134741995550127882086643229405994497832100418469624606729124247059205917700026031601822980444770112343004401983520447867547955367878488767434987434429879042661015244399655761836156685431962912822796021249604285315538378649272846249239383215189], [8793939513808567481944745395824578438453617513082062113459548521574573203643710972086650613786902715441321945752404795158227395959204313732291065854384168029225528245309778474440169491854754880269701404699904719444226824120437073809259994932929764889951394879980599365380857791340890982367267453828588782402324931894192407697272792475640640041487788136367769392634468489808507603930008424019859050905225504474725513969561627963662376613034101064416505786778259575434851989655719204349939597021295964241907874198021205328457438991488590903537091377793370342427724020187755696429684333108570150816536725882637789744797769083799707513920135259552700736237945993256698821879379809822140518629419263307173849368028952648564239085506243177741644734215636758082029499518892190162110509434842095634152409056505957011585798832426085356106850566339710046564375191819170205936650703301237400390320155474617464537905315172202], [203401514755182963456019496597820207340459706001144040954789266318313441849777526561189250502349258339964998132000467065770646642228945093009975125201126206951023710371380619369019840535218494226254708297263087422185011219657705702848538911638326914192615942005022261292964136638292695247164605265129255618387656735080974724261348470833624229425885621094388734120928306216387146798950887009963918943661053850112291700113830687494395393940636365480846247119362827150799244841867714638828696138936010216289165784639770832730354657892982893284734832157020351606357474002959781394138389777581015427421812365031647015607541091850366711012892480154946141852969844978278393811105430589628536271601007429098688273241726048751797634590902704883470309914720758291195482486177990197653004925492488273133806556076026934359086126], [65070371849018394278363624245959976095049733916040959125686266721884391009434910318942403908280903437079098919111471778529594156881193059312168012255550980312131996242147006530577654775626384798425297948370312900928025941362960161055134852517667540463207321112225597456483563165072808085962879262258380689819156661793128370334420635383658948274905809549402977283467967011240221071683727276873945802758962109498534011532305617087040360536820242684023197440558347123159039525819145618247556100074139467151663165001520935779759023364043080808990570374373363999881937003248588265420514045132318005185052981047503393114049854208992075981471791405606736023148628397824435305855872840094779126217323130934042134607791060854066972245725091353318018057784221398144315190970760248993360672014364126038745527949869027624650232803061744607144553804240370484013352338714646576393395940666123507241112147427853328532618803634787909635587586120617]], "outputs": [["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"], ["Not a perfect square!"]], "starter_code": "def square_it(digits: int) -> str:", "canonical_solution": "def square_it(digits):\n    s = str(digits)\n    n = len(s) ** 0.5\n    if n != int(n):\n        return 'Not a perfect square!'\n    n = int(n)\n    return '\\n'.join((s[i * n:i * n + n] for i in range(int(n))))", "entry_point": "square_it", "task_id": "TACO_lite/1056", "input_output_examples": "[[[1212], [123123]], [['12\\n12'], ['123\\n123\\n123']]]", "llm_generated_inputs": {"deepseek-v3": "[[1212], [123123123], [123456789], [1234567890], [1], [0], [123], [12345678]]", "qwen2.5-coder-32b-instruct": "[[1212], [123123123], [16], [25], [100], [1], [4], [9], [15], [1234567890], [12345678901234567890], [0], [-4], [-9], [11111111111111111111]]"}}
{"requirement": "def trotter(n: int) -> int:\n\"\"\"Bleatrix Trotter the sheep has devised a strategy that helps her fall asleep faster. First, she picks a number N. Then she starts naming N, 2 × N, 3 × N, and so on.\nWhenever she names a number, she thinks about all of the digits in that number. She keeps track of which digits (0, 1, 2, 3, 4, 5, 6, 7, 8, and 9) she has seen at least once so far as part of any number she has named. Once she has seen each of the ten digits at least once, she will fall asleep.\nBleatrix must start with N and must always name (i + 1) × N directly after i × N.\nFor example, suppose that Bleatrix picks N = 1692. She would count as follows:\n\nN = 1692. Now she has seen the digits 1, 2, 6, and 9.\n2N = 3384. Now she has seen the digits 1, 2, 3, 4, 6, 8, and 9.\n3N = 5076. Now she has seen all ten digits, and falls asleep.\n\nThe purpose of this kata is to return the last number Bleatrix Trotter sees before falling asleep.\nInput\nWill always be positive integer or zero\n\nOutput\nThe last number Bleatrix Trotter sees or \"INSOMNIA\" (-1 in Rust and C++) if she will count forever\n\nPlease note, this challenge is not my idea. It's from Google Code Jam 2016\n\n\n\"\"\"", "inputs": [[1692], [2], [7], [100], [1], [11], [163444], [206929], [459923], [691520], [0], [12500], [1250000]], "outputs": [[5076], [90], [70], [900], [10], [110], [653776], [620787], [4139307], [2074560], ["INSOMNIA"], [900000], [90000000]], "starter_code": "def trotter(n: int) -> int:", "canonical_solution": "def trotter(n):\n    i, numStr, numList = (0, '', ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'])\n    if n == 0:\n        return 'INSOMNIA'\n    while all([i in numStr for i in numList]) != True:\n        i += 1\n        numStr = numStr + str(n * i)\n    return i * n", "entry_point": "trotter", "task_id": "TACO_lite/1061", "input_output_examples": "[[[1692]], [[5076]]]", "llm_generated_inputs": {"deepseek-v3": "[[1692], [0], [1], [2], [1234567890], [10], [11], [7], [42], [100]]", "qwen2.5-coder-32b-instruct": "[[1692], [0], [1], [2], [1111111111], [9], [10], [123456789], [987654321], [111]]"}}
{"requirement": "from typing import List\n\n\ndef get_sequence(o: int, s: int, st: int = 1023456789) -> List[int]:\n\"\"\"In mathematics, a **pandigital number** is a number that in a given base has among its significant digits each digit used in the base at least once. For example, 1234567890 is a pandigital number in base 10.\n\nFor simplification, in this kata, we will consider pandigital numbers in *base 10* and with all digits used *exactly once*. The challenge is to calculate a sorted sequence of pandigital numbers, starting at a certain `offset` and with a specified `size`.\n\nExample:\n```python\n  > get_sequence(0, 5)\n  [1023456789, 1023456798, 1023456879, 1023456897, 1023456978]\n```\n\nRules:\n- We are looking for positive pandigital numbers in base 10.\n- Each digit should occur `exactly once`.\n- A pandigital number can't start with digit zero.\n- The offset is an integer (negative, zero or positive number) (long in Java)\n- The size is a positive integer number (int in Java)\n- Return the `size` pandigital numbers which are not smaller than the `offset`. If there is not enough `size` pandigital numbers, just return all of them.\n- Return an empty array if nothing is found.\n\"\"\"", "inputs": [[0, 5], [5432160879, 3], [9876543000, 5], [9999999999, 1], [-123456789, 1], [-9999999999, 25]], "outputs": [[[1023456789, 1023456798, 1023456879, 1023456897, 1023456978]], [[5432160879, 5432160897, 5432160978]], [[9876543012, 9876543021, 9876543102, 9876543120, 9876543201]], [[]], [[1023456789]], [[1023456789, 1023456798, 1023456879, 1023456897, 1023456978, 1023456987, 1023457689, 1023457698, 1023457869, 1023457896, 1023457968, 1023457986, 1023458679, 1023458697, 1023458769, 1023458796, 1023458967, 1023458976, 1023459678, 1023459687, 1023459768, 1023459786, 1023459867, 1023459876, 1023465789]]], "starter_code": "from typing import List\ndef get_sequence(o: int, s: int, st: int = 1023456789) -> List[int]:", "canonical_solution": "def get_sequence(o, s, st=1023456789):\n    li = []\n    for i in range([st, o][o > 0 and o > st], 9876543211):\n        i = str(i)\n        if i[0] != '0' and len(set(i)) == 10:\n            li.append(int(i))\n        if len(li) == s:\n            break\n    return li", "entry_point": "get_sequence", "task_id": "TACO_lite/1063", "input_output_examples": "[[[[0, 5]]], [[[1023456789, 1023456798, 1023456879, 1023456897, 1023456978]]]]", "llm_generated_inputs": {"deepseek-v3": "[[1023456789, 0, 1234567890], [0, 5, 9876543210], [1023456789, 1, 1023456789], [9876543210, 5, 9876543210], [1000000000, 100, 1234567890], [0, 0, 1234567890], [1000000000, 0, 1234567890], [-100, 5, 1234567890]]", "qwen2.5-coder-32b-instruct": "[[1023456789, 1, 123456789], [1023456789, 1, 987654321]]"}}
{"requirement": "def gordon(a: str) -> str:\n\"\"\"Gordon Ramsay shouts. He shouts and swears. There may be something wrong with him.\n\nAnyway, you will be given a string of four words. Your job is to turn them in to Gordon language. \n\nRules:\n\nObviously the words should be Caps,\nEvery word should end with '!!!!',\nAny letter 'a' or 'A' should become '@',\nAny other vowel should become '*'.\n\"\"\"", "inputs": [["What feck damn cake"], ["are you stu pid"], ["i am a chef"], ["dont you talk tome"], ["how dare you feck"]], "outputs": [["WH@T!!!! F*CK!!!! D@MN!!!! C@K*!!!!"], ["@R*!!!! Y**!!!! ST*!!!! P*D!!!!"], ["*!!!! @M!!!! @!!!! CH*F!!!!"], ["D*NT!!!! Y**!!!! T@LK!!!! T*M*!!!!"], ["H*W!!!! D@R*!!!! Y**!!!! F*CK!!!!"]], "starter_code": "def gordon(a: str) -> str:", "canonical_solution": "def gordon(a):\n    return '!!!! '.join(a.upper().split()).translate(str.maketrans('AEIOU', '@****')) + '!!!!'", "entry_point": "gordon", "task_id": "TACO_lite/1065", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['What are we doing'], ['hello world how are you'], ['a e i o u'], ['A E I O U'], ['This is a test'], ['No vowels here'], ['ANOTHER EXAMPLE SENTENCE'], [''], ['a a a a'], ['e e e e'], ['i i i i'], ['o o o o'], ['u u u u'], ['A a E e I i O o U u']]", "qwen2.5-coder-32b-instruct": "[['hello world'], ['gordon ramsay'], ['i am hungry'], ['what a lovely day'], ['A quick brown fox'], ['jump over lazy dog'], ['aeiou'], ['AEIOU'], ['aaaaa'], ['AAAAA'], ['this is a test'], ['gordon gordon gordon gordon']]"}}
{"requirement": "def convert_hash_to_array(hash: dict) -> list:\n\"\"\"Convert a hash into an array. Nothing more, Nothing less.\n\n```\n{name: 'Jeremy', age: 24, role: 'Software Engineer'}\n```\nshould be converted into\n\n```\n[[\"name\", \"Jeremy\"], [\"age\", 24], [\"role\", \"Software Engineer\"]]\n```\n\n```if:python,javascript,crystal\n**Note**: The output array should be sorted alphabetically.\n```\n\nGood Luck!\n\"\"\"", "inputs": [[{"name": "Jeremy"}], [{"name": "Jeremy", "age": 24}], [{"name": "Jeremy", "age": 24, "role": "Software Engineer"}], [{"product": "CodeWars", "power_level_over": 9000}], [{}]], "outputs": [[[["name", "Jeremy"]]], [[["age", 24], ["name", "Jeremy"]]], [[["age", 24], ["name", "Jeremy"], ["role", "Software Engineer"]]], [[["power_level_over", 9000], ["product", "CodeWars"]]], [[]]], "starter_code": "def convert_hash_to_array(hash: dict) -> list:", "canonical_solution": "def convert_hash_to_array(hash):\n    return sorted(map(list, hash.items()))", "entry_point": "convert_hash_to_array", "task_id": "TACO_lite/1066", "input_output_examples": "[[[{'name': 'Jeremy', 'age': 24, 'role': 'Software Engineer'}]], [[[['age', 24], ['name', 'Jeremy'], ['role', 'Software Engineer']]]]]", "llm_generated_inputs": {"deepseek-v3": "[[{'name': 'Jeremy', 'age': 24, 'role': 'Software Engineer'}], [{'a': 1, 'b': 2, 'c': 3}], [{'z': 26, 'y': 25, 'x': 24}], [{'single_key': 'single_value'}], [{}], [{'name': 'Alice', 'age': 30, 'city': 'Wonderland', 'job': 'Developer'}], [{'a': 'apple', 'b': 'banana', 'c': 'cherry'}], [{'1': 'one', '2': 'two', '3': 'three'}], [{'key_with_empty_value': ''}], [{'empty_key': None}]]", "qwen2.5-coder-32b-instruct": "[[{'name': 'Jeremy', 'age': 24, 'role': 'Software Engineer'}], [{'a': 1, 'b': 2, 'c': 3}], [{'z': 9, 'y': 8, 'x': 7}], [{}], [{'single': 'value'}], [{'numbers': [1, 2, 3], 'nested': {'key': 'value'}}]]"}}
{"requirement": "from typing import List\n\n\ndef lamps(a: List[int]) -> int:\n\"\"\"# Task\nN lamps are placed in a line, some are switched on and some are off. What is the smallest number of lamps that need to be switched so that on and off lamps will alternate with each other? \n\nYou are given an array `a` of zeros and ones - `1` mean switched-on lamp and `0` means switched-off.\n\nYour task is to find the smallest number of lamps that need to be switched.\n\n# Example\n\nFor `a = [1, 0, 0, 1, 1, 1, 0]`, the result should be `3`.\n```\na     --> 1 0 0 1 1 1 0\nswith --> 0 1     0\nbecame--> 0 1 0 1 0 1 0 ```\n\n# Input/Output\n\n\n- `[input]` integer array `a`\n\narray of zeros and ones - initial lamp setup, 1 mean switched-on lamp and 0 means switched-off.\n\n`2 < a.length <= 1000`\n\n\n- `[output]` an integer\n\nminimum number of switches.\n\"\"\"", "inputs": [[[1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1]], [[1, 0, 1]], [[1, 0, 1, 0]], [[0, 1, 0, 1, 0]], [[1, 0, 1, 0, 0, 1, 0, 1]], [[1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0]]], "outputs": [[5], [0], [0], [0], [4], [5]], "starter_code": "from typing import List\ndef lamps(a: List[int]) -> int:", "canonical_solution": "def lamps(a):\n    n = sum((1 for i, x in enumerate(a) if x != i % 2))\n    return min(n, len(a) - n)", "entry_point": "lamps", "task_id": "TACO_lite/1072", "input_output_examples": "[[[[1, 0, 0, 1, 1, 1, 0]]], [[3]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 0, 0, 1, 1, 1, 0]], [[0, 1, 0, 1, 0, 1, 0]], [[1, 1, 1, 1, 1, 1, 1]], [[0, 0, 0, 0, 0, 0, 0]], [[1, 0, 1, 0, 1, 0, 1]], [[0, 1, 0, 1, 0, 1, 0, 1]], [[1, 1, 0, 0, 1, 1, 0, 0]], [[1, 0, 1, 0, 0, 1, 0, 1]], [[0, 0, 1, 1, 0, 0, 1, 1]], [[1, 0, 0, 1, 0, 1, 0, 0, 1]]]", "qwen2.5-coder-32b-instruct": "[[[1, 0, 0, 1, 1, 1, 0]], [[0, 1, 0, 1, 0, 1, 0]], [[1, 1, 0, 0, 1, 1, 0]], [[1, 1, 1, 1, 1, 1, 1]], [[0, 0, 0, 0, 0, 0, 0]], [[1, 0, 1, 0, 1, 0, 1]], [[1, 0]], [[0, 1]], [[1, 1, 0]], [[0, 0, 1]]]"}}
{"requirement": "def bin_to_hex(s: str, res: str = '') -> str:\n\"\"\"Define two functions: `hex_to_bin` and `bin_to_hex` (or `hexToBin` and `binToHex`)\n\n\n# hex_to_bin\n\nTakes a hexadecimal string as an argument .\n\n**Note:** This string can contain upper or lower case characters and start with any amount of zeros.\n\nReturns the binary representation (without leading zeros) of the numerical value of the hexadecimal string.\n\nExamples:\n\n```\n\"00F\"    -->  \"1111\"\n\"5\"      -->  \"101\"\n\"00000\"  -->  \"0\"\n\"04D2\"   -->  \"10011010010\"\n```\n\n# bin_to_hex\n\nTakes a binary string (with or without leading zeros) as an argument .\n\nReturns the hexadecimal representation of the numerical value of the binary string.\n\n**Note:** Any non-numerical characters should be lower case\n\n\nExamples:\n\n```\n\"1111\"         -->  \"f\"\n\"000101\"       -->  \"5\"\n\"10011010010\"  -->  \"4d2\"\n```\n\n**Note:** You can assume all arguments are valid so there is no need for error checking.\n\nOh, and I've disabled a few things.\n\n\nAny feedback would be much appreciated\n\"\"\"", "inputs": [["000101"], ["001111"], ["000"], ["10011010010"]], "outputs": [["5"], ["f"], ["0"], ["4d2"]], "starter_code": "def bin_to_hex(s: str, res: str = '') -> str:", "canonical_solution": "bin2hex = {'0000': '0', '0001': '1', '0010': '2', '0011': '3', '0100': '4', '0101': '5', '0110': '6', '0111': '7', '1000': '8', '1001': '9', '1010': 'a', '1011': 'b', '1100': 'c', '1101': 'd', '1110': 'e', '1111': 'f'}\nhex2bin = {v: k for k, v in bin2hex.items()}\n\ndef bin_to_hex(s, res=''):\n    s = '0' * (4 - len(s) % 4) + s\n    while s:\n        res += bin2hex[s[:4]]\n        s = s[4:]\n    return res.lstrip('0') or '0'\n\ndef hex_to_bin(s, res=''):\n    while s:\n        res += hex2bin[s[0].lower()]\n        s = s[1:]\n    return res.lstrip('0') or '0'", "entry_point": "bin_to_hex", "task_id": "TACO_lite/1076", "input_output_examples": "[[['00F'], ['5'], ['00000'], ['04D2'], [['1111']], ['000101'], [['10011010010']]], [['1111'], ['101'], ['0'], ['10011010010'], [['f']], ['5'], [['4d2']]]]", "llm_generated_inputs": {"deepseek-v3": "[['1111', ''], ['000101', ''], ['10011010010', ''], ['0', ''], ['1', ''], ['1010101010101010', ''], ['0000000000000001', ''], ['1111111111111111', '']]", "qwen2.5-coder-32b-instruct": "[['1111', ''], ['000101', ''], ['10011010010', ''], ['0', ''], ['1', ''], ['10', ''], ['110', ''], ['1110', ''], ['11110', ''], ['11111', ''], ['100000', ''], ['11111111', ''], ['100000000', ''], ['111111111', ''], ['1000000000', ''], ['1111111111', ''], ['10000000000', ''], ['11111111111', ''], ['100000000000', ''], ['111111111111', ''], ['1000000000000', ''], ['1111111111111', ''], ['10000000000000', ''], ['11111111111111', ''], ['100000000000000', ''], ['111111111111111', ''], ['1000000000000000', ''], ['1111111111111111', ''], ['0000000000000000', ''], ['11111111111111111111111111111111', ''], ['10101010101010101010101010101010', ''], ['11001100110011001100110011001100', ''], ['00000000000000000000000000000000', '']]"}}
{"requirement": "def find_longest(xs: list) -> int:\n\"\"\"Find the number with the most digits.\n\nIf two numbers in the argument array have the same number of digits, return the first one in the array.\n\"\"\"", "inputs": [[[1, 10, 100]], [[9000, 8, 800]], [[8, 900, 500]], [[3, 40000, 100]], [[1, 200, 100000]]], "outputs": [[100], [9000], [900], [40000], [100000]], "starter_code": "def find_longest(xs: list) -> int:", "canonical_solution": "def find_longest(xs):\n    return max(xs, key=lambda x: len(str(x)))", "entry_point": "find_longest", "task_id": "TACO_lite/1080", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[123, 4567, 89]], [[1, 22, 333, 4444]], [[987654321, 123456789]], [[5, 55, 555, 5555, 55555]], [[1000, 100, 10, 1]], [[9, 99, 999, 9999]], [[123456789, 987654321, 12345678]], [[111, 222, 333, 4444]], [[123, 456, 789, 101112]], [[1]], [[]]]", "qwen2.5-coder-32b-instruct": "[[[1, 22, 333]], [[5678, 90, 12]], [[12345, 6789, 101112]], [[1, 1, 1]], [[0, 0, 0]], [[1000, 100, 10]], [[987654321, 123456789, 9876543210]], [[]], [[12345678901234567890]]]"}}
{"requirement": "def name_that_number(num: int) -> str:\n\"\"\"In this kata, you'll be given an integer of range `0 <= x <= 99` and have to return that number spelt out in English. A few examples:\n\n```python\nname_that_number(4)   # returns \"four\"\nname_that_number(19)  # returns \"nineteen\"\nname_that_number(99)  # returns \"ninety nine\"\n```\n\nWords should be separated by only spaces and not hyphens. No need to validate parameters, they will always be in the range [0, 99]. Make sure that the returned String has no leading of trailing spaces. Good luck!\n\"\"\"", "inputs": [[1], [52], [21], [99], [0], [53], [23], [76]], "outputs": [["one"], ["fifty two"], ["twenty one"], ["ninety nine"], ["zero"], ["fifty three"], ["twenty three"], ["seventy six"]], "starter_code": "def name_that_number(num: int) -> str:", "canonical_solution": "WORDS = ((90, 'ninety'), (80, 'eighty'), (70, 'seventy'), (60, 'sixty'), (50, 'fifty'), (40, 'forty'), (30, 'thirty'), (20, 'twenty'), (19, 'nineteen'), (18, 'eighteen'), (17, 'seventeen'), (16, 'sixteen'), (15, 'fifteen'), (14, 'fourteen'), (13, 'thirteen'), (12, 'twelve'), (11, 'eleven'), (10, 'ten'), (9, 'nine'), (8, 'eight'), (7, 'seven'), (6, 'six'), (5, 'five'), (4, 'four'), (3, 'three'), (2, 'two'), (1, 'one'))\n\ndef name_that_number(num):\n    result = []\n    for word_value, word_name in WORDS:\n        quo, num = divmod(num, word_value)\n        if quo:\n            result.append(word_name)\n    return ' '.join(result) or 'zero'", "entry_point": "name_that_number", "task_id": "TACO_lite/1083", "input_output_examples": "[[[4], [19], [99]], [['four'], ['nineteen'], ['ninety nine']]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [10], [11], [20], [21], [99], [42], [5], [13]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [9], [10], [11], [19], [20], [21], [29], [30], [39], [40], [49], [50], [59], [60], [69], [70], [79], [80], [89], [90], [99]]"}}
{"requirement": "def cake(c: int, d: str) -> str:\n\"\"\"It's your Birthday. Your colleagues buy you a cake. The numbers of candles on the cake is provided (x). Please note this is not reality, and your age can be anywhere up to 1,000. Yes, you would look a mess.\n\nAs a surprise, your colleagues have arranged for your friend to hide inside the cake and burst out. They pretend this is for your benefit, but likely it is just because they want to see you fall over covered in cake. Sounds fun!\n\nWhen your friend jumps out of the cake, he/she will knock some of the candles to the floor. If the number of candles that fall is higher than 70% of total candles (x), the carpet will catch fire. \n\nYou will work out the number of candles that will fall from the provided string (y). You must add up the character ASCII code of each even indexed (assume a 0 based indexing) character in y, with the alphabetical position of each odd indexed character in y to give the string a total.\n\n\n\nexample: 'abc' --> a=97, b=2, c=99 --> y total = 198. \n\nIf the carpet catches fire, return 'Fire!', if not, return 'That was close!'.\n\"\"\"", "inputs": [[900, "abcdef"], [56, "ifkhchlhfd"], [256, "aaaaaddddr"], [333, "jfmgklfhglbe"], [12, "jaam"], [808, "alfbpmmpz"], [660, "zyxsqwh"], [651, "hmgoltyy"], [349, "nxls"], [958, "hovzfsxbmwu"], [301, "doda"], [383, "zwwl"], [871, "gnlyvknjga"], [583, "slhacx"], [0, "jpipe"]], "outputs": [["That was close!"], ["Fire!"], ["Fire!"], ["Fire!"], ["Fire!"], ["Fire!"], ["Fire!"], ["Fire!"], ["Fire!"], ["Fire!"], ["Fire!"], ["Fire!"], ["That was close!"], ["That was close!"], ["That was close!"]], "starter_code": "def cake(c: int, d: str) -> str:", "canonical_solution": "cake = lambda c, d: ['That was close!', 'Fire!'][c != 0 and c * 0.7 < sum((ord(e) - 96 * (i % 2 != 0) for i, e in enumerate(d)))]", "entry_point": "cake", "task_id": "TACO_lite/1084", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[100, 'abc'], [200, 'def'], [0, 'a'], [1000, 'xyz'], [50, '123'], [100, ''], [100, 'AaBbCc'], [100, '!@#$']]", "qwen2.5-coder-32b-instruct": "[[100, 'abcdefgh'], [50, 'aabbccddeeff'], [200, 'xyz'], [300, ' '], [0, 'abc'], [1000, 'AaBbCc'], [1, 'a'], [71, 'abcdefg'], [70, 'abcdefg'], [10, '1234567890']]"}}
{"requirement": "from typing import List\nfrom typing import Union\n\n\ndef get_function(sequence: List[int]) -> Union[str, Callable[[int], int]]:\n\"\"\"This is a follow-up from my previous Kata which can be found here: http://www.codewars.com/kata/5476f4ca03810c0fc0000098\n\nThis time, for any given linear sequence, calculate the function [f(x)] and return it as a function in Javascript or Lambda/Block in Ruby.\n\nFor example:\n\n```python\nget_function([0, 1, 2, 3, 4])(5) => 5\nget_function([0, 3, 6, 9, 12])(10) => 30\nget_function([1, 4, 7, 10, 13])(20) => 61\n```\n\nAssumptions for this kata are:\n```\nThe sequence argument will always contain 5 values equal to f(0) - f(4).\nThe function will always be in the format \"nx +/- m\", 'x +/- m', 'nx', 'x' or 'm'\nIf a non-linear sequence simply return 'Non-linear sequence' for javascript, ruby, and python. For C#, throw an ArgumentException.\n```\n\"\"\"", "inputs": [[[1, 2, 4, 7, 11]], [[0, 1, 2, 3, 100000]], [[0, 1, 2, 100000, 4]], [[0, 1, 100000, 3, 4]], [[0, 100000, 2, 3, 4]]], "outputs": [["Non-linear sequence"], ["Non-linear sequence"], ["Non-linear sequence"], ["Non-linear sequence"], ["Non-linear sequence"]], "starter_code": "from typing import List\nfrom typing import Union\ndef get_function(sequence: List[int]) -> Union[str, Callable[[int], int]]:", "canonical_solution": "def get_function(sequence):\n    slope = sequence[1] - sequence[0]\n    for x in range(1, 5):\n        if sequence[x] - sequence[x - 1] != slope:\n            return 'Non-linear sequence'\n    return lambda a: slope * a + sequence[0]", "entry_point": "get_function", "task_id": "TACO_lite/1087", "input_output_examples": "[[[[0, 1, 2, 3, 4]], [[0, 3, 6, 9, 12]], [[1, 4, 7, 10, 13]]], [[5], [30], [61]]]", "llm_generated_inputs": {"deepseek-v3": "[[[0, 1, 2, 3, 4]], [[0, 3, 6, 9, 12]], [[1, 4, 7, 10, 13]], [[2, 4, 6, 8, 10]], [[5, 10, 15, 20, 25]], [[0, 0, 0, 0, 0]], [[1, 1, 1, 1, 1]], [[1, 2, 3, 4, 6]], [[1, 3, 5, 7, 10]], [[1, 2, 4, 8, 16]]]", "qwen2.5-coder-32b-instruct": "[[[0, 1, 2, 3, 4]], [[0, 3, 6, 9, 12]], [[1, 4, 7, 10, 13]], [[1, 1, 1, 1, 1]], [[0, 0, 0, 0, 0]], [[1, 2, 4, 8, 16]], [[5, 10, 15, 20, 25]], [[3, 6, 9, 12, 15]], [[2, 4, 6, 8, 10]], [[0, 2, 4, 6, 8]], [[1, 0, -1, -2, -3]], [[0, 1, 4, 9, 16]], [[1, 3, 5, 7, 9]], [[2, 5, 8, 11, 14]], [[1, 3, 6, 10, 15]]]"}}
{"requirement": "from typing import List\n\n\ndef merge_arrays(a: List[int], b: List[int]) -> List[int]:\n\"\"\"Write a function that merges two sorted arrays into a single one. The arrays only contain integers. Also, the final outcome must be sorted and not have any duplicate.\n\"\"\"", "inputs": [[[1, 3, 5], [2, 4, 6]], [[2, 4, 8], [2, 4, 6]], [[1, 2, 3], []], [[], []]], "outputs": [[[1, 2, 3, 4, 5, 6]], [[2, 4, 6, 8]], [[1, 2, 3]], [[]]], "starter_code": "from typing import List\ndef merge_arrays(a: List[int], b: List[int]) -> List[int]:", "canonical_solution": "def merge_arrays(a, b):\n    return sorted(set(a + b))", "entry_point": "merge_arrays", "task_id": "TACO_lite/1097", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 3, 5], [2, 4, 6]], [[1, 2, 3], [1, 2, 3]], [[], [1, 2, 3]], [[1, 2, 3], []], [[], []], [[1, 3, 5, 7], [2, 4, 6, 8]], [[1, 1, 2, 2], [2, 2, 3, 3]], [[10, 20, 30], [5, 15, 25]], [[-5, 0, 5], [-3, 3]], [[1, 1, 1], [1, 1, 1]]]", "qwen2.5-coder-32b-instruct": "[[[1, 3, 5], [2, 4, 6]], [[1, 2, 3], [3, 4, 5]], [[], [1, 2, 3]], [[1, 2, 3], []], [[], []], [[1, 1, 1], [1, 1, 1]], [[1, 2, 3], [4, 5, 6]], [[10, 20, 30], [5, 15, 25, 35]]]"}}
{"requirement": "def nickname_generator(name: str) -> str:\n\"\"\"Nickname Generator\n\nWrite a function, `nicknameGenerator` that takes a string name as an argument and returns the first 3 or 4 letters as a nickname.\n\nIf the 3rd letter is a consonant, return the first 3 letters.\n\nIf the 3rd letter is a vowel, return the first 4 letters. \n\nIf the string is less than 4 characters, return \"Error: Name too short\".\n\n**Notes:**\n\n- Vowels are \"aeiou\", so discount the letter \"y\".\n- Input will always be a string.\n- Input will always have the first letter capitalised and the rest lowercase (e.g. Sam).\n- The input can be modified\n\"\"\"", "inputs": [["Jimmy"], ["Samantha"], ["Sam"], ["Kayne"], ["Melissa"], ["James"], ["Gregory"], ["Jeannie"], ["Kimberly"], ["Timothy"], ["Dani"], ["Saamy"], ["Saemy"], ["Saimy"], ["Saomy"], ["Saumy"], ["Boyna"], ["Kiyna"], ["Sayma"], ["Ni"], ["Jam"], ["Suv"]], "outputs": [["Jim"], ["Sam"], ["Error: Name too short"], ["Kay"], ["Mel"], ["Jam"], ["Greg"], ["Jean"], ["Kim"], ["Tim"], ["Dan"], ["Saam"], ["Saem"], ["Saim"], ["Saom"], ["Saum"], ["Boy"], ["Kiy"], ["Say"], ["Error: Name too short"], ["Error: Name too short"], ["Error: Name too short"]], "starter_code": "def nickname_generator(name: str) -> str:", "canonical_solution": "def nickname_generator(name):\n    return 'Error: Name too short' if len(name) < 4 else name[:3 + (name[2] in 'aeiuo')]", "entry_point": "nickname_generator", "task_id": "TACO_lite/1099", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['Sam'], ['Samantha'], ['Alex'], ['Olivia'], ['Amy'], ['Jo'], ['Eve'], ['Ian'], ['Uma'], ['A'], ['Bo'], ['Cate'], ['Diana'], ['Ethan'], ['Fiona'], ['Greg'], ['Hannah'], ['Ivy'], ['Jake'], ['Katie']]", "qwen2.5-coder-32b-instruct": "[['Sam'], ['Alex'], ['Bob'], ['Amanda'], ['Eve'], ['Ian'], ['Ioana'], ['Joe'], ['Uma'], ['Al'], ['Jo'], ['I'], ['AEIO']]"}}
{"requirement": "from typing import List\n\n\ndef shortest_time(n: int, m: int, speeds: List[int]) -> int:\n\"\"\"# Task\n\nJohn is a programmer. He treasures his time very much. He lives on the `n` floor of a building. Every morning he will go downstairs as quickly as possible to begin his great work today.\n\nThere are two ways he goes downstairs: walking or taking the elevator.\n\nWhen John uses the elevator, he will go through the following steps:\n```\n1. Waiting the elevator from m floor to n floor;\n2. Waiting the elevator open the door and go in;\n3. Waiting the elevator close the door;\n4. Waiting the elevator down to 1 floor;\n5. Waiting the elevator open the door and go out;\n(the time of go in/go out the elevator will be ignored)\n```\n\nGiven the following arguments:\n```\nn: An integer. The floor of John(1-based).\nm: An integer. The floor of the elevator(1-based).\nspeeds: An array of integer. It contains four integer [a,b,c,d]\n        a: The seconds required when the elevator rises or falls 1 floor\n        b: The seconds required when the elevator open the door\n        c: The seconds required when the elevator close the door\n        d: The seconds required when John walks to n-1 floor\n```\n\nPlease help John to calculate the shortest time to go downstairs.\n\n\n\n\n# Example\n\nFor `n = 5, m = 6 and speeds = [1,2,3,10]`, the output should be `12`.\n\nJohn go downstairs by using the elevator:\n\n`1 + 2 + 3 + 4 + 2 = 12`\n\nFor `n = 1, m = 6 and speeds = [1,2,3,10]`, the output should be `0`.\n\nJohn is already at 1 floor, so the output is `0`.\n\nFor `n = 5, m = 4 and speeds = [2,3,4,5]`, the output should be `20`.\n\nJohn go downstairs by walking:\n\n`5 x 4 = 20`\n\"\"\"", "inputs": [[5, 6, [1, 2, 3, 10]], [1, 6, [1, 2, 3, 10]], [5, 5, [1, 2, 3, 10]], [2, 2, [1, 2, 3, 10]], [2, 2, [2, 3, 4, 10]], [5, 4, [1, 2, 3, 10]], [5, 4, [2, 3, 4, 5]], [1, 6, [0, 0, 0, 0]], [1, 6, [0, 2, 0, 0]], [1, 6, [20, 0, 10, 0]]], "outputs": [[12], [0], [11], [8], [10], [12], [20], [0], [0], [0]], "starter_code": "from typing import List\ndef shortest_time(n: int, m: int, speeds: List[int]) -> int:", "canonical_solution": "def shortest_time(n, m, speeds):\n    lift, open, close, walk = speeds\n    return min(abs(m - n) * lift + open + close + (n - 1) * lift + open, (n - 1) * walk)", "entry_point": "shortest_time", "task_id": "TACO_lite/1101", "input_output_examples": "[[[5, 6, [1, 2, 3, 10]], [1, 6, [1, 2, 3, 10]], [5, 4, [2, 3, 4, 5]]], [[12], [0], [20]]]", "llm_generated_inputs": {"deepseek-v3": "[[5, 6, [1, 2, 3, 10]], [1, 6, [1, 2, 3, 10]], [5, 4, [2, 3, 4, 5]], [10, 1, [1, 1, 1, 1]], [10, 10, [1, 2, 3, 4]], [2, 5, [5, 5, 5, 5]], [3, 3, [1, 1, 1, 1]], [4, 2, [2, 2, 2, 2]], [7, 7, [3, 3, 3, 3]], [6, 1, [1, 2, 3, 4]]]", "qwen2.5-coder-32b-instruct": "[[5, 6, [1, 2, 3, 10]], [1, 6, [1, 2, 3, 10]], [5, 4, [2, 3, 4, 5]], [10, 10, [1, 1, 1, 1]], [1, 1, [10, 10, 10, 10]], [2, 1, [1, 1, 1, 1]], [2, 3, [1, 1, 1, 1]], [100, 50, [1, 1, 1, 100]], [100, 150, [1, 1, 1, 100]], [5, 5, [10, 5, 5, 2]]]"}}
{"requirement": "def divisible_count(x: int, y: int, k: int) -> int:\n\"\"\"Complete the function that takes 3 numbers `x, y and k` (where `x ≤ y`), and returns the number of integers within the range `[x..y]` (both ends included) that are divisible by `k`.\n\nMore scientifically:  `{ i : x ≤ i ≤ y, i mod k = 0 }`\n\n\n## Example\n\nGiven ```x = 6, y = 11, k = 2``` the function should return `3`, because there are three numbers divisible by `2` between `6` and `11`: `6, 8, 10`\n\n- **Note**: The test cases are very large. You will need a O(log n) solution or better to pass. (A constant time solution is possible.)\n\"\"\"", "inputs": [[6, 11, 2], [11, 345, 17], [0, 1, 7], [20, 20, 2], [20, 20, 8], [19, 20, 2], [0, 10, 1], [11, 14, 2], [101, 9999999999999999999999999999999999999999999, 11], [1005, 9999999999999999999999999999999999999999999, 109]], "outputs": [[3], [20], [1], [1], [0], [1], [11], [2], [909090909090909090909090909090909090909081], [91743119266055045871559633027522935779807]], "starter_code": "def divisible_count(x: int, y: int, k: int) -> int:", "canonical_solution": "def divisible_count(x, y, k):\n    return y // k - (x - 1) // k", "entry_point": "divisible_count", "task_id": "TACO_lite/1104", "input_output_examples": "[[[6, 11, 2]], [[3]]]", "llm_generated_inputs": {"deepseek-v3": "[[6, 11, 2], [1, 10, 3], [10, 10, 5], [10, 10, 3], [0, 0, 1], [1, 100, 1], [1, 100, 101], [100, 200, 50], [100, 200, 201], [-10, 10, 5], [-10, 10, 7], [1, 1000000, 1000], [1, 1000000, 1000001]]", "qwen2.5-coder-32b-instruct": "[[6, 11, 2], [1, 10, 1], [5, 5, 5], [0, 0, 1], [10, 10, 2], [1, 100, 10], [10, 100, 3], [100, 200, 50], [1, 1000000, 1], [1000000, 1000000, 1000000], [1, 1000000, 1000000], [10, 20, 0], [-10, 10, 2], [-20, -10, 2], [-20, 20, 4]]"}}
{"requirement": "def pattern(n: int) -> str:\n\"\"\"## Task:\nYou have to write a function `pattern` which returns the following Pattern(See Pattern & Examples) upto `n` number of rows. \n\n* Note:`Returning` the pattern is not the same as `Printing` the pattern.\n\n#### Rules/Note:\n* If `n < 1` then it should return \"\" i.e. empty string.\n* There are `no whitespaces` in the pattern.\n\n### Pattern: \n\n    1\n    22\n    333\n    ....\n    .....\n    nnnnnn\n    \n### Examples:\n\n+ pattern(5):\n\n      1\n      22\n      333\n      4444\n      55555\n      \n* pattern(11):  \n\n      1\n      22\n      333\n      4444\n      55555\n      666666\n      7777777\n      88888888\n      999999999\n      10101010101010101010\n      1111111111111111111111\n\n```if-not:cfml\n* Hint: Use \\n in string to jump to next line\n```\n```if:cfml\n* Hint: Use Chr(10) in string to jump to next line\n```\n[List of all my katas]('http://www.codewars.com/users/curious_db97/authored')\n\"\"\"", "inputs": [[1], [2], [5], [0], [-25]], "outputs": [["1"], ["1\n22"], ["1\n22\n333\n4444\n55555"], [""], [""]], "starter_code": "def pattern(n: int) -> str:", "canonical_solution": "def pattern(n):\n    return '\\n'.join([x * str(x) for x in range(1, n + 1)])", "entry_point": "pattern", "task_id": "TACO_lite/1111", "input_output_examples": "[[[5], [11]], [['1\\n22\\n333\\n4444\\n55555'], ['1\\n22\\n333\\n4444\\n55555\\n666666\\n7777777\\n88888888\\n999999999\\n10101010101010101010\\n1111111111111111111111']]]", "llm_generated_inputs": {"deepseek-v3": "[[5], [11], [1], [0], [-1], [2], [10]]", "qwen2.5-coder-32b-instruct": "[[1], [5], [11], [0], [-5], [20]]"}}
{"requirement": "from typing import List\n\n\ndef highest_rank(arr: List[int]) -> int:\n\"\"\"Complete the method which returns the number which is most frequent in the given input array. If there is a tie for most frequent number, return the largest number among them.\n\nNote: no empty arrays will be given.\n\n\n## Examples\n\n```\n[12, 10, 8, 12, 7, 6, 4, 10, 12]              -->  12\n[12, 10, 8, 12, 7, 6, 4, 10, 12, 10]          -->  12\n[12, 10, 8, 8, 3, 3, 3, 3, 2, 4, 10, 12, 10]  -->   3\n```\n\"\"\"", "inputs": [[[12, 10, 8, 12, 7, 6, 4, 10, 12]], [[12, 10, 8, 12, 7, 6, 4, 10, 10]], [[12, 10, 8, 12, 7, 6, 4, 10, 12, 10]], [[12, 10, 8, 8, 3, 3, 3, 3, 2, 4, 10, 12, 10]], [[1, 2, 3]], [[1, 1, 2, 3]], [[1, 1, 2, 2, 3]]], "outputs": [[12], [10], [12], [3], [3], [1], [2]], "starter_code": "from typing import List\ndef highest_rank(arr: List[int]) -> int:", "canonical_solution": "from collections import Counter\n\ndef highest_rank(arr):\n    if arr:\n        c = Counter(arr)\n        m = max(c.values())\n        return max((k for k, v in c.items() if v == m))", "entry_point": "highest_rank", "task_id": "TACO_lite/1116", "input_output_examples": "[[[[12, 10, 8, 12, 7, 6, 4, 10, 12]], [[12, 10, 8, 12, 7, 6, 4, 10, 12, 10]], [[12, 10, 8, 8, 3, 3, 3, 3, 2, 4, 10, 12, 10]]], [[12], [12], [3]]]", "llm_generated_inputs": {"deepseek-v3": "[[[12, 10, 8, 12, 7, 6, 4, 10, 12]], [[12, 10, 8, 12, 7, 6, 4, 10, 12, 10]], [[12, 10, 8, 8, 3, 3, 3, 3, 2, 4, 10, 12, 10]], [[1, 1, 2, 2]], [[5, 5, 5, 5, 5]], [[10, 20, 30, 40, 50]], [[7, 7, 7, 8, 8, 8, 9, 9, 9]], [[1, 2, 3, 4, 5, 5, 4, 3, 2, 1]], [[0, 0, 1, 1, 1, 2, 2, 2, 2]], [[100, 100, 200, 200, 200, 300, 300, 300, 300]]]", "qwen2.5-coder-32b-instruct": "[[[12, 10, 8, 12, 7, 6, 4, 10, 12]], [[12, 10, 8, 12, 7, 6, 4, 10, 12, 10]], [[12, 10, 8, 8, 3, 3, 3, 3, 2, 4, 10, 12, 10]], [[1, 1, 2, 2, 3, 3]], [[5, 5, 5, 1, 1, 1, 2, 2]], [[7]], [[9, 9, 8, 8, 7, 7, 6, 6, 5, 5]], [[10, 20, 20, 10, 30, 30, 30, 20]], [[100, 200, 300, 300, 200, 100, 300]]]"}}
{"requirement": "def spoonerize(words: str) -> str:\n\"\"\"A spoonerism is a spoken phrase in which the first letters of two of the words are swapped around, often with amusing results.\n\nIn its most basic form a spoonerism is a two word phrase in which only the first letters of each word are swapped:\n\n```\"not picking\" --> \"pot nicking\"```\n\nYour task is to create a function that takes a string of two words, separated by a space: ```words``` and returns a spoonerism of those words in a string, as in the above example.\n\nNOTE: All input strings will contain only two words.  Spoonerisms can be more complex.  For example, three-word phrases in which the first letters of the first and last words are swapped: ```\"pack of lies\" --> \"lack of pies\"``` or more than one letter from a word is swapped: ```\"flat battery --> \"bat flattery\"```\n\n\nYou are NOT expected to account for these, or any other nuances involved in spoonerisms.\n\nOnce you have completed this kata, a slightly more challenging take on the idea can be found here: http://www.codewars.com/kata/56dbed3a13c2f61ae3000bcd\n\"\"\"", "inputs": [["not picking"], ["wedding bells"], ["jelly beans"], ["pop corn"]], "outputs": [["pot nicking"], ["bedding wells"], ["belly jeans"], ["cop porn"]], "starter_code": "def spoonerize(words: str) -> str:", "canonical_solution": "def spoonerize(words):\n    a, b = words.split()\n    return '{}{} {}{}'.format(b[0], a[1:], a[0], b[1:])", "entry_point": "spoonerize", "task_id": "TACO_lite/1117", "input_output_examples": "[[['not picking'], ['pack of lies'], ['flat battery']], [['pot nicking'], ['lack of pies'], ['bat flattery']]]", "llm_generated_inputs": {"deepseek-v3": "[['not picking'], ['flat battery'], ['pack of lies'], ['hello world'], ['quick brown'], ['a b'], ['the cat'], ['big house'], ['zebra crossing'], ['empty string']]", "qwen2.5-coder-32b-instruct": "[['not picking'], ['hello world'], ['python programming'], ['spoon erize'], ['a bc'], ['xy z'], ['same same'], ['empty string'], ['one two'], ['red blue']]"}}
{"requirement": "from typing import List\n\n\ndef merge_arrays(arr1: List[int], arr2: List[int]) -> List[int]:\n\"\"\"You are given two sorted arrays that contain only integers. Your task is to find a way to merge them into a single one, sorted in **ascending order**. Complete the function `mergeArrays(arr1, arr2)`, where `arr1` and `arr2` are the original sorted arrays.\n\nYou don't need to worry about validation, since `arr1` and `arr2` must be arrays with 0 or more Integers. If both `arr1` and `arr2` are empty, then just return an empty array.\n\n**Note:** `arr1` and `arr2` may be sorted in different orders. Also `arr1` and `arr2` may have same integers. Remove duplicated in the returned result.\n\n## Examples\n\nHappy coding!\n\"\"\"", "inputs": [[[1, 2, 3, 4], [5, 6, 7, 8]], [[10, 8, 6, 4, 2], [9, 7, 5, 3, 1]], [[-20, 35, 36, 37, 39, 40], [-10, -5, 0, 6, 7, 8, 9, 10, 25, 38, 50, 62]], [[5, 6, 7, 8, 9, 10], [20, 18, 15, 14, 13, 12, 11, 4, 3, 2]], [[45, 30, 20, 15, 12, 5], [9, 10, 18, 25, 35, 50]], [[-8, -3, -2, 4, 5, 6, 7, 15, 42, 90, 134], [216, 102, 74, 32, 8, 2, 0, -9, -13]], [[-100, -27, -8, 5, 23, 56, 124, 325], [-34, -27, 6, 12, 25, 56, 213, 325, 601]], [[18, 7, 2, 0, -22, -46, -103, -293], [-300, -293, -46, -31, -5, 0, 18, 19, 74, 231]], [[105, 73, -4, -73, -201], [-201, -73, -4, 73, 105]]], "outputs": [[[1, 2, 3, 4, 5, 6, 7, 8]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[-20, -10, -5, 0, 6, 7, 8, 9, 10, 25, 35, 36, 37, 38, 39, 40, 50, 62]], [[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 20]], [[5, 9, 10, 12, 15, 18, 20, 25, 30, 35, 45, 50]], [[-13, -9, -8, -3, -2, 0, 2, 4, 5, 6, 7, 8, 15, 32, 42, 74, 90, 102, 134, 216]], [[-100, -34, -27, -8, 5, 6, 12, 23, 25, 56, 124, 213, 325, 601]], [[-300, -293, -103, -46, -31, -22, -5, 0, 2, 7, 18, 19, 74, 231]], [[-201, -73, -4, 73, 105]]], "starter_code": "from typing import List\ndef merge_arrays(arr1: List[int], arr2: List[int]) -> List[int]:", "canonical_solution": "def merge_arrays(arr1, arr2):\n    return sorted(set(arr1 + arr2))", "entry_point": "merge_arrays", "task_id": "TACO_lite/1118", "input_output_examples": "[[[[1, 3, 5], [2, 4, 6]], [[1, 2, 3], [4, 5, 6]], [[], [1, 2, 3]], [[5, 6, 7], []], [[], []], [[1, 1, 2, 2], [1, 1, 3, 3]]], [[[1, 2, 3, 4, 5, 6]], [[1, 2, 3, 4, 5, 6]], [[1, 2, 3]], [[5, 6, 7]], [[]], [[1, 2, 3]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 3, 5], [2, 4, 6]], [[1, 2, 3], [1, 2, 3]], [[], [1, 2, 3]], [[1, 2, 3], []], [[], []], [[5, 10, 15], [10, 20, 30]], [[1, 3, 5], [6, 4, 2]], [[10, 20, 30], [5, 15, 25]], [[1, 1, 1], [2, 2, 2]], [[1, 3, 5], [1, 3, 5]]]", "qwen2.5-coder-32b-instruct": "[[[1, 3, 5], [2, 4, 6]], [[1, 2, 3], [3, 4, 5]], [[], []], [[1, 2, 3], []], [[], [1, 2, 3]], [[5, 4, 3], [6, 7, 8]], [[10, 20, 30], [5, 15, 25, 35]], [[1, 1, 1], [1, 1, 1]], [[1, 2, 2, 3], [2, 3, 4, 4]], [[-1, 0, 1], [-2, -1, 0]]]"}}
{"requirement": "def combs_non_empty_boxes(n: int, k: int) -> int:\n\"\"\"You have a set of four (4) balls labeled with different numbers: ball_1 (1), ball_2 (2), ball_3 (3) and ball(4) and we have 3 equal boxes for distribute them. The possible combinations of the balls, without having empty boxes, are:\n\n```\n (1)            (2)        (3)(4)     \n______        ______       _______ \n    \n```\n\n```\n (1)           (2)(4)        (3)\n______         ______      ______\n  \n```\n\n```\n(1)(4)           (2)         (3)\n______          ______      ______\n\n```\n\n```\n  (1)           (2)(3)       (4)\n_______         _______     ______\n\n```\n\n```\n(1)(3)            (2)        (4)\n_______         _______     ______\n```\n\n```\n(1)(2)            (3)        (4)\n_______         _______     ______\n```\nWe have a total of **6** combinations.\n\nThink how many combinations you will have with two boxes instead of three. You will obtain **7** combinations.\n\nObviously, the four balls in only box will give only one possible combination (the four balls in the unique box). Another particular case is the four balls in four boxes having again one possible combination(Each box having one ball).\n\nWhat will be the reasonable result for a set of n elements with no boxes?\n\nThink to create a function that may calculate the amount of these combinations of a set of ```n``` elements in ```k``` boxes.\n\nYou do no not have to check the inputs type that will be always valid integers.\n\nThe code should detect the cases when ```k > n```, returning \"It cannot be possible!\". \n\nFeatures of the random tests:\n```\n1 <= k <= n <= 800\n```\nRuby version will be published soon.\n\"\"\"", "inputs": [[4, 3], [4, 2], [4, 4], [4, 1], [4, 0], [4, 5], [20, 8]], "outputs": [[6], [7], [1], [1], [0], ["It cannot be possible!"], [15170932662679]], "starter_code": "def combs_non_empty_boxes(n: int, k: int) -> int:", "canonical_solution": "from math import factorial as fact\n\ndef combs_non_empty_boxes(n, k):\n    if k < 0 or k > n:\n        return 'It cannot be possible!'\n    return sum(([1, -1][i % 2] * (k - i) ** n * fact(k) // (fact(k - i) * fact(i)) for i in range(k + 1))) // fact(k)", "entry_point": "combs_non_empty_boxes", "task_id": "TACO_lite/1120", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[4, 3], [4, 2], [4, 1], [4, 4], [0, 0], [5, 3], [3, 5], [1, 1], [10, 5], [800, 800]]", "qwen2.5-coder-32b-instruct": "[[4, 3], [4, 2], [4, 4], [4, 1], [5, 3], [5, 5], [5, 1], [800, 800], [800, 1], [800, 400], [3, 4], [1, 1], [2, 3]]"}}
{"requirement": "from typing import List\n\n\ndef match_arrays(v: List[int], r: List[int]) -> int:\n\"\"\"You have two arrays in this kata, every array contain only unique elements. Your task is to calculate number of elements in first array which also are in second array.\n\"\"\"", "inputs": [[["Perl", "Closure", "JavaScript"], ["Go", "C++", "Erlang"]], [["Erlang", "JavaScript"], ["Go", "C++", "Python"]], [[true, 3, 9, 11, 15], [true, 3, 11]]], "outputs": [[0], [0], [3]], "starter_code": "from typing import List\ndef match_arrays(v: List[int], r: List[int]) -> int:", "canonical_solution": "def match_arrays(v, r):\n    return sum((x in r for x in v))\nverbose = False", "entry_point": "match_arrays", "task_id": "TACO_lite/1122", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3], [2, 3, 4]], [[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [1, 2, 3]], [[], [1, 2, 3]], [[1, 2, 3], []], [[1, 1, 2, 3], [2, 3, 4]], [[1, 2, 3], [2, 2, 3, 4]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3], [2, 3, 4]], [[5, 6, 7], [8, 9, 10]], [[10, 20, 30], [10, 20, 30]], [[], [1, 2, 3]], [[1, 2, 3], []], [[], []], [[1, 2, 3], [4, 5, 6, 1]], [[100, 200, 300], [300, 400, 500]], [[1, 3, 5, 7], [2, 4, 6, 8]]]"}}
{"requirement": "def interpreter(tape: str, array: str) -> str:\n\"\"\"# Task:\nThis kata asks you to make a custom esolang interpreter for the language [MiniBitMove](https://esolangs.org/wiki/MiniBitMove). MiniBitMove has only two commands and operates on a array of bits. It works like this:\n\n- `1`: Flip the bit at the current cell\n- `0`: Move selector by 1\n\nIt takes two inputs, the program and the bits in needs to operate on. The program returns the modified bits. The program stops when selector reaches the end of the array. Otherwise the program repeats itself. **Note: This means that if a program does not have any zeros it is an infinite loop**\n\nExample of a program that flips all bits in an array:\n```\nCode: 10\nBits: 11001001001010\nResult: 00110110110101\n```\n\nAfter you're done, feel free to make translations and discuss this kata.\n\"\"\"", "inputs": [["10", "1100101"], ["100", "1111111111"], ["110", "1010"], ["0", "100010001"], ["101010", "111"]], "outputs": [["0011010"], ["0101010101"], ["1010"], ["100010001"], ["000"]], "starter_code": "def interpreter(tape: str, array: str) -> str:", "canonical_solution": "from itertools import cycle\n\ndef interpreter(tape, array):\n    idx, result = (0, list(map(int, array)))\n    for cmd in cycle(map(int, tape)):\n        if idx == len(array):\n            break\n        if cmd:\n            result[idx] = 1 - result[idx]\n        else:\n            idx += 1\n    return ''.join(map(str, result))", "entry_point": "interpreter", "task_id": "TACO_lite/1138", "input_output_examples": "[[['10', '11001001001010']], [['00110110110101']]]", "llm_generated_inputs": {"deepseek-v3": "[['10', '11001001001010'], ['100', '10101010101010'], ['111', '11001001001010'], ['', '11001001001010'], ['10', ''], ['0', '11001001001010'], ['110', '11001001001010']]", "qwen2.5-coder-32b-instruct": "[['10', '11001001001010'], ['1', '1111'], ['0', '11001001001010'], ['101', '11001001001010'], ['', '11001001001010'], ['10', ''], ['10', '1'], ['10', '0'], ['11', '11001001001010'], ['00', '11001001001010']]"}}
{"requirement": "def string_color(string: str) -> str:\n\"\"\"# Do names have colors?\n\n*Now they do.*\n\nMake a function that takes in a name (Any string two chars or longer really, but the name is the idea) and use the ascii values of it's substrings to produce the hex value of its color! Here is how it's going to work:\n\n* The first two hexadecimal digits are the *SUM* of the value of characters (modulo 256).\n* The second two are the *PRODUCT* of all the characters (again, modulo 256, which is one more than `FF` in hexadecimal).\n* The last two are the *ABSOLUTE VALUE of the DIFFERENCE* between the first letter, and the sum of every other letter. (I think you get the idea with the modulo thing).\n\nFor example `\"Jack\"` returns `\"79CAE5\"`, which is... **baby blue!**\n```\n\"Jack\"  #  \"J\" = 74, \"a\" = 97, \"c\" = 99, \"k\" = 107\n\n74 + 97 + 99 + 107 = 377                   -->  mod 256 = 121  -->  hex: 79\n74 * 97 * 99 * 107 = 76036554              -->  mod 256 = 202  -->  hex: CA\n74 - (97 + 99 + 107) = -229  --> abs: 229  -->  mod 256 = 229  -->  hex: E5\n```\n\nNOTE: The function should return `None/nil` when the input is less than two chars.\n\"\"\"", "inputs": [["A"], [""], ["John Doe"], ["CodeWars"]], "outputs": [[null], [null], ["C70033"], ["182892"]], "starter_code": "def string_color(string: str) -> str:", "canonical_solution": "from operator import sub, mul\nfrom functools import reduce\n\ndef string_color(string):\n    if len(string) < 2:\n        return None\n    r = sum(map(ord, list(string))) % 256\n    g = reduce(mul, list(map(ord, list(string)))) % 256\n    b = abs(reduce(sub, list(map(ord, list(string))))) % 256\n    return '{:02X}{:02X}{:02X}'.format(r, g, b)", "entry_point": "string_color", "task_id": "TACO_lite/1139", "input_output_examples": "[[['Jack']], [['79CAE5']]]", "llm_generated_inputs": {"deepseek-v3": "[['Jack'], ['Alice'], ['Bob'], ['Eve'], ['A'], ['123'], ['HelloWorld'], [''], ['Zz'], ['Python']]", "qwen2.5-coder-32b-instruct": "[['Jack'], ['Anna'], ['Zebra'], ['xy'], ['a'], [''], ['A'], ['AB'], ['abcde'], ['12345'], ['!@#$%'], ['LongerString'], ['Spaces In']]"}}
{"requirement": "def make_readable(s: int) -> str:\n\"\"\"Write a function, which takes a non-negative integer (seconds) as input and returns the time in a human-readable format (`HH:MM:SS`)\n\n* `HH` = hours, padded to 2 digits, range: 00 - 99\n* `MM` = minutes, padded to 2 digits, range: 00 - 59\n* `SS` = seconds, padded to 2 digits, range: 00 - 59\n\nThe maximum time never exceeds 359999 (`99:59:59`)\n\nYou can find some examples in the test fixtures.\n\"\"\"", "inputs": [[0], [59], [60], [3599], [3600], [86399], [86400], [359999]], "outputs": [["00:00:00"], ["00:00:59"], ["00:01:00"], ["00:59:59"], ["01:00:00"], ["23:59:59"], ["24:00:00"], ["99:59:59"]], "starter_code": "def make_readable(s: int) -> str:", "canonical_solution": "def make_readable(s):\n    return '{:02}:{:02}:{:02}'.format(s // 3600, s // 60 % 60, s % 60)", "entry_point": "make_readable", "task_id": "TACO_lite/1141", "input_output_examples": "[[[0], [59], [60], [3599], [3600], [86399], [86400], [359999]], [['00:00:00'], ['00:00:59'], ['00:01:00'], ['00:59:59'], ['01:00:00'], ['23:59:59'], ['24:00:00'], ['99:59:59']]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [5], [60], [3661], [86399], [359999], [59], [3600], [7200], [12345]]", "qwen2.5-coder-32b-instruct": "[[0], [5], [60], [3599], [3600], [86399], [359999], [59], [12345], [604800]]"}}
{"requirement": "def find(n: int) -> int:\n\"\"\"Your task is to write function ```findSum```.\n\nUpto and including ```n```, this function will return the sum of all multiples of 3 and 5.\n\nFor example:\n\n```findSum(5)``` should return 8 (3 + 5)\n\n```findSum(10)``` should return 33 (3 + 5 + 6 + 9 + 10)\n\"\"\"", "inputs": [[5], [10], [100], [1000]], "outputs": [[8], [33], [2418], [234168]], "starter_code": "def find(n: int) -> int:", "canonical_solution": "def find(n):\n    return sum((e for e in range(1, n + 1) if e % 3 == 0 or e % 5 == 0))", "entry_point": "find", "task_id": "TACO_lite/1143", "input_output_examples": "[[[5], [10]], [[8], [33]]]", "llm_generated_inputs": {"deepseek-v3": "[[5], [10], [0], [1], [15], [100], [-5]]", "qwen2.5-coder-32b-instruct": "[[5], [10], [0], [-5], [1], [15], [100]]"}}
{"requirement": "def convert_temp(temp: float, from_scale: str, to_scale: str) -> int:\n\"\"\"Write a function ```convert_temp(temp, from_scale, to_scale)``` converting temperature from one scale to another. \n\n\nReturn converted temp value. \n\nRound converted temp value to an integer(!).\n\nReading: http://en.wikipedia.org/wiki/Conversion_of_units_of_temperature\n\n```\npossible scale inputs:\n    \"C\"  for Celsius\n    \"F\"  for Fahrenheit\n    \"K\"  for Kelvin\n    \"R\"  for Rankine\n    \"De\" for Delisle\n    \"N\"  for Newton\n    \"Re\" for Réaumur\n    \"Ro\" for Rømer\n```\n\n```temp``` is a number, ```from_scale``` and ```to_scale``` are strings. \n\n```python\nconvert_temp(   100, \"C\",  \"F\") # => 212\nconvert_temp(    40, \"Re\", \"C\") # => 50\nconvert_temp(    60, \"De\", \"F\") # => 140\nconvert_temp(373.15, \"K\",  \"N\") # => 33\nconvert_temp(   666, \"K\",  \"K\") # => 666\n```\n\"\"\"", "inputs": [[100, "C", "F"], [-30, "De", "K"], [40, "Re", "C"], [60, "De", "F"], [373.15, "K", "N"], [666, "K", "K"], [60, "C", "F"], [60, "De", "C"], [128.25, "Ro", "C"], [-273.15, "C", "R"], [0, "K", "R"]], "outputs": [[212], [393], [50], [140], [33], [666], [140], [60], [230], [0], [0]], "starter_code": "def convert_temp(temp: float, from_scale: str, to_scale: str) -> int:", "canonical_solution": "TO_KELVIN = {'C': (1, 273.15), 'F': (5.0 / 9, 459.67 * 5.0 / 9), 'R': (5.0 / 9, 0), 'De': (-2.0 / 3, 373.15), 'N': (100.0 / 33, 273.15), 'Re': (5.0 / 4, 273.15), 'Ro': (40.0 / 21, -7.5 * 40 / 21 + 273.15)}\n\ndef convert_temp(temp, from_scale, to_scale):\n    if from_scale == to_scale:\n        return temp\n    if from_scale != 'K':\n        a, b = TO_KELVIN[from_scale]\n        temp = a * temp + b\n        if to_scale == 'K':\n            return int(round(temp))\n    a, b = TO_KELVIN[to_scale]\n    return int(round((temp - b) / a))", "entry_point": "convert_temp", "task_id": "TACO_lite/1144", "input_output_examples": "[[[100, 'C', 'F'], [40, 'Re', 'C'], [60, 'De', 'F'], [373.15, 'K', 'N'], [666, 'K', 'K']], [[212], [50], [140], [33], [666]]]", "llm_generated_inputs": {"deepseek-v3": "[[100, 'C', 'F'], [40, 'Re', 'C'], [60, 'De', 'F'], [373.15, 'K', 'N'], [666, 'K', 'K'], [0, 'C', 'K'], [32, 'F', 'C'], [273.15, 'K', 'C'], [100, 'C', 'R'], [0, 'C', 'De'], [33, 'N', 'C'], [80, 'Re', 'F'], [60, 'Ro', 'C'], [-40, 'C', 'F'], [212, 'F', 'C'], [0, 'C', 'Re'], [100, 'C', 'Ro'], [0, 'K', 'F'], [100, 'F', 'R'], [100, 'De', 'K']]", "qwen2.5-coder-32b-instruct": "[[100, 'C', 'F'], [40, 'Re', 'C'], [60, 'De', 'F'], [373.15, 'K', 'N'], [666, 'K', 'K'], [0, 'C', 'K'], [32, 'F', 'C'], [273.15, 'K', 'C'], [491.67, 'R', 'F'], [150, 'De', 'C'], [0, 'N', 'C'], [0, 'Re', 'C'], [0, 'Ro', 'C'], [-40, 'C', 'F'], [-40, 'F', 'C'], [100, 'C', 'De'], [212, 'F', 'De'], [0, 'C', 'Re'], [0, 'C', 'Ro'], [100, 'C', 'N'], [33, 'N', 'C']]"}}
{"requirement": "def unscramble_eggs(word: str) -> str:\n\"\"\"Unscramble the eggs.\n\nThe string given to your function has had an \"egg\" inserted directly after each consonant.  You need to return the string before it became eggcoded.\n\n## Example\n\nKata is supposed to be for beginners to practice regular expressions, so commenting would be appreciated.\n\"\"\"", "inputs": [["ceggodegge heggeregge"], ["FeggUNegg KeggATeggA"], ["egegggegg"], ["Heggeleggleggo weggoreggleggdegg"], ["seggceggreggameggbeggleggedegg egegggeggsegg"], ["egegggeggyegg beggreggeadegg"], ["veggegeggyeggmeggitegge onegg teggoaseggtegg"]], "outputs": [["code here"], ["FUN KATA"], ["egg"], ["Hello world"], ["scrambled eggs"], ["eggy bread"], ["vegymite on toast"]], "starter_code": "def unscramble_eggs(word: str) -> str:", "canonical_solution": "def unscramble_eggs(word):\n    return word.replace('egg', '')", "entry_point": "unscramble_eggs", "task_id": "TACO_lite/1145", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['Heggelloleggo'], ['Aeegggg'], ['BeggCeggD'], ['EeggIeggOeggU'], ['FeggGeggHeggJeggKeggL'], ['Meggegggeggg'], [''], ['Egg'], ['Xeggyeggeggz']]", "qwen2.5-coder-32b-instruct": "[['Kegatkeg'], ['Rgegegg'], ['eggegg'], ['Hgeelloge'], ['Pegpegegnpege'], ['egg'], [''], ['a'], ['aeiou'], ['bcdfghjklmnpqrstvwxyz']]"}}
{"requirement": "from typing import List\n\n\ndef sort_emotions(arr: List[str], order: bool) -> List[str]:\n\"\"\"## Emotional Sort ( ︶︿︶)\n\nYou'll have a function called \"**sortEmotions**\" that will return an array of **emotions** sorted. It has two parameters, the first parameter called \"**arr**\" will expect an array of **emotions** where an **emotion** will be one of the following:\n\n- **:D** -> Super Happy\n- **:)** -> Happy\n- **:|** -> Normal\n- **:(** -> Sad\n- **T\\_T** -> Super Sad\n\nExample of the array:``[ 'T_T', ':D', ':|', ':)', ':(' ]``\n\nAnd the second parameter is called \"**order**\", if this parameter is **true** then the order of the emotions will be descending (from **Super Happy** to **Super Sad**) if it's **false** then it will be ascending (from **Super Sad** to **Super Happy**)\n\nExample if **order** is true with the above array: ``[ ':D', ':)', ':|', ':(', 'T_T' ]``\n\n- Super Happy -> Happy -> Normal -> Sad -> Super Sad\n\nIf **order** is false: ``[ 'T_T', ':(', ':|', ':)', ':D' ]``\n\n- Super Sad -> Sad -> Normal -> Happy -> Super Happy\n\nExample:\n```\narr = [':D', ':|', ':)', ':(', ':D']\nsortEmotions(arr, true) // [ ':D', ':D', ':)', ':|', ':(' ]\nsortEmotions(arr, false) // [ ':(', ':|', ':)', ':D', ':D' ]\n\n```\n\n**More in test cases!**\n\nNotes:\n- The array could be empty, in that case return the same empty array ¯\\\\\\_( ツ )\\_/¯\n- All **emotions** will be valid\n\n## Enjoy! (づ｡◕‿‿◕｡)づ\n\"\"\"", "inputs": [[[":D", "T_T", ":D", ":("], true], [["T_T", ":D", ":(", ":("], true], [[":)", "T_T", ":)", ":D", ":D"], true], [[":D", "T_T", ":D", ":("], false], [["T_T", ":D", ":(", ":("], false], [[":)", "T_T", ":)", ":D", ":D"], false], [[], false], [[], true]], "outputs": [[[":D", ":D", ":(", "T_T"]], [[":D", ":(", ":(", "T_T"]], [[":D", ":D", ":)", ":)", "T_T"]], [["T_T", ":(", ":D", ":D"]], [["T_T", ":(", ":(", ":D"]], [["T_T", ":)", ":)", ":D", ":D"]], [[]], [[]]], "starter_code": "from typing import List\ndef sort_emotions(arr: List[str], order: bool) -> List[str]:", "canonical_solution": "def sort_emotions(arr, order):\n    return sorted(arr, key=[':D', ':)', ':|', ':(', 'T_T'].index, reverse=not order)", "entry_point": "sort_emotions", "task_id": "TACO_lite/1150", "input_output_examples": "[[[[':D', ':|', ':)', ':(', ':D'], True], [[':D', ':|', ':)', ':(', ':D'], False]], [[[':D', ':D', ':)', ':|', ':(']], [[':(', ':|', ':)', ':D', ':D']]]]", "llm_generated_inputs": {"deepseek-v3": "[[[':D', ':)', ':|', ':(', 'T_T'], True], [[':D', ':)', ':|', ':(', 'T_T'], False], [[':D', ':|', ':)', ':(', ':D'], True], [[':D', ':|', ':)', ':(', ':D'], False], [['T_T', ':(', ':|', ':)', ':D'], True], [['T_T', ':(', ':|', ':)', ':D'], False], [[':|', ':|', ':|'], True], [[':|', ':|', ':|'], False], [[], True], [[], False], [[':D'], True], [[':D'], False], [['T_T', 'T_T', ':(', ':(', ':|', ':|', ':)', ':)', ':D', ':D'], True], [['T_T', 'T_T', ':(', ':(', ':|', ':|', ':)', ':)', ':D', ':D'], False]]", "qwen2.5-coder-32b-instruct": "[[[':D', ':|', ':)', ':(', 'T_T'], True], [[':D', ':|', ':)', ':(', 'T_T'], False], [[':D', ':D', ':)', ':|', ':('], True], [[':D', ':D', ':)', ':|', ':('], False], [['T_T', ':(', ':|', ':)', ':D'], True], [['T_T', ':(', ':|', ':)', ':D'], False], [[':)'], True], [[':)'], False], [[], True], [[], False]]"}}
{"requirement": "def get_column_title(n: int) -> str:\n\"\"\"Hi there! \nYou have to implement the \n\n`String get_column_title(int num) // syntax depends on programming language`\n\nfunction that takes an integer number (index of the Excel column) and returns the string represents the title of this column.\n\n#Intro\nIn the MS Excel lines are numbered by decimals, columns - by sets of letters.\n\nFor example, the first column has the title \"A\", second column - \"B\", 26th - \"Z\", 27th - \"AA\". \n\n\"BA\"(53) comes after \"AZ\"(52), \"AAA\" comes after \"ZZ\".\n\n\n\n\nExcel? Columns? More details [here](https://en.wikipedia.org/wiki/Microsoft_Excel)\n\n#Input\nIt takes only one argument - column decimal index number.\nArgument `num` is a natural number.\n\n#Output\nOutput is the upper-case string represents the title of column. It contains the English letters: A..Z\n\n#Errors\nFor cases `num < 1` your function should throw/raise `IndexError`. In case of non-integer argument you should throw/raise `TypeError`.\n\nIn Java, you should throw `Exceptions`.\n\nNothing should be returned in Haskell.\n\n#Examples\nPython, Ruby:\n```\n>>> get_column_title(52)\n\"AZ\"\n>>> get_column_title(1337)\n\"AYK\"\n>>> get_column_title(432778)\n\"XPEH\"\n>>> get_column_title()\nTypeError:\n>>> get_column_title(\"123\")\nTypeError:\n>>> get_column_title(0)\nIndexError:\n```\nJS, Java:\n```\n>>> getColumnTitle(52)\n\"AZ\"\n>>> getColumnTitle(1337)\n\"AYK\"\n>>> getColumnTitle(432778)\n\"XPEH\"\n>>> getColumnTitle()\nTypeError:\n>>> getColumnTitle(\"123\")\nTypeError:\n>>> getColumnTitle(0)\nIndexError:\n```\n\n#Hint\nThe difference between the 26-digits notation and Excel columns numeration that in the first system, after \"Z\" there are \"BA\", \"BB\", ..., while in the Excel columns scale there is a range of 26 elements: AA, AB, ... , AZ between Z and BA. \n\nIt is as if in the decimal notation was the following order: 0, 1, 2, .., 9, 00, 01, 02, .., 09, 10, 11, .., 19, 20..29..99, 000, 001 and so on.\n\n#Also\nThe task is really sapid and hard. If you're stuck - write to the discussion board, there are many smart people willing to help.\n\"\"\"", "inputs": [[1], [26], [52], [53], [702]], "outputs": [["A"], ["Z"], ["AZ"], ["BA"], ["ZZ"]], "starter_code": "def get_column_title(n: int) -> str:", "canonical_solution": "from string import ascii_uppercase as u\n\ndef get_column_title(n):\n    assert isinstance(n, int) and n > 0\n    col = []\n    while n:\n        n, r = divmod(n - 1, 26)\n        col.append(u[r])\n    return ''.join(reversed(col))", "entry_point": "get_column_title", "task_id": "TACO_lite/1152", "input_output_examples": "[[[52], [1337], [432778], [], ['123'], [0]], [['AZ'], ['AYK'], ['XPEH'], ['TypeError'], ['TypeError'], ['IndexError']]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [26], [27], [52], [53], [702], [703], [1337], [432778], [0], [-1], ['123'], [3.14]]", "qwen2.5-coder-32b-instruct": "[[1], [26], [27], [52], [53], [1337], [432778], [702], [703], [18278], [0], [-1], [0.5], ['123'], ['A'], [None]]"}}
{"requirement": "from typing import List\n\n\ndef total_primes(a: int, b: int) -> List[int]:\n\"\"\"*This is the advanced version of the [Total Primes](https://www.codewars.com/kata/total-primes/) kata.*\n\n---\n\nThe number `23` is the smallest prime that can be \"cut\" into **multiple** primes: `2, 3`. Another such prime is `6173`, which can be cut into `61, 73` or `617, 3` or `61, 7, 3` (all primes). A third one is `557` which can be sliced into `5, 5, 7`. Let's call these numbers **total primes**.\n\nNotes:\n* one-digit primes are excluded by definition;\n* leading zeros are also excluded: e.g. splitting `307` into `3, 07` is **not** valid\n\n\n## Task\n\nComplete the function that takes a range `[a..b]` (both limits included) and returns the total primes within that range (`a ≤ total primes ≤ b`).\n\nThe tests go up to 10^(6).\n~~~if:python\nFor your convenience, a list of primes up to 10^(6) is preloaded, called `PRIMES`.\n~~~\n\n\n## Examples\n```\n(0, 100)  ==>  [23, 37, 53, 73]\n\n(500, 600) ==> [523, 541, 547, 557, 571, 577, 593]\n```\nHappy coding!\n\n---\n\n## My other katas\n\nIf you enjoyed this kata then please try [my other katas](https://www.codewars.com/collections/katas-created-by-anter69)! :-)\n\n#### *Translations are welcome!*\n\"\"\"", "inputs": [[10, 100], [500, 600], [23, 37], [0, 20], [113, 197], [199, 299], [1, 2273], [11703, 13330], [312232, 312311], [967335, 967871]], "outputs": [[[23, 37, 53, 73]], [[523, 541, 547, 557, 571, 577, 593]], [[23, 37]], [[]], [[113, 137, 173, 193, 197]], [[211, 223, 227, 229, 233, 241, 257, 271, 277, 283, 293]], [[23, 37, 53, 73, 113, 137, 173, 193, 197, 211, 223, 227, 229, 233, 241, 257, 271, 277, 283, 293, 311, 313, 317, 331, 337, 347, 353, 359, 367, 373, 379, 383, 389, 397, 433, 523, 541, 547, 557, 571, 577, 593, 613, 617, 673, 677, 719, 727, 733, 743, 757, 761, 773, 797, 977, 1013, 1033, 1093, 1097, 1117, 1123, 1129, 1153, 1171, 1277, 1319, 1327, 1361, 1367, 1373, 1493, 1637, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1789, 1913, 1931, 1933, 1973, 1979, 1993, 1997, 2113, 2131, 2137, 2179, 2213, 2237, 2239, 2243, 2251, 2267, 2269, 2273]], [[11717, 11719, 11731, 11743, 11777, 11779, 11783, 11789, 11813, 11821, 11827, 11833, 11839, 11863, 11887, 11897, 11933, 11941, 11953, 11971, 12373, 12377, 12497, 12713, 12743, 12757, 12893, 12917, 12973, 13033, 13037, 13103, 13109, 13127, 13147, 13151, 13159, 13163, 13171, 13177, 13183, 13217, 13219, 13229, 13241, 13259, 13267, 13297, 13313, 13327]], [[312233, 312241, 312251, 312253, 312269, 312281, 312283, 312289, 312311]], [[967349, 967361, 967397, 967493, 967511, 967529, 967567, 967583, 967607, 967693, 967709, 967739, 967751, 967753, 967787, 967823, 967859]]], "starter_code": "from typing import List\ndef total_primes(a: int, b: int) -> List[int]:", "canonical_solution": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nprimes = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in primes\n    for n in accumulate(s[:-1]):\n        if n in primes:\n            m = s[len(n):]\n            if m in primes or all_primes(m):\n                return True\n\ndef total_primes(a, b):\n    return [int(a) for a in map(str, range(max(10, a), b + 1)) if a in primes and all_primes(a)]", "entry_point": "total_primes", "task_id": "TACO_lite/1156", "input_output_examples": "[[[0, 100], [500, 600]], [[[23, 37, 53, 73]], [[523, 541, 547, 557, 571, 577, 593]]]]", "llm_generated_inputs": {"deepseek-v3": "[[0, 100], [500, 600], [10, 20], [100, 200], [23, 23], [6173, 6173], [557, 557], [1000, 1001], [9999, 10000], [100000, 1000000]]", "qwen2.5-coder-32b-instruct": "[[0, 100], [500, 600], [100, 1000], [1000, 10000], [10000, 100000], [100000, 1000000], [10, 20], [1, 1], [2, 2], [800, 850], [999, 1001], [9999, 10001], [99999, 100001], [999999, 1000001]]"}}
{"requirement": "def fouriest(i: int) -> str:\n\"\"\"# Fourier transformations are hard. Fouriest transformations are harder.\n\nThis Kata is based on the SMBC Comic on fourier transformations.\n\nA fourier transformation on a number is one that converts the number to a base in which it has more `4`s ( `10` in base `6` is `14`, which has `1` four as opposed to none, hence, fourier in base `6` ).\n\nA number's fouriest transformation converts it to the base in which it has the most `4`s.  \nFor example: `35353` is the fouriest in base `6`: `431401`.\n\nThis kata requires you to create a method `fouriest` that takes a number and makes it the fouriest, telling us in which base this happened, as follows:\n\n```python\nfouriest(number) -> \"{number} is the fouriest ({fouriest_representation}) in base {base}\"\n```\n\n## Important notes\n\n* For this kata we don't care about digits greater than `9` ( only `0` to `9` ), so we will represent all digits greater than `9` as `'x'`: `10` in base `11` is `'x'`, `119` in base `20` is `'5x'`, `118` in base `20` is also `'5x'`\n\n* When a number has several fouriest representations, we want the one with the LOWEST base\n\n```if:haskell,javascript\n* Numbers below `9` will not be tested\n```\n\n```if:javascript\n* A `BigNumber` library has been provided; documentation is [here](https://mikemcl.github.io/bignumber.js/)\n```\n\n## Examples\n\n```python\n\"30 is the fouriest (42) in base 7\"\n\"15 is the fouriest (14) in base 11\"\n```\n\"\"\"", "inputs": [[30], [15], [9999], [35353], [100], [1000000243], [142042158218941532125212890], [2679388715912901287113185885289513476], [640614569414659959863091616350016384446719891887887380], [2579111107964987025047536361483312385374008248282655401675211033926782006920415224913494809688581314878892733564]], "outputs": [["30 is the fouriest (42) in base 7"], ["15 is the fouriest (14) in base 11"], ["9999 is the fouriest (304444) in base 5"], ["35353 is the fouriest (431401) in base 6"], ["100 is the fouriest (244) in base 6"], ["1000000243 is the fouriest (24x44) in base 149"], ["142042158218941532125212890 is the fouriest (14340031300334233041101030243023303030) in base 5"], ["2679388715912901287113185885289513476 is the fouriest (444444444444444444) in base 128"], ["640614569414659959863091616350016384446719891887887380 is the fouriest (44444444444444444444444444444444) in base 52"], ["2579111107964987025047536361483312385374008248282655401675211033926782006920415224913494809688581314878892733564 is the fouriest (4444444444444444444444444444444444444444444444) in base 290"]], "starter_code": "def fouriest(i: int) -> str:", "canonical_solution": "def transform(num, base):\n    digits = []\n    while num > 0:\n        num, remainder = divmod(num, base)\n        digits.append(remainder if remainder < 10 else 'x')\n    return digits\n\ndef fouriest(i):\n    max_fours, base, best = (0, 5, [None, None])\n    while i >= base ** max_fours:\n        digits = transform(i, base)\n        if digits.count(4) > max_fours:\n            max_fours = digits.count(4)\n            best = (base, ''.join(map(str, digits[::-1])))\n        base += 1\n    base, transformed = best\n    return '%s is the fouriest (%s) in base %s' % (i, transformed, base)", "entry_point": "fouriest", "task_id": "TACO_lite/1159", "input_output_examples": "[[[30], [15]], [['30 is the fouriest (42) in base 7'], ['15 is the fouriest (14) in base 11']]]", "llm_generated_inputs": {"deepseek-v3": "[[9], [10], [15], [30], [35353], [100], [1234], [5000], [7], [0]]", "qwen2.5-coder-32b-instruct": "[[30], [15], [35353], [9], [10], [100], [1000], [9999], [123456], [4444]]"}}
{"requirement": "from typing import List\n\n\ndef compound_array(a: List[int], b: List[int]) -> List[int]:\n\"\"\"You have to create a method \"compoundArray\" which should take as input two int arrays of different length and return one int array with numbers of both arrays shuffled one by one. \n```Example: \nInput - {1,2,3,4,5,6} and {9,8,7,6} \nOutput - {1,9,2,8,3,7,4,6,5,6}\n```\n\"\"\"", "inputs": [[[], []], [[], []], [[], []], [[], []], [[], []], [[], []], [[], []]], "outputs": [[[1, 9, 2, 8, 3, 7, 4, 6, 5, 6]], [[0, 9, 1, 8, 2, 7, 6, 5, 4, 3, 2, 1, 0]], [[11, 21, 12, 22, 23, 24]], [[2147483647, 9, 2147483646, 2147483645, 2147483644, 2147483643]], [[214, 215, 216, 217, 218]], [[214, 215, 219, 217, 218]], [[]]], "starter_code": "from typing import List\ndef compound_array(a: List[int], b: List[int]) -> List[int]:", "canonical_solution": "def compound_array(a, b):\n    x = []\n    while a or b:\n        if a:\n            x.append(a.pop(0))\n        if b:\n            x.append(b.pop(0))\n    return x", "entry_point": "compound_array", "task_id": "TACO_lite/1163", "input_output_examples": "[[[[1, 2, 3, 4, 5, 6], [9, 8, 7, 6]]], [[[1, 9, 2, 8, 3, 7, 4, 6, 5, 6]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 5, 6], [9, 8, 7, 6]], [[1, 2, 3], [4, 5]], [[1], [2, 3, 4, 5]], [[], [1, 2, 3]], [[1, 2, 3], []], [[10, 20], [30, 40, 50, 60]], [[5, 10, 15], [20, 25]], [[100, 200, 300, 400], [500]], [[0, 0, 0], [1, 1, 1]], [[-1, -2, -3], [1, 2, 3]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 4, 5, 6], [9, 8, 7, 6]], [[1, 3, 5], [2, 4, 6, 8, 10]], [[], [1, 2, 3]], [[1, 2, 3], []], [[1], [9]], [[1, 2], [3]], [[1, 2, 3], [4, 5]]]"}}
{"requirement": "from typing import List\n\n\ndef jumping(arr: List[int], n: int) -> int:\n\"\"\"# Task\n\nYou are a lonely frog. \n\nYou live on an integer array.\n\nThe meaning of your life is to jump and jump..\n\nNow, here comes your new task. \n\nYou are given an integer array `arr` and a positive integer `n`.\n\nYou will jump following the rules below:\n\n- Your initial position at `arr[0]`. arr[0] will always be `0`.\n\n- You will jump according to the number of current position(arr[i])\n  - That is, if the number is a positive integer, let say 3, you will jump forward 3 steps; If the number is a negative integer, let say -3, you will jump backward 3 steps; If the number is 0, you will stay here for a little rest.\n\n- The number of current position(arr[i]) will increase decrease by 1 after each turn (jump or stay).\n  - That is, if the number of current position(arr[i]) is greater than or equal to `n`, the number will decrease 1; if the number at current position(arr[i]) is less than `n`, the number will increase 1.\n\nYou will stop jumping when you reach the exit (your position greater than or equal to arr.length). Please tell me, at the moment, how many elements in `arr` are equal to `n`?\n\n# Note\n\n- `3 <= arr.length <= 1000`, `1 <= n <= 9`\n\n- Frog will never jump backward out of `arr`.\n\n# Example\n\nFor `arr = [0,3,0,1,-3], n = 3`, the output should be `2`.\n```\n Let us jump softly:\n \n [0,3,0,1,-3]\n  ^--You are here, current number is 0, you stay here. \n     currect number 0 < n, so 0 -> 1\n [1,3,0,1,-3]\n  ^--You are here, current number is 1, you will jump forward \n     to position 1. current number 1 < n, so 1 -> 2\n [2,3,0,1,-3]\n    ^--You are here, current number is 3, you will jump forward \n       to position 4. current number 3 >= n, so 3 -> 2\n [2,2,0,1,-3]\n           ^--You are here, current number is -3, you will jump backward\n              to position 1. current number -3 < n, so -3 -> -2\n [2,2,0,1,-2]\n    ^--You are here, current number is 2, you will jump forward \n       to position 3. current number 2 < n, so 2 -> 3\n [2,3,0,1,-2]\n        ^--You are here, current number is 1, you will jump forward\n           to position 3. current number 1 < n, so 1 -> 2\n [2,3,0,2,-2]\n           ^--You are here, current number is -2, you will jump backward\n              to position 2. current number -2 < n, so -2 -> -1\n [2,3,0,2,-1]\n      ^--You are here, current number is 0, you stay here.\n         current number 0 < n, so 0 -> 1\n [2,3,1,2,-1]\n      ^--You are here, current number is 1, you will jump forward \n         to position 3. current number 1 < n, so 1 -> 2\n [2,3,2,2,-1]\n        ^--You are here, current number is 2, you will jump forward to position 5.\n     current number 2 < n, so 2 -> 3\n [2,3,2,3,-1] exit\n               ^--You are here, you reach to the exit.\n \n At the moment, arr[1] and arr[3] are equal to n.\n So, the output should be 2.\n```\nFor `arr = [0,-1,-2,-3,-4], n = 4`, the output should be `2`.\n```\n Let's us jump fast ;-)\n \n [0,-1,-2,-3,-4]\n  ^\n [1,-1,-2,-3,-4]\n  ^\n [2,-1,-2,-3,-4]\n     ^\n [2, 0,-2,-3,-4]\n  ^\n [3, 0,-2,-3,-4]\n        ^\n [3, 0,-1,-3,-4]\n  ^\n [4, 0,-1,-3,-4]\n           ^\n [4, 0,-1,-2,-4]\n  ^\n [3, 0,-1,-2,-4]\n              ^\n [3, 0,-1,-2,-3]\n  ^\n [4, 0,-1,-2,-3]\n           ^\n [4, 0,-1,-1,-3]\n     ^\n [4, 1,-1,-1,-3]\n     ^\n [4, 2,-1,-1,-3]\n        ^\n [4, 2, 0,-1,-3]\n     ^\n [4, 3, 0,-1,-3]\n           ^\n [4, 3, 0, 0,-3]\n        ^\n [4, 3, 1, 0,-3]\n        ^\n [4, 3, 2, 0,-3]\n           ^\n [4, 3, 2, 1,-3]\n           ^\n [4, 3, 2, 2,-3]\n              ^\n [4, 3, 2, 2,-2]\n     ^\n [4, 4, 2, 2,-2]\n              ^\n [4, 4, 2, 2,-1]\n        ^\n [4, 4, 3, 2,-1]\n              ^\n [4, 4, 3, 2, 0]\n           ^\n [4, 4, 3, 3, 0] exit\n                 ^\n At the moment, arr[0] and arr[1] are equal to n.\n So, the output should be 2.\n```\n\nFor `arr = [0,-1,-2,-3,-4], n = 3`, the output should be `0`.\n```\n Let's jump fast ;-)\n \n [0,-1,-2,-3,-4]\n  ^\n [1,-1,-2,-3,-4]\n  ^\n [2,-1,-2,-3,-4]\n     ^\n [2, 0,-2,-3,-4]\n  ^\n [3, 0,-2,-3,-4]\n        ^\n [3, 0,-1,-3,-4]\n  ^\n [2, 0,-1,-3,-4]\n           ^\n [2, 0,-1,-2,-4]\n  ^\n [3, 0,-1,-2,-4]\n        ^\n [3, 0, 0,-2,-4]\n     ^\n [3, 1, 0,-2,-4]\n     ^\n [3, 2, 0,-2,-4]\n        ^\n [3, 2, 1,-2,-4]\n        ^\n [3, 2, 2,-2,-4]\n           ^\n [3, 2, 2,-1,-4]\n     ^\n [3, 3, 2,-1,-4]\n           ^\n [3, 3, 2, 0,-4]\n        ^\n [3, 3, 3, 0,-4]\n              ^\n [3, 3, 3, 0,-3]\n  ^\n [2, 3, 3, 0,-3]\n           ^\n [2, 3, 3, 1,-3]\n           ^\n [2, 3, 3, 2,-3]\n              ^\n [2, 3, 3, 2,-2]\n     ^\n [2, 2, 3, 2,-2]\n              ^\n [2, 2, 3, 2,-1]\n        ^\n [2, 2, 2, 2,-1] exit\n                  ^\n \n At the moment, there is no element equal to n.\n So, the output should be 0.\n```\n\n[Base idea taken from [here](https://adventofcode.com/2017/day/5)]\n\"\"\"", "inputs": [[[2, 3, 2, 3, -1], 3], [[4, 4, 3, 3, 0], 4], [[2, 2, 2, 2, -1], 3], [[2, 2, 2, 1, -1], 2], [[0, 0, 0, 0, 0], 1]], "outputs": [[2], [2], [0], [3], [0]], "starter_code": "from typing import List\ndef jumping(arr: List[int], n: int) -> int:", "canonical_solution": "def jumping(arr, n):\n    i = 0\n    while i < len(arr):\n        x = arr[i]\n        arr[i] += 1 if x < n else -1\n        i += x\n    return arr.count(n)", "entry_point": "jumping", "task_id": "TACO_lite/1166", "input_output_examples": "[[[[0, 3, 0, 1, -3], 3], [[0, -1, -2, -3, -4], 4], [[0, -1, -2, -3, -4], 3]], [[2], [2], [0]]]", "llm_generated_inputs": {"deepseek-v3": "[[[0, 3, 0, 1, -3], 3], [[0, -1, -2, -3, -4], 4], [[0, -1, -2, -3, -4], 3], [[0, 1, 2, 3, 4], 2], [[0, 0, 0, 0, 0], 1], [[0, 5, -5, 5, -5, 5], 5], [[0, -1, -1, -1, -1], 1], [[0, 9, -9, 9, -9, 9], 9], [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1], [[0, 2, -2, 2, -2, 2, -2, 2, -2, 2], 2]]", "qwen2.5-coder-32b-instruct": "[[[0, 3, 0, 1, -3], 3], [[0, -1, -2, -3, -4], 4], [[0, -1, -2, -3, -4], 3], [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1], [[0, 2, 2, 2, 2, 2, 2, 2, 2, 2], 2], [[0, 9, 8, 7, 6, 5, 4, 3, 2, 1], 9], [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 5], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 1], [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1], 2], [[0, -1, 1, -1, 1, -1, 1, -1, 1, -1], 1], [[0, 3, 0, 1, -3, 0, 1, -3, 0, 1], 3], [[0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], 2], [[0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], 9]]"}}
{"requirement": "def solve(st: str) -> bool:\n\"\"\"Consider the string `\"adfa\"` and the following rules: \n```Pearl\na) each character MUST be changed either to the one before or the one after in alphabet. \nb) \"a\" can only be changed to \"b\" and \"z\" to \"y\". \n```\nFrom our string, we get:\n```Pearl\n\"adfa\" -> [\"begb\",\"beeb\",\"bcgb\",\"bceb\"]\nAnother example: \"bd\" -> [\"ae\",\"ac\",\"ce\",\"cc\"]\n--We see that in each example, one of the possibilities is a palindrome.\n```\nI was working on the code for this but I couldn't quite figure it out. So far I have:\n\n```python\ndef solve(st: str) -> bool:\n    return [all(ord(x) - ord(y) in [\"FIX\"] for x, y in zip(st, st[::-1]))][0]\n```\nI'm not sure what three numbers go into the array labelled `[\"FIX\"]`. This is the only thing missing. \n\nYou will be given a lowercase string and your task is to return `True` if at least one of the possiblities is a palindrome or `False` otherwise. You can use your own code or fix mine. \n\nMore examples in test cases. Good luck!\n\"\"\"", "inputs": [["abba"], ["abaazaba"], ["abccba"], ["adfa"], ["ae"], ["abzy"], ["ababbaba"], ["sq"], ["kxbkwgyydkcbtjcosgikfdyhuuprubpwthgflucpyylbofvqxkkvqthmdnywpaunfihvupbwpruwfybdmgeuocltdaidyyewmbzm"]], "outputs": [[true], [false], [true], [true], [false], [false], [true], [true], [true]], "starter_code": "def solve(st: str) -> bool:", "canonical_solution": "def solve(st):\n    return all((True if ord(x) - ord(y) in [-2, 0, 2] else False for x, y in zip(st, st[::-1])))", "entry_point": "solve", "task_id": "TACO_lite/1190", "input_output_examples": "[[['adfa'], ['bd']], [[True], [True]]]", "llm_generated_inputs": {"deepseek-v3": "[['adfa'], ['bd'], ['a'], ['zz'], ['abc'], ['aaa'], ['xyz'], ['abba'], ['abcdcba'], ['zyx']]", "qwen2.5-coder-32b-instruct": "[['adfa'], ['bd'], ['a'], ['z'], ['ab'], ['zy'], ['abcba'], ['racecar'], ['palindrome'], ['zzz'], ['aaa'], ['aabbaa']]"}}
{"requirement": "def truncate_string(s: str, n: int) -> str:\n\"\"\"Truncate the given string (first argument) if it is longer than the given maximum length (second argument). Return the truncated string with a `\"...\"` ending.\n\nNote that inserting the three dots to the end will add to the string length.\n\nHowever, if the given maximum string length num is less than or equal to 3, then the addition of the three dots does not add to the string length in determining the truncated string.\n\n\n## Examples\n```\n('codewars', 9)  ==>  'codewars'\n('codewars', 7)  ==>  'code...'\n('codewars', 2)  ==>  'co...'\n```\n\n[Taken from FCC](https://www.freecodecamp.com/challenges/truncate-a-string)\n\n\n\"\"\"", "inputs": [["pippi", 3], ["Peter Piper picked a peck of pickled peppers", 14], ["A-tisket a-tasket A green and yellow basket", 43], ["A-tisket a-tasket A green and yellow basket", 45], ["A-", 1], ["Chingel loves his Angel so much!!!", 27], ["I like ice-cream.Do you?", 19], ["Seems like you have passed the final test. Congratulations", 53]], "outputs": [["pip..."], ["Peter Piper..."], ["A-tisket a-tasket A green and yellow basket"], ["A-tisket a-tasket A green and yellow basket"], ["A..."], ["Chingel loves his Angel ..."], ["I like ice-cream..."], ["Seems like you have passed the final test. Congrat..."]], "starter_code": "def truncate_string(s: str, n: int) -> str:", "canonical_solution": "def truncate_string(s, n):\n    return s if len(s) <= n else s[:n if n <= 3 else n - 3] + '...'", "entry_point": "truncate_string", "task_id": "TACO_lite/1195", "input_output_examples": "[[['codewars', 9], ['codewars', 7], ['codewars', 2]], [['codewars'], ['code...'], ['co...']]]", "llm_generated_inputs": {"deepseek-v3": "[['codewars', 9], ['codewars', 7], ['codewars', 2], ['hello world', 11], ['hello world', 8], ['hello world', 5], ['short', 10], ['short', 5], ['short', 3], ['a', 1], ['abc', 3], ['abcdef', 6], ['abcdef', 4], ['abcdef', 2], ['', 0], ['', 3], ['long string with spaces', 20], ['long string with spaces', 10], ['long string with spaces', 5], ['long string with spaces', 3]]", "qwen2.5-coder-32b-instruct": "[['codewars', 9], ['codewars', 7], ['codewars', 2], ['a', 1], ['abc', 3], ['abcde', 4], ['hello world', 11], ['hello world', 10], ['truncate', 0], ['truncate', 1], ['truncate', 2], ['truncate', 3], ['short', 5], ['short', 6]]"}}
{"requirement": "def shorten_to_date(long_date: str) -> str:\n\"\"\"You're re-designing a blog and the blog's posts have the following format for showing the date and time a post was made: \n\n*Weekday* *Month* *Day*, *time*\ne.g., \nFriday May 2, 7pm\n\nYou're running out of screen real estate, and on some pages you want to display a shorter format, *Weekday* *Month* *Day* that omits the time.\n\nWrite a function, shortenToDate, that takes the Website date/time in its original string format, and returns the shortened format.\n\nAssume shortenToDate's input will always be a string, e.g. \"Friday May 2, 7pm\". Assume shortenToDate's output will be the shortened string, e.g., \"Friday May 2\".\n\"\"\"", "inputs": [["Monday February 2, 8pm"], ["Tuesday May 29, 8pm"], ["Wed September 1, 3am"], ["Friday May 2, 9am"], ["Tuesday January 29, 10pm"]], "outputs": [["Monday February 2"], ["Tuesday May 29"], ["Wed September 1"], ["Friday May 2"], ["Tuesday January 29"]], "starter_code": "def shorten_to_date(long_date: str) -> str:", "canonical_solution": "def shorten_to_date(long_date):\n    return long_date.split(',')[0]", "entry_point": "shorten_to_date", "task_id": "TACO_lite/1197", "input_output_examples": "[[['Friday May 2, 7pm']], [['Friday May 2']]]", "llm_generated_inputs": {"deepseek-v3": "[['Friday May 2, 7pm'], ['Monday January 1, 12am'], ['Sunday December 31, 11:59pm'], ['Tuesday March 15, 3:30pm'], ['Thursday October 5, 9:15am'], ['Wednesday July 4, 12:00pm'], ['Saturday November 11, 6:45pm'], ['Friday February 29, 8:00pm'], ['Monday April 30, 10:00am'], ['Sunday June 20, 5:30pm']]", "qwen2.5-coder-32b-instruct": "[['Friday May 2, 7pm'], ['Monday January 1, 12am'], ['Saturday December 31, 11:59pm'], ['Sunday June 15, 3pm'], ['Thursday July 4, 8am'], ['Wednesday November 11, 11am'], ['Tuesday February 29, 2pm'], ['Friday March 1, 9pm'], ['Monday April 30, 10pm'], ['Sunday August 8, 5pm'], ['Friday September 19, 6pm'], ['Saturday October 10, 4pm'], ['Sunday November 22, 7pm'], ['Monday December 25, 8pm'], ['Friday May 2, 7:30pm'], ['Monday January 1, 12:05am'], ['Saturday December 31, 11:59:59pm'], ['Sunday June 15, 3:45pm'], ['Thursday July 4, 8:01am'], ['Wednesday November 11, 11:15am'], ['Tuesday February 29, 2:20pm']]"}}
{"requirement": "def istrimorphic(N: int) -> int:\n\"\"\"Given a number N, the task is to check whether the number is Trimorphic number or not. A number is called Trimorphic number if and only if its cube ends in the same digits as the number itself. In other words, number appears at the end of its cube i.e let's say if the number of digits of N is k then the last k digit of the cube should be equal to N only.\nExample 1:\nInput: N = 1\nOutput: 1\nExplaination: 1^{3} = 1. So the cube here is ending with \nthe number.\nExample 2:\nInput: N = 2\nOutput: 0\nExplaination: 2^{3} = 8. The cube is not ending with the \nnumber at it's end.\nExample 3:\nInput: N = 24\nOutput: 1\nExplaination: 24^{3} = 13824. The cube is ending with 24.\nYour Task:\nYou do not need to read input or print anything, Your task is to complete the function istrimorphic() which takes N as input parameter and returns 1 if the number is trimorphic, otherwise, returns 0.\nExpected Time Complexity: O(LogN)\nExpected Auxiliary Space: O(1)\nConstraints:\n1 < N < 10000\n\"\"\"", "inputs": [[1], [2], [24]], "outputs": [[1], [0], [1]], "starter_code": "def istrimorphic(N: int) -> int:", "canonical_solution": "def istrimorphic(N):\n    c = N ** 3\n    t = str(N)\n    s = str(c)\n    if s[-len(t):] == t:\n        return 1\n    else:\n        return 0", "entry_point": "istrimorphic", "task_id": "TACO_lite/1200", "input_output_examples": "[[[1], [2], [24]], [[1], [0], [1]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [24], [5], [25], [99], [376], [10000], [0], [-1]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [24], [25], [76], [376], [625], [9376], [9474], [9999], [10], [100], [1000], [10000], [123], [456], [789]]"}}
{"requirement": "def aa_percentage(seq: str, residues: list = ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']) -> int:\n\"\"\"You are a biologist working on the amino acid  composition of proteins. Every protein consists of a long chain of 20 different amino acids with different properties. \nCurrently, you are collecting data on the percentage, various amino acids make up a protein you are working on. As manually counting the occurences of amino acids takes too long (especially when counting more than one amino acid), you decide to write a program for this task:\n\nWrite a function that takes two arguments,\n 1. A (snippet of a) protein sequence\n 2. A list of amino acid residue codes \n\nand returns the rounded percentage of the protein that the given amino acids make up. \nIf no amino acid list is given, return the percentage of hydrophobic amino acid residues [\"A\", \"I\", \"L\", \"M\", \"F\", \"W\", \"Y\", \"V\"].\n\"\"\"", "inputs": [["MSRSLLLRFLLFLLLLPPLP", ["M"]], ["MSRSLLLRFLLFLLLLPPLP", ["M", "L"]], ["MSRSLLLRFLLFLLLLPPLP", ["F", "S", "L"]], ["MSRSLLLRFLLFLLLLPPLP"], ["RLMADDFFGQTLMAAAAAAQERRR", ["A"]], ["RLMADDFFGQTLMAAAAAAQERRR", ["A", "R", "D"]], ["RLMADDFFGQTLMAAAAAAQERRR"], ["PLPPLPLLEELELRPFFMAAGGTPLAMMGG", ["X"]], ["PLPPLPLLEELELRPFFMAAGGTPLAMMGG", ["P", "L"]], ["PLPPLPLLEELELRPFFMAAGGTPLAMMGG", ["P", "E", "L", "R", "F", "M", "A", "G", "T"]], ["PLPPLPLLEELELRPFFMAAGGTPLAMMGG"]], "outputs": [[5], [55], [70], [65], [29], [54], [54], [0], [43], [100], [50]], "starter_code": "def aa_percentage(seq: str, residues: list = ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']) -> int:", "canonical_solution": "def aa_percentage(seq, residues=['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']):\n    return round(sum((seq.count(r) for r in residues)) / len(seq) * 100)", "entry_point": "aa_percentage", "task_id": "TACO_lite/1203", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['ACDEFGHIKLMNPQRSTVWY', ['A', 'C', 'D']], ['ACDEFGHIKLMNPQRSTVWY', ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']], ['ACDEFGHIKLMNPQRSTVWY', []], ['ACDEFGHIKLMNPQRSTVWY', ['X', 'Y', 'Z']], ['', ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']], ['ACDEFGHIKLMNPQRSTVWY', ['A']], ['ACDEFGHIKLMNPQRSTVWY', ['A', 'A', 'A']], ['ACDEFGHIKLMNPQRSTVWY', ['X']], ['ACDEFGHIKLMNPQRSTVWY', ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']], ['ACDEFGHIKLMNPQRSTVWY', ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V', 'A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']]]", "qwen2.5-coder-32b-instruct": "[['AIMFWYV', ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']], ['ABCDEFG', ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']], ['', ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']], ['AIMFWYV', []], ['AIMFWYV', ['X', 'Y', 'Z']], ['AAAAAAAAAA', ['A']], ['VVVVVVVVVV', ['V']], ['AILMFYW', ['A', 'I', 'L', 'M', 'F', 'W', 'Y']], ['AILMFYW', ['G', 'H', 'K']], ['AILMFYW', ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']]]"}}
{"requirement": "from typing import List\n\n\ndef leaderboard_climb(arr: List[int], kara: List[int]) -> List[int]:\n\"\"\"```if:python \nNote: Python may currently have some performance issues. If you find them, please let me know and provide suggestions to improve the Python version! It's my weakest language... any help is much appreciated :)\n```\n\nArtlessly stolen and adapted from Hackerrank.\n\nKara Danvers is new to CodeWars, and eager to climb up in the ranks. We want to determine Kara's rank as she progresses up the leaderboard. \n\nThis kata uses Dense Ranking, so any identical scores count as the same rank (e.g, a scoreboard of `[100, 97, 97, 90, 82, 80, 72, 72, 60]` corresponds with rankings of `[1, 2, 2, 3, 4, 5, 6, 6, 7]`\n\nYou are given an array, `scores`, of leaderboard scores, descending, and another array, `kara`, representing Kara's Codewars score over time, ascending. Your function should return an array with each item corresponding to the rank of Kara's current score on the leaderboard.\n\n**Note:** This kata's performance requirements are significantly steeper than the Hackerrank version. Some arrays will contain millions of elements; optimize your code so you don't time out. If you're timing out before 200 tests are completed, you've likely got the wrong code complexity. If you're timing out around 274 tests (there are 278), you likely need to make some tweaks to how you're handling the arrays.\n\nExamples:\n\n(For the uninitiated, Kara Danvers is Supergirl. This is important, because Kara thinks and moves so fast that she can complete a kata within microseconds. Naturally, latency being what it is, she's already opened many kata across many, many tabs, and solves them one by one on a special keyboard so she doesn't have to wait hundreds of milliseconds in between solving them. As a result, the only person's rank changing on the leaderboard is Kara's, so we don't have to worry about shifting values of other codewarriors. Thanks, Supergirl.)\n\nGood luck! Please upvote if you enjoyed it :)\n\"\"\"", "inputs": [[[100, 90, 90, 80], [70, 80, 105]], [[982, 490, 339, 180], [180, 250, 721, 2500]], [[1982, 490, 339, 180], [180, 250, 721, 880]], [[1079, 490, 339, 180], [180, 250, 1200, 1980]]], "outputs": [[[4, 3, 1]], [[4, 4, 2, 1]], [[4, 4, 2, 2]], [[4, 4, 1, 1]]], "starter_code": "from typing import List\ndef leaderboard_climb(arr: List[int], kara: List[int]) -> List[int]:", "canonical_solution": "def leaderboard_climb(arr, kara):\n    scores = sorted(set(arr), reverse=True)\n    position = len(scores)\n    ranks = []\n    for checkpoint in kara:\n        while position >= 1 and checkpoint >= scores[position - 1]:\n            position -= 1\n        ranks.append(position + 1)\n    return ranks", "entry_point": "leaderboard_climb", "task_id": "TACO_lite/1204", "input_output_examples": "[[[[100, 97, 97, 90, 82, 80, 72, 72, 60], [85, 88, 95]]], [[[5, 4, 3]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[100, 97, 97, 90, 82, 80, 72, 72, 60], [60, 72, 82, 97]], [[100, 90, 80, 70, 60], [50, 60, 70, 80, 90, 100]], [[100, 90, 90, 80], [85, 90, 95]], [[100, 100, 100], [99, 100, 101]], [[100], [50, 100, 150]], [[100, 90, 80, 70, 60], [70]], [[100, 90, 80, 70, 60], [100]], [[100, 90, 80, 70, 60], [60]], [[100, 90, 80, 70, 60], [61, 71, 81, 91, 101]], [[100, 90, 80, 70, 60], [59, 60, 61]], [[100, 90, 80, 70, 60], [100, 90, 80, 70, 60]], [[100, 90, 80, 70, 60], [60, 70, 80, 90, 100]], [[100, 90, 80, 70, 60], [100, 100, 100]], [[100, 90, 80, 70, 60], [60, 60, 60]], [[100, 90, 80, 70, 60], [70, 70, 70]], [[100, 90, 80, 70, 60], [80, 80, 80]], [[100, 90, 80, 70, 60], [90, 90, 90]], [[100, 90, 80, 70, 60], [100, 100, 100]], [[100, 90, 80, 70, 60], [50, 100]], [[100, 90, 80, 70, 60], [60, 100]]]", "qwen2.5-coder-32b-instruct": "[[[100, 97, 97, 90, 82, 80, 72, 72, 60], [60]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [70]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [97]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [100]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [50, 60, 70, 80, 90, 100]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [101]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [98, 98, 98]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [100, 100, 100]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [59, 58, 57]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [100, 97, 90, 82, 80, 72, 60]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [100, 101, 102]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [100, 100, 100, 100]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [60, 72, 82, 90, 97, 100]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [59, 58, 57, 56, 55]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [98, 99, 100]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [101, 102, 103]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [60, 60, 60, 60]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [100, 100, 100, 100, 100]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [96, 95, 94, 93, 92]], [[100, 97, 97, 90, 82, 80, 72, 72, 60], [73, 74, 75, 76, 77]]]"}}
{"requirement": "from typing import List\n\n\ndef sum_groups(arr: List[int]) -> int:\n\"\"\"# Task\n\nGiven an array of integers, sum consecutive even numbers and consecutive odd numbers. Repeat the process while it can be done and return the length of the final array.\n\n# Example\n\nFor `arr = [2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]`\n \nThe result should be `6`.\n\n```\n[2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]  -->\n         2+2+6       0+2+0     5+5+7+7       3+3+9\n[2, 1,   10,    5,    2,        24,     4,   15   ] -->\n                               2+24+4\n[2, 1,   10,    5,             30,           15   ]\nThe length of final array is 6\n```\n\n# Input/Output\n\n- `[input]` integer array `arr`\n\n  A non-empty array, \n\n  `1 ≤ arr.length ≤ 1000`\n\n  `0 ≤ arr[i] ≤ 1000`\n\n\n- `[output]` an integer\n\n  The length of the final array\n\"\"\"", "inputs": [[[2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]], [[2, 1, 2, 2, 6, 5, 0, 2, 0, 3, 3, 3, 9, 2]], [[2]], [[1, 2]], [[1, 1, 2, 2]]], "outputs": [[6], [5], [1], [2], [1]], "starter_code": "from typing import List\ndef sum_groups(arr: List[int]) -> int:", "canonical_solution": "from itertools import groupby\n\ndef sum_groups(arr):\n    newarr = [sum(j) for i, j in groupby(arr, key=lambda x: x % 2 == 0)]\n    return len(newarr) if newarr == arr else sum_groups(newarr)", "entry_point": "sum_groups", "task_id": "TACO_lite/1213", "input_output_examples": "[[[[2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]]], [[6]]]", "llm_generated_inputs": {"deepseek-v3": "[[[2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]], [[1, 1, 1, 1, 1]], [[2, 2, 2, 2, 2]], [[1, 2, 3, 4, 5]], [[0, 0, 0, 0, 0]], [[1]], [[2]], [[1, 3, 5, 7, 9, 2, 4, 6, 8, 10]], [[10, 10, 10, 1, 1, 1, 2, 2, 2]], [[1000, 1000, 1000, 1000, 1000]]]", "qwen2.5-coder-32b-instruct": "[[[2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]], [[1, 3, 5, 7, 9]], [[2, 4, 6, 8, 10]], [[1, 2, 3, 4, 5, 6]], [[1]], [[2]], [[1, 1, 1, 1, 1, 1]], [[2, 2, 2, 2, 2, 2]], [[1, 2, 1, 2, 1, 2]], [[2, 1, 2, 1, 2, 1]], [[0, 0, 0, 0, 0, 0]], [[1000, 1000, 1000, 1000, 1000, 1000]], [[1, 1000, 1, 1000, 1, 1000]]]"}}
{"requirement": "from typing import List\n\n\ndef ant(grid: List[List[int]], column: int, row: int, n: int, direction: int = 0) -> List[List[int]]:\n\"\"\"[Langton's ant](https://en.wikipedia.org/wiki/Langton%27s_ant) is a two-dimensional Turing machine invented in the late 1980s. The ant starts out on a grid of black and white cells and follows a simple set of rules that has complex emergent behavior.\n\n## Task\n\nComplete the function and return the `n`th iteration of Langton's ant with the given input.\n\n### Parameters:\n\n* `grid` - a two dimensional array of `1`s and `0`s (representing white and black cells respectively)\n* `column` - horizontal position of ant\n* `row` - ant's vertical position\n* `n` - number of iterations\n* `dir` - ant's current direction (0 - north, 1 - east, 2 - south, 3 - west), **should default to 0**\n\n**Note:** parameters `column` and `row` will always be inside the `grid`, and number of generations `n` will never be negative.\n\n## Output\n\nThe state of the `grid` after `n` iterations.\n\n## Rules\n\nThe ant can travel in any of the four cardinal directions at each step it takes. The ant moves according to the rules below:\n\n* At a white square (represented with `1`), turn 90° right, flip the color of the square, and move forward one unit.\n* At a black square (`0`), turn 90° left, flip the color of the square, and move forward one unit.\n\nThe grid has no limits and therefore if the ant moves outside the borders, the grid should be expanded with `0`s, respectively maintaining the rectangle shape.\n\n## Example\n\n```python\nant([[1]], 0, 0, 1, 0)   # should return: [[0, 0]]\n```\n\nInitially facing north (`0`), at the first iteration the ant turns right (because it stands on a white square, `1`), flips the square and moves forward.\n\"\"\"", "inputs": [[[[0]], 0, 0, 1, 0], [[[1]], 0, 0, 1, 0], [[[0]], 0, 0, 3, 0], [[[0]], 0, 0, 1]], "outputs": [[[[0, 0]]], [[[0, 1]]], [[[0, 1], [0, 1]]], [[[0, 0]]]], "starter_code": "from typing import List\ndef ant(grid: List[List[int]], column: int, row: int, n: int, direction: int = 0) -> List[List[int]]:", "canonical_solution": "BLACK = 0\nWHITE = 1\nCARDINALS = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\ndef ant(grid, column, row, n, direction=0):\n    r, c, d = (row, column, direction)\n    for _ in range(n):\n        if grid[r][c] == BLACK:\n            grid[r][c] = WHITE\n            d = (d + 3) % 4\n        else:\n            grid[r][c] = BLACK\n            d = (d + 1) % 4\n        r, c = (r + CARDINALS[d][0], c + CARDINALS[d][1])\n        if r < 0:\n            grid.insert(0, [0] * len(grid[0]))\n            r += 1\n        elif r == len(grid):\n            grid.append([0] * len(grid[0]))\n        elif c < 0:\n            grid = [[0] + row for row in grid]\n            c += 1\n        elif c == len(grid[0]):\n            grid = [row + [0] for row in grid]\n    return grid", "entry_point": "ant", "task_id": "TACO_lite/1220", "input_output_examples": "[[[[[1]], 0, 0, 1, 0]], [[[[0, 0]]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[[1]], 0, 0, 1, 0], [[[0]], 0, 0, 1, 0], [[[1, 0], [0, 1]], 1, 1, 2, 1], [[[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1, 1, 5, 2], [[[0, 0], [0, 0]], 0, 0, 10, 3], [[[1]], 0, 0, 0, 0], [[[1, 0, 1], [0, 1, 0], [1, 0, 1]], 1, 1, 100, 0], [[[1, 1], [1, 1]], 0, 0, 3, 1], [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1, 4, 2], [[[1, 0], [0, 1]], 0, 1, 1, 3]]", "qwen2.5-coder-32b-instruct": "[[[[1]], 0, 0, 1, 0], [[[1]], 0, 0, 2, 0], [[[0]], 0, 0, 1, 0], [[[0]], 0, 0, 2, 0], [[[1, 1], [0, 0]], 0, 0, 3, 0], [[[1, 1], [0, 0]], 1, 1, 4, 2], [[[1, 0], [0, 1]], 0, 1, 5, 1], [[[1, 0], [0, 1]], 1, 0, 6, 3], [[[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1, 1, 10, 0], [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1, 10, 2], [[[1]], 0, 0, 0, 0], [[[1, 0, 1], [0, 1, 0], [1, 0, 1]], 1, 1, 20, 0]]"}}
{"requirement": "def identify_weapon(character: str) -> str:\n\"\"\"The characters of Chima need your help. Their weapons got mixed up! They need you to write a program that accepts the name of a character in Chima then tells which weapon he/she owns.\n\nFor example: for the character `\"Laval\"` your program should return the solution `\"Laval-Shado Valious\"`\n\nYou must complete the following character-weapon pairs:\n\n* Laval-Shado Valious, \n* Cragger-Vengdualize, \n* Lagravis-Blazeprowlor, \n* Crominus-Grandorius, \n* Tormak-Tygafyre, \n* LiElla-Roarburn. \n    \nReturn `\"Not a character\"` for invalid inputs.\n\"\"\"", "inputs": [["Laval"], ["Crominus"], ["Lagravis"], ["Cragger"], ["Tormak"], ["LiElla"], ["G'loona"], ["Stinkin gorillas"], ["qwertyuiopasdfghjklzxcvbnm"]], "outputs": [["Laval-Shado Valious"], ["Crominus-Grandorius"], ["Lagravis-Blazeprowlor"], ["Cragger-Vengdualize"], ["Tormak-Tygafyre"], ["LiElla-Roarburn"], ["Not a character"], ["Not a character"], ["Not a character"]], "starter_code": "def identify_weapon(character: str) -> str:", "canonical_solution": "def identify_weapon(character):\n    tbl = {'Laval': 'Laval-Shado Valious', 'Cragger': 'Cragger-Vengdualize', 'Lagravis': 'Lagravis-Blazeprowlor', 'Crominus': 'Crominus-Grandorius', 'Tormak': 'Tormak-Tygafyre', 'LiElla': 'LiElla-Roarburn'}\n    return tbl.get(character, 'Not a character')", "entry_point": "identify_weapon", "task_id": "TACO_lite/1237", "input_output_examples": "[[['Laval'], ['Cragger'], ['Lagravis'], ['Crominus'], ['Tormak'], ['LiElla'], ['Worriz']], [['Laval-Shado Valious'], ['Cragger-Vengdualize'], ['Lagravis-Blazeprowlor'], ['Crominus-Grandorius'], ['Tormak-Tygafyre'], ['LiElla-Roarburn'], ['Not a character']]]", "llm_generated_inputs": {"deepseek-v3": "[['Laval'], ['Cragger'], ['Lagravis'], ['Crominus'], ['Tormak'], ['LiElla'], ['InvalidCharacter'], [''], ['123'], ['Laval '], [' laval']]", "qwen2.5-coder-32b-instruct": "[['Laval'], ['Cragger'], ['Lagravis'], ['Crominus'], ['Tormak'], ['LiElla'], ['laval'], ['cragger'], ['lagravis'], ['crominus'], ['tormak'], ['liella'], ['Laval-Shado Valious'], ['Cragger-Vengdualize'], ['Lagravis-Blazeprowlor'], ['Crominus-Grandorius'], ['Tormak-Tygafyre'], ['LiElla-Roarburn'], [''], [' '], ['InvalidCharacter'], [None], [12345]]"}}
{"requirement": "def para_to_rect(eqn1: str, eqn2: str) -> str:\n\"\"\"### Task:\n\nYour job is to take a pair of parametric equations, passed in as strings, and convert them into a single rectangular equation by eliminating the parameter. Both parametric halves will represent linear equations of x as a function of time and y as a function of time respectively. \n\nThe format of the final equation must be `Ax + By = C` or `Ax - By = C` where A and B must be positive and A, B, and C are integers. The final equation also needs to have the lowest possible whole coefficients. Omit coefficients equal to one.\n\nThe method is called `para_to_rect` or `EquationsManager.paraToRect` and takes in two strings in the form `x = at +(or -) b` and `y = ct +(or -) d` respectively, where `a` and `c` must be integers, and `b` and `d` must be positive integers. If `a` or `c` is omitted, the coefficient of _t_ is obviously assumed to be 1 (see final case in the example tests). There will NEVER be double signs in the equations inputted (For example: `\"x = -12t + -18\"` and `\"y = -12t - -18\"` won't show up.)\n\n### Examples:\n\n```python\npara_to_rect(\"x = 12t + 18\", \"y = 8t + 7\") => \"2x - 3y = 15\"\n```\n\n> __CALCULATION:__  \n  x = 12t + 18  \n  y = 8t + 7  \n  2x = 24t + 36  \n  3y = 24t + 21  \n  2x - 3y = (24t + 36) - (24t + 21)  \n  2x - 3y = 15  \n\n```python\npara_to_rect(\"x = -12t - 18\", \"y = 8t + 7\") => \"2x + 3y = -15\"\n```\n\n> __CALCULATION:__  \n  x = -12t - 18  \n  y = 8t + 7  \n  2x = -24t - 36  \n  3y = 24t + 21  \n  2x + 3y = (-24t - 36) + (24t + 21)  \n  2x + 3y = -15  \n\n```python\npara_to_rect(\"x = -t + 12\", \"y = 12t - 1\") => \"12x + y = 143\"\n```\n\n> __CALCULATION:__  \n  x = -t + 12  \n  y = 12t - 1  \n  12x = -12t + 144  \n  y   = 12t  - 1  \n  12x + y = 143  \n\nMore examples in the sample test cases.\n\n### Notes:\n\nAs you can see above, sometimes you'll need to add the two parametric equations after multiplying by the necessary values; sometimes you'll need to subtract them – just get rid of the _t_!\n\"\"\"", "inputs": [["x = 12t + 18", "y = 8t + 7"], ["x = -12t + 18", "y = 8t + 7"], ["x = 12t + 18", "y = -8t + 7"], ["x = -12t + 18", "y = -8t + 7"], ["x = -t + 12", "y = 12t - 1"], ["x = -12t - 18", "y = 8t - 7"], ["x = -12t + 18", "y = 8t - 7"], ["x = -18t + 12", "y = 7t - 8"], ["x = 18t + 12", "y = 7t - 8"], ["x = 18t + 12", "y = 7t + 8"], ["x = 2t + 5", "y = 3t + 4"], ["x = -2t + 5", "y = 3t - 4"], ["x = 15t + 2", "y = 20t - 11"], ["x = 15t - 2", "y = -20t - 11"], ["x = 2t - 1", "y = 2t - 1"], ["x = -2t + 1", "y = 2t + 1"], ["x = 16t + 16", "y = 8t - 12"], ["x = 16t - 16", "y = -8t - 12"], ["x = -t + 12", "y = 2t - 3"], ["x = t + 12", "y = 2t - 3"], ["x = 6t - 99", "y = 10t - 79"], ["x = -139t + 119", "y = -89t + 12"], ["x = -93t + 104", "y = t - 77"], ["x = 148t + 3", "y = -11t + 63"], ["x = -t + 96", "y = 29t - 143"], ["x = -144t - 118", "y = -142t + 65"], ["x = -71t + 37", "y = -131t - 124"], ["x = -t + 109", "y = -54t - 118"], ["x = -73t - 59", "y = t + 132"], ["x = -90t - 42", "y = -37t + 149"], ["x = -69t - 7", "y = 117t - 59"], ["x = 14t - 145", "y = 3t + 19"], ["x = 84t + 84", "y = -36t - 41"], ["x = 138t - 139", "y = -47t - 134"], ["x = -113t - 116", "y = -72t - 124"], ["x = 103t - 106", "y = -81t - 24"], ["x = -14t + 124", "y = t - 44"], ["x = 144t - 119", "y = -29t + 69"], ["x = 125t - 4", "y = -t + 50"], ["x = -132t + 142", "y = 75t - 58"]], "outputs": [["2x - 3y = 15"], ["2x + 3y = 57"], ["2x + 3y = 57"], ["2x - 3y = 15"], ["12x + y = 143"], ["2x + 3y = -57"], ["2x + 3y = 15"], ["7x + 18y = -60"], ["7x - 18y = 228"], ["7x - 18y = -60"], ["3x - 2y = 7"], ["3x + 2y = 7"], ["4x - 3y = 41"], ["4x + 3y = -41"], ["x - y = 0"], ["x + y = 2"], ["x - 2y = 40"], ["x + 2y = -40"], ["2x + y = 21"], ["2x - y = 27"], ["5x - 3y = -258"], ["89x - 139y = 8923"], ["x + 93y = -7057"], ["11x + 148y = 9357"], ["29x + y = 2641"], ["71x - 72y = -13058"], ["131x - 71y = 13651"], ["54x - y = 6004"], ["x + 73y = 9577"], ["37x - 90y = -14964"], ["39x + 23y = -1630"], ["3x - 14y = -701"], ["3x + 7y = -35"], ["47x + 138y = -25025"], ["72x - 113y = 5660"], ["81x + 103y = -11058"], ["x + 14y = -492"], ["29x + 144y = 6485"], ["x + 125y = 6246"], ["25x + 44y = 998"]], "starter_code": "def para_to_rect(eqn1: str, eqn2: str) -> str:", "canonical_solution": "from math import gcd\n\ndef para_to_rect(eqn1, eqn2):\n    a, b = eqn1.split('= ')[1].split('t ')\n    c, d = eqn2.split('= ')[1].split('t ')\n    if a in ('', '-'):\n        a += '1'\n    if c in ('', '-'):\n        c += '1'\n    a, b, c, d = map(eval, (a, b, c, d))\n    x = gcd(a, c)\n    e, f = (c // x, -a // x)\n    if e < 0:\n        e, f = (-e, -f)\n    return f'{(e if e > 1 else '')}x {'+-'[f < 0]} {(abs(f) if abs(f) > 1 else '')}y = {e * b + f * d}'", "entry_point": "para_to_rect", "task_id": "TACO_lite/1238", "input_output_examples": "[[['x = 12t + 18', 'y = 8t + 7'], ['x = -12t - 18', 'y = 8t + 7'], ['x = -t + 12', 'y = 12t - 1']], [['2x - 3y = 15'], ['2x + 3y = -15'], ['12x + y = 143']]]", "llm_generated_inputs": {"deepseek-v3": "[['x = 12t + 18', 'y = 8t + 7'], ['x = -12t - 18', 'y = 8t + 7'], ['x = -t + 12', 'y = 12t - 1'], ['x = 3t - 5', 'y = 2t + 4'], ['x = t + 1', 'y = t - 1'], ['x = 5t + 10', 'y = 5t + 10'], ['x = 2t - 3', 'y = 3t + 2'], ['x = 4t + 8', 'y = -2t + 6'], ['x = -3t + 9', 'y = 4t - 12'], ['x = t', 'y = t']]", "qwen2.5-coder-32b-instruct": "[['x = 12t + 18', 'y = 8t + 7'], ['x = -12t - 18', 'y = 8t + 7'], ['x = -t + 12', 'y = 12t - 1'], ['x = t + 5', 'y = -t + 3'], ['x = 2t', 'y = 3t + 4'], ['x = 5', 'y = 2t + 3'], ['x = 3t + 2', 'y = 3t + 2'], ['x = t', 'y = t'], ['x = -t', 'y = t'], ['x = 0t + 5', 'y = 0t + 7']]"}}
{"requirement": "def average_string(s: str) -> str:\n\"\"\"You are given a string of numbers between 0-9. Find the average of these numbers and return it as a floored whole number (ie: no decimal places) written out as a string. Eg:\n\n\"zero nine five two\" -> \"four\"\n\nIf the string is empty or includes a number greater than 9, return \"n/a\"\n\"\"\"", "inputs": [["zero nine five two"], ["four six two three"], ["one two three four five"], ["five four"], ["zero zero zero zero zero"], ["one one eight one"], ["one"], [""], ["ten"], ["pippi"]], "outputs": [["four"], ["three"], ["three"], ["four"], ["zero"], ["two"], ["one"], ["n/a"], ["n/a"], ["n/a"]], "starter_code": "def average_string(s: str) -> str:", "canonical_solution": "N = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n\ndef average_string(s):\n    try:\n        return N[sum((N.index(w) for w in s.split())) // len(s.split())]\n    except (ZeroDivisionError, ValueError):\n        return 'n/a'", "entry_point": "average_string", "task_id": "TACO_lite/1239", "input_output_examples": "[[['zero nine five two'], [''], ['one ten']], [['four'], ['n/a'], ['n/a']]]", "llm_generated_inputs": {"deepseek-v3": "[['zero nine five two'], ['four two seven one'], ['one one one one'], ['nine nine nine nine nine'], [''], ['ten'], ['zero one two three four five six seven eight nine'], ['one two three four five six seven eight nine zero'], ['zero'], ['nine'], ['zero zero zero zero zero'], ['one two three four five six seven eight nine ten']]", "qwen2.5-coder-32b-instruct": "[['zero nine five two'], ['one two three four five six seven eight nine zero'], ['five five five'], [''], ['ten eleven twelve'], ['0 1 2 3 4 5 6 7 8 9'], ['9 9 9 9 9 9 9 9 9 9'], ['1 2 3 a b c'], ['10 20 30']]"}}
{"requirement": "from typing import List\n\n\ndef length_of_sequence(arr: List[int], n: int) -> int:\n\"\"\"As part of this Kata, you need to find the length of the sequence in an array, between the first and the second occurrence of a specified number.\n\nFor example, for a given array `arr`\n\n    [0, -3, 7, 4, 0, 3, 7, 9]\n    \nFinding length between two `7`s like\n    \n    lengthOfSequence([0, -3, 7, 4, 0, 3, 7, 9], 7)\n    \nwould return `5`.\n\nFor sake of simplicity, there will only be numbers (positive or negative) in the supplied array.\n\nIf there are less or more than two occurrences of the number to search for, return `0`, or in Haskell, `Nothing`.\n\"\"\"", "inputs": [[[1], 0], [[1], 1], [[-7, 3, -7, -7, 2, 1], -7], [[-7, 3, -7, -7, 2, -7], -7]], "outputs": [[0], [0], [0], [0]], "starter_code": "from typing import List\ndef length_of_sequence(arr: List[int], n: int) -> int:", "canonical_solution": "def length_of_sequence(arr, n):\n    if arr.count(n) != 2:\n        return 0\n    a = arr.index(n)\n    b = arr.index(n, a + 1)\n    return b - a + 1", "entry_point": "length_of_sequence", "task_id": "TACO_lite/1242", "input_output_examples": "[[[[0, -3, 7, 4, 0, 3, 7, 9], 7]], [[5]]]", "llm_generated_inputs": {"deepseek-v3": "[[[0, -3, 7, 4, 0, 3, 7, 9], 7], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5], [[1, 1, 1, 1, 1], 1], [[1, 2, 3, 4, 5], 6], [[], 1], [[5, 5], 5], [[1, 2, 3, 4, 5, 2, 6, 7, 8, 9], 2], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10], 10], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10], 10], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10], 10]]", "qwen2.5-coder-32b-instruct": "[[[0, -3, 7, 4, 0, 3, 7, 9], 7], [[1, 2, 3, 4, 5, 6], 3], [[7, 1, 2, 3, 7, 4, 5, 7], 7], [[1, 2, 3, 4, 5, 6], 7], [[7, 7, 7, 7, 7], 7], [[], 7], [[7], 7], [[7, 1, 2, 3, 4, 5], 7], [[1, 2, 3, 4, 5, 7], 7]]"}}
{"requirement": "def controller(events: str) -> str:\n\"\"\"# Situation\nYou have been hired by a company making electric garage doors. Accidents with the present product line have resulted in numerous damaged cars, broken limbs and several killed pets. Your mission is to write a safer version of their controller software.\n\n# Specification\nWe always start with a closed door. The remote control has exactly one button, with the following behaviour.\n\n+ If the door is closed, a push starts opening the door, and vice-versa\n+ It takes 5 seconds for the door to open or close completely\n+ While the door is moving, one push pauses movement, another push resumes movement in the same direction\n\nIn order to make the door safer, it has been equiped with resistance-based obstacle detection. When the door detects an obstacle, it must immediately reverse the direction of movement.\n\n# Input\nA string where each character represents one second, with the following possible values.\n\n* ```'.'``` No event\n* ```'P'``` Button has been pressed\n* ```'O'``` Obstacle has been detected (supersedes P)\n\nAs an example, ```'..P....'``` means that nothing happens for two seconds, then the button is pressed, then no further events.\n\n# Output\nA string where each character represents one second and indicates the position of the door (0 if fully closed and 5 fully open). The door starts moving immediately, hence its position changes at the same second as the event.\n\n# Example\n```..P...O.....``` as input should yield\n```001234321000``` as output\n\"\"\"", "inputs": [[""], [".........."], ["P.."], ["P...."], ["P......P......"], ["P.P.."], ["P.P.P...."], [".....P.P........P...."], [".....P......P.P..P...."], ["P.O...."], ["P......P.O...."], ["P..OP..P.."], ["P......P..OP..P..."], ["..P...O....."]], "outputs": [[""], ["0000000000"], ["123"], ["12345"], ["12345554321000"], ["12222"], ["122234555"], ["000001222222222234555"], ["0000012345554333321000"], ["1210000"], ["12345554345555"], ["1232222100"], ["123455543233334555"], ["001234321000"]], "starter_code": "def controller(events: str) -> str:", "canonical_solution": "def controller(events):\n    out, state, dir, moving = ([], 0, 1, False)\n    for c in events:\n        if c == 'O':\n            dir *= -1\n        elif c == 'P':\n            moving = not moving\n        if moving:\n            state += dir\n        if state in [0, 5]:\n            moving, dir = (False, 1 if state == 0 else -1)\n        out.append(str(state))\n    return ''.join(out)", "entry_point": "controller", "task_id": "TACO_lite/1244", "input_output_examples": "[[['..P...O.....']], [['001234321000']]]", "llm_generated_inputs": {"deepseek-v3": "[['..P....'], ['P..P..P..'], ['..O....'], ['..P..O..'], ['P.O.P.O.P'], ['........'], ['P'], ['O'], ['PPPPP'], ['PO.PO.PO']]", "qwen2.5-coder-32b-instruct": "[['.'], ['P'], ['PP'], ['PPP'], ['PPPP'], ['PPPPP'], ['PPPPPP'], ['O'], ['PO'], ['OP'], ['..P....'], ['..P...O.....'], ['P........'], ['P.P.P.P.P'], ['OOOOO'], ['PPOOO'], ['PPPPPOOOO'], ['............................'], ['PPPPPPPPPPPPPPPPPPPPPPPPPPPPP'], ['POPOPOPOPOPOPOPOPOPOPOPOPOPOP']]"}}
{"requirement": "def count_repeats(s: str) -> int:\n\"\"\"Write a function that returns the count of characters that have to be removed in order to get a string with no consecutive repeats.\n\n*Note:* This includes any characters\n\n##  Examples\n\n```python\n'abbbbc'  => 'abc'    #  answer: 3\n'abbcca'  => 'abca'   #  answer: 2\n'ab cca'  => 'ab ca'  #  answer: 1\n```\n\"\"\"", "inputs": [["abcdefg"], ["aabbccddeeffgg"], ["abcdeefee"], ["122453124"], ["@*$##^^^*)*"], ["abmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]], "outputs": [[0], [7], [2], [1], [3], [1177]], "starter_code": "def count_repeats(s: str) -> int:", "canonical_solution": "from itertools import groupby\n\ndef count_repeats(s):\n    return len(s) - len(list(groupby(s)))", "entry_point": "count_repeats", "task_id": "TACO_lite/1245", "input_output_examples": "[[['abbbbc'], ['abbcca'], ['ab cca']], [[3], [2], [1]]]", "llm_generated_inputs": {"deepseek-v3": "[['abbbbc'], ['abbcca'], ['ab cca'], ['aaaaa'], ['abcde'], ['aaabbbccc'], ['aabbaa'], ['a a a a'], [''], ['a']]", "qwen2.5-coder-32b-instruct": "[['abbbbc'], ['abbcca'], ['ab cca'], ['aabbccddeeff'], ['abcdefg'], ['aaaabbbb'], ['a'], [''], ['aa bb cc dd'], ['aabbaa']]"}}
{"requirement": "def encryption(string: str) -> str:\n\"\"\"Write a function that will encrypt a given sentence into International Morse Code, both the input and out puts will be strings.\n\nCharacters should be separated by a single space.\nWords should be separated by a triple space.\n\nFor example, \"HELLO WORLD\" should return -> \".... . .-.. .-.. ---   .-- --- .-. .-.. -..\"\n\nTo find out more about Morse Code follow this link: https://en.wikipedia.org/wiki/Morse_code\n\nA preloaded object/dictionary/hash called CHAR_TO_MORSE will be provided to help convert characters to Morse Code.\n\"\"\"", "inputs": [["HELLO WORLD"], ["SOS"], ["1836"], ["THE QUICK BROWN FOX"], ["JUMPED OVER THE"], ["LAZY DOG"], ["WOLFRAM ALPHA 1"], ["CodeWars Rocks"], [""], ["Final basic test"]], "outputs": [[".... . .-.. .-.. ---   .-- --- .-. .-.. -.."], ["... --- ..."], [".---- ---.. ...-- -...."], ["- .... .   --.- ..- .. -.-. -.-   -... .-. --- .-- -.   ..-. --- -..-"], [".--- ..- -- .--. . -..   --- ...- . .-.   - .... ."], [".-.. .- --.. -.--   -.. --- --."], [".-- --- .-.. ..-. .-. .- --   .- .-.. .--. .... .-   .----"], ["-.-. --- -.. . .-- .- .-. ...   .-. --- -.-. -.- ..."], [""], ["..-. .. -. .- .-..   -... .- ... .. -.-.   - . ... -"]], "starter_code": "def encryption(string: str) -> str:", "canonical_solution": "CODE = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ' ': ' '}\n\ndef encryption(string):\n    string.upper()\n    return ' '.join([CODE[a] for a in string.upper()])", "entry_point": "encryption", "task_id": "TACO_lite/1247", "input_output_examples": "[[['HELLO WORLD']], [['.... . .-.. .-.. ---   .-- --- .-. .-.. -..']]]", "llm_generated_inputs": {"deepseek-v3": "[['HELLO WORLD'], ['PYTHON'], ['123'], ['@#$'], [' '], ['A'], ['a'], ['Hello World'], ['This is a test.'], ['!@#$%^&*()']]", "qwen2.5-coder-32b-instruct": "[['HELLO WORLD'], ['SOS'], ['PYTHON'], ['123'], ['!@#'], [' '], ['MORSE CODE'], ['aBcDeFgHiJkLmNoPqRsTuVwXyZ'], ['0123456789']]"}}
{"requirement": "def num_of_open_lockers(n: int) -> int:\n\"\"\"A high school has a strange principal. On the first day, he has his students perform an odd opening day ceremony:\n\nThere are number of lockers \"n\" and number of students \"n\" in the school. The principal asks the first student to go to every locker and open it. Then he has the second student go to every second locker and close it. The third goes to every third locker and, if it is closed, he opens it, and if it is open, he closes it. The fourth student does this to every fourth locker, and so on. After the process is completed with the \"n\"th student, how many lockers are open?\n\nThe task is to write a function which gets any number as an input and returns the number of open lockers after last sudent complets his activity. So input of the function is just one number which shows number of lockers and number of students. For example if there are 1000 lockers and 1000 students in school then input is 1000 and function returns number of open lockers after 1000th student completes his action.\n\nThe given input is always an integer greater than or equal to zero that is why there is no need for validation.\n\"\"\"", "inputs": [[0], [1], [4], [56], [128], [500], [562], [74864], [3991700], [950811894]], "outputs": [[0], [1], [2], [7], [11], [22], [23], [273], [1997], [30835]], "starter_code": "def num_of_open_lockers(n: int) -> int:", "canonical_solution": "def num_of_open_lockers(n):\n    return int(n ** 0.5)", "entry_point": "num_of_open_lockers", "task_id": "TACO_lite/1249", "input_output_examples": "[[[1000]], [[31]]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [2], [9], [10], [25], [100], [1000]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [2], [3], [4], [9], [16], [25], [100], [1000]]"}}
{"requirement": "def next_day_of_week(current_day: int, available_week_days: int) -> int:\n\"\"\"# Task\n You have set an alarm for some of the week days.\n \n Days of the week are encoded in binary representation like this:\n```\n0000001 - Sunday\n0000010 - Monday\n0000100 - Tuesday\n0001000 - Wednesday\n0010000 - Thursday\n0100000 - Friday \n1000000 - Saturday```\nFor example, if your alarm is set only for Sunday and Friday, the representation will be `0100001`. \n\n Given the current day of the week, your task is to find the day of the week when alarm will ring next time.\n\n# Example\n\n For `currentDay = 4, availableWeekDays = 42`, the result should be `6`.\n \n ```\ncurrentDay = 4 means the current Day is Wednesday\navailableWeekDays = 42 convert to binary is \"0101010\"\nSo the next day is 6 (Friday)\n```\n\n# Input/Output\n\n\n - `[input]` integer `currentDay`\n \n The weekdays range from 1 to 7, 1 is Sunday and 7 is Saturday\n\n\n\n\n - `[input]` integer `availableWeekDays`\n \n An integer. Days of the week are encoded in its binary representation.\n\n\n - `[output]` an integer\n\n The next day available.\n\"\"\"", "inputs": [[4, 42], [6, 42], [7, 42]], "outputs": [[6], [2], [2]], "starter_code": "def next_day_of_week(current_day: int, available_week_days: int) -> int:", "canonical_solution": "def next_day_of_week(current_day, available_week_days):\n    x = 2 ** current_day\n    while not x & available_week_days:\n        x = max(1, x * 2 % 2 ** 7)\n    return x.bit_length()", "entry_point": "next_day_of_week", "task_id": "TACO_lite/1250", "input_output_examples": "[[[4, 42]], [[6]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 1], [2, 2], [3, 4], [4, 8], [5, 16], [6, 32], [7, 64], [1, 127], [7, 127], [3, 42], [5, 18], [2, 0], [4, 64], [6, 1], [1, 0], [7, 1]]", "qwen2.5-coder-32b-instruct": "[[1, 1], [1, 2], [7, 128], [3, 14], [4, 42], [6, 62], [7, 127], [2, 4], [5, 32], [7, 64]]"}}
{"requirement": "def caesar_crypto_encode(text: str, shift: int) -> str:\n\"\"\"Let’s get to know our hero: Agent #134 - Mr. Slayer.\n\nHe was sent by his CSV agency to Ancient Rome in order to resolve some important national issues. However, something incredible has happened - the enemies have taken Julius Caesar as a prisoner!!!\n\nCaesar, not a simple man as you know, managed to send cryptic message with coordinates of his location hoping that somebody would break the code. Here our agent of the secret service comes to the stage.\n\nBut he needs your help!\n\n**Mission:**\n\nYou have to implement the function “Encode” of CaesarCrypto class that codes or decodes text based on Caesar’s algorithm.the function receives 2 parameters: an original text of any length of type “string” and a number of type “int” that represents shifts;only letters in both cases must be encrypted;alphabet contains only letters in this range: a-zA-Z;by encryption the letter can change the case;shift could be either positive or negative (for left shift);If the input text is empty, null or includes only whitespaces, return an empty string.\n\nTime's ticking away. The life of Caesar is on the chopping block! Go for it!\n\"\"\"", "inputs": [["123,.)(!?", 10], ["", 10], [null, 10], ["   ", 10], ["Hello world!", 127], ["eBIIL TLOIA!", -127], ["ksdjai8983hdk?}{", 15], ["Hello world!", 0]], "outputs": [["123,.)(!?"], [""], [""], [""], ["eBIIL TLOIA!"], ["Hello world!"], ["zHsypx8983wsz?}{"], ["Hello world!"]], "starter_code": "def caesar_crypto_encode(text: str, shift: int) -> str:", "canonical_solution": "from string import ascii_letters as az\n\ndef caesar_crypto_encode(text, shift):\n    if not text:\n        return ''\n    sh = shift % 52\n    return str.translate(text, str.maketrans(az, az[sh:] + az[:sh])).strip()", "entry_point": "caesar_crypto_encode", "task_id": "TACO_lite/1262", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['Hello, World!', 3], ['Hello, World!', -3], ['Caesar', 0], ['Caesar', 26], ['Caesar', -26], ['Caesar', 52], ['Caesar', -52], ['', 5], ['   ', 5], [None, 5], ['12345!@#$%', 5], ['abcdefghijklmnopqrstuvwxyz', 1], ['ABCDEFGHIJKLMNOPQRSTUVWXYZ', -1], ['aBcDeFgHiJkLmNoPqRsTuVwXyZ', 13], ['zZ', 1], ['aA', -1]]", "qwen2.5-coder-32b-instruct": "[['Hello World', 3], ['abc', 1], ['xyz', 2], ['ABC', -1], ['XYZ', -2], ['aBcDeFgHiJkLmNoPqRsTuVwXyZ', 5], ['zYxWvUtSrQpOnMlKjIhGfEdCbA', -5], ['', 3], ['   ', 3], ['The quick brown fox jumps over lazy dogs.', 7], ['The quick brown fox jumps over lazy dogs.', -7], ['Python3.8', 4], ['Python3.8', -4]]"}}
{"requirement": "def canthreepartsequalsum(A: list) -> bool:\n\"\"\"Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i+1 < j with (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])\n \nExample 1:\nInput: A = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n\nExample 2:\nInput: A = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false\n\nExample 3:\nInput: A = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n\n \nConstraints:\n\n3 <= A.length <= 50000\n-10^4 <= A[i] <= 10^4\n\"\"\"", "inputs": [[[0, 2, 5, 2, 5, 1, 6, 12, 20, 28, 37]], [[0, 2, 3, -3, 3, 10, 19, 18, 20, 20, 21]], [[0, 2, 3, -3, 3, -4, 5, 6, 8, 8, 9]], [[3, 6, 12, 17, 15, 17, 22, 23, 14, 18]]], "outputs": [[false], [false], [true], [true]], "starter_code": "def canthreepartsequalsum(A: list) -> bool:", "canonical_solution": "def canthreepartsequalsum(A: list) -> bool:\n    if len(A) < 3:\n        return False\n    for i in range(1, len(A)):\n        A[i] = A[i - 1] + A[i]\n    end_value = A[-1]\n    if end_value % 3 != 0:\n        return False\n    index = len(A) - 2\n    while A[index] != 2 * end_value // 3:\n        index -= 1\n        if index == 0:\n            return False\n    index -= 1\n    while A[index] != end_value // 3:\n        index -= 1\n        if index < 0:\n            return False\n    return True", "entry_point": "canthreepartsequalsum", "task_id": "TACO_lite/1263", "input_output_examples": "[[[[0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]], [[0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1]], [[3, 3, 6, 5, -2, 2, 5, 1, -9, 4]]], [[True], [False], [True]]]", "llm_generated_inputs": {"deepseek-v3": "[[[0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]], [[0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1]], [[3, 3, 6, 5, -2, 2, 5, 1, -9, 4]], [[1, 1, 1]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[0, 0, 0, 0, 0, 0, 0, 0, 0]], [[-1, -1, -1, -1, -1, -1, -1, -1, -1]], [[1, -1, 1, -1, 1, -1, 1, -1, 1]], [[10, -10, 10, -10, 10, -10, 10, -10, 10]], [[1, 2, 3, 6]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]], [[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]], [[10000, -10000, 10000, -10000, 10000]], [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]]]", "qwen2.5-coder-32b-instruct": "[[[0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]], [[0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1]], [[3, 3, 6, 5, -2, 2, 5, 1, -9, 4]], [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], [[10, -10, 10, -10, 10, -10]], [[1, 2, 3, 4, 5, 6, 7, 8, 9]], [[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]], [[0, 0, 0]], [[1, -1, 1, -1, 1, -1]], [[10000, -5000, -2500, -2500]], [[-10000, 5000, 2500, 2500]], [[1, 2, 3, 0, 0, 0, 1, 2, 3]], [[1, 2, 3, 0, 0, 0, 1, 2]], [[1, 1, 1, 2, 2, 2, 3, 3, 3]]]"}}
{"requirement": "from typing import List\n\n\ndef longest(words: List[str]) -> int:\n\"\"\"Complete the function that takes one argument, a list of words, and returns the length of the longest word in the list.\n\nFor example: \n\n```python\n['simple', 'is', 'better', 'than', 'complex'] ==> 7\n```\n\nDo not modify the input list.\n\"\"\"", "inputs": [[["simple", "is", "better", "than", "complex"]], [["explicit", "is", "better", "than", "implicit"]], [["beautiful", "is", "better", "than", "ugly"]]], "outputs": [[7], [8], [9]], "starter_code": "from typing import List\ndef longest(words: List[str]) -> int:", "canonical_solution": "def longest(words):\n    return max(map(len, words))", "entry_point": "longest", "task_id": "TACO_lite/1272", "input_output_examples": "[[[['simple', 'is', 'better', 'than', 'complex']]], [[7]]]", "llm_generated_inputs": {"deepseek-v3": "[[['simple', 'is', 'better', 'than', 'complex']], [['a', 'ab', 'abc', 'abcd']], [['']], [['longest', 'word', 'in', 'the', 'list']], [['single']], [['multiple', 'words', 'of', 'same', 'length']], [['python', 'java', 'c++', 'javascript']], [['a', 'a', 'a', 'a']], [['verylongword', 'short', 'medium']]]", "qwen2.5-coder-32b-instruct": "[[['simple', 'is', 'better', 'than', 'complex']], [['a', 'ab', 'abc']], [['longestword', 'short', 'tiny']], [['equal', 'equal', 'equal']], [[]], [['oneverylongwordindeed']], [['same', 'size', 'test']]]"}}
{"requirement": "from typing import List\n\n\ndef candies(s: List[int]) -> int:\n\"\"\"# Description\n\"It's the end of trick-or-treating and we have a list/array representing how much candy each child in our group has made out with. We don't want the kids to start arguing, and using our parental intuition we know trouble is brewing as many of the children in the group have received different amounts of candy from each home. \n\nSo we want each child to have the same amount of candies, only we can't exactly take any candy away from the kids, that would be even worse. Instead we decide to give each child extra candy until they all have the same amount.\n# Task\nYour job is to find out how much candy each child has, and give them each additional candy until they too have as much as the child(ren) with the most candy. You also want to keep a total of how much candy you've handed out because reasons.\"\n\nYour job is to give all the kids the same amount of candies as the kid with the most candies and then return the total number candies that have been given out. If there are no kids, or only one, return -1. \n\nIn the first case (look below) the most candies are given to second kid (i.e second place in list/array), 8. Because of that we will give the first kid 3 so he can have 8 and the third kid 2 and the fourth kid 4, so all kids will have 8 candies.So we end up handing out 3 + 2 + 4 = 9.\n\n```python\ncandies ([5,8,6,4]) # return 9\n\ncandies ([1,2,4,6]) # return 11\n\ncandies ([1,6]) # return 5\n\ncandies ([]) # return -1\n\ncandies ([6]) # return -1 (because only one kid)\n```\n```cs\nCandyProblem.GetMissingCandies(new [] {5, 6, 8, 4}) // return 9\n\nCandyProblem.GetMissingCandies(new [] {1, 2, 4, 6}) // return 11\n\nCandyProblem.GetMissingCandies(new [] { }) // return -1\n\nCandyProblem.GetMissingCandies(new [] {1, 6}) // return 5\n\n```\n```haskell \ncandies [5,8,6,4] -- return 9\n\ncandies [1,2,4,6] -- return 11\n\ncandies [] -- return -1\n\ncandies [1,6] -- return 5\n```\n\"\"\"", "inputs": [[[5, 8, 6, 4]], [[1, 2, 4, 6]], [[1, 2]], [[4, 2]], [[1, 3, 3, 7]], [[7, 7, 7, 7]], [[17, 20, 50, 61, 42, 44]], [[0]], [[]], [[4]], [[null]]], "outputs": [[9], [11], [1], [2], [14], [0], [132], [-1], [-1], [-1], [-1]], "starter_code": "from typing import List\ndef candies(s: List[int]) -> int:", "canonical_solution": "def candies(s):\n    if not s or len(s) == 1:\n        return -1\n    return len(s) * max(s) - sum(s)", "entry_point": "candies", "task_id": "TACO_lite/1273", "input_output_examples": "[[[[5, 8, 6, 4]], [[1, 2, 4, 6]], [[1, 6]], [[]], [[6]]], [[9], [11], [5], [-1], [-1]]]", "llm_generated_inputs": {"deepseek-v3": "[[[5, 8, 6, 4]], [[1, 2, 4, 6]], [[1, 6]], [[]], [[6]], [[10, 10, 10, 10]], [[0, 0, 0, 0]], [[1, 1, 1, 2]], [[100, 200, 300]], [[7, 7, 7, 7, 7, 7, 7]]]", "qwen2.5-coder-32b-instruct": "[[[5, 8, 6, 4]], [[1, 2, 4, 6]], [[1, 6]], [[]], [[6]], [[10, 10, 10]], [[1]], [[3, 3, 3, 3, 3]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]]]"}}
{"requirement": "def over_the_road(address: int, n: int) -> int:\n\"\"\"### Task\nYou've just moved into a perfectly straight street with exactly ```n``` identical houses on either side of the road. Naturally, you would like to find out the house number of the people on the other side of the street. The street looks something like this:\n\n--------------------\n### Street\n```\n1|   |6\n3|   |4\n5|   |2\n```\n\nEvens increase on the right; odds decrease on the left. House numbers start at ```1``` and increase without gaps.\nWhen ```n = 3```, ```1``` is opposite ```6```, ```3``` opposite ```4```, and ```5``` opposite ```2```. \n\n-----------------\n### Example\nGiven your house number ```address``` and length of street ```n```, give the house number on the opposite side of the street.\n\n```CoffeeScript\noverTheRoad(address, n)\noverTheRoad(1, 3) = 6\noverTheRoad(3, 3) = 4\noverTheRoad(2, 3) = 5\noverTheRoad(3, 5) = 8\n```\n\n```python\nover_the_road(address, n)\nover_the_road(1, 3) = 6\nover_the_road(3, 3) = 4\nover_the_road(2, 3) = 5\nover_the_road(3, 5) = 8\n```\n\n\nBoth n and address could get upto 500 billion with over 200 random tests.\n\"\"\"", "inputs": [[1, 3], [3, 3], [2, 3], [3, 5], [7, 11], [10, 22], [20, 3400], [9, 26], [20, 10]], "outputs": [[6], [4], [5], [8], [16], [35], [6781], [44], [1]], "starter_code": "def over_the_road(address: int, n: int) -> int:", "canonical_solution": "def over_the_road(address, n):\n    return 2 * n + 1 - address", "entry_point": "over_the_road", "task_id": "TACO_lite/1284", "input_output_examples": "[[[1, 3], [3, 3], [2, 3], [3, 5]], [[6], [4], [5], [8]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 3], [3, 3], [2, 3], [3, 5], [10, 10], [500000000000, 500000000000], [1, 500000000000], [500000000000, 1], [2, 2], [999999999999, 999999999999], [123456, 654321]]", "qwen2.5-coder-32b-instruct": "[[1, 3], [3, 3], [2, 3], [3, 5], [1, 1], [2, 2], [500000000000, 500000000000], [1, 500000000000], [999999999999, 500000000000], [2, 500000000000], [499999999999, 500000000000], [500000000000, 500000000000], [5, 5], [6, 5], [7, 5], [8, 5], [9, 5]]"}}
{"requirement": "def calc(s: str) -> int:\n\"\"\"Given a string, turn each letter into its ASCII character code and join them together to create a number - let's call this number `total1`:\n\n```\n'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667\n```\n\nThen replace any incidence of the number `7` with the number `1`, and call this number 'total2':\n```\ntotal1 = 656667\n              ^\ntotal2 = 656661\n              ^\n```\n\nThen return the difference between the sum of the digits in `total1` and `total2`:\n\n```\n  (6 + 5 + 6 + 6 + 6 + 7)\n- (6 + 5 + 6 + 6 + 6 + 1)\n-------------------------\n                       6\n```\n\"\"\"", "inputs": [["abcdef"], ["ifkhchlhfd"], ["aaaaaddddr"], ["jfmgklf8hglbe"], ["jaam"], ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"]], "outputs": [[6], [6], [30], [6], [12], [96]], "starter_code": "def calc(s: str) -> int:", "canonical_solution": "def calc(s):\n    total1 = ''.join(map(lambda c: str(ord(c)), s))\n    total2 = total1.replace('7', '1')\n    return sum(map(int, total1)) - sum(map(int, total2))", "entry_point": "calc", "task_id": "TACO_lite/1286", "input_output_examples": "[[['ABC']], [[6]]]", "llm_generated_inputs": {"deepseek-v3": "[['ABC'], ['7'], [''], ['123'], ['a'], ['A7B'], ['XYZ'], ['777'], ['Hello World'], ['!@#$%^&*()']]", "qwen2.5-coder-32b-instruct": "[['ABC'], ['A'], [''], ['7'], ['ZZZ'], ['a7b'], ['123'], ['!@#'], ['seven'], ['SEVEN']]"}}
{"requirement": "def encode_resistor_colors(ohms_string: str) -> str:\n\"\"\"## Overview\nResistors are electrical components marked with colorful stripes/bands to indicate both their resistance value in ohms and how tight a tolerance that value has. If you did my Resistor Color Codes kata, you wrote a function which took a string containing a resistor's band colors, and returned a string identifying the resistor's ohms and tolerance values.\n\n\nWell, now you need that in reverse: The previous owner of your \"Beyond-Ultimate Raspberry Pi Starter Kit\" (as featured in my Fizz Buzz Cuckoo Clock kata) had emptied all the tiny labeled zip-lock bags of components into the box, so that for each resistor you need for a project, instead of looking for text on a label, you need to find one with the sequence of band colors that matches the ohms value you need.\n\n## The resistor color codes\nYou can see this Wikipedia page for a colorful chart, but the basic resistor color codes are:\n\n0: black, 1: brown, 2: red, 3: orange, 4: yellow, 5: green, 6: blue, 7: violet, 8: gray, 9: white\n\nAll resistors have at least three bands, with the first and second bands indicating the first two digits of the ohms value, and the third indicating the power of ten to multiply them by, for example a resistor with a value of 47 ohms, which equals 47 * 10^0 ohms, would have the three bands \"yellow violet black\".\n\nMost resistors also have a fourth band indicating tolerance -- in an electronics kit like yours, the tolerance will always be 5%, which is indicated by a gold band. So in your kit, the 47-ohm resistor in the above paragraph would have the four bands \"yellow violet black gold\".\n\n## Your mission\nYour function will receive a string containing the ohms value you need, followed by a space and the word \"ohms\" (to avoid Codewars unicode headaches I'm just using the word instead of the ohms unicode symbol). The way an ohms value is formatted depends on the magnitude of the value:\n\n* For resistors less than 1000 ohms, the ohms value is just formatted as the plain number. For example, with the 47-ohm resistor above, your function would receive the string `\"47 ohms\"`, and return the string `\"yellow violet black gold\".\n\n* For resistors greater than or equal to 1000 ohms, but less than 1000000 ohms, the ohms value is divided by 1000, and has a lower-case \"k\" after it. For example, if your function received the string `\"4.7k ohms\"`, it would need to return the string `\"yellow violet red gold\"`.\n\n* For resistors of 1000000 ohms or greater, the ohms value is divided by 1000000, and has an upper-case \"M\" after it. For example, if your function received the string `\"1M ohms\"`, it would need to return the string `\"brown black green gold\"`. \n\nTest case resistor values will all be between 10 ohms and 990M ohms.\n\n## More examples, featuring some common resistor values from your kit\n\n\n```\n\"10 ohms\"        \"brown black black gold\"\n\"100 ohms\"       \"brown black brown gold\"\n\"220 ohms\"       \"red red brown gold\"\n\"330 ohms\"       \"orange orange brown gold\"\n\"470 ohms\"       \"yellow violet brown gold\"\n\"680 ohms\"       \"blue gray brown gold\"\n\"1k ohms\"        \"brown black red gold\"\n\"10k ohms\"       \"brown black orange gold\"\n\"22k ohms\"       \"red red orange gold\"\n\"47k ohms\"       \"yellow violet orange gold\"\n\"100k ohms\"      \"brown black yellow gold\"\n\"330k ohms\"      \"orange orange yellow gold\"\n\"2M ohms\"        \"red black green gold\"\n```\n\nHave fun!\n\"\"\"", "inputs": [["10 ohms"], ["47 ohms"], ["100 ohms"], ["220 ohms"], ["330 ohms"], ["470 ohms"], ["680 ohms"], ["1k ohms"], ["4.7k ohms"], ["10k ohms"], ["22k ohms"], ["47k ohms"], ["100k ohms"], ["330k ohms"], ["1M ohms"], ["2M ohms"]], "outputs": [["brown black black gold"], ["yellow violet black gold"], ["brown black brown gold"], ["red red brown gold"], ["orange orange brown gold"], ["yellow violet brown gold"], ["blue gray brown gold"], ["brown black red gold"], ["yellow violet red gold"], ["brown black orange gold"], ["red red orange gold"], ["yellow violet orange gold"], ["brown black yellow gold"], ["orange orange yellow gold"], ["brown black green gold"], ["red black green gold"]], "starter_code": "def encode_resistor_colors(ohms_string: str) -> str:", "canonical_solution": "c = 'black brown red orange yellow green blue violet gray white'.split()\n\ndef encode_resistor_colors(ohms_string):\n    ohms = str(int(eval(ohms_string.replace('k', '*1000').replace('M', '*1000000').split()[0])))\n    return '%s %s %s gold' % (c[int(ohms[0])], c[int(ohms[1])], c[len(ohms[2:])])", "entry_point": "encode_resistor_colors", "task_id": "TACO_lite/1298", "input_output_examples": "[[['47 ohms'], ['4.7k ohms'], ['1M ohms'], ['10 ohms'], ['100 ohms'], ['220 ohms'], ['330 ohms'], ['470 ohms'], ['680 ohms'], ['1k ohms'], ['10k ohms'], ['22k ohms'], ['47k ohms'], ['100k ohms'], ['330k ohms'], ['2M ohms']], [['yellow violet black gold'], ['yellow violet red gold'], ['brown black green gold'], ['brown black black gold'], ['brown black brown gold'], ['red red brown gold'], ['orange orange brown gold'], ['yellow violet brown gold'], ['blue gray brown gold'], ['brown black red gold'], ['brown black orange gold'], ['red red orange gold'], ['yellow violet orange gold'], ['brown black yellow gold'], ['orange orange yellow gold'], ['red black green gold']]]", "llm_generated_inputs": {"deepseek-v3": "[['10 ohms'], ['100 ohms'], ['220 ohms'], ['330 ohms'], ['470 ohms'], ['680 ohms'], ['1k ohms'], ['10k ohms'], ['22k ohms'], ['47k ohms'], ['100k ohms'], ['330k ohms'], ['2M ohms'], ['0.1k ohms'], ['0.01M ohms'], ['999 ohms'], ['999k ohms'], ['999M ohms']]", "qwen2.5-coder-32b-instruct": "[['10 ohms'], ['100 ohms'], ['220 ohms'], ['330 ohms'], ['470 ohms'], ['680 ohms'], ['1k ohms'], ['10k ohms'], ['22k ohms'], ['47k ohms'], ['100k ohms'], ['330k ohms'], ['2M ohms'], ['990M ohms'], ['999 ohms'], ['1.0k ohms'], ['1000 ohms'], ['1000000 ohms'], ['0.99k ohms'], ['1.001k ohms']]"}}
{"requirement": "def yes_no(arr: list) -> list:\n\"\"\"Write a code that receives an array of numbers or strings, goes one by one through it while taking one value out, leaving one value in, taking, leaving, and back again to the beginning until all values are out.  \nIt's like a circle of people who decide that every second person will leave it, until the last person is there. So if the last element of the array is taken, the first element that's still there, will stay.  \nThe code returns a new re-arranged array with the taken values by their order. The first value of the initial array is always taken.\n\nExamples:\n\"\"\"", "inputs": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [["this", "code", "is", "right", "the"]], [[]], [["a"]], [["a", "b"]]], "outputs": [[[1, 3, 5, 7, 9, 2, 6, 10, 8, 4]], [["this", "is", "the", "right", "code"]], [[]], [["a"]], [["a", "b"]]], "starter_code": "def yes_no(arr: list) -> list:", "canonical_solution": "from collections import deque\n\ndef yes_no(arr):\n    d, result = (deque(arr), [])\n    while d:\n        result.append(d.popleft())\n        d.rotate(-1)\n    return result", "entry_point": "yes_no", "task_id": "TACO_lite/1303", "input_output_examples": "[[[['a', 'b', 'c', 'd', 'e', 'f']], [[1, 2, 3, 4, 5, 6, 7, 8, 9]]], [[['a', 'c', 'e', 'b', 'f', 'd']], [[1, 3, 5, 7, 9, 2, 6, 4, 8]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 5]], [['a', 'b', 'c', 'd', 'e']], [[True, False, True, False]], [[]], [[10]], [['apple', 'banana', 'cherry', 'date', 'elderberry']], [[1, 'a', 2, 'b', 3, 'c']]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 4, 5]], [['a', 'b', 'c', 'd', 'e']], [[10, 20, 30, 40, 50, 60]], [[1]], [[]], [[True, False, True, False]], [[1, 'two', 3, 'four', 5]], [[None, None, None]]]"}}
{"requirement": "from typing import List\n\n\ndef optimal_number_of_coins(n: int, coins: List[int]) -> float:\n\"\"\"Coffee Vending Machine Problems [Part 1]\n\nYou have a vending machine, but it can not give the change back. You decide to implement this functionality. First of all, you need to know the minimum number of coins for this operation (i'm sure you don't want to return 100 pennys instead of 1$ coin).\nSo, find an optimal number of coins required, if you have unlimited set of coins with given denominations.\n\nAssume all inputs are valid positive integers, and every set of coin denominations has len 4 for simplicity;\n\nExamples:\n\noptimal_number_of_coins(1, [1, 2, 5, 10]) \n(1 penny) so returns 1  \noptimal_number_of_coins(5, [1, 2, 5, 10])\n(5) so returns 1\noptimal_number_of_coins(6, [1, 3, 5, 10])\n(3+3 or 5+1) = 6 so returns 2\noptimal_number_of_coins(10, [1, 2, 5, 10]) \n(10) so returns 1\noptimal_number_of_coins(12, [1, 3, 5, 10])\n(10+1+1) = 12 so returns 3\noptimal_number_of_coins(53, [1, 2, 5, 25])\n(25+25+2+1) = 53 so returns 4\noptimal_number_of_coins(7, [1, 1, 1, 25])\n(1+1+1+1+1+1+1) = 7 so returns 7\netc..\n\nHave fun =)\n\"\"\"", "inputs": [[1, [1, 2, 5, 10]], [5, [1, 2, 5, 10]], [6, [1, 3, 5, 10]], [10, [1, 2, 5, 10]], [12, [1, 3, 5, 10]], [53, [1, 2, 5, 25]], [7, [1, 1, 1, 25]], [76, [1, 3, 4, 10]], [33, [1, 6, 9, 10]], [63, [1, 2, 9, 10]], [239, [1, 2, 3, 10]], [333, [1, 1, 5, 25]], [543, [1, 3, 5, 25]], [777, [1, 2, 3, 10]], [18, [1, 3, 9, 10]], [16, [1, 8, 9, 10]], [14, [1, 3, 7, 9]]], "outputs": [[1], [1], [2], [1], [3], [4], [7], [9], [4], [7], [26], [17], [25], [80], [2], [2], [2]], "starter_code": "from typing import List\ndef optimal_number_of_coins(n: int, coins: List[int]) -> float:", "canonical_solution": "from functools import lru_cache\n\ndef optimal_number_of_coins(n, coins):\n\n    def f(amount: int, idx: int) -> float:\n        q, r = divmod(amount, coins[idx])\n        if r == 0:\n            return q\n        elif amount < 0 or idx <= 0:\n            return float('inf')\n        else:\n            return min(1 + f(amount - coins[idx], idx), f(amount, idx - 1))\n    coins = sorted(set(coins))\n    return f(n, len(coins) - 1)", "entry_point": "optimal_number_of_coins", "task_id": "TACO_lite/1307", "input_output_examples": "[[[1, [1, 2, 5, 10]], [5, [1, 2, 5, 10]], [6, [1, 3, 5, 10]], [10, [1, 2, 5, 10]], [12, [1, 3, 5, 10]], [53, [1, 2, 5, 25]], [7, [1, 1, 1, 25]]], [[1], [1], [2], [1], [3], [4], [7]]]", "llm_generated_inputs": {"deepseek-v3": "[[1, [1, 2, 5, 10]], [5, [1, 2, 5, 10]], [6, [1, 3, 5, 10]], [10, [1, 2, 5, 10]], [12, [1, 3, 5, 10]], [53, [1, 2, 5, 25]], [7, [1, 1, 1, 25]], [0, [1, 2, 5, 10]], [100, [1, 5, 10, 25]], [99, [1, 3, 5, 10]], [15, [1, 2, 5, 10]], [27, [1, 3, 5, 10]], [50, [1, 5, 10, 25]], [100, [1, 5, 10, 50]], [3, [1, 2, 5, 10]], [4, [1, 2, 5, 10]], [8, [1, 3, 5, 10]], [9, [1, 3, 5, 10]], [11, [1, 3, 5, 10]], [13, [1, 3, 5, 10]]]", "qwen2.5-coder-32b-instruct": "[[1, [1, 2, 5, 10]], [5, [1, 2, 5, 10]], [6, [1, 3, 5, 10]], [10, [1, 2, 5, 10]], [12, [1, 3, 5, 10]], [53, [1, 2, 5, 25]], [7, [1, 1, 1, 25]], [0, [1, 2, 5, 10]], [100, [1, 5, 10, 25]], [3, [1, 1, 1, 1]], [8, [1, 3, 3, 3]], [9, [2, 3, 5, 10]], [15, [1, 6, 10, 25]], [23, [1, 5, 10, 25]]]"}}
{"requirement": "from typing import List\n\n\ndef adjacent_element_product(array: List[int]) -> int:\n\"\"\"## Task\n\n**_Given_** *an array of integers* , **_Find_** **_the maximum product_** *obtained from multiplying 2 adjacent numbers in the array*.\n____\n\n# Notes\n\n* **_Array/list_** size is *at least 2*.\n\n* **_Array/list_** numbers could be a *mixture of positives, negatives also zeroes* .\n___\n\n# Input >> Output Examples\n```\nadjacentElementsProduct([1, 2, 3]); ==> return 6\n```\n\n## **_Explanation_**:\n\n* **_The maximum product_** *obtained from multiplying* ` 2 * 3 = 6 `, and **_they're adjacent numbers in the array_**.\n___\n```\nadjacentElementsProduct([9, 5, 10, 2, 24, -1, -48]); ==> return 50\n```\n## **_Explanation_**:\n**_Max product_** obtained *from multiplying*   ``` 5 * 10  =  50  ```.\n___\n```\nadjacentElementsProduct([-23, 4, -5, 99, -27, 329, -2, 7, -921])  ==>  return -14\n```\n\n## **_Explanation_**:\n\n* **_The maximum product_** *obtained from multiplying* ` -2 * 7 = -14 `, and **_they're adjacent numbers in the array_**.\n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n\"\"\"", "inputs": [[[5, 8]], [[5, 1, 1, 8]], [[1, 2, 3]], [[1, 5, 10, 9]], [[4, 12, 3, 1, 5]], [[5, 1, 2, 3, 1, 4]], [[3, 6, -2, -5, 7, 3]], [[9, 5, 10, 2, 24, -1, -48]], [[5, 6, -4, 2, 3, 2, -23]], [[-23, 4, -5, 99, -27, 329, -2, 7, -921]], [[1, 0, 1, 0, 1000]], [[1, 2, 3, 0]]], "outputs": [[40], [8], [6], [90], [48], [6], [21], [50], [30], [-14], [0], [6]], "starter_code": "from typing import List\ndef adjacent_element_product(array: List[int]) -> int:", "canonical_solution": "def adjacent_element_product(array):\n    return max((a * b for a, b in zip(array, array[1:])))", "entry_point": "adjacent_element_product", "task_id": "TACO_lite/1308", "input_output_examples": "[[[[1, 2, 3]], [[9, 5, 10, 2, 24, -1, -48]], [[-23, 4, -5, 99, -27, 329, -2, 7, -921]]], [[6], [50], [-14]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3]], [[9, 5, 10, 2, 24, -1, -48]], [[-23, 4, -5, 99, -27, 329, -2, 7, -921]], [[0, 0, 0, 0]], [[-1, -2, -3, -4]], [[5, -5, 5, -5, 5]], [[1000000, 2000000]], [[-1000000, 2000000]], [[1, 0, -1]], [[2, 3, -2, 5, -1]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3]], [[9, 5, 10, 2, 24, -1, -48]], [[-23, 4, -5, 99, -27, 329, -2, 7, -921]], [[0, 0, 0, 0]], [[1, -1, 1, -1]], [[100, 200]], [[-10, -20, -30, -40]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[-1, 0, 1]], [[1000, -1000, 500, -500]]]"}}
{"requirement": "def find_closest_value(m: int) -> int:\n\"\"\"The first positive integer, `n`, with its value `4n² + 1`, being divisible by `5` and `13` is `4`. (condition 1)\n\nIt can be demonstrated that we have infinite numbers that may satisfy the above condition.\n\nIf we name **ai**, the different terms of the sequence of numbers with this property, we define `S(n)` as:\n\n\n\nWe are interested in working with numbers of this sequence from 10 to 15 digits. Could you elaborate a solution for these results?\n\n\n\nYou will be given an integer value `m`(always valid an positive) and you should output the closest value of the sequence to `m`.\n\nIf the given value `m` is in the sequence, your solution should return the same value.\n\nIn the case that there are two possible solutions: `s1` and `s2`, (`s1 < s2`), because `|m - s1| = |m - s2|`, output the highest solution `s2`\n\nNo hardcoded solutions are allowed.\n\nNo misterious formulae are required, just good observation to discover hidden patterns.\n\nSee the example tests to see output format and useful examples, edge cases are included.\n\nFeatures of the random tests\n`1000 <= m <= 5.2 e14`\n\n**Note** Sierpinsky presented the numbers that satisfy condition (1)\n\"\"\"", "inputs": [[1], [5000], [7500], [8300], [14313], [20005], [18331], [18332]], "outputs": [[4], [5074], [7293], [8320], [14313], [20293], [17944], [18720]], "starter_code": "def find_closest_value(m: int) -> int:", "canonical_solution": "def sierpinski():\n    x = s = 0\n    while 1:\n        for a in (4, 9, 56, 61):\n            s += x + a\n            yield s\n        x += 65\ns = sierpinski()\nS = [next(s)]\nfrom bisect import bisect_left\n\ndef find_closest_value(m):\n    while S[-1] < m:\n        S.append(next(s))\n    i = bisect_left(S, m)\n    return min(S[i:i - 2:-1], key=lambda n: abs(m - n))", "entry_point": "find_closest_value", "task_id": "TACO_lite/1314", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[1000], [500000000000], [1234567890123], [4], [9999999999999], [10000000000000], [520000000000000], [100000000000000], [99999999999999], [123456789012345]]", "qwen2.5-coder-32b-instruct": "[[1000], [520000000000000], [4], [208], [10400], [10401], [5200], [5201], [1000000000000], [1000000000001]]"}}
{"requirement": "def cumulative_triangle(n: int) -> float:\n\"\"\"Imagine a triangle of numbers which follows this pattern:\n\n * Starting with the number \"1\", \"1\" is positioned at the top of the triangle. As this is the 1st row, it can only support a single number.\n * The 2nd row can support the next 2 numbers: \"2\" and \"3\"\n * Likewise, the 3rd row, can only support the next 3 numbers: \"4\", \"5\", \"6\"\n * And so on; this pattern continues.\n\n```\n    1\n   2 3\n  4 5 6\n 7 8 9 10\n...\n```\n\nGiven N, return the sum of all numbers on the Nth Row:\n\n1 <= N <= 10,000\n\"\"\"", "inputs": [[1], [2], [3], [4], [15], [150], [100], [500], [1000], [10000]], "outputs": [[1], [5], [15], [34], [1695], [1687575], [500050], [62500250], [500000500], [500000005000]], "starter_code": "def cumulative_triangle(n: int) -> float:", "canonical_solution": "def cumulative_triangle(n):\n    return n * (n * n + 1) / 2", "entry_point": "cumulative_triangle", "task_id": "TACO_lite/1319", "input_output_examples": "[[[1], [2], [3], [4]], [[1], [5], [15], [34]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [4], [5], [10], [100], [10000]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [10], [100], [1000], [10000]]"}}
{"requirement": "from typing import List\n\n\ndef calculate_scrap(arr: List[float], n: int) -> int:\n\"\"\"# Explanation\n\nIt's your first day in the robot factory and your supervisor thinks that you should start with an easy task. So you are responsible for purchasing raw materials needed to produce the robots.\n\nA complete robot weights `50` kilogram. Iron is the only material needed to create a robot. All iron is inserted in the first machine; the output of this machine is the input for the next one, and so on. The whole process is sequential. Unfortunately not all machines are first class, so a given percentage of their inputs are destroyed during processing.\n\n# Task\n\nYou need to figure out how many kilograms of iron you need to buy to build the requested number of robots.\n\n# Example\n\nThree machines are used to create a robot. Each of them produces `10%` scrap. Your target is to deliver `90` robots.  \nThe method will be called with the following parameters:\n\n```\nCalculateScrap(scrapOfTheUsedMachines, numberOfRobotsToProduce)\nCalculateScrap(int[] { 10, 10, 10 }, 90)\n```\n\n# Assumptions\n\n* The scrap is less than `100%`.\n* The scrap is never negative.\n* There is at least one machine in the manufacturing line.\n* Except for scrap there is no material lost during manufacturing.\n* The number of produced robots is always a positive number.\n* You can only buy full kilograms of iron.\n\"\"\"", "inputs": [[[10], 90], [[20, 10], 55], [[0], 90], [[0, 0, 0], 90], [[10, 0], 90], [[0, 10], 90], [[10, 0, 0, 10], 81], [[0, 10, 0, 10], 81], [[0, 10, 10, 0], 81], [[10, 20, 30, 40, 50, 60, 70, 80, 90], 25], [[90, 80, 70, 60, 50, 40, 30, 20, 10], 20], [[10, 0, 30, 0, 50, 0, 70, 0, 90], 25], [[22, 33, 44, 10, 0, 0, 0, 88, 12], 33], [[22, 33, 44, 10, 0, 0, 0, 88, 12, 10, 0, 30, 0, 50, 0, 70, 0, 90], 13], [[47, 69, 28, 20, 41, 71, 84, 56, 62, 3, 74, 35, 25, 4, 57, 73, 64, 35, 78, 51], 8], [[38, 38, 73, 9, 3, 47, 86, 67, 75, 52, 46, 86, 30, 37, 80, 48, 52, 0, 85, 72], 11], [[71, 82, 47, 72, 5, 75, 69, 30, 16, 43, 10, 11, 64, 53, 12, 78, 23, 7, 24, 85], 12], [[81, 31, 24, 55, 42, 10, 68, 28, 12, 38, 60, 62, 66, 96, 51, 54, 89, 1, 4, 27], 9]], "outputs": [[5000], [3820], [4500], [4500], [5000], [5000], [5000], [5000], [5000], [3444665], [2755732], [132276], [59323], [2472964], [2671381450], [29229344539], [1465387910], [4301282783]], "starter_code": "from typing import List\ndef calculate_scrap(arr: List[float], n: int) -> int:", "canonical_solution": "from math import ceil\n\ndef calculate_scrap(arr, n):\n    x = 50\n    for i in arr:\n        x /= 1 - i / 100\n    return ceil(n * x)", "entry_point": "calculate_scrap", "task_id": "TACO_lite/1320", "input_output_examples": "[[[[10, 10, 10], 90]], [[1205]]]", "llm_generated_inputs": {"deepseek-v3": "[[[10, 10, 10], 90], [[20, 30, 40], 50], [[5], 100], [[0, 0, 0], 100], [[99, 99, 99], 1], [[50], 10], [[10], 0], [[10, 20, 30, 40], 200], [[1], 1000], [[10, 10], 50]]", "qwen2.5-coder-32b-instruct": "[[[10, 10, 10], 90], [[5, 5, 5, 5], 100], [[0, 0, 0], 50], [[99], 1], [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1000], [[20, 30, 40], 50], [[50, 50], 2], [[10], 1], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1], [[10, 20, 30, 40, 50], 1]]"}}
{"requirement": "def divisible_by_three(s: str) -> bool:\n\"\"\"A trick I learned in elementary school to determine whether or not a number was divisible by three is to add all of the integers in the number together and to divide the resulting sum by three. If there is no remainder from dividing the sum by three, then the original number is divisible by three as well.\n\n\n\nGiven a series of numbers as a string, determine if the number represented by the string is divisible by three.\n\nYou can expect all test case arguments to be strings representing values greater than 0. \n\nExample:\n\n```\n\"123\"      -> true\n\"8409\"     -> true\n\"100853\"   -> false\n\"33333333\" -> true\n\"7\"        -> false\n```\n\"\"\"", "inputs": [["123"], ["19254"], ["88"], ["1"], ["963210456"], ["10110101011"], ["9"], ["6363"], ["10987654321"], ["9876543211234567890009"], ["9876543211234567890002"]], "outputs": [[true], [true], [false], [false], [true], [false], [true], [true], [false], [true], [false]], "starter_code": "def divisible_by_three(s: str) -> bool:", "canonical_solution": "def divisible_by_three(s):\n    return int(s) % 3 == 0", "entry_point": "divisible_by_three", "task_id": "TACO_lite/1323", "input_output_examples": "[[['123'], ['8409'], ['100853'], ['33333333'], ['7']], [[True], [True], [False], [True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[['123'], ['8409'], ['100853'], ['33333333'], ['7'], ['0'], ['111111111111111111111111111111'], ['999'], ['1000000000000000000000000000001']]", "qwen2.5-coder-32b-instruct": "[['123'], ['8409'], ['100853'], ['33333333'], ['7'], ['0'], ['9'], ['999999999'], ['111'], ['369'], ['1'], ['2'], ['4'], ['5'], ['8'], ['11'], ['22'], ['33']]"}}
{"requirement": "from typing import List\n\n\ndef new_numeral_system(n: str) -> List[str]:\n\"\"\"# Task\n Your Informatics teacher at school likes coming up with new ways to help you understand the material. When you started studying numeral systems, he introduced his own numeral system, which he's convinced will help clarify things. His numeral system has base 26, and its digits are represented by English capital letters - `A for 0, B for 1, and so on`.\n\n The teacher assigned you the following numeral system exercise: given a one-digit `number`, you should find all unordered pairs of one-digit numbers whose values add up to the `number`.\n\n# Example\n\n For `number = 'G'`, the output should be `[\"A + G\", \"B + F\", \"C + E\", \"D + D\"]`\n\n Translating this into the decimal numeral system we get: number = 6, so it is `[\"0 + 6\", \"1 + 5\", \"2 + 4\", \"3 + 3\"]`.\n\n# Input/Output\n\n - `[input]` string(char in C#) `number`\n\n   A character representing a correct one-digit number in the new numeral system.\n\n   Constraints: `'A' ≤ number ≤ 'Z'.`\n\n - `[output]` a string array\n\n   An array of strings in the format \"letter1 + letter2\", where \"letter1\" and \"letter2\" are correct one-digit numbers in the new numeral system. The strings should be sorted by \"letter1\".\n\n   Note that \"letter1 + letter2\" and \"letter2 + letter1\" are equal pairs and we don't consider them to be different.\n\"\"\"", "inputs": [["G"], ["A"], ["D"], ["E"], ["O"]], "outputs": [[["A + G", "B + F", "C + E", "D + D"]], [["A + A"]], [["A + D", "B + C"]], [["A + E", "B + D", "C + C"]], [["A + O", "B + N", "C + M", "D + L", "E + K", "F + J", "G + I", "H + H"]]], "starter_code": "from typing import List\ndef new_numeral_system(n: str) -> List[str]:", "canonical_solution": "def new_numeral_system(n):\n    a = [c for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if c <= n]\n    return ['{} + {}'.format(a[i], a[-1 - i]) for i in range((len(a) + 1) // 2)]", "entry_point": "new_numeral_system", "task_id": "TACO_lite/1327", "input_output_examples": "[[['G']], [[['A + G', 'B + F', 'C + E', 'D + D']]]]", "llm_generated_inputs": {"deepseek-v3": "[['A'], ['B'], ['C'], ['Z'], ['G'], ['M']]", "qwen2.5-coder-32b-instruct": "[['A'], ['B'], ['C'], ['D'], ['E'], ['F'], ['G'], ['H'], ['I'], ['J'], ['K'], ['L'], ['M'], ['N'], ['O'], ['P'], ['Q'], ['R'], ['S'], ['T'], ['U'], ['V'], ['W'], ['X'], ['Y'], ['Z']]"}}
{"requirement": "def next_higher(n: int, k: int) -> int:\n\"\"\"If we multiply the integer      `717 (n)` by `7 (k)`, the result will be equal to `5019`.\n\nConsider all the possible ways that this last number may be split as a string and calculate their corresponding sum obtained by adding the substrings as integers. When we add all of them up,... surprise, we got the original number `717`:\n\n```\nPartitions as string                Total Sums\n['5', '019']                        5 + 19 = 24\n['50', '19']                       50 + 19 = 69\n['501', '9']                      501 + 9 = 510\n['5', '0', '19']                5 + 0 + 19 = 24\n['5', '01', '9']                 5 + 1 + 9 = 15\n['50', '1', '9']                50 + 1 + 9 = 60\n['5', '0', '1', '9']         5 + 0 + 1 + 9 = 15\n                            ____________________\n                              Big Total:    717\n                            ____________________\n```\nIn fact, `717` is one of the few integers that has such property with a factor `k = 7`.\n\nChanging the factor `k`, for example to `k = 3`, we may see that the integer `40104` fulfills this property.\n\nGiven an integer `start_value` and an integer `k`, output the smallest integer `n`, but higher than `start_value`, that fulfills the above explained properties.\n\nIf by chance, `start_value`, fulfills the property, do not return `start_value` as a result, only the next integer. Perhaps you may find this assertion redundant if you understood well the requirement of the kata: \"output the smallest integer `n`, but higher than `start_value`\"\n\nThe values for `k` in the input may be one of these: `3, 4, 5, 7`\n\n### Features of the random tests\n\nIf you want to understand the style and features of the random tests, see the *Notes* at the end of these instructions.\n\nThe random tests are classified in three parts.\n\n- Random tests each with one of the possible values of `k` and a random `start_value` in the interval `[100, 1300]`\n- Random tests each with a `start_value` in a larger interval for each value of `k`, as follows:\n - for `k = 3`, a random `start value` in the range `[30000, 40000]`\n - for `k = 4`, a random `start value` in the range `[2000, 10000]`\n - for `k = 5`, a random `start value` in the range `[10000, 20000]`\n - for `k = 7`, a random `start value` in the range `[100000, 130000]`\n- More challenging tests, each with a random `start_value` in the interval `[100000, 110000]`.\n\n\n\nSee the examples tests.\n\nEnjoy it.\n\n# Notes:\n\n- As these sequences are finite, in other words, they have a maximum term for each value of k, the tests are prepared in such way that the `start_value`  will always be less than this maximum term. So you may be confident that your code will always find an integer.\n\n- The values of `k` that generate sequences of integers, for the constrains of this kata are: 2, 3, 4, 5, and 7. The case `k = 2` was not included because it generates only two integers.\n\n- The sequences have like \"mountains\" of abundance of integers but also have very wide ranges like \"valleys\" of scarceness. Potential solutions, even the fastest ones, may time out searching the next integer due to an input in one of these valleys. So it was intended to avoid these ranges.\n\nJavascript and Ruby versions will be released soon.\n\"\"\"", "inputs": [[100, 3], [200, 4], [300, 5], [500, 7], [717, 7], [1611, 3]], "outputs": [[162], [260], [846], [717], [861], [1989]], "starter_code": "def next_higher(n: int, k: int) -> int:", "canonical_solution": "def sum_part(n):\n    m, p, q, r, s = (1, 1, 1, 0, n)\n    while n > 9:\n        n, d = divmod(n, 10)\n        r += d * p\n        p *= 10\n        if d:\n            m = 1\n        else:\n            m *= 2\n        s += q * n + m * memo[r]\n        q *= 2\n    return s\nfrom collections import defaultdict\nqualified = defaultdict(list)\nmemo = {n: n for n in range(10)}\nfor n in range(10, 10 ** 6):\n    memo[n] = sum_part(n)\n    if memo[n] > n:\n        k, r = divmod(n, memo[n] - n)\n        if not r:\n            qualified[k].append(memo[n] - n)\nfrom bisect import bisect\n\ndef next_higher(n, k):\n    return qualified[k][bisect(qualified[k], n + 1)]", "entry_point": "next_higher", "task_id": "TACO_lite/1343", "input_output_examples": "[[[717, 7]], [[5019]]]", "llm_generated_inputs": {"deepseek-v3": "[[717, 7], [40104, 3], [100, 3], [1000, 4], [10000, 5], [100000, 7], [500, 3], [30000, 3], [2000, 4], [10000, 5], [100000, 7], [100001, 3], [100001, 4], [100001, 5], [100001, 7], [110000, 3], [110000, 4], [110000, 5], [110000, 7], [1300, 3], [1300, 4], [1300, 5], [1300, 7]]", "qwen2.5-coder-32b-instruct": "[[716, 7], [40099, 3], [1999, 4], [9999, 5], [99999, 7], [109999, 3], [39999, 3], [19999, 4], [99999, 5], [129999, 7]]"}}
{"requirement": "def mouth_size(animal: str) -> str:\n\"\"\"The wide mouth frog is particularly interested in the eating habits of other creatures.\n\nHe just can't stop asking the creatures he encounters what they like to eat. But then he meet the alligator who just LOVES to eat wide-mouthed frogs!\n\nWhen he meets the alligator, it then makes a tiny mouth.\n\nYour goal in this kata is to create complete the `mouth_size` method this method take one argument `animal` which corresponds to the animal encountered by frog. If this one is an `alligator` (case insensitive) return `small` otherwise return `wide`.\n\"\"\"", "inputs": [["toucan"], ["ant bear"], ["alligator"]], "outputs": [["wide"], ["wide"], ["small"]], "starter_code": "def mouth_size(animal: str) -> str:", "canonical_solution": "def mouth_size(animal):\n    return 'small' if animal.lower() == 'alligator' else 'wide'", "entry_point": "mouth_size", "task_id": "TACO_lite/1345", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['alligator'], ['Alligator'], ['ALLIGATOR'], ['aLlIgAtOr'], ['frog'], ['bear'], ['snake'], [''], [' '], ['123'], ['alligator2']]", "qwen2.5-coder-32b-instruct": "[['alligator'], ['Alligator'], ['ALLIGATOR'], ['frog'], ['Frog'], ['FLY'], ['elephant'], ['ELEPHANT'], [' '], [''], ['alligatOr'], ['alligator '], [' alligator'], ['alligator!']]"}}
{"requirement": "from typing import List\n\n\ndef make_sentences(parts: List[str]) -> str:\n\"\"\"Implement a function, so it will produce a sentence out of the given parts.\n\nArray of parts could contain:\n- words;\n- commas in the middle;\n- multiple periods at the end.\n\nSentence making rules:\n- there must always be a space between words;\n- there must not be a space between a comma and word on the left;\n- there must always be one and only one period at the end of a sentence.\n\n**Example:**\n\"\"\"", "inputs": [[["hello", "world"]], [["Quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"]], [["hello", ",", "my", "dear"]], [["one", ",", "two", ",", "three"]], [["One", ",", "two", "two", ",", "three", "three", "three", ",", "4", "4", "4", "4"]], [["hello", "world", "."]], [["Bye", "."]], [["hello", "world", ".", ".", "."]], [["The", "Earth", "rotates", "around", "The", "Sun", "in", "365", "days", ",", "I", "know", "that", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."]]], "outputs": [["hello world."], ["Quick brown fox jumped over the lazy dog."], ["hello, my dear."], ["one, two, three."], ["One, two two, three three three, 4 4 4 4."], ["hello world."], ["Bye."], ["hello world."], ["The Earth rotates around The Sun in 365 days, I know that."]], "starter_code": "from typing import List\ndef make_sentences(parts: List[str]) -> str:", "canonical_solution": "def make_sentences(parts):\n    return ' '.join(parts).replace(' ,', ',').strip(' .') + '.'", "entry_point": "make_sentences", "task_id": "TACO_lite/1348", "input_output_examples": "[[[['Hello', ',', 'world', '...']]], [['Hello, world.']]]", "llm_generated_inputs": {"deepseek-v3": "[[['Hello', 'world']], [['Hello', ',', 'world']], [['Hello', 'world', '.', '.']], [['Hello', ',', 'world', '.', '.']], [['Hello', 'world', '!']], [['Hello', 'world', '.', '!']], [['Hello', ',', 'world', '.', '!']], [['Hello', 'world', ' ', '!']], [['Hello', 'world', ' ', '.']], [['Hello', 'world', ' ', ',', '!']], [['Hello', 'world', ' ', ',', '.']], [['Hello', 'world', ' ', ',', '!', '.']], [[]], [['.', '.', '.']], [[',', ',', ',']], [['Hello', ' ', 'world']], [['Hello', 'world', ' ', ' ', '!']]]", "qwen2.5-coder-32b-instruct": "[[['Hello', 'world']], [['This', 'is', 'a', 'test,sentence.']], [['Multiple', 'periods', 'here...']], [['No', 'spaces', 'after,commas,']], [['Singleword']], [['Comma,', 'at', 'the', 'end,']], [['...']], [[]], [['Trailing', 'space ', 'before', 'period.']], [['   Leading', 'and', 'trailing   ', 'spaces,']]]"}}
{"requirement": "def largest_sum(s: str) -> int:\n\"\"\"This kata is part of the collection [Mary's Puzzle Books](https://www.codewars.com/collections/marys-puzzle-books).\n\n# Zero Terminated Sum\n\nMary has another puzzle book, and it's up to you to help her out! This book is filled with zero-terminated substrings, and you have to find the substring with the largest sum of its digits. For example, one puzzle looks like this:\n```\n\"72102450111111090\"\n```\nHere, there are 4 different substrings: `721`, `245`, `111111`, and `9`. The sums of their digits are `10`, `11`, `6`, and `9` respectively. Therefore, the substring with the largest sum of its digits is `245`, and its sum is `11`.\n\nWrite a function `largest_sum` which takes a string and returns the maximum of the sums of the substrings. In the example above, your function should return `11`.\n\n### Notes:\n\n- A substring can have length 0. For example, `123004560` has three substrings, and the middle one has length 0.\n- All inputs will be valid strings of digits, and the last digit will always be `0`.\n\"\"\"", "inputs": [["72102450111111090"], ["123004560"], ["0"], ["4755843230"], ["3388049750"], ["3902864190"], ["4098611970"], ["5628206860"], ["5891002970"], ["0702175070"]], "outputs": [[11], [15], [0], [41], [25], [30], [41], [23], [23], [15]], "starter_code": "def largest_sum(s: str) -> int:", "canonical_solution": "def largest_sum(s):\n    return max((sum(map(int, x)) for x in s.split('0')))", "entry_point": "largest_sum", "task_id": "TACO_lite/1350", "input_output_examples": "[[['72102450111111090'], ['123004560']], [[11], [15]]]", "llm_generated_inputs": {"deepseek-v3": "[['72102450111111090'], ['123004560'], ['0000000'], ['9876543210'], ['5050505050'], ['1111111111111111111111111111110'], ['0'], ['9999999999999999999999999999990'], ['1002003004005006007008009000'], ['1234567890123456789012345678901234567890']]", "qwen2.5-coder-32b-instruct": "[['72102450111111090'], ['123004560'], ['0'], ['9999999990'], ['1010101010'], ['5050505050'], ['11111111110'], ['0000000000'], ['9080706050403020100'], ['1234567890']]"}}
{"requirement": "def is_audio(filename: str) -> bool:\n\"\"\"*Are you a file extension master? Let's find out by checking if Bill's files are images or audio files. Please use regex if available natively for your language.*\n\nYou will create 2 string methods:\n\n- **isAudio/is_audio**, matching 1 or + uppercase/lowercase letter(s) (combination possible), with the extension .mp3, .flac, .alac, or .aac.\n\n- **isImage/is_image**, matching 1 or + uppercase/lowercase letter(s) (combination possible), with the extension .jpg, .jpeg, .png, .bmp, or .gif. \n\n\n*Note that this is not a generic image/audio files checker. It's meant to be a test for Bill's files only. Bill doesn't like punctuation. He doesn't like numbers, neither. Thus, his filenames are letter-only*\n\n**Rules**\n\n1. It should return true or false, simply.\n2. File extensions should consist of lowercase letters and numbers only.\n3. File names should consist of letters only (uppercase, lowercase, or both)\n\nGood luck!\n\"\"\"", "inputs": [["Nothing Else Matters.mp3"], ["NothingElseMatters.mp3"], ["DaftPunk.FLAC"], ["DaftPunk.flac"], ["AmonTobin.aac"], [" Amon Tobin.alac"], ["tobin.alac"]], "outputs": [[false], [true], [false], [true], [true], [false], [true]], "starter_code": "def is_audio(filename: str) -> bool:", "canonical_solution": "def is_audio(filename):\n    name, ext = filename.split('.')\n    return name.isalpha() and ext in {'mp3', 'flac', 'alac', 'aac'}\n\ndef is_img(filename):\n    name, ext = filename.split('.')\n    return name.isalpha() and ext in {'jpg', 'jpeg', 'png', 'bmp', 'gif'}", "entry_point": "is_audio", "task_id": "TACO_lite/1352", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['song.mp3'], ['music.flac'], ['audiofile.aac'], ['record.alac'], ['SONG.mp3'], ['MuSiC.flac'], ['AUDIOFILE.aac'], ['RECORD.alac'], ['song.MP3'], ['music.FLAC'], ['audiofile.AAC'], ['record.ALAC'], ['song'], ['music.txt'], ['audiofile.mp4'], ['record.wav'], ['song1.mp3'], ['music_file.flac'], ['audio-file.aac'], ['record!.alac'], ['.mp3'], ['song..mp3'], ['song.mp3.'], ['song.mp3.txt'], ['song.mp3.flac'], ['song.mp3.aac'], ['song.mp3.alac'], ['song.mp3.jpg'], ['song.mp3.jpeg'], ['song.mp3.png'], ['song.mp3.bmp'], ['song.mp3.gif']]", "qwen2.5-coder-32b-instruct": "[['song.mp3'], ['track.flac'], ['audio.alac'], ['music.aac'], ['Song.MP3'], ['Track.FLAC'], ['Audio.ALAC'], ['Music.AAC'], ['myAudioFile.mp3'], ['BillLikesFLAC.flac'], ['ALACTracks.alac'], ['AACfiles.aac'], ['noextension'], ['image.jpg'], ['doc.txt'], ['file..mp3'], ['.mp3'], ['mp3'], ['A.B.C.mp3'], ['ValidNameWithLettersOnly.mp3'], ['Invalid_Name_With_Underscore.mp3'], ['Invalid-Name-With-Hyphen.mp3'], ['123numbersinname.mp3'], ['numbers123.mp3']]"}}
{"requirement": "def duplicate_count(s: str) -> int:\n\"\"\"### Count the number of Duplicates\n\nWrite a function that will return the count of **distinct case-insensitive** alphabetic characters and numeric digits that occur more than \nonce in the input string. \nThe input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.\n\n\n### Example\n\"abcde\" -> 0             `# no characters repeats more than once`  \n\"aabbcde\" -> 2           `# 'a' and 'b'`  \n\"aabBcde\" -> 2           ``# 'a' occurs twice and 'b' twice (`b` and `B`)``  \n\"indivisibility\" -> 1    `# 'i' occurs six times`  \n\"Indivisibilities\" -> 2  `# 'i' occurs seven times and 's' occurs twice`  \n\"aA11\" -> 2              `# 'a' and '1'`  \n\"ABBA\" -> 2              `# 'A' and 'B' each occur twice`\n\"\"\"", "inputs": [[""], ["abcde"], ["abcdeaa"], ["abcdeaB"], ["Indivisibilities"]], "outputs": [[0], [0], [1], [2], [2]], "starter_code": "def duplicate_count(s: str) -> int:", "canonical_solution": "def duplicate_count(s):\n    return len([c for c in set(s.lower()) if s.lower().count(c) > 1])", "entry_point": "duplicate_count", "task_id": "TACO_lite/1356", "input_output_examples": "[[['abcde'], ['aabbcde'], ['aabBcde'], ['indivisibility'], ['Indivisibilities'], ['aA11'], ['ABBA']], [[0], [2], [2], [1], [2], [2], [2]]]", "llm_generated_inputs": {"deepseek-v3": "[['abcde'], ['aabbcde'], ['aabBcde'], ['indivisibility'], ['Indivisibilities'], ['aA11'], ['ABBA'], [''], ['11223344556677889900'], ['AaBbCcDdEeFfGgHh'], ['!@#$%^&*()'], ['aA11!!22'], ['a'], ['aa']]", "qwen2.5-coder-32b-instruct": "[['abcde'], ['aabbcde'], ['aabBcde'], ['indivisibility'], ['Indivisibilities'], ['aA11'], ['ABBA'], ['1234567890'], ['11223344556677889900'], ['aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz'], ['AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'], [''], ['a'], ['Aa'], ['1'], ['11']]"}}
{"requirement": "def derivative(eq: str) -> str:\n\"\"\"Complete the function that calculates the derivative of a polynomial. A polynomial is an expression like: 3x^(4) - 2x^(2) + x - 10\n\n### How to calculate the derivative:\n\n* Take the exponent and multiply it with the coefficient\n* Reduce the exponent by 1\n\nFor example: 3x^(4) --> (4*3)x^((4-1)) = 12x^(3)\n\n### Good to know:\n\n* The derivative of a constant is 0 (e.g. 100 --> 0)\n* Anything to the 0th exponent equals 1 (e.g. x^(0) = 1)\n* The derivative of the sum of two function is the sum of the derivatives\n\nNotes:\n* The exponentiation is marked with \"^\"\n* Exponents are always integers and >= 0\n* Exponents are written only if > 1\n* There are no spaces around the operators\n* Leading \"+\" signs are omitted\n\nSee the examples below.\n\n## Examples\n```python\nderivative(\"-100\")      = \"0\"\nderivative(\"4x+1\")      = \"4\"      # = 4x^0 + 0\nderivative(\"-x^2+3x+4\") = \"-2x+3\"  # = -2x^1 + 3x^0 + 0\n```\n\"\"\"", "inputs": [["4x+1"], ["-4x-1"], ["x^2+2x+1"], ["0"], ["-100"], ["-x^2+3x+4"], ["-x^5-x^4-x^3"], ["10x^9+10x^3+10x"], ["100x^5+12x^3-3x-3"], ["-1000x^7+200x^4+6x^2+x+1000"]], "outputs": [["4"], ["-4"], ["2x+2"], ["0"], ["0"], ["-2x+3"], ["-5x^4-4x^3-3x^2"], ["90x^8+30x^2+10"], ["500x^4+36x^2-3"], ["-7000x^6+800x^3+12x+1"]], "starter_code": "def derivative(eq: str) -> str:", "canonical_solution": "import re\nmy_regexp = '(?P<sign>[+\\\\-]?)(?P<coeff>\\\\d*)x(?:\\\\^(?P<exp>\\\\d+))?'\nas_int = lambda s: int(s) if s else 1\n\ndef derivative(eq):\n    result = ''\n    for monom in re.finditer(my_regexp, eq):\n        sign, coeff, exp = monom.groups()\n        coeff, exp = list(map(as_int, (coeff, exp)))\n        coeff *= exp\n        exp -= 1\n        result += ('{sign}{coeff}' if exp == 0 else '{sign}{coeff}x' if exp == 1 else '{sign}{coeff}x^{exp}').format(sign=sign, coeff=coeff, exp=exp)\n    return result if result else '0'", "entry_point": "derivative", "task_id": "TACO_lite/1361", "input_output_examples": "[[['-100'], ['4x+1'], ['-x^2+3x+4']], [['0'], ['4'], ['-2x+3']]]", "llm_generated_inputs": {"deepseek-v3": "[['3x^4-2x^2+x-10'], ['-100'], ['4x+1'], ['-x^2+3x+4'], ['x'], ['x^3'], ['0'], ['-x'], ['5x^0'], ['2x^1'], ['x^2+2x+1'], ['-3x^3+2x^2-x+7']]", "qwen2.5-coder-32b-instruct": "[['-100'], ['4x+1'], ['-x^2+3x+4'], ['3x^4-2x^2+x-10'], ['x'], ['x^5'], ['5'], ['0'], ['2x^3-4x^2+3x-1'], ['7x^7-6x^6+5x^5-4x^4+3x^3-2x^2+x-0'], ['-3x^2'], ['2x^2'], ['x^2-x+1']]"}}
{"requirement": "def nb_year(population: int, percent: float, aug: int, target: int) -> int:\n\"\"\"In a small town the population is `p0 = 1000` at the beginning of a year. The population\nregularly increases by `2 percent` per year and moreover `50` new inhabitants per year\ncome to live in the town. \nHow many years does the town need to see its population\ngreater or equal to `p = 1200` inhabitants?\n\n```\nAt the end of the first year there will be: \n1000 + 1000 * 0.02 + 50 => 1070 inhabitants\n\nAt the end of the 2nd year there will be: \n1070 + 1070 * 0.02 + 50 => 1141 inhabitants (number of inhabitants is an integer)\n\nAt the end of the 3rd year there will be:\n1141 + 1141 * 0.02 + 50 => 1213\n\nIt will need 3 entire years.\n```\nMore generally given parameters:\n\n`p0, percent, aug (inhabitants coming or leaving each year), p (population to surpass)`\n\nthe function `nb_year` should return `n` number of entire years needed to\nget a population greater or equal to `p`.\n\naug is an integer, percent a positive or null number, p0 and p are positive integers (> 0)\n```\nExamples:\nnb_year(1500, 5, 100, 5000) -> 15\nnb_year(1500000, 2.5, 10000, 2000000) -> 10\n```\n\nNote: Don't forget to convert the percent parameter as a percentage in the body of your function: if the parameter percent is 2 you have to convert it to 0.02.\n\"\"\"", "inputs": [[1500, 5, 100, 5000], [1500000, 2.5, 10000, 2000000], [1500000, 0.25, 1000, 2000000], [1500000, 0.25, -1000, 2000000], [1500000, 0.25, 1, 2000000], [1500000, 0.0, 10000, 2000000]], "outputs": [[15], [10], [94], [151], [116], [50]], "starter_code": "def nb_year(population: int, percent: float, aug: int, target: int) -> int:", "canonical_solution": "def nb_year(population, percent, aug, target):\n    year = 0\n    while population < target:\n        population += population * percent / 100.0 + aug\n        year += 1\n    return year", "entry_point": "nb_year", "task_id": "TACO_lite/1362", "input_output_examples": "[[[1500, 5, 100, 5000], [1500000, 2.5, 10000, 2000000]], [[15], [10]]]", "llm_generated_inputs": {"deepseek-v3": "[[1000, 2.0, 50, 1200], [1500, 5.0, 100, 5000], [1500000, 2.5, 10000, 2000000], [1000, 0.0, 0, 1000], [1000, 0.0, 50, 1050], [1000, 100.0, 0, 2000], [1000, -2.0, 50, 1200], [1000, 2.0, -50, 1200], [1000, 2.0, 50, 1000], [1000, 2.0, 50, 999]]", "qwen2.5-coder-32b-instruct": "[[1000, 2, 50, 1200], [1500, 5, 100, 5000], [1500000, 2.5, 10000, 2000000], [1000, 0, 50, 1500], [1000, 2, 0, 2000], [1000, 0, 0, 1000], [1000, 100, 0, 2000], [1, 0, 1, 2], [1000, 2, -50, 1000]]"}}
{"requirement": "from typing import List\n\n\ndef is_odd_heavy(arr: List[int]) -> bool:\n\"\"\"An array is defined to be `odd-heavy` if it contains at least one odd element and every element whose value is `odd` is greater than \nevery even-valued element. \n\neg.\n```\nArray [11,4,9,2,8] is odd-heavy \nbecause:- its odd elements [11,9] are greater than all the even elements [4,2,8]\n\nArray [11,4,9,2,3,10] is not odd-heavy\nbecause:- one of it's even element 10 from [4,2,10] is greater than two of its odd elements [9,3] from [ 11,9,3]\n\n```\nwrite a function called `isOddHeavy` or `is_odd_heavy` that accepts an integer array and returns `true` if the array is `odd-heavy` else return `false`.\n\"\"\"", "inputs": [[[0, 2, 19, 4, 4]], [[1, -2, -1, 2]], [[-3, 2, 1, 3, -1, -2]], [[3, 4, -2, -3, -2]], [[-1, 1, -2, 2, -2, -2, -4, 4]], [[-1, -2, 21]], [[0, 0, 0, 0]], [[0, -1, 1]], [[0, 2, 3]], [[0]], [[]], [[1]], [[0, 1, 2, 3, 4, 0, -2, -1, -4, -3]], [[1, -1, 3, -1]], [[1, -1, 2, -2, 3, -3, 0]], [[3]], [[2, 4, 6]], [[-2, -4, -6, -8, -11]]], "outputs": [[true], [false], [false], [false], [false], [true], [false], [false], [true], [false], [false], [true], [false], [true], [false], [true], [false], [false]], "starter_code": "from typing import List\ndef is_odd_heavy(arr: List[int]) -> bool:", "canonical_solution": "def is_odd_heavy(arr):\n    maxEven, minOdd = (f(filter(lambda n: n % 2 == v, arr), default=float('-inf')) for f, v in ((max, 0), (min, 1)))\n    return maxEven < minOdd", "entry_point": "is_odd_heavy", "task_id": "TACO_lite/1363", "input_output_examples": "[[[[11, 4, 9, 2, 8]], [[11, 4, 9, 2, 3, 10]]], [[True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[[11, 4, 9, 2, 8]], [[11, 4, 9, 2, 3, 10]], [[1]], [[2]], [[1, 3, 5, 7]], [[2, 4, 6, 8]], [[0, 0, 0, 1]], [[-1, -2, -3, -4]], [[]], [[100, 101, 102, 103]], [[100, 101, 102, 99]]]", "qwen2.5-coder-32b-instruct": "[[[11, 4, 9, 2, 8]], [[11, 4, 9, 2, 3, 10]], [[1, 3, 5, 7, 9]], [[2, 4, 6, 8, 10]], [[13, 2, 15, 4, 17, 6]], [[1]], [[2]], [[]], [[1, 2]], [[2, 1]], [[3, 3, 3, 2, 2]], [[2, 2, 2, 3, 3]]]"}}
{"requirement": "def bouncing_ball(initial: float, proportion: float) -> int:\n\"\"\"You drop a ball from a given height. After each bounce, the ball returns to some fixed proportion of its previous height. If the ball bounces to height 1 or less, we consider it to have stopped bouncing. Return the number of bounces it takes for the ball to stop moving.\n\n\n\n```\nbouncingBall(initialHeight, bouncingProportion)\n\nboucingBall(4, 0.5)\nAfter first bounce, ball bounces to height 2\nAfter second bounce, ball bounces to height 1\nTherefore answer is 2 bounces\n\nboucingBall(30, 0.3)\nAfter first bounce, ball bounces to height 9\nAfter second bounce, ball bounces to height 2.7\nAfter third bounce, ball bounces to height 0.81\nTherefore answer is 3 bounces\n\n\n```\n\nInitial height is an integer in range [2,1000]\n\nBouncing Proportion is a decimal in range [0, 1)\n\"\"\"", "inputs": [[2, 0.5], [4, 0.5], [10, 0.1], [100, 0.1], [9, 0.3], [30, 0.3]], "outputs": [[1], [2], [1], [2], [2], [3]], "starter_code": "def bouncing_ball(initial: float, proportion: float) -> int:", "canonical_solution": "import math\n\ndef bouncing_ball(initial, proportion):\n    return math.ceil(math.log(initial, 1 / proportion))", "entry_point": "bouncing_ball", "task_id": "TACO_lite/1373", "input_output_examples": "[[[4, 0.5], [30, 0.3]], [[2], [3]]]", "llm_generated_inputs": {"deepseek-v3": "[[4, 0.5], [30, 0.3], [2, 0.99], [1000, 0.01], [10, 0.9], [50, 0.5], [1, 0.5], [1001, 0.5], [5, -0.1], [5, 1.0], [5, 1.1]]", "qwen2.5-coder-32b-instruct": "[[4, 0.5], [30, 0.3], [2, 0.99], [1000, 0.01], [5, 0.0], [10, 0.5], [7, 0.7], [8, 0.25], [6, 0.9], [999, 0.999]]"}}
{"requirement": "from typing import List\n\n\ndef josephus(xs: List[int], k: int) -> List[int]:\n\"\"\"This problem takes its name by arguably the most important event in the life of the ancient historian Josephus: according to his tale, he and his 40 soldiers were trapped in a cave by the Romans during a siege.\n\nRefusing to surrender to the enemy, they instead opted for mass suicide, with a twist: **they formed a circle and proceeded to kill one man every three, until one last man was left (and that it was supposed to kill himself to end the act)**.\n\nWell, Josephus and another man were the last two and, as we now know every detail of the story, you may have correctly guessed that they didn't exactly follow through the original idea.\n\nYou are now to create a function that returns a Josephus permutation, taking as parameters the initial *array/list of items* to be permuted as if they were in a circle and counted out every *k* places until none remained.\n\n**Tips and notes:** it helps to start counting from 1 up to n, instead of the usual range 0..n-1; k will always be >=1.\n\nFor example, with n=7 and k=3 `josephus(7,3)` should act this way.\n```\n[1,2,3,4,5,6,7] - initial sequence\n[1,2,4,5,6,7] => 3 is counted out and goes into the result [3]\n[1,2,4,5,7] => 6 is counted out and goes into the result [3,6]\n[1,4,5,7] => 2 is counted out and goes into the result [3,6,2]\n[1,4,5] => 7 is counted out and goes into the result [3,6,2,7]\n[1,4] => 5 is counted out and goes into the result [3,6,2,7,5]\n[4] => 1 is counted out and goes into the result [3,6,2,7,5,1]\n[] => 4 is counted out and goes into the result [3,6,2,7,5,1,4]\n```\nSo our final result is:\n```\njosephus([1,2,3,4,5,6,7],3)==[3,6,2,7,5,1,4]\n```\nFor more info, browse the Josephus Permutation page on wikipedia; related kata: Josephus Survivor.\n\nAlso, [live game demo](https://iguacel.github.io/josephus/) by [OmniZoetrope](https://www.codewars.com/users/OmniZoetrope).\n\"\"\"", "inputs": [[[], 1], [[], 2], [[], 4], [[], 4], [[], 3], [[], 3], [[], 11], [[], 40], [[], 3], [[], 9]], "outputs": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[2, 4, 6, 8, 10, 3, 7, 1, 9, 5]], [["e", "s", "W", "o", "C", "d", "r", "a"]], [[3, 5, "W", 0, "C", "d", "r", 4]], [[3, 6, 2, 7, 5, 1, 4]], [[]], [[11, 22, 33, 44, 5, 17, 29, 41, 3, 16, 30, 43, 7, 21, 36, 50, 15, 32, 48, 14, 34, 1, 20, 39, 9, 28, 2, 25, 47, 24, 49, 27, 8, 38, 19, 6, 42, 35, 26, 23, 31, 40, 4, 18, 12, 13, 46, 37, 45, 10]], [[10, 7, 8, 13, 5, 4, 12, 11, 3, 15, 14, 9, 1, 6, 2]], [[1]], [[true, true, true, false, false, true, false, true, false]]], "starter_code": "from typing import List\ndef josephus(xs: List[int], k: int) -> List[int]:", "canonical_solution": "def josephus(xs, k):\n    i, ys = (0, [])\n    while len(xs) > 0:\n        i = (i + k - 1) % len(xs)\n        ys.append(xs.pop(i))\n    return ys", "entry_point": "josephus", "task_id": "TACO_lite/1375", "input_output_examples": "[[[[1, 2, 3, 4, 5, 6, 7], 3]], [[[3, 6, 2, 7, 5, 1, 4]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 5, 6, 7], 3], [[1, 2, 3, 4, 5], 2], [[1, 2, 3], 1], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4], [[1], 1], [[1, 2, 3, 4], 5], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 7], [[10, 20, 30, 40, 50], 3], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 4, 5, 6, 7], 3], [[1, 2, 3, 4, 5, 6, 7], 1], [[1, 2, 3, 4, 5, 6, 7], 7], [[1, 2, 3, 4, 5, 6, 7], 2], [[1], 1], [[1, 2], 1], [[1, 2], 2], [[1, 2, 3], 3], [[1, 2, 3, 4], 4], [[1, 2, 3, 4, 5], 5], [[1, 2, 3, 4, 5, 6], 6], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 8], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 9]]"}}
{"requirement": "def is_prime(n: int) -> bool:\n\"\"\"In this kata you will create a function to check a non-negative input to see if it is a prime number.\n\nThe function will take in a number and will return True if it is a prime number and False if it is not.\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n\n### Examples\n\"\"\"", "inputs": [[0], [1], [2], [11], [12], [61], [571], [573], [25]], "outputs": [[false], [false], [true], [true], [false], [true], [true], [false], [false]], "starter_code": "def is_prime(n: int) -> bool:", "canonical_solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    return all((n % i for i in range(3, int(math.sqrt(n)) + 1, 2)))", "entry_point": "is_prime", "task_id": "TACO_lite/1381", "input_output_examples": "[[[3], [4]], [[True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[2], [3], [4], [1], [0], [-1], [29], [30], [7919], [7920]]", "qwen2.5-coder-32b-instruct": "[[2], [3], [4], [5], [10], [13], [17], [19], [20], [23], [24], [29], [31], [37], [41], [43], [47], [53], [59], [61], [67], [71], [73], [79], [83], [89], [97], [100], [101], [0], [1], [-1], [-5], [1000], [1009]]"}}
{"requirement": "def points(dice: str) -> int:\n\"\"\"[Generala](https://en.wikipedia.org/wiki/Generala) is a dice game popular in South America. It's very similar to [Yahtzee](https://en.wikipedia.org/wiki/Yahtzee) but with a different scoring approach. It is played with 5 dice, and the possible results are:\n\n| Result        | Points | Rules                                                                                                                                          | Samples                            |\n|---------------|--------|------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------|\n| GENERALA      | 50     | When all rolled dice are of the same value.                                                                                                    | 66666, 55555, 44444, 11111, 22222, 33333.  |\n| POKER         | 40     | Four rolled dice are of the same value.                                                                                                        | 44441, 33233, 22262.               |\n| FULLHOUSE     | 30     | Three rolled dice are of the same value, the remaining two are of a different value, but equal among themselves.                               | 12121, 44455, 66116.               |\n| STRAIGHT      | 20     | Rolled dice are in sequential order. Dice with value `1` is a wildcard that can be used at the beginning of the straight, or at the end of it. | 12345, 23456, 34561, 13654, 62534. |\n| Anything else | 0      | Anything else will return `0` points.                                                                                                          | 44421, 61623, 12346.               |\n\nPlease note that dice are not in order; for example `12543` qualifies as a `STRAIGHT`. Also, No matter what string value you get for the dice, you can always reorder them any order you need to make them qualify as a `STRAIGHT`. I.E. `12453`, `16543`, `15364`, `62345` all qualify as valid `STRAIGHT`s.\n\n\n\nComplete the function that is given the rolled dice as a string of length `5` and return the points scored in that roll. You can safely assume that provided parameters will be valid:\n\n * String of length 5,\n * Each character will be a number between `1` and `6`\n\"\"\"", "inputs": [["55555"], ["44444"], ["44441"], ["33233"], ["22262"], ["12121"], ["44455"], ["66116"], ["12345"], ["23456"], ["34561"], ["13564"], ["62534"], ["44421"], ["61623"], ["12346"]], "outputs": [[50], [50], [40], [40], [40], [30], [30], [30], [20], [20], [20], [20], [20], [0], [0], [0]], "starter_code": "def points(dice: str) -> int:", "canonical_solution": "def points(dice):\n    dice = sorted([int(d) for d in dice])\n    counts = [dice.count(i) for i in range(1, 7)]\n    if 5 in counts:\n        return 50\n    if 4 in counts:\n        return 40\n    if 3 in counts and 2 in counts:\n        return 30\n    if counts.count(1) == 5 and counts.index(0) not in [2, 3, 4]:\n        return 20\n    return 0", "entry_point": "points", "task_id": "TACO_lite/1383", "input_output_examples": "[[['66666'], ['55555'], ['44444'], ['33333'], ['22222'], ['11111'], ['44441'], ['33233'], ['22262'], ['12121'], ['44455'], ['66116'], ['12345'], ['23456'], ['34561'], ['13654'], ['62534'], ['44421'], ['61623'], ['12346'], ['12543'], ['12453'], ['16543'], ['15364'], ['62345']], [[50], [50], [50], [50], [50], [50], [40], [40], [40], [30], [30], [30], [20], [20], [20], [20], [20], [0], [0], [0], [20], [20], [20], [20], [20]]]", "llm_generated_inputs": {"deepseek-v3": "[[66666], [44441], [12121], [12345], [23456], [34561], [13654], [62534], [44421], [61623], [12346], [11111], [22222], [33333], [44444], [55555], [33233], [22262], [44455], [66116]]", "qwen2.5-coder-32b-instruct": "[['66666'], ['55555'], ['44444'], ['11111'], ['22222'], ['33333'], ['44441'], ['33233'], ['22262'], ['12121'], ['44455'], ['66116'], ['12345'], ['23456'], ['34561'], ['13654'], ['62534'], ['44421'], ['61623'], ['12346'], ['11122'], ['22233'], ['12333'], ['11222'], ['55544'], ['11112'], ['66661'], ['11113'], ['22223'], ['33334'], ['44445'], ['55556'], ['12332'], ['23443'], ['34554'], ['45665'], ['56116'], ['61221'], ['11223'], ['22334'], ['33445'], ['44556'], ['12354'], ['23465'], ['34512'], ['45623'], ['56134'], ['61245'], ['12456'], ['23561'], ['34612']]"}}
{"requirement": "def faulty_odometer(n: int) -> int:\n\"\"\"# Task\n You are given a car odometer which displays the miles traveled as an integer. \n \n The odometer has a defect, however: it proceeds from digit `3` to digit `5` always skipping the digit `4`. This defect shows up in all positions (ones, tens, hundreds, etc). \n\n\n \n For example, if the odometer displays `15339` and the car travels another mile, the odometer changes to `15350` (instead of `15340`).\n\n Your task is to calculate the real distance, according The number the odometer shows.\n\n# Example\n\n For `n = 13` the output should be `12`(4 skiped).\n \n For `n = 15` the output should be `13`(4 and 14 skiped).\n \n For `n = 2003` the output should be `1461`.\n\n# Input/Output\n\n\n - `[input]` integer `n`\n\n  The number the odometer shows.\n  \n  `1 <= n <= 999999999`\n\n\n - `[output]` an integer\n\n  The real distance.\n\"\"\"", "inputs": [[13], [15], [55], [2005], [1500], [999999], [165826622]], "outputs": [[12], [13], [40], [1462], [1053], [531440], [69517865]], "starter_code": "def faulty_odometer(n: int) -> int:", "canonical_solution": "tr = str.maketrans('56789', '45678')\n\ndef faulty_odometer(n):\n    return int(str(n).translate(tr), 9)", "entry_point": "faulty_odometer", "task_id": "TACO_lite/1384", "input_output_examples": "[[[13], [15], [2003]], [[12], [13], [1461]]]", "llm_generated_inputs": {"deepseek-v3": "[[13], [15], [2003], [1], [4], [5], [10], [14], [20], [33], [40], [55], [100], [144], [200], [333], [400], [555], [1000], [1444], [2000], [3333], [4000], [5555], [999999999]]", "qwen2.5-coder-32b-instruct": "[[13], [15], [2003], [1], [3], [5], [9], [10], [19], [20], [29], [30], [39], [40], [49], [50], [99], [100], [999], [1000], [9999], [10000], [99999], [100000], [999999], [1000000], [9999999], [10000000], [99999999], [100000000], [999999999]]"}}
{"requirement": "def minor_or_major(chord: str) -> str:\n\"\"\"Check if given chord is minor or major.\n\n_____________________________________________________________\nRules:\n\n1. Basic minor/major chord have three elements.\n\n2. Chord is minor when interval between first and second element equals 3 and between second and third -> 4.\n\n3. Chord is major when interval between first and second element equals 4 and between second and third -> 3.\n\n4. In minor/major chord interval between first and third element equals... 7.\n\n_______________________________________________________________\nThere is a preloaded list of the 12 notes of a chromatic scale built on C. This means that there are (almost) all allowed note' s names in music.\n\nnotes = \n['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n\nNote that e. g. 'C#' - 'C' = 1, 'C' - 'C#' = 1, 'Db' - 'C' = 1 and 'B' - 'C' = 1. \n\nInput:\nString of notes separated by whitespace, e. g. 'A C# E'\n\nOutput:\nString message: 'Minor', 'Major' or 'Not a chord'.\n\"\"\"", "inputs": [["C E G"], ["Db F Ab"], ["D F# A"], ["Eb G Bb"], ["E G# B"], ["F A C"], ["F# A# C#"], ["Gb Bb Db"], ["G B D"], ["Ab C Eb"], ["A C# E"], ["Bb D F"], ["B D# F#"], ["C Eb G"], ["C# E G#"], ["D F A"], ["D# F# A#"], ["Eb Gb Bb"], ["E G B"], ["F Ab C"], ["F# A C#"], ["G Bb D"], ["G# B D#"], ["A C E"], ["Bb Db F"], ["B D F#"], ["C D G"], ["A C D"], ["A C# D#"], ["D F A G"], ["D F"], ["D F A C#"], ["K L M"], ["C A G"], ["C H G"], ["G E C"], ["E C A"], ["G# E C#"], ["Bb Gb Eb"]], "outputs": [["Major"], ["Major"], ["Major"], ["Major"], ["Major"], ["Major"], ["Major"], ["Major"], ["Major"], ["Major"], ["Major"], ["Major"], ["Major"], ["Minor"], ["Minor"], ["Minor"], ["Minor"], ["Minor"], ["Minor"], ["Minor"], ["Minor"], ["Minor"], ["Minor"], ["Minor"], ["Minor"], ["Minor"], ["Not a chord"], ["Not a chord"], ["Not a chord"], ["Not a chord"], ["Not a chord"], ["Not a chord"], ["Not a chord"], ["Not a chord"], ["Not a chord"], ["Not a chord"], ["Not a chord"], ["Not a chord"], ["Not a chord"]], "starter_code": "def minor_or_major(chord: str) -> str:", "canonical_solution": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for mode, offset in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef minor_or_major(chord):\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')", "entry_point": "minor_or_major", "task_id": "TACO_lite/1389", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['A C E'], ['C E G'], ['D F A'], ['F A C'], ['G B D'], ['E G B'], ['C D E'], ['A B C'], ['C# E G#'], ['Db F Ab'], ['C# E G'], ['Db F A'], ['C E G B'], ['C'], ['C E'], ['C E G B D'], ['C C C'], ['C# Db E'], ['C C# D'], ['C D E F']]", "qwen2.5-coder-32b-instruct": "[['C Eb G'], ['C E G'], ['A C# E'], ['A C E'], ['D F A'], ['D F# A'], ['G B D'], ['G Bb D'], ['E G# B'], ['E G B'], ['F# A# D#'], ['F# A D#'], ['B D# F#'], ['B D F#'], ['C C C'], ['C C# D'], ['C D D#'], ['C Db Eb'], ['C D Eb'], ['A A A'], ['A A# B'], ['A B B#'], ['A A# Bb'], ['A B Bb'], ['G# A# B#'], ['G# A B#'], ['G# A# B'], ['G# A B'], ['C E A'], ['C E B'], ['C Eb B'], ['C Eb A#'], ['C D F'], ['C D F#'], ['C Eb G#'], ['C E Gb'], ['A C Eb'], ['A C Gb'], ['A C# F'], ['A C# F#'], ['D F Ab'], ['D F G#'], ['D F# C#'], ['D F# C'], ['G B Eb'], ['G B F#'], ['G Bb E'], ['G Bb F'], ['E G# C#'], ['E G# C'], ['E G Bb']]"}}
{"requirement": "def f(k: int, n: int) -> int:\n\"\"\"_This kata is based on [Project Euler Problem 546](https://projecteuler.net/problem=546)_\n\n# Objective\n\nGiven the recursive sequence \n\nfk(n) =\n\n\n∑\n\ni\n=\n0\n\n\nn\n\n\n\nfk(floor(i / k)) where fk(0) = 1\n\nDefine a function `f` that takes arguments `k` and `n` and returns the nth term in the sequence fk\n\n## Examples\n\n`f(2, 3)` = f2(3) = 6\n\n`f(2, 200)` = f2(200) = 7389572\n\n`f(7, 500)` = f7(500) = 74845\n\n`f(1000, 0)` = f1000(0) = 1\n\n\n**Note:** \nNo error checking is needed, `k` ranges from 2 to 100 and `n` ranges between 0 and 500000 (mostly small and medium values with a few large ones)\n\n\n\n\nAs always any feedback would be much appreciated\n\"\"\"", "inputs": [[2, 3], [2, 200], [2, 1000], [7, 500], [100, 0], [3, 50000], [97, 100000], [100, 500000]], "outputs": [[6], [7389572], [264830889564], [74845], [1], [80887845303700596855], [209497156], [21469002551]], "starter_code": "def f(k: int, n: int) -> int:", "canonical_solution": "def f(k, n):\n    a = []\n    for i in range(0, n + 1):\n        if i < k:\n            a += [i + 1]\n        else:\n            a += [a[-1] + a[i // k]]\n    return a[-1]", "entry_point": "f", "task_id": "TACO_lite/1398", "input_output_examples": "[[[2, 3], [2, 200], [7, 500], [1000, 0]], [[6], [7389572], [74845], [1]]]", "llm_generated_inputs": {"deepseek-v3": "[[2, 3], [2, 200], [7, 500], [1000, 0], [2, 0], [100, 1], [10, 10], [50, 100], [99, 500000], [3, 10000]]", "qwen2.5-coder-32b-instruct": "[[2, 3], [2, 200], [7, 500], [1000, 0], [2, 0], [2, 1], [10, 10], [5, 100], [50, 500], [100, 1000], [2, 500000], [100, 500000]]"}}
{"requirement": "def validate_usr(un: str) -> bool:\n\"\"\"Write a simple regex to validate a username. Allowed characters are:\n\n- lowercase letters,\n- numbers,\n- underscore\n\nLength should be between 4 and 16 characters (both included).\n\"\"\"", "inputs": [["asddsa"], ["a"], ["Hass"], ["Hasd_12assssssasasasasasaasasasasas"], [""], ["____"], ["012"], ["p1pp1"], ["asd43 34"], ["asd43_34"]], "outputs": [[true], [false], [false], [false], [false], [true], [false], [true], [false], [true]], "starter_code": "def validate_usr(un: str) -> bool:", "canonical_solution": "import re\n\ndef validate_usr(un):\n    return re.match('^[a-z0-9_]{4,16}$', un) != None", "entry_point": "validate_usr", "task_id": "TACO_lite/1399", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['valid_username'], ['short'], ['this_username_is_too_long'], ['InvalidUsername'], ['user@name'], ['user_name_123'], ['user'], ['user_1234567890123456'], ['user_123456789012345'], ['user_12345678901234'], ['user_1234567890123'], ['user_123456789012'], ['user_12345678901'], ['user_1234567890'], ['user_123456789'], ['user_12345678'], ['user_1234567'], ['user_123456'], ['user_12345'], ['user_1234'], ['user_123'], ['user_12'], ['user_1'], ['user_'], ['user'], ['']]", "qwen2.5-coder-32b-instruct": "[['user_123'], ['usr'], ['this_is_a_valid_username'], ['toolongusername12345'], ['valid_user1'], ['1234'], ['____'], ['user!name'], ['user name'], ['User123'], ['user123\\n'], ['user123\\t'], ['user123.'], ['user_'], ['user1'], ['user12345678901234']]"}}
{"requirement": "def majority(arr: list) -> str:\n\"\"\"Goal\nGiven a list of elements [a1, a2, ..., an], with each ai being a string, write a function **majority** that returns the value that appears the most in the list. \n\nIf there's no winner, the function should return None, NULL, nil, etc, based on the programming language.\n\nExample\nmajority([\"A\", \"B\", \"A\"]) returns \"A\"\nmajority([\"A\", \"B\", \"B\", \"A\"]) returns None\n\"\"\"", "inputs": [[["A", "B", "A"]], [["A", "B", "C"]], [["A", "B", "B", "A"]], [["A", "A", "A", "A"]], [["A"]], [["A", "A", "A", "BBBBBBBB"]], [["A", "B", "C", "C"]], [[]], [["B", "C", "", ""]]], "outputs": [["A"], [null], [null], ["A"], ["A"], ["A"], ["C"], [null], [""]], "starter_code": "def majority(arr: list) -> str:", "canonical_solution": "from collections import Counter\n\ndef majority(arr):\n    mc = Counter(arr).most_common(2)\n    if arr and (len(mc) == 1 or mc[0][1] != mc[1][1]):\n        return mc[0][0]", "entry_point": "majority", "task_id": "TACO_lite/1400", "input_output_examples": "[[[['A', 'B', 'A']], [['A', 'B', 'B', 'A']]], [['A'], [None]]]", "llm_generated_inputs": {"deepseek-v3": "[[['A', 'B', 'A']], [['A', 'B', 'B', 'A']], [['A', 'A', 'A', 'B', 'B']], [['A', 'B', 'C', 'D', 'E']], [['A', 'A', 'B', 'B', 'C', 'C']], [['A', 'A', 'A', 'B', 'B', 'B', 'B']], [[]], [['A']], [['A', 'A', 'A', 'A']], [['A', 'B', 'C', 'A', 'B', 'C', 'A', 'B', 'C']]]", "qwen2.5-coder-32b-instruct": "[[['A', 'B', 'A']], [['A', 'B', 'B', 'A']], [['C', 'C', 'C', 'B', 'B', 'A']], [['X']], [[]], [['Y', 'Y', 'Z', 'Z', 'Z']], [['M', 'N', 'M', 'O', 'N', 'M', 'N']]]"}}
{"requirement": "def is_valid(idn: str) -> bool:\n\"\"\"Given a string, determine if it's a valid identifier.\n\n## Here is the syntax for valid identifiers:\n* Each identifier must have at least one character.\n* The first character must be picked from: alpha, underscore, or dollar sign. The first character cannot be a digit.\n* The rest of the characters (besides the first) can be from: alpha, digit, underscore, or dollar sign. In other words, it can be any valid identifier character.\n\n### Examples of valid identifiers:\n* i\n* wo_rd\n* b2h\n\n### Examples of invalid identifiers:\n* 1i\n* wo rd \n* !b2h\n\"\"\"", "inputs": [["okay_ok1"], ["$ok"], ["___"], ["str_STR"], ["myIdentf"], ["1ok0okay"], ["!Ok"], [""], ["str-str"], ["no no"]], "outputs": [[true], [true], [true], [true], [true], [false], [false], [false], [false], [false]], "starter_code": "def is_valid(idn: str) -> bool:", "canonical_solution": "import re\n\ndef is_valid(idn):\n    return re.compile('^[a-z_\\\\$][a-z0-9_\\\\$]*$', re.IGNORECASE).match(idn) != None", "entry_point": "is_valid", "task_id": "TACO_lite/1402", "input_output_examples": "[[['i'], ['wo_rd'], ['b2h'], ['1i'], ['wo rd'], ['!b2h']], [[True], [True], [True], [False], [False], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[['i'], ['wo_rd'], ['b2h'], ['_valid'], ['$valid'], ['validIdentifier123'], ['1i'], ['wo rd'], ['!b2h'], [''], ['123'], ['invalid@'], ['invalid!'], ['invalid space'], ['validButWithDollar$'], ['ValidWithUnderscore_'], ['$'], ['_']]", "qwen2.5-coder-32b-instruct": "[['i'], ['wo_rd'], ['b2h'], ['_valid'], ['$valid'], ['valid123'], ['1invalid'], ['invalid char!'], ['invalid-char-'], ['invalid char '], ['1'], ['_'], ['$'], [''], ['!'], ['@'], ['#'], ['%'], ['^'], ['&'], ['*'], ['('], [')'], ['+'], ['='], ['{'], ['}'], ['['], [']'], ['|'], ['\\\\'], ['\"'], ['<'], ['>'], [','], ['.'], ['?'], ['/'], [';'], [':'], ['~']]"}}
{"requirement": "from typing import List\n\n\ndef makearrayincreasing(arr1: List[int], arr2: List[int]) -> int:\n\"\"\"Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.\nIn one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].\nIf there is no way to make arr1 strictly increasing, return -1.\n \nExample 1:\nInput: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\nOutput: 1\nExplanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].\n\nExample 2:\nInput: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\nOutput: 2\nExplanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].\n\nExample 3:\nInput: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\nOutput: -1\nExplanation: You can't make arr1 strictly increasing.\n \nConstraints:\n\n1 <= arr1.length, arr2.length <= 2000\n0 <= arr1[i], arr2[i] <= 10^9\n\"\"\"", "inputs": [[[1, 5, 3, 6, 7], [1, 3, 2, 4]], [[1, 5, 3, 6, 7], [4, 3, 1]], [[1, 5, 3, 6, 7], [1, 6, 3, 3]]], "outputs": [[1], [2], [-1]], "starter_code": "from typing import List\ndef makearrayincreasing(arr1: List[int], arr2: List[int]) -> int:", "canonical_solution": "import bisect\nfrom typing import List\nfrom functools import lru_cache\n\ndef makearrayincreasing(arr1: List[int], arr2: List[int]) -> int:\n    array = arr1\n    replace = list(sorted(set(arr2)))\n\n    def dfs(array_pos: int, prev_number: int) -> int:\n        min_replacements = len(replace) * 2\n        if array_pos == len(array):\n            return 0\n        next_replace_pos = 0\n        if array_pos > 0:\n            next_replace_pos = bisect.bisect(replace, prev_number)\n        if array_pos == 0 or next_replace_pos < len(replace):\n            tmp = array[array_pos]\n            min_replacements = min(min_replacements, dfs(array_pos + 1, replace[next_replace_pos]) + 1)\n        if array_pos == 0 or prev_number < array[array_pos]:\n            min_replacements = min(min_replacements, dfs(array_pos + 1, array[array_pos]))\n        return min_replacements\n    result = dfs(0, -100)\n    if result > len(replace):\n        return -1\n    return result", "entry_point": "makearrayincreasing", "task_id": "TACO_lite/1411", "input_output_examples": "[[[[1, 5, 3, 6, 7], [1, 3, 2, 4]], [[1, 5, 3, 6, 7], [4, 3, 1]], [[1, 5, 3, 6, 7], [1, 6, 3, 3]]], [[1], [2], [-1]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 5, 3, 6, 7], [1, 3, 2, 4]], [[1, 5, 3, 6, 7], [4, 3, 1]], [[1, 5, 3, 6, 7], [1, 6, 3, 3]], [[1, 2, 3, 4, 5], [1, 2, 3, 4]], [[5, 4, 3, 2, 1], [1, 2, 3, 4, 5]], [[1, 1, 1, 1, 1], [2, 3, 4, 5, 6]], [[1], [2]], [[1, 3, 2], [4]], [[10, 20, 30], [5, 15, 25]], [[1, 5, 10], [2, 3, 4]]]", "qwen2.5-coder-32b-instruct": "[[[1, 5, 3, 6, 7], [1, 3, 2, 4]], [[1, 5, 3, 6, 7], [4, 3, 1]], [[1, 5, 3, 6, 7], [1, 6, 3, 3]], [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1]], [[5, 4, 3, 2, 1], [1, 2, 3, 4, 5]], [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], [[1, 2, 3, 4, 5], []], [[1], [2]], [[1000000000], [1000000000]], [[1, 3, 5, 7, 9], [2, 4, 6, 8, 10]], [[1, 3, 5, 7, 9], [1, 3, 5, 7, 9]], [[1, 3, 5, 7, 9], [0, 2, 4, 6, 8]], [[1, 2, 3], [3, 2, 1]], [[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [1, 2, 3]], [[1, 2, 3], [2, 3, 4]], [[1, 2, 3], [1, 2]], [[1, 2, 3], [2]], [[1, 2, 3], [1]], [[1, 2, 3], [3]], [[1, 2, 3], [0]], [[1, 2, 3], [4]], [[1, 2, 3], [5]], [[1, 2, 3], [6]], [[1, 2, 3], [7]], [[1, 2, 3], [8]], [[1, 2, 3], [9]], [[1, 2, 3], [10]], [[1, 2, 3], [11]], [[1, 2, 3], [12]], [[1, 2, 3], [13]], [[1, 2, 3], [14]], [[1, 2, 3], [15]]]"}}
{"requirement": "def is_happy(n: int) -> bool:\n\"\"\"A happy number is a number defined by the following process: starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n\nThose numbers for which this process ends in 1 are **happy numbers**, while those that do not end in 1 are unhappy numbers (or sad numbers) (Wikipedia).\n\nWrite a function that takes `n` as parameter and return `true` if and only if `n` is an happy number, `false` otherwise.\n\n\n## Examples\n\nFor example number `7` is happy because after a number of steps the computed sequence ends up with a 1: `7, 49, 97, 130, 10, 1 `\n\nWhile `3` is not, and would give us an infinite sequence: `3, 9, 81, 65, 61, 37, 58, 89, 145, 42, 20, 4, 16, 37, 58, 89, 145, 42, 20, 4, 16, 37, ...`\n\n\nHappy coding!\n\"\"\"", "inputs": [[1], [7], [16]], "outputs": [[true], [true], [false]], "starter_code": "def is_happy(n: int) -> bool:", "canonical_solution": "def is_happy(n):\n    seen = set()\n    while n != 1:\n        n = sum((int(d) ** 2 for d in str(n)))\n        if n not in seen:\n            seen.add(n)\n        else:\n            return False\n    return True", "entry_point": "is_happy", "task_id": "TACO_lite/1425", "input_output_examples": "[[[7], [3]], [[True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[7], [3], [1], [19], [4], [0], [100], [2]]", "qwen2.5-coder-32b-instruct": "[[1], [7], [10], [13], [19], [23], [28], [31], [32], [44], [49], [68], [70], [79], [82], [86], [91], [94], [97], [100], [2], [3], [4], [5], [6], [8], [9], [11], [12], [14], [15], [16], [17], [18], [20], [21], [22], [24], [25], [26], [27], [29], [30], [33], [34], [35], [36], [38], [39], [40], [41]]"}}
{"requirement": "def past(h: int, m: int, s: int) -> int:\n\"\"\"Clock shows 'h' hours, 'm' minutes and 's' seconds after midnight.\n\nYour task is to make 'Past' function which returns time converted to milliseconds.\n\n## Example:\n\n```python\npast(0, 1, 1) == 61000\n```\n\nInput constraints: `0 <= h <= 23`, `0 <= m <= 59`, `0 <= s <= 59`\n\"\"\"", "inputs": [[0, 1, 1], [1, 1, 1], [0, 0, 0], [1, 0, 1], [1, 0, 0]], "outputs": [[61000], [3661000], [0], [3601000], [3600000]], "starter_code": "def past(h: int, m: int, s: int) -> int:", "canonical_solution": "def past(h, m, s):\n    return (3600 * h + 60 * m + s) * 1000", "entry_point": "past", "task_id": "TACO_lite/1432", "input_output_examples": "[[[0, 1, 1]], [[61000]]]", "llm_generated_inputs": {"deepseek-v3": "[[0, 0, 0], [23, 59, 59], [0, 1, 1], [12, 30, 30], [1, 0, 0], [0, 1, 0], [0, 0, 1], [10, 20, 30], [5, 5, 5]]", "qwen2.5-coder-32b-instruct": "[[0, 1, 1], [23, 59, 59], [0, 0, 0], [12, 34, 56], [1, 0, 0], [0, 1, 0], [0, 0, 1], [23, 0, 0], [0, 59, 0], [0, 0, 59]]"}}
{"requirement": "from typing import List\nfrom typing import Dict\nfrom typing import Union\n\n\ndef score_pole_vault(vaulter_list: List[Dict[str, Union[str, List[str]]]]) -> Dict[str, str]:\n\"\"\"Your task is to determine the top 3 place finishes in a pole vault competition involving several different competitors. This is isn't always so simple, and it is often a source of confusion for people who don't know the actual rules.\n\nHere's what you need to know:\n\nAs input, you will receive an array of objects. Each object contains the respective competitor's name (as a string) and his/her results at the various bar heights (as an array of strings):\n\n[{name: \"Sergey\", results: [\"\", \"O\", \"XO\", \"O\", \"XXO\", \"XXX\", \"\", \"\"]}{name: \"Jan\", results: [\"\", \"\", \"\", \"O\", \"O\", \"XO\", \"XXO\", \"XXX\"]}{name: \"Bruce\", results: [\"\", \"XO\", \"XXO\", \"XXX\", \"\", \"\", \"\", \"\"]}{name: \"HerrWert\", results: [\"XXX\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]}]\n\nIn the array of strings described above, each string represents the vaulter's performance at a given height. The possible values are based on commonly used written notations on a pole vault scoresheet:\nAn empty string indicates that the vaulter did not jump at this height for a variety of possible reasons (\"passed\" at this height, was temporarily called away to a different track and field event, was already eliminated from competition, or withdrew due to injury, for example).An upper-case X in the string represents an unsuccessful attempt at the height. (As you may know, the vaulter is eliminated from the competition after three consecutive failed attempts.)An upper-case O represents a successful attempt. If present at all, this will be the final character in the string, because it indicates that the vaulter has now successfully completed this height and is ready to move on.\n\nAll vaulters will have a result string (though possibly empty) for every height involved in the competition, making it possible to match up the results of different vaulters with less confusion.\n\nObviously, your first task is to determine who cleared the greatest height successfully. In other words, who has a \"O\" mark at a higher array element than any other competitor? You might want to work through the arrays from right to left to determine this. In the most straightforward case, you would first determine the winner, then second place, and finally third place by this simple logic.\n\nBut what if there's a tie for one of these finishing places? Proceed as follows (according to American high school rules, at least):\nFirst trace backwards to find the greatest height that both vaulters cleared successfully. Then determine who had the fewest unsuccessful attempts at this height (i.e., the fewest X's in the string for this height). This person wins the tie-break.But what if they're still tied with one another?  Do NOT continue to trace backwards through the heights! Instead, compare their total numbers of unsuccessful attempts at all heights in the competition. The vaulter with the fewest total misses wins the tie-break.But what if they're still tied? It depends on the finishing place:If it's for second or third place, the tie stands (i.e., is not broken).But if it's for first place, there must be a jump-off (like overtime or penalty kicks in other sports) to break the tie and determine the winner. (This jump-off occurs - hypothetically - after your code runs and is thus not a part of this kata.)\n\nReturn a single object as your result. Each place-finish that is included in the results (including at least first place as property \"1st\" and possibly second and third places as properties \"2nd\" and \"3rd\") should have as its value the respective vaulter's name. In the event of a tie, the value of the property is the names of all tied vaulters, in alphabetical order, separated by commas, and followed by the notation \"(jump-off)\" if the tie is for first place or \"(tie)\" if it's for second or third place.\n\nHere are some possible outcomes to show you what I mean:\n{1st: \"Jan\", 2nd: \"Sergey\"; 3rd: \"Bruce\"} (These results correspond to the sample input data given above.){1st: \"Julia\", 2nd: \"Madi, Emily (tie)}\"{1st: \"Caleb, Dustin (jump-off)\", 3rd: \"Sam\"}{1st: \"Meredith\", 2nd: \"Maddy\", 3rd: \"Cierra, Sara (tie)\"}{1st: \"Alex, Basti, Max (jump-off)\"}\n\nIf you are familiar with the awarding of place finishes in sporting events or team standings in a league, then you know that there won't necessarily be a 2nd or 3rd place, because ties in higher places \"bump\"  all lower places downward accordingly.\n\nOne more thing: You really shouldn't change the array of objects that you receive as input. This represents the physical scoresheet. We need this \"original document\" to be intact, so that we can refer back to it to resolve a disputed result!\n\nHave fun with this!\n\n- - - - -\n\nNotes for the Python version:\n\nThe rules for the Python version are the same as the original JavaScript version. \n\nThe input and output will look the same as the JavaScript version. But, the JavaScript objects will be replaced by Python dictionaries. The JavaScript arrays will be replaced by Python lists. The Python function name was changed to include underscores as is customary with Python names. The example below should help clarify all of this.\n\nThe input for the Python version will be a list containing dictionaries with the competitors' names and results. The names in the dictionaries are strings. The results are lists with a list of strings. And example follows.\n\nscore_pole_vault([\n        {\"name\": \"Linda\", \"results\": [\"XXO\", \"O\",\"XXO\", \"O\"]},\n        {\"name\": \"Vickie\", \"results\": [\"O\",\"X\", \"\", \"\"]},\n        {\"name\": \"Debbie\", \"results\": [\"XXO\", \"O\",\"XO\", \"XXX\"]},\n        {\"name\": \"Michelle\", \"results\": [\"XO\",\"XO\",\"XXX\",\"\"]},\n        {\"name\": \"Carol\", \"results\": [\"XXX\", \"\",\"\",\"\"]}\n])\n\n\nThe returned results should be in a dictionary with one to three elements. \n\nExamples of possible returned results:\n\n  {'1st': 'Linda', '2nd': 'Debbie', '3rd': 'Michelle'}\n\n  {'1st': 'Green, Hayes (jump-off)', '3rd': 'Garcia'}           \n  Note: Since first place was tied in this case, there is no 2nd place awarded.\n\n  {'1st': 'Wilson', '2nd': 'Laurie', '3rd': 'Joyce, Moore (tie)'}\n  \nI have tried to create test cases that have every concievable tie situation.\n\nHave fun with this version, as well!\n\"\"\"", "inputs": [[[{"name": "Linda", "results": ["XXO", "O", "XXO", "O"]}, {"name": "Vickie", "results": ["O", "X", "", ""]}, {"name": "Debbie", "results": ["XXO", "O", "XO", "XXX"]}, {"name": "Michelle", "results": ["XO", "XO", "XXX", ""]}, {"name": "Carol", "results": ["XXX", "", "", ""]}]], [[{"name": "Linda", "results": ["XXO", "O", "XXO", "XXX"]}, {"name": "Vickie", "results": ["O", "X", "", ""]}, {"name": "Debbie", "results": ["XXO", "O", "XO", "XXX"]}, {"name": "Michelle", "results": ["XO", "XO", "XXX", ""]}, {"name": "Carol", "results": ["XXX", "", "", ""]}]], [[{"name": "Kimberly", "results": ["O", "O", "XO", "XXX"]}, {"name": "Constance", "results": ["O", "X", "", ""]}, {"name": "Phoebe", "results": ["XXO", "O", "XO", "XXX"]}, {"name": "Carol", "results": ["XXX", "", "", ""]}]], [[{"name": "Lana", "results": ["XO", "O", "O", "XXO", "XXX"]}, {"name": "Onyx", "results": ["XXO", "XXO", "XO", "O", "XXX"]}, {"name": "Molly", "results": ["XO", "XO", "O", "XXX", ""]}, {"name": "Alexandria", "results": ["XO", "XO", "O", "XXX", ""]}, {"name": "Rebecca", "results": ["XXO", "O", "O", "XXX", ""]}]], [[{"name": "Lana", "results": ["XO", "O", "O", "XXO", "XXX"]}, {"name": "Onyx", "results": ["XXO", "XXO", "XO", "O", "XXX"]}, {"name": "Molly", "results": ["XO", "XO", "O", "XXX", ""]}, {"name": "Rebecca", "results": ["XXO", "O", "O", "XXX", ""]}]], [[{"name": "Sarah", "results": ["O", "X", "", ""]}, {"name": "Brett", "results": ["XO", "O", "XO", "XXO"]}, {"name": "Sharon", "results": ["O", "X", "", ""]}, {"name": "Kelli", "results": ["XXX", "", "", ""]}, {"name": "Laura", "results": ["O", "XO", "XO", "XXO"]}]], [[{"name": "Elle", "results": ["O", "O", "XXO", "XXO"]}, {"name": "Sarah", "results": ["O", "X", "", ""]}, {"name": "Brett", "results": ["XO", "O", "XO", "XXO"]}, {"name": "Kelli", "results": ["XXX", "", "", ""]}, {"name": "Laura", "results": ["O", "XO", "XO", "XXO"]}]], [[{"name": "Allison", "results": ["XO", "O", "XXO", "XXX"]}, {"name": "Olivia", "results": ["O", "XO", "XXO", "XXX"]}, {"name": "Rhyana", "results": ["XO", "O", "XO", "XO"]}, {"name": "Zola", "results": ["XO", "O", "XXX", ""]}, {"name": "Megan", "results": ["XO", "O", "XXX", ""]}]], [[{"name": "Allison", "results": ["XO", "O", "XXO", "XXX"]}, {"name": "Olivia", "results": ["O", "XO", "XXO", "XXX"]}, {"name": "Rhyana", "results": ["XO", "O", "XO", "XO"]}, {"name": "Zola", "results": ["XO", "O", "XXX", ""]}, {"name": "Megan", "results": ["XO", "O", "XXO", "XXX"]}]], [[{"name": "Anna", "results": ["XO", "O", "XO", "XO"]}, {"name": "Allison", "results": ["XO", "O", "XXO", "XXX"]}, {"name": "Olivia", "results": ["O", "XO", "XXO", "XXX"]}, {"name": "Rhiana", "results": ["XO", "O", "XO", "XO"]}, {"name": "Zola", "results": ["XO", "O", "XXX", ""]}, {"name": "Megan", "results": ["XO", "O", "XXO", "XXX"]}]]], "outputs": [[{"1st": "Linda", "2nd": "Debbie", "3rd": "Michelle"}], [{"1st": "Debbie", "2nd": "Linda", "3rd": "Michelle"}], [{"1st": "Kimberly", "2nd": "Phoebe", "3rd": "Constance"}], [{"1st": "Onyx", "2nd": "Lana", "3rd": "Alexandria, Molly, Rebecca (tie)"}], [{"1st": "Onyx", "2nd": "Lana", "3rd": "Molly, Rebecca (tie)"}], [{"1st": "Brett, Laura (jump-off)", "3rd": "Sarah, Sharon (tie)"}], [{"1st": "Brett, Elle, Laura (jump-off)"}], [{"1st": "Rhyana", "2nd": "Allison, Olivia (tie)"}], [{"1st": "Rhyana", "2nd": "Allison, Megan, Olivia (tie)"}], [{"1st": "Anna, Rhiana (jump-off)", "3rd": "Allison, Megan, Olivia (tie)"}]], "starter_code": "from typing import List\nfrom typing import Dict\nfrom typing import Union\ndef score_pole_vault(vaulter_list: List[Dict[str, Union[str, List[str]]]]) -> Dict[str, str]:", "canonical_solution": "def score_pole_vault(vaulter_list):\n    popytki = len(vaulter_list[0]['results'])\n    temp = {}\n    res = {}\n    for mas in vaulter_list:\n        i = popytki - 1\n        while i >= 0 and mas['results'][i].find('O') == -1:\n            i -= 1\n        if i < 0:\n            n = 0\n            m = ''.join(mas['results']).count('X')\n        else:\n            n = mas['results'][i].count('X')\n            m = ''.join(mas['results'][:i]).count('X')\n        new_key = (popytki - i, n, m)\n        temp[new_key] = temp.get(new_key, []) + [mas['name']]\n    k = iter(sorted(temp))\n    i = 0\n    while i < 3:\n        key = next(k)\n        if i == 0 and len(temp[key]) == 1:\n            res['1st'] = temp[key][0]\n            i += 1\n        elif i == 0 and len(temp[key]) > 1:\n            res['1st'] = ', '.join(sorted(temp[key])) + ' (jump-off)'\n            i += len(temp[key])\n        elif i == 1 and len(temp[key]) == 1:\n            res['2nd'] = temp[key][0]\n            i += 1\n        elif i == 1 and len(temp[key]) > 1:\n            res['2nd'] = ', '.join(sorted(temp[key])) + ' (tie)'\n            i += len(temp[key])\n        elif i == 2 and len(temp[key]) == 1:\n            res['3rd'] = temp[key][0]\n            i += 1\n        elif i == 2 and len(temp[key]) > 1:\n            res['3rd'] = ', '.join(sorted(temp[key])) + ' (tie)'\n            i += len(temp[key])\n    return res", "entry_point": "score_pole_vault", "task_id": "TACO_lite/1434", "input_output_examples": "[[[[{'name': 'Linda', 'results': ['XXO', 'O', 'XXO', 'O']}, {'name': 'Vickie', 'results': ['O', 'X', '', '']}, {'name': 'Debbie', 'results': ['XXO', 'O', 'XO', 'XXX']}, {'name': 'Michelle', 'results': ['XO', 'XO', 'XXX', '']}, {'name': 'Carol', 'results': ['XXX', '', '', '']}]]], [[{'1st': 'Linda', '2nd': 'Debbie', '3rd': 'Michelle'}]]]", "llm_generated_inputs": {"deepseek-v3": "[[[{'name': 'Sergey', 'results': ['', 'O', 'XO', 'O', 'XXO', 'XXX', '', '']}, {'name': 'Jan', 'results': ['', '', '', 'O', 'O', 'XO', 'XXO', 'XXX']}, {'name': 'Bruce', 'results': ['', 'XO', 'XXO', 'XXX', '', '', '', '']}, {'name': 'HerrWert', 'results': ['XXX', '', '', '', '', '', '', '']}]], [[{'name': 'Linda', 'results': ['XXO', 'O', 'XXO', 'O']}, {'name': 'Vickie', 'results': ['O', 'X', '', '']}, {'name': 'Debbie', 'results': ['XXO', 'O', 'XO', 'XXX']}, {'name': 'Michelle', 'results': ['XO', 'XO', 'XXX', '']}, {'name': 'Carol', 'results': ['XXX', '', '', '']}]], [[{'name': 'Alex', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Basti', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Max', 'results': ['O', 'O', 'O', 'O']}]], [[{'name': 'Julia', 'results': ['O', 'XO', 'XXO', 'XXX']}, {'name': 'Madi', 'results': ['O', 'XO', 'XXO', 'XXX']}, {'name': 'Emily', 'results': ['O', 'XO', 'XXO', 'XXX']}]], [[{'name': 'Caleb', 'results': ['O', 'XO', 'XXO', 'XXX']}, {'name': 'Dustin', 'results': ['O', 'XO', 'XXO', 'XXX']}, {'name': 'Sam', 'results': ['O', 'XO', 'XXO', 'XXX']}]], [[{'name': 'Meredith', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Maddy', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Cierra', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Sara', 'results': ['O', 'O', 'O', 'O']}]], [[{'name': 'Wilson', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Laurie', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Joyce', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Moore', 'results': ['O', 'O', 'O', 'O']}]], [[{'name': 'Green', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Hayes', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Garcia', 'results': ['O', 'O', 'O', 'O']}]]]", "qwen2.5-coder-32b-instruct": "[[[{'name': 'Sergey', 'results': ['', 'O', 'XO', 'O', 'XXO', 'XXX', '', '']}, {'name': 'Jan', 'results': ['', '', '', 'O', 'O', 'XO', 'XXO', 'XXX']}, {'name': 'Bruce', 'results': ['', 'XO', 'XXO', 'XXX', '', '', '', '']}, {'name': 'HerrWert', 'results': ['XXX', '', '', '', '', '', '', '']}]], [[{'name': 'Julia', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Madi', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Emily', 'results': ['O', 'O', 'O', 'O']}]], [[{'name': 'Caleb', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Dustin', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Sam', 'results': ['O', 'O', 'O', 'X']}]], [[{'name': 'Meredith', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Maddy', 'results': ['O', 'O', 'O', 'X']}, {'name': 'Cierra', 'results': ['O', 'O', 'X', 'X']}, {'name': 'Sara', 'results': ['O', 'O', 'X', 'X']}]], [[{'name': 'Alex', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Basti', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Max', 'results': ['O', 'O', 'O', 'O']}]], [[{'name': 'Linda', 'results': ['XXO', 'O', 'XXO', 'O']}, {'name': 'Vickie', 'results': ['O', 'X', '', '']}, {'name': 'Debbie', 'results': ['XXO', 'O', 'XO', 'XXX']}, {'name': 'Michelle', 'results': ['XO', 'XO', 'XXX', '']}, {'name': 'Carol', 'results': ['XXX', '', '', '']}]], [[{'name': 'Green', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Hayes', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Garcia', 'results': ['O', 'O', 'X', 'X']}]], [[{'name': 'Wilson', 'results': ['O', 'O', 'O', 'O']}, {'name': 'Laurie', 'results': ['O', 'O', 'O', 'X']}, {'name': 'Joyce', 'results': ['O', 'O', 'X', 'X']}, {'name': 'Moore', 'results': ['O', 'O', 'X', 'X']}]], [[{'name': 'Alice', 'results': ['', '', '', '']}, {'name': 'Bob', 'results': ['', '', '', '']}]], [[{'name': 'Charlie', 'results': ['O', 'O', 'O', 'O']}]]]"}}
{"requirement": "def nth_perm(n: int, d: int) -> str:\n\"\"\"Lexicographic permutations are ordered combinations of a set of items ordered in a specific way.\n\nFor instance, the first 8 permutations of the digits 0123, in lexicographic order, are:\n\n```\n1st 0123\n2nd 0132\n3rd 0213\n4th 0231\n5th 0312\n6th 0321\n7th 1023\n8th 1032\n```\n\nYour task is to write a function ```L( n, d )``` that will return a `string` representing the `nth` permutation of the `d` digit, starting with 0 (i.e. d=10 means all digits 0123456789).\n\nSo for `d = 4`, `L(7,4)` should return `'1023'`, and `L(4,4)` should return `'0231'`\n.\n\n\nSome things to bear in mind:\n\n• The function should return a `string`, otherwise permutations beginning with a 0 will have it removed. \n\n• Test cases will not exceed the highest possible valid values for `n`\n\n• The function should work for any `d` between `1` and `10`.\n\n• A value of 1 for `n` means the 1st permutation, so `n = 0` is not a valid input.\n\n• Oh, and no itertools ;)\n\"\"\"", "inputs": [[1, 1], [12, 5], [1000, 7], [1000, 8], [1000000, 10], [874, 7], [100, 5], [400, 6], [900, 8], [3000000, 10], [1234567, 10], [654321, 10], [100000, 9], [33333, 8]], "outputs": [["0"], ["02431"], ["1325460"], ["02436571"], ["2783915460"], ["1234560"], ["40231"], ["314250"], ["02354761"], ["8241697530"], ["3469702158"], ["1827653409"], ["247815360"], ["64157203"]], "starter_code": "def nth_perm(n: int, d: int) -> str:", "canonical_solution": "import math\n\ndef nth_perm(n, d):\n    digits = [str(i) for i in range(d)]\n    out = ''\n    for i in range(1, d):\n        cycles = math.ceil(n / math.factorial(d - i))\n        out += digits.pop(cycles % (d - i + 1) - 1)\n    return out + digits.pop()", "entry_point": "nth_perm", "task_id": "TACO_lite/1439", "input_output_examples": "[[[7, 4], [4, 4]], [['1023'], ['0231']]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 1], [2, 2], [6, 3], [7, 4], [4, 4], [1, 10], [362880, 10], [24, 4], [3, 3], [120, 5]]", "qwen2.5-coder-32b-instruct": "[[1, 1], [1, 2], [2, 2], [1, 3], [3, 3], [6, 3], [1, 4], [4, 4], [7, 4], [24, 4], [1, 5], [120, 5], [1, 6], [720, 6], [1, 7], [5040, 7], [1, 8], [40320, 8], [1, 9], [362880, 9], [1, 10], [3628800, 10], [999999, 10]]"}}
{"requirement": "def capitalize_word(word: str) -> str:\n\"\"\"Your coworker was supposed to write a simple helper function to capitalize a string (that contains a single word) before they went on vacation.\n\nUnfortunately, they have now left and the code they gave you doesn't work. Fix the helper function they wrote so that it works as intended (i.e. make the first character in the string \"word\" upper case).\n\nDon't worry about numbers, special characters, or non-string types being passed to the function. The string lengths will be from 1 character up to 10 characters, but will never be empty.\n\n\n\"\"\"", "inputs": [["word"], ["i"], ["glasswear"]], "outputs": [["Word"], ["I"], ["Glasswear"]], "starter_code": "def capitalize_word(word: str) -> str:", "canonical_solution": "def capitalize_word(word):\n    return word.capitalize()", "entry_point": "capitalize_word", "task_id": "TACO_lite/1441", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['hello'], ['world'], ['python'], ['a'], ['z'], ['A'], ['Z'], ['123'], ['!@#'], ['aBcDeF']]", "qwen2.5-coder-32b-instruct": "[['a'], ['z'], ['apple'], ['banana'], ['grapefruit'], ['kiwi'], ['orange'], ['pear'], ['strawberry'], ['blueberry'], ['mango'], ['peach'], ['plum'], ['raspberry'], ['watermelon'], ['xylophone'], ['Y'], ['zebra'], ['antelope'], ['elephant']]"}}
{"requirement": "def repeater(string: str, n: int) -> str:\n\"\"\"Write a function named `repeater()` that takes two arguments (a string and a number), and returns a new string where the input string is repeated that many times.\n\n## Example:\n\nshould return\n\"\"\"", "inputs": [["a", 5], ["Na", 16], ["Wub ", 6]], "outputs": [["aaaaa"], ["NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNa"], ["Wub Wub Wub Wub Wub Wub "]], "starter_code": "def repeater(string: str, n: int) -> str:", "canonical_solution": "def repeater(string, n):\n    return string * n", "entry_point": "repeater", "task_id": "TACO_lite/1474", "input_output_examples": "[[['hello', 3], ['abc', 2], ['', 5], ['x', 0]], [['hellohellohello'], ['abcabc'], [''], ['']]]", "llm_generated_inputs": {"deepseek-v3": "[['a', 3], ['hello', 2], ['python', 0], ['', 5], ['abc', 1], ['123', 4], [' ', 10], ['!@#', 3]]", "qwen2.5-coder-32b-instruct": "[['abc', 3], ['', 5], ['x', 0], ['hello', 1], ['world', -2], ['repeat', 10]]"}}
{"requirement": "def diagonal(n: int, p: int) -> int:\n\"\"\"In the drawing below we have a part of the Pascal's triangle, lines are numbered from **zero** (top).\nThe left diagonal in pale blue with only numbers equal to 1 is diagonal **zero**, then in dark green \n(1, 2, 3, 4, 5, 6, 7) is diagonal 1, then in pale green (1, 3, 6, 10, 15, 21) is\ndiagonal 2 and so on.\n\nWe want to calculate the sum of the binomial coefficients on a given diagonal.\nThe sum on diagonal 0 is 8 (we'll write it S(7, 0), 7 is the number of the line where we start, \n0 is the number of the diagonal). In the same way S(7, 1) is 28, S(7, 2) is 56.\n\nCan you write a program which calculate S(n, p) where n is the line where we start and p \nis the number of the diagonal?\n\nThe function will take n and p (with: `n >= p >= 0`) as parameters and will return the sum.\n\n## Examples:\n```\ndiagonal(20, 3) => 5985\ndiagonal(20, 4) => 20349\n```\n## Hint:\nWhen following a diagonal from top to bottom have a look at the numbers on the diagonal at its right.\n\n## Ref:\nhttp://mathworld.wolfram.com/BinomialCoefficient.html\n\n![alternative text](http://i.imgur.com/eUGaNvIm.jpg)\n\"\"\"", "inputs": [[20, 3], [20, 4], [20, 5], [20, 15], [100, 0], [1291, 5], [1291, 56], [1291, 1234], [12910, 15], [129100, 5]], "outputs": [[5985], [20349], [54264], [20349], [101], [6385476296235036], [15478983586799578981605681450735426444083026237083755223526535252775423299626083333014485638841019200], [15478983586799578981605681450735426444083026237083755223526535252775423299626083333014485638841019200], [28229317689300804466421113746024782373551037613710510], [6429758786797926366807779220]], "starter_code": "def diagonal(n: int, p: int) -> int:", "canonical_solution": "def diagonal(n, p):\n    res = 0\n    for base in range(p, max(n, p) + 1):\n        value = 1\n        for i in range(base - p + 1, base + 1):\n            value *= i\n        for i in range(1, p + 1):\n            value //= i\n        res += int(value)\n    return res", "entry_point": "diagonal", "task_id": "TACO_lite/1476", "input_output_examples": "[[[20, 3], [20, 4]], [[5985], [20349]]]", "llm_generated_inputs": {"deepseek-v3": "[[5, 0], [5, 1], [5, 2], [7, 0], [7, 1], [7, 2], [10, 3], [10, 4], [0, 0], [1, 0], [1, 1], [20, 3], [20, 4], [100, 10], [15, 15]]", "qwen2.5-coder-32b-instruct": "[[7, 0], [7, 1], [7, 2], [20, 3], [20, 4], [0, 0], [1, 0], [1, 1], [10, 5], [15, 10], [100, 50]]"}}
{"requirement": "from typing import List\n\n\ndef chameleon(chameleons: List[int], color: int) -> int:\n\"\"\"**Story**  \nOn some island lives a chameleon population. Chameleons here can be of only one of three colors - red, green and blue. Whenever two chameleons of different colors meet, they can change their colors to a third one (i.e. when red and blue chameleons meet, they can both become green). There is no other way for chameleons to change their color (in particular, when red and blue chameleons meet, they can't become both red, only third color can be assumed).  \nChameleons want to become of one certain color. They may plan they meetings to reach that goal. Chameleons want to know, how fast their goal can be achieved (if it can be achieved at all).\n\n**Formal problem**  \n*Input:*  \nColor is coded as integer, 0 - red, 1 - green, 2 - blue.\nChameleon starting population is given as an array of three integers, with index corresponding to color (i.e. [2, 5, 3] means 2 red, 5 green and 3 blue chameleons). All numbers are non-negative, their sum is between `1` and `int.MaxValue` (maximal possible value for `int` type, in other languages). Desired color is given as an integer from 0 to 2.  \n*Output:*  \n`Kata.Chameleon` should return *minimal* number of meetings required to change all chameleons to a given color, or -1 if it is impossible (for example, if all chameleons are initially of one other color).  \n  \n**Notes and hints**  \n-- Some tests use rather big input values. Be effective.  \n-- There is a strict proof that answer is either -1 or no greater than total number of chameleons (thus, return type `int` is justified). Don't worry about overflow.  \n  \n**Credits**  \nKata based on \"Chameleons\" puzzle from braingames.ru: http://www.braingames.ru/?path=comments&puzzle=226 (russian, not translated).\n\"\"\"", "inputs": [[[0, 0, 17], 1], [[1, 1, 15], 2], [[34, 32, 35], 0], [[34, 32, 35], 1], [[33, 0, 35], 2], [[673905669, 673905681, 174867657], 2], [[74356, 0, 0], 0], [[1, 2147483646, 1], 1], [[0, 1, 0], 2], [[0, 1, 0], 1], [[0, 333, 0], 0]], "outputs": [[-1], [1], [35], [-1], [33], [673905681], [0], [1], [-1], [0], [-1]], "starter_code": "from typing import List\ndef chameleon(chameleons: List[int], color: int) -> int:", "canonical_solution": "def chameleon(chameleons, color):\n    (_, a), (_, b), (_, c) = sorted(((i == color, v) for i, v in enumerate(chameleons)))\n    return -1 if not a and (not c) or (b - a) % 3 else b", "entry_point": "chameleon", "task_id": "TACO_lite/1486", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 1, 1], 0], [[2, 2, 2], 1], [[3, 3, 3], 2], [[0, 0, 1], 0], [[0, 1, 0], 1], [[1, 0, 0], 2], [[1, 2, 3], 0], [[4, 5, 6], 1], [[7, 8, 9], 2], [[0, 0, 0], 0], [[0, 0, 0], 1], [[0, 0, 0], 2], [[1000000, 1000000, 1000000], 0], [[1000000, 1000000, 1000000], 1], [[1000000, 1000000, 1000000], 2], [[1, 0, 0], 0], [[0, 1, 0], 2], [[0, 0, 1], 1], [[1, 1, 0], 2], [[1, 0, 1], 1], [[0, 1, 1], 0]]", "qwen2.5-coder-32b-instruct": "[[[2, 5, 3], 0], [[1, 1, 1], 1], [[0, 0, 0], 0], [[10, 0, 0], 1], [[0, 10, 0], 2], [[0, 0, 10], 0], [[3, 3, 3], 3], [[1, 2, 3], 2], [[100, 100, 100], 100], [[1, 0, 1], 1], [[0, 1, 0], 0], [[1, 1, 0], 1], [[2, 2, 1], 2], [[1, 2, 2], 2], [[2, 1, 2], 2], [[3, 0, 3], 3], [[0, 3, 3], 3], [[3, 3, 0], 3], [[1000000, 0, 0], 1], [[0, 1000000, 0], 2], [[0, 0, 1000000], 0]]"}}
{"requirement": "def validate_word(word: str) -> bool:\n\"\"\"You are going to be given a word. Your job will be to make sure that each character in that word has the exact same number of occurrences. You will return `true` if it is valid, or `false` if it is not.\n\nFor example:\n\n`\"abcabc\"` is a valid word because `'a'` appears twice, `'b'` appears twice, and`'c'` appears twice.  \n`\"abcabcd\"` is **NOT** a valid word because `'a'` appears twice, `'b'` appears twice, `'c'` appears twice, but `'d'` only appears once!  \n`\"123abc!\"` is a valid word because all of the characters only appear once in the word.\n\nFor this kata, capitals are considered the same as lowercase letters. Therefore: `'A' == 'a'` .\n\n#Input \nA string (no spaces) containing `[a-z],[A-Z],[0-9]` and common symbols. The length will be `0 < string < 100`.\n\n#Output\n`true` if the word is a valid word, or `false` if the word is not valid.\n\"\"\"", "inputs": [["abcabc"], ["Abcabc"], ["AbcabcC"], ["AbcCBa"], ["pippi"], ["?!?!?!"], ["abc123"], ["abcabcd"], ["abc!abc!"], ["abc:abc"]], "outputs": [[true], [true], [false], [true], [false], [true], [true], [false], [true], [false]], "starter_code": "def validate_word(word: str) -> bool:", "canonical_solution": "from collections import Counter\n\ndef validate_word(word):\n    return len(set(Counter(word.lower()).values())) == 1", "entry_point": "validate_word", "task_id": "TACO_lite/1488", "input_output_examples": "[[['abcabc'], ['abcabcd'], ['123abc!']], [[True], [False], [True]]]", "llm_generated_inputs": {"deepseek-v3": "[['abcabc'], ['abcabcd'], ['123abc!'], ['AABBCc'], ['112233'], ['aabbccd'], ['a'], ['aa'], ['aA'], ['!@#!@#'], ['abacaba'], ['abacabac'], ['abcABCabc'], ['abcABC123'], ['abcABC123!!!'], [''], ['aaaabbbbccccddddeeee'], ['a1a1b2b2c3c3'], ['AaAaBbBbCcCc'], ['aabbc']]", "qwen2.5-coder-32b-instruct": "[['abcabc'], ['abcabcd'], ['123abc!'], ['AaBbCc'], ['112233'], ['!@#$%^'], ['aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz'], ['a'], ['1'], ['!'], ['abAB'], ['1234567890'], ['1234567890!'], ['aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz1'], ['abcABC123!@#'], ['abcABC123!@#abcABC123!@#'], ['abcABC123!@#abcABC123!@#a']]"}}
{"requirement": "from typing import List\n\n\ndef triple_shiftian(T: List[int], n: int) -> int:\n\"\"\"Much cooler than your run-of-the-mill Fibonacci numbers, the Triple Shiftian are so defined: `T[n] = 4 * T[n-1] - 5 * T[n-2] + 3 * T[n-3]`.\n\nYou are asked to create a function which accept a base with the first 3 numbers and then returns the nth element.\n```python\ntriple_shiftian([1,1,1],25) == 1219856746\ntriple_shiftian([1,2,3],25) == 2052198929\ntriple_shiftian([6,7,2],25) == -2575238999\ntriple_shiftian([3,2,1],35) == 23471258855679\ntriple_shiftian([1,9,2],2) ==  2\n```\n*Note: this is meant to be an interview quiz, so the description is scarce in detail on purpose*\n\nSpecial thanks to the [first person I met in person here in London just because of CW](http://www.codewars.com/users/webtechalex) and that assisted me during the creation of this kata ;)\n\"\"\"", "inputs": [[[1, 1, 1, 2, 6, 17, 44, 109, 267, 655, 1612, 3974, 9801, 24170, 59597, 146941, 362289, 893242, 2202346, 5430041, 13388160, 33009473, 81387215, 200665975, 494756244, 1219856746], 25], [[1, 2, 3, 5, 11, 28, 72, 181, 448, 1103, 2715, 6689, 16490, 40660, 100257, 247198, 609487, 1502729, 3705075, 9135116, 22523276, 55532749, 136919964, 337585939, 832342183, 2052198929], 25], [[3, 2, 1, 3, 13, 40, 104, 255, 620, 1517, 3733, 9207, 22714, 56020, 138131, 340566, 839669, 2070239, 5104309, 12585048, 31029364, 76505143, 188628896, 465077961, 1146682793, 2827228055], 25], [[6, 7, 2, -9, -25, -49, -98, -222, -545, -1364, -3397, -8403, -20719, -51052, -125822, -310185, -764786, -1885685, -4649365, -11463393, -28263802, -69686338, -171816521, -423625800, -1044479609, -2575238999], 25], [[1, 1, 1, 2, 6, 17, 44, 109, 267, 655, 1612, 3974, 9801, 24170, 59597, 146941, 362289, 893242, 2202346, 5430041, 13388160, 33009473, 81387215, 200665975, 494756244, 1219856746, 3007643689, 7415559758, 18283590825, 45079495577, 111146707457, 274040124418, 675665447118, 1665901288753, 4107398292676, 10127083068293], 35], [[1, 2, 3, 5, 11, 28, 72, 181, 448, 1103, 2715, 6689, 16490, 40660, 100257, 247198, 609487, 1502729, 3705075, 9135116, 22523276, 55532749, 136919964, 337585939, 832342183, 2052198929, 5059842618, 12475402376, 30758993201, 75838488778, 186985196235, 461025320653, 1136690767771, 2802592056524, 6909990349200, 17037073417493], 35], [[3, 2, 1, 3, 13, 40, 104, 255, 620, 1517, 3733, 9207, 22714, 56020, 138131, 340566, 839669, 2070239, 5104309, 12585048, 31029364, 76505143, 188628896, 465077961, 1146682793, 2827228055, 6970732138, 17186836656, 42375370099, 104479493530, 257601633593, 635135177019, 1565971020701, 3861013098488, 9519602821504, 23471258855679], 35], [[6, 7, 2, -9, -25, -49, -98, -222, -545, -1364, -3397, -8403, -20719, -51052, -125822, -310185, -764786, -1885685, -4649365, -11463393, -28263802, -69686338, -171816521, -423625800, -1044479609, -2575238999, -6349435351, -15654985236, -38598481186, -95167304617, -234641768246, -578525993457, -1426397046449, -3516883523249, -8671126841122, -21379280887590], 35], [[3, 2, 1], 0], [[6, 7, 2], 2]], "outputs": [[1219856746], [2052198929], [2827228055], [-2575238999], [10127083068293], [17037073417493], [23471258855679], [-21379280887590], [3], [2]], "starter_code": "from typing import List\ndef triple_shiftian(T: List[int], n: int) -> int:", "canonical_solution": "def triple_shiftian(T, n):\n    for i in range(3, n + 1):\n        T.append(4 * T[i - 1] - 5 * T[i - 2] + 3 * T[i - 3])\n    return T[n]", "entry_point": "triple_shiftian", "task_id": "TACO_lite/1490", "input_output_examples": "[[[[1, 1, 1], 25], [[1, 2, 3], 25], [[6, 7, 2], 25], [[3, 2, 1], 35], [[1, 9, 2], 2]], [[1219856746], [2052198929], [-2575238999], [23471258855679], [2]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 1, 1], 25], [[1, 2, 3], 25], [[6, 7, 2], 25], [[3, 2, 1], 35], [[1, 9, 2], 2], [[0, 0, 0], 10], [[1, 0, 0], 5], [[0, 1, 0], 5], [[0, 0, 1], 5], [[1, 2, 3], 0], [[1, 2, 3], 1], [[1, 2, 3], 2], [[-1, -2, -3], 10], [[10, 20, 30], 15], [[1, 1, 1], 100]]", "qwen2.5-coder-32b-instruct": "[[[1, 1, 1], 0], [[1, 1, 1], 1], [[1, 1, 1], 2], [[1, 1, 1], 25], [[1, 2, 3], 25], [[6, 7, 2], 25], [[3, 2, 1], 35], [[1, 9, 2], 2], [[0, 0, 0], 10], [[1, -1, 1], 10], [[100, 200, 300], 5], [[1, 1, 1], 100]]"}}
{"requirement": "def count_vowels(s: str = '') -> int:\n\"\"\"Write a function `count_vowels` to count the number of vowels in a given string.\n\n### Notes:\n\n- Return `nil` or `None` for non-string inputs.\n- Return `0` if the parameter is omitted.\n\n### Examples:\n\n```python\ncount_vowels(\"abcdefg\") => 2\ncount_vowels(\"aAbcdeEfg\") => 4\n\ncount_vowels(12) => None\n```\n\"\"\"", "inputs": [["abcdefg"], ["asdfdsafdsafds"], [""], ["asdfdsaf  asdfsdaf  13243242  dsafdsafds"], ["aeiouAEIOU"], ["1213"], ["12        3"], ["ewqriwetruituofdsajflsd23423r5043"], ["asdfviosdfopsiewrwwer   asdf  asdfdsaf)(asdflkajdsf "], ["asdfdsaf  asdfsasdfdsafgjlsdjf   asdfdsf daf  13243242  dsafdsafds"], ["aeiouAEdsafdsf  asdfw2434&***OU"], [12], [[]], [{}]], "outputs": [[2], [3], [0], [6], [10], [0], [0], [8], [12], [9], [11], [null], [null], [null]], "starter_code": "def count_vowels(s: str = '') -> int:", "canonical_solution": "def count_vowels(s=''):\n    return sum((x.lower() in 'aeoui' for x in s)) if type(s) == str else None", "entry_point": "count_vowels", "task_id": "TACO_lite/1498", "input_output_examples": "[[['abcdefg'], ['aAbcdeEfg'], [12]], [[2], [4], [None]]]", "llm_generated_inputs": {"deepseek-v3": "[['abcdefg'], ['aAbcdeEfg'], ['xyz'], [''], ['AEIOUaeiou'], ['12345'], ['!@#$%'], [12], [None], [True]]", "qwen2.5-coder-32b-instruct": "[['abcdefg'], ['aAbcdeEfg'], [12], [''], ['AEIOUaeiou'], ['bcdfghjklmnpqrstvwxyz'], ['1234567890'], ['!@#$%^&*()'], ['A quick brown fox jumps over the lazy dog']]"}}
{"requirement": "from typing import List\n\n\ndef artificial_rain(garden: List[int]) -> int:\n\"\"\"Little Petya often visits his grandmother in the countryside. The grandmother has a large vertical garden, which can be represented as a set of `n` rectangles of varying height. Due to the newest irrigation system we can create artificial rain above them.\n\nCreating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. The water will then flow to the neighbouring sections but only if each of their heights does not exceed the height of the previous watered section.\n\n___\n\n## Example:\n\nLet's say there's a garden consisting of 5 rectangular sections of heights `4, 2, 3, 3, 2`.\n\nCreating the artificial rain over the left-most section is inefficient as the water **WILL FLOW DOWN** to the section with the height of `2`, but it **WILL NOT FLOW UP** to the section with the height of `3` from there. Only 2 sections will be covered: `4, 2`.\n\nThe most optimal choice will be either of the sections with the height of `3` because the water will flow to its neighbours covering 4 sections altogether: `2, 3, 3, 2`. You can see this process in the following illustration:\n\n\n\n___\n\nAs Petya is keen on programming, he decided to find such section that if we create artificial rain above it, the number of watered sections will be maximal.\n\n## Output:\nThe maximal number of watered sections if we create artificial rain above exactly one section.\n\n**Note: performance will be tested.**\n\"\"\"", "inputs": [[[2]], [[1, 2, 1, 2, 1]], [[4, 2, 3, 3, 2]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]], [[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]], [[1, 2, 3, 4, 5, 1, 5, 4, 3, 2, 1]], [[1, 1, 1, 2, 1, 2, 10, 2, 3, 3]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 8, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 100, 7, 6, 5, 4, 3, 2, 1]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 1, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 100, 7, 6, 5, 4, 3, 2, 1]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 1, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 4, 88, 89, 90, 2, 92, 100, 7, 6, 5, 4, 3, 2, 1]]], "outputs": [[1], [3], [4], [10], [10], [11], [6], [5], [53], [61], [48]], "starter_code": "from typing import List\ndef artificial_rain(garden: List[int]) -> int:", "canonical_solution": "def artificial_rain(garden):\n    left, area, record = (0, 0, 1)\n    for i in range(1, len(garden)):\n        if garden[i] < garden[i - 1]:\n            left = i\n        elif garden[i] > garden[i - 1]:\n            area = max(area, record)\n            record = i - left\n        record += 1\n    return max(area, record)", "entry_point": "artificial_rain", "task_id": "TACO_lite/1504", "input_output_examples": "[[[[4, 2, 3, 3, 2]]], [[4]]]", "llm_generated_inputs": {"deepseek-v3": "[[[4, 2, 3, 3, 2]], [[1, 2, 3, 4, 5]], [[5, 4, 3, 2, 1]], [[1, 1, 1, 1, 1]], [[1]], [[3, 3, 3, 3, 2, 2, 2, 1, 1, 1]], [[1, 2, 1, 2, 1, 2, 1]], [[10, 10, 10, 10, 10, 10, 10, 10, 10, 10]], [[2, 5, 3, 8, 6, 7, 1]], [[7, 1, 2, 3, 4, 5, 6, 7, 8, 9]], [[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]], [[1, 3, 5, 7, 9, 8, 6, 4, 2]], [[2, 4, 6, 8, 10, 9, 7, 5, 3, 1]], [[1, 2, 3, 4, 5, 4, 3, 2, 1]], [[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]]]", "qwen2.5-coder-32b-instruct": "[[[4, 2, 3, 3, 2]], [[1, 2, 3, 4, 5]], [[5, 4, 3, 2, 1]], [[1, 1, 1, 1, 1]], [[1, 2, 1, 2, 1]], [[3, 3, 3, 3, 3]], [[10]], [[]], [[1, 3, 2, 4, 3, 2, 1]], [[1, 2, 3, 2, 1, 2, 3]]]"}}
{"requirement": "def lcs(x: str, y: str) -> str:\n\"\"\"Write a function called `LCS` that accepts two sequences and returns the longest subsequence common to the passed in sequences.\n\n### Subsequence\nA subsequence is different from a substring. The terms of a subsequence need not be consecutive terms of the original sequence.\n\n\n\n### Example subsequence\nSubsequences of `\"abc\"` = `\"a\"`, `\"b\"`, `\"c\"`, `\"ab\"`, `\"ac\"`, `\"bc\"` and `\"abc\"`.\n\n### LCS examples\n```python\nlcs( \"abcdef\" , \"abc\" ) => returns \"abc\"\nlcs( \"abcdef\" , \"acf\" ) => returns \"acf\"\nlcs( \"132535365\" , \"123456789\" ) => returns \"12356\"\n```\n\n### Notes\n* Both arguments will be strings\n* Return value must be a string\n* Return an empty string if there exists no common subsequence\n* Both arguments will have one or more characters (in JavaScript)\n* All tests will only have a single longest common subsequence. Don't worry about cases such as `LCS( \"1234\", \"3412\" )`, which would have two possible longest common subsequences: `\"12\"` and `\"34\"`.\n\nNote that the Haskell variant will use randomized testing, but any longest common subsequence will be valid.\n\nNote that the OCaml variant is using generic lists instead of strings, and will also have randomized tests (any longest common subsequence will be valid).\n\n### Tips\n\nWikipedia has an explanation of the two properties that can be used to solve the problem:\n\n- [First property](http://en.wikipedia.org/wiki/Longest_common_subsequence_problem#First_property)\n- [Second property](http://en.wikipedia.org/wiki/Longest_common_subsequence_problem#Second_property)\n\"\"\"", "inputs": [["a", "b"], ["a", "a"], ["abc", "ac"], ["abcdef", "abc"], ["abcdef", "acf"], ["anothertest", "notatest"], ["132535365", "123456789"], ["finaltest", "zzzfinallyzzz"]], "outputs": [[""], ["a"], ["ac"], ["abc"], ["acf"], ["nottest"], ["12356"], ["final"]], "starter_code": "def lcs(x: str, y: str) -> str:", "canonical_solution": "def lcs(x, y):\n    if len(x) == 0 or len(y) == 0:\n        return ''\n    if x[-1] == y[-1]:\n        return lcs(x[:-1], y[:-1]) + x[-1]\n    else:\n        lcs1 = lcs(x, y[:-1])\n        lcs2 = lcs(x[:-1], y)\n        if len(lcs1) > len(lcs2):\n            return lcs1\n        else:\n            return lcs2", "entry_point": "lcs", "task_id": "TACO_lite/1509", "input_output_examples": "[[['abcdef', 'abc'], ['abcdef', 'acf'], ['132535365', '123456789']], [['abc'], ['acf'], ['12356']]]", "llm_generated_inputs": {"deepseek-v3": "[['abcdef', 'abc'], ['abcdef', 'acf'], ['132535365', '123456789'], ['hello', 'world'], ['abc', 'def'], ['abc', 'abc'], ['a', 'a'], ['longest', 'stone'], ['1234', '3412'], ['', ''], ['abc', ''], ['', 'abc']]", "qwen2.5-coder-32b-instruct": "[['abcdef', 'abc'], ['abcdef', 'acf'], ['132535365', '123456789'], ['a', 'a'], ['a', 'b'], ['abc', 'def'], ['', ''], ['aaaa', 'aa'], ['abcdgh', 'aedfhr'], ['aggtab', 'gxtxayb'], ['abcdefghijklmnopqrstuvwxyz', 'zyxwvutsrqponmlkjihgfedcba'], ['longest', 'stone']]"}}
{"requirement": "from typing import List\nfrom typing import Dict\n\n\ndef get_char_count(s: str) -> Dict[int, List[str]]:\n\"\"\"Write a method that takes a string as an argument and groups the number of time each character appears in the string as a hash sorted by the highest number of occurrences.\n\nThe characters should be sorted alphabetically e.g:\n\n```python\nget_char_count(\"cba\") == {1: [\"a\", \"b\", \"c\"]}\n```\n\nYou should ignore spaces, special characters and count uppercase letters as lowercase ones.\n\nFor example: \n```python\nget_char_count(\"Mississippi\")           ==  {4: [\"i\", \"s\"], 2: [\"p\"], 1: [\"m\"]}\nget_char_count(\"Hello. Hello? HELLO!\")  ==  {6: [\"l\"], 3: [\"e\", \"h\", \"o\"]}\nget_char_count(\"aaa...bb...c!\")         ==  {3: [\"a\"], 2: [\"b\"], 1: [\"c\"]}\nget_char_count(\"abc123\")                ==  {1: [\"1\", \"2\", \"3\", \"a\", \"b\", \"c\"]}\nget_char_count(\"aaabbbccc\")             ==  {3: [\"a\", \"b\", \"c\"]}\n```\n\"\"\"", "inputs": [["Get me the bacon!"], ["Codewars is bacon"], ["France is also bacon"], ["AaAAaAAabB!B!B3b23jdc"], [""], ["!!!@@@"], ["Mississippi"], ["Hello. Hello? HELLO!"], ["aaa...bb...c!"], ["abc123"], ["aaabbbccc"]], "outputs": [[{"1": ["a", "b", "c", "g", "h", "m", "n", "o"], "2": ["t"], "3": ["e"]}], [{"1": ["b", "d", "e", "i", "n", "r", "w"], "2": ["a", "c", "o", "s"]}], [{"1": ["b", "e", "f", "i", "l", "r"], "2": ["c", "n", "o", "s"], "3": ["a"]}], [{"1": ["2", "c", "d", "j"], "2": ["3"], "5": ["b"], "8": ["a"]}], [{}], [{}], [{"1": ["m"], "2": ["p"], "4": ["i", "s"]}], [{"3": ["e", "h", "o"], "6": ["l"]}], [{"1": ["c"], "2": ["b"], "3": ["a"]}], [{"1": ["1", "2", "3", "a", "b", "c"]}], [{"3": ["a", "b", "c"]}]], "starter_code": "from typing import List\nfrom typing import Dict\ndef get_char_count(s: str) -> Dict[int, List[str]]:", "canonical_solution": "def get_char_count(s):\n    counts = {}\n    for c in (c.lower() for c in s if c.isalnum()):\n        counts[c] = counts[c] + 1 if c in counts else 1\n    m = {}\n    for k, v in counts.items():\n        m[v] = sorted(m[v] + [k]) if v in m else [k]\n    return m", "entry_point": "get_char_count", "task_id": "TACO_lite/1510", "input_output_examples": "[[['cba'], ['Mississippi'], ['Hello. Hello? HELLO!'], ['aaa...bb...c!'], ['abc123'], ['aaabbbccc']], [[{1: ['a', 'b', 'c']}], [{4: ['i', 's'], 2: ['p'], 1: ['m']}], [{6: ['l'], 3: ['e', 'h', 'o']}], [{3: ['a'], 2: ['b'], 1: ['c']}], [{1: ['1', '2', '3', 'a', 'b', 'c']}], [{3: ['a', 'b', 'c']}]]]", "llm_generated_inputs": {"deepseek-v3": "[['cba'], ['Mississippi'], ['Hello. Hello? HELLO!'], ['aaa...bb...c!'], ['abc123'], ['aaabbbccc'], [''], ['   '], ['!!!@@@###'], ['AaA bBb CcC'], ['123 456 789'], ['a1b2c3 d4e5f6'], ['aA aA aA'], ['aA!@#bB$%^cC&*('], ['aA!@#bB$%^cC&*()dD']]", "qwen2.5-coder-32b-instruct": "[['Mississippi'], ['Hello. Hello? HELLO!'], ['aaa...bb...c!'], ['abc123'], ['aaabbbccc'], ['cba'], ['AaAaAaAaAa'], ['1234567890'], ['!@#$%^&*()'], ['   '], [''], ['a b c d e f g h i j k l m n o p q r s t u v w x y z'], ['A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'], ['The quick brown fox jumps over the lazy dog']]"}}
{"requirement": "from typing import List\n\n\ndef max_profit(prices: List[int]) -> int:\n\"\"\"You're a buyer/seller and your buisness is at stake... You ___need___ to make profit... Or at least, you need to lose the least amount of money!  \nKnowing a list of prices for buy/sell operations, you need to pick two of them. Buy/sell market is evolving across time and the list represent this evolution. First, you need to buy one item, then sell it later. Find the best profit you can do.\n\n### Example:\n\nGiven an array of prices `[3, 10, 8, 4]`, the best profit you could make would be `7` because you buy at `3` first, then sell at `10`.\n\n# Input:\n\nA list of prices (integers), of length 2 or more.\n\n# Output:\n\nThe result of the best buy/sell operation, as an integer.\n\n\n\n### Note:\nBe aware you'll face lists with several thousands of elements, so think about performance.\n\"\"\"", "inputs": [[[10, 7, 5, 8, 11, 9]], [[3, 4]], [[9, 9]], [[10, 7, 5, 4, 1]]], "outputs": [[6], [1], [0], [-1]], "starter_code": "from typing import List\ndef max_profit(prices: List[int]) -> int:", "canonical_solution": "def max_profit(prices):\n    m = best = float('-inf')\n    for v in reversed(prices):\n        m, best = (max(m, best - v), max(best, v))\n    return m", "entry_point": "max_profit", "task_id": "TACO_lite/1518", "input_output_examples": "[[[[3, 10, 8, 4]]], [[7]]]", "llm_generated_inputs": {"deepseek-v3": "[[[3, 10, 8, 4]], [[7, 1, 5, 3, 6, 4]], [[10, 7, 5, 8, 11, 9]], [[5, 4, 3, 2, 1]], [[1, 2, 3, 4, 5]], [[2, 2, 2, 2, 2]], [[100, 180, 260, 310, 40, 535, 695]], [[10, 22, 5, 75, 65, 80]], [[1]], [[]]]", "qwen2.5-coder-32b-instruct": "[[[3, 10, 8, 4]], [[7, 1, 5, 3, 6, 4]], [[7, 6, 4, 3, 1]], [[1, 2, 3, 4, 5]], [[10, 9, 8, 2, 3, 1]], [[1, 2]], [[2, 1]], [[1, 2, 2, 1]], [[1, 1, 1, 1]], [[100, 180, 260, 310, 40, 535, 695]]]"}}
{"requirement": "def decrypt(s: str) -> str:\n\"\"\"# Task\n Smartphones software security has become a growing concern related to mobile telephony. It is particularly important as it relates to the security of available personal information.\n \n For this reason, Ahmed decided to encrypt phone numbers of contacts in such a way that nobody can decrypt them. At first he tried encryption algorithms very complex, but the decryption process is tedious, especially when he needed to dial a speed dial.\n\n He eventually found the algorithm following: instead of writing the number itself, Ahmed multiplied by 10, then adds the result to the original number.\n \n For example, if the phone number is `123`, after the transformation, it becomes `1353`. Ahmed truncates the result (from the left), so it has as many digits as the original phone number. In this example Ahmed wrote `353` instead of `123` in his smart phone.\n\n Ahmed needs a program to recover the original phone number from number stored on his phone. The program return \"impossible\" if the initial number can not be calculated.\n \n Note: There is no left leading zero in either the input or the output; Input `s` is given by string format, because it may be very huge ;-)\n\n# Example\n\n For `s=\"353\"`, the result should be `\"123\"`\n \n ```\n    1230\n  +  123\n  .......\n  = 1353  \n  \n  truncates the result to 3 digit -->\"353\"\n  \n  So the initial number is \"123\"\n ```\n For `s=\"123456\"`, the result should be `\"738496\"`\n \n ```\n    7384960\n  +  738496\n  .........\n  = 8123456\n  \n  truncates the result to 6 digit -->\"123456\"\n  \n  So the initial number is \"738496\"\n ```\n For `s=\"4334\"`, the result should be `\"impossible\"`\n \n Because no such a number can be encrypted to `\"4334\"`.\n\n# Input/Output\n\n\n - `[input]` string `s`\n\n  string presentation of n with `1 <= n <= 10^100`\n\n\n - `[output]` a string\n\n  The original phone number before encryption, or `\"impossible\"` if the initial number can not be calculated.\n\"\"\"", "inputs": [["353"], ["444"], ["123456"], ["147"], ["4334"]], "outputs": [["123"], ["404"], ["738496"], ["377"], ["impossible"]], "starter_code": "def decrypt(s: str) -> str:", "canonical_solution": "def decrypt(s):\n    return next((str(b // 11) for b in (int(str(a) + s) for a in range(1, 11)) if b % 11 == 0), 'impossible')", "entry_point": "decrypt", "task_id": "TACO_lite/1523", "input_output_examples": "[[['353'], ['123456'], ['4334']], [['123'], ['738496'], ['impossible']]]", "llm_generated_inputs": {"deepseek-v3": "[['353'], ['123456'], ['4334'], ['1'], ['9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'], ['10'], ['738496'], ['0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'], ['987654321'], ['1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111']]", "qwen2.5-coder-32b-instruct": "[['353'], ['123456'], ['4334'], ['0'], ['1'], ['10'], ['999'], ['1001'], ['1111111111'], ['9876543210'], ['10000000000'], ['11111111111111111111111111111111111111111111111111'], ['99999999999999999999999999999999999999999999999999']]"}}
{"requirement": "def split_in_parts(s: str, part_length: int) -> str:\n\"\"\"The aim of this kata is to split a given string into different strings of equal size (note size of strings is passed to the method)\n\nExample:\n\n    Split the below string into other strings of size #3\n\n    'supercalifragilisticexpialidocious'\n\n    Will return a new string\n    'sup erc ali fra gil ist ice xpi ali doc iou s'\n\n\nAssumptions:\n\n    String length is always greater than 0\n    String has no spaces\n    Size is always positive\n\"\"\"", "inputs": [["supercalifragilisticexpialidocious", 3], ["HelloKata", 1], ["HelloKata", 9]], "outputs": [["sup erc ali fra gil ist ice xpi ali doc iou s"], ["H e l l o K a t a"], ["HelloKata"]], "starter_code": "def split_in_parts(s: str, part_length: int) -> str:", "canonical_solution": "from textwrap import wrap\n\ndef split_in_parts(s, part_length):\n    return ' '.join(wrap(s, part_length))", "entry_point": "split_in_parts", "task_id": "TACO_lite/1528", "input_output_examples": "[[['supercalifragilisticexpialidocious', 3]], [['sup erc ali fra gil ist ice xpi ali doc iou s']]]", "llm_generated_inputs": {"deepseek-v3": "[['supercalifragilisticexpialidocious', 3], ['abcdefgh', 2], ['hello', 1], ['python', 6], ['a', 1], ['abcdef', 4], ['testcase', 5], ['longstringwithnospaces', 7]]", "qwen2.5-coder-32b-instruct": "[['supercalifragilisticexpialidocious', 3], ['abcdefg', 1], ['abcdefg', 7], ['abcdefg', 2], ['a', 1], ['thisisatest', 5], ['shortword', 10], ['boundarycase', 4]]"}}
{"requirement": "from typing import List\n\n\ndef mult_primefactor_sum(a: int, b: int) -> List[int]:\n\"\"\"Every number may be factored in prime factors.\n\nFor example, the number 18 may be factored by its prime factors ``` 2 ``` and ```3```\n```\n18 = 2 . 3 . 3 = 2 . 3²\n```\nThe sum of the prime factors of 18 is  ```2 + 3 + 3 = 8```\n\nBut some numbers like 70 are divisible by the sum of its prime factors:\n```\n70 = 2 . 5 . 7 # sum of prime factors = 2 + 5 + 7 = 14\nand 70 is a multiple of 14\n```\nOf course that primes would fulfill this property, but is obvious, because the prime decomposition of a number, is the number itself and every number is divisible by iself. That is why we will discard every prime number in the results\n\nWe are interested in collect the integer positive numbers (non primes) that have this property in a certain range ```[a, b]``` (inclusive).\n\nMake the function ```mult_primefactor_sum()```, that receives the values ```a```, ```b``` as limits of the range ```[a, b]``` and ```a < b``` and outputs the sorted list of these numbers.\n\nLet's see some cases:\n```python\nmult_primefactor_sum(10, 100) == [16, 27, 30, 60, 70, 72, 84] \n\nmult_primefactor_sum(1, 60) == [1, 4, 16, 27, 30, 60]\n```\n\"\"\"", "inputs": [[10, 100], [80, 150], [90, 200]], "outputs": [[[16, 27, 30, 60, 70, 72, 84]], [[84, 105, 150]], [[105, 150, 180]]], "starter_code": "from typing import List\ndef mult_primefactor_sum(a: int, b: int) -> List[int]:", "canonical_solution": "def mult_primefactor_sum(a, b):\n    s = []\n    for i in range(a, b + 1):\n        r = factorize_add(i)\n        if r != i and i % r == 0:\n            s.append(i)\n    return s\n\ndef factorize_add(num):\n    if num < 4:\n        return num\n    d = 2\n    p = 0\n    while d < num ** 0.5 + 1:\n        while not num % d:\n            p += d\n            num /= d\n        d += 1 if d == 2 else 2\n    return p if num == 1 else p + num", "entry_point": "mult_primefactor_sum", "task_id": "TACO_lite/1530", "input_output_examples": "[[[10, 100], [1, 60]], [[[16, 27, 30, 60, 70, 72, 84]], [[1, 4, 16, 27, 30, 60]]]]", "llm_generated_inputs": {"deepseek-v3": "[[10, 100], [1, 60], [2, 20], [50, 150], [1, 1], [100, 120], [30, 50], [70, 80], [1, 2], [4, 10]]", "qwen2.5-coder-32b-instruct": "[[10, 100], [1, 60], [20, 50], [100, 200], [1, 1], [2, 2], [3, 5], [14, 14], [70, 70], [60, 70]]"}}
{"requirement": "def hammingweight(n: int) -> int:\n\"\"\"Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).\n\nNote:\n\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\nIn Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer -3.\n \nExample 1:\nInput: n = 00000000000000000000000000001011\nOutput: 3\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.\n\nExample 2:\nInput: n = 00000000000000000000000010000000\nOutput: 1\nExplanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.\n\nExample 3:\nInput: n = 11111111111111111111111111111101\nOutput: 31\nExplanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.\n \n\nConstraints:\n\nThe input must be a binary string of length 32.\n \nFollow up: If this function is called many times, how would you optimize it?\n\"\"\"", "inputs": [[11], [128], [4294967293]], "outputs": [[3], [1], [31]], "starter_code": "def hammingweight(n: int) -> int:", "canonical_solution": "def hammingweight(n: int) -> int:\n    count = 0\n    while n != 0:\n        n &= n - 1\n        count += 1\n    return count", "entry_point": "hammingweight", "task_id": "TACO_lite/1538", "input_output_examples": "[[[11], [128], [4294967293]], [[3], [1], [31]]]", "llm_generated_inputs": {"deepseek-v3": "[[11], [128], [4294967293], [0], [4294967295], [2863311530], [1431655765], [2147483648], [1], [3758096384]]", "qwen2.5-coder-32b-instruct": "[[11], [128], [4294967293], [0], [4294967295], [2863311530], [1431655765], [-3], [1], [2147483647], [-2147483648]]"}}
{"requirement": "from typing import List\n\n\ndef or_arrays(a1: List[int], a2: List[int], d: int = 0) -> List[int]:\n\"\"\"It started as a discussion with a friend, who didn't fully grasp some way of setting defaults, but I thought the idea was cool enough for a beginner kata: binary `OR` each matching element of two given arrays (or lists, if you do it in Python; vectors in c++) of integers and give the resulting ORed array [starts to sound like a tonguetwister, doesn't it?].\n\nIf one array is shorter than the other, use the optional third parametero (defaulted to `0`) to `OR` the unmatched elements.\n\nFor example:\n\n```python\nor_arrays([1,2,3],[1,2,3]) == [1,2,3]\nor_arrays([1,2,3],[4,5,6]) == [5,7,7]\nor_arrays([1,2,3],[1,2]) == [1,2,3]\nor_arrays([1,2],[1,2,3]) == [1,2,3]\nor_arrays([1,2,3],[1,2,3],3) == [1,2,3]\n```\n\"\"\"", "inputs": [[[1, 2, 3], [1, 2, 3]], [[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [1, 2]], [[1, 0], [1, 2, 3]], [[1, 0, 3], [1, 2, 3], 3]], "outputs": [[[1, 2, 3]], [[5, 7, 7]], [[1, 2, 3]], [[1, 2, 3]], [[1, 2, 3]]], "starter_code": "from typing import List\ndef or_arrays(a1: List[int], a2: List[int], d: int = 0) -> List[int]:", "canonical_solution": "from itertools import zip_longest\n\ndef or_arrays(a1, a2, d=0):\n    return [x | y for x, y in zip_longest(a1, a2, fillvalue=d)]", "entry_point": "or_arrays", "task_id": "TACO_lite/1540", "input_output_examples": "[[[[1, 2, 3], [1, 2, 3]], [[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [1, 2]], [[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [1, 2, 3], 3]], [[[1, 2, 3]], [[5, 7, 7]], [[1, 2, 3]], [[5, 7, 7]], [[1, 2, 3]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3], [1, 2, 3], 0], [[1, 2, 3], [4, 5, 6], 0], [[1, 2, 3], [1, 2], 0], [[1, 2], [1, 2, 3], 0], [[1, 2, 3], [1, 2, 3], 3], [[], [1, 2, 3], 0], [[1, 2, 3], [], 0], [[], [], 0], [[1, 2, 3], [1, 2, 3], 1], [[1, 2, 3], [4, 5, 6], 2], [[1, 2, 3], [1, 2], 4], [[1, 2], [1, 2, 3], 5]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3], [1, 2, 3], 3], [[1, 2, 3], [], 5], [[], [1, 2, 3], 5], [[], [], 0]]"}}
{"requirement": "from typing import Union\n\n\ndef baby_count(x: str) -> Union[int, str]:\n\"\"\"You've had a baby.\n\nWell done. Nice isn't it? Life destroying... but in a good way.\n\nPart of your new routine is lying awake at night worrying that you've either lost the baby... or that you have more than 1!\n\nGiven a string of words (x), you need to calculate how many babies are in it. To count as a baby you must have all of the letters in baby ('b', 'a', 'b', 'y'). That counts as 1. They do not need to be in order in the string. Upper and lower case letters count.\n\nExamples:\n\nIf there are no babies in the string - you lost the baby!! Return a different value, as shown below:\n\n```if-not:kotlin\n'none here' = \"Where's the baby?!\"\n'' = \"Where's the baby?!\"\n```\n\n```if:kotlin \n\"none here\" = null\n\"\" = null\n```\n\"\"\"", "inputs": [["baby"], ["abby"], ["baby baby baby"], ["Why the hell are there so many babies?!"], ["Anyone remember life before babies?"], ["Happy babies boom ba by?"], ["b a b y"], [""], ["none here"]], "outputs": [[1], [1], [3], [1], [1], [2], [1], ["Where's the baby?!"], ["Where's the baby?!"]], "starter_code": "from typing import Union\ndef baby_count(x: str) -> Union[int, str]:", "canonical_solution": "def baby_count(x):\n    x = x.lower()\n    return min(x.count('a'), x.count('b') // 2, x.count('y')) or \"Where's the baby?!\"", "entry_point": "baby_count", "task_id": "TACO_lite/1550", "input_output_examples": "[[['none here'], ['']], [[\"Where's the baby?!\"], [\"Where's the baby?!\"]]]", "llm_generated_inputs": {"deepseek-v3": "[['baby'], ['bbabyy'], ['ababyb'], ['bbya'], ['BABY'], ['BbAbYy'], ['babby'], ['aabyb'], ['none here'], [''], ['bbay'], ['bby'], ['bya'], ['baby baby'], ['babybaby'], ['babyybabby'], ['bbbaaayyy'], ['bbaaayy'], ['bbaaay'], ['bbayyy'], ['bbabyyy']]", "qwen2.5-coder-32b-instruct": "[['babycakes'], ['BabY'], ['babybaby'], ['bbya'], ['ybabab'], ['babayy'], ['bababababababababababababababababa'], ['none here'], [''], ['no babies here'], ['baBaBy'], ['bbyyaa']]"}}
{"requirement": "from typing import List\n\n\ndef common(a: List[int], b: List[int], c: List[int]) -> int:\n\"\"\"Given three arrays of integers, return the sum of elements that are common in all three arrays.\n\nFor example: \n\n```\ncommon([1,2,3],[5,3,2],[7,3,2]) = 5 because 2 & 3 are common in all 3 arrays\ncommon([1,2,2,3],[5,3,2,2],[7,3,2,2]) = 7 because 2,2 & 3 are common in the 3 arrays\n```\n\nMore examples in the test cases. \n\nGood luck!\n\"\"\"", "inputs": [[[1, 2, 3], [5, 3, 2], [7, 3, 2]], [[1, 2, 2, 3], [5, 3, 2, 2], [7, 3, 2, 2]], [[1], [1], [1]], [[1], [1], [2]]], "outputs": [[5], [7], [1], [0]], "starter_code": "from typing import List\ndef common(a: List[int], b: List[int], c: List[int]) -> int:", "canonical_solution": "from collections import Counter\n\ndef common(a, b, c):\n    return sum((Counter(a) & Counter(b) & Counter(c)).elements())", "entry_point": "common", "task_id": "TACO_lite/1555", "input_output_examples": "[[[[1, 2, 3], [5, 3, 2], [7, 3, 2]], [[1, 2, 2, 3], [5, 3, 2, 2], [7, 3, 2, 2]]], [[5], [7]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3], [5, 3, 2], [7, 3, 2]], [[1, 2, 2, 3], [5, 3, 2, 2], [7, 3, 2, 2]], [[1, 1, 1], [1, 1, 1], [1, 1, 1]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[], [], []], [[1, 2, 3], [1, 2], [1]], [[10, 20, 30, 40], [10, 20, 30], [10, 20]], [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [3, 4, 5]], [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]], [[1, 1, 2, 2], [2, 2, 3, 3], [2, 2, 4, 4]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3], [5, 3, 2], [7, 3, 2]], [[1, 2, 2, 3], [5, 3, 2, 2], [7, 3, 2, 2]], [[1, 4, 5], [4, 5, 6], [5, 6, 7]], [[1, 1, 1], [1, 1, 1], [1, 1, 1]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 20, 30], [20, 30, 40], [30, 40, 50]], [[1, 2, 3, 3, 3], [3, 3, 3, 2, 1], [3, 2, 1, 1, 1]], [[], [], []], [[1, 2, 3], [], [1, 2, 3]], [[1, 2, 3], [1, 2, 3], []]]"}}
{"requirement": "def get_char(c: int) -> str:\n\"\"\"Write a function which takes a number and returns the corresponding ASCII char for that value.\n\nExample: \n\n~~~if-not:java,racket\n```\nget_char(65) # => 'A'\n```\n~~~\n~~~if:java\n~~~\n~~~if:racket\n~~~\n\nFor ASCII table, you can refer to http://www.asciitable.com/\n\"\"\"", "inputs": [[65], [33], [34], [35], [36], [37], [38]], "outputs": [["A"], ["!"], ["\""], ["#"], ["$"], ["%"], ["&"]], "starter_code": "def get_char(c: int) -> str:", "canonical_solution": "def get_char(c):\n    return chr(c)", "entry_point": "get_char", "task_id": "TACO_lite/1556", "input_output_examples": "[[[65]], [['A']]]", "llm_generated_inputs": {"deepseek-v3": "[[65], [97], [48], [32], [126], [0], [127], [255]]", "qwen2.5-coder-32b-instruct": "[[65], [97], [32], [0], [126], [127]]"}}
{"requirement": "from typing import List\n\n\ndef solve(nums: List[int], div: int) -> List[int]:\n\"\"\"This is a problem that involves adding numbers to items in a list.\nIn a list you will have to add the item's remainder when divided by a given divisor to each item.\n\nFor example if the item is 40 and the divisor is 3 you would have to add 1 since 40 minus the closest multiple of 3 which is 39 is 1. So the 40 in the list will become 41. You would have to return the modified list in this problem.\n\nFor this problem you will receive a divisor called `div` as well as simple list of whole numbers called `nums`. Good luck and happy coding.\n\n# Examples\n```python\nnums = [2, 7, 5, 9, 100, 34, 32, 0], div = 3\n  ==>  [4, 8, 7, 9, 101, 35, 34, 0] \n\nnums = [1000, 999, 998, 997], div = 5\n   ==> [1000, 1003, 1001, 999]\n\nnums = [], div = 2\n   ==> []\n```\n\n**Note:** random tests check lists containing up to 10000 elements.\n\"\"\"", "inputs": [[[2, 7, 5, 9, 100, 34, 32, 0], 3], [[], 2], [[1000, 999, 998, 997], 5], [[0, 0, 0, 0], 5], [[4, 3, 2, 1], 5], [[33, 23, 45, 78, 65], 10]], "outputs": [[[4, 8, 7, 9, 101, 35, 34, 0]], [[]], [[1000, 1003, 1001, 999]], [[0, 0, 0, 0]], [[8, 6, 4, 2]], [[36, 26, 50, 86, 70]]], "starter_code": "from typing import List\ndef solve(nums: List[int], div: int) -> List[int]:", "canonical_solution": "def solve(nums, div):\n    return [x + x % div for x in nums]", "entry_point": "solve", "task_id": "TACO_lite/1559", "input_output_examples": "[[[[2, 7, 5, 9, 100, 34, 32, 0], 3], [[1000, 999, 998, 997], 5], [[], 2]], [[[4, 8, 7, 9, 101, 35, 34, 0]], [[1000, 1003, 1001, 999]], [[]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[2, 7, 5, 9, 100, 34, 32, 0], 3], [[1000, 999, 998, 997], 5], [[], 2], [[10, 20, 30, 40], 1], [[5, 10, 15, 20], 10], [[1, 2, 3, 4, 5], 7], [[0, 0, 0, 0], 2], [[10000, 20000, 30000], 10000], [[-1, -2, -3, -4], 3], [[7, 14, 21, 28], 7]]", "qwen2.5-coder-32b-instruct": "[[[2, 7, 5, 9, 100, 34, 32, 0], 3], [[1000, 999, 998, 997], 5], [[], 2], [[1, 2, 3, 4, 5], 1], [[0, 0, 0, 0], 10], [[10, 20, 30, 40], 10], [[11, 22, 33, 44], 11], [[15, 25, 35, 45], 2], [[1, 1, 1, 1], 1], [[9999, 9998, 9997, 9996], 4]]"}}
{"requirement": "from typing import Dict\n\n\ndef outed(meet: Dict[str, int], boss: str) -> str:\n\"\"\"Your colleagues have been looking over you shoulder. When you should have been doing your boring real job, you've been using the work computers to smash in endless hours of codewars.\n\nIn a team meeting, a terrible, awful person declares to the group that you aren't working. You're in trouble. You quickly have to gauge the feeling in the room to decide whether or not you should gather your things and leave. \n\n```if-not:java\nGiven an object (meet) containing team member names as keys, and their happiness rating out of 10 as the value, you need to assess the overall happiness rating of the group. If <= 5, return 'Get Out Now!'. Else return 'Nice Work Champ!'.\n```\n```if:java\nGiven a `Person` array (meet) containing team members, you need to assess the overall happiness rating of the group. If <= 5, return \"Get Out Now!\". Else return \"Nice Work Champ!\".\n\nThe `Person` class looks like:\n~~~java\nclass Person {\n  final String name;    // team memnber's name\n  final int happiness;  // happiness rating out of 10\n}\n~~~\n```\n\nHappiness rating will be total score / number of people in the room.\n\nNote that your boss is in the room (boss), their score is worth double it's face value (but they are still just one person!).\n\nThe Office II - Boredom Score\nThe Office III - Broken Photocopier\nThe Office IV - Find a Meeting Room\nThe Office V - Find a Chair\n\"\"\"", "inputs": [[{"tim": 0, "jim": 2, "randy": 0, "sandy": 7, "andy": 0, "katie": 5, "laura": 1, "saajid": 2, "alex": 3, "john": 2, "mr": 0}, "laura"], [{"tim": 1, "jim": 3, "randy": 9, "sandy": 6, "andy": 7, "katie": 6, "laura": 9, "saajid": 9, "alex": 9, "john": 9, "mr": 8}, "katie"], [{"tim": 2, "jim": 4, "randy": 0, "sandy": 5, "andy": 8, "katie": 6, "laura": 2, "saajid": 2, "alex": 3, "john": 2, "mr": 8}, "john"]], "outputs": [["Get Out Now!"], ["Nice Work Champ!"], ["Get Out Now!"]], "starter_code": "from typing import Dict\ndef outed(meet: Dict[str, int], boss: str) -> str:", "canonical_solution": "def outed(meet, boss):\n    return 'Get Out Now!' if (sum(meet.values()) + meet[boss]) / len(meet) <= 5 else 'Nice Work Champ!'", "entry_point": "outed", "task_id": "TACO_lite/1566", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[{'Alice': 6, 'Bob': 4, 'Charlie': 5}, 'Alice'], [{'Alice': 3, 'Bob': 3, 'Charlie': 3}, 'Bob'], [{'Alice': 10, 'Bob': 10, 'Charlie': 10}, 'Charlie'], [{'Alice': 0, 'Bob': 0, 'Charlie': 0}, 'Alice'], [{'Alice': 5, 'Bob': 5}, 'Bob'], [{'Alice': 1}, 'Alice'], [{'Alice': 6, 'Bob': 4, 'Charlie': 5, 'Dave': 7}, 'Charlie'], [{'Alice': 2, 'Bob': 2, 'Charlie': 2, 'Dave': 2}, 'Dave'], [{'Alice': 8, 'Bob': 8, 'Charlie': 8, 'Dave': 8, 'Eve': 8}, 'Eve'], [{'Alice': 9, 'Bob': 1}, 'Bob']]", "qwen2.5-coder-32b-instruct": "[[{'john': 3, 'jane': 7, 'doe': 5}, 'john'], [{'alice': 8, 'bob': 6, 'charlie': 4}, 'bob'], [{'me': 10, 'boss': 10}, 'boss'], [{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1}, 'a'], [{'onlyboss': 5}, 'onlyboss'], [{'colleague1': 3, 'colleague2': 3, 'colleague3': 3, 'colleague4': 3, 'colleague5': 3, 'colleague6': 3, 'colleague7': 3, 'colleague8': 3, 'colleague9': 3}, 'colleague1'], [{'happy': 10, 'sad': 1, 'angry': 1, 'boss': 10}, 'boss'], [{'neutral': 5, 'neutral2': 5, 'neutral3': 5, 'neutral4': 5, 'neutral5': 5, 'neutral6': 5, 'neutral7': 5, 'neutral8': 5, 'neutral9': 5, 'neutral10': 5}, 'neutral']]"}}
{"requirement": "def find(stg: str) -> str:\n\"\"\"# Description:\n\n Find the longest successive exclamation marks and question marks combination in the string. A successive exclamation marks and question marks combination must contains two part: a substring of \"!\" and a substring \"?\", they are adjacent. \n \n If more than one result are found, return the one which at left side; If no such a combination found, return `\"\"`.\n\n# Examples\n\n```\nfind(\"!!\") === \"\"\nfind(\"!??\") === \"!??\"\nfind(\"!?!!\") === \"?!!\"\nfind(\"!!???!????\") === \"!!???\"\nfind(\"!!???!?????\") === \"!?????\"\nfind(\"!????!!!?\") === \"????!!!\" \nfind(\"!?!!??!!!?\") === \"??!!!\"\n```\n\n# Note\nPlease don't post issue about difficulty or duplicate. Because:\n>[That's unfair on the kata creator. This is a valid kata and introduces new people to javascript some regex or loops, depending on how they tackle this problem.  --matt c](https://www.codewars.com/kata/remove-exclamation-marks/discuss#57fabb625c9910c73000024e)\n\"\"\"", "inputs": [["!!"], ["!??"], ["!?!!"], ["!!???!????"], ["!!???!?????"], ["!????!!!?"], ["!?!!??!!!?"]], "outputs": [[""], ["!??"], ["?!!"], ["!!???"], ["!?????"], ["????!!!"], ["??!!!"]], "starter_code": "def find(stg: str) -> str:", "canonical_solution": "import re\n\ndef find(stg):\n    matches = re.findall('(!+|\\\\?+)', stg)\n    return max((f'{a}{b}' for a, b in zip(matches, matches[1:])), key=len, default='')", "entry_point": "find", "task_id": "TACO_lite/1576", "input_output_examples": "[[['!!'], ['!??'], ['!?!!'], ['!!???!????'], ['!!???!?????'], ['!????!!!?'], ['!?!!??!!!?']], [[''], ['!??'], ['?!!'], ['!!???'], ['!?????'], ['????!!!'], ['??!!!']]]", "llm_generated_inputs": {"deepseek-v3": "[['!!'], ['!??'], ['!?!!'], ['!!???!????'], ['!!???!?????'], ['!????!!!?'], ['!?!!??!!!?'], ['!?!!??!!!??'], ['!?!?!?!?!?'], ['??!!!??'], ['!?'], ['!?!'], ['?!?'], ['!!!???'], ['!?!?!?!!!'], ['!?!!!???'], ['!?!!!????'], ['!?!!!?????'], ['!?!!!!?????'], ['!?!!!!??????'], ['!?!!!!???????']]", "qwen2.5-coder-32b-instruct": "[['!!'], ['!?'], ['!?!!'], ['!!??'], ['!!???!????'], ['!!???!?????'], ['!????!!!?'], ['!?!!??!!!?'], ['!!!!!!!!!!!!'], ['????????????'], ['!??????'], ['?!!!!'], ['!??!??!'], ['!??!??!?'], ['!??!??!??'], ['!??!??!???'], ['!??!??!????'], ['!??!??!?????'], ['!??!??!??????'], ['!??!??!???????'], ['!??!??!????????'], ['!??!??!?????????'], ['!??!??!??????????'], ['!??!??!???????????'], ['!??!??!????????????'], ['!??!??!?????????????'], ['!??!??!??????????????'], ['!??!??!??????????????'], ['!??!??!??????????????'], ['!??!??!??????????????'], [''], ['no_special_chars_here']]"}}
{"requirement": "def acronym_buster(message: str) -> str:\n\"\"\"Laura really hates people using acronyms in her office and wants to force her colleagues to remove all acronyms before emailing her. She wants you to build a system that will edit out all known acronyms or else will notify the sender if unknown acronyms are present.\n\nAny combination of three or more letters in upper case will be considered an acronym. Acronyms will not be combined with lowercase letters, such as in the case of 'KPIs'. They will be kept isolated as a word/words within a string.\n\nFor any string: \n\nAll instances of 'KPI' must become \"key performance indicators\" \nAll instances of 'EOD' must become \"the end of the day\" \nAll instances of 'TBD' must become \"to be decided\"\nAll instances of 'WAH' must become \"work at home\"\nAll instances of 'IAM' must become \"in a meeting\"\nAll instances of 'OOO' must become \"out of office\"\nAll instances of 'NRN' must become \"no reply necessary\"\nAll instances of 'CTA' must become \"call to action\"\nAll instances of 'SWOT' must become \"strengths, weaknesses, opportunities and threats\"\nIf there are any unknown acronyms in the string, Laura wants you to return only the message:\n'[acronym] is an acronym. I do not like acronyms. Please remove them from your email.'\nSo if the acronym in question was 'BRB', you would return the string:\n'BRB is an acronym. I do not like acronyms. Please remove them from your email.'\nIf there is more than one unknown acronym in the string, return only the first in your answer.\n\nIf all acronyms can be replaced with full words according to the above, however, return only the altered string.\n\nIf this is the case, ensure that sentences still start with capital letters. '!' or '?' will not be used.\n\"\"\"", "inputs": [["BRB I need to go into a KPI meeting before EOD"], ["I am IAM so will be OOO until EOD"], ["Going to WAH today. NRN. OOO"], ["We're looking at SMB on SM DMs today"], ["OOO"], ["KPI"], ["EOD"], ["TBD"], ["TBD by EOD"], ["BRB I am OOO"], ["WAH"], ["IAM"], ["NRN"], ["CTA"], ["Hi PAB"], ["HATDBEA"], ["LDS"], ["PB"], ["FA"], ["CTA and HTTP"], ["SWOT."], ["HTTP"], ["Please WAH today. KPI on track"], ["The advert needs a CTA. NRN before EOD."], ["I sent you a RFP yesterday."], ["My SM account needs some work."]], "outputs": [["BRB is an acronym. I do not like acronyms. Please remove them from your email."], ["I am in a meeting so will be out of office until the end of the day"], ["Going to work at home today. No reply necessary. Out of office"], ["SMB is an acronym. I do not like acronyms. Please remove them from your email."], ["Out of office"], ["Key performance indicators"], ["The end of the day"], ["To be decided"], ["To be decided by the end of the day"], ["BRB is an acronym. I do not like acronyms. Please remove them from your email."], ["Work at home"], ["In a meeting"], ["No reply necessary"], ["Call to action"], ["PAB is an acronym. I do not like acronyms. Please remove them from your email."], ["HATDBEA is an acronym. I do not like acronyms. Please remove them from your email."], ["LDS is an acronym. I do not like acronyms. Please remove them from your email."], ["PB"], ["FA"], ["HTTP is an acronym. I do not like acronyms. Please remove them from your email."], ["Strengths, weaknesses, opportunities and threats."], ["HTTP is an acronym. I do not like acronyms. Please remove them from your email."], ["Please work at home today. Key performance indicators on track"], ["The advert needs a call to action. No reply necessary before the end of the day."], ["RFP is an acronym. I do not like acronyms. Please remove them from your email."], ["My SM account needs some work."]], "starter_code": "def acronym_buster(message: str) -> str:", "canonical_solution": "import re\nfrom functools import reduce\n_ACRONYMS = {'KPI': 'key performance indicators', 'EOD': 'the end of the day', 'EOP': 'the end of the day', 'TBD': 'to be decided', 'WAH': 'work at home', 'IAM': 'in a meeting', 'OOO': 'out of office', 'NRN': 'no reply necessary', 'CTA': 'call to action', 'SWOT': 'strengths, weaknesses, opportunities and threats'}\n_ACRONYM_PATTERN = re.compile('\\\\b[A-Z]{3,}\\\\b')\n_CAPITAL_PATTERN = re.compile('(?:\\\\. |^)([a-z])')\n_CAPITAL_FIX = lambda match: '{}'.format(match.group(0).upper())\n\ndef acronym_buster(message):\n    message = reduce(lambda msg, item: msg.replace(*item), _ACRONYMS.items(), message)\n    try:\n        acro = next(_ACRONYM_PATTERN.finditer(message)).group(0)\n        return '{} is an acronym. I do not like acronyms. Please remove them from your email.'.format(acro)\n    except StopIteration:\n        return _CAPITAL_PATTERN.sub(_CAPITAL_FIX, message)", "entry_point": "acronym_buster", "task_id": "TACO_lite/1600", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['Please send me the KPI report by EOD.'], ['The meeting is TBD, but IAM currently OOO.'], ['NRN regarding the CTA for the SWOT analysis.'], [\"I WAH today, so let's discuss the KPIs later.\"], [\"BRB is an acronym I don't know.\"], ['We need to finalize the EOD and TBD, but the KPI is unclear.'], ['Unknown acronyms like ASAP are not allowed.'], ['The project status is still TBD, and IAM waiting for the KPI update.'], ['Please review the SWOT analysis and provide your CTA.'], ['The deadline is EOD, and the agenda is still TBD.'], ['I will be OOO tomorrow, so NRN for any emails.'], ['The KPI report is due by EOD, and the CTA is still unclear.'], ['Unknown acronyms like FYI are not acceptable in our emails.'], ['The SWOT analysis is complete, and the CTA is pending.'], ['Please ensure the KPI report is sent by EOD, and the TBD is resolved.']]", "qwen2.5-coder-32b-instruct": "[['We need to focus on our KPI'], ['The meeting is EOD'], ['This project is still TBD'], ['She works WAH'], ['He will be IAM'], ['She is OOO'], ['No NRN needed'], ['They want a CTA'], ['Analyze the SWOT'], ['We have a KPI and EOD meeting'], ['This is a WAH and IAM session'], ['Our project is TBD and OOO'], ['BRB, I will join later'], ['XYZ is not a known acronym'], ['Multiple unknown acronyms ABC and DEF'], ['KPIs are important but not KPI'], ['EOD is the end of the day'], ['TBD is to be decided'], ['WAH means work at home'], ['IAM stands for in a meeting'], ['OOO indicates out of office'], ['NRN means no reply necessary'], ['CTA is call to action'], ['SWOT analysis covers strengths, weaknesses, opportunities and threats'], ['This is a simple sentence'], ['ALLCAPS should be checked'], ['NoAcronymsHere']]"}}
{"requirement": "def f(n: int) -> int:\n\"\"\"Find the closest prime number under a certain integer ```n``` that has the maximum possible amount of even digits.\n\nFor ```n = 1000```, the highest prime under ```1000``` is ```887```, having two even digits (8 twice)\n\nNaming ```f()```, the function that gives that prime, the above case and others will be like the following below.\n```\nf(1000) ---> 887 (even digits: 8, 8)\n\nf(1210) ---> 1201 (even digits: 2, 0)\n\nf(10000) ---> 8887\n\nf(500) ---> 487\n\nf(487) ---> 467\n``` \nFeatures of the random tests:\n```\nNumber of tests = 28\n1000 <= n <= 5000000\n```\n\nEnjoy it!!\n\"\"\"", "inputs": [[1000], [10000], [500], [487]], "outputs": [[887], [8887], [487], [467]], "starter_code": "def f(n: int) -> int:", "canonical_solution": "from bisect import bisect_left as bisect\nn = 5000000\nsieve, PED, PED_DATA = ([0] * ((n >> 1) + 1), [], [])\nfor i in range(3, n + 1, 2):\n    if not sieve[i >> 1]:\n        for j in range(i ** 2 >> 1, n + 1 >> 1, i):\n            sieve[j] = 1\n        s = str(i)\n        nEveD = sum((s.count(d) for d in '02468'))\n        if nEveD:\n            PED.append(i)\n            PED_DATA.append((nEveD, len(s) - 1))\n\ndef f(n):\n    idx = bisect(PED, n) - 1\n    m, (nEveD, l) = (PED[idx], PED_DATA[idx])\n    for c in range(idx):\n        mc, (nEveDc, lc) = (PED[idx - c], PED_DATA[idx - c])\n        if nEveDc > nEveD:\n            m, nEveD = (mc, nEveDc)\n        if lc < nEveD:\n            break\n    return m", "entry_point": "f", "task_id": "TACO_lite/1601", "input_output_examples": "[[[1000], [1210], [10000], [500], [487]], [[887], [1201], [8887], [487], [467]]]", "llm_generated_inputs": {"deepseek-v3": "[[1000], [1210], [10000], [500], [487], [2], [3], [10], [100], [100000], [5000000], [1001], [8888], [12345], [2468], [13579], [1]]", "qwen2.5-coder-32b-instruct": "[[1000], [1210], [10000], [500], [487], [1001], [2000], [3000], [4000], [5000], [6000], [7000], [8000], [9000], [10000], [20000], [30000], [40000], [50000], [100000], [200000], [300000], [400000], [500000], [1000000], [2000000], [3000000], [4000000], [5000000]]"}}
{"requirement": "def convert_bits(a: int, b: int) -> int:\n\"\"\"Complete the function to determine the number of bits required to convert integer `A` to integer `B` (where `A` and `B` >= 0)\n\nThe upper limit for `A` and `B` is 2^(16), `int.MaxValue` or similar.\n\nFor example, you can change 31 to 14 by flipping the 4th and 0th bit:\n```\n 31  0 0 0 1 1 1 1 1\n 14  0 0 0 0 1 1 1 0\n---  ---------------\nbit  7 6 5 4 3 2 1 0\n```\nThus `31` and `14` should return `2`.\n\"\"\"", "inputs": [[31, 14], [7, 17], [31, 0], [0, 0], [127681, 127681], [312312312, 5645657], [43, 2009989843]], "outputs": [[2], [3], [5], [0], [0], [13], [17]], "starter_code": "def convert_bits(a: int, b: int) -> int:", "canonical_solution": "def convert_bits(a, b):\n    return bin(a ^ b).count('1')", "entry_point": "convert_bits", "task_id": "TACO_lite/1606", "input_output_examples": "[[[31, 14]], [[2]]]", "llm_generated_inputs": {"deepseek-v3": "[[31, 14], [0, 0], [1, 1], [255, 0], [127, 128], [1023, 1023], [65535, 0], [12345, 54321], [32768, 32768], [65535, 65535]]", "qwen2.5-coder-32b-instruct": "[[31, 14], [0, 0], [0, 1], [1, 0], [255, 0], [0, 255], [65535, 0], [0, 65535], [12345, 54321], [65535, 65535], [1, 2], [2, 1], [16, 32], [32, 16]]"}}
{"requirement": "def mirror(code: str, chars: str = 'abcdefghijklmnopqrstuvwxyz') -> str:\n\"\"\"Your back at your newly acquired decrypting job for the secret organization when a new assignment comes in.   Apparently the enemy has been communicating using a device they call \"The Mirror\".  \nIt is a rudimentary device with encrypts the message by switching its letter with its mirror opposite (A => Z), (B => Y), (C => X) etc.  \n\nYour job is to build a method called \"mirror\" which will decrypt the messages. Resulting messages will be in lowercase.\n\nTo add more secrecy, you are to accept a second optional parameter, telling you which letters or characters are to be reversed; if it is not given, consider the whole alphabet as a default.\n\nTo make it a bit more clear: e.g. in case of \"abcdefgh\" as the second optional parameter, you replace \"a\" with \"h\", \"b\" with \"g\" etc. .\n\nFor example:\n```python\nmirror(\"Welcome home\"), \"dvoxlnv slnv\" #whole alphabet mirrored here\nmirror(\"hello\", \"abcdefgh\"), \"adllo\" #notice only \"h\" and \"e\" get reversed\n```\n\"\"\"", "inputs": [["Welcome home"], ["hello"], ["goodbye"], ["ngmlsoor"], ["gsrh rh z hvxivg"], ["Welcome home", "w"], ["hello", "abcdefgh"], ["goodbye", ""], ["CodeWars", "+-*/="], ["this is a secret", " *"]], "outputs": [["dvoxlnv slnv"], ["svool"], ["tllwybv"], ["mtnohlli"], ["this is a secret"], ["welcome home"], ["adllo"], ["goodbye"], ["codewars"], ["this*is*a*secret"]], "starter_code": "def mirror(code: str, chars: str = 'abcdefghijklmnopqrstuvwxyz') -> str:", "canonical_solution": "def mirror(code, chars='abcdefghijklmnopqrstuvwxyz'):\n    return code.lower().translate(str.maketrans(chars, chars[::-1]))", "entry_point": "mirror", "task_id": "TACO_lite/1609", "input_output_examples": "[[['Welcome home'], ['hello', 'abcdefgh']], [['dvoxlnv slnv'], ['adllo']]]", "llm_generated_inputs": {"deepseek-v3": "[['Welcome home', 'abcdefghijklmnopqrstuvwxyz'], ['hello', 'abcdefgh'], ['The quick brown fox jumps over the lazy dog', 'abcdefghijklmnopqrstuvwxyz'], ['abcde', 'abcde'], ['xyz', 'xyz'], ['12345', '12345'], ['', 'abcdefghijklmnopqrstuvwxyz'], ['Hello World', 'aeiou'], ['@#$%^&*', '!@#$%^&*'], ['AaBbCc', 'abcdefghijklmnopqrstuvwxyz']]", "qwen2.5-coder-32b-instruct": "[['hello', 'abcdefgh'], ['xyz', 'abc'], ['', 'abcdefghijklmnopqrstuvwxyz'], ['abcxyz', 'abcdefghijklmnopqrstuvwxyz'], ['a', 'a'], ['ab', 'ab'], ['', ''], ['hello', ''], ['hello', 'zyxwvutsrqponmlkjihgfedcba'], ['HELLO', 'abcdefghijklmnopqrstuvwxyz'], ['123', 'abcdefghijklmnopqrstuvwxyz'], ['!@#', 'abcdefghijklmnopqrstuvwxyz']]"}}
{"requirement": "from typing import Union\n\n\ndef playerrankup(pts: int) -> Union[str, bool]:\n\"\"\"Let's imagine we have a popular online RPG. A player begins with a score of 0 in class E5. A1 is the highest level a player can achieve.\n\nNow let's say the players wants to rank up to class E4. To do so the player needs to achieve at least 100 points to enter the qualifying stage.\n\nWrite a script that will check to see if the player has achieved at least 100 points in his class. If so, he enters the qualifying stage. \n\nIn that case, we return, ```\"Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.\"```.\n\nOtherwise return, ```False/false``` (according to the language n use).\n\nNOTE:  Remember, in C# you have to cast your output value to Object type!\n\"\"\"", "inputs": [[-1], [0], [45], [59], [64], [100], [105], [111], [118], [332532105]], "outputs": [[false], [false], [false], [false], [false], ["Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up."], ["Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up."], ["Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up."], ["Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up."], ["Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up."]], "starter_code": "from typing import Union\ndef playerrankup(pts: int) -> Union[str, bool]:", "canonical_solution": "def playerrankup(pts):\n    msg = 'Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.'\n    return msg if pts >= 100 else False", "entry_point": "playerrankup", "task_id": "TACO_lite/1612", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[99], [100], [101], [0], [-1], [1000]]", "qwen2.5-coder-32b-instruct": "[[99], [100], [150], [0], [-50], [200]]"}}
{"requirement": "from typing import List\n\n\ndef score_test(tests: List[int], right: int, omit: int, wrong: int) -> int:\n\"\"\"A new school year is approaching, which also means students will be taking tests. \n\nThe tests in this kata are to be graded in different ways. A certain number of points will be given for each correct answer and a certain number of points will be deducted for each incorrect answer. For ommitted answers, points will either be awarded, deducted, or no points will be given at all.\n\nReturn the number of points someone has scored on varying tests of different lengths.\n\nThe given parameters will be:\n\n* An array containing a series of `0`s, `1`s, and `2`s, where `0` is a correct answer, `1` is an omitted answer, and `2` is an incorrect answer.\n* The points awarded for correct answers\n* The points awarded for omitted answers (note that this may be negative)\n* The points **deducted** for incorrect answers (hint: this value has to be subtracted)\n\n\n**Note:**\nThe input will always be valid (an array and three numbers)\n\n\n## Examples\n\n\\#1:\n```\n[0, 0, 0, 0, 2, 1, 0], 2, 0, 1  -->  9\n```\nbecause:\n* 5 correct answers: `5*2 = 10`\n* 1 omitted answer: `1*0 = 0`\n* 1 wrong answer: `1*1 = 1`\n\nwhich is: `10 + 0 - 1 = 9`\n\n\\#2:\n```\n[0, 1, 0, 0, 2, 1, 0, 2, 2, 1], 3, -1, 2)  -->  3\n```\nbecause: `4*3 + 3*-1 - 3*2 = 3`\n\"\"\"", "inputs": [[[0, 0, 0, 0, 2, 1, 0], 2, 0, 1], [[0, 1, 0, 0, 2, 1, 0, 2, 2, 1], 3, -1, 2], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5, -1, 2], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 2, 0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 0], 6, 0, 1.5], [[0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 0, 2, 1, 2, 0, 2, 1], 10, -5, 10], [[0, 2, 0, 2, 0, 2, 0, 2], 10, 0, 5], [[0, 1, 2, 0, 0, 2, 0, 1, 2, 1, 0, 0, 1, 0, 2, 1, 0, 2, 2, 0], 9, 3, 2]], "outputs": [[9], [3], [70], [87], [-60], [20], [84]], "starter_code": "from typing import List\ndef score_test(tests: List[int], right: int, omit: int, wrong: int) -> int:", "canonical_solution": "def score_test(tests, right, omit, wrong):\n    points = (right, omit, -wrong)\n    return sum((points[test] for test in tests))", "entry_point": "score_test", "task_id": "TACO_lite/1623", "input_output_examples": "[[[[0, 0, 0, 0, 2, 1, 0], 2, 0, 1], [[0, 1, 0, 0, 2, 1, 0, 2, 2, 1], 3, -1, 2]], [[9], [3]]]", "llm_generated_inputs": {"deepseek-v3": "[[[0, 0, 0, 0, 2, 1, 0], 2, 0, 1], [[0, 1, 0, 0, 2, 1, 0, 2, 2, 1], 3, -1, 2], [[], 5, 0, 2], [[1, 1, 1, 1], 0, -1, 1], [[2, 2, 2, 2], 1, 0, 3], [[0, 1, 2, 0, 1, 2], 5, -2, 4], [[0], 10, 0, 5], [[1], 0, -5, 0], [[2], 0, 0, 10], [[0, 1, 2, 0, 1, 2, 0, 1, 2], 2, -1, 3]]", "qwen2.5-coder-32b-instruct": "[[[0, 0, 0, 0, 2, 1, 0], 2, 0, 1], [[0, 1, 0, 0, 2, 1, 0, 2, 2, 1], 3, -1, 2], [[1, 1, 1, 1, 1], 0, 0, 0], [[0, 0, 0, 0, 0], 10, 0, 0], [[2, 2, 2, 2, 2], 0, 0, 5], [[0, 1, 2], 5, 3, 2], [[0, 0, 0], -1, -1, -1], [[1, 2, 0], 1, -1, -2], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 1, 0, 0], [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2], 0, 0, 1]]"}}
{"requirement": "from typing import List\n\n\ndef find_average(nums: List[float]) -> float:\n\"\"\"## Find Mean\n\nFind the mean (average) of a list of numbers in an array.\n\n## Information\n\nTo find the mean (average) of a set of numbers add all of the numbers together and divide by the number of values in the list.\n\nFor an example list of `1, 3, 5, 7`\n\n1. Add all of the numbers\n\n```\n1+3+5+7 = 16\n```\n\n2. Divide by the number of values in the list. In this example there are 4 numbers in the list.\n\n```\n16/4 = 4\n```\n\n3. The mean (or average) of this list is 4\n\"\"\"", "inputs": [[[1]], [[1, 3, 5, 7]], [[-1, 3, 5, -7]], [[5, 7, 3, 7]], [[]]], "outputs": [[1], [4], [0], [5.5], [0]], "starter_code": "from typing import List\ndef find_average(nums: List[float]) -> float:", "canonical_solution": "def find_average(nums):\n    return float(sum(nums)) / len(nums) if len(nums) != 0 else 0", "entry_point": "find_average", "task_id": "TACO_lite/1627", "input_output_examples": "[[[[1, 3, 5, 7]]], [[4.0]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1.0, 3.0, 5.0, 7.0]], [[10.0, 20.0, 30.0, 40.0, 50.0]], [[0.0, 0.0, 0.0, 0.0]], [[2.5]], [[-1.0, -2.0, -3.0, -4.0]], [[1.5, 2.5, 3.5, 4.5, 5.5]], [[]]]", "qwen2.5-coder-32b-instruct": "[[[1, 3, 5, 7]], [[10, 20, 30, 40, 50]], [[5]], [[1.5, 2.5, 3.5]], [[]], [[0, 0, 0, 0]], [[100, -50, 25, -25]], [[1000000000.0, 1000000000.0, 1000000000.0]]]"}}
{"requirement": "def look_and_say_and_sum(N: int) -> int:\n\"\"\"# Task\nGet the digits sum of `n`th number from the [Look-and-Say sequence](http://en.wikipedia.org/wiki/Look-and-say_sequence)(1-based).\n\n`1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, ...`\n\n# Input/Output\n\n`[input]` integer `n`\n\n`n`th number in the sequence to get where `1 <= n <= 55`  and `n=1 is \"1\"`.\n\n[output] an integer\n\nThe sum of digits in `n`th number from the `Look-and-Say` sequence.\n\n# Example\n\nFor `n = 2`, the output shoule be 2.\n\n`\"11\" --> 1 + 1 --> 2`\n\nFor `n = 3`, the output shoule be 3.\n\n`\"21\" --> 2 + 1 --> 3`\n\nFor `n = 4`, the output shoule be 5.\n\n`\"1211\" --> 1 + 2 + 1 + 1 --> 5`\n\"\"\"", "inputs": [[1], [2], [3], [4], [5]], "outputs": [[1], [2], [3], [5], [8]], "starter_code": "def look_and_say_and_sum(N: int) -> int:", "canonical_solution": "def look_and_say_and_sum(N):\n    l = [1]\n    for n in range(N - 1):\n        result = [1, l[0]]\n        for i in range(1, len(l)):\n            if l[i] == result[-1]:\n                result[-2] += 1\n            else:\n                result += [1, l[i]]\n        l = result\n    return sum(l)", "entry_point": "look_and_say_and_sum", "task_id": "TACO_lite/1630", "input_output_examples": "[[[2], [3], [4]], [[2], [3], [5]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [4], [5], [10], [20], [30], [40], [50], [55]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33], [34], [35], [36], [37], [38], [39], [40], [41], [42], [43], [44], [45], [46], [47], [48], [49], [50], [51]]"}}
{"requirement": "def polybius(text: str) -> str:\n\"\"\"Implement the [Polybius square cipher](http://en.wikipedia.org/wiki/Polybius_square).\n\nReplace every letter with a two digit number. The first digit is the row number, and the second digit is the column number of following square. Letters `'I'` and `'J'` are both 24 in this cipher:\n\n\ntable#polybius-square {width: 100px;}\ntable#polybius-square td {background-color: #2f2f2f;}\ntable#polybius-square th {background-color: #3f3f3f;}\n\n\n12345\n1ABCDE\n2FGHI/JK\n3LMNOP\n4QRSTU\n5VWXYZ\n\n\nInput will be valid (only spaces and uppercase letters from A to Z), so no need to validate them.\n\n\n\n## Examples\n\n```python\npolybius('A')  # \"11\"\npolybius('IJ') # \"2424\"\npolybius('CODEWARS') # \"1334141552114243\"\npolybius('POLYBIUS SQUARE CIPHER') # \"3534315412244543 434145114215 132435231542\"\n```\n\"\"\"", "inputs": [["POLYBIUS"], ["CODEWARS"], ["POLYBIUS SQUARE CIPHER"]], "outputs": [["3534315412244543"], ["1334141552114243"], ["3534315412244543 434145114215 132435231542"]], "starter_code": "def polybius(text: str) -> str:", "canonical_solution": "def polybius(text):\n    letmap = {'A': '11', 'B': '12', 'C': '13', 'D': '14', 'E': '15', 'F': '21', 'G': '22', 'H': '23', 'I': '24', 'J': '24', 'K': '25', 'L': '31', 'M': '32', 'N': '33', 'O': '34', 'P': '35', 'Q': '41', 'R': '42', 'S': '43', 'T': '44', 'U': '45', 'V': '51', 'W': '52', 'X': '53', 'Y': '54', 'Z': '55', ' ': ' '}\n    enc = ''\n    for i in range(0, len(text)):\n        enc = enc + letmap[text[i].upper()]\n    return enc", "entry_point": "polybius", "task_id": "TACO_lite/1631", "input_output_examples": "[[['A'], ['IJ'], ['CODEWARS'], ['POLYBIUS SQUARE CIPHER']], [['11'], ['2424'], ['1334141552114243'], ['3534315412244543 434145114215 132435231542']]]", "llm_generated_inputs": {"deepseek-v3": "[['A'], ['IJ'], ['CODEWARS'], ['POLYBIUS SQUARE CIPHER'], ['HELLO WORLD'], ['JAVA'], ['PYTHON'], ['Z'], ['I J'], ['SPACE'], ['QUICK BROWN FOX'], ['JAZZ'], ['IJAZZ'], ['ABCDEFGHIJKLMNOPQRSTUVWXYZ'], ['I J K L M N O P Q R S T U V W X Y Z']]", "qwen2.5-coder-32b-instruct": "[['A'], ['IJ'], ['CODEWARS'], ['POLYBIUS SQUARE CIPHER'], ['B'], ['Z'], [' '], ['HELLO WORLD'], ['PYTHON'], ['JUMP'], ['FJORD']]"}}
{"requirement": "from typing import List\n\n\ndef scoreboard(string: str) -> List[int]:\n\"\"\"You are working at a lower league football stadium and you've been tasked with automating the scoreboard.\n\nThe referee will shout out the score, you have already set up the voice recognition module which turns the ref's voice into a string, but the spoken score needs to be converted into a pair for the scoreboard!\n\ne.g. `\"The score is four nil\"` should return `[4,0]`\n\nEither teams score has a range of 0-9, and the ref won't say the same string every time e.g. \n      \n    \"new score: two three\"\n      \n    \"two two\"\n      \n    \"Arsenal just conceded another goal, two nil\"\n    \nNote:\n```python\nPlease return an array\n```\n\nPlease rate and enjoy!\n\"\"\"", "inputs": [["The score is four nil"], ["new score: two three"], ["two two"], ["Arsenal just conceded another goal, two nil"]], "outputs": [[[4, 0]], [[2, 3]], [[2, 2]], [[2, 0]]], "starter_code": "from typing import List\ndef scoreboard(string: str) -> List[int]:", "canonical_solution": "def scoreboard(string):\n    scores = {'nil': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    return [scores[x] for x in string.split() if x in scores]", "entry_point": "scoreboard", "task_id": "TACO_lite/1635", "input_output_examples": "[[['The score is four nil'], ['new score: two three'], ['two two'], ['Arsenal just conceded another goal, two nil']], [[[4, 0]], [[2, 3]], [[2, 2]], [[2, 0]]]]", "llm_generated_inputs": {"deepseek-v3": "[['The score is four nil'], ['new score: two three'], ['two two'], ['Arsenal just conceded another goal, two nil'], ['The final score is nine nine'], ['score update: zero zero'], ['The match ended with a score of one seven'], ['The score is five four'], ['The score is three six'], ['The score is eight two'], ['The score is zero nine'], ['The score is seven zero'], ['The score is two five'], ['The score is six one'], ['The score is four four'], ['The score is nine zero'], ['The score is zero zero'], ['The score is one one'], ['The score is three three'], ['The score is five five']]", "qwen2.5-coder-32b-instruct": "[['The score is four nil'], ['new score: two three'], ['two two'], ['Arsenal just conceded another goal, two nil'], ['The final score is nine eight'], ['zero zero'], ['one one'], ['five four'], ['seven six'], ['three nil'], ['nil nil'], ['score: nine zero'], ['goal! one nil'], ['The match ends two two'], ['eight seven'], ['six five'], ['four three']]"}}
{"requirement": "def check(a: list, x: int) -> bool:\n\"\"\"*** No Loops Allowed ***\n\nYou will be given an array (a) and a value (x). All you need to do is check whether the provided array contains the value, without using a loop.\n\nArray can contain numbers or strings. X can be either. Return true if the array contains the value, false if not. With strings you will need to account for case.\n\nLooking for more, loop-restrained fun? Check out the other kata in the series:\n\n https://www.codewars.com/kata/no-loops-1-small-enough\n https://www.codewars.com/kata/no-loops-3-copy-within\n\"\"\"", "inputs": [[[66, 101], 66], [[80, 117, 115, 104, 45, 85, 112, 115], 45], [["t", "e", "s", "t"], "e"], [["what", "a", "great", "kata"], "kat"], [[66, "codewars", 11, "alex loves pushups"], "alex loves pushups"], [["come", "on", 110, "2500", 10, "!", 7, 15], "Come"], [["when's", "the", "next", "Katathon?", 9, 7], "Katathon?"], [[8, 7, 5, "bored", "of", "writing", "tests", 115], 45], [["anyone", "want", "to", "hire", "me?"], "me?"]], "outputs": [[true], [true], [true], [false], [true], [false], [true], [false], [true]], "starter_code": "def check(a: list, x: int) -> bool:", "canonical_solution": "def check(a, x):\n    return x in a", "entry_point": "check", "task_id": "TACO_lite/1637", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 5], 3], [[1, 2, 3, 4, 5], 6], [['apple', 'banana', 'cherry'], 'banana'], [['apple', 'banana', 'cherry'], 'grape'], [['apple', 'banana', 'cherry'], 'APPLE'], [['apple', 'banana', 'cherry'], 'Apple'], [[1, 'apple', 3.14, 'banana'], 'apple'], [[1, 'apple', 3.14, 'banana'], 3.14], [[1, 'apple', 3.14, 'banana'], 'cherry'], [[], 1], [[1], 1], [[''], ''], [[None, 0, False], None], [[None, 0, False], False]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3], 2], [['apple', 'banana', 'cherry'], 'banana'], [[1, 2, 3], 4], [['apple', 'banana', 'cherry'], 'Banana'], [[], 1], [[''], ''], [[None, True, False], True], [[None, True, False], None], [[1.1, 2.2, 3.3], 2.2], [[1.1, 2.2, 3.3], 2.3]]"}}
{"requirement": "from typing import List\n\n\ndef rthn_between(a: int, b: int) -> List[int]:\n\"\"\"*This kata is inspired by [Project Euler Problem #387](https://projecteuler.net/problem=387)*\n\n---\n\nA [Harshad number](https://en.wikipedia.org/wiki/Harshad_number) (or Niven number) is a number that is divisible by the sum of its digits. A *right truncatable Harshad number* is any Harshad number that, when recursively right-truncated, results in a Harshad number at each truncation. By definition, 1-digit numbers are **not** right truncatable Harshad numbers.\n\nFor example `201` (which is a Harshad number) yields `20`, then `2` when right-truncated, which are all Harshad numbers. Thus `201` is a *right truncatable Harshad number*.\n\n\n## Your task\n\nGiven a range of numbers (`(a, b)`, both included), return the list of right truncatable Harshad numbers in this range.\n\n```if-not:javascript\nNote: there are `500` random tests, with 0 <= `a` <= `b` <= 10^(16)\n```\n```if:javascript\nNote: there are `500` random tests, with `0 <= a <= b <= Number.MAX_SAFE_INTEGER`\n```\n\n## Examples\n\n```\n0, 20        -->  [10, 12, 18, 20]\n30, 100      -->  [30, 36, 40, 42, 45, 48, 50, 54, 60, 63, 70, 72, 80, 81, 84, 90, 100]\n90, 200      -->  [90, 100, 102, 108, 120, 126, 180, 200]\n200, 210     -->  [200, 201, 204, 207, 209, 210]\n1000, 2000   -->  [1000, 1002, 1008, 1020, 1026, 1080, 1088, 1200, 1204, 1206, 1260, 1800, 2000]\n2200, 2300   -->  []\n9000002182976, 9000195371842  -->  [9000004000000, 9000004000008]\n```\n\n---\n\n## My other katas\n\nIf you enjoyed this kata then please try [my other katas](https://www.codewars.com/collections/katas-created-by-anter69)! :-)\n\n#### *Translations are welcome!*\n\"\"\"", "inputs": [[0, 20], [30, 100], [90, 200], [200, 210], [1000, 2000], [2200, 2300], [9000002182976, 9000195371842]], "outputs": [[[10, 12, 18, 20]], [[30, 36, 40, 42, 45, 48, 50, 54, 60, 63, 70, 72, 80, 81, 84, 90, 100]], [[90, 100, 102, 108, 120, 126, 180, 200]], [[200, 201, 204, 207, 209, 210]], [[1000, 1002, 1008, 1020, 1026, 1080, 1088, 1200, 1204, 1206, 1260, 1800, 2000]], [[]], [[9000004000000, 9000004000008]]], "starter_code": "from typing import List\ndef rthn_between(a: int, b: int) -> List[int]:", "canonical_solution": "def gen(n):\n    if n >= 10 ** 16:\n        return\n    for i in range(10):\n        x = 10 * n + i\n        if x % sum(map(int, str(x))):\n            continue\n        yield x\n        for y in gen(x):\n            yield y\nL = sorted((x for n in range(1, 10) for x in gen(n)))\nfrom bisect import bisect_left as bl, bisect_right as br\n\ndef rthn_between(a, b):\n    return L[bl(L, a):br(L, b)]", "entry_point": "rthn_between", "task_id": "TACO_lite/1655", "input_output_examples": "[[[0, 20], [30, 100], [90, 200], [200, 210], [1000, 2000], [2200, 2300], [9000002182976, 9000195371842]], [[[10, 12, 18, 20]], [[30, 36, 40, 42, 45, 48, 50, 54, 60, 63, 70, 72, 80, 81, 84, 90, 100]], [[90, 100, 102, 108, 120, 126, 180, 200]], [[200, 201, 204, 207, 209, 210]], [[1000, 1002, 1008, 1020, 1026, 1080, 1088, 1200, 1204, 1206, 1260, 1800, 2000]], [[]], [[9000004000000, 9000004000008]]]]", "llm_generated_inputs": {"deepseek-v3": "[[0, 20], [30, 100], [90, 200], [200, 210], [1000, 2000], [2200, 2300], [9000002182976, 9000195371842], [1, 1], [10, 10], [201, 201], [0, 0], [-1, 10], [10000000000000000, 10000000000000000]]", "qwen2.5-coder-32b-instruct": "[[0, 20], [30, 100], [90, 200], [200, 210], [1000, 2000], [2200, 2300], [9000002182976, 9000195371842], [1, 1], [10, 10], [0, 0], [99999999999999, 100000000000000], [100000000000000, 100000000000001], [123456789, 123456789], [111111111, 222222222]]"}}
{"requirement": "from typing import List\n\n\ndef sel_reverse(arr: List[int], l: int) -> List[int]:\n\"\"\"Given an array, return the reversed version of the array (a different kind of reverse though), you reverse portions of the array, you'll be given a length argument which represents the length of each portion you are to reverse.\n\nE.g\n  \n  if after reversing some portions of the array and the length of the remaining portion in the array is not up to the length argument, just reverse them.\n  \n\n`selReverse(array, length)`\n\n- array - array to reverse\n- length - length of each portion to reverse\n\nNote : if the length argument exceeds the array length, reverse all of them, if the length argument is zero do not reverse at all.\n\"\"\"", "inputs": [[[2, 4, 6, 8, 10, 12, 14, 16], 3], [[2, 4, 6, 8, 10, 12, 14, 16], 2], [[1, 2, 3, 4, 5, 6], 2], [[1, 2, 3, 4, 5, 6], 0], [[1, 2, 3, 4, 5, 6], 10]], "outputs": [[[6, 4, 2, 12, 10, 8, 16, 14]], [[4, 2, 8, 6, 12, 10, 16, 14]], [[2, 1, 4, 3, 6, 5]], [[1, 2, 3, 4, 5, 6]], [[6, 5, 4, 3, 2, 1]]], "starter_code": "from typing import List\ndef sel_reverse(arr: List[int], l: int) -> List[int]:", "canonical_solution": "def sel_reverse(arr, l):\n    return [elt for i in range(0, len(arr), l) for elt in arr[i:i + l][::-1]] if l != 0 else arr", "entry_point": "sel_reverse", "task_id": "TACO_lite/1656", "input_output_examples": "[[[[2, 4, 6, 8, 10, 12, 14, 16], 3], [[5, 7, 2, 8, 1, 4, 9], 2], [[1, 2, 3, 4, 5], 5], [[1, 2, 3, 4, 5], 10], [[1, 2, 3, 4, 5], 0]], [[[6, 4, 2, 12, 10, 8, 16, 14]], [[7, 5, 8, 2, 4, 1, 9]], [[5, 4, 3, 2, 1]], [[5, 4, 3, 2, 1]], [[1, 2, 3, 4, 5]]]]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 5], 2], [[1, 2, 3, 4, 5], 3], [[1, 2, 3, 4, 5], 0], [[1, 2, 3, 4, 5], 5], [[1, 2, 3, 4, 5], 6], [[1, 2, 3, 4, 5, 6, 7, 8], 4], [[1, 2, 3, 4, 5, 6, 7, 8], 1], [[], 3], [[1], 2], [[1, 2, 3, 4, 5, 6, 7, 8, 9], 3]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 4, 5, 6], 2], [[1, 2, 3, 4, 5, 6], 3], [[1, 2, 3, 4, 5, 6], 6], [[1, 2, 3, 4, 5, 6], 7], [[1, 2, 3, 4, 5, 6], 0], [[1, 2, 3, 4, 5], 2], [[1, 2, 3, 4, 5], 1], [[1, 2, 3, 4, 5], 5], [[1, 2, 3, 4, 5], 0], [[1, 2, 3, 4, 5], 6], [[1, 2, 3, 4, 5], 3], [[1], 1], [[1], 2], [[1], 0], [[], 1], [[], 0]]"}}
{"requirement": "from typing import Union\n\n\ndef calculator(x: int, y: int, op: str) -> Union[int, str]:\n\"\"\"You are required to create a simple calculator that returns the result of addition, subtraction, multiplication or division of two numbers.\n\nYour function will accept three arguments:\nThe first and second argument should be numbers.\nThe third argument should represent a sign indicating the operation to perform on these two numbers.\n```if-not:csharp\nif the variables are not numbers or the sign does not belong to the list above a message \"unknown value\" must be returned.\n```\n```if:csharp\nIf the sign is not a valid sign, throw an ArgumentException.\n```\n\n# Example:\n\n```python\ncalculator(1, 2, '+') => 3\ncalculator(1, 2, '$') # result will be \"unknown value\"\n```\n\nGood luck!\n\"\"\"", "inputs": [[6, 2, "+"], [4, 3, "-"], [5, 5, "*"], [5, 4, "/"], [6, "$", "+"], [6, 2, "&"], [4, 3, "\\"], ["a", 3, "+"], [6, 2, "="], [6, 2, "\t"], [":", ",", "+"]], "outputs": [[8], [1], [25], [1.25], ["unknown value"], ["unknown value"], ["unknown value"], ["unknown value"], ["unknown value"], ["unknown value"], ["unknown value"]], "starter_code": "from typing import Union\ndef calculator(x: int, y: int, op: str) -> Union[int, str]:", "canonical_solution": "def calculator(x, y, op):\n    return eval(f'{x}{op}{y}') if type(x) == type(y) == int and str(op) in '+-*/' else 'unknown value'", "entry_point": "calculator", "task_id": "TACO_lite/1660", "input_output_examples": "[[[1, 2, '+'], [1, 2, '$']], [[3], ['unknown value']]]", "llm_generated_inputs": {"deepseek-v3": "[[1, 2, '+'], [5, 3, '-'], [4, 5, '*'], [10, 2, '/'], [7, 0, '/'], [0, 0, '+'], [-5, -3, '*'], [10, -2, '/'], [10, 2, '$'], ['a', 2, '+'], [1, 'b', '-'], [None, 2, '*'], [1, 2, None], [1.5, 2, '+'], [1, 2.5, '-'], [1, 2, '++'], [1, 2, '']]", "qwen2.5-coder-32b-instruct": "[[1, 2, '+'], [5, 3, '-'], [4, 6, '*'], [8, 2, '/'], [7, 0, '/'], ['a', 2, '+'], [1, 'b', '-'], [1, 2, 'abc'], [1, 2, '$'], [0, 0, '+'], [-1, -1, '*'], [-5, 2, '/'], [5, -2, '-']]"}}
{"requirement": "def uncollapse(digits: str) -> str:\n\"\"\"## Task\nIn this kata you'll be given a string of English digits \"collapsed\" together, like this:\n\n`zeronineoneoneeighttwoseventhreesixfourtwofive`\n\nYour task is to split the string back to digits:\n\n`zero nine one one eight two seven three six four two five`\n\n## Examples\n```\nthree -> three\neightsix -> eight six\nfivefourseven -> five four seven\nninethreesixthree -> nine three six three\nfivethreefivesixthreenineonesevenoneeight -> five three five six three nine one seven one eight\n```\n\"\"\"", "inputs": [["three"], ["eightsix"], ["fivefourseven"], ["ninethreesixthree"], ["foursixeighttwofive"], ["fivethreefivesixthreenineonesevenoneeight"], ["threesevensevensixninenineninefiveeighttwofiveeightsixthreeeight"], ["zeroonetwothreefourfivesixseveneightnine"]], "outputs": [["three"], ["eight six"], ["five four seven"], ["nine three six three"], ["four six eight two five"], ["five three five six three nine one seven one eight"], ["three seven seven six nine nine nine five eight two five eight six three eight"], ["zero one two three four five six seven eight nine"]], "starter_code": "def uncollapse(digits: str) -> str:", "canonical_solution": "import re\n\ndef uncollapse(digits):\n    return ' '.join(re.findall('zero|one|two|three|four|five|six|seven|eight|nine', digits))", "entry_point": "uncollapse", "task_id": "TACO_lite/1662", "input_output_examples": "[[['three'], ['eightsix'], ['fivefourseven'], ['ninethreesixthree'], ['fivethreefivesixthreenineonesevenoneeight']], [['three'], ['eight six'], ['five four seven'], ['nine three six three'], ['five three five six three nine one seven one eight']]]", "llm_generated_inputs": {"deepseek-v3": "[['three'], ['eightsix'], ['fivefourseven'], ['ninethreesixthree'], ['fivethreefivesixthreenineonesevenoneeight'], ['zero'], ['oneoneone'], ['twotwotwotwo'], ['threefourfive'], ['sixseveneightnineten'], ['onetwothreefourfivesixseveneightnineten'], [''], ['onethreefive'], ['twofour'], ['sixeight'], ['seventen'], ['ninetwo'], ['fourone'], ['fiveseven'], ['eightthree'], ['tenzero'], ['onethreefive'], ['twofour'], ['sixeight'], ['seventen'], ['ninetwo'], ['fourone'], ['fiveseven'], ['eightthree'], ['tenzero']]", "qwen2.5-coder-32b-instruct": "[['three'], ['eightsix'], ['fivefourseven'], ['ninethreesixthree'], ['fivethreefivesixthreenineonesevenoneeight'], ['zeronineoneoneeighttwoseventhreesixfourtwofive'], ['zero'], ['nine'], [' '], [''], ['eleven'], ['onetwothreefourfivesixseveneightnine']]"}}
{"requirement": "from typing import List\n\n\ndef coprimes(n: int) -> List[int]:\n\"\"\"Two integers are coprimes if the their only greatest common divisor is 1.\n\n## Task\nIn this kata you'll be given a number ```n >= 2``` and output a list with all positive integers less than ```gcd(n, k) == 1```, with ```k``` being any of the output numbers.\n\nThe list cannot include duplicated entries and has to be sorted.\n\n\n## Examples\n```\n2 -> [1]\n3 -> [1, 2]\n6 -> [1, 5]\n10 -> [1, 3, 7, 9]\n20 -> [1, 3, 7, 9, 11, 13, 17, 19]\n25 -> [1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24]\n30 -> [1, 7, 11, 13, 17, 19, 23, 29]\n```\n\"\"\"", "inputs": [[2], [3], [6], [10], [20], [25], [30]], "outputs": [[[1]], [[1, 2]], [[1, 5]], [[1, 3, 7, 9]], [[1, 3, 7, 9, 11, 13, 17, 19]], [[1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24]], [[1, 7, 11, 13, 17, 19, 23, 29]]], "starter_code": "from typing import List\ndef coprimes(n: int) -> List[int]:", "canonical_solution": "def coprimes(n):\n    p, s = (n, list(range(n)))\n    for d in range(2, int(n ** 0.5) + 1):\n        if not p % d:\n            while not p % d:\n                p //= d\n            s[d::d] = ((n - d - 1) // d + 1) * [0]\n    if p > 1:\n        s[p::p] = ((n - p - 1) // p + 1) * [0]\n    return [i for i, n in enumerate(s) if n]", "entry_point": "coprimes", "task_id": "TACO_lite/1673", "input_output_examples": "[[[2], [3], [6], [10], [20], [25], [30]], [[[1]], [[1, 2]], [[1, 5]], [[1, 3, 7, 9]], [[1, 3, 7, 9, 11, 13, 17, 19]], [[1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24]], [[1, 7, 11, 13, 17, 19, 23, 29]]]]", "llm_generated_inputs": {"deepseek-v3": "[[2], [3], [6], [10], [20], [25], [30], [1], [100], [17]]", "qwen2.5-coder-32b-instruct": "[[2], [3], [6], [10], [20], [25], [30], [1], [100], [101]]"}}
{"requirement": "def longestvalidparentheses(s: str) -> int:\n\"\"\"Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n \nExample 1:\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\n\nExample 2:\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\n\nExample 3:\nInput: s = \"\"\nOutput: 0\n\n \nConstraints:\n\n0 <= s.length <= 3 * 104\ns[i] is '(', or ')'.\n\"\"\"", "inputs": [["\"(()\""], ["\")()())\""], ["\"\""]], "outputs": [[2], [4], [0]], "starter_code": "def longestvalidparentheses(s: str) -> int:", "canonical_solution": "def longestvalidparentheses(s: str) -> int:\n    memo = {}\n    n = len(s)\n\n    def dp(i):\n        if i <= 0:\n            return 0\n        if i in memo:\n            return memo[i]\n        if (s[i - 1], s[i]) == ('(', ')'):\n            memo[i] = dp(i - 2) + 2\n        elif (s[i - 1], s[i]) == (')', ')') and i - dp(i - 1) - 1 >= 0 and (s[i - dp(i - 1) - 1] == '('):\n            memo[i] = dp(i - 1) + 2 + dp(i - dp(i - 1) - 2)\n        else:\n            memo[i] = 0\n        return memo[i]\n    ret = 0\n    for i in range(n - 1, 0, -1):\n        ret = max(ret, dp(i))\n    return ret", "entry_point": "longestvalidparentheses", "task_id": "TACO_lite/1682", "input_output_examples": "[[['(()'], [')()())'], ['']], [[2], [4], [0]]]", "llm_generated_inputs": {"deepseek-v3": "[['(()'], [')()())'], [''], ['()'], ['()((())'], ['((())())'], ['((((((()))))))'], ['))))(((('], ['()()()()'], ['(()))()()'], ['((())))(()'], ['((()()())))'], ['()(()'], ['(()(()))'], [')(())(())('], ['(()())(())']]", "qwen2.5-coder-32b-instruct": "[['(()'], [')()())'], [''], ['()'], ['((()))'], ['(()))('], ['()()'], ['(((((((((('], ['))))))))))'], ['()(()())'], ['(()(()))'], [')'], ['('], ['(()())(())'], ['(()((())()))'], ['()(()'], [')(()'], ['()()()()'], ['((((((((()))))))'], ['((((((((()))))))']]"}}
{"requirement": "def bernoulli_number(n: int) -> Fraction:\n\"\"\"## Story\n\nBefore we dive into the exercise, I would like to show you why these numbers are so important in computer programming today.\n\nIt all goes back to the time of 19th century. Where computers we know today were non-existing. The first ever **computer program** was for the Analytical Engine to compute **Bernoulli numbers**. A woman named Ada Lovelace wrote the very first program. The sad part is the engine was never fully build so her code was never tested. She also predicted the start of **AI** (artificial intelligence).\n\nComputers will be able to compose music by themselves, solve problems (not only numbers) ... So in her honor reproduce what was done back in 1842. The Bernoulli numbers are a sequence of rational numbers with deep connections to number theory. The Swiss mathematician Jakob Bernoulli and the Japanese mathematician Seki Kowa discovered the numbers around the same time at the start of the 18th Century. If you want to read more about her or Bernoulli numbers follow these links:\n\nhttps://en.wikipedia.org/wiki/Ada_Lovelace\n\nhttps://en.wikipedia.org/wiki/Bernoulli_number\n\nhttp://mathworld.wolfram.com/BernoulliNumber.html\n\n## Exercise\n\nYour job is to write a function `bernoulli_number(n)` which outputs the n-th Bernoulli number. The input will always be a non-negative integer so you do not need to worry about exceptions. How you will solve the problem is none of my business but here are some guidelines.  \nYou can make pascal triangle and then with the basic formula generate all Bernoulli numbers. Look example below.\n\nFor the sake of floating numbers, just use `Fractions` so there will be no problems with rounding.\n\n\n0 = 1 + 2b1 ............................................................... \n  b1 = - 1/2\n\n0 = 1 + 3b1 + 3b2 ...................................................    b2        = 1/6\n\n0 = 1 + 4b1 + 6b2 + 4b3 .......................................  b3 = 0\n\n0 = 1 + 5b1 + 10b2 + 10b3 + 5b4 ...................... b4 = - 1/30\n\n... and so on.\n\n```\nbernoulli_number(0) # return 1\nbernoulli_number(1) # return Fraction(-1,2) or Rational(-1,2) or \"1/2\"\nbernoulli_number(6) # return Fraction(1,42) or ...\nbernoulli_number(42) # return Fraction(1520097643918070802691,1806) or ...\nbernoulli_number(22) # return Fraction(854513,138) or ... \"854513/138\"\n```\n\n## Note\n\nSee \"Sample Tests\" to see the return type for each language.\n\nGood luck and happy coding! \n\nPS: be careful some numbers might exceed `1000`.\nIf this kata is too hard for you try to solve pascal triangle and something similar to this and then come back :).\n\"\"\"", "inputs": [[0], [3], [1337]], "outputs": [[1], [0], [0]], "starter_code": "def bernoulli_number(n: int) -> Fraction:", "canonical_solution": "from fractions import Fraction as frac\n\ndef ber():\n    res, m = ([], 0)\n    while True:\n        res.append(frac(1, m + 1))\n        for j in range(m, 0, -1):\n            res[j - 1] = j * (res[j - 1] - res[j])\n        yield res[0]\n        m += 1\n\ndef bernoulli_number(n):\n    if n == 1:\n        return Fraction(-1, 2)\n    if n % 2 == 1:\n        return 0\n    bn2 = [ix for ix in zip(range(n + 2), ber())]\n    bn2 = [b for _, b in bn2]\n    return bn2[n]", "entry_point": "bernoulli_number", "task_id": "TACO_lite/1691", "input_output_examples": "[[[0], [1], [6], [42], [22]], [[1], [-1/2], [1/42], [1520097643918070802691/1806], [854513/138]]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [2], [6], [22], [42], [100]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [2], [3], [4], [5], [6], [10], [20], [22], [42], [50], [100]]"}}
{"requirement": "from typing import List\n\n\ndef is_thue_morse(seq: List[int]) -> bool:\n\"\"\"# Task\n Given a sequence of 0s and 1s, determine if it is a prefix of Thue-Morse sequence.\n\n The infinite Thue-Morse sequence is obtained by first taking a sequence containing a single 0 and then repeatedly concatenating the current sequence with its binary complement.\n\n A binary complement of a sequence X is a sequence Y of the same length such that the sum of elements X_i and Y_i on the same positions is equal to 1 for each i.\n\n Thus the first few iterations to obtain Thue-Morse sequence are:\n```\n0\n0 1\n0 1 1 0\n0 1 1 0 1 0 0 1\n...\n```\n\n# Examples\n\n For `seq=[0, 1, 1, 0, 1]`, the result should be `true`.\n \n For `seq=[0, 1, 0, 0]`, the result should be `false`.\n\n\n# Inputs & Output\n\n\n - `[input]` integer array `seq`\n\n  An non-empty array.\n  \n  Constraints: \n  \n  `1 <= seq.length <= 1000`\n  \n  `seq[i] ∈ [0,1]`\n\n\n - `[output]` a boolean value\n\n  `true` if it is a prefix of Thue-Morse sequence. `false` otherwise.\n\"\"\"", "inputs": [[[0, 1, 1, 0, 1]], [[0]], [[1]], [[0, 1, 0, 0]]], "outputs": [[true], [true], [false], [false]], "starter_code": "from typing import List\ndef is_thue_morse(seq: List[int]) -> bool:", "canonical_solution": "def is_thue_morse(seq):\n    init_seq = [0]\n    while len(init_seq) < len(seq):\n        init_seq += [1 if n == 0 else 0 for n in init_seq]\n    return init_seq[:len(seq)] == seq", "entry_point": "is_thue_morse", "task_id": "TACO_lite/1697", "input_output_examples": "[[[[0, 1, 1, 0, 1]], [[0, 1, 0, 0]]], [[True], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[[0]], [[0, 1]], [[0, 1, 1, 0]], [[0, 1, 1, 0, 1, 0, 0, 1]], [[0, 1, 1, 0, 1]], [[0, 1, 0, 0]], [[1]], [[1, 0]], [[0, 0]], [[1, 1]], [[0, 1, 1, 1]], [[0, 1, 1, 0, 0, 1, 1, 0]], [[0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0]]]", "qwen2.5-coder-32b-instruct": "[[[0]], [[0, 1]], [[0, 1, 1, 0]], [[0, 1, 1, 0, 1, 0, 0, 1]], [[0, 1, 1, 0, 1]], [[0, 1, 0, 0]], [[1]], [[1, 0]], [[1, 0, 0, 1]], [[0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0]], [[0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1]]]"}}
{"requirement": "from typing import List\n\n\ndef max_product(lst: List[int], n_largest_elements: int) -> int:\n\"\"\"### Introduction and Warm-up (Highly recommended)\n\n### [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n___\n\n## Task\n\n**_Given_** an *array/list [] of integers* , **_Find the product of the k maximal_** numbers.\n___\n\n### Notes \n\n* **_Array/list_** size is *at least 3* .\n\n* **_Array/list's numbers_**  *Will be* **_mixture of positives , negatives and zeros_** \n\n* **_Repetition_** of numbers in *the array/list could occur*.\n___\n\n### Input >> Output Examples \n\n```\nmaxProduct ({4, 3, 5}, 2) ==>  return (20)\n```\n\n#### _Explanation_:\n\n* **_Since_** *the size (k) equal 2* , then **_the subsequence of size 2_** *whose gives* **_product of maxima_**  is `5 * 4 = 20` .\n___\n\n```\nmaxProduct ({8, 10 , 9, 7}, 3) ==>  return (720)\n```\n\n#### _Explanation_:\n\n* **_Since_** *the size (k) equal 3* , then **_the subsequence of size 3_** *whose gives* **_product of maxima_**  is ` 8 * 9 * 10 = 720` .\n___\n\n```\nmaxProduct ({10, 8, 3, 2, 1, 4, 10}, 5) ==> return (9600)\n```\n\n#### _Explanation_:\n\n* **_Since_** *the size (k) equal 5* , then **_the subsequence of size 5_** *whose gives* **_product of maxima_**  is ` 10 * 10 * 8 * 4 * 3 = 9600` .\n___\n\n```\nmaxProduct ({-4, -27, -15, -6, -1}, 2) ==> return (4)\n```\n\n#### _Explanation_:\n\n* **_Since_** *the size (k) equal 2* , then **_the subsequence of size 2_** *whose gives* **_product of maxima_**  is ` -4 * -1 = 4` .\n___\n\n```\nmaxProduct ({10, 3, -1, -27} , 3)  return (-30)\n``` \n\n#### _Explanation_:\n* **_Since_** *the size (k) equal 3* , then **_the subsequence of size 3_** *whose gives* **_product of maxima_**  is ` 10 * 3 * -1 = -30 ` .\n___\n___\n___\n___\n\n#### [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n#### [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n#### [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n##### ALL translations are welcomed\n\n##### Enjoy Learning !!\n##### Zizou\n\"\"\"", "inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5], [[4, 3, 5], 2], [[10, 8, 7, 9], 3], [[8, 6, 4, 6], 3], [[10, 2, 3, 8, 1, 10, 4], 5], [[13, 12, -27, -302, 25, 37, 133, 155, -1], 5], [[-4, -27, -15, -6, -1], 2], [[-17, -8, -102, -309], 2], [[10, 3, -27, -1], 3], [[14, 29, -28, 39, -16, -48], 4]], "outputs": [[0], [20], [720], [288], [9600], [247895375], [4], [136], [-30], [-253344]], "starter_code": "from typing import List\ndef max_product(lst: List[int], n_largest_elements: int) -> int:", "canonical_solution": "def max_product(lst, n_largest_elements):\n    lst_largest = sorted(lst)[-n_largest_elements:]\n    prod = 1\n    for number in lst_largest:\n        prod *= number\n    return prod", "entry_point": "max_product", "task_id": "TACO_lite/1714", "input_output_examples": "[[[[4, 3, 5], 2], [[8, 10, 9, 7], 3], [[10, 8, 3, 2, 1, 4, 10], 5], [[-4, -27, -15, -6, -1], 2], [[10, 3, -1, -27], 3]], [[20], [720], [9600], [4], [-30]]]", "llm_generated_inputs": {"deepseek-v3": "[[[4, 3, 5], 2], [[8, 10, 9, 7], 3], [[10, 8, 3, 2, 1, 4, 10], 5], [[-4, -27, -15, -6, -1], 2], [[10, 3, -1, -27], 3], [[1, 2, 3], 1], [[0, 0, 0], 2], [[-1, -2, -3, -4], 3], [[1, -1, 1, -1], 4], [[100, -100, 50, -50], 2]]", "qwen2.5-coder-32b-instruct": "[[[4, 3, 5], 2], [[8, 10, 9, 7], 3], [[10, 8, 3, 2, 1, 4, 10], 5], [[-4, -27, -15, -6, -1], 2], [[10, 3, -1, -27], 3], [[1, 2, 3], 2], [[0, 0, 0], 2], [[1, 2, 3, 4, 5], 5], [[-1, -2, -3, -4, -5], 3], [[100, 200, 300, 400, 500], 2]]"}}
{"requirement": "def count_odd_pentafib(n: int) -> int:\n\"\"\"We have the following sequence:\n```python\nf(0) = 0\nf(1) = 1\nf(2) = 1\nf(3) = 2\nf(4) = 4;\nf(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4) + f(n-5);\n```\n\nYour task is to give the number of total values for the odd terms of the sequence  up to the n-th term (included). (The number n (of n-th term) will be given as a positive integer)\n\nThe values 1 (one) is the only that is duplicated in the sequence and should be counted only once.\n\nE.g. \n```\ncount_odd_pentafib(5) -----> 1 # because the terms up to 5 are: 0, 1, 1, 2, 4, 8 (only 1 is odd and counted once)\n```\nOther examples:\n```\n count_odd_pentafib(10) ------> 3 #because the odds terms are: [1, 1, 31, 61] (three different values)\n\ncount_odd_pentafib(15) ------> 5 # beacause the odd terms are: [1, 1, 31, 61, 1793, 3525] (five different values)\n```\nGood luck !!\n\n(Your code should be fast. Many moderate high values will be waiting to test it.)\n\"\"\"", "inputs": [[0], [1], [2]], "outputs": [[0], [1], [1]], "starter_code": "def count_odd_pentafib(n: int) -> int:", "canonical_solution": "def count_odd_pentafib(n):\n    return 2 * (n // 6) + [0, 1, 2, 2, 2, 2][n % 6] - (n >= 2)", "entry_point": "count_odd_pentafib", "task_id": "TACO_lite/1715", "input_output_examples": "[[[5], [10], [15]], [[1], [3], [5]]]", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [2], [5], [10], [15], [20], [25], [30], [50]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [2], [3], [4], [5], [10], [15], [20], [50], [100]]"}}
{"requirement": "def body_count(code: str) -> bool:\n\"\"\"Chuck has lost count of how many asses he has kicked...\n\nChuck stopped counting at 100,000 because he prefers to kick things in the face instead of counting. That's just who he is.\n\nTo stop having to count like a mere mortal chuck developed his own special code using the hairs on his beard. You do not need to know the details of how it works, you simply need to know that the format is as follows: 'A8A8A8A8A8.-A%8.88.'\n\nIn Chuck's code, 'A' can be any capital letter and '8' can be any number 0-9 and any %, - or . symbols must not be changed.\n\nYour task, to stop Chuck beating your ass with his little finger, is to use regex to verify if the number is a genuine Chuck score. If not it's probably some crap made up by his nemesis Bruce Lee. Return true if the provided count passes, and false if it does not.  \n\n```Javascript\nExample:\n     'A8A8A8A8A8.-A%8.88.' <- don't forget final full stop :D\\n\nTests:\n     'A2B8T1Q9W4.-F%5.34.' == true;\n     'a2B8T1Q9W4.-F%5.34.' == false; (small letter)\n     'A2B8T1Q9W4.-F%5.3B.' == false; (last char should be number) \n     'A2B8T1Q9W4.£F&5.34.' == false; (symbol changed from - and %)\n\n\n ```\n\nThe pattern only needs to appear within the text. The full input can be longer, i.e. the pattern can be surrounded by other characters... Chuck loves to be surrounded!\n\nReady, steady, VERIFY!!\n\"\"\"", "inputs": [["A6C2E5Z9A4.-F%8.08."], ["PP P6A6T5F5S3.-Z%1.11.hgr"], ["A6A1E3A8M2.-Q%8.88."], ["d G8H1E2O9N3.-W%8.56. f"], ["B4A1D1I8B4.-E%8.76."], ["ffr65A C8K4D9U7V5.-Y%8.00."], [" 76     B2L4D0A8C6.-T%8.90.       lkd"], ["B2L4D0A8C6.-T%8.90"], ["B2L4D0AFC6.-T%8.90."], ["B4A1D1I8B4"], ["B4A6666..."], ["B4A1D1I000.-E%0.00.)"], [".-E%8.76."], ["B4A1t6I7.-E%8.76."], ["b4A1D1I8B4.-E%8.76."]], "outputs": [[true], [true], [true], [true], [true], [true], [true], [false], [false], [false], [false], [false], [false], [false], [false]], "starter_code": "def body_count(code: str) -> bool:", "canonical_solution": "from re import search\n\ndef body_count(code):\n    return bool(search('(?:[A-Z]\\\\d){5}\\\\.-[A-Z]%\\\\d\\\\.\\\\d{2}\\\\.', code))", "entry_point": "body_count", "task_id": "TACO_lite/1723", "input_output_examples": "[[['A2B8T1Q9W4.-F%5.34.'], ['a2B8T1Q9W4.-F%5.34.'], ['A2B8T1Q9W4.-F%5.3B.'], ['A2B8T1Q9W4.£F&5.34.']], [[True], [False], [False], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[['A2B8T1Q9W4.-F%5.34.'], ['a2B8T1Q9W4.-F%5.34.'], ['A2B8T1Q9W4.-F%5.3B.'], ['A2B8T1Q9W4.£F&5.34.'], ['This is a valid code: A2B8T1Q9W4.-F%5.34. Chuck approves!'], ['Invalid code here: A2B8T1Q9W4.-F%5.3B. Bruce Lee is sneaky!'], ['A2B8T1Q9W4.-F%5.34.extra characters are fine!'], ['A2B8T1Q9W4.-F%5.34'], ['A2B8T1Q9W4.-F%5.34. '], [' A2B8T1Q9W4.-F%5.34. '], ['A2B8T1Q9W4.-F%5.34. and some more text'], ['A2B8T1Q9W4.-F%5.34. with symbols: !@#$%^&*()'], ['A2B8T1Q9W4.-F%5.34.'], ['A2B8T1Q9W4.-F%5.34. '], ['A2B8T1Q9W4.-F%5.34. and some more text']]", "qwen2.5-coder-32b-instruct": "[['A2B8T1Q9W4.-F%5.34.'], ['a2B8T1Q9W4.-F%5.34.'], ['A2B8T1Q9W4.-F%5.3B.'], ['A2B8T1Q9W4.£F&5.34.'], ['Z9Y7X5V3N1.-M%2.67.'], ['A0A0A0A0A0.-A%0.00.'], ['A8A8A8A8A8.-A%8.88. extra stuff'], ['extra stuff A8A8A8A8A8.-A%8.88.'], ['A8A8A8A8A8.-A%8.88.A8A8A8A8A8.-A%8.88.'], ['A8A8A8A8A8.-A%8.88A8A8A8A8.-A%8.88.'], ['A8A8A8A8A8.-A%8.88. A8A8A8A8A8.-A%8.88.'], ['A8A8A8A8A8.-A%8.88.A8A8A8A8A8.-A%8.88.'], ['A8A8A8A8A8.-A%8.88A'], ['A8A8A8A8A8.-A%8.8'], ['A8A8A8A8A8.-A%8.'], ['A8A8A8A8A8.-A%.'], ['A8A8A8A8A8.-A.'], ['A8A8A8A8A8.-.'], ['A8A8A8A8A8.'], ['A8A8A8A8A8.-A%8.88. '], [' A8A8A8A8A8.-A%8.88.'], ['A8A8A8A8A8.-A%8.88.'], ['A8A8A8A8A8.-A%8.88']]"}}
{"requirement": "def hex_color(codes: str) -> str:\n\"\"\"You're looking through different hex codes, and having trouble telling the difference between  #000001  and  #100000 \n\nWe need a way to tell which is red, and which is blue!\n\nThat's where you create ```hex_color()```!\n\nIt should read an RGB input, and return whichever value (red, blue, or green) is of greatest concentration!\n\nBut, if multiple colors are of equal concentration, you should return their mix!\n\n```python\nred + blue = magenta\n\ngreen + red = yellow\n\nblue + green = cyan\n\nred + blue + green = white\n```\n\nOne last thing, if the string given is empty, or has all 0's, return black!\n\nExamples:\n```python\nhex_color('087 255 054') == 'green'\nhex_color('181 181 170') == 'yellow'\nhex_color('000 000 000') == 'black'\nhex_color('001 001 001') == 'white'\n```\n\"\"\"", "inputs": [[""], ["000 000 000"], ["121 245 255"], ["027 100 100"], ["021 021 021"], ["255 000 000"], ["000 147 000"], ["212 103 212"], ["101 101 092"]], "outputs": [["black"], ["black"], ["blue"], ["cyan"], ["white"], ["red"], ["green"], ["magenta"], ["yellow"]], "starter_code": "def hex_color(codes: str) -> str:", "canonical_solution": "colors = {(1, 0, 0): 'red', (0, 1, 0): 'green', (0, 0, 1): 'blue', (1, 0, 1): 'magenta', (1, 1, 0): 'yellow', (0, 1, 1): 'cyan', (1, 1, 1): 'white'}\n\ndef hex_color(codes):\n    codes = codes or '0 0 0'\n    items = [int(c) for c in codes.split()]\n    m = max(items)\n    return colors[tuple((i == m for i in items))] if m else 'black'", "entry_point": "hex_color", "task_id": "TACO_lite/1728", "input_output_examples": "[[['087 255 054'], ['181 181 170'], ['000 000 000'], ['001 001 001']], [['green'], ['yellow'], ['black'], ['white']]]", "llm_generated_inputs": {"deepseek-v3": "[['087 255 054'], ['181 181 170'], ['000 000 000'], ['001 001 001'], ['255 000 000'], ['000 255 000'], ['000 000 255'], ['255 255 000'], ['255 000 255'], ['000 255 255'], ['128 128 128'], ['128 128 000'], ['128 000 128'], ['000 128 128'], ['300 300 300'], [''], ['0 0 0'], ['255 255 255'], ['001 002 003'], ['100 100 100']]", "qwen2.5-coder-32b-instruct": "[['087 255 054'], ['181 181 170'], ['000 000 000'], ['001 001 001'], ['255 000 000'], ['000 255 000'], ['000 000 255'], ['255 255 000'], ['255 000 255'], ['000 255 255'], ['255 255 255'], ['128 128 128'], ['100 100 000'], ['000 100 100'], ['100 000 100'], ['000 000 001'], ['100000'], ['000 000 000000'], ['255 255 254'], ['000 000 000001']]"}}
{"requirement": "from typing import List\n\n\ndef infected_zeroes(s: List[int]) -> int:\n\"\"\"In this kata, the number 0 is infected. You are given a list. Every turn, any item in the list that is adjacent to a 0 becomes infected and transforms into a 0. How many turns will it take for the whole list to become infected?\n\n```\n[0,1,1,0] ==> [0,0,0,0] \nAll infected in 1 turn.\n\n[1,1,0,1,1] --> [1,0,0,0,1] --> [0,0,0,0,0]\nAll infected in 2 turns\n\n[0,1,1,1] --> [0,0,1,1] --> [0,0,0,1] --> [0,0,0,0]\nAll infected in 3 turns.\n```\n\nAll lists will contain at least one item, and at least one zero, and the only items will be 0s and 1s. Lists may be very very long, so pure brute force approach will not work.\n\"\"\"", "inputs": [[[0]], [[0, 1, 1, 0]], [[0, 1, 1, 1, 0]], [[1, 1, 0, 1, 1]], [[0, 1, 1, 1]], [[1, 1, 1, 0]]], "outputs": [[0], [1], [2], [2], [3], [3]], "starter_code": "from typing import List\ndef infected_zeroes(s: List[int]) -> int:", "canonical_solution": "def infected_zeroes(s):\n    m = 0\n    l = 0\n    for i, n in enumerate(s):\n        if n == 0:\n            m = i if l == 0 else max(m, (i - l + 1) // 2)\n            l = i + 1\n    return max(m, len(s) - l)", "entry_point": "infected_zeroes", "task_id": "TACO_lite/1732", "input_output_examples": "[[[[0, 1, 1, 0]], [[1, 1, 0, 1, 1]], [[0, 1, 1, 1]]], [[1], [2], [3]]]", "llm_generated_inputs": {"deepseek-v3": "[[[0, 1, 1, 0]], [[1, 1, 0, 1, 1]], [[0, 1, 1, 1]], [[0, 0, 0, 0]], [[1, 0, 1, 0, 1, 0, 1]], [[0, 1, 0, 1, 0, 1, 0]], [[1, 1, 1, 1, 0]], [[0, 1, 1, 1, 1]], [[0, 1, 0, 1, 0, 1, 0, 1, 0]], [[1, 1, 1, 1, 1, 1, 1, 0]]]", "qwen2.5-coder-32b-instruct": "[[[0, 1, 1, 0]], [[1, 1, 0, 1, 1]], [[0, 1, 1, 1]], [[1, 0, 1]], [[0]], [[1, 0]], [[0, 1]], [[1, 1, 1, 1, 0, 1, 1, 1, 1]], [[0, 1, 0, 1, 0, 1, 0, 1, 0]], [[1, 1, 1, 1, 1, 1, 1, 1, 0]]]"}}
{"requirement": "def filter_numbers(string: str) -> str:\n\"\"\"Failed Filter - Bug Fixing #3\nOh no, Timmy's filter doesn't seem to be working? Your task is to fix the FilterNumber function to remove all the numbers from the string.\n\n\n\"\"\"", "inputs": [["test123"], ["a1b2c3"], ["aa1bb2cc3dd"], ["CodeWars"], ["99234"]], "outputs": [["test"], ["abc"], ["aabbccdd"], ["CodeWars"], [""]], "starter_code": "def filter_numbers(string: str) -> str:", "canonical_solution": "def filter_numbers(string):\n    return ''.join((x for x in string if not x.isdigit()))", "entry_point": "filter_numbers", "task_id": "TACO_lite/1733", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['Hello123World456'], ['NoNumbersHere'], ['1234567890'], [''], ['Special!Chars@123'], ['Mixed123With456Spaces 789'], ['OnlyOneNumber1'], ['NumbersAtTheEnd123'], ['NumbersAtTheStart123Hello'], ['Multiple123Numbers456In789Between']]", "qwen2.5-coder-32b-instruct": "[['abc123'], ['123456'], ['noNumbersHere!'], ['1a2b3c4d5e'], [''], [' '], ['numbers123and456letters'], ['special!@#123characters$%^']]"}}
{"requirement": "def solve(n: int) -> int:\n\"\"\"Consider a sequence generation that follows the following steps. We will store removed values in variable `res`. Assume `n = 25`:\n```Haskell\n-> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25] Let's remove the first number => res = [1]. We get..\n-> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]. Let's remove 2 (so res = [1,2]) and every 2-indexed number. We get..\n-> [3,5,7,9,11,13,15,17,19,21,23,25]. Now remove 3, then every 3-indexed number. res = [1,2,3]. \n-> [5,7,11,13,17,19,23,25]. Now remove 5, and every 5-indexed number. res = [1,2,3,5]. We get..\n-> [7,11,13,17,23,25]. Now remove 7 and every 7-indexed. res = [1,2,3,5,7].  \nBut we know that there are no other 7-indexed elements, so we include all remaining numbers in res. So res = [1,2,3,5,7,11,13,17,23,25] and sum(res) = 107.\n\nNote that when we remove every n-indexed number, we must remember that indices start at 0. So for every 3-indexed number above:\n[3,5,7,9,11,13,15,17,19,21,23], we remove index0=3, index3= 9, index6=15,index9=21, etc.\n\nNote also that if the length of sequence is greater than x, where x is the first element of the sequence, you should continue the remove step: remove x, and every x-indexed number until the length of sequence is shorter than x. In our example above, we stopped at 7 because the the length of the remaining sequence [7,11,13,17,23,25] is shorter than 7.\n```\nYou will be given a number `n` and your task will be to return the sum of the elements in res, where the maximum element in res is `<= n`. \n\nFor example:\n\n```Python\nSolve(7) = 18, because this is the sum of res = [1,2,3,5,7].\nSolve(25) = 107\n```\n\nMore examples in the test cases. \n\nGood luck!\n\"\"\"", "inputs": [[7], [25], [50], [100], [1000], [10000]], "outputs": [[18], [107], [304], [993], [63589], [4721110]], "starter_code": "def solve(n: int) -> int:", "canonical_solution": "def solve(n):\n    zoznam = [int(i) for i in range(2, n + 1)]\n    res = [1]\n    while zoznam != []:\n        res.append(zoznam[0])\n        del zoznam[0::zoznam[0]]\n    return sum(res)", "entry_point": "solve", "task_id": "TACO_lite/1738", "input_output_examples": "[[[7], [25]], [[18], [107]]]", "llm_generated_inputs": {"deepseek-v3": "[[7], [25], [1], [2], [3], [10], [50], [100], [0], [-1]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [5], [7], [10], [15], [20], [25], [30], [50], [100]]"}}
{"requirement": "def obfuscate(email: str) -> str:\n\"\"\"Many people choose to obfuscate their email address when displaying it on the Web. One common way of doing this is by substituting the `@` and `.` characters for their literal equivalents in brackets.\n\nExample 1:\n```\nuser_name@example.com\n=> user_name [at] example [dot] com\n```\n\nExample 2:\n```\naf5134@borchmore.edu\n=> af5134 [at] borchmore [dot] edu\n```\nExample 3:\n```\njim.kuback@ennerman-hatano.com\n=> jim [dot] kuback [at] ennerman-hatano [dot] com\n```\n\nUsing the examples above as a guide, write a function that takes an email address string and returns the obfuscated version as a string that replaces the characters `@` and `.` with `[at]` and `[dot]`, respectively.\n\n>Notes\n\n>* Input (`email`) will always be a string object. Your function should return a string.\n\n>* Change only the `@` and `.` characters.\n\n>* Email addresses may contain more than one `.` character.\n\n>* Note the additional whitespace around the bracketed literals in the examples!\n\"\"\"", "inputs": [["user_name@example.com"], ["af5134@borchmore.edu"], ["jim.kuback@ennerman-hatano.com"], ["sir_k3v1n_wulf@blingblong.net"], ["Hmm, this would be better with input validation...!"]], "outputs": [["user_name [at] example [dot] com"], ["af5134 [at] borchmore [dot] edu"], ["jim [dot] kuback [at] ennerman-hatano [dot] com"], ["sir_k3v1n_wulf [at] blingblong [dot] net"], ["Hmm, this would be better with input validation [dot]  [dot]  [dot] !"]], "starter_code": "def obfuscate(email: str) -> str:", "canonical_solution": "def obfuscate(email):\n    return email.replace('@', ' [at] ').replace('.', ' [dot] ')", "entry_point": "obfuscate", "task_id": "TACO_lite/1739", "input_output_examples": "[[['user_name@example.com'], ['af5134@borchmore.edu'], ['jim.kuback@ennerman-hatano.com']], [['user_name [at] example [dot] com'], ['af5134 [at] borchmore [dot] edu'], ['jim [dot] kuback [at] ennerman-hatano [dot] com']]]", "llm_generated_inputs": {"deepseek-v3": "[['user_name@example.com'], ['af5134@borchmore.edu'], ['jim.kuback@ennerman-hatano.com'], ['john.doe@example.co.uk'], ['test@test'], ['test@test.com'], ['test.test@test.test.com'], ['@.'], ['...@...'], ['test@'], ['@test.com'], ['.@.'], ['test.test.test@example.com']]", "qwen2.5-coder-32b-instruct": "[['user_name@example.com'], ['af5134@borchmore.edu'], ['jim.kuback@ennerman-hatano.com'], ['no.at.sign.com'], ['multiple.dots.in.domain@sub.example.co.uk'], ['singlechar@e.co'], ['@missingusername.com'], ['username@.missingdomain'], ['username@missingdomain.'], ['user.name@domain.com'], ['user@domain..com'], ['user@domain.c.'], ['user@[at]domain.com'], ['user@[dot]domain.com'], ['user@domain[dot]com'], ['user@domain[at]com'], ['user.name@[at]domain[dot]com']]"}}
{"requirement": "def solve(n: int) -> int:\n\"\"\"In this Kata, you will be given a number and your task will be to return the nearest prime number. \n\n```Haskell\nsolve(4) = 3. The nearest primes are 3 and 5. If difference is equal, pick the lower one. \nsolve(125) = 127\n```\n\nWe'll be testing for numbers up to `1E10`. `500` tests.\n\nMore examples in test cases. \n\nGood luck!\n\nIf you like Prime Katas, you will enjoy this Kata: [Simple Prime Streaming](https://www.codewars.com/kata/5a908da30025e995880000e3)\n\"\"\"", "inputs": [[3], [11], [4], [110], [1110], [3000], [35000], [350000], [3500000], [10000000000]], "outputs": [[3], [11], [3], [109], [1109], [2999], [34981], [350003], [3499999], [10000000019]], "starter_code": "def solve(n: int) -> int:", "canonical_solution": "def isPrime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef solve(n):\n    if isPrime(n):\n        return n\n    add = 1\n    rem = 1\n    ans = None\n    while True:\n        if isPrime(n + add):\n            ans = n + add\n        if isPrime(n - rem):\n            ans = n - rem\n        if ans != None:\n            return ans\n        add += 1\n        rem += 1", "entry_point": "solve", "task_id": "TACO_lite/1746", "input_output_examples": "[[[4], [125]], [[3], [127]]]", "llm_generated_inputs": {"deepseek-v3": "[[4], [125], [1], [2], [10], [29], [30], [10000000000], [9999999999], [100000], [1000000], [100000000], [1000000000]]", "qwen2.5-coder-32b-instruct": "[[4], [125], [1], [2], [3], [10], [17], [10000000000.0], [9999999999], [10000000000], [1500456789]]"}}
{"requirement": "from typing import List\n\n\ndef closest(lst: List[int]) -> Optional[int]:\n\"\"\"Simply find the closest value to zero from the list. Notice that there are negatives in the list.\n\nList is always not empty and contains only integers. Return ```None``` if it is not possible to define only one of such values. And of course, we are expecting 0 as closest value to zero.\n\nExamples:\n```code\n[2, 4, -1, -3]  => -1\n[5, 2, -2]      => None\n[5, 2, 2]       => 2\n[13, 0, -6]     => 0\n```\n\"\"\"", "inputs": [[[10, 3, 9, 1]], [[2, 4, -1, -3]], [[5, 2, -2]], [[5, 2, 2]], [[13, 0, -6]], [[1]], [[5, 1, -1, 2, -10]], [[5, -5, -2, 5, -3]], [[27, 37, 48, -18, 42, 16, 5, 34, 35, 26, -34, 3, -43, 35, 0, -45, -7, 45, 34, -18, 44, 12, 6, -45, 33, 27, -2, 28, 12, 9]], [[11, -30, -18, 4, -13, 43, 12, -5, -6, -3, 48, 24, -35, 13, -14, 16, 40, -5, 33, -39, -29, 19, -19, -36, 17, 26, 43, 11, 28, -32]], [[28, -36, 49, 39, -33, 22, -5, 23, -24, 47, -47, -30, -20, -18, 40, -21, -45, 10, -48, -26, -12, -21, 48, 16, 26, 21, -9, 33, 8, -49]], [[32, -26, 15, 17, -11, -14, 17, 44, 16, 49, 14, 11, 40, 27, -32, 6, 18, 38, 48, -28, -29, -28, 21, -38, 26, -37, -43, 16, 13, -6]], [[36, 43, 44, -15, 37, 38, -11, 37, 21, 8, 20, -13, -32, -15, 31, -6, -33, -6, -47, 0, 0, 33, 42, 0, -47, -29, -38, 18, -32, -33]], [[20, 26, 13, -47, -35, 39, 24, 46, -16, 5, 46, -30, -33, -38, -47, 23, 10, -39, -36, 41, 5, -24, 28, -30, 40, -24, -28, -17, -36, 41]]], "outputs": [[1], [-1], [null], [2], [0], [1], [null], [-2], [0], [-3], [-5], [null], [0], [5]], "starter_code": "from typing import List\ndef closest(lst: List[int]) -> Optional[int]:", "canonical_solution": "def closest(lst):\n    m = min(lst, key=abs)\n    return m if m == 0 or -m not in lst else None", "entry_point": "closest", "task_id": "TACO_lite/1749", "input_output_examples": "[[[[2, 4, -1, -3]], [[5, 2, -2]], [[5, 2, 2]], [[13, 0, -6]]], [[-1], [None], [2], [0]]]", "llm_generated_inputs": {"deepseek-v3": "[[[2, 4, -1, -3]], [[5, 2, -2]], [[5, 2, 2]], [[13, 0, -6]], [[-5, -3, -1, 1, 3]], [[1, 1, 1, 1]], [[-1, -1, -1, -1]], [[0, 0, 0, 0]], [[100, -100]], [[-7, 8, 9, -6]]]", "qwen2.5-coder-32b-instruct": "[[[2, 4, -1, -3]], [[5, 2, -2]], [[5, 2, 2]], [[13, 0, -6]], [[0]], [[1, -1]], [[100, 99, -100]], [[-1, -2, -3, 3, 2, 1]], [[1]], [[-1]]]"}}
{"requirement": "def totalamountvisible(topNum: int, numOfSides: int) -> float:\n\"\"\"Your task is to return the number of visible dots on a die after it has been rolled(that means the total count of dots that would not be touching the table when rolled)\n\n6, 8, 10, 12, 20 sided dice are the possible inputs for \"numOfSides\" \n\ntopNum is equal to the number that is on top, or the number that was rolled.\n\nfor this exercise, all opposite faces add up to be 1 more than the total amount of sides\n  Example: 6 sided die would have 6 opposite 1, 4 opposite 3, and so on.\nfor this exercise, the 10 sided die starts at 1 and ends on 10.\n\nNote: topNum will never be greater than numOfSides\n\"\"\"", "inputs": [[5, 6], [19, 20], [6, 20], [15, 20], [8, 20], [9, 8], [4, 10], [12, 12], [7, 10], [4, 12]], "outputs": [[19], [208], [195], [204], [197], [36], [48], [77], [51], [69]], "starter_code": "def totalamountvisible(topNum: int, numOfSides: int) -> float:", "canonical_solution": "def totalamountvisible(topNum, numOfSides):\n    return numOfSides * (numOfSides + 1) / 2 - (numOfSides - topNum + 1)", "entry_point": "totalamountvisible", "task_id": "TACO_lite/1760", "input_output_examples": "[[[6, 6]], [[11.0]]]", "llm_generated_inputs": {"deepseek-v3": "[[5, 6], [1, 6], [3, 8], [7, 10], [11, 12], [19, 20], [4, 10], [6, 12], [2, 20], [1, 10], [10, 20]]", "qwen2.5-coder-32b-instruct": "[[1, 6], [6, 6], [3, 6], [5, 8], [1, 8], [8, 8], [5, 10], [10, 10], [1, 10], [7, 12], [12, 12], [1, 12], [20, 20], [1, 20], [10, 20], [0, 6], [7, 6], [11, 10], [21, 20]]"}}
{"requirement": "def code_for_same_protein(seq1: str, seq2: str) -> bool:\n\"\"\"In genetics 2 differents DNAs sequences can code for the same protein. \n\nThis is due to the redundancy of the genetic code, in fact 2 different tri-nucleotide can code for the same amino-acid.\nFor example the tri-nucleotide 'TTT' and the tri-nucleotide 'TTC' both code for the amino-acid 'F'. For more information you can take a look [here](https://en.wikipedia.org/wiki/DNA_codon_table).\n\nYour goal in this kata is to define if two differents DNAs sequences code for exactly the same protein. Your function take the 2 sequences you should compare.\nFor some kind of simplicity here the sequences will respect the following rules:\n\n- It is a full protein sequence beginning with a Start codon and finishing by an Stop codon\n- It will only contain valid tri-nucleotide. \n\nThe translation hash is available for you under a translation hash `$codons` [Ruby] or `codons` [Python and JavaScript].\n\nTo better understand this kata you can take a look at this [one](https://www.codewars.com/kata/5708ef48fe2d018413000776), it can help you to start.\n\"\"\"", "inputs": [["ATGTCGTCAATTTAA", "ATGTCGTCAATTTAA"], ["ATGTTTTAA", "ATGTTCTAA"], ["ATGTTTTAA", "ATGATATAA"], ["ATGTTTGGGAATAATTAAGGGTAA", "ATGTTCGGGAATAATGGGAGGTAA"]], "outputs": [[true], [true], [false], [false]], "starter_code": "def code_for_same_protein(seq1: str, seq2: str) -> bool:", "canonical_solution": "def code_for_same_protein(seq1, seq2):\n    if seq1 == seq2:\n        return True\n    lista = [['GCT', 'GCC', 'GCA', 'GCG'], ['CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'], ['AAT', 'AAC'], ['GAT', 'GAC'], ['AAT', 'AAC', 'GAT', 'GAC'], ['TGT', 'TGC'], ['CAA', 'CAG'], ['GAA', 'GAG'], ['CAA', 'CAG', 'GAA', 'GAG'], ['GGT', 'GGC', 'GGA', 'GGG'], ['CAT', 'CAC'], ['ATG'], ['ATT', 'ATC', 'ATA'], ['CTT', 'CTC', 'CTA', 'CTG', 'TTA', 'TTG'], ['AAA', 'AAG'], ['ATG'], ['TTT', 'TTC'], ['CCT', 'CCC', 'CCA', 'CCG'], ['TCT', 'TCC', 'TCA', 'TCG', 'AGT', 'AGC'], ['ACT', 'ACC', 'ACA', 'ACG'], ['TGG'], ['TAT', 'TAC'], ['GTT', 'GTC', 'GTA', 'GTG'], ['TAA', 'TGA', 'TAG']]\n    for j in range(0, len(lista)):\n        for i in range(0, len(seq1), 3):\n            if seq1[i:i + 3] in lista[j] and seq2[i:i + 3] not in lista[j]:\n                return False\n    return True", "entry_point": "code_for_same_protein", "task_id": "TACO_lite/1762", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG', 'ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG'], ['ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG', 'ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAC'], ['ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG', 'ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG'], ['ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG', 'ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG'], ['ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG', 'ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG']]", "qwen2.5-coder-32b-instruct": "[['ATGTTA', 'ATGTTC'], ['ATGCTGTA', 'ATGGTGTA'], ['ATG', 'ATG'], ['ATGTAAG', 'ATGTAA'], ['ATGTTAATG', 'ATGTTCATG'], ['ATGTTAATGA', 'ATGTTCATGA'], ['ATGTTAATGAAA', 'ATGTTCATGAAA'], ['ATGTTAATGAAAG', 'ATGTTCATGAAAG'], ['ATGTTAATGAAAGGG', 'ATGTTCATGAAAGGG'], ['ATGTTAATGAAAGGGGG', 'ATGTTCATGAAAGGGGG']]"}}
{"requirement": "def solve_runes(runes: str) -> int:\n\"\"\"To give credit where credit is due: This problem was taken from the ACMICPC-Northwest Regional Programming Contest. Thank you problem writers.\n\nYou are helping an archaeologist decipher some runes. He knows that this ancient society used a Base 10 system, and that they never start a number with a leading zero. He's figured out most of the digits as well as a few operators, but he needs your help to figure out the rest.\n\nThe professor will give you a simple math expression, of the form\n\n```\n[number][op][number]=[number]\n```\n\nHe has converted all of the runes he knows into digits. The only operators he knows are addition (`+`),subtraction(`-`), and multiplication (`*`), so those are the only ones that will appear. Each number will be in the range from -1000000 to 1000000, and will consist of only the digits 0-9, possibly a leading -, and maybe a few ?s. If there are ?s in an expression, they represent a digit rune that the professor doesn't know (never an operator, and never a leading -). All of the ?s in an expression will represent the same digit (0-9), and it won't be one of the other given digits in the expression. No number will begin with a 0 unless the number itself is  0, therefore 00 would not be a valid number. \n\nGiven an expression, figure out the value of the rune represented by the question mark. If more than one digit works, give the lowest one. If no digit works, well, that's bad news for the professor - it means that he's got some of his runes wrong. output -1 in that case.\n\nComplete the method to solve the expression to find the value of the unknown rune. The method takes a string as a paramater repressenting the expression and will return an int value representing the unknown rune or -1 if no such rune exists.\n\n~~~if:php\n**Most of the time, the professor will be able to figure out most of the runes himself, but sometimes, there may be exactly 1 rune present in the expression that the professor cannot figure out (resulting in all question marks where the digits are in the expression) so be careful ;)**\n~~~\n\"\"\"", "inputs": [["123?45*?=?"], ["?*123?45=?"], ["??605*-63=-73???5"], ["123?45+?=123?45"], ["?8?170-1?6256=7?2?14"], ["?38???+595???=833444"], ["123?45-?=123?45"], ["-7715?5--484?00=-28?9?5"], ["50685?--1?5630=652?8?"], ["??+??=??"], ["-?56373--9216=-?47157"]], "outputs": [[0], [0], [1], [0], [9], [2], [0], [6], [4], [-1], [8]], "starter_code": "def solve_runes(runes: str) -> int:", "canonical_solution": "import re\n\ndef solve_runes(runes):\n    for d in sorted(set('0123456789') - set(runes)):\n        toTest = runes.replace('?', d)\n        if re.search('([^\\\\d]|\\\\b)0\\\\d+', toTest):\n            continue\n        l, r = toTest.split('=')\n        if eval(l) == eval(r):\n            return int(d)\n    return -1", "entry_point": "solve_runes", "task_id": "TACO_lite/1780", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['1+1=2'], ['123*45?=5?088'], ['-5?*-1=5?'], ['??+??=??'], ['?*8=16'], ['?*?=16'], ['??*1=??'], ['?-1=0'], ['?8?+?2?=???'], ['?0?+?0?=??0'], ['??*??=????'], ['?+?=?'], ['?*?=?'], ['?+?=??'], ['?*?=??'], ['?+?=???'], ['?*?=???'], ['?+?=????'], ['?*?=????'], ['?+?=?????'], ['?*?=?????'], ['?+?=??????'], ['?*?=??????'], ['?+?=???????'], ['?*?=???????'], ['?+?=????????'], ['?*?=????????'], ['?+?=?????????'], ['?*?=?????????'], ['?+?=??????????'], ['?*?=??????????']]", "qwen2.5-coder-32b-instruct": "[['1+1=? '], ['?2+3=5'], ['1?+1?=22'], ['??+??=44'], ['123-?=120'], ['?-?1=8'], ['1?*?=12'], ['??*??=81'], ['10-?=0'], ['?-?=-1'], ['1*?=0'], ['?*?=0'], ['1+?=2'], ['?+?=2'], ['1-?=0'], ['?-?=0'], ['1*?=1'], ['?*?=1'], ['123+?=126'], ['123-?=120'], ['123*?=246'], ['123/?=41'], ['1?+2?=33'], ['1?-2?=33'], ['1?*2?=33'], ['1?/2?=3'], ['123+?=126'], ['123-?=120'], ['123*?=246'], ['123/?=41'], ['123+?=127'], ['123-?=121'], ['123*?=247'], ['123/?=40'], ['????+????=8888'], ['????-????=0'], ['????*????=161051'], ['1000000-?=999999'], ['1000000+?=1000001'], ['1000000*?=0'], ['1000000/?=1'], ['1234567+?=1234568'], ['1234567-?=1234566'], ['1234567*?=0'], ['1234567/?=1'], ['?+?=0'], ['?-?=0'], ['?*?=0'], ['?/?=1'], ['123+?=124'], ['123-?=122']]"}}
{"requirement": "from typing import List\n\n\ndef solve(a: List[int], b: List[int]) -> str:\n\"\"\"Alice and Bob have participated to a Rock Off with their bands. A jury of true metalheads rates the two challenges, awarding points to the bands on a scale from 1 to 50 for three categories: Song Heaviness, Originality, and Members' outfits.\n\nFor each one of these 3 categories they are going to be awarded one point, should they get a better judgement from the jury. No point is awarded in case of an equal vote.\n\nYou are going to receive two arrays, containing first the score of Alice's band and then those of Bob's. Your task is to find their total score by comparing them in a single line. \n\nExample:\n\nAlice's band plays a Nirvana inspired grunge and has been rated \n``20`` for Heaviness, \n``32`` for Originality and only \n``18`` for Outfits.\nBob listens to Slayer and has gotten a good \n``48`` for Heaviness, \n``25`` for Originality and a rather honest \n``40`` for Outfits.\n\nThe total score should be followed by a colon ```:``` and by one of the following quotes:\nif Alice's band wins: ```Alice made \"Kurt\" proud!```\nif Bob's band wins: ```Bob made \"Jeff\" proud!```\nif they end up with a draw: ```that looks like a \"draw\"! Rock on!```\n\nThe solution to the example above should therefore appear like \n``'1, 2: Bob made \"Jeff\" proud!'``.\n\"\"\"", "inputs": [[[47, 7, 2], [47, 7, 2]], [[47, 50, 22], [26, 47, 12]], [[25, 50, 22], [34, 49, 50]], [[8, 8, 11], [3, 8, 10]], [[20, 32, 18], [48, 25, 40]], [[5, 6, 7], [3, 6, 10]], [[21, 39, 15], [50, 1, 12]], [[0, 1, 2], [1, 2, 0]]], "outputs": [["0, 0: that looks like a \"draw\"! Rock on!"], ["3, 0: Alice made \"Kurt\" proud!"], ["1, 2: Bob made \"Jeff\" proud!"], ["2, 0: Alice made \"Kurt\" proud!"], ["1, 2: Bob made \"Jeff\" proud!"], ["1, 1: that looks like a \"draw\"! Rock on!"], ["2, 1: Alice made \"Kurt\" proud!"], ["1, 2: Bob made \"Jeff\" proud!"]], "starter_code": "from typing import List\ndef solve(a: List[int], b: List[int]) -> str:", "canonical_solution": "def solve(a, b):\n    alice = sum((i > j for i, j in zip(a, b)))\n    bob = sum((j > i for i, j in zip(a, b)))\n    if alice == bob:\n        words = 'that looks like a \"draw\"! Rock on!'\n    elif alice > bob:\n        words = 'Alice made \"Kurt\" proud!'\n    else:\n        words = 'Bob made \"Jeff\" proud!'\n    return '{}, {}: {}'.format(alice, bob, words)", "entry_point": "solve", "task_id": "TACO_lite/1784", "input_output_examples": "[[[[20, 32, 18], [48, 25, 40]]], [['1, 2: Bob made \"Jeff\" proud!']]]", "llm_generated_inputs": {"deepseek-v3": "[[[20, 32, 18], [48, 25, 40]], [[30, 30, 30], [30, 30, 30]], [[50, 10, 5], [5, 50, 10]], [[1, 2, 3], [3, 2, 1]], [[10, 20, 30], [20, 30, 10]], [[45, 35, 25], [25, 35, 45]], [[0, 0, 0], [0, 0, 0]], [[50, 50, 50], [50, 50, 50]], [[1, 1, 1], [50, 50, 50]], [[50, 50, 50], [1, 1, 1]]]", "qwen2.5-coder-32b-instruct": "[[[20, 32, 18], [48, 25, 40]], [[30, 30, 30], [30, 30, 30]], [[50, 50, 50], [1, 1, 1]], [[1, 1, 1], [50, 50, 50]], [[25, 25, 25], [24, 24, 24]], [[24, 24, 24], [25, 25, 25]], [[49, 50, 49], [50, 49, 50]], [[20, 20, 20], [20, 20, 21]], [[20, 20, 21], [20, 20, 20]]]"}}
{"requirement": "def increasing_numbers(d: int) -> int:\n\"\"\"An `non decreasing` number is one containing no two consecutive digits (left to right), whose the first is higer than the second. For example, 1235 is an non decreasing number, 1229 is too, but 123429 isn't.\n\nWrite a function that finds the number of non decreasing numbers up to `10**N` (exclusive) where N is the input of your function. For example, if `N=3`, you have to count all non decreasing numbers from 0 to 999.\n\n\n\n You'll definitely need something smarter than brute force for large values of N!\n\"\"\"", "inputs": [[0], [1], [2], [3], [4], [5], [6], [10], [20], [50]], "outputs": [[1], [10], [55], [220], [715], [2002], [5005], [92378], [10015005], [12565671261]], "starter_code": "def increasing_numbers(d: int) -> int:", "canonical_solution": "def increasing_numbers(d):\n    s = 1\n    for i in range(1, 10):\n        s = s * (i + d) // i\n    return s", "entry_point": "increasing_numbers", "task_id": "TACO_lite/1786", "input_output_examples": "[[[3]], [[220]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [4], [5], [0], [-1]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [0]]"}}
{"requirement": "def original_number(s: str) -> str:\n\"\"\"# Task\n\nJohn has an important number, and he doesn't want others to see it.\n\nHe decided to encrypt the number, using the following steps:\n```\nHis number is always a non strict increasing sequence\nie. \"123\"\n\nHe converted each digit into English words.\nie. \"123\"--> \"ONETWOTHREE\"\n\nAnd then, rearrange the letters randomly.\nie. \"ONETWOTHREE\" --> \"TTONWOHREEE\"\n```\n\nJohn felt that his number were safe in doing so. In fact, such encryption can be easily decrypted :(\n\nGiven the encrypted string `s`, your task is to decrypt it, return the original number in string format.\n\nNote, You can assume that the input string `s` is always valid; It contains only uppercase Letters; The decrypted numbers are arranged in ascending order; The leading zeros are allowed.\n\n\n# Example\n\nFor `s = \"ONE\"`, the output should be `1`.\n\nFor `s = \"EON\"`, the output should be `1` too.\n\nFor `s = \"ONETWO\"`, the output should be `12`.\n\nFor `s = \"OONETW\"`, the output should be `12` too.\n\nFor `s = \"ONETWOTHREE\"`, the output should be `123`.\n\nFor `s = \"TTONWOHREEE\"`, the output should be `123` too.\n\"\"\"", "inputs": [["ONE"], ["OEN"], ["ONETWO"], ["OONETW"], ["TTONWOHREEE"]], "outputs": [["1"], ["1"], ["12"], ["12"], ["123"]], "starter_code": "def original_number(s: str) -> str:", "canonical_solution": "from collections import Counter\nEXECUTIONS_ORDER = [('Z', Counter('ZERO'), '0'), ('W', Counter('TWO'), '2'), ('U', Counter('FOUR'), '4'), ('X', Counter('SIX'), '6'), ('G', Counter('EIGHT'), '8'), ('O', Counter('ONE'), '1'), ('H', Counter('THREE'), '3'), ('F', Counter('FIVE'), '5'), ('V', Counter('SEVEN'), '7'), ('I', Counter('NINE'), '9')]\n\ndef original_number(s):\n    ans, count, executions = ([], Counter(s), iter(EXECUTIONS_ORDER))\n    while count:\n        c, wordCount, value = next(executions)\n        ans.extend([value] * count[c])\n        for _ in range(count[c]):\n            count -= wordCount\n    return ''.join(sorted(ans))", "entry_point": "original_number", "task_id": "TACO_lite/1789", "input_output_examples": "[[['ONE'], ['EON'], ['ONETWO'], ['OONETW'], ['ONETWOTHREE'], ['TTONWOHREEE']], [['1'], ['1'], ['12'], ['12'], ['123'], ['123']]]", "llm_generated_inputs": {"deepseek-v3": "[['ONE'], ['EON'], ['ONETWO'], ['OONETW'], ['ONETWOTHREE'], ['TTONWOHREEE'], ['ZERO'], ['OZER'], ['ZEROTWO'], ['TWOZERO'], ['ZEROTWOTHREE'], ['THREETWOZERO'], ['FOURFIVE'], ['FIVEFOUR'], ['ZEROFIVEFOUR'], ['FOURFIVEZERO'], ['ZEROFOURFIVE'], ['SIXSEVENEIGHT'], ['EIGHTSEVENSIX'], ['ZEROSIXSEVENEIGHT'], ['EIGHTSEVENSIXZERO'], ['ZEROEIGHTSEVENSIX'], ['NINE'], ['ENIN'], ['ZERONINE'], ['NINEZERO'], ['ZERONINETWO'], ['TWONINEZERO']]", "qwen2.5-coder-32b-instruct": "[['ONE'], ['EON'], ['ONETWO'], ['OONETW'], ['ONETWOTHREE'], ['TTONWOHREEE'], ['FOURFIVE'], ['UFFORIVNE'], ['NINE'], ['INEN'], ['ZERO'], ['REZO'], ['ZEROTWO'], ['WTOEREZRO'], ['ONETWOFOUR'], ['NOTWOFUOER'], ['THREEEIGHT'], ['EERHTGIEET'], ['SEVENNINE'], ['EVSNNEINE'], ['ONETWOTHREEFOURFIVESIXSEVENEIGHTNINE'], ['EGIHNOFFUONSWVEITXESRNEIIVNETNGIEE']]"}}
{"requirement": "def is_smooth(n: int) -> str:\n\"\"\"The concept of \"[smooth number](https://en.wikipedia.org/wiki/Smooth_number)\" is applied to all those numbers whose prime factors are lesser than or equal to `7`: `60` is a smooth number (`2 * 2 * 3 * 5`), `111` is not (`3 * 37`).\n\nMore specifically, smooth numbers are classified by their highest prime factor and your are tasked with writing a `isSmooth`/`is_smooth` function that returns a string with this classification as it follows:\n\n* 2-smooth numbers should be all defined as a `\"power of 2\"`, as they are merely that;\n* 3-smooth numbers are to return a result of `\"3-smooth\"`;\n* 5-smooth numbers will be labelled as `\"Hamming number\"`s (incidentally, you might appreciate [this nice kata on them](https://www.codewars.com/kata/hamming-numbers));\n* 7-smooth numbers are classified as `\"humble numbers\"`s;\n* for all the other numbers, just return `non-smooth`.\n\nExamples:\n```python\nis_smooth(16) == \"power of 2\"\nis_smooth(36) == \"3-smooth\"\nis_smooth(60) == \"Hamming number\"\nis_smooth(98) == \"humble number\"\nis_smooth(111) == \"non-smooth\"\n```\nThe provided input `n` is always going to be a positive number `> 1`.\n\"\"\"", "inputs": [[16], [36], [60], [98], [111], [4096], [729], [3125], [7], [17]], "outputs": [["power of 2"], ["3-smooth"], ["Hamming number"], ["humble number"], ["non-smooth"], ["power of 2"], ["3-smooth"], ["Hamming number"], ["humble number"], ["non-smooth"]], "starter_code": "def is_smooth(n: int) -> str:", "canonical_solution": "def is_smooth(n):\n    for x in [2, 3, 5, 7]:\n        while n % x == 0:\n            n //= x\n        if n == 1:\n            return ('power of 2', '3-smooth', 'Hamming number', 'humble number')[(2 < x) + (3 < x) + (5 < x)]\n    return 'non-smooth'", "entry_point": "is_smooth", "task_id": "TACO_lite/1792", "input_output_examples": "[[[16], [36], [60], [98], [111]], [['power of 2'], ['3-smooth'], ['Hamming number'], ['humble number'], ['non-smooth']]]", "llm_generated_inputs": {"deepseek-v3": "[[16], [36], [60], [98], [111], [2], [3], [5], [7], [1], [49], [25], [37], [210], [1024], [100]]", "qwen2.5-coder-32b-instruct": "[[16], [36], [60], [98], [111], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [14], [21], [28], [30], [42], [49], [50], [63], [70], [72], [84], [100], [128], [256], [512], [1024], [4096], [8192], [16384], [32768], [65536], [131072], [262144], [524288], [1048576], [2097152], [4194304], [8388608], [16777216], [33554432], [67108864], [134217728], [268435456], [536870912], [1073741824], [2147483648]]"}}
{"requirement": "def calculate_age(year_of_birth: int, current_year: int) -> str:\n\"\"\"Philip's just turned four and he wants to know how old he will be in various years in the future such as 2090 or 3044. His parents can't keep up calculating this so they've begged you to help them out by writing a programme that can answer Philip's endless questions.\n\nYour task is to write a function that takes two parameters: the year of birth and the year to count years in relation to. As Philip is getting more curious every day he may soon want to know how many years it was until he would be born, so your function needs to work with both dates in the future and in the past.\n\nProvide output in this format: For dates in the future: \"You are ... year(s) old.\" For dates in the past: \"You will be born in ... year(s).\" If the year of birth equals the year requested return: \"You were born this very year!\"\n\n\"...\" are to be replaced by the number, followed and proceeded by a single space. Mind that you need to account for both \"year\" and \"years\", depending on the result.\n\nGood Luck!\n\"\"\"", "inputs": [[2012, 2016], [1989, 2016], [2000, 2090], [2000, 1990], [2000, 2000], [900, 2900], [2010, 1990], [2010, 1500], [2011, 2012], [2000, 1999]], "outputs": [["You are 4 years old."], ["You are 27 years old."], ["You are 90 years old."], ["You will be born in 10 years."], ["You were born this very year!"], ["You are 2000 years old."], ["You will be born in 20 years."], ["You will be born in 510 years."], ["You are 1 year old."], ["You will be born in 1 year."]], "starter_code": "def calculate_age(year_of_birth: int, current_year: int) -> str:", "canonical_solution": "def calculate_age(year_of_birth, current_year):\n    diff = abs(current_year - year_of_birth)\n    plural = '' if diff == 1 else 's'\n    if year_of_birth < current_year:\n        return 'You are {} year{} old.'.format(diff, plural)\n    elif year_of_birth > current_year:\n        return 'You will be born in {} year{}.'.format(diff, plural)\n    return 'You were born this very year!'", "entry_point": "calculate_age", "task_id": "TACO_lite/1796", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[2020, 2023], [2020, 2020], [2020, 2018], [2020, 2090], [2020, 3044], [2020, 2021], [2020, 2019], [2020, 2030], [2020, 2000], [2020, 2022]]", "qwen2.5-coder-32b-instruct": "[[2018, 2022], [2022, 2018], [2022, 2022], [2000, 2025], [2005, 1995], [1990, 1990], [2023, 2024], [2023, 2023], [2025, 2025], [2021, 2020]]"}}
{"requirement": "def basic_op(operator: str, value1: float, value2: float) -> float:\n\"\"\"Your task is to create a function that does four basic mathematical operations.\n\nThe function should take three arguments - operation(string/char), value1(number), value2(number).  \nThe function should return result of numbers after applying the chosen operation.\n\n### Examples\n\n```python\nbasic_op('+', 4, 7)         # Output: 11\nbasic_op('-', 15, 18)       # Output: -3\nbasic_op('*', 5, 5)         # Output: 25\nbasic_op('/', 49, 7)        # Output: 7\n```\n\"\"\"", "inputs": [["+", 4, 7], ["-", 15, 18], ["*", 5, 5], ["/", 49, 7]], "outputs": [[11], [-3], [25], [7]], "starter_code": "def basic_op(operator: str, value1: float, value2: float) -> float:", "canonical_solution": "def basic_op(operator, value1, value2):\n    if operator == '+':\n        return value1 + value2\n    if operator == '-':\n        return value1 - value2\n    if operator == '/':\n        return value1 / value2\n    if operator == '*':\n        return value1 * value2", "entry_point": "basic_op", "task_id": "TACO_lite/1802", "input_output_examples": "[[['+', 4, 7], ['-', 15, 18], ['*', 5, 5], ['/', 49, 7]], [[11], [-3], [25], [7]]]", "llm_generated_inputs": {"deepseek-v3": "[['+', 4, 7], ['-', 15, 18], ['*', 5, 5], ['/', 49, 7], ['+', 0, 0], ['-', 0, 10], ['*', 0, 10], ['/', 0, 10], ['/', 10, 0], ['*', -5, 5], ['-', -5, -5], ['/', -10, 2], ['&', 4, 7], ['', 4, 7]]", "qwen2.5-coder-32b-instruct": "[['+', 4, 7], ['-', 15, 18], ['*', 5, 5], ['/', 49, 7], ['+', 0, 0], ['-', 0, 0], ['*', 0, 0], ['/', 0, 1], ['+', -1, -1], ['-', -1, -1], ['*', -1, -1], ['/', 1, -1], ['+', 1.5, 2.5], ['-', 1.5, 2.5], ['*', 1.5, 2.5], ['/', 3.5, 1.5], ['/', 1, 0], ['^', 2, 3], ['%', 10, 3]]"}}
{"requirement": "from typing import List\n\n\ndef group(arr: List[int]) -> List[List[int]]:\n\"\"\"Sam is an avid collector of numbers. Every time he finds a new number he throws it on the top of his number-pile. Help Sam organise his collection so he can take it to the International Number Collectors Conference in Cologne. \n\nGiven an array of numbers, your function should return an array of arrays, where each subarray contains all the duplicates of a particular number. Subarrays should be in the same order as the first occurence of the number they contain:\nAssume the input is always going to be an array of numbers. If the input is an empty array, an empty array should be returned.\n\"\"\"", "inputs": [[[3, 2, 6, 2, 1, 3]], [[3, 2, 6, 2]], [[]], [[1, 100, 4, 2, 4]], [[-1, 1, -1]]], "outputs": [[[[3, 3], [2, 2], [6], [1]]], [[[3], [2, 2], [6]]], [[]], [[[1], [100], [4, 4], [2]]], [[[-1, -1], [1]]]], "starter_code": "from typing import List\ndef group(arr: List[int]) -> List[List[int]]:", "canonical_solution": "group = lambda arr: [[n] * arr.count(n) for n in sorted(set(arr), key=arr.index)]", "entry_point": "group", "task_id": "TACO_lite/1806", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 5]], [[1, 1, 2, 2, 3, 3, 4, 4, 5, 5]], [[5, 5, 4, 4, 3, 3, 2, 2, 1, 1]], [[1, 1, 1, 2, 2, 3, 3, 3, 3]], [[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]], [[]], [[1]], [[1, 1, 1, 1, 1]], [[2, 1, 2, 1, 2, 1, 2, 1]], [[3, 3, 1, 1, 2, 2, 4, 4]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 2, 4, 1, 5]], [[10, 10, 10, 20, 20, 30]], [[7, 8, 9]], [[]], [[5, 5, 5, 5, 5]], [[1, 1, 2, 2, 3, 3, 4, 4, 5, 5]]]"}}
{"requirement": "from typing import List\n\n\ndef digitize(n: int) -> List[int]:\n\"\"\"Given a non-negative integer, return an array / a list of the individual digits in order.\n\nExamples:\n\n```\n123 => [1,2,3]\n\n1 => [1]\n\n8675309 => [8,6,7,5,3,0,9]\n```\n\"\"\"", "inputs": [[123], [1], [0], [1230], [8675309]], "outputs": [[[1, 2, 3]], [[1]], [[0]], [[1, 2, 3, 0]], [[8, 6, 7, 5, 3, 0, 9]]], "starter_code": "from typing import List\ndef digitize(n: int) -> List[int]:", "canonical_solution": "def digitize(n):\n    return [int(d) for d in str(n)]", "entry_point": "digitize", "task_id": "TACO_lite/1814", "input_output_examples": "[[[123], [1], [8675309]], [[[1, 2, 3]], [[1]], [[8, 6, 7, 5, 3, 0, 9]]]]", "llm_generated_inputs": {"deepseek-v3": "[[123], [1], [0], [8675309], [1000000], [999999], [123456789], [10]]", "qwen2.5-coder-32b-instruct": "[[123], [1], [8675309], [0], [9876543210]]"}}
{"requirement": "def greet(name: str) -> str:\n\"\"\"Write a method that takes one argument as name and then greets that name, capitalized and ends with an exclamation point.\n\nExample:\n\n```\n\"riley\" --> \"Hello Riley!\"\n\"JACK\"  --> \"Hello Jack!\"\n```\n\"\"\"", "inputs": [["riley"], ["molly"], ["BILLY"]], "outputs": [["Hello Riley!"], ["Hello Molly!"], ["Hello Billy!"]], "starter_code": "def greet(name: str) -> str:", "canonical_solution": "def greet(name):\n    return f'Hello {name.title()}!'", "entry_point": "greet", "task_id": "TACO_lite/1818", "input_output_examples": "[[['riley'], ['JACK']], [['Hello Riley!'], ['Hello Jack!']]]", "llm_generated_inputs": {"deepseek-v3": "[['riley'], ['JACK'], ['alice'], ['BOB'], ['mArY'], ['a'], ['123'], [''], ['john doe'], ['   john   ']]", "qwen2.5-coder-32b-instruct": "[['riley'], ['JACK'], ['chris'], ['sally'], ['BOB'], ['123'], [''], ['a'], ['A'], ['longnamefortesting']]"}}
{"requirement": "def to_freud(sentence: str) -> str:\n\"\"\"You probably know the 42 number as \"The answer to life, the universe and everything\" according to Douglas Adams' \"The Hitchhiker's Guide to the Galaxy\". For Freud, the answer was quite different.\n\nIn the society he lived in, people-women in particular- had to repress their sexual needs and desires. This was simply how the society was at the time. \nFreud then wanted to study the illnesses created by this, and so he digged to the root of their desires. This led to some of the most important psychoanalytic theories to this day, Freud being the father of psychoanalysis.\n\nNow, basically, when a person hears about Freud, s/he hears \"sex\" because for Freud, everything was basically related to, and explained by sex. \n\nIn this kata, the toFreud() function will take a string as its argument, and return a string with every word replaced by the explanation to everything, according to Freud. Note that an empty string, or no arguments, should result in the ouput being \"\"(empty string).\n\"\"\"", "inputs": [["test"], ["sexy sex"], ["This is a test"], ["This is a longer test"], ["You're becoming a true freudian expert"]], "outputs": [["sex"], ["sex sex"], ["sex sex sex sex"], ["sex sex sex sex sex"], ["sex sex sex sex sex sex"]], "starter_code": "def to_freud(sentence: str) -> str:", "canonical_solution": "def to_freud(sentence):\n    return ' '.join(('sex' for _ in sentence.split()))", "entry_point": "to_freud", "task_id": "TACO_lite/1821", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[['hello world'], ['Freud was a genius'], ['This is a test sentence'], ['   '], [''], ['one'], ['multiple    spaces'], ['123 456 789'], ['!@# $%^ &*()']]", "qwen2.5-coder-32b-instruct": "[['This is a test sentence'], ['Sex is the answer'], [''], ['Psychoanalysis'], ['Everything is related to sex'], [' '], ['Freud']]"}}
{"requirement": "def unlock(message: str) -> str:\n\"\"\"Introduction \n\nMr. Safety loves numeric locks and his Nokia 3310. He locked almost everything in his house. He is so smart and he doesn't need to remember the combinations. He has an algorithm to generate new passcodes on his Nokia cell phone. \n\n\n Task \n\nCan you crack his numeric locks? Mr. Safety's treasures wait for you. Write an algorithm to open his numeric locks. Can you do it without his Nokia 3310? \n\nInput \n\nThe `str` or `message` (Python) input string consists of lowercase and upercase characters. It's a real object that you want to unlock.\n\nOutput \nReturn a string that only consists of digits.\n\nExample\n```\nunlock(\"Nokia\")  // => 66542\nunlock(\"Valut\")  // => 82588\nunlock(\"toilet\") // => 864538\n```\n\"\"\"", "inputs": [["Nokia"], ["Valut"], ["toilet"], ["waterheater"], ["birdhouse"]], "outputs": [["66542"], ["82588"], ["864538"], ["92837432837"], ["247346873"]], "starter_code": "def unlock(message: str) -> str:", "canonical_solution": "def unlock(message):\n    return message.lower().translate(message.maketrans('abcdefghijklmnopqrstuvwxyz', '22233344455566677778889999'))", "entry_point": "unlock", "task_id": "TACO_lite/1824", "input_output_examples": "[[['Nokia'], ['Valut'], ['toilet']], [[66542], [82588], [864538]]]", "llm_generated_inputs": {"deepseek-v3": "[['Nokia'], ['Valut'], ['toilet'], ['HelloWorld'], ['123abc'], ['!@#$%^&*()'], [''], ['a'], ['A'], ['AaBbCc'], ['Nokia3310'], ['MrSafety'], ['Python3.9'], ['lowercase'], ['UPPERCASE'], ['MixedCase123']]", "qwen2.5-coder-32b-instruct": "[['Nokia'], ['Valut'], ['toilet'], ['a'], ['Z'], ['abcXYZ'], ['123'], [''], ['Safety'], ['treasures']]"}}
{"requirement": "def check_challenge(pledged: int, current: int, month: str) -> str:\n\"\"\"Given the number pledged for a year, current value and name of the month, return string that gives information about the challenge status:\n\n- ahead of schedule\n- behind schedule\n- on track\n- challenge is completed\n\nExamples:\n\n`(12, 1, \"February\")` - should return `\"You are on track.\"`\n\n`(12, 1, \"March\")` - should return `\"You are 1 behind schedule.\"`\n\n`(12, 5, \"March\")` - should return `\"You are 3 ahead of schedule.\"`\n\n`(12, 12, \"September\")` - should return `\"Challenge is completed.\"`\n\nDetails:\n- you do not need to do any prechecks (input will always be a natural number and correct name of the month)\n- months should be as even as possible (i.e. for 100 items: January, February, March and April - 9, other months 8)\n- count only the item for completed months (i.e. for March check the values from January and February) and it means that for January you should always return `\"You are on track.\"`.\n\n\n\"\"\"", "inputs": [[12, 5, "January"], [12, 1, "February"], [12, 1, "March"], [12, 12, "September"], [12, 5, "March"], [100, 5, "March"], [100, 52, "July"], [100, 51, "July"], [100, 53, "July"]], "outputs": [["You are on track."], ["You are on track."], ["You are 1 behind schedule."], ["Challenge is completed."], ["You are 3 ahead of schedule!"], ["You are 13 behind schedule."], ["You are on track."], ["You are 1 behind schedule."], ["You are 1 ahead of schedule!"]], "starter_code": "def check_challenge(pledged: int, current: int, month: str) -> str:", "canonical_solution": "import calendar\nM = {calendar.month_name[i]: i - 1 for i in range(1, 13)}\n\ndef check_challenge(pledged, current, month):\n    if pledged == current:\n        return 'Challenge is completed.'\n    m = M[month]\n    per_month, rest = divmod(pledged, 12)\n    todo = per_month * m + min(rest, m)\n    delta = current - todo\n    if delta == 0 or m == 0:\n        return 'You are on track.'\n    elif delta > 0:\n        return f'You are {delta} ahead of schedule!'\n    else:\n        return f'You are {-delta} behind schedule.'", "entry_point": "check_challenge", "task_id": "TACO_lite/1830", "input_output_examples": "[[[[12, 1, 'February']], [[12, 1, 'March']], [[12, 5, 'March']], [[12, 12, 'September']]], [['You are on track.'], ['You are 1 behind schedule.'], ['You are 3 ahead of schedule.'], ['Challenge is completed.']]]", "llm_generated_inputs": {"deepseek-v3": "[[12, 1, 'January'], [12, 1, 'February'], [12, 1, 'March'], [12, 3, 'March'], [12, 5, 'March'], [12, 12, 'September'], [100, 9, 'January'], [100, 17, 'February'], [100, 25, 'March'], [100, 33, 'April'], [100, 41, 'May'], [100, 49, 'June'], [100, 57, 'July'], [100, 65, 'August'], [100, 73, 'September'], [100, 81, 'October'], [100, 89, 'November'], [100, 100, 'December'], [100, 110, 'December'], [100, 50, 'June'], [100, 60, 'July'], [100, 70, 'August']]", "qwen2.5-coder-32b-instruct": "[[12, 1, 'February'], [12, 1, 'March'], [12, 5, 'March'], [12, 12, 'September'], [12, 0, 'January'], [12, 6, 'June'], [12, 12, 'December'], [100, 9, 'April'], [100, 40, 'May'], [100, 80, 'August'], [100, 90, 'October'], [100, 100, 'December'], [100, 72, 'December'], [100, 27, 'March']]"}}
{"requirement": "def to_alternating_case(string: str) -> str:\n\"\"\"# altERnaTIng cAsE <=> ALTerNAtiNG CaSe\n\nDefine `String.prototype.toAlternatingCase` (or a similar function/method *such as* `to_alternating_case`/`toAlternatingCase`/`ToAlternatingCase` in your selected language; **see the initial solution for details**) such that each lowercase letter becomes uppercase and each uppercase letter becomes lowercase. For example:\n``` haskell\ntoAlternatingCase \"hello world\" `shouldBe` \"HELLO WORLD\"\ntoAlternatingCase \"HELLO WORLD\" `shouldBe` \"hello world\"\ntoAlternatingCase \"hello WORLD\" `shouldBe` \"HELLO world\"\ntoAlternatingCase \"HeLLo WoRLD\" `shouldBe` \"hEllO wOrld\"\ntoAlternatingCase \"12345\"       `shouldBe` \"12345\"\ntoAlternatingCase \"1a2b3c4d5e\"  `shouldBe` \"1A2B3C4D5E\"\n```\n```C++\nstring source = \"HeLLo WoRLD\";\nstring upperCase = to_alternating_case(source);\ncout << upperCase << endl; // outputs: hEllO wOrld\n```\nAs usual, your function/method should be pure, i.e. it should **not** mutate the original string.\n\"\"\"", "inputs": [["hello world"], ["HELLO WORLD"], ["hello WORLD"], ["HeLLo WoRLD"], ["12345"], ["1a2b3c4d5e"], ["String.prototype.toAlternatingCase"]], "outputs": [["HELLO WORLD"], ["hello world"], ["HELLO world"], ["hEllO wOrld"], ["12345"], ["1A2B3C4D5E"], ["sTRING.PROTOTYPE.TOaLTERNATINGcASE"]], "starter_code": "def to_alternating_case(string: str) -> str:", "canonical_solution": "def to_alternating_case(string):\n    return string.swapcase()", "entry_point": "to_alternating_case", "task_id": "TACO_lite/1835", "input_output_examples": "[[['hello world'], ['HELLO WORLD'], ['hello WORLD'], ['HeLLo WoRLD'], ['12345'], ['1a2b3c4d5e']], [['HELLO WORLD'], ['hello world'], ['HELLO world'], ['hEllO wOrld'], ['12345'], ['1A2B3C4D5E']]]", "llm_generated_inputs": {"deepseek-v3": "[['hello world'], ['HELLO WORLD'], ['hello WORLD'], ['HeLLo WoRLD'], ['12345'], ['1a2b3c4d5e'], [''], ['a'], ['A'], ['!@#$%^&*()'], ['Hello, World! 123'], ['hElLo wOrLd'], ['123abcDEF'], ['AaAaAa'], ['zZzZzZ']]", "qwen2.5-coder-32b-instruct": "[['hello world'], ['HELLO WORLD'], ['hello WORLD'], ['HeLLo WoRLD'], ['12345'], ['1a2b3c4d5e'], [''], ['aBcDeFgHiJ'], ['PYTHON'], ['python'], ['123abcXYZ'], ['s123 ABC xyz!']]"}}
{"requirement": "def single_digit(n: int) -> int:\n\"\"\"The goal of this Kata is to reduce the passed integer to a single digit (if not already) by converting the number to binary, taking the sum of the binary digits, and if that sum is not a single digit then repeat the process.\n\n- n will be an integer such that 0 < n < 10^20\n- If the passed integer is already a single digit there is no need to reduce\n\nFor example given 5665 the function should return 5:\n\n```\n5665 --> (binary) 1011000100001\n1011000100001 --> (sum of binary digits) 5\n```\n\n\nGiven 123456789 the function should return 1:\n\n```\n123456789 --> (binary) 111010110111100110100010101\n111010110111100110100010101 --> (sum of binary digits) 16\n16 --> (binary) 10000\n10000 --> (sum of binary digits) 1\n```\n\"\"\"", "inputs": [[5], [999], [1234444123], [443566], [565656565], [9889345778311094737448], [4868872], [234234235], [567448], [10000000000]], "outputs": [[5], [8], [1], [2], [3], [2], [8], [2], [7], [3]], "starter_code": "def single_digit(n: int) -> int:", "canonical_solution": "def single_digit(n):\n    while n > 9:\n        n = bin(n).count('1')\n    return n", "entry_point": "single_digit", "task_id": "TACO_lite/1837", "input_output_examples": "[[[5665], [123456789]], [[5], [1]]]", "llm_generated_inputs": {"deepseek-v3": "[[5665], [123456789], [9], [10], [99999999999999999999], [1], [2], [1023], [100000000000000000000], [11111111111111111111]]", "qwen2.5-coder-32b-instruct": "[[5], [123456789], [5665], [1], [9], [10], [1023], [104729], [9999999999999999999]]"}}
{"requirement": "from typing import List\n\n\ndef number_of_pairs(gloves: List[str]) -> int:\n\"\"\"Pair of gloves\n=============\n\nWinter is coming, you must prepare your ski holidays. The objective of this kata is to determine the number of pair of gloves you can constitute from the gloves you have in your drawer.\n\nA pair of gloves is constituted of two gloves of the same color.\n\nYou are given an array containing the color of each glove.\n\nYou must return the number of pair you can constitute.\n\nYou must not change the input array.\n\nExample :\n```python\nmy_gloves = [\"red\",\"green\",\"red\",\"blue\",\"blue\"]\nnumber_of_pairs(my_gloves) == 2;// red and blue\n\nred_gloves = [\"red\",\"red\",\"red\",\"red\",\"red\",\"red\"];\nnumber_of_pairs(red_gloves) == 3; // 3 red pairs\n```\n\"\"\"", "inputs": [[["red", "red"]], [["red", "green", "blue"]], [["gray", "black", "purple", "purple", "gray", "black"]], [[]], [["red", "green", "blue", "blue", "red", "green", "red", "red", "red"]]], "outputs": [[1], [0], [3], [0], [4]], "starter_code": "from typing import List\ndef number_of_pairs(gloves: List[str]) -> int:", "canonical_solution": "from collections import Counter\n\ndef number_of_pairs(gloves):\n    return sum((c // 2 for c in Counter(gloves).values()))", "entry_point": "number_of_pairs", "task_id": "TACO_lite/1842", "input_output_examples": "[[[['red', 'green', 'red', 'blue', 'blue']], [['red', 'red', 'red', 'red', 'red', 'red']]], [[2], [3]]]", "llm_generated_inputs": {"deepseek-v3": "[[['red', 'green', 'red', 'blue', 'blue']], [['red', 'red', 'red', 'red', 'red', 'red']], [['black', 'white', 'black', 'black', 'white', 'black']], [[]], [['yellow']], [['purple', 'purple', 'purple', 'purple', 'purple', 'purple', 'purple']], [['green', 'blue', 'green', 'blue', 'green', 'blue', 'green']], [['orange', 'orange', 'pink', 'pink', 'orange', 'pink', 'orange', 'pink']]]", "qwen2.5-coder-32b-instruct": "[[['red', 'green', 'red', 'blue', 'blue']], [['red', 'red', 'red', 'red', 'red', 'red']], [['yellow', 'yellow', 'yellow']], [['orange']], [[]], [['purple', 'purple', 'pink', 'pink', 'pink', 'pink']], [['black', 'white', 'black', 'white', 'black', 'white', 'black']], [['grey', 'grey', 'grey', 'grey', 'grey', 'grey', 'grey', 'grey']]]"}}
{"requirement": "from typing import List\n\n\ndef paul(x: List[str]) -> str:\n\"\"\"Paul is an excellent coder and sits high on the CW leaderboard. He solves kata like a banshee but would also like to lead a normal life, with other activities. But he just can't stop solving all the kata!!\n\nGiven an array (x) you need to calculate the Paul Misery Score. The values are worth the following points:\n\nkata = 5\nPetes kata = 10\nlife = 0\neating = 1\n\nThe Misery Score is the total points gained from the array. Once you have the total, return as follows:\n\n<40        = 'Super happy!'<70   >=40 = 'Happy!'<100  >=70 = 'Sad!'\\>=100       = 'Miserable!'\n\"\"\"", "inputs": [[["life", "eating", "life"]], [["life", "Petes kata", "Petes kata", "Petes kata", "eating"]], [["Petes kata", "Petes kata", "eating", "Petes kata", "Petes kata", "eating"]]], "outputs": [["Super happy!"], ["Super happy!"], ["Happy!"]], "starter_code": "from typing import List\ndef paul(x: List[str]) -> str:", "canonical_solution": "def paul(x):\n    points = {'life': 0, 'eating': 1, 'kata': 5, 'Petes kata': 10}\n    misery = sum(map(points.get, x))\n    return ['Miserable!', 'Sad!', 'Happy!', 'Super happy!'][(misery < 40) + (misery < 70) + (misery < 100)]", "entry_point": "paul", "task_id": "TACO_lite/1845", "input_output_examples": "[[[['kata', 'life', 'Petes kata', 'eating', 'eating']], [['kata', 'kata', 'Petes kata', 'kata', 'life', 'life', 'eating']], [['kata', 'Petes kata', 'Petes kata', 'eating', 'eating', 'eating', 'eating']], [['life', 'eating', 'eating', 'eating', 'eating', 'eating', 'life', 'life', 'life']]], [['Happy!'], ['Sad!'], ['Miserable!'], ['Super happy!']]]", "llm_generated_inputs": {"deepseek-v3": "[[['kata', 'Petes kata', 'life', 'eating']], [['kata', 'kata', 'kata', 'kata']], [['Petes kata', 'Petes kata', 'Petes kata']], [['life', 'life', 'life']], [['eating', 'eating', 'eating', 'eating', 'eating']], [['kata', 'life', 'eating']], [['Petes kata', 'eating']], [[]], [['kata', 'Petes kata', 'kata', 'Petes kata', 'kata', 'Petes kata', 'kata', 'Petes kata']], [['eating', 'life', 'eating', 'life', 'eating', 'life']]]", "qwen2.5-coder-32b-instruct": "[[['kata', 'kata', 'eating', 'life']], [['Petes kata', 'Petes kata', 'Petes kata', 'Petes kata']], [['kata', 'Petes kata', 'eating', 'life', 'life']], [['eating', 'eating', 'eating', 'eating', 'eating']], [['kata', 'kata', 'kata', 'kata', 'kata', 'kata', 'kata', 'kata', 'kata', 'kata']], [['Petes kata', 'Petes kata', 'Petes kata', 'Petes kata', 'Petes kata', 'Petes kata', 'Petes kata', 'Petes kata', 'Petes kata', 'Petes kata']], [['life', 'life', 'life', 'life', 'life', 'life', 'life', 'life', 'life', 'life']], [[]], [['kata', 'Petes kata', 'eating', 'life', 'kata', 'Petes kata', 'eating', 'life', 'kata', 'Petes kata', 'eating', 'life', 'kata', 'Petes kata', 'eating', 'life']]]"}}
{"requirement": "from typing import Union\n\n\ndef union_jack(n: Union[int, float]) -> Union[str, bool]:\n\"\"\"Your aged grandfather is tragically optimistic about Team GB's chances in the upcoming World Cup, and has enlisted you to help him make [Union Jack](https://en.wikipedia.org/wiki/Union_Jack) flags to decorate his house with. \n\n## Instructions\n* Write a function which takes as a parameter a number which represents the dimensions of the flag. The flags will always be square, so the number 9 means you should make a flag measuring 9x9.\n* It should return a *string* of the flag, with _'X' for the red/white lines and '-' for the blue background_. It should include newline characters so that it's not all on one line.\n* For the sake of symmetry, treat odd and even numbers differently: odd number flags should have a central cross that is *only one 'X' thick*. Even number flags should have a central cross that is *two 'X's thick* (see examples below).\n\n## Other points\n* The smallest flag you can make without it looking silly is 7x7. If you get a number smaller than 7, simply _make the flag 7x7_.\n* If you get a decimal, round it _UP to the next whole number_, e.g. 12.45 would mean making a flag that is 13x13.\n* If you get something that's not a number at all, *return false*.\n\nTranslations and comments (and upvotes) welcome! \n\n![alt](http://i.imgur.com/1612YR3.jpg?1)\n\n## Examples:\n```python\nunion_jack(9) # (9 is odd, so the central cross is 1'X' thick)\n\"X---X---X\n-X--X--X-\n--X-X-X--\n---XXX---\nXXXXXXXXX\n---XXX---\n--X-X-X--\n-X--X--X-\nX---X---X\"\n\nunion_jack(10) # (10 is even, so the central cross is 2 'X's thick)\n'X---XX---X\n-X--XX--X-\n--X-XX-X--\n---XXXX---\nXXXXXXXXXX\nXXXXXXXXXX\n---XXXX---\n--X-XX-X--\n-X--XX--X-\nX---XX---X\n\nunion_jack(1) # (the smallest possible flag is 7x7)\n\"X--X--X\n-X-X-X-\n--XXX--\nXXXXXXX\n--XXX--\n-X-X-X-\nX--X--X\"\n\nunion_jack('string') #return false.\n```\n\"\"\"", "inputs": [[4.5], [7.1], [19.00384]], "outputs": [["X--X--X\n-X-X-X-\n--XXX--\nXXXXXXX\n--XXX--\n-X-X-X-\nX--X--X"], ["X--XX--X\n-X-XX-X-\n--XXXX--\nXXXXXXXX\nXXXXXXXX\n--XXXX--\n-X-XX-X-\nX--XX--X"], ["X--------XX--------X\n-X-------XX-------X-\n--X------XX------X--\n---X-----XX-----X---\n----X----XX----X----\n-----X---XX---X-----\n------X--XX--X------\n-------X-XX-X-------\n--------XXXX--------\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\n--------XXXX--------\n-------X-XX-X-------\n------X--XX--X------\n-----X---XX---X-----\n----X----XX----X----\n---X-----XX-----X---\n--X------XX------X--\n-X-------XX-------X-\nX--------XX--------X"]], "starter_code": "from typing import Union\ndef union_jack(n: Union[int, float]) -> Union[str, bool]:", "canonical_solution": "from math import ceil\n\ndef union_jack(n):\n    if not isinstance(n, (int, float)):\n        return False\n    n = max(7, ceil(n))\n    h, m = divmod(n - 1, 2)\n    flag = [['X' if len({i, n - j - 1, j, h, h + m}) < 4 + m else '-' for i in range(n)] for j in range(n)]\n    return '\\n'.join((''.join(row) for row in flag))", "entry_point": "union_jack", "task_id": "TACO_lite/1850", "input_output_examples": "[[[9], [10], [1], ['string']], [['X---X---X\\n-X--X--X-\\n--X-X-X--\\n---XXX---\\nXXXXXXXXX\\n---XXX---\\n--X-X-X--\\n-X--X--X-\\nX---X---X'], ['X---XX---X\\n-X--XX--X-\\n--X-XX-X--\\n---XXXX---\\nXXXXXXXXXX\\nXXXXXXXXXX\\n---XXXX---\\n--X-XX-X--\\n-X--XX--X-\\nX---XX---X'], ['X--X--X\\n-X-X-X-\\n--XXX--\\nXXXXXXX\\n--XXX--\\n-X-X-X-\\nX--X--X'], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[[9], [10], [7], [6.2], [12.45], [1], ['string'], [-5], [0], [True], [None]]", "qwen2.5-coder-32b-instruct": "[[9], [10], [1], [12.45], [7], [8], [6.99], [0], [-5], [7.0], ['string'], [None], [[]], [{}]]"}}
{"requirement": "def amicable_numbers(n1: int, n2: int) -> bool:\n\"\"\"Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number. (A proper divisor of a number is a positive factor of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, and 3.) \n\nFor example, the smallest pair of amicable numbers is (220, 284); for the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110, of which the sum is 284; and the proper divisors of 284 are 1, 2, 4, 71 and 142, of which the sum is 220.\n\nDerive function ```amicableNumbers(num1, num2)``` which returns ```true/True``` if pair ```num1 num2``` are amicable, ```false/False``` if not.\n\nSee more at https://en.wikipedia.org/wiki/Amicable_numbers\n\"\"\"", "inputs": [[220, 284], [220, 280], [1184, 1210], [220221, 282224], [10744, 10856], [299920, 9284], [999220, 2849], [122265, 139815]], "outputs": [[true], [false], [true], [false], [true], [false], [false], [true]], "starter_code": "def amicable_numbers(n1: int, n2: int) -> bool:", "canonical_solution": "def getDivs(n):\n    return {1} | {y for x in range(2, int(n ** 0.5) + 1) for y in [n // x, x] if not n % x}\n\ndef amicable_numbers(n1, n2):\n    return sum(getDivs(n1)) == n2 and sum(getDivs(n2)) == n1", "entry_point": "amicable_numbers", "task_id": "TACO_lite/1856", "input_output_examples": "[[[220, 284]], [[True]]]", "llm_generated_inputs": {"deepseek-v3": "[[220, 284], [1184, 1210], [6, 6], [12, 16], [1, 2], [0, 0], [-220, -284], [220, 285], [284, 220], [100, 200]]", "qwen2.5-coder-32b-instruct": "[[220, 284], [1184, 1210], [2620, 2924], [5020, 5564], [6232, 6368], [10, 20], [1, 1], [0, 0], [-1, -1], [220, 220], [284, 220]]"}}
{"requirement": "def string_letter_count(s: str) -> str:\n\"\"\"Take an input string and return a string that is made up of the number of occurences of each english letter in the input followed by that letter, sorted alphabetically. The output string shouldn't contain chars missing from input (chars with 0 occurence); leave them out.\n\n\n\nAn empty string, or one with no letters, should return an empty string.\n\nNotes:\n\n* the input will always be valid;\n* treat letters as **case-insensitive**\n\n\n## Examples\n\n```\n\"This is a test sentence.\"  ==>  \"1a1c4e1h2i2n4s4t\"\n\"\"                          ==>  \"\"\n\"555\"                       ==>  \"\"\n```\n\"\"\"", "inputs": [["The quick brown fox jumps over the lazy dog."], ["The time you enjoy wasting is not wasted time."], ["./4592#{}()"], ["This%Sentence\"is$$being^tested."], ["abccdefgdhijklmno_pqrsTuvwxYz"], [""], ["."], ["y"]], "outputs": [["1a1b1c1d3e1f1g2h1i1j1k1l1m1n4o1p1q2r1s2t2u1v1w1x1y1z"], ["2a1d5e1g1h4i1j2m3n3o3s6t1u2w2y"], [""], ["1b1c1d6e1g1h3i3n4s4t"], ["1a1b2c2d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z"], [""], [""], ["1y"]], "starter_code": "def string_letter_count(s: str) -> str:", "canonical_solution": "from collections import Counter\n\ndef string_letter_count(s):\n    cnt = Counter((c for c in s.lower() if c.isalpha()))\n    return ''.join((str(n) + c for c, n in sorted(cnt.items())))", "entry_point": "string_letter_count", "task_id": "TACO_lite/1858", "input_output_examples": "[[['This is a test sentence.'], [''], ['555']], [['1a1c4e1h2i2n4s4t'], [''], ['']]]", "llm_generated_inputs": {"deepseek-v3": "[['This is a test sentence.'], [''], ['555'], ['Hello World!'], ['AaBbCc'], ['123abcABC'], ['   '], ['!@#$%^&*()'], ['aA aA aA'], ['The quick brown fox jumps over the lazy dog.']]", "qwen2.5-coder-32b-instruct": "[['This is a test sentence.'], [''], ['555'], ['Aabbcc'], ['xyz'], ['Hello World!'], ['123abcABC'], ['No numbers here!'], ['SameLetterCount'], ['Multiple    spaces']]"}}
{"requirement": "def simple_multiplication(number: int) -> int:\n\"\"\"This kata is about multiplying a given number by eight if it is an even number and by nine otherwise.\n\"\"\"", "inputs": [[2], [1], [8], [4], [5]], "outputs": [[16], [9], [64], [32], [45]], "starter_code": "def simple_multiplication(number: int) -> int:", "canonical_solution": "def simple_multiplication(number):\n    return number * 9 if number % 2 else number * 8", "entry_point": "simple_multiplication", "task_id": "TACO_lite/1860", "input_output_examples": "[[], []]", "llm_generated_inputs": {"deepseek-v3": "[[2], [3], [0], [1], [-4], [-5], [10], [11]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [2], [-1], [-2], [100], [99]]"}}
{"requirement": "def simplify(n: int) -> str:\n\"\"\"### What is simplifying a square root?\n\nIf you have a number, like 80, for example, you would start by finding the greatest perfect square divisible by 80. In this case, that's 16. Find the square root of 16, and multiply it by 80 / 16. Answer = 4 √5. \n\n##### The above example:\n\n![simplify_roots_example.png](https://i.postimg.cc/gjv2NwCm/simplify-roots-example.png)\n\n### Task:\n\nYour job is to write two functions, `simplify`, and `desimplify`, that simplify and desimplify square roots, respectively. (Desimplify isn't a word, but I couldn't come up with a better way to put it.) `simplify` will take an integer and return a string like \"x sqrt y\", and `desimplify` will take a string like \"x sqrt y\" and return an integer. For `simplify`, if a square root cannot be simplified, return \"sqrt y\". \n\n_Do not modify the input._\n\n### Some examples:\n\n```python\nsimplify(1)  #=> \"1\"\nsimplify(2)  #=> \"sqrt 2\"\nsimplify(3)  #=> \"sqrt 3\"\nsimplify(8)  #=> \"2 sqrt 2\"\nsimplify(15) #=> \"sqrt 15\"\nsimplify(16) #=> \"4\"\nsimplify(18) #=> \"3 sqrt 2\"\nsimplify(20) #=> \"2 sqrt 5\"\nsimplify(24) #=> \"2 sqrt 6\"\nsimplify(32) #=> \"4 sqrt 2\"\n\ndesimplify(\"1\")        #=> 1\ndesimplify(\"sqrt 2\")   #=> 2\ndesimplify(\"sqrt 3\")   #=> 3\ndesimplify(\"2 sqrt 2\") #=> 8\ndesimplify(\"sqrt 15\")  #=> 15\ndesimplify(\"4\")        #=> 16\ndesimplify(\"3 sqrt 2\") #=> 18\ndesimplify(\"2 sqrt 5\") #=> 20\ndesimplify(\"2 sqrt 6\") #=> 24\ndesimplify(\"4 sqrt 2\") #=> 32\n```\n\nAlso check out my other creations — [Square Roots: Approximation](https://www.codewars.com/kata/square-roots-approximation), [Square and Cubic Factors](https://www.codewars.com/kata/square-and-cubic-factors), [Keep the Order](https://www.codewars.com/kata/keep-the-order), [Naming Files](https://www.codewars.com/kata/naming-files), [Elections: Weighted Average](https://www.codewars.com/kata/elections-weighted-average), [Identify Case](https://www.codewars.com/kata/identify-case), [Split Without Loss](https://www.codewars.com/kata/split-without-loss), [Adding Fractions](https://www.codewars.com/kata/adding-fractions),\n[Random Integers](https://www.codewars.com/kata/random-integers), [Implement String#transpose](https://www.codewars.com/kata/implement-string-number-transpose), [Implement Array#transpose!](https://www.codewars.com/kata/implement-array-number-transpose), [Arrays and Procs #1](https://www.codewars.com/kata/arrays-and-procs-number-1), and [Arrays and Procs #2](https://www.codewars.com/kata/arrays-and-procs-number-2).\n\"\"\"", "inputs": [[1], [2], [3], [8], [15], [16], [18], [20], [24], [32], [4], [7], [9], [10], [12], [13], [14], [50], [80], [200]], "outputs": [["1"], ["sqrt 2"], ["sqrt 3"], ["2 sqrt 2"], ["sqrt 15"], ["4"], ["3 sqrt 2"], ["2 sqrt 5"], ["2 sqrt 6"], ["4 sqrt 2"], ["2"], ["sqrt 7"], ["3"], ["sqrt 10"], ["2 sqrt 3"], ["sqrt 13"], ["sqrt 14"], ["5 sqrt 2"], ["4 sqrt 5"], ["10 sqrt 2"]], "starter_code": "def simplify(n: int) -> str:", "canonical_solution": "def simplify(n):\n    for d in range(int(n ** 0.5), 0, -1):\n        if not n % d ** 2:\n            break\n    if d * d == n:\n        return '%d' % d\n    elif d == 1:\n        return 'sqrt %d' % n\n    else:\n        return '%d sqrt %d' % (d, n // d ** 2)\n\ndef desimplify(s):\n    x, _, y = s.partition('sqrt')\n    return int(x or '1') ** 2 * int(y or '1')", "entry_point": "simplify", "task_id": "TACO_lite/1869", "input_output_examples": "[[[1], [2], [3], [8], [15], [16], [18], [20], [24], [32], [1], ['1'], ['sqrt 2'], ['sqrt 3'], ['2 sqrt 2'], ['sqrt 15'], ['4'], ['3 sqrt 2'], ['2 sqrt 5'], ['2 sqrt 6'], ['4 sqrt 2']], [['1'], ['sqrt 2'], ['sqrt 3'], ['2 sqrt 2'], ['sqrt 15'], ['4'], ['3 sqrt 2'], ['2 sqrt 5'], ['2 sqrt 6'], ['4 sqrt 2'], ['1'], [1], [2], [3], [8], [15], [16], [18], [20], [24], [32]]]", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [8], [15], [16], [18], [20], [24], [32], [0], [-1], [100], [50], [121], [200]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [8], [9], [10], [12], [15], [16], [18], [20], [24], [25], [30], [32], [36], [40], [45], [48], [49], [50], [54], [60], [64], [72], [75], [80], [81], [90], [96], [98], [100], [108], [120], [125], [128], [144], [150], [160], [162], [169], [180], [192], [196], [200], [216], [225], [240], [243]]"}}
{"requirement": "from typing import List\n\n\ndef largestsumafterknegations(A: List[int], K: int) -> int:\n\"\"\"Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total.  (We may choose the same index i multiple times.)\nReturn the largest possible sum of the array after modifying it in this way.\n \nExample 1:\nInput: A = [4,2,3], K = 1\nOutput: 5\nExplanation: Choose indices (1,) and A becomes [4,-2,3].\n\n\nExample 2:\nInput: A = [3,-1,0,2], K = 3\nOutput: 6\nExplanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].\n\n\nExample 3:\nInput: A = [2,-3,-1,5,-4], K = 2\nOutput: 13\nExplanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].\n\n\n\n \nNote:\n\n1 <= A.length <= 10000\n1 <= K <= 10000\n-100 <= A[i] <= 100\n\"\"\"", "inputs": [[[-2, 3, 4], 1], [[4, 2, 3], 1], [[3, -1, 0, 2], 3], [[2, -3, -1, 5, -4], 2]], "outputs": [[9], [5], [6], [13]], "starter_code": "from typing import List\ndef largestsumafterknegations(A: List[int], K: int) -> int:", "canonical_solution": "def largestsumafterknegations(A, K):\n    lst = sorted(A)\n    count = K\n    i = 0\n    while count > 0:\n        if lst[i] <= lst[i + 1]:\n            lst[i] = lst[i] * -1\n            count -= 1\n        else:\n            i += 1\n    return sum(lst)", "entry_point": "largestsumafterknegations", "task_id": "TACO_lite/1871", "input_output_examples": "[[[[4, 2, 3], 1], [[3, -1, 0, 2], 3], [[2, -3, -1, 5, -4], 2]], [[5], [6], [13]]]", "llm_generated_inputs": {"deepseek-v3": "[[[4, 2, 3], 1], [[3, -1, 0, 2], 3], [[2, -3, -1, 5, -4], 2], [[1, 2, 3, 4, 5], 0], [[-1, -2, -3, -4, -5], 5], [[0, 0, 0, 0, 0], 10], [[100, -100, 100, -100], 4], [[-1, -2, -3, -4, -5], 6], [[1], 1], [[-1], 1], [[5, -3, 2, -1, 4], 3], [[-5, -3, -2, -1, -4], 2], [[10, -10, 10, -10, 10], 5], [[1, 3, 2, 6, 7, 9], 10000], [[-1, -3, -2, -6, -7, -9], 10000], [[1, -1, 1, -1, 1], 10000], [[0, 0, 0, 0, 0], 10000], [[100], 10000], [[-100], 10000]]", "qwen2.5-coder-32b-instruct": "[[[4, 2, 3], 1], [[3, -1, 0, 2], 3], [[2, -3, -1, 5, -4], 2], [[-1, -2, -3, -4], 2], [[1, 2, 3, 4], 4], [[0, 0, 0, 0], 1], [[100, -100, 50, -50], 3], [[1], 1], [[-1], 1], [[0], 1], [[1, 2, 3, 4], 0], [[-1, -2, -3, -4], 4], [[100, 200, 300], 10000]]"}}
{"requirement": "def dpc_sequence(s: str) -> int:\n\"\"\"# Task\n You are given a string consisting of `\"D\", \"P\" and \"C\"`. A positive integer N is called DPC of this string if it satisfies the following properties: \n \n ```\n For each i = 1, 2, ... , size of the string:\n\n If i-th character is \"D\", then N can be divided by i\n If i-th character is \"P\", then N and i should be relatively prime\n If i-th character is \"C\", then N should neither be divided by i \n                           nor be relatively prime with i```\n\nYour task is to find the smallest DPC of a given string, or return `-1` if there is no such. The result is guaranteed to be `<= 10^9`.\n\n# Example\n For `s = \"DDPDD\"`, the result should be `20`.\n \n `\"DDPDD\"` means `N` should `divided by 1,2,4,5`, and `N,3` should be relatively prime. The smallest N should be `20`.\n\n# Input/Output\n\n\n - `[input]` string `s`\n\n  The given string\n\n\n - `[output]` an integer\n\n  The smallest DPC of `s` or `-1` if it doesn't exist.\n\"\"\"", "inputs": [["DDPDD"], ["DDDDPDDCCCDDPDCCPCDCDDPCPCCDDCD"], ["DPCPDPPPDCPDPDPC"], ["DDDDDDCD"], ["CDDDPDDD"], ["DDDDDDPCCDPDPP"]], "outputs": [[20], [15782844], [-1], [-1], [-1], [-1]], "starter_code": "def dpc_sequence(s: str) -> int:", "canonical_solution": "from math import gcd\nfrom functools import reduce\n\ndef dpc_sequence(s):\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    d, p, c = ([], [], [])\n    for i in range(len(s)):\n        if s[i] == 'D':\n            d.append(i + 1)\n        elif s[i] == 'P':\n            p.append(i + 1)\n        else:\n            c.append(i + 1)\n    if not d:\n        return -1\n    lcm_d = reduce(lambda i, j: lcm(i, j), d)\n    for i in p:\n        if gcd(lcm_d, i) != 1:\n            return -1\n    for i in c:\n        if lcm_d % i == 0 or gcd(lcm_d, i) == 1:\n            return -1\n    return lcm_d", "entry_point": "dpc_sequence", "task_id": "TACO_lite/1873", "input_output_examples": "[[['DDPDD']], [[20]]]", "llm_generated_inputs": {"deepseek-v3": "[['DDPDD'], ['PPP'], ['CCC'], ['DPC'], ['D'], ['P'], ['C'], ['DDDDD'], ['PPPPP'], ['CCCCC'], ['DPCDPC'], ['DDPPCC'], ['DPDPDP'], ['PCPCPC'], ['DDDPPPCCC'], ['DPCDPCDPC'], ['DPCDPCDPCDPC'], ['DDDDDPPPPPCCCCC'], ['DPCDPCDPCDPCDPC'], ['DPCDPCDPCDPCDPCDPC']]", "qwen2.5-coder-32b-instruct": "[['DDPDD'], ['PPPPP'], ['CCCCC'], ['DPDPD'], ['DCDCD'], ['D'], ['P'], ['C'], ['DDDDDDDDDD'], ['PPPPPPPPPP'], ['CCCCCCCCCC'], ['DPDPDPDPDP'], ['DCDCDCDCDC'], ['DPCCPDCCPD'], ['DDDDPPPPCCCC'], ['DPCDPDCDPD']]"}}
{"requirement": "def find_f1_eq_f2(n: int, k: int) -> int:\n\"\"\"We define the function `f1(n,k)`, as the least multiple of `n` that has all its digits less than `k`. \n\nWe define the function `f2(n,k)`, as the least multiple of `n` that has all the digits that are less than `k`.\n\nEach digit may occur more than once in both values of `f1(n,k)` and `f2(n,k)`.\n\nThe possible values for `n` and `k` according to these ranges for both functions `f1` and `f2` in this kata:\n``` \n1 <= n <= 1.000.000.000.000\n3 <= k <= 9\n``` \n\nFor example, let's see the value of both functions for `n = 71` and `k = 4`:\n``` \nf1(71,4) == 213 # all its digits less than 4\nf2(71,4) == 2130 # 0,1,2,3 all of them present \n```\nThe integer `76` is the first integer that has the same values of `f1` and `f2` for `k = 4`. \n```\nf1(76,4) = f2(76,4) = 10032\n```\nLet's call these kind of numbers, **forgiving numbers**. (Let's continue with the fashion of attributing personality traits to numbers and, of course, an unknown one)\nSo, `76` is the smallest forgiving number of order `4`.\nIn the same way, `485` is the smallest forgiving number of order `5`.\n\nCreate a function that given an integer `n` and the order `k`, will output the higher and closest forgiving number to `n` of order `k`.\n\nLet's see some examples:\n```\nfind_f1_eq_f2(500,5) == 547\nfind_f1_eq_f2(1600,6) == 1799\nfind_f1_eq_f2(14900,7) == 14996\n```\nIf the number `n` is a forgiving itself for a certain order `k`, the function will never output the same value, remember, closest and **higher** than `n`.\n\nFor example, `3456`, is a forgiving one of order `4`,\n```\nfind_f1_eq_f2(3456,4) == 3462\n```\n**Features of the tests:**\n\n* `n` and `k` will be always valid and positive integers.\n\n* A total of 8 fixed tests.\n\n* A total of 150 random tests in the ranges for `n` and `k` given above.\n\nI'll be waiting your awesome solution. :)\n\"\"\"", "inputs": [[542, 5], [1750, 6], [14990, 7], [3456, 4], [30500, 3], [62550, 5], [568525, 7], [9567100, 8]], "outputs": [[547], [1799], [14996], [3462], [30501], [62557], [568531], [9567115]], "starter_code": "def find_f1_eq_f2(n: int, k: int) -> int:", "canonical_solution": "def find_f1_eq_f2(n, k):\n    s = set(range(k))\n    while True:\n        n += 1\n        testn = n\n        while True:\n            f = set(map(int, str(testn)))\n            if f <= s:\n                if f == s:\n                    return n\n                break\n            testn += n", "entry_point": "find_f1_eq_f2", "task_id": "TACO_lite/1874", "input_output_examples": "[[[500, 5], [1600, 6], [14900, 7], [3456, 4]], [[547], [1799], [14996], [3462]]]", "llm_generated_inputs": {"deepseek-v3": "[[500, 5], [1600, 6], [14900, 7], [3456, 4], [1, 3], [1000000000000, 9], [71, 4], [485, 5]]", "qwen2.5-coder-32b-instruct": "[[500, 5], [1600, 6], [14900, 7], [3456, 4], [1, 9], [1000000000000, 3], [999999999999, 9], [76, 4], [485, 5], [2, 3], [10, 4], [100, 5], [1000, 6], [10000, 7], [100000, 8], [1000000, 9], [123456789, 3], [987654321, 9], [547, 5], [1799, 6], [14996, 7], [3462, 4]]"}}
{"requirement": "def frogify(s: str) -> str:\n\"\"\"A little weird green frog speaks in a very strange variation of English: it reverses sentence, omitting all puntuation marks  `, ; ( ) - ` except the final exclamation, question or period. We urgently need help with building a proper translator.\nTo simplify the task, we always use lower-case letters. Apostrophes are forbidden as well.\n\nTranslator should be able to process multiple sentences in one go. Sentences are separated by arbitrary amount of spaces.\n\n**Examples**\n\n`you should use python.` -> `python use should you.`\n\n`look, a fly!` -> `fly a look!`\n\n`multisentence is good. is not it?` -> `good is multisentence. it not is?`\n\"\"\"", "inputs": [["i am a frog."], ["can you do it?"], ["seems like you understand!"], ["multisentence is good. is not it?"], ["green, red or orange - we all just frogs, do not you think so?"]], "outputs": [["frog a am i."], ["it do you can?"], ["understand you like seems!"], ["good is multisentence. it not is?"], ["so think you not do frogs just all we orange or red green?"]], "starter_code": "def frogify(s: str) -> str:", "canonical_solution": "import re\n\ndef frogify(s):\n    return ' '.join((' '.join(re.findall('[a-z]+', sentence)[::-1]) + punct for sentence, punct in re.findall('(.*?)([.!?])', s)))", "entry_point": "frogify", "task_id": "TACO_lite/1883", "input_output_examples": "[[['you should use python.'], ['look, a fly!'], ['multisentence is good. is not it?']], [['python use should you.'], ['fly a look!'], ['good is multisentence. it not is?']]]", "llm_generated_inputs": {"deepseek-v3": "[['you should use python.'], ['look, a fly!'], ['multisentence is good. is not it?'], ['hello world.'], ['this is a test, it works!'], ['no punctuation here'], ['  multiple   spaces   between   words.  '], ['only one sentence.'], ['another example, with more, punctuation!'], ['question mark at the end?']]", "qwen2.5-coder-32b-instruct": "[['you should use python.'], ['look, a fly!'], ['multisentence is good. is not it?'], ['singleword.'], ['multiple   spaces   between words.'], ['punctuation; should, be-ignored.'], ['ending with exclamation!'], ['ending with question?'], ['no punctuation'], ['!onlyexclamation'], ['?onlyquestion'], ['.onlyperiod'], ['two. sentences here.'], ['three. sentences, here!'], ['four. sentences; here?'], ['   leading and trailing spaces   .']]"}}
{"requirement": "from typing import List\n\n\ndef shortest_arrang(n: int) -> List[int]:\n\"\"\"Mrs Jefferson is a great teacher. One of her strategies that helped her to reach astonishing results in the learning process is to have some fun with her students. At school, she wants to make an arrangement of her class to play a certain game with her pupils. For that, she needs to create the arrangement with **the minimum amount of groups that have consecutive sizes**.\n\nLet's see. She has      ```14``` students. After trying a bit she could do the needed arrangement:\n        ```[5, 4, 3, 2]```\n- one group of  ```5``` students\n- another group of      ```4``` students\n- then, another one of  ```3``` \n- and finally, the smallest group of    ```2``` students.\n\nAs the game was a success, she was asked to help to the other classes to teach and show the game. That's why she desperately needs some help to make this required arrangements that make her spend a lot of time. \n\nTo make things worse, she found out that there are some classes with some special number of students that is impossible to get that arrangement.\n\nPlease, help this teacher!\n\nYour code will receive the number of students of the class. It should output the arrangement as an array with the consecutive sizes of the groups in decreasing order.\n\nFor the special case that no arrangement of the required feature is possible the code should output     ```[-1] ```\n\nThe value of n is unknown and may be pretty high because some classes joined to to have fun with the game.\n\nYou may see more example tests in the Example Tests Cases Box.\n\"\"\"", "inputs": [[10], [14], [16], [22], [65]], "outputs": [[[4, 3, 2, 1]], [[5, 4, 3, 2]], [[-1]], [[7, 6, 5, 4]], [[33, 32]]], "starter_code": "from typing import List\ndef shortest_arrang(n: int) -> List[int]:", "canonical_solution": "def shortest_arrang(n):\n    if n % 2 == 1:\n        return [n // 2 + 1, n // 2]\n    for i in range(3, n // 2):\n        if i % 2 == 1 and n % i == 0:\n            return list(range(n // i + i // 2, n // i - i // 2 - 1, -1))\n        elif i % 2 == 0 and n % i == i // 2:\n            return list(range(n // i + i // 2, n // i - i // 2, -1))\n    return [-1]", "entry_point": "shortest_arrang", "task_id": "TACO_lite/1888", "input_output_examples": "[[[14], ['some special number']], [[[5, 4, 3, 2]], [[-1]]]]", "llm_generated_inputs": {"deepseek-v3": "[[14], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [15], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [100], [101], [102], [103], [104], [105], [1000], [1001], [1002], [1003], [1004], [1005], [1000000]]", "qwen2.5-coder-32b-instruct": "[[14], [10], [15], [1], [0], [3], [6], [8], [21], [28], [999999]]"}}
{"requirement": "def two_count(n: int) -> int:\n\"\"\"Write a function that returns the number of '2's in the factorization of a number.  \nFor example,\n```python\ntwo_count(24)\n```\nshould return 3, since the factorization of 24 is 2^3 x 3\n```python\ntwo_count(17280)\n```\nshould return 7, since the factorization of 17280 is 2^7 x 5 x 3^3  \nThe number passed to two_count (twoCount)  will always be a positive integer greater than or equal to 1.\n\"\"\"", "inputs": [[24], [17280], [222222222222], [256], [1], [2], [482848428248882482], [7], [7777777777777777], [84934656]], "outputs": [[3], [7], [1], [8], [0], [1], [1], [0], [0], [20]], "starter_code": "def two_count(n: int) -> int:", "canonical_solution": "def two_count(n):\n    res = 0\n    while not n & 1:\n        res += 1\n        n >>= 1\n    return res", "entry_point": "two_count", "task_id": "TACO_lite/1889", "input_output_examples": "[[[24], [17280]], [[3], [7]]]", "llm_generated_inputs": {"deepseek-v3": "[[24], [17280], [1], [2], [3], [8], [1024], [100], [128], [15]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [8], [9], [10], [16], [18], [24], [32], [64], [128], [256], [512], [1024], [17280], [1000000]]"}}
{"requirement": "def zipvalidate(postcode: str) -> bool:\n\"\"\"You should write a simple function that takes string as input and checks if it is a valid Russian postal code, returning `true` or `false`.\n\nA valid postcode should be 6 digits with no white spaces, letters or other symbols. Empty string should also return false. \n\nPlease also keep in mind that a valid post code **cannot start with** `0, 5, 7, 8 or 9`\n\n\n## Examples\n\nValid postcodes:\n* 198328\n* 310003\n* 424000\n\nInvalid postcodes:\n* 056879\n* 12A483\n* 1@63\n* 111\n\"\"\"", "inputs": [["142784"], ["642784"], ["111"], ["1111111"], ["AA5590"], [""], ["\n245980"], ["245980\n"], ["245980a"], ["24598a"], [" 310587 "], ["555555"], ["775255"], ["875555"], ["012345"], ["968345"], ["@68345"]], "outputs": [[true], [true], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false], [false]], "starter_code": "def zipvalidate(postcode: str) -> bool:", "canonical_solution": "def zipvalidate(postcode):\n    return len(postcode) == 6 and postcode.isdigit() and (postcode[0] not in '05789')", "entry_point": "zipvalidate", "task_id": "TACO_lite/1897", "input_output_examples": "[[['198328'], ['310003'], ['424000'], ['056879'], ['12A483'], ['1@63'], ['111']], [[True], [True], [True], [False], [False], [False], [False]]]", "llm_generated_inputs": {"deepseek-v3": "[['198328'], ['310003'], ['424000'], ['056879'], ['556879'], ['756879'], ['856879'], ['956879'], ['12A483'], ['1@63'], ['111'], ['1111111'], [''], [' 123456'], ['123456 '], ['123 456']]", "qwen2.5-coder-32b-instruct": "[['198328'], ['310003'], ['424000'], ['056879'], ['12A483'], ['1@63'], ['111'], ['500000'], ['700000'], ['800000'], ['900000'], ['100000'], ['200000'], ['600000'], ['123456'], ['111111'], ['222222'], ['333333'], ['444444'], ['666666'], [''], [' '], ['12345a'], ['1234567'], ['12 3456'], ['123456 '], [' 123456']]"}}

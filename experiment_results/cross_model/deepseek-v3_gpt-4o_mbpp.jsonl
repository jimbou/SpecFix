{"task_id": "Mbpp/16", "requirement": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if the input string contains at least one sequence of one or more lowercase letters, followed by an underscore, followed by one or more lowercase letters. The function should return False otherwise.\n    The function should not require the entire string to match this pattern; it only needs to find at least one such substring.\n    assert text_lowercase_underscore(\"aab_cbbbc\") == (True)\n    \"\"\"", "generated_programs": ["import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "Mbpp/63", "requirement": "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute difference between the two elements within each tuple in the given list of tuples.\n    \n    The function assumes that each tuple in the list contains exactly two integers. If the input list is empty, the function raises a ValueError.\n    \n    Args:\n        test_list: A list of tuples, where each tuple contains exactly two integers.\n    \n    Returns:\n        The maximum absolute difference between the two elements within each tuple.\n    \n    Raises:\n        ValueError: If the input list is empty.\n    \n    Examples:\n        >>> max_difference([(3, 5), (1, 7), (10, 3), (1, 2)])\n        7\n        >>> max_difference([])\n        ValueError\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError('Input list is empty.')\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError('The input list is empty.')\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError('Input list is empty')\n    return max((abs(x - y) for x, y in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError('Input list cannot be empty.')\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError('Input list is empty')\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError('Input list is empty')\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError('The input list is empty.')\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError('The input list is empty.')\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError('Input list is empty.')\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError('The input list is empty.')\n    return max((abs(a - b) for a, b in test_list))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/72", "requirement": "def dif_Square(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given integer `n` can be represented as the difference of two squares, i.e., `n = a² - b²`, where `a` and `b` are non-negative integers.\n\n    The function should return `True` if such a representation exists, otherwise `False`. The function should handle all integer inputs, including negative numbers, but should return `False` for negative inputs since the difference of two squares cannot be negative.\n\n    Examples:\n    assert dif_Square(5) == True\n    assert dif_Square(-1) == False\n    assert dif_Square(0) == True\n    assert dif_Square(3) == True\n    assert dif_Square(4) == True\n    \"\"\"", "generated_programs": ["def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 2 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 2 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 != 0 or n % 4 == 0", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    for a in range(int((n + 1) ** 0.5) + 1):\n        for b in range(a + 1):\n            if a ** 2 - b ** 2 == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 1 or n % 4 == 0", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 2 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 2 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return True", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 2 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 4 == 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n    \"\"\"\n    Write a Python function to determine if a number is divisible by 11 using the modulo operation.\n    The function should return True if the number is divisible by 11, otherwise False.\n    assert is_Diff(12345) == False\n    \"\"\"", "generated_programs": ["def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/92", "requirement": "def is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not. \n    A number is considered undulating if it strictly alternates between two distinct digits. \n    For example, `1212121` is undulating because it alternates between `1` and `2`.\n    The number must have at least two digits, and no two adjacent digits should be the same.\n    The alternation pattern must be consistent throughout the number.\n    \n    assert is_undulating(1212121) == True\n    \"\"\"", "generated_programs": ["def is_undulating(n: int) -> bool:\n    num_str = str(n)\n    if len(num_str) < 2:\n        return False\n    digit1, digit2 = (num_str[0], num_str[1])\n    if digit1 == digit2:\n        return False\n    for i in range(len(num_str)):\n        if i % 2 == 0 and num_str[i] != digit1:\n            return False\n        if i % 2 == 1 and num_str[i] != digit2:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    digits = {s[0], s[1]}\n    if len(digits) != 2 or any((s[i] == s[i + 1] for i in range(len(s) - 1))):\n        return False\n    return all((s[i] == s[i % 2] for i in range(len(s))))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    distinct_digits = set(s)\n    if len(distinct_digits) != 2:\n        return False\n    pattern = s[:2]\n    for i in range(0, len(s), 2):\n        if s[i:i + 2] != pattern[:len(s[i:i + 2])]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    str_n = str(n)\n    if len(str_n) < 2:\n        return False\n    unique_digits = set(str_n)\n    if len(unique_digits) != 2:\n        return False\n    return all((str_n[i] != str_n[i + 1] for i in range(len(str_n) - 1)))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    a, b = (s[0], s[1])\n    if a == b:\n        return False\n    for i in range(len(s)):\n        if s[i] != (a if i % 2 == 0 else b):\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    num_str = str(n)\n    if len(num_str) < 2:\n        return False\n    digit1, digit2 = (num_str[0], num_str[1])\n    if digit1 == digit2:\n        return False\n    for i in range(len(num_str)):\n        if i % 2 == 0 and num_str[i] != digit1:\n            return False\n        if i % 2 == 1 and num_str[i] != digit2:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    number_str = str(n)\n    if len(number_str) < 2:\n        return False\n    digit1, digit2 = (number_str[0], number_str[1])\n    if digit1 == digit2:\n        return False\n    for i in range(2, len(number_str)):\n        if number_str[i] != (digit1 if i % 2 == 0 else digit2):\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    digit1, digit2 = (s[0], s[1])\n    if digit1 == digit2:\n        return False\n    for i in range(len(s)):\n        if i % 2 == 0 and s[i] != digit1:\n            return False\n        if i % 2 == 1 and s[i] != digit2:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    num_str = str(n)\n    if len(num_str) < 2:\n        return False\n    first, second = (num_str[0], num_str[1])\n    if first == second:\n        return False\n    for i in range(len(num_str)):\n        if i % 2 == 0 and num_str[i] != first:\n            return False\n        if i % 2 == 1 and num_str[i] != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    num_str = str(n)\n    if len(num_str) < 2:\n        return False\n    digit1, digit2 = (num_str[0], num_str[1])\n    if digit1 == digit2:\n        return False\n    for i in range(len(num_str)):\n        if i % 2 == 0 and num_str[i] != digit1 or (i % 2 == 1 and num_str[i] != digit2):\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given positive integer.\n    The function should raise a ValueError if the input is a non-positive integer (i.e., zero or negative).\n    The function should optimize the divisor counting process by limiting the loop to the square root of `n`.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer.\n    \"\"\"", "generated_programs": ["import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    limit = math.isqrt(n)\n    for i in range(1, limit + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    limit = int(math.sqrt(n)) + 1\n    for i in range(1, limit):\n        if n % i == 0:\n            count += 1 if i == n // i else 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    sqrt_n = math.isqrt(n)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1 if i == n // i else 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    limit = int(math.sqrt(n)) + 1\n    for i in range(1, limit):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/99", "requirement": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Write a function to convert the given decimal number to its binary equivalent, represented as a string. \n    The binary string should start with the first '1' encountered, ensuring no leading zeros. \n    If the input number is 0, the function should return '0'.\n    assert decimal_to_binary(8) == '1000'\n    \"\"\"", "generated_programs": ["def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    return bin(n)[2:]", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    return bin(n)[2:]", "def decimal_to_binary(n: int) -> str:\n    return bin(n)[2:] if n != 0 else '0'", "def decimal_to_binary(n: int) -> str:\n    return bin(n)[2:] if n > 0 else '0'", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    return bin(n)[2:]", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    return bin(n)[2:]", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    return bin(n)[2:]", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    return bin(n)[2:]", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    return bin(n)[2:]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/103", "requirement": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Write a function to find the Eulerian number a(n, m).\n    The Eulerian number a(n, m) is defined for integers n >= 0 and 0 <= m < n.\n    For m < 0 or m >= n, the function should return 0.\n    assert eulerian_num(3, 1) == 4\n    \"\"\"", "generated_programs": ["from functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "from functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "from functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i][j] = (i - j) * dp[i - 1][j] + (j + 1) * dp[i - 1][j - 1]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.8, "original_passk": 0.9}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements in given nested lists. \n    The function assumes that the input `nestedlist` contains at least one sublist and that all sublists are non-empty.\n    If the input is an empty list or contains empty sublists, the function will raise a `TypeError`.\n\n    Examples:\n    >>> assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    >>> common_in_nested_lists([[]])\n    TypeError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input list contains empty sublists or is empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input must contain non-empty sublists')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input list is empty or contains empty sublists.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('All sublists must be non-empty')\n    return list(set.intersection(*map(set, nestedlist)))", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input contains empty list or empty sublists.')\n    return list(reduce(set.intersection, map(set, nestedlist)))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    from functools import reduce\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Nested list must contain at least one non-empty sublist.')\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input contains empty lists.')\n    return list(set.intersection(*map(set, nestedlist)))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input contains an empty list or sublists.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input list or sublist cannot be empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input must be a non-empty list containing non-empty sublists.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/120", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute product of the two numbers within each tuple in a given list of tuples.\n    The function should calculate the product of the two numbers within each tuple, take the absolute value of that product,\n    and then return the largest absolute product among these products.\n    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n\"\"\"\nWrite a function to sum all amicable numbers from 1 to a specified number.\n\n\nassert amicable_numbers_sum(999)==504\n\"\"\"", "generated_programs": ["from math import sqrt\n\ndef divisors_sum(n: int) -> int:\n    total = 1\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = divisors_sum(a)\n        if b != a and b <= limit and (divisors_sum(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n\n    def find_amicable_numbers(limit: int) -> List[int]:\n        amicables = set()\n        for a in range(2, limit + 1):\n            b = sum_of_divisors(a)\n            if b > a and b <= limit and (sum_of_divisors(b) == a):\n                amicables.update({a, b})\n        return list(amicables)\n    return sum(find_amicable_numbers(limit))", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        divisors = [1]\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef divisor_sum(n: int) -> int:\n    return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def is_amicable(a: int) -> bool:\n        b = divisor_sum(a)\n        return b != a and divisor_sum(b) == a\n    return sum((i for i in range(1, limit + 1) if is_amicable(i)))", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 0\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != 1 and i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "from math import sqrt\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        divisors_sum = 1\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        divisors_sum = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i + (n // i if i != n // i else 0)\n        return divisors_sum\n\n    def is_amicable(a: int) -> bool:\n        b = sum_of_divisors(a)\n        return b != a and sum_of_divisors(b) == a\n    return sum((a for a in range(2, limit + 1) if is_amicable(a)))", "from typing import List\n\ndef sum_of_divisors(n: int) -> int:\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i and i != 1:\n                divisors.append(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Write a function to calculate the angle of the vector from complex number `a` to complex number `b` in the complex plane.\n    The angle is calculated as the phase of the complex number resulting from the difference `b - a`.\n\n    Example:\n    >>> assert math.isclose(angle_complex(0, 1j), 1.5707963267948966, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.phase(b - a)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.phase(b - a)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.phase(b - a)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/126", "requirement": "def sum_of_common_divisors(a: int, b: int) -> int:\n    \"\"\"\n    Write a Python function to calculate and return the sum of all common divisors of two given integers.\n    The function should return the sum as a single integer.\n\n    Example:\n    >>> sum_of_common_divisors(10, 15)\n    6\n    \"\"\"", "generated_programs": ["from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_gcd = gcd(a, b)\n    return sum((i for i in range(1, common_gcd + 1) if common_gcd % i == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_gcd = gcd(a, b)\n    return sum((i for i in range(1, common_gcd + 1) if common_gcd % i == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    return sum((i for i in range(1, gcd(a, b) + 1) if gcd(a, b) % i == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_divisor = gcd(a, b)\n    return sum((i for i in range(1, common_divisor + 1) if common_divisor % i == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_gcd = gcd(a, b)\n    return sum((i for i in range(1, common_gcd + 1) if common_gcd % i == 0))", "import math\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    gcd_value = math.gcd(a, b)\n    return sum((i for i in range(1, gcd_value + 1) if gcd_value % i == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    g = gcd(a, b)\n    return sum((i for i in range(1, g + 1) if g % i == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_gcd = gcd(a, b)\n    return sum((i for i in range(1, common_gcd + 1) if common_gcd % i == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_divisor = gcd(a, b)\n    return sum((i for i in range(1, common_divisor + 1) if common_divisor % i == 0))", "import math\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    gcd = math.gcd(a, b)\n    return sum((i for i in range(1, gcd + 1) if gcd % i == 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether the given matrix is a magic square.\n    A magic square is a square matrix where the sums of the numbers in each row, each column, and both main diagonals are equal to the magic sum.\n    The magic sum for an n x n matrix is calculated as n * (n ** 2 + 1) // 2.\n    Additionally, the matrix must be square (i.e., the number of rows equals the number of columns).\n    \n    Examples:\n    >>> magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])\n    True\n    >>> magic_square_test([[1, 1, 1], [1, 1, 1], [1, 1, 1]])\n    False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_sum or sum((my_matrix[j][i] for j in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if n == 0 or any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if n == 0 or any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col_idx in range(n):\n        col_sum = sum((my_matrix[row_idx][col_idx] for row_idx in range(n)))\n        if col_sum != magic_sum:\n            return False\n    main_diagonal_sum = sum((my_matrix[i][i] for i in range(n)))\n    anti_diagonal_sum = sum((my_matrix[i][n - i - 1] for i in range(n)))\n    if main_diagonal_sum != magic_sum or anti_diagonal_sum != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if any((sum(row) != magic_sum for row in my_matrix)):\n        return False\n    if any((sum((my_matrix[i][j] for i in range(n))) != magic_sum for j in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/130", "requirement": "from typing import List\n\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list. \n    The function assumes that the input list is non-empty. If the list is empty, \n    the function will raise an IndexError when attempting to access the first element \n    of an empty list.\n\n    Examples:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    >>> max_occurrences([])\n    IndexError\n    \"\"\"", "generated_programs": ["from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('List is empty')\n    frequency = Counter(nums)\n    return max(frequency, key=frequency.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The list is empty.')\n    frequency = Counter(nums)\n    return max(frequency, key=frequency.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The input list is empty.')\n    frequency = Counter(nums)\n    return max(frequency, key=frequency.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('Attempting to access an element from an empty list.')\n    frequency = Counter(nums)\n    return max(frequency, key=frequency.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The input list is empty.')\n    frequency = Counter(nums)\n    return max(frequency, key=frequency.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    frequency = Counter(nums)\n    return max(frequency, key=frequency.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The list is empty')\n    frequency = Counter(nums)\n    return max(frequency, key=frequency.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    count = Counter(nums)\n    return max(count, key=count.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The list is empty.')\n    frequency = Counter(nums)\n    return max(frequency, key=frequency.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The list is empty')\n    frequency = Counter(nums)\n    return max(frequency, key=frequency.get)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/137", "requirement": "from typing import List\n\n\ndef zero_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of the number of zeroes to the number of non-zero elements in an array of integers.\n    assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "import math\nfrom typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "import math\nfrom typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    return zeroes / non_zeroes if non_zeroes > 0 else float('inf')", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / (non_zeroes + zeroes)", "import math\nfrom typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    return zeroes / non_zeroes if non_zeroes != 0 else 0.0", "import math\nfrom typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given integer can be represented as the sum of multiple non-zero powers of 2.\n    The function should return `True` if the number has more than one bit set in its binary representation, indicating it is a sum of multiple powers of 2.\n    The function should return `False` if the number is a single power of 2 (i.e., only one bit is set in its binary representation).\n    The function should handle negative integers by checking their binary representation in the same manner as positive integers.\n    assert is_Sum_Of_Powers_Of_Two(10) == True\n    \"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(abs(n)).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n < 0:\n        n = abs(n)\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(abs(n)).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(abs(n)).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n < 0:\n        n = abs(n)\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(abs(n)).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    binary_repr = bin(abs(n))[2:]\n    return binary_repr.count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(abs(n)).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(abs(n)).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n < 0:\n        n = abs(n)\n    return bin(n).count('1') > 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/145", "requirement": "from typing import List\n\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the maximum absolute difference between the maximum and minimum values in a given non-empty array of integers.\n    If the array is empty, the function should return 0.\n    \n    assert max_Abs_Diff((2,1,5,3)) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return abs(max(arr) - min(arr))", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return abs(max(arr) - min(arr))", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return abs(max(arr) - min(arr))", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"\n    Write a function that returns non-negative integers x and y that satisfy ax + by = n as a tuple, or return None if no such solution exists.\n    \n    The function should handle the following cases:\n    1. If `a` or `b` is zero, the function should raise a ZeroDivisionError.\n    2. If `n` is zero, the function should return (0, 0) if both `a` and `b` are non-zero.\n    3. If `n` is not divisible by the greatest common divisor (GCD) of `a` and `b`, the function should return None.\n    4. If multiple solutions exist, the function should return the first solution where both `x` and `y` are non-negative, without prioritizing any specific solution (e.g., smallest `x` or smallest `y`).\n    \n    The function assumes that `a`, `b`, and `n` are positive integers. If `a`, `b`, or `n` is negative, the behavior is undefined.\n    \n    assert find_solution(2, 3, 7) == (2, 1)\n    \"\"\"", "generated_programs": ["import math\nfrom typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('`a` or `b` cannot be zero.')\n    if n == 0:\n        return (0, 0)\n    gcd = math.gcd(a, b)\n    if n % gcd != 0:\n        return None\n\n    def extended_euclidean(a: int, b: int) -> Tuple[int, int, int]:\n        if b == 0:\n            return (a, 1, 0)\n        gcd, x1, y1 = extended_euclidean(b, a % b)\n        x, y = (y1, x1 - a // b * y1)\n        return (gcd, x, y)\n    gcd, x0, y0 = extended_euclidean(a, b)\n    x0 *= n // gcd\n    y0 *= n // gcd\n    k = 0\n    while True:\n        x = x0 + k * (b // gcd)\n        y = y0 - k * (a // gcd)\n        if x >= 0 and y >= 0:\n            return (x, y)\n        k += 1", "from typing import Tuple, Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a and b cannot be zero.')\n    if n == 0:\n        return (0, 0)\n    if n % gcd(a, b) != 0:\n        return None\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError(\"Neither 'a' nor 'b' can be zero.\")\n    if n == 0:\n        return (0, 0)\n    g = gcd(a, b)\n    if n % g != 0:\n        return None\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError(\"Coefficient 'a' or 'b' cannot be zero.\")\n    if n == 0:\n        return (0, 0)\n    if n % gcd(a, b) != 0:\n        return None\n    for x in range(0, n // a + 1):\n        for y in range(0, n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError(\"Neither 'a' nor 'b' can be zero.\")\n    if n == 0:\n        return (0, 0)\n    if n % gcd(a, b) != 0:\n        return None\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        gcd_val, x1, y1 = extended_gcd(b, a % b)\n        x = y1\n        y = x1 - a // b * y1\n        return (gcd_val, x, y)\n    g, x, y = extended_gcd(a, b)\n    x *= n // g\n    y *= n // g\n    k = 0\n    while x < 0 or y < 0:\n        if x < 0:\n            k = b // g\n            x += k\n            y -= k\n        elif y < 0:\n            k = a // g\n            x -= k\n            y += k\n    if x >= 0 and y >= 0:\n        return (x, y)\n    return None", "from typing import Tuple, Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a or b cannot be zero')\n    if n == 0:\n        return (0, 0)\n    g = gcd(a, b)\n    if n % g != 0:\n        return None\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (1, 0)\n        x1, y1 = extended_gcd(b, a % b)\n        x = y1\n        y = x1 - a // b * y1\n        return (x, y)\n    x, y = extended_gcd(a, b)\n    x *= n // g\n    y *= n // g\n    k = 0\n    while True:\n        current_x = x + k * (b // g)\n        current_y = y - k * (a // g)\n        if current_x >= 0 and current_y >= 0:\n            return (current_x, current_y)\n        k += 1", "from typing import Tuple, Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a or b cannot be zero.')\n    if n == 0:\n        return (0, 0)\n    if n % gcd(a, b) != 0:\n        return None\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a or b cannot be zero.')\n    if n == 0:\n        if a != 0 and b != 0:\n            return (0, 0)\n    if n % gcd(a, b) != 0:\n        return None\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y.is_integer() and y >= 0:\n            return (x, int(y))\n    return None", "from math import gcd\nfrom typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a and b cannot be zero')\n    if n == 0:\n        return (0, 0)\n    if n % gcd(a, b) != 0:\n        return None\n\n    def extended_gcd(x: int, y: int):\n        if y == 0:\n            return (x, 1, 0)\n        gcd_val, x1, y1 = extended_gcd(y, x % y)\n        return (gcd_val, y1, x1 - x // y * y1)\n    g, x, y = extended_gcd(a, b)\n    x *= n // g\n    y *= n // g\n    k = max(0, -x * g // b)\n    while True:\n        x_candidate = x + k * b // g\n        y_candidate = y - k * a // g\n        if x_candidate >= 0 and y_candidate >= 0:\n            return (x_candidate, y_candidate)\n        if x_candidate < 0 or y_candidate < 0:\n            return None\n        k += 1", "from typing import Tuple, Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a and b must be non-zero')\n    if n == 0:\n        return (0, 0)\n    g = gcd(a, b)\n    if n % g != 0:\n        return None\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        gcd_val, x1, y1 = extended_gcd(b, a % b)\n        x, y = (y1, x1 - a // b * y1)\n        return (gcd_val, x, y)\n    gcd_val, x0, y0 = extended_gcd(a, b)\n    x0 *= n // g\n    y0 *= n // g\n    for k in range(-min(x0 // (b // g), y0 // (-a // g)), max(x0 // (b // g), y0 // (-a // g)) + 2):\n        x = x0 + k * (b // g)\n        y = y0 - k * (a // g)\n        if x >= 0 and y >= 0:\n            return (x, y)\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.6}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n    \"\"\"\n    Write a Python function to set all even bits of a given number to 1 if any of the even bits are not already set.\n    The function should return the original number if all even bits are already set.\n    assert even_bit_set_number(10) == 10\n    \"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    even_bit_mask = n | 2863311530\n    return n if even_bit_mask == n else even_bit_mask", "def even_bit_set_number(n: int) -> int:\n    even_mask = 0\n    for i in range(0, n.bit_length(), 2):\n        even_mask |= 1 << i\n    return n | even_mask", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 0\n    for i in range(0, n.bit_length() + 1, 2):\n        even_bit_mask |= 1 << i\n    return n | even_bit_mask if n & even_bit_mask != even_bit_mask else n", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length() + 1, 2):\n        mask |= 1 << i\n    return n if n & mask == mask else n | mask", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 0\n    for i in range(0, n.bit_length(), 2):\n        even_bit_mask |= 1 << i\n    return n | even_bit_mask if n & even_bit_mask != even_bit_mask else n", "def even_bit_set_number(n: int) -> int:\n    return n | 2863311530", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for bit in range(0, n.bit_length() + 1, 2):\n        mask |= 1 << bit\n    result = n | mask\n    return result if result != n else n", "from typing import List\n\ndef even_bit_set_number(n: int) -> int:\n    even_bitmask = 0\n    for i in range(0, 32, 2):\n        even_bitmask |= 1 << i\n    new_number = n | even_bitmask\n    return n if new_number == n else new_number", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 0\n    for i in range(0, n.bit_length(), 2):\n        even_bit_mask |= 1 << i\n    if n & even_bit_mask == even_bit_mask:\n        return n\n    return n | even_bit_mask", "def even_bit_set_number(n: int) -> int:\n    even_bitmask = sum((2 ** i for i in range(0, n.bit_length(), 2)))\n    if n & even_bitmask == even_bitmask:\n        return n\n    return n | even_bitmask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, \n    such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    The first element of the sequence can be any integer from 1 to m.\n    If n is 0, the function should raise an IndexError.\n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('The sequence length cannot be zero.')\n\n    def count_sequences(prev: int, remaining_length: int) -> int:\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_elem in range(max(1, 2 * prev), m + 1):\n            total += count_sequences(next_elem, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for start_elem in range(1, m + 1):\n        total_sequences += count_sequences(start_elem, n - 1)\n    return total_sequences", "from functools import lru_cache\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be greater than 0')\n\n    def count_sequences(previous, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total_sequences = 0\n        for i in range(max(2 * previous, 1), m + 1):\n            total_sequences += count_sequences(i, remaining_length - 1)\n        return total_sequences\n    total = 0\n    for first_element in range(1, m + 1):\n        total += count_sequences(first_element, n - 1)\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be a positive integer.')\n\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_value in range(current * 2, m + 1):\n            total += count_sequences(next_value, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(first_element, n - 1)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequence length cannot be zero')\n\n    def count_sequences(prev: int, length: int) -> int:\n        if length == n:\n            return 1\n        total = 0\n        start = max(1, 2 * prev)\n        for i in range(start, m + 1):\n            total += count_sequences(i, length + 1)\n        return total\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(first_element, 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequence length must be greater than 0')\n\n    def calculate_sequences(start, length):\n        if length == 1:\n            return 1\n        count = 0\n        for next_element in range(2 * start, m + 1):\n            count += calculate_sequences(next_element, length - 1)\n        return count\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += calculate_sequences(first_element, n)\n    return total_count", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequence length cannot be zero')\n\n    def count_sequences(start: int, remaining_length: int) -> int:\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_value in range(2 * start, m + 1):\n            total += count_sequences(next_value, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for first_value in range(1, m + 1):\n        total_sequences += count_sequences(first_value, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequence length cannot be zero.')\n\n    def count_sequences(start, length):\n        if length == 1:\n            return 1\n        total = 0\n        for i in range(2 * start, m + 1):\n            total += count_sequences(i, length - 1)\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequence length cannot be zero.')\n\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_elem in range(max(1, 2 * current), m + 1):\n            total += count_sequences(next_elem, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(first_element, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be greater than 0')\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_element in range(2 * current_element, m + 1):\n            total += count_sequences(next_element, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(first_element, n - 1)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('n cannot be 0.')\n\n    def count_sequences(prev: int, remaining: int) -> int:\n        if remaining == 0:\n            return 1\n        total = 0\n        for i in range(max(2 * prev, 1), m + 1):\n            total += count_sequences(i, remaining - 1)\n        return total\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    return total_sequences"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/253", "requirement": "from typing import List, Any\n\n\ndef count_integer(lst: List[Any]) -> int:\n    \"\"\"\n    Write a Python function that returns the number of elements in a given list that are of type `int`, excluding `bool` values.\n    assert count_integer([1, 2, 'abc', 1.2]) == 2\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for x in lst if isinstance(x, int) and (not isinstance(x, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(item, int) and (not isinstance(item, bool)) for item in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    from numbers import Integral\n    return sum((isinstance(x, Integral) and (not isinstance(x, bool)) for x in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for x in lst if isinstance(x, int) and (not isinstance(x, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(item, int) and (not isinstance(item, bool)) for item in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for x in lst if isinstance(x, int) and (not isinstance(x, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(x, int) and (not isinstance(x, bool)) for x in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(x, int) and (not isinstance(x, bool)) for x in lst))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Newman-Shanks-Williams prime number.\n    \n    The Newman-Shanks-Williams prime sequence is defined as follows:\n    - The first Newman-Shanks-Williams prime (n=1) is 3.\n    - The second Newman-Shanks-Williams prime (n=2) is 5.\n    - The third Newman-Shanks-Williams prime (n=3) is 7.\n    - For n > 1, the nth Newman-Shanks-Williams prime is generated using the recurrence relation: c = 2 * b + a, where a and b are the previous two primes in the sequence.\n    \n    The function should return the nth Newman-Shanks-Williams prime number.\n    \n    Examples:\n    >>> newman_prime(1)\n    3\n    >>> newman_prime(2)\n    5\n    >>> newman_prime(3)\n    7\n    \"\"\"", "generated_programs": ["def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(3, n):\n        c = 2 * b + a\n        a, b = (b, c)\n    return 2 * b + a", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    primes = [3, 5, 7]\n    for i in range(3, n):\n        primes.append(2 * primes[-1] + primes[-2])\n    return primes[n - 1]", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(3, n):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    primes = [3, 5, 7]\n    for i in range(4, n + 1):\n        next_prime = 2 * primes[-1] + primes[-2]\n        primes.append(next_prime)\n    return primes[-1]", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    if n == 3:\n        return 7\n    seq = [3, 5, 7]\n    for i in range(3, n):\n        next_value = 2 * seq[-1] + seq[-2]\n        seq.append(next_value)\n    return seq[n - 1]", "def newman_prime(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input should be a positive integer.')\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    if n == 3:\n        return 7\n    a = 3\n    b = 5\n    for _ in range(3, n):\n        c = 2 * b + a\n        a = b\n        b = c\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    a, b = (3, 5)\n    for _ in range(3, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    a, b = (3, 5)\n    for _ in range(3, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    sequence = [3, 5]\n    for i in range(3, n + 1):\n        next_prime = 2 * sequence[-1] + sequence[-2]\n        sequence.append(next_prime)\n    return sequence[n - 1]", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    if n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/264", "requirement": "def dog_age(h_age: float) -> float:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years. \n    For non-positive human ages (h_age <= 0), the function should return 0.0.\n    For human ages less than or equal to 2, the dog's age is calculated as h_age * 10.5.\n    For human ages greater than 2, the dog's age is calculated as 21 + (h_age - 2) * 4.\n    assert dog_age(12)==61\n    \"\"\"", "generated_programs": ["def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/265", "requirement": "from typing import List, Any\n\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Splits the list `S` into `step` number of sublists, where each sublist contains elements spaced by `step` intervals. \n    The first sublist contains elements at positions 0, step, 2*step, etc., the second sublist contains elements at positions 1, step+1, 2*step+1, etc., and so on.\n    \n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i] for i in range(start, len(S), step)] for start in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i] for i in range(start, len(S), step)] for start in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i] for i in range(j, len(S), step)] for j in range(step)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/286", "requirement": "from typing import List\n\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the largest sum of a contiguous subarray in the modified array formed by repeating the given array `k` times. \n    The function should treat the repeated array as a single continuous sequence, allowing the subarray to span across multiple repetitions if necessary.\n    \n    The function should handle the following cases:\n    - If `k` is 1, it should return the maximum subarray sum of the original array.\n    - If the total sum of the array is positive, the maximum subarray sum could be significantly larger when the array is repeated multiple times.\n    - If the total sum of the array is non-positive, the maximum subarray sum should be calculated by considering at most two repetitions of the array.\n    \n    assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    if total_sum > 0:\n        return kadane(a * 2) + (k - 2) * total_sum\n    else:\n        return kadane(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_subarray_sum(arr):\n        max_ending_here = max_so_far = arr[0]\n        for num in arr[1:]:\n            max_ending_here = max(num, max_ending_here + num)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return max_subarray_sum(a)\n    if total_sum > 0:\n        return max_subarray_sum(a * 2) + (k - 2) * total_sum\n    return max_subarray_sum(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_subarray_sum(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in arr:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    total_sum = sum(a)\n    if k == 1:\n        return max_subarray_sum(a)\n    if total_sum > 0:\n        extended_array = a * 2\n        return max_subarray_sum(extended_array) + (k - 2) * total_sum\n    else:\n        extended_array = a * 2\n        return max_subarray_sum(extended_array)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_subarray_sum(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in arr:\n            current_sum += num\n            max_sum = max(max_sum, current_sum)\n            if current_sum < 0:\n                current_sum = 0\n        return max_sum\n    total_sum = sum(a)\n    if k == 1:\n        return max_subarray_sum(a)\n    if total_sum > 0:\n        return max_subarray_sum(a * 2) + (k - 2) * total_sum\n    return max_subarray_sum(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for num in arr[1:]:\n            max_ending_here = max(num, max_ending_here + num)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_kadane = kadane(a)\n    if k == 1:\n        return max_kadane\n    extended_kadane = kadane(a + a)\n    if total_sum > 0:\n        return extended_kadane + (k - 2) * total_sum\n    return extended_kadane", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in arr:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    total_sum = sum(a)\n    max_kadane_single = kadane(a)\n    if k == 1:\n        return max_kadane_single\n    elif total_sum > 0:\n        return max_kadane_single + (k - 1) * total_sum\n    else:\n        double_array = a + a\n        return kadane(double_array)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    arr_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif arr_sum > 0:\n        return kadane(a * 2) + (k - 2) * arr_sum\n    else:\n        return kadane(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_end_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_end_here = max(x, max_end_here + x)\n            max_so_far = max(max_so_far, max_end_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_single = kadane(a)\n    if k == 1:\n        return max_single\n    double_arr = a * 2\n    max_double = kadane(double_arr)\n    if total_sum > 0:\n        return max_double + (k - 2) * total_sum\n    else:\n        return max_double", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in arr:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    total_sum = sum(a)\n    if k == 1:\n        return max_sub_array_sum(a)\n    max_subarray_two_repeat = max_sub_array_sum(a * 2)\n    if total_sum > 0:\n        return max_subarray_two_repeat + total_sum * (k - 2)\n    else:\n        return max_subarray_two_repeat", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_so_far = float('-inf')\n        current_max = 0\n        for num in arr:\n            current_max += num\n            if current_max > max_so_far:\n                max_so_far = current_max\n            if current_max < 0:\n                current_max = 0\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    max_two_repeats = kadane(a + a)\n    if total_sum > 0:\n        return max_two_repeats + (k - 2) * total_sum\n    else:\n        return max_two_repeats"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n    \"\"\"\n    Write a function to find the depth of a dictionary. The depth is defined as the number of nested dictionaries plus one. \n    An empty dictionary has a depth of 1. Non-dictionary inputs should return a depth of 0.\n\n    Examples:\n    >>> dict_depth({'a':1, 'b': {'c': {'d': {}}}})\n    4\n    >>> dict_depth({})\n    1\n    >>> dict_depth(123)\n    0\n    \"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) if isinstance(v, dict) else 0 for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.11111111111111116, "original_passk": 0.4}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Find the maximum sum of an increasing subsequence from the prefix of the list up to the ith index, \n    and then add the kth element to this sum. The kth element must be strictly after the ith index (k > i).\n    \n    The function calculates the maximum sum of increasing subsequences up to each index using dynamic programming.\n    It then finds the maximum sum among the subsequences up to the ith index where the last element is less than the kth element.\n    If no such subsequence exists, the function returns the value of the kth element alone.\n    \n    Args:\n        a (List[int]): The input list of integers.\n        n (int): The length of the list.\n        index (int): The index up to which the increasing subsequence is considered.\n        k (int): The index of the element to be added to the sum, must be greater than index.\n    \n    Returns:\n        int: The maximum sum of the increasing subsequence up to the ith index plus the kth element, or the kth element alone if no valid subsequence is found.\n    \n    Examples:\n        >>> max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6)\n        11\n        >>> max_sum_increasing_subseq([5, 4, 3, 2, 1], 5, 1, 3)\n        2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k] if max_sum > 0 else a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    maximum_sum = 0\n    found = False\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            maximum_sum = max(maximum_sum, dp[i])\n            found = True\n    return maximum_sum + a[k] if found else a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    if index >= k or index >= n or k >= n:\n        return a[k]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k] if max_sum > 0 else a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k <= index or index < 0 or index >= n or (k < 0) or (k >= n):\n        return 0\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(n):\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k <= index:\n        raise ValueError('k must be greater than index')\n    max_sum_dp = [0] * n\n    for i in range(n):\n        max_sum_dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                max_sum_dp[i] = max(max_sum_dp[i], max_sum_dp[j] + a[i])\n    max_sum_till_index = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum_till_index = max(max_sum_till_index, max_sum_dp[i])\n    result = max_sum_till_index + a[k]\n    return result", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k] if max_sum > 0 else a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k <= index:\n        return a[k]\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k <= index or index >= n or k >= n:\n        return 0\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_prefix_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_prefix_sum = max(max_prefix_sum, dp[i])\n    return max_prefix_sum + a[k]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.125}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n    \"\"\"\n    Write a function to convert a given string to a tuple of characters, excluding spaces.\n    assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the highest unset bit (i.e., the leftmost bit that is 0) in the binary representation of the number.\n    The function should traverse the bits from the highest bit position down to the lowest, find the first unset bit, set it to 1, and return the result.\n    If no unset bit is found below the highest bit, set the next higher bit.\n    assert set_left_most_unset_bit(10) == 14\n    \"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length() + 1\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i", "def set_left_most_unset_bit(n: int) -> int:\n    num_bits = n.bit_length()\n    for i in range(num_bits - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n | 1 << num_bits", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length() + 1\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n | 1 << bit_length", "def set_left_most_unset_bit(n: int) -> int:\n    mask = 1 << n.bit_length() + 1\n    while mask > 0:\n        if n & mask == 0:\n            return n | mask\n        mask >>= 1\n    return n | 1 << n.bit_length()", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            return n\n    return n | 1 << bit_length", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n | 1 << bit_length + 1", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if n & 1 << i == 0:\n            return n | 1 << i\n    return n | 1 << bit_length", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n | 1 << bit_length", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n | 1 << bit_length", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        mask = 1 << i\n        if not n & mask:\n            return n | mask\n    return n | 1 << bit_length"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/391", "requirement": "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    \"\"\"\n    Convert three lists of equal length into a list of nested dictionaries. Each element of the first list becomes a key in the outer dictionary, and the corresponding elements from the second and third lists form the inner dictionary. \n    \n    Args:\n        list1 (List[Any]): The list of keys for the outer dictionary.\n        list2 (List[Any]): The list of keys for the inner dictionary.\n        list3 (List[Any]): The list of values for the inner dictionary.\n    \n    Returns:\n        List[Dict[Any, Dict[Any, Any]]]: A list of nested dictionaries where each dictionary has the structure {list1[i]: {list2[i]: list3[i]}}.\n    \n    Raises:\n        IndexError: If the input lists are not of equal length.\n    \n    Examples:\n        >>> convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"], [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"], [85, 98, 89, 92])\n        [{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]\n        \n        >>> convert_list_dictionary([\"B001\", \"B002\"], [\"Alice Smith\"], [90, 95])\n        IndexError\n    \"\"\"", "generated_programs": ["from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('Input lists must be of equal length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('All input lists must have the same length.')\n    return [{key: {inner_key: value}} for key, inner_key, value in zip(list1, list2, list3)]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('Input lists are not of equal length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('The input lists are not of equal length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('Input lists must be of equal length.')\n    result = [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]\n    return result", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('Input lists are not of equal length')\n    return [{k: {l: m}} for k, l, m in zip(list1, list2, list3)]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError('Input lists are not of equal length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('Input lists are not of equal length.')\n    return [{key: {inner_key: value}} for key, inner_key, value in zip(list1, list2, list3)]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('Input lists must be of equal length.')\n    result = []\n    for i in range(len(list1)):\n        result.append({list1[i]: {list2[i]: list3[i]}})\n    return result", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise IndexError('All input lists must be of equal length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.6}}
{"task_id": "Mbpp/415", "requirement": "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Write a python function to find a pair with the highest product from a given array of integers.\n    The function should consider both the product of the two largest numbers and the product of the two smallest numbers (which could be higher if both are negative).\n    The function assumes that the input array will always have at least 2 elements. If the array has fewer than 2 elements, the function will raise an IndexError.\n    \n    Examples:\n    >>> max_Product([1, 2, 3, 4, 7, 0, 8, 4])\n    (7, 8)\n    >>> max_Product([5])\n    IndexError\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('Array must contain at least 2 elements.')\n    arr.sort()\n    max_product_pair = max((arr[0], arr[1]), (arr[-1], arr[-2]), key=lambda x: x[0] * x[1])\n    return max_product_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('Array must contain at least two elements.')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 >= product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('Array must have at least two elements')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 >= product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('Array must have at least 2 elements.')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 >= product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must have at least 2 elements.')\n    arr.sort()\n    max_product_pair = arr[-1] * arr[-2]\n    min_product_pair = arr[0] * arr[1]\n    if max_product_pair > min_product_pair:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('Array must have at least 2 elements.')\n    arr.sort()\n    max_pair = max((arr[0], arr[1]), (arr[-1], arr[-2]), key=lambda pair: pair[0] * pair[1])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('Array must have at least 2 elements.')\n    arr.sort()\n    max_1, max_2 = (arr[-1], arr[-2])\n    min_1, min_2 = (arr[0], arr[1])\n    if max_1 * max_2 > min_1 * min_2:\n        return (max_1, max_2)\n    else:\n        return (min_1, min_2)", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must have at least 2 elements.')\n    arr.sort()\n    max1, max2 = (arr[-1], arr[-2])\n    min1, min2 = (arr[0], arr[1])\n    if max1 * max2 > min1 * min2:\n        return (max2, max1)\n    else:\n        return (min1, min2)", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('Input array must have at least 2 elements.')\n    arr.sort()\n    max_product_positives = arr[-1] * arr[-2]\n    max_product_negatives = arr[0] * arr[1]\n    if max_product_positives > max_product_negatives:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('Array must have at least 2 elements')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 > product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find the directrix of a parabola given in the standard form \\( y = ax^2 + bx + c \\).\n    The directrix is calculated using the formula derived from the standard form:\n    - \\( h = -b / (2 * a) \\)\n    - \\( k = c - b^2 / (4 * a) \\)\n    - \\( directrix = k - 1 / (4 * a) \\)\n    The result should be converted to an integer by truncating the decimal part.\n    assert parabola_directrix(5,3,2)==-198\n    \"\"\"", "generated_programs": ["import math\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return math.trunc(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "import math\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return math.trunc(directrix)", "import math\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return math.trunc(directrix)", "from typing import int\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "import math\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return math.trunc(directrix)", "import math\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return math.trunc(directrix)", "from math import trunc\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return trunc(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first (n + 1) Perrin numbers, including the nth Perrin number.\n    \n    The Perrin sequence is defined as follows:\n    - P(0) = 3, P(1) = 0, P(2) = 2\n    - P(n) = P(n-2) + P(n-3) for n >= 3\n    \n    Edge cases:\n    - If n == 0, return 0.\n    - If n == 1, return 2.\n    - If n == 2, return 3.\n    \n    Input validation:\n    - The function does not handle negative inputs and will raise an IndexError if n is negative.\n    \n    Args:\n        n (int): The index of the Perrin number up to which the sum is calculated.\n        \n    Returns:\n        int: The sum of the first (n + 1) Perrin numbers.\n        \n    Examples:\n        >>> cal_sum(2)\n        3\n        >>> cal_sum(-1)\n        IndexError\n        >>> cal_sum(0)\n        0\n    \"\"\"\n    assert cal_sum(9) == 49", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Negative indices are not allowed')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index should not be negative.')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input cannot be negative')\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('The input must be a non-negative integer!')\n    perrin_sequence = [3, 0, 2]\n    if n < 3:\n        return sum(perrin_sequence[:n + 1])\n    for i in range(3, n + 1):\n        perrin_sequence.append(perrin_sequence[i - 2] + perrin_sequence[i - 3])\n    return sum(perrin_sequence)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Negative index is not allowed')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin_sequence = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin_sequence.append(perrin_sequence[i - 2] + perrin_sequence[i - 3])\n    return sum(perrin_sequence)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Negative index is not allowed.')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "from typing import List\n\ndef cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin: List[int] = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "from typing import List\n\ndef cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    perrin_sequence: List[int] = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin_sequence.append(perrin_sequence[i - 2] + perrin_sequence[i - 3])\n    return sum(perrin_sequence[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Negative index is not allowed for the Perrin sequence.')\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of even positive factors of a given positive integer.\n    The function should return 0 for non-positive integers or invalid inputs (e.g., negative numbers or zero).\n    Factors are defined as positive divisors of the number, and the range of factors considered should be from 1 to the number itself (inclusive).\n    \n    Examples:\n    >>> sumofFactors(18)\n    26\n    >>> sumofFactors(-12)\n    0\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n <= 0 or not isinstance(n, int):\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n <= 0 or not isinstance(n, int):\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches any word containing the letter 'z' anywhere within it, regardless of its position in the word. The function should respect word boundaries and only match 'z' as part of a word, not as part of non-word characters.\n\n    Examples:\n    >>> text_match_wordz(\"pythonz.\")\n    True\n    >>> text_match_wordz(\"amazing\")\n    True\n    >>> text_match_wordz(\"zebra\")\n    True\n    >>> text_match_wordz(\"hello\")\n    False\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    pattern = '\\\\b\\\\w*z\\\\w*\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, i)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for size in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, size)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import chain, combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    return [list(comb) for comb in chain.from_iterable((combinations(lst, r) for r in range(len(lst) + 1)))]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, i)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, i)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(comb) for comb in combinations(lst, r)])\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/465", "requirement": "def drop_empty(dict1: dict) -> dict:\n    \"\"\"\n    Write a function to drop items from a given dictionary where the value is None.\n\n    Parameters:\n    dict1 (dict): The input dictionary from which items with None values will be removed.\n\n    Returns:\n    dict: A new dictionary with all key-value pairs retained except those where the value is None.\n\n    Examples:\n    >>> drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None})\n    {'c1': 'Red', 'c2': 'Green'}\n    \"\"\"", "generated_programs": ["def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "from typing import Dict\n\ndef drop_empty(dict1: Dict) -> Dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "from typing import Dict\n\ndef drop_empty(dict1: Dict) -> Dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "from typing import Dict\n\ndef drop_empty(dict1: Dict) -> Dict:\n    return {key: value for key, value in dict1.items() if value is not None}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product formed by multiplying all numbers of the longest increasing subsequence in the array.\n    The function should consider the entire subsequence to calculate the product, not just any subset of the subsequence.\n    assert max_product([3, 100, 4, 5, 150, 6]) == 3000\n    \"\"\"", "generated_programs": ["from typing import List\nfrom math import prod\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    parent = [-1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i] and dp[j] + 1 > dp[i]:\n                dp[i] = dp[j] + 1\n                parent[i] = j\n    max_length = max(dp)\n    index = dp.index(max_length)\n    lis = []\n    while index != -1:\n        lis.append(arr[index])\n        index = parent[index]\n    return prod(lis[::-1])", "from typing import List\nfrom math import prod\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    product = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i] and dp[j] + 1 > dp[i]:\n                dp[i] = dp[j] + 1\n                product[i] = product[j] * arr[i]\n        if product[i] == 1:\n            product[i] = arr[i]\n    max_len = max(dp)\n    max_product = 0\n    for i in range(n):\n        if dp[i] == max_len:\n            max_product = max(max_product, product[i])\n    return max_product", "from typing import List\nfrom math import prod\n\ndef max_product(arr: List[int]) -> int:\n\n    def longest_increasing_subsequence(arr: List[int]) -> List[int]:\n        n = len(arr)\n        dp = [1] * n\n        prev = [-1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n        max_length_index = dp.index(max(dp))\n        lis = []\n        while max_length_index != -1:\n            lis.append(arr[max_length_index])\n            max_length_index = prev[max_length_index]\n        return lis[::-1]\n    lis = longest_increasing_subsequence(arr)\n    return prod(lis)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n\n    def longest_increasing_subsequence(arr: List[int]) -> List[int]:\n        n = len(arr)\n        dp = [1] * n\n        prev = [-1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n        max_length = max(dp)\n        idx = dp.index(max_length)\n        lis = []\n        while idx != -1:\n            lis.append(arr[idx])\n            idx = prev[idx]\n        return lis[::-1]\n    lis = longest_increasing_subsequence(arr)\n    product = 1\n    for num in lis:\n        product *= num\n    return product", "from typing import List\nfrom math import prod\n\ndef max_product(arr: List[int]) -> int:\n\n    def longest_increasing_subsequence(nums):\n        n = len(nums)\n        lis = [[num] for num in nums]\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i] and len(lis[j]) + 1 > len(lis[i]):\n                    lis[i] = lis[j] + [nums[i]]\n        return max(lis, key=len)\n    sequence = longest_increasing_subsequence(arr)\n    return prod(sequence)", "from typing import List\nfrom math import prod\n\ndef max_product(arr: List[int]) -> int:\n\n    def find_longest_increasing_subsequence(nums: List[int]) -> List[int]:\n        n = len(nums)\n        dp = [[] for _ in range(n)]\n        for i in range(n):\n            dp[i].append(nums[i])\n            for j in range(i):\n                if nums[j] < nums[i] and len(dp[j]) + 1 > len(dp[i]):\n                    dp[i] = dp[j] + [nums[i]]\n        lis = max(dp, key=len)\n        return lis\n    lis = find_longest_increasing_subsequence(arr)\n    return prod(lis)", "from typing import List\nfrom math import prod\n\ndef max_product(arr: List[int]) -> int:\n\n    def longest_increasing_subsequence(nums):\n        n = len(nums)\n        lis = [1] * n\n        parent = [-1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i] and lis[j] + 1 > lis[i]:\n                    lis[i] = lis[j] + 1\n                    parent[i] = j\n        max_len_index = lis.index(max(lis))\n        subsequence = []\n        current = max_len_index\n        while current != -1:\n            subsequence.append(nums[current])\n            current = parent[current]\n        subsequence.reverse()\n        return subsequence\n    increasing_subsequence = longest_increasing_subsequence(arr)\n    return prod(increasing_subsequence)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n\n    def longest_increasing_subsequence(nums: List[int]) -> List[int]:\n        n = len(nums)\n        dp = [1] * n\n        prev = [-1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i] and dp[i] < dp[j] + 1:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n        max_length_idx = max(range(n), key=lambda x: dp[x])\n        lis = []\n        while max_length_idx != -1:\n            lis.append(nums[max_length_idx])\n            max_length_idx = prev[max_length_idx]\n        return lis[::-1]\n    lis = longest_increasing_subsequence(arr)\n    product = 1\n    for num in lis:\n        product *= num\n    return product", "from typing import List\nfrom math import prod\n\ndef max_product(arr: List[int]) -> int:\n\n    def longest_increasing_subsequence(arr: List[int]) -> List[int]:\n        n = len(arr)\n        dp = [1] * n\n        prev = [-1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j] and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n        max_length_idx = max(range(n), key=lambda x: dp[x])\n        lis = []\n        while max_length_idx != -1:\n            lis.append(arr[max_length_idx])\n            max_length_idx = prev[max_length_idx]\n        return lis[::-1]\n    lis = longest_increasing_subsequence(arr)\n    return prod(lis)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n\n    def longest_increasing_subsequence(arr: List[int]) -> List[int]:\n        n = len(arr)\n        lis = [1] * n\n        prev = [-1] * n\n        for i in range(n):\n            for j in range(i):\n                if arr[j] < arr[i] and lis[j] + 1 > lis[i]:\n                    lis[i] = lis[j] + 1\n                    prev[i] = j\n        max_length_idx = max(range(n), key=lambda x: lis[x])\n        subseq = []\n        while max_length_idx != -1:\n            subseq.append(arr[max_length_idx])\n            max_length_idx = prev[max_length_idx]\n        return subseq[::-1]\n    increasing_subsequence = longest_increasing_subsequence(arr)\n    product = 1\n    for num in increasing_subsequence:\n        product *= num\n    return product"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/471", "requirement": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function to find the remainder of the product of all elements in the array when divided by n.\n    The product is computed first by multiplying all elements in the array, and then the modulo operation is applied to the final product.\n    If the array is empty, the function should return 1 % n, which is 1, as the product of an empty list is considered to be 1.\n    assert find_remainder([100, 10, 5, 25, 35, 14], 11) == 9\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\nfrom functools import reduce\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    return reduce(lambda x, y: x * y % n, arr, 1) % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    result = 1\n    for num in arr:\n        result = result * num % n\n    return result % n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/479", "requirement": "def first_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the first digit of a given number. \n    For negative numbers, the first digit should include the negative sign and the first numerical digit (e.g., for -456, the first digit is -4).\n    The function should return the number itself if it is a single-digit number (including negative single-digit numbers).\n    assert first_Digit(123) == 1\n    assert first_Digit(-456) == -4\n    assert first_Digit(-7) == -7\n    \"\"\"", "generated_programs": ["def first_Digit(n: int) -> int:\n    num_str = str(n)\n    if len(num_str) == 1 or (len(num_str) == 2 and num_str.startswith('-')):\n        return n\n    return int(num_str[0]) if n > 0 else int(num_str[:2])", "def first_Digit(n: int) -> int:\n    if abs(n) < 10:\n        return n\n    else:\n        str_n = str(n)\n        return int(str_n[:2]) if n < 0 else int(str_n[0])", "def first_Digit(n: int) -> int:\n    if -10 < n < 10:\n        return n\n    str_n = str(n)\n    return int(str_n[:2]) if n < 0 else int(str_n[0])", "def first_Digit(n: int) -> int:\n    if -10 < n < 10:\n        return n\n    str_n = str(n)\n    if n < 0:\n        return int(str_n[:2])\n    return int(str_n[0])", "def first_Digit(n: int) -> int:\n    if abs(n) < 10:\n        return n\n    while abs(n) >= 10:\n        n = int(n / 10)\n    return n", "def first_Digit(n: int) -> int:\n    if -10 < n < 10:\n        return n\n    str_n = str(n)\n    return int(str_n[0]) if n > 0 else int(str_n[:2])", "def first_Digit(n: int) -> int:\n    if -10 < n < 10:\n        return n\n    str_n = str(n)\n    if n < 0:\n        return int(str_n[:2])\n    else:\n        return int(str_n[0])", "def first_Digit(n: int) -> int:\n    if -10 < n < 10:\n        return n\n    elif n < 0:\n        return int(str(n)[0:2])\n    else:\n        return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    if abs(n) < 10:\n        return n\n    str_n = str(n)\n    if n < 0:\n        return int(str_n[:2])\n    return int(str_n[0])", "def first_Digit(n: int) -> int:\n    if -10 < n < 10:\n        return n\n    abs_n = abs(n)\n    first_digit = int(str(abs_n)[0])\n    return first_digit if n > 0 else -first_digit"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/558", "requirement": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of the absolute differences between corresponding digits of two integers.\n    The function should pad the shorter integer with leading zeros to make the lengths equal before performing the comparison.\n    \n    Examples:\n    >>> digit_distance_nums(100, 1)\n    2\n    >>> digit_distance_nums(1, 2)\n    1\n    \"\"\"", "generated_programs": ["def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    return sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    n1_str, n2_str = (str(n1), str(n2))\n    max_len = max(len(n1_str), len(n2_str))\n    n1_str = n1_str.zfill(max_len)\n    n2_str = n2_str.zfill(max_len)\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(n1_str, n2_str)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    n1_str = str(n1)\n    n2_str = str(n2)\n    max_len = max(len(n1_str), len(n2_str))\n    n1_str = n1_str.zfill(max_len)\n    n2_str = n2_str.zfill(max_len)\n    return sum((abs(int(a) - int(b)) for a, b in zip(n1_str, n2_str)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str1, str2 = (str(n1), str(n2))\n    max_length = max(len(str1), len(str2))\n    str1, str2 = (str1.zfill(max_length), str2.zfill(max_length))\n    return sum((abs(int(a) - int(b)) for a, b in zip(str1, str2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    n1_str, n2_str = (str(n1), str(n2))\n    max_len = max(len(n1_str), len(n2_str))\n    n1_str = n1_str.zfill(max_len)\n    n2_str = n2_str.zfill(max_len)\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(n1_str, n2_str)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    n1_str, n2_str = (str(n1), str(n2))\n    max_len = max(len(n1_str), len(n2_str))\n    n1_str = n1_str.zfill(max_len)\n    n2_str = n2_str.zfill(max_len)\n    return sum((abs(int(a) - int(b)) for a, b in zip(n1_str, n2_str)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    n1_str, n2_str = (str(n1), str(n2))\n    max_len = max(len(n1_str), len(n2_str))\n    n1_str, n2_str = (n1_str.zfill(max_len), n2_str.zfill(max_len))\n    return sum((abs(int(a) - int(b)) for a, b in zip(n1_str, n2_str)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    n1_str = str(n1)\n    n2_str = str(n2)\n    max_len = max(len(n1_str), len(n2_str))\n    n1_str = n1_str.zfill(max_len)\n    n2_str = n2_str.zfill(max_len)\n    return sum((abs(int(a) - int(b)) for a, b in zip(n1_str, n2_str)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str1, str2 = (str(n1), str(n2))\n    max_len = max(len(str1), len(str2))\n    str1 = str1.zfill(max_len)\n    str2 = str2.zfill(max_len)\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str1, str2)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/559", "requirement": "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum of any contiguous sublist in the given list.\n    The function should handle edge cases such as an empty list by returning negative infinity.\n    \n    Parameters:\n    a (List[int]): The list of integers.\n    size (int): The size of the list.\n    \n    Returns:\n    int: The maximum sum of any contiguous sublist. If the list is empty, returns negative infinity.\n    \n    Examples:\n    >>> max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8)\n    7\n    >>> max_sub_array_sum([], 0)\n    -inf\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    from math import inf\n    if size == 0:\n        return -inf\n    max_sum = -inf\n    current_sum = 0\n    for num in a:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return float('-inf')\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_sum = -math.inf\n    current_sum = 0\n    for value in a:\n        current_sum = max(value, current_sum + value)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return float('-inf')\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return float('-inf')\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    from math import inf\n    if size == 0:\n        return -inf\n    max_sum = -inf\n    current_sum = 0\n    for num in a:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return float('-inf')\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/563", "requirement": "def extract_values(text: str) -> List[str]:\n    \"\"\"Extract all substrings that are enclosed within double quotation marks from the input string.\n    Each substring should be captured without the surrounding quotes.\n    assert extract_values('\"Python\", \"PHP\", \"Java\"')==['Python', 'PHP', 'Java']\n    \"\"\"", "generated_programs": ["import re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"([^\"]*)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"([^\"]+)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "import re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\\\\\"(.*?)\\\\\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "import re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "def count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Counts the number of unordered pairs (i, j) in the list `arr` where `i < j` and `arr[i] != arr[j]`.\n    The function takes a list of integers `arr` and an integer `n` representing the length of the list.\n    assert count_Pairs([1,2,1],3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    pair_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                pair_count += 1\n    return pair_count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/579", "requirement": "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    \"\"\"\n    Write a function to find the dissimilar elements in the given two tuples and return them in sorted order.\n    \n    The function should return a tuple containing elements that are not common between the two input tuples, \n    sorted in ascending order.\n    \n    assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(set(test_tup2))))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1) ^ set(test_tup2)))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(test_tup2)))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1) ^ set(test_tup2)))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(set(test_tup2))))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(set(test_tup2))))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(set(test_tup2))))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(test_tup2)))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(set(test_tup2))))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(set(test_tup2))))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.9}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Write a function to remove uneven integer elements in the nested mixed tuple. \n    The function should recursively process nested tuples and only retain even integers. \n    Non-integer types (e.g., floats, strings) should be removed from the result unless they are nested tuples, which are processed recursively.\n    \n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_tuple(t):\n        result = []\n        for item in t:\n            if isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n            elif isinstance(item, tuple):\n                result.append(filter_tuple(item))\n        return tuple(result)\n    return filter_tuple(test_tuple)", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def filter_even(item):\n        if isinstance(item, tuple):\n            return tuple((filter_even(sub_item) for sub_item in item if isinstance(sub_item, (int, tuple))))\n        elif isinstance(item, int) and item % 2 == 0:\n            return item\n        return None\n    return tuple((filter_even(item) for item in test_tuple if isinstance(item, (int, tuple)) and (isinstance(item, int) and item % 2 == 0 or isinstance(item, tuple))))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even_elements(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            return True\n        return False\n\n    def process_tuple(input_tuple):\n        result = []\n        for item in input_tuple:\n            if isinstance(item, tuple):\n                nested_result = process_tuple(item)\n                if nested_result:\n                    result.append(tuple(nested_result))\n            elif filter_even_elements(item):\n                result.append(item)\n        return result\n    return tuple(process_tuple(test_tuple))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return element\n        elif isinstance(element, tuple):\n            return tuple(filter(None, (process_element(sub_elem) for sub_elem in element)))\n        return None\n    return tuple(filter(None, (process_element(elem) for elem in test_tuple)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_tuple(item):\n        if isinstance(item, int):\n            return item % 2 == 0\n        elif isinstance(item, tuple):\n            return True\n        return False\n\n    def process_tuple(item):\n        if isinstance(item, tuple):\n            return tuple((process_tuple(sub_item) for sub_item in item if filter_tuple(sub_item)))\n        elif isinstance(item, int) and item % 2 == 0:\n            return item\n    return process_tuple(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def recursive_filter(item):\n        if isinstance(item, int):\n            return item % 2 == 0\n        elif isinstance(item, tuple):\n            return tuple((recursive_filter(sub_item) for sub_item in item if recursive_filter(sub_item)))\n        return False\n    return tuple((recursive_filter(element) for element in test_tuple if recursive_filter(element)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_tuple(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                result.append(process_tuple(item))\n            elif isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n        return tuple(result)\n    return process_tuple(test_tuple)", "from typing import Tuple\n\ndef extract_even(test_tuple: tuple) -> tuple:\n\n    def process_tuple(t: tuple) -> tuple:\n        result = []\n        for element in t:\n            if isinstance(element, int) and element % 2 == 0:\n                result.append(element)\n            elif isinstance(element, tuple):\n                result.append(process_tuple(element))\n        return tuple(result)\n    return process_tuple(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return element\n        elif isinstance(element, tuple):\n            return tuple(filter(None, map(process_element, element)))\n        return None\n    return tuple(filter(None, map(process_element, test_tuple)))", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def process_nested(item):\n        if isinstance(item, tuple):\n            return tuple((process_nested(subitem) for subitem in item if isinstance(subitem, int) and subitem % 2 == 0 or isinstance(subitem, tuple)))\n        elif isinstance(item, int) and item % 2 == 0:\n            return item\n    return tuple((process_nested(item) for item in test_tuple if isinstance(item, int) and item % 2 == 0 or isinstance(item, tuple)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.6, "original_passk": 0.7}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n    \"\"\"\n    Write a Python function to find the surface area of a square pyramid with a given base edge `b` and slant height `s`.\n    The surface area is calculated using the formula: b ** 2 + 2 * b * s.\n    assert surface_Area(3, 4) == 33\n    \"\"\"", "generated_programs": ["from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/583", "requirement": "def catalan_number(num: int) -> int:\n    \"\"\"\n    Write a function which returns the nth Catalan number. The function should raise a ValueError if the input is a negative integer.\n    \n    Args:\n        num (int): The index of the Catalan number to compute.\n    \n    Returns:\n        int: The nth Catalan number.\n    \n    Raises:\n        ValueError: If the input is a negative integer.\n    \n    Examples:\n        >>> catalan_number(10)\n        16796\n        >>> catalan_number(-1)\n        ValueError\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('The input cannot be a negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import factorial\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return factorial(2 * num) // (factorial(num + 1) * factorial(num))", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import factorial\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('The input cannot be a negative integer.')\n    return factorial(2 * num) // (factorial(num + 1) * factorial(num))", "from math import factorial\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('The input is a negative integer')\n    return factorial(2 * num) // (factorial(num + 1) * factorial(num))", "import math\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input cannot be a negative integer')\n    return math.comb(2 * num, num) // (num + 1)", "import math\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('The input must be a non-negative integer.')\n    return math.comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer')\n    return comb(2 * num, num) // (num + 1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Given rectangular coordinates (x, y), calculate and return both polar coordinates (radius, angle) and the original rectangular coordinates as a complex number.\n    \n    The polar coordinates are calculated as follows:\n    - Radius (r) is the Euclidean distance from the origin to the point (x, y).\n    - Angle (theta) is the angle in radians between the positive x-axis and the line connecting the origin to the point (x, y).\n    \n    The function returns a tuple containing:\n    - A tuple of polar coordinates (r, theta).\n    - The original rectangular coordinates as a complex number (x + yj).\n    \n    Examples:\n    >>> polar_rect(3, 4)\n    ((5.0, 0.9272952180016122), (3+4j))\n    \"\"\"", "generated_programs": ["from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    polar_coords = (r, theta)\n    rect_coords = complex(x, y)\n    return (polar_coords, rect_coords)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    polar_coordinates = (r, theta)\n    rectangular_as_complex = complex(x, y)\n    return (polar_coordinates, rectangular_as_complex)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    polar_coordinates = (r, theta)\n    rectangular_as_complex = complex(x, y)\n    return (polar_coordinates, rectangular_as_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    radius = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coordinates = (radius, angle)\n    rectangular_coordinates = complex(x, y)\n    return (polar_coordinates, rectangular_coordinates)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    polar_coordinates = (r, theta)\n    rectangular_complex = complex(x, y)\n    return (polar_coordinates, rectangular_complex)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    radius = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coordinates = (radius, angle)\n    rectangular_coordinates = complex(x, y)\n    return (polar_coordinates, rectangular_coordinates)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/592", "requirement": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given integer n.\n    Specifically, the function computes the sum of the product of C(n, i) and C(n, i+1) for i ranging from 0 to n-1.\n    assert sum_Of_product(3) == 15\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the difference between the first even and first odd number of a given list.\n    If either the first even or the first odd number is not found, the function should return 0.\n    \n    Examples:\n    >>> assert diff_even_odd([1,3,5,7,4,1,6,8]) == 3\n    >>> assert diff_even_odd([2,4,6,8,10]) == 0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        return 0\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        return 0\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    return even - odd if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 == 1:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        return 0\n    return abs(even - odd)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the k-th smallest element in the merged sorted array of the given two sorted arrays.\n    The merged sorted array is formed by combining `arr1` and `arr2` in sorted order, considering all elements including duplicates.\n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(a: List[int], b: List[int], k: int) -> int:\n        len_a, len_b = (len(a), len(b))\n        if len_a > len_b:\n            return kth_element(b, a, k)\n        if len_a == 0:\n            return b[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        index_a = min(len_a, k // 2)\n        index_b = k - index_a\n        if index_b > len_b:\n            index_a = k - len_b\n            index_b = len_b\n        if k > len_a + len_b:\n            raise ValueError('k exceeds the total number of elements')\n        value_a, value_b = (a[index_a - 1], b[index_b - 1])\n        if value_a == value_b:\n            return value_a\n        elif value_a < value_b:\n            return kth_element(a[index_a:], b, k - index_a)\n        else:\n            return kth_element(a, b[index_b:], k - index_b)\n    return kth_element(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(arr1, arr2, k):\n        if not arr1:\n            return arr2[k - 1]\n        if not arr2:\n            return arr1[k - 1]\n        if k == 1:\n            return min(arr1[0], arr2[0])\n        mid1 = len(arr1) // 2\n        mid2 = len(arr2) // 2\n        if mid1 + mid2 < k - 1:\n            if arr1[mid1] > arr2[mid2]:\n                return kth_element(arr1, arr2[mid2 + 1:], k - mid2 - 1)\n            else:\n                return kth_element(arr1[mid1 + 1:], arr2, k - mid1 - 1)\n        elif arr1[mid1] > arr2[mid2]:\n            return kth_element(arr1[:mid1], arr2, k)\n        else:\n            return kth_element(arr1, arr2[:mid2], k)\n    return kth_element(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def find_kth_element_from_sorted_arrays(a, b, k):\n        m, n = (len(a), len(b))\n        if m > n:\n            return find_kth_element_from_sorted_arrays(b, a, k)\n        if m == 0:\n            return b[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        idx_a = min(m, k // 2)\n        idx_b = k - idx_a\n        if a[idx_a - 1] <= b[idx_b - 1]:\n            return find_kth_element_from_sorted_arrays(a[idx_a:], b, k - idx_a)\n        else:\n            return find_kth_element_from_sorted_arrays(a, b[idx_b:], k - idx_b)\n    return find_kth_element_from_sorted_arrays(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(a, b, k):\n        len_a, len_b = (len(a), len(b))\n        if len_a > len_b:\n            return kth_element(b, a, k)\n        if len_a == 0:\n            return b[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        idx_a, idx_b = (min(len_a, k // 2), min(len_b, k // 2))\n        if a[idx_a - 1] <= b[idx_b - 1]:\n            return kth_element(a[idx_a:], b, k - idx_a)\n        else:\n            return kth_element(a, b[idx_b:], k - idx_b)\n    return kth_element(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(a, b, k):\n        len_a, len_b = (len(a), len(b))\n        if len_a > len_b:\n            return kth_element(b, a, k)\n        if len_a == 0:\n            return b[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        pa = min(len_a, k // 2)\n        pb = k - pa\n        if a[pa - 1] <= b[pb - 1]:\n            return kth_element(a[pa:], b, k - pa)\n        else:\n            return kth_element(a, b[pb:], k - pb)\n    return kth_element(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def find_kth_util(a, b, k):\n        len_a, len_b = (len(a), len(b))\n        if len_a > len_b:\n            return find_kth_util(b, a, k)\n        if not a:\n            return b[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        idx_a = min(len_a, k // 2)\n        idx_b = k - idx_a\n        if a[idx_a - 1] <= b[idx_b - 1]:\n            return find_kth_util(a[idx_a:], b, k - idx_a)\n        else:\n            return find_kth_util(a, b[idx_b:], k - idx_b)\n    return find_kth_util(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_smallest(arr1, arr2, k):\n        len1, len2 = (len(arr1), len(arr2))\n        if len1 > len2:\n            return kth_smallest(arr2, arr1, k)\n        if len1 == 0:\n            return arr2[k - 1]\n        if k == 1:\n            return min(arr1[0], arr2[0])\n        idx1 = min(len1, k // 2)\n        idx2 = k - idx1\n        pivot1 = arr1[idx1 - 1]\n        pivot2 = arr2[idx2 - 1]\n        if pivot1 <= pivot2:\n            return kth_smallest(arr1[idx1:], arr2, k - idx1)\n        else:\n            return kth_smallest(arr1, arr2[idx2:], k - idx2)\n    return kth_smallest(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(arr1, arr2, k):\n        if not arr1:\n            return arr2[k - 1]\n        if not arr2:\n            return arr1[k - 1]\n        if k == 1:\n            return min(arr1[0], arr2[0])\n        mid_idx = k // 2 - 1\n        mid1 = arr1[mid_idx] if mid_idx < len(arr1) else float('inf')\n        mid2 = arr2[mid_idx] if mid_idx < len(arr2) else float('inf')\n        if mid1 < mid2:\n            return kth_element(arr1[mid_idx + 1:], arr2, k - (mid_idx + 1))\n        else:\n            return kth_element(arr1, arr2[mid_idx + 1:], k - (mid_idx + 1))\n    return kth_element(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_helper(a, b, k):\n        if not a:\n            return b[k - 1]\n        if not b:\n            return a[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        idx_a, idx_b = (min(len(a), k // 2) - 1, min(len(b), k // 2) - 1)\n        if a[idx_a] <= b[idx_b]:\n            return kth_helper(a[idx_a + 1:], b, k - idx_a - 1)\n        else:\n            return kth_helper(a, b[idx_b + 1:], k - idx_b - 1)\n    return kth_helper(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(arr1, arr2, k):\n        if not arr1:\n            return arr2[k - 1]\n        if not arr2:\n            return arr1[k - 1]\n        if k == 1:\n            return min(arr1[0], arr2[0])\n        mid1 = len(arr1) // 2\n        mid2 = len(arr2) // 2\n        median1 = arr1[mid1]\n        median2 = arr2[mid2]\n        if mid1 + mid2 < k - 1:\n            if median1 < median2:\n                return kth_element(arr1[mid1 + 1:], arr2, k - mid1 - 1)\n            else:\n                return kth_element(arr1, arr2[mid2 + 1:], k - mid2 - 1)\n        elif median1 < median2:\n            return kth_element(arr1, arr2[:mid2], k)\n        else:\n            return kth_element(arr1[:mid1], arr2, k)\n    return kth_element(arr1, arr2, k)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/602", "requirement": "def first_repeated_char(str1: str) -> str:\n    \"\"\"\n    Write a python function to find the first repeated character in a given string. \n    If no repeated character is found, the function should return an empty string ''.\n    assert first_repeated_char(\"abcabc\") == \"a\"\n    \"\"\"", "generated_programs": ["def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "from typing import Optional\n\ndef first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/604", "requirement": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse the order of words in a given string, where words are separated by one or more spaces. \n    Leading, trailing, and multiple spaces between words should be normalized to a single space in the output.\n    assert reverse_words(\"python program\")==(\"program python\")\n    \"\"\"", "generated_programs": ["def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(s.split()[::-1])", "import re\n\ndef reverse_words(s: str) -> str:\n    return ' '.join(reversed(re.split('\\\\s+', s.strip())))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/620", "requirement": "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    \"\"\"\n    Write a function to find the size of the largest subset of a list of numbers such that for every pair of numbers in the subset, one number is divisible by the other. \n    The function should return 0 if the input list is empty.\n    \n    Examples:\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n    \"\"\"\n    Write a Python function to find the area of the largest right-angled triangle that can be inscribed in a semicircle with a given radius. \n    The largest right-angled triangle inscribed in a semicircle has its hypotenuse as the diameter of the semicircle.\n    The area of such a triangle is given by the formula: radius^2 * 2.\n    If the radius is negative, the function should return None.\n    assert triangle_area(-1) == None\n    \"\"\"", "generated_programs": ["def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius < 0:\n        return None\n    return radius ** 2 / 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius < 0:\n        return None\n    return radius ** 2", "from typing import Union\n\ndef triangle_area(radius: float) -> Union[float, None]:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/630", "requirement": "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given 2D coordinate tuple, including the original coordinate itself.\n    \n    The function should handle only tuples of length 2, representing 2D coordinates. For tuples of any other length, the function should raise a ValueError.\n    \n    The adjacent coordinates are defined as the 8 surrounding coordinates (including diagonals) and the original coordinate itself.\n    \n    Examples:\n    >>> get_coordinates((3, 4))\n    [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    \n    >>> get_coordinates((1, 1, 1))\n    ValueError\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('The tuple must have exactly two elements representing 2D coordinates.')\n    x, y = test_tup\n    coordinates = []\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            coordinates.append([x + dx, y + dy])\n    return coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('The tuple must have exactly two elements representing a 2D coordinate.')\n    x, y = test_tup\n    adjacent_coordinates = [[x - 1, y - 1], [x - 1, y], [x - 1, y + 1], [x, y - 1], [x, y], [x, y + 1], [x + 1, y - 1], [x + 1, y], [x + 1, y + 1]]\n    return adjacent_coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must be of length 2.')\n    x, y = test_tup\n    result = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            result.append([x + dx, y + dy])\n    return result", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Function only supports 2D coordinates.')\n    x, y = test_tup\n    result = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            result.append([x + dx, y + dy])\n    return result", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Only 2D coordinate tuples are supported')\n    x, y = test_tup\n    result = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            result.append([x + dx, y + dy])\n    return result", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must be of length 2 representing 2D coordinates.')\n    x, y = test_tup\n    result = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            result.append([x + i, y + j])\n    return result", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('The coordinate tuple must be of length 2.')\n    x, y = test_tup\n    adjacent_coordinates = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            adjacent_coordinates.append([x + i, y + j])\n    return adjacent_coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Only 2D coordinates are valid')\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input must be a 2D coordinate tuple of length 2.')\n    x, y = test_tup\n    neighbors = [[x + dx, y + dy] for dx in (-1, 0, 1) for dy in (-1, 0, 1)]\n    return neighbors", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must be of length 2.')\n    x, y = test_tup\n    adjacent_coordinates = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            adjacent_coordinates.append([x + dx, y + dy])\n    return adjacent_coordinates"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/631", "requirement": "def replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace all whitespaces with underscores in a given string.\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    \"\"\"", "generated_programs": ["def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the nearest integer given the wind velocity in km/h and a temperature in celsius.\n    assert wind_chill(120,35)==40\n    \"\"\"", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16)", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.4}}
{"task_id": "Mbpp/722", "requirement": "def filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    Filters the input dictionary of students, retaining only those whose height is greater than or equal to the minimum height `h` and whose weight is greater than or equal to the minimum weight `w`.\n    \n    The input is given as:\n    - a dictionary with a student name as a key and a tuple of floats (student_height, student_weight) as a value,\n    - a minimum height `h`,\n    - a minimum weight `w`.\n    \n    The function returns a new dictionary containing only the students who meet both the height and weight criteria.\n    \n    Example:\n    >>> filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70)\n    {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: stats for name, stats in students.items() if stats[0] >= h and stats[1] >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/735", "requirement": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Write a Python function to toggle the middle bits of the number, excluding the most significant bit (MSB) and the least significant bit (LSB) in its binary representation.\n    \n    - If the input number is 0, return 1.\n    - If the number has fewer than 3 bits, return the number as-is.\n    - For numbers with 3 or more bits, toggle all bits except the MSB and LSB.\n    \n    Examples:\n    >>> toggle_middle_bits(9)  # Binary: 1001 → 1111 (15)\n    15\n    >>> toggle_middle_bits(0)  # Binary: 0 → 1 (1)\n    1\n    >>> toggle_middle_bits(3)  # Binary: 11 → 11 (3)\n    3\n    \"\"\"", "generated_programs": ["def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_str = bin(n)[2:]\n    if len(binary_str) < 3:\n        return n\n    toggled_middle = ''.join(('1' if bit == '0' else '0' for bit in binary_str[1:-1]))\n    toggled_binary = binary_str[0] + toggled_middle + binary_str[-1]\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) < 3:\n        return n\n    middle_bits = binary_representation[1:-1]\n    toggled_middle_bits = ''.join(('1' if bit == '0' else '0' for bit in middle_bits))\n    new_binary = binary_representation[0] + toggled_middle_bits + binary_representation[-1]\n    return int(new_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) < 3:\n        return n\n    middle_bits = binary[1:-1]\n    toggled_middle_bits = ''.join(('0' if bit == '1' else '1' for bit in middle_bits))\n    toggled_binary = binary[0] + toggled_middle_bits + binary[-1]\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    length = len(binary_representation)\n    if length < 3:\n        return n\n    middle_bits = binary_representation[1:-1]\n    toggled_middle_bits = ''.join(('1' if bit == '0' else '0' for bit in middle_bits))\n    toggled_binary = binary_representation[0] + toggled_middle_bits + binary_representation[-1]\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) < 3:\n        return n\n    msb = binary[0]\n    lsb = binary[-1]\n    middle = ''.join(('1' if bit == '0' else '0' for bit in binary[1:-1]))\n    toggled_binary = msb + middle + lsb\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_rep = bin(n)[2:]\n    if len(binary_rep) < 3:\n        return n\n    toggled_middle = ''.join(('1' if bit == '0' else '0' for bit in binary_rep[1:-1]))\n    toggled_binary = binary_rep[0] + toggled_middle + binary_rep[-1]\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) < 3:\n        return n\n    middle = ''.join(('1' if bit == '0' else '0' for bit in binary[1:-1]))\n    toggled_binary = binary[0] + middle + binary[-1]\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_str = bin(n)[2:]\n    if len(binary_str) < 3:\n        return n\n    msb = binary_str[0]\n    lsb = binary_str[-1]\n    middle_bits = ''.join(('1' if bit == '0' else '0' for bit in binary_str[1:-1]))\n    toggled_binary = msb + middle_bits + lsb\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) < 3:\n        return n\n    toggled_binary = binary[0] + ''.join(('1' if b == '0' else '0' for b in binary[1:-1])) + binary[-1]\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) < 3:\n        return n\n    toggled = binary[0] + ''.join(('1' if b == '0' else '0' for b in binary[1:-1])) + binary[-1]\n    return int(toggled, 2)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/740", "requirement": "from typing import Dict, Tuple, Any\n\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    \"\"\"\n    Write a function to convert the given tuple to a dictionary where each pair of adjacent elements \n    is treated as a key-value pair. The function should iterate through the tuple in steps of 2, \n    creating a dictionary entry for each pair. If the tuple has an odd number of elements, \n    the last element should be ignored.\n\n    Example:\n    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/743", "requirement": "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotate a given list by a specified number of items to the right direction. \n    If the input list is empty, a ZeroDivisionError will be raised.\n\n    Args:\n        l (List[int]): The list to be rotated.\n        m (int): The number of items to rotate the list by.\n\n    Returns:\n        List[int]: The rotated list.\n\n    Raises:\n        ZeroDivisionError: If the input list is empty.\n\n    Examples:\n        >>> rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n        [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n        >>> rotate_right([], 3)\n        ZeroDivisionError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('The input list is empty.')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Input list is empty')\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Input list is empty and cannot be rotated.')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('The input list is empty.')\n    m %= len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Input list is empty.')\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Input list is empty.')\n    m %= len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('The input list is empty.')\n    m %= len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('The input list is empty.')\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('The input list is empty.')\n    m = m % len(l)\n    return l[-m:] + l[:-m]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\"\"\"\nWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. \nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(num: int) -> bool:\n        digits = [int(d) for d in str(num) if d != '0']\n        return all((num % digit == 0 for digit in digits))\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(num: int) -> bool:\n        digits = [int(d) for d in str(num) if d != '0']\n        return all((num % d == 0 for d in digits))\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(number: int) -> bool:\n        for digit_char in str(number):\n            digit = int(digit_char)\n            if digit == 0 or number % digit != 0:\n                return False\n        return True\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(num: int) -> bool:\n        digits = [int(d) for d in str(num) if d != '0']\n        return all((num % digit == 0 for digit in digits))\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(num: int) -> bool:\n        digits = [int(d) for d in str(num) if d != '0']\n        return all((num % digit == 0 for digit in digits))\n    return [n for n in range(startnum, endnum + 1) if is_divisible_by_digits(n)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(num: int) -> bool:\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                return False\n        return True\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(num: int) -> bool:\n        digits = [int(d) for d in str(num) if d != '0']\n        return all((num % d == 0 for d in digits))\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(n: int) -> bool:\n        for digit in str(n):\n            if digit == '0' or n % int(digit) != 0:\n                return False\n        return True\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(number: int) -> bool:\n        for digit in str(number):\n            if digit == '0' or number % int(digit) != 0:\n                return False\n        return True\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(num: int) -> bool:\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                return False\n        return True\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.5, "original_passk": 0.4}}
{"task_id": "Mbpp/752", "requirement": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Jacobsthal number using the recurrence relation:\n    J(n) = J(n-1) + 2 * J(n-2), with base cases J(0) = 0 and J(1) = 1.\n    The sequence of Jacobsthal numbers is: 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    \n    The function should handle non-negative integer inputs. For negative inputs, the function should return 1.\n    \n    assert jacobsthal_num(5) == 11\n    \"\"\"", "generated_programs": ["def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "from typing import Union\n\ndef jacobsthal_num(n: int) -> Union[int, None]:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "from typing import Optional\n\ndef jacobsthal_num(n: int) -> Optional[int]:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    J_prev = 1\n    J_prev2 = 0\n    for i in range(2, n + 1):\n        J_current = J_prev + 2 * J_prev2\n        J_prev2 = J_prev\n        J_prev = J_current\n    return J_prev", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    \"\"\"\n    Write a Python function to find the minimum difference between any two elements in a given array or tuple of integers.\n    The function should handle both lists and tuples as input and return the minimum difference as an integer.\n    \n    Examples:\n    >>> find_min_diff((1, 5, 3, 19, 18, 25), 6)\n    1\n    >>> find_min_diff([1, 5, 3, 19, 18, 25], 6)\n    1\n    \"\"\"", "generated_programs": ["from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, sorted_arr[i] - sorted_arr[i - 1])\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    arr = sorted(arr)\n    return min((arr[i + 1] - arr[i] for i in range(n - 1)))", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    if n < 2:\n        return 0\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, sorted_arr[i + 1] - sorted_arr[i])\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    if n <= 1:\n        return 0\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = abs(sorted_arr[i + 1] - sorted_arr[i])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    if n < 2:\n        return 0\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        diff = sorted_arr[i] - sorted_arr[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    if n < 2:\n        return 0\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, sorted_arr[i] - sorted_arr[i - 1])\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        diff = arr[i] - arr[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number using the formula: nth polite number = n + floor(log2(n + 1)) + 1.\n    A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers.\n    For more details, refer to: geeksforgeeks.org/n-th-polite-number/\n    \n    Parameters:\n    n (int): The position of the polite number in the sequence (1-based index).\n    \n    Returns:\n    int: The nth polite number.\n    \n    Examples:\n    >>> assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "from math import log2, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "from math import log2, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even number and the first odd number in a given list.\n    If either an even or an odd number is not found in the list, the function should return 0.\n    \n    Examples:\n    >>> mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8])\n    4\n    >>> mul_even_odd([2, 4, 6, 8])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if not even_found and num % 2 == 0:\n            first_even = num\n            even_found = True\n        if not odd_found and num % 2 != 0:\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_num = next((x for x in list1 if x % 2 == 0), None)\n    odd_num = next((x for x in list1 if x % 2 != 0), None)\n    if even_num is None or odd_num is None:\n        return 0\n    return even_num * odd_num", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if not even_found and num % 2 == 0:\n            first_even = num\n            even_found = True\n        if not odd_found and num % 2 != 0:\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if not even_found and num % 2 == 0:\n            first_even = num\n            even_found = True\n        if not odd_found and num % 2 != 0:\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            break\n    if even_found and odd_found:\n        return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if num % 2 == 0 and (not even_found):\n            first_even = num\n            even_found = True\n        elif num % 2 != 0 and (not odd_found):\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if not even_found and num % 2 == 0:\n            first_even = num\n            even_found = True\n        if not odd_found and num % 2 != 0:\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            return first_even * first_odd\n    return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/785", "requirement": "def tuple_str_int(test_str: str) -> tuple:\n    \"\"\"\n    Write a function to convert a tuple string to a tuple of integers. The function should strip the parentheses from the string, split the string by commas, and explicitly convert each element to an integer.\n    assert tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)\n    \"\"\"", "generated_programs": ["def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    test_str = test_str.strip('()')\n    return tuple(map(int, test_str.split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    test_str = test_str.strip('()')\n    return tuple(map(int, test_str.split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    stripped_str = test_str.strip('()')\n    int_elements = map(int, stripped_str.split(','))\n    return tuple(int_elements)", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    stripped = test_str.strip('()')\n    split_values = stripped.split(', ')\n    return tuple(map(int, split_values))", "from typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, ...]:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "from typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, ...]:\n    return tuple(map(int, test_str.strip('()').split(',')))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/787", "requirement": "def text_match_three(text: str) -> re.Match:\n\"\"\"\nWrite a function that matches a string that has an a followed by three 'b'.\nassert not text_match_three(\"ac\")\n\"\"\"", "generated_programs": ["import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.fullmatch('a{1}b{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('a(b{3})', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('a(b{3})$', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('a{1}b{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('a(?:bb){3}$', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('a(b{3})$', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.fullmatch('a(?:b{3})', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.fullmatch('a(b{3})', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('a(b{3})', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('a(b{3})', text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches a string that starts with 'a', is immediately followed by 'b', and ends with 'b'. The string must contain at least two characters: 'a' and 'b', and the last character must be 'b'.\n    assert text_starta_endb(\"aabbbb\")\n    \"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('ab.*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^ab.*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('ab.*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^ab.*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('ab.*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^ab.*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^ab.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^ab.*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^ab.*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^ab.*b$'\n    return re.match(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/16", "requirement": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if the input string contains at least one sequence of lowercase letters joined by a single underscore, and False otherwise. The string may contain other characters or sequences that do not follow this pattern.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"abc_def_ghi_\")\n    True\n    \"\"\"", "generated_programs": ["import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('\\\\b[a-z]+_[a-z]+\\\\b', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('\\\\b[a-z]+_[a-z]+\\\\b', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('\\\\b[a-z]+_[a-z]+\\\\b', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('\\\\b[a-z]+_[a-z]+\\\\b', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('\\\\b[a-z]+_[a-z]+\\\\b', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('\\\\b[a-z]+_[a-z]+\\\\b', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('\\\\b[a-z]+_[a-z]+\\\\b', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('\\\\b[a-z]+_[a-z]+\\\\b', text))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "Mbpp/63", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute difference between the two numbers in each tuple within the given list.\n    assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(a - b) for a, b in test_list))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/72", "requirement": "def dif_Square(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given number can be represented as the difference of two squares, \n    i.e., whether there exist integers `a` and `b` such that `a² - b² = n`. The function should return `True` if such \n    a representation exists and `False` otherwise. The function should handle both positive and negative integers, \n    considering that the difference of squares can be positive, negative, or zero. The integers `a` and `b` can be \n    positive, negative, or zero. The function should iterate `a` from `0` to `abs(n) + 1` to ensure all possible \n    combinations are considered.\n\n    Examples:\n    - `dif_Square(5)` returns `True` because 3² - 2² = 9 - 4 = 5.\n    - `dif_Square(-4)` returns `True` because 0² - 2² = 0 - 4 = -4.\n    - `dif_Square(2)` returns `False` because no such integers `a` and `b` exist.\n\n    assert dif_Square(5) == True\n    \"\"\"", "generated_programs": ["def dif_Square(n: int) -> bool:\n    for a in range(0, abs(n) + 2):\n        b_squared = a * a - n\n        if b_squared >= 0:\n            b = int(b_squared ** 0.5)\n            if b * b == b_squared:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 2):\n        for b in range(a + 1):\n            if a ** 2 - b ** 2 == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(0, abs(n) + 1):\n        for b in range(0, abs(n) + 1):\n            if a * a - b * b == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 2):\n        b_squared = a * a - n\n        if b_squared >= 0:\n            b = int(b_squared ** 0.5)\n            if b * b == b_squared:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 2):\n        b_square = a * a - n\n        if b_square >= 0:\n            b = int(b_square ** 0.5)\n            if b * b == b_square:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(0, abs(n) + 1):\n        for b in range(0, a + 1):\n            if a * a - b * b == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        a_squared = a * a\n        b_squared = a_squared - n\n        b = int(b_squared ** 0.5)\n        if b * b == b_squared:\n            return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(0, abs(n) + 1):\n        for b in range(0, a + 1):\n            if a * a - b * b == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    limit = abs(n) + 1\n    for a in range(limit):\n        for b in range(limit):\n            if a * a - b * b == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(0, abs(n) + 2):\n        b_squared = a * a - n\n        if b_squared >= 0:\n            b = int(b_squared ** 0.5)\n            if b * b == b_squared:\n                return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n    \"\"\"\n    Determine if a given integer is divisible by 11. The function should consider the actual value of the integer, including negative numbers, and return True if the number is divisible by 11, otherwise False. The input is guaranteed to be a valid integer.\n\n    Examples:\n    >>> is_Diff(12345)\n    False\n    >>> is_Diff(-121)\n    True\n    \"\"\"", "generated_programs": ["def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/92", "requirement": "def is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not.\n    An undulating number is defined as a number where the digits strictly alternate between two distinct digits, \n    starting with the first digit being different from the second. For example, `1212121` is undulating because \n    it alternates between `1` and `2`. The number must have at least two digits to be considered undulating.\n    \n    assert is_undulating(1212121) == True\n    \"\"\"", "generated_programs": ["def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i in range(2, len(s)):\n        if i % 2 == 0 and s[i] != first:\n            return False\n        elif i % 2 == 1 and s[i] != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    num_str = str(n)\n    if len(num_str) < 2:\n        return False\n    first_digit = num_str[0]\n    second_digit = num_str[1]\n    if first_digit == second_digit:\n        return False\n    for i in range(2, len(num_str)):\n        if num_str[i] != first_digit and num_str[i] != second_digit:\n            return False\n        if num_str[i] == num_str[i - 1]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    num_str = str(n)\n    if len(num_str) < 2:\n        return False\n    first_digit = num_str[0]\n    second_digit = num_str[1]\n    if first_digit == second_digit:\n        return False\n    for i in range(2, len(num_str)):\n        if i % 2 == 0 and num_str[i] != first_digit:\n            return False\n        if i % 2 != 0 and num_str[i] != second_digit:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    num_str = str(n)\n    if len(num_str) < 2:\n        return False\n    first_digit = num_str[0]\n    second_digit = num_str[1]\n    if first_digit == second_digit:\n        return False\n    for i in range(0, len(num_str), 2):\n        if num_str[i] != first_digit:\n            return False\n    for i in range(1, len(num_str), 2):\n        if num_str[i] != second_digit:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    num_str = str(n)\n    if len(num_str) < 2:\n        return False\n    first_digit = num_str[0]\n    second_digit = num_str[1]\n    if first_digit == second_digit:\n        return False\n    for i in range(2, len(num_str)):\n        if num_str[i] != num_str[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    n_str = str(n)\n    if len(n_str) < 2:\n        return False\n    first_digit = n_str[0]\n    second_digit = n_str[1]\n    if first_digit == second_digit:\n        return False\n    for i in range(2, len(n_str)):\n        if i % 2 == 0:\n            if n_str[i] != first_digit:\n                return False\n        elif n_str[i] != second_digit:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    n_str = str(n)\n    if len(n_str) < 2:\n        return False\n    first_digit = n_str[0]\n    second_digit = n_str[1]\n    if first_digit == second_digit:\n        return False\n    for i in range(2, len(n_str)):\n        if n_str[i] != (first_digit if i % 2 == 0 else second_digit):\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    n_str = str(n)\n    if len(n_str) < 2:\n        return False\n    first_digit = n_str[0]\n    second_digit = n_str[1]\n    if first_digit == second_digit:\n        return False\n    for i in range(2, len(n_str)):\n        if n_str[i] != n_str[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    str_n = str(n)\n    if len(str_n) < 2:\n        return False\n    first_digit, second_digit = (str_n[0], str_n[1])\n    if first_digit == second_digit:\n        return False\n    for i in range(2, len(str_n)):\n        if str_n[i] != (second_digit if i % 2 else first_digit):\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given positive integer.\n    The function should raise a ValueError if the input is not a positive integer.\n    \n    Parameters:\n    n (int): A positive integer for which the number of positive divisors is to be found.\n    \n    Returns:\n    int: The count of positive divisors of the input integer.\n    \n    Raises:\n    ValueError: If the input is not a positive integer.\n    \n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(-10)\n    ValueError\n    \"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('The input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('The input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "from typing import List\n\ndef divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/99", "requirement": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n    For the input `n = 0`, the function should return the string \"0\".\n    assert decimal_to_binary(8) == '1000'\n    \"\"\"", "generated_programs": ["def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    return bin(n)[2:] if n != 0 else '0'", "def decimal_to_binary(n: int) -> str:\n    return bin(n)[2:] if n != 0 else '0'", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    return bin(n)[2:] if n != 0 else '0'", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/103", "requirement": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m), which is the number of permutations of the set {1, 2, ..., n} \n    with exactly m ascents. The function returns 0 if m is negative or if m is greater than or equal to n.\n    The Eulerian number is computed using dynamic programming, where the recurrence relation is defined as:\n    - dp[i][j] = 1 if j == 0 or j == i - 1\n    - dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j] if i > 1 and j < i\n    - dp[i][j] = 0 otherwise\n\n    Parameters:\n    n (int): The size of the set, must be a non-negative integer.\n    m (int): The number of ascents, must be a non-negative integer.\n\n    Returns:\n    int: The Eulerian number a(n, m), or 0 if m is invalid.\n\n    Examples:\n    >>> eulerian_num(3, 1)\n    4\n    \"\"\"", "generated_programs": ["def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(min(m + 1, i)):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(0, i):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * n for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(n):\n            if j == 0:\n                dp[i][j] = 1\n            elif j == i - 1:\n                dp[i][j] = 1\n            elif j < i:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * n for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(i):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(min(m, i - 1) + 1):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * n for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(i):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            elif j < i:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0 for _ in range(n)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(i):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(i):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * n for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(i):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements that are present in all nested lists.\n    The function should return a list of integers that are common to every nested list in the input.\n    If the input is an empty list or contains any empty nested list, the function should raise a TypeError.\n    \n    Examples:\n    >>> assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    >>> common_in_nested_lists([[]])\n    TypeError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not lst for lst in nestedlist)):\n        raise TypeError('Input contains empty nested list or is itself empty.')\n    common_elements = set(nestedlist[0])\n    for lst in nestedlist[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not lst for lst in nestedlist)):\n        raise TypeError('Input contains empty list or nested list.')\n    return list(set.intersection(*map(set, nestedlist)))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input list or one of the nested lists is empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input contains empty list or nested list.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not lst for lst in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for lst in nestedlist[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(lst) == 0 for lst in nestedlist)):\n        raise TypeError('Input contains an empty list or nested empty list.')\n    common_elements = set(nestedlist[0])\n    for lst in nestedlist[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not lst for lst in nestedlist)):\n        raise TypeError('Input contains an empty list or the main list is empty')\n    return list(set.intersection(*map(set, nestedlist)))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(sublist) == 0 for sublist in nestedlist)):\n        raise TypeError('Input contains empty nested lists or is empty.')\n    return list(set.intersection(*map(set, nestedlist)))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input contains an empty list or nested list.')\n    common_values = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_values.intersection_update(sublist)\n    return list(common_values)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/120", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute product of the two numbers in each tuple within a given list of tuples. Each tuple in the list must contain exactly two integers. The function calculates the product of the two numbers in each tuple, takes the absolute value of that product, and returns the maximum value among these absolute products.\n\n    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n\"\"\"\nWrite a function to sum all amicable numbers from 1 to a specified number.\n\n\nassert amicable_numbers_sum(999)==504\n\"\"\"", "generated_programs": ["import math\n\ndef sum_of_divisors(n: int) -> int:\n    if n < 2:\n        return 0\n    total = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for num in range(2, limit):\n        sum1 = sum_of_divisors(num)\n        if sum1 > num and sum1 < limit:\n            sum2 = sum_of_divisors(sum1)\n            if sum2 == num:\n                amicable_sum += num + sum1\n    return amicable_sum", "from typing import List\n\ndef proper_divisors_sum(n: int) -> int:\n    return sum((i for i in range(1, n) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for number in range(2, limit):\n        partner = proper_divisors_sum(number)\n        if partner != number and partner < limit and (proper_divisors_sum(partner) == number):\n            amicable_sum += number\n    return amicable_sum", "from typing import Tuple\n\ndef sum_of_divisors(n: int) -> int:\n    total = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    sum_amicable = 0\n    for num in range(1, limit):\n        partner = sum_of_divisors(num)\n        if partner != num and partner < limit and (sum_of_divisors(partner) == num):\n            sum_amicable += num\n    return sum_amicable", "from typing import List\n\ndef divisors_sum(n: int) -> int:\n    total = 0\n    for i in range(1, n):\n        if n % i == 0:\n            total += i\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for num in range(2, limit):\n        a = num\n        b = divisors_sum(a)\n        if b > a and b < limit:\n            if divisors_sum(b) == a:\n                amicable_sum += a + b\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for num in range(2, limit):\n        partner = sum_of_divisors(num)\n        if partner != num and partner < limit and (sum_of_divisors(partner) == num):\n            amicable_sum += num\n    return amicable_sum", "from typing import List\n\ndef divisors_sum(n: int) -> int:\n    return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = divisors_sum(a)\n        if b != a and b < limit and (divisors_sum(b) == a):\n            amicable_sum += a\n    return amicable_sum", "def divisor_sum(n: int) -> int:\n    return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = divisor_sum(a)\n        if b != a and b < limit and (divisor_sum(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef proper_divisors_sum(n: int) -> int:\n    total = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef is_amicable_pair(a: int, b: int) -> bool:\n    return a != b and proper_divisors_sum(a) == b and (proper_divisors_sum(b) == a)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amiable_sum = 0\n    for number in range(2, limit + 1):\n        partner = proper_divisors_sum(number)\n        if is_amicable_pair(number, partner):\n            amiable_sum += number\n    return amiable_sum", "import math\n\ndef divisors_sum(n: int) -> int:\n    sum_divs = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            sum_divs += i\n            if i != n // i:\n                sum_divs += n // i\n    return sum_divs\n\ndef amicable_numbers_sum(limit: int) -> int:\n    total_sum = 0\n    for num in range(2, limit):\n        sum1 = divisors_sum(num)\n        if sum1 < limit and sum1 != num:\n            sum2 = divisors_sum(sum1)\n            if sum2 == num:\n                total_sum += num\n    return total_sum", "import math\n\ndef d(n: int) -> int:\n    divisors_sum = 1\n    for i in range(2, math.isqrt(n) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = d(a)\n        if b != a and b <= limit and (d(b) == a):\n            amicable_sum += a\n    return amicable_sum"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Calculate the phase angle of the difference between two complex numbers `b` and `a`.\n\n    The function computes the phase angle (in radians) of the complex number resulting from the difference `b - a`.\n\n    Args:\n        a (complex): The first complex number.\n        b (complex): The second complex number.\n\n    Returns:\n        float: The phase angle of the complex number `b - a`.\n\n    Examples:\n        >>> import math\n        >>> math.isclose(angle_complex(0, 1j), 1.5707963267948966, rel_tol=0.001)\n        True\n    \"\"\"", "generated_programs": ["import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/126", "requirement": "def sum_of_common_divisors(a: int, b: int) -> int:\n    \"\"\"\n    Write a Python function to calculate the sum of all common divisors of two given numbers.\n    The function should first determine the greatest common divisor (GCD) of the two numbers,\n    then find all divisors of the GCD, and finally return the sum of these divisors.\n    \n    Example:\n    assert sum_of_common_divisors(10, 15) == 6\n    \"\"\"", "generated_programs": ["from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    greatest_cd = gcd(a, b)\n    sum_divisors = 0\n    for i in range(1, greatest_cd + 1):\n        if greatest_cd % i == 0:\n            sum_divisors += i\n    return sum_divisors", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n\n    def divisors(n: int):\n        divs = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divs.add(i)\n                divs.add(n // i)\n        return divs\n    common_gcd = gcd(a, b)\n    return sum(divisors(common_gcd))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    greatest_cd = gcd(a, b)\n    sum_divisors = sum((i for i in range(1, greatest_cd + 1) if greatest_cd % i == 0))\n    return sum_divisors", "import math\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    gcd = math.gcd(a, b)\n    return sum((i for i in range(1, gcd + 1) if gcd % i == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    g = gcd(a, b)\n    total = 0\n    for i in range(1, g + 1):\n        if g % i == 0:\n            total += i\n    return total", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    g = gcd(a, b)\n    sum_divisors = 0\n    for i in range(1, g + 1):\n        if g % i == 0:\n            sum_divisors += i\n    return sum_divisors", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_gcd = gcd(a, b)\n    return sum((divisor for divisor in range(1, common_gcd + 1) if common_gcd % divisor == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_divisor = gcd(a, b)\n    return sum((i for i in range(1, common_divisor + 1) if common_divisor % i == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    greatest_common_divisor = gcd(a, b)\n    sum_divisors = 0\n    for i in range(1, greatest_common_divisor + 1):\n        if greatest_common_divisor % i == 0:\n            sum_divisors += i\n    return sum_divisors", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_gcd = gcd(a, b)\n    divisors_sum = 0\n    for i in range(1, common_gcd + 1):\n        if common_gcd % i == 0:\n            divisors_sum += i\n    return divisors_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether the matrix is a magic square.\n    \n    A magic square is a square matrix where the sum of each row, each column, and both diagonals are equal to the magic sum, \n    which is calculated as `n * (n ** 2 + 1) // 2`, where `n` is the size of the matrix. Additionally, the matrix must be a \n    square (i.e., the number of rows equals the number of columns), and all elements must be unique.\n    \n    Args:\n        my_matrix (List[List[int]]): A square matrix of integers.\n    \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \n    Examples:\n        >>> magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])\n        True\n        >>> magic_square_test([[1, 1, 1], [1, 1, 1], [1, 1, 1]])\n        False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    seen = set()\n    for row in my_matrix:\n        seen.update(row)\n    if len(seen) != n * n:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    unique_elements = set()\n    for row in my_matrix:\n        unique_elements.update(row)\n    if len(unique_elements) != n * n:\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if not all((sum(row) == magic_sum for row in my_matrix)):\n        return False\n    if not all((sum((my_matrix[i][j] for i in range(n))) == magic_sum for j in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    elements = set()\n    for row in my_matrix:\n        for number in row:\n            if number < 1 or number > n ** 2 or number in elements:\n                return False\n            elements.add(number)\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_sum or sum((my_matrix[j][i] for j in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    unique_elements = set()\n    for row in my_matrix:\n        for num in row:\n            if num in unique_elements:\n                return False\n            unique_elements.add(num)\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if n == 0 or any((len(row) != n for row in my_matrix)):\n        return False\n    unique_elements = set()\n    flat_list = [element for row in my_matrix for element in row]\n    if len(set(flat_list)) != n * n:\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if n == 0 or any((len(row) != n for row in my_matrix)):\n        return False\n    expected_sum = n * (n ** 2 + 1) // 2\n    unique_values = set()\n    for row in my_matrix:\n        if sum(row) != expected_sum:\n            return False\n        unique_values.update(row)\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != expected_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != expected_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != expected_sum:\n        return False\n    if len(unique_values) != n * n:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    unique_elements = set()\n    total_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        for elem in row:\n            if elem in unique_elements:\n                return False\n            unique_elements.add(elem)\n    for row in my_matrix:\n        if sum(row) != total_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != total_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != total_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != total_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix:\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    unique_values = set()\n    for row in my_matrix:\n        unique_values.update(row)\n    if len(unique_values) != n * n:\n        return False\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_sum or sum((row[i] for row in my_matrix)) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum or sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    elements = [elem for row in my_matrix for elem in row]\n    if len(set(elements)) != n * n:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    elements = {elem for row in my_matrix for elem in row}\n    if len(elements) != n * n:\n        return False\n    magic_sum = n * (n * n + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/130", "requirement": "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with the maximum frequency in a given list.\n    If the list is empty, the function should raise an IndexError.\n    If multiple items have the same maximum frequency, the function should return the first one encountered.\n    \n    Examples:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    >>> max_occurrences([])\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"", "generated_programs": ["from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    count = Counter(nums)\n    max_count = max(count.values())\n    for num in nums:\n        if count[num] == max_count:\n            return num", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    count = Counter(nums)\n    max_frequency = max(count.values())\n    return next((num for num in nums if count[num] == max_frequency))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    count = Counter(nums)\n    max_freq = max(count.values())\n    for num in nums:\n        if count[num] == max_freq:\n            return num", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    counts = Counter(nums)\n    max_frequency = max(counts.values())\n    for num in nums:\n        if counts[num] == max_frequency:\n            return num", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    frequency = Counter(nums)\n    max_count = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_count:\n            return num", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    count = Counter(nums)\n    max_count = max(count.values())\n    for num in nums:\n        if count[num] == max_count:\n            return num", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    count = Counter(nums)\n    max_freq = max(count.values())\n    for num in nums:\n        if count[num] == max_freq:\n            return num", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    counter = Counter(nums)\n    max_frequency = max(counter.values())\n    for num in nums:\n        if counter[num] == max_frequency:\n            return num", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    count = Counter(nums)\n    max_count = max(count.values())\n    for num in nums:\n        if count[num] == max_count:\n            return num", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('list index out of range')\n    frequency = Counter(nums)\n    return max(frequency, key=lambda x: frequency[x])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/137", "requirement": "from typing import List\n\n\ndef zero_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of zeroes to the number of non-zero elements in an array of integers.\n    The ratio is calculated as the number of zeroes divided by the number of non-zero elements.\n    If there are no non-zero elements, the function should return 0.0.\n    assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given number can be represented as a sum of distinct non-zero powers of 2.\n    A number can be represented as a sum of distinct non-zero powers of 2 if its binary representation contains more than one '1'.\n    For example, 10 (binary '1010') can be represented as 8 + 2, which are distinct non-zero powers of 2.\n    The function should return `False` if the number is a single non-zero power of 2 (e.g., 1, 2, 4, 8, etc.).\n    assert is_Sum_Of_Powers_Of_Two(10) == True\n    \"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/145", "requirement": "from typing import List\n\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the maximum absolute difference between any two elements in a given array.\n    The maximum absolute difference is defined as the difference between the maximum and minimum values in the array.\n    If the array is empty, the function should return 0.\n    \n    Examples:\n    >>> max_Abs_Diff((2, 1, 5, 3))\n    4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val - min_val", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val - min_val", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_value = max(arr)\n    min_value = min(arr)\n    return max_value - min_value", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val - min_val", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_value = max(arr)\n    min_value = min(arr)\n    return max_value - min_value", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"\n    Write a function that returns the smallest non-negative integers x and y that satisfy the equation ax + by = n as a tuple, or return None if no such solution exists.\n    The solution should be the smallest non-negative solution, meaning both x and y should be non-negative and as small as possible, with x being minimized first, followed by y.\n    If either a or b is zero, the function should raise a ZeroDivisionError.\n    If either a or b is negative, the function should return None, as no non-negative solution exists in such cases.\n    assert find_solution(2, 3, 7) == (2, 1)\n    \"\"\"", "generated_programs": ["from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('Neither a nor b can be zero.')\n    if a < 0 or b < 0:\n        return None\n    x, y = (0, 0)\n    while True:\n        if a * x > n:\n            return None\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            return (x, y)\n        x += 1", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a <= 0 or b <= 0:\n        return None\n    x, y = (0, n)\n    while a * x <= n:\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n        x += 1\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a or b cannot be zero')\n    if a < 0 or b < 0:\n        return None\n    x = 0\n    while a * x <= n:\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n        x += 1\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError(\"Neither 'a' nor 'b' can be zero.\")\n    if a < 0 or b < 0:\n        return None\n    x = 0\n    while a * x <= n:\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            return (x, y)\n        x += 1\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a <= 0 or b <= 0:\n        raise ZeroDivisionError('a and b must be positive non-zero integers')\n    for x in range(n // a + 1):\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('Neither a nor b can be zero.')\n    if a < 0 or b < 0:\n        return None\n    x, y = (0, 0)\n    while a * x <= n:\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n        x += 1\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a <= 0 or b <= 0:\n        raise ZeroDivisionError(\"Either 'a' or 'b' is zero or negative, which is not allowed.\")\n    x = 0\n    while a * x <= n:\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n        x += 1\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a <= 0 or b <= 0:\n        return None\n    x, y = (0, 0)\n    while a * x <= n:\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n        x += 1\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('Neither a nor b can be zero.')\n    if a < 0 or b < 0:\n        return None\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a or b cannot be zero')\n    if a < 0 or b < 0:\n        return None\n    x, y = (0, 0)\n    while a * x <= n:\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n        x += 1\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n    \"\"\"\n    Write a Python function to set all even bits of a given number to 1 only if they are not already set. \n    The function should return the original number if all even bits are already set.\n    \n    assert even_bit_set_number(10) == 10\n    \"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    return n | sum((1 << i for i in range(0, n.bit_length() + 1, 2)))", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length(), 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 0\n    num_of_bits = n.bit_length()\n    for i in range(0, num_of_bits + 1, 2):\n        even_bit_mask |= 1 << i\n    new_n = n | even_bit_mask\n    return n if new_n == n else new_n", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < n.bit_length():\n        if bit_position % 2 == 0:\n            even_bit_mask |= 1 << bit_position\n        bit_position += 1\n    updated_number = n | even_bit_mask\n    return updated_number if updated_number != n else n", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 32:\n        if bit_position % 2 == 0:\n            even_bit_mask |= 1 << bit_position\n        bit_position += 1\n    return n | even_bit_mask", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = sum((1 << i for i in range(0, n.bit_length(), 2)))\n    return n | even_bit_mask", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 0\n    bit_length = n.bit_length()\n    for i in range(0, bit_length, 2):\n        even_bit_mask |= 1 << i\n    result = n | even_bit_mask\n    return n if result == n else result", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_length = n.bit_length() + 1\n    for i in range(bit_length):\n        if i % 2 == 0:\n            mask |= 1 << i\n    result = n | mask\n    return result if result != n else n", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 0\n    bit_length = n.bit_length()\n    for i in range(0, bit_length, 2):\n        even_bit_mask |= 1 << i\n    updated_number = n | even_bit_mask\n    return updated_number if updated_number != n else n", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_length = n.bit_length()\n    for i in range(0, bit_length + 1, 2):\n        mask |= 1 << i\n    updated_number = n | mask\n    return n if updated_number == n else updated_number"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, \n    such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    \n    The sequence starts with any positive integer from 1 to m. For the first element, there is no previous element, \n    so it can be any integer from 1 to m. For each subsequent element, it must be at least twice the previous element \n    and at most m. The function should return 0 if n is 0, as there are no valid sequences of length 0.\n    \n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for length in range(2, n + 1):\n        for cur in range(1, m + 1):\n            for prev in range(1, cur // 2 + 1):\n                dp[length][cur] += dp[length - 1][prev]\n    return sum(dp[n])", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for length in range(2, n + 1):\n        for curr in range(1, m + 1):\n            for prev in range(1, curr // 2 + 1):\n                dp[length][curr] += dp[length - 1][prev]\n    result = sum((dp[n][i] for i in range(1, m + 1)))\n    return result", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            total_count = 0\n            lower_bound = (j + 1) // 2\n            for k in range(1, lower_bound):\n                total_count += dp[i - 1][k]\n            dp[i][j] = total_count\n    return sum((dp[n][j] for j in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start, length):\n        if length == 1:\n            return 1\n        seq_count = 0\n        next_start = start * 2\n        while next_start <= m:\n            seq_count += count_sequences(next_start, length - 1)\n            next_start += 1\n        return seq_count\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    for length in range(2, n + 1):\n        for i in range(1, m + 1):\n            dp[i][length] = 0\n            for prev in range(1, i // 2 + 1):\n                dp[i][length] += dp[prev][length - 1]\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += dp[i][n]\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start, length):\n        if length == 1:\n            return 1\n        count = 0\n        next_start = start * 2\n        while next_start <= m:\n            count += count_sequences(next_start, length - 1)\n            next_start *= 2\n        return count\n    total_count = 0\n    for first in range(1, m + 1):\n        total_count += count_sequences(first, n)\n    return total_count", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    for length in range(2, n + 1):\n        for current in range(1, m + 1):\n            dp[current][length] = sum((dp[prev][length - 1] for prev in range(1, current // 2 + 1)))\n    return sum((dp[i][n] for i in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start, remaining_length):\n        if remaining_length == 1:\n            return 1\n        count = 0\n        next_value = start * 2\n        while next_value <= m:\n            count += count_sequences(next_value, remaining_length - 1)\n            next_value += 1\n        return count\n    total_count = 0\n    for starting_value in range(1, m + 1):\n        total_count += count_sequences(starting_value, n)\n    return total_count", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = sum((dp[i - 1][k] for k in range(1, j // 2 + 1)))\n    return sum((dp[n][j] for j in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start, length):\n        if length == 0:\n            return 1\n        total_sequences = 0\n        next_min = 2 * start\n        for next_num in range(next_min, m + 1):\n            total_sequences += count_sequences(next_num, length - 1)\n        return total_sequences\n    total = 0\n    for first_element in range(1, m + 1):\n        total += count_sequences(first_element, n - 1)\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "Mbpp/253", "requirement": "from typing import List, Any\n\n\ndef count_integer(lst: List[Any]) -> int:\n    \"\"\"\n    Write a Python function that returns the number of integer elements in a given list, excluding boolean values.\n    The function should only count elements that are instances of `int` and not instances of `bool`.\n    \n    Example:\n    >>> count_integer([1, 2, 'abc', 1.2])\n    2\n    \"\"\"\n    pass", "generated_programs": ["from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return len([x for x in lst if isinstance(x, int) and (not isinstance(x, bool))])", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(x, int) and (not isinstance(x, bool)) for x in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(x, int) and (not isinstance(x, bool)) for x in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(x, int) and (not isinstance(x, bool)) for x in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Newman–Shanks–Williams prime number.\n    The sequence starts with the first element, where the initial values are `(1, 1)`.\n    For n == 1, the function should return 3.\n    The iteration starts from 2 to n + 1, updating the sequence values as follows:\n    c = 2 * b + a, where a and b are the previous two values in the sequence.\n    After the iteration, the function should return the last computed value `c`.\n    assert newman_prime(3) == 7\n    \"\"\"", "generated_programs": ["def newman_prime(n: int) -> int:\n    a, b = (1, 1)\n    if n == 1:\n        return 3\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer.')\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    a, b = (1, 1)\n    if n == 1:\n        return 3\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    a, b = (1, 1)\n    c = 3\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    a, b = (1, 1)\n    if n == 1:\n        return 3\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    a, b = (1, 1)\n    if n == 1:\n        return 3\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    a, b = (1, 1)\n    if n == 1:\n        return 3\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    a, b = (1, 1)\n    if n == 1:\n        return 3\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/264", "requirement": "def dog_age(h_age: float) -> float:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years. \n    For non-positive human ages (h_age <= 0), the function should return 0.0.\n    For human ages less than or equal to 2, the dog's age is calculated as h_age * 10.5.\n    For human ages greater than 2, the dog's age is calculated as 21 + (h_age - 2) * 4.\n    assert dog_age(12)==61\n    \"\"\"", "generated_programs": ["def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/265", "requirement": "from typing import List, Any\n\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Write a function that takes in a list `S` and an integer `step`, and splits the list into `step` sublists. \n    Each sublist contains elements spaced `step` apart, starting from different offsets. Specifically, the first \n    sublist contains elements at indices `0, step, 2*step, ...`, the second sublist contains elements at indices \n    `1, step+1, 2*step+1, ...`, and so on. The function returns a list of these sublists.\n\n    Example:\n    assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == \n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for i in range(len(S)):\n        result[i % step].append(S[i])\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    sublists = [[] for _ in range(step)]\n    for i in range(len(S)):\n        sublists[i % step].append(S[i])\n    return sublists", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for i in range(len(S)):\n        result[i % step].append(S[i])\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for i, elem in enumerate(S):\n        result[i % step].append(elem)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for index, value in enumerate(S):\n        result[index % step].append(value)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for index, element in enumerate(S):\n        result[index % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for index, value in enumerate(S):\n        result[index % step].append(value)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        result[i % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for index, value in enumerate(S):\n        result[index % step].append(value)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i] for i in range(offset, len(S), step)] for offset in range(step)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/286", "requirement": "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the largest sum of a contiguous subarray in the modified array formed by repeating the given array k times. \n    The function should consider the possibility of wrapping around the array when calculating the maximum sum. \n    Specifically:\n    - If k == 1, the function should return the maximum subarray sum of the original array.\n    - If the total sum of the array is less than or equal to zero, the function should return the maximum subarray sum of the array repeated twice.\n    - If the total sum of the array is positive, the function should return the maximum of:\n        - The maximum subarray sum of the original array.\n        - The sum of the array repeated (k - 2) times plus the maximum subarray sum of the array concatenated with itself.\n    \n    assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef kadane(a: List[int]) -> int:\n    max_ending_here = max_so_far = a[0]\n    for x in a[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    max_single_kadane = kadane(a)\n    total_sum = sum(a)\n    if k == 1:\n        return max_single_kadane\n    max_double_kadane = kadane(a * 2)\n    if total_sum <= 0:\n        return max_double_kadane\n    return max(max_single_kadane, total_sum * (k - 2) + max_double_kadane)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_subarray_sum(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    max_single = max_subarray_sum(a)\n    if k == 1:\n        return max_single\n    arr_sum = sum(a)\n    if arr_sum <= 0:\n        return max_subarray_sum(a * 2)\n    max_double = max_subarray_sum(a * 2)\n    return max(max_single, max_double + arr_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    max_kadane = kadane(a)\n    if k == 1:\n        return max_kadane\n    total_sum = sum(a)\n    max_kadane_twice = kadane(a * 2)\n    if total_sum <= 0:\n        return max_kadane_twice\n    else:\n        return max(max_kadane, (k - 2) * total_sum + max_kadane_twice)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr: List[int]) -> int:\n        max_ending_here = arr[0]\n        max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    array_sum = sum(a)\n    max_single_arr_sum = max_sub_array_sum(a)\n    if k == 1:\n        return max_single_arr_sum\n    max_double_arr_sum = max_sub_array_sum(a * 2)\n    if array_sum <= 0:\n        return max_double_arr_sum\n    return max(max_single_arr_sum, max_double_arr_sum + array_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    kadane_one = kadane(a)\n    if k == 1:\n        return kadane_one\n    kadane_two = kadane(a * 2)\n    if total_sum <= 0:\n        return kadane_two\n    max_mid_sum = (k - 2) * total_sum if k > 2 else 0\n    return max(kadane_one, kadane_two + max_mid_sum)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_single = kadane(a)\n    if k == 1:\n        return max_single\n    extended_a = a + a\n    max_double = kadane(extended_a)\n    if total_sum <= 0:\n        return max_double\n    return max(max_single, total_sum * (k - 2) + max_double)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for num in arr[1:]:\n            max_ending_here = max(num, max_ending_here + num)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    max_single = kadane(a)\n    if k == 1:\n        return max_single\n    total_sum = sum(a)\n    max_prefix_suffix = kadane(a * 2)\n    if total_sum <= 0:\n        return max_prefix_suffix\n    return max(max_single, max_prefix_suffix + (k - 2) * total_sum)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    max_single = kadane(a)\n    total_sum = sum(a)\n    if k == 1:\n        return max_single\n    max_double = kadane(a * 2)\n    if total_sum <= 0:\n        return max_double\n    else:\n        return max(max_single, max_double + total_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        current_sum = max_sum = arr[0]\n        for i in range(1, len(arr)):\n            current_sum = max(arr[i], current_sum + arr[i])\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    max_sub_sum_1 = kadane(a)\n    if k == 1:\n        return max_sub_sum_1\n    total_sum = sum(a)\n    max_sub_sum_2 = kadane(a + a)\n    if total_sum <= 0:\n        return max_sub_sum_2\n    else:\n        return max(max_sub_sum_1, (k - 2) * total_sum + max_sub_sum_2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    max_single = kadane(a)\n    total_sum = sum(a)\n    if k == 1:\n        return max_single\n    max_double = kadane(a + a)\n    if total_sum > 0:\n        return max(max_single, max_double + (k - 2) * total_sum)\n    else:\n        return max_double"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n    \"\"\"\n    Write a function to find the depth of a dictionary. \n    The depth of a dictionary is defined as the number of nested dictionaries it contains, including itself. \n    An empty dictionary is considered to have a depth of 1. \n    Non-dictionary inputs should return a depth of 0.\n    \n    Examples:\n    >>> dict_depth({'a':1, 'b': {'c': {'d': {}}}})\n    4\n    >>> dict_depth({})\n    1\n    >>> dict_depth(123)\n    0\n    \"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict))) if d else 1", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict))) or 1", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.4, "original_passk": 0.4}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum of a strictly increasing subsequence that ends at the kth element, \n    where the subsequence is formed from the prefix of the list up to the ith index (i <= index) and must include \n    the kth element. The function should return the sum of this subsequence. If index >= k, the function should \n    return -1, as it is not possible to form such a subsequence.\n\n    Args:\n        a (List[int]): The input list of integers.\n        n (int): The length of the list.\n        index (int): The index up to which the prefix is considered.\n        k (int): The index of the element that must be included in the subsequence.\n\n    Returns:\n        int: The maximum sum of the strictly increasing subsequence ending at the kth element, or -1 if index >= k.\n\n    Examples:\n        >>> max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6)\n        11\n        >>> max_sum_increasing_subseq([5, 4, 3, 2, 1], 5, 1, 3)\n        -1\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index < k:\n        dp = [0] * n\n        max_sum = -1\n        for i in range(index + 1):\n            dp[i] = a[i]\n            if i == k:\n                max_sum = a[i]\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n            if i == k:\n                max_sum = dp[i]\n        return max_sum\n    else:\n        return -1", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index < k:\n        prefix = a[:index + 1]\n        if a[k] not in prefix:\n            return -1\n        dp = [0] * len(prefix)\n        for i in range(len(prefix)):\n            dp[i] = prefix[i]\n            for j in range(i):\n                if prefix[j] < prefix[i]:\n                    dp[i] = max(dp[i], dp[j] + prefix[i])\n        return max(dp[:k + 1])\n    else:\n        return -1", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index < k:\n        dp = [0] * n\n        dp[k] = a[k]\n        for i in range(k - 1, -1, -1):\n            if i <= index:\n                if a[i] < a[k]:\n                    dp[i] = max(dp[i], a[i] + dp[k])\n        for i in range(k - 1, -1, -1):\n            if i <= index:\n                for j in range(i + 1, k):\n                    if a[j] > a[i]:\n                        dp[i] = max(dp[i], a[i] + dp[j])\n        return dp[0]\n    else:\n        return -1", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index < k:\n        dp = [0] * (index + 1)\n        dp[k] = a[k]\n        for i in range(k, index + 1):\n            for j in range(k, i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n        return max(dp[k:index + 1])\n    return -1", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index < k:\n        dp = [0] * (index + 1)\n        dp[k] = a[k]\n        for i in range(k, index + 1):\n            for j in range(k, i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n        return max(dp[k:index + 1])\n    return -1", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index < k:\n        dp = [0] * (index + 1)\n        for i in range(k + 1):\n            a += k", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index < k:\n        dp = [0] * (index + 1)\n        dp[k] = a[k]\n        for i in range(k, index + 1):\n            for j in range(k, i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n        return dp[index]\n    return -1", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index < k:\n        dp = [0] * (index + 1)\n        for i in range(index + 1):\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n        return dp[k]\n    return -1"], "result": {"repaired_passk": 0.19999999999999996, "cross_model_passk": 0.0, "original_passk": 0.125}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n    \"\"\"\n    Write a function to convert a given string to a tuple of characters, excluding spaces.\n    assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n    \"\"\"", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((c for c in str1 if c != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((c for c in str1 if c != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((ch for ch in str1 if ch != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the most significant unset bit in the binary representation of the given integer.\n    The most significant unset bit is the highest-order bit that is unset, starting from the leftmost bit (MSB) to the rightmost bit (LSB).\n    assert set_left_most_unset_bit(10) == 14\n    \"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length() + 1\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    import math\n    num_bits = math.floor(math.log2(n)) + 1\n    for i in range(num_bits, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    num_bits = n.bit_length()\n    for i in range(num_bits, -1, -1):\n        if n & 1 << i == 0:\n            n |= 1 << i\n            break\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length() + 1\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    mask = 1\n    while mask <= n:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    mask = 1\n    while mask <= n:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    num_bits = n.bit_length() + 1\n    for i in range(num_bits - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/391", "requirement": "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    \"\"\"\n    Converts three lists of equal length into a list of nested dictionaries. Each nested dictionary contains a single key-value pair, where the key is an element from `list1` and the value is another dictionary. The inner dictionary has a key from `list2` and a value from `list3`.\n\n    The function assumes that all three input lists are of equal length. If the lists are of unequal length, the behavior is undefined and may result in an `IndexError`.\n\n    Args:\n        list1 (List[Any]): A list of keys for the outer dictionary.\n        list2 (List[Any]): A list of keys for the inner dictionary.\n        list3 (List[Any]): A list of values for the inner dictionary.\n\n    Returns:\n        List[Dict[Any, Dict[Any, Any]]]: A list of nested dictionaries, where each dictionary has the structure {list1[i]: {list2[i]: list3[i]}}.\n\n    Examples:\n        >>> convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"], [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"], [85, 98, 89, 92])\n        [{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]\n\n        >>> convert_list_dictionary(['B001', 'B002'], ['Alice Smith'], [90, 95])\n        ['IndexError']\n    \"\"\"", "generated_programs": ["from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError('Input lists are not of equal length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('Input lists are not of equal length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError('All input lists must be of the same length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        if len(list1) != len(list2) or len(list2) != len(list3):\n            raise IndexError('Input lists have unequal lengths')\n        return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]\n    except IndexError:\n        return ['IndexError']", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError('Input lists must be of equal length.')\n    result = [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]\n    return result", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('Input lists are not of equal length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise IndexError('All input lists must have the same length')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        return ['IndexError']\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        return ['IndexError']\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise IndexError('Input lists must be of equal length.')\n    result = []\n    for i in range(len(list1)):\n        result.append({list1[i]: {list2[i]: list3[i]}})\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.6}}
{"task_id": "Mbpp/415", "requirement": "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Write a python function to find a pair with the highest product from a given array of integers. \n    The function assumes that the input array will always have at least 2 elements. If the array \n    contains fewer than 2 elements, the function will raise an IndexError. The function sorts the \n    array and compares the product of the two largest elements with the product of the two smallest \n    elements to determine the pair with the highest product.\n\n    :param arr: A list of integers with at least 2 elements.\n    :return: A tuple of two integers representing the pair with the highest product.\n    :raises IndexError: If the input array contains fewer than 2 elements.\n\n    Examples:\n    >>> max_Product([1, 2, 3, 4, 7, 0, 8, 4])\n    (7, 8)\n    >>> max_Product([5])\n    Traceback (most recent call last):\n        ...\n    IndexError: The input array must contain at least 2 elements.\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must contain at least 2 elements.')\n    arr.sort()\n    max1, max2 = (arr[-1], arr[-2])\n    min1, min2 = (arr[0], arr[1])\n    if max1 * max2 > min1 * min2:\n        return (max2, max1)\n    else:\n        return (min1, min2)", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must contain at least 2 elements.')\n    arr.sort()\n    max1, max2 = (arr[-1], arr[-2])\n    min1, min2 = (arr[0], arr[1])\n    if max1 * max2 > min1 * min2:\n        return (max2, max1)\n    else:\n        return (min1, min2)", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must contain at least 2 elements.')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 >= product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must contain at least 2 elements.')\n    arr.sort()\n    max1, max2 = (arr[-1], arr[-2])\n    min1, min2 = (arr[0], arr[1])\n    if max1 * max2 > min1 * min2:\n        return (max2, max1)\n    else:\n        return (min1, min2)", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must contain at least 2 elements.')\n    arr.sort()\n    product1 = arr[0] * arr[1]\n    product2 = arr[-1] * arr[-2]\n    if product1 > product2:\n        return (arr[0], arr[1])\n    else:\n        return (arr[-2], arr[-1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must contain at least 2 elements.')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 >= product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must contain at least 2 elements.')\n    arr.sort()\n    product1 = arr[0] * arr[1]\n    product2 = arr[-1] * arr[-2]\n    if product1 > product2:\n        return (arr[0], arr[1])\n    else:\n        return (arr[-2], arr[-1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must contain at least 2 elements.')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 > product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must contain at least 2 elements.')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 > product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('The input array must contain at least 2 elements.')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 > product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find the directrix of a parabola given in the form y = ax^2 + bx + c.\n    The directrix is calculated using the formula: directrix = -1000 // (4 * a) - 148.\n    The coefficients b and c are not used in the calculation.\n    assert parabola_directrix(5,3,2)==-198\n    \"\"\"", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n    \"\"\"\n    Calculate the sum of Perrin numbers up to the nth index (inclusive).\n    \n    The Perrin sequence is defined as:\n    P(0) = 3, P(1) = 0, P(2) = 2,\n    and for n > 2, P(n) = P(n-2) + P(n-3).\n    \n    The function returns the sum of Perrin numbers from P(0) to P(n).\n    \n    Edge cases:\n    - If n is 0, the function returns 3.\n    - If n is 1, the function returns 3.\n    - If n is 2, the function returns 5.\n    - If n is negative, the function raises an IndexError.\n    \n    Examples:\n    >>> cal_sum(2)\n    5\n    >>> cal_sum(-1)\n    IndexError\n    >>> cal_sum(0)\n    3\n    \n    assert cal_sum(9) == 49\n    \"\"\"", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be non-negative')\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index cannot be negative.')\n    if n == 0:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index cannot be negative.')\n    perrin_sequence = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin_sequence.append(perrin_sequence[i - 2] + perrin_sequence[i - 3])\n    return sum(perrin_sequence[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index cannot be negative')\n    perrin = [3, 0, 2]\n    while len(perrin) <= n:\n        perrin.append(perrin[-2] + perrin[-3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be non-negative')\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index must not be negative.')\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index cannot be negative.')\n    perrin = [3, 0, 2]\n    if n <= 2:\n        return sum(perrin[:n + 1])\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index cannot be negative')\n    perrin_sequence = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin_sequence.append(perrin_sequence[i - 2] + perrin_sequence[i - 3])\n    return sum(perrin_sequence[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index cannot be negative.')\n    perrin = [3, 0, 2]\n    if n <= 2:\n        return sum(perrin[:n + 1])\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index cannot be negative')\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of positive even factors of a given non-negative integer.\n    A factor is considered even if it is divisible by 2. The function should return 0 for negative inputs.\n    \n    Examples:\n    >>> sumofFactors(18)\n    26\n    >>> sumofFactors(-12)\n    0\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "from typing import List\n\ndef sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches any word containing the letter 'z' regardless of its position within the word.\n    The word must be bounded by word boundaries.\n    assert text_match_wordz(\"pythonz.\")==True\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return re.search('\\\\b\\\\w*z\\\\w*\\\\b', text) is not None", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    pattern = '\\\\b\\\\w*z\\\\w*\\\\b'\n    return re.search(pattern, text) is not None", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"", "generated_programs": ["from itertools import combinations\nfrom typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = [[]]\n    for r in range(1, len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(combo) for combo in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import chain, combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    return list(map(list, chain.from_iterable((combinations(lst, r) for r in range(len(lst) + 1)))))", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend(combinations(lst, r))\n    return [list(comb) for comb in all_combinations]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/465", "requirement": "def drop_empty(dict1: dict) -> dict:\n    \"\"\"\n    Write a function to drop key-value pairs from a given dictionary where the value is `None`.\n\n    Args:\n        dict1 (dict): The input dictionary from which to remove `None` values.\n\n    Returns:\n        dict: A new dictionary with all key-value pairs where the value is not `None`.\n\n    Examples:\n        >>> drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None})\n        {'c1': 'Red', 'c2': 'Green'}\n    \"\"\"", "generated_programs": ["def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "from typing import Dict\n\ndef drop_empty(dict1: Dict) -> Dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "from typing import Dict\n\ndef drop_empty(dict1: Dict) -> Dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product of any two numbers in the array where the second number is greater than the first.\n    The function should consider all pairs of numbers (i, j) where i < j and arr[j] > arr[i], and return the maximum product of such pairs.\n    \n    Examples:\n    >>> max_product([3, 100, 4, 5, 150, 6])\n    3000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod if max_prod != float('-inf') else 0", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_product_val = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[j] > arr[i]:\n                product = arr[i] * arr[j]\n                if product > max_product_val:\n                    max_product_val = product\n    return max_product_val", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod if max_prod != float('-inf') else -1", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = -1\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_product = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[j] > arr[i]:\n                product = arr[i] * arr[j]\n                if product > max_product:\n                    max_product = product\n    return max_product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = 0\n    min_value = float('inf')\n    for j in range(1, len(arr)):\n        for i in range(j):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = -1\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/471", "requirement": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function to find the remainder of the product of all elements in the array when divided by n.\n    The product of an empty array is considered to be 1. The modulo operation is applied after computing the entire product.\n    \n    Examples:\n    >>> find_remainder([100, 10, 5, 25, 35, 14], 11)\n    9\n    >>> find_remainder([], 10)\n    1\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\nfrom functools import reduce\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = reduce(lambda x, y: x * y, arr)\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for number in arr:\n        product *= number\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    result = 1\n    for num in arr:\n        result *= num\n    return result % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/479", "requirement": "def first_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the first digit of a given number, retaining the sign of the original number.\n    For example, for the input -456, the function should return -456.\n    assert first_Digit(123) == 1\n    \"\"\"", "generated_programs": ["def first_Digit(n: int) -> int:\n    sign = -1 if n < 0 else 1\n    n = abs(n)\n    while n >= 10:\n        n //= 10\n    return sign * n", "def first_Digit(n: int) -> int:\n    return int(str(n)[0] if n > 0 else str(n)[1]) * (-1 if n < 0 else 1)", "def first_Digit(n: int) -> int:\n    sign = -1 if n < 0 else 1\n    n = abs(n)\n    while n >= 10:\n        n //= 10\n    return sign * n", "def first_Digit(n: int) -> int:\n    sign = -1 if n < 0 else 1\n    n = abs(n)\n    while n >= 10:\n        n //= 10\n    return sign * n", "def first_Digit(n: int) -> int:\n    return int(str(n)[0]) if n >= 0 else -int(str(abs(n))[0])", "def first_Digit(n: int) -> int:\n    sign = -1 if n < 0 else 1\n    n = abs(n)\n    while n >= 10:\n        n //= 10\n    return sign * n", "def first_Digit(n: int) -> int:\n    sign = -1 if n < 0 else 1\n    n = abs(n)\n    while n >= 10:\n        n //= 10\n    return sign * n", "def first_Digit(n: int) -> int:\n    sign = -1 if n < 0 else 1\n    n = abs(n)\n    while n >= 10:\n        n //= 10\n    return sign * n", "def first_Digit(n: int) -> int:\n    while abs(n) >= 10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    from math import copysign\n    first_digit = int(str(abs(n))[0])\n    return int(copysign(first_digit, n))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/558", "requirement": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of the per-digit difference between two integers. \n    The function should pad the shorter number with leading zeros to match the length of the longer number \n    before calculating the absolute difference for each digit position.\n    \n    assert digit_distance_nums(1,2) == 1\n    \"\"\"", "generated_programs": ["def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    total_distance = sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))\n    return total_distance", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1), str(n2))\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_length = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_length)\n    str_n2 = str_n2.zfill(max_length)\n    distance = sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))\n    return distance", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    return sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    distance_sum = sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))\n    return distance_sum", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    return sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1), str(n2))\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    total_distance = sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))\n    return total_distance", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    distance_sum = sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))\n    return distance_sum", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1), str(n2))\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1, str_n2 = (str_n1.zfill(max_len), str_n2.zfill(max_len))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/559", "requirement": "from typing import List\n\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Find the maximum sum of any contiguous sublist in the given list. \n    If the list is empty, return negative infinity (`-inf`). \n    The function should handle cases where all elements are negative by returning the maximum sum of any sublist, which could be a single element.\n\n    Examples:\n    >>> max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8)\n    7\n    >>> max_sub_array_sum([], 0)\n    -inf\n    \"\"\"", "generated_programs": ["from typing import List\nimport sys\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -float('inf')\n    max_so_far = -sys.maxsize - 1\n    max_ending_here = 0\n    for x in a:\n        max_ending_here = max_ending_here + x\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far", "from typing import List\nimport sys\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -sys.maxsize - 1\n    max_so_far = -sys.maxsize - 1\n    current_max = 0\n    for i in range(size):\n        current_max = current_max + a[i]\n        if max_so_far < current_max:\n            max_so_far = current_max\n        if current_max < 0:\n            current_max = 0\n    return max_so_far", "from typing import List\nimport sys\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -sys.maxsize - 1\n    max_so_far = -sys.maxsize - 1\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here = max_ending_here + a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far if max_so_far != -sys.maxsize - 1 else max(a)", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = -math.inf\n    current_max = 0\n    for i in range(size):\n        current_max = max(a[i], current_max + a[i])\n        max_so_far = max(max_so_far, current_max)\n    return max_so_far", "from typing import List\nfrom math import inf\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -inf\n    current_max = global_max = a[0]\n    for i in range(1, size):\n        current_max = max(a[i], current_max + a[i])\n        global_max = max(global_max, current_max)\n    return global_max", "from typing import List\nfrom math import inf\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -inf\n    max_sum = -inf\n    current_sum = 0\n    for num in a:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = -math.inf\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here += a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = -math.inf\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here += a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/563", "requirement": "def extract_values(text: str) -> List[str]:\n    \"\"\"Extract all substrings that are enclosed within double quotation marks from the input string.\n    Each substring should be captured without the surrounding quotes.\n    assert extract_values('\"Python\", \"PHP\", \"Java\"')==['Python', 'PHP', 'Java']\n    \"\"\"", "generated_programs": ["from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    matches = re.findall('\\\\\"(.*?)\\\\\"', text)\n    return matches", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"([^\"]*)\"', text)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "def count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Counts the number of unordered pairs (i, j) where i < j and arr[i] != arr[j].\n    The function iterates through all possible pairs in the list and increments the count if the elements in the pair are not equal.\n    assert count_Pairs([1,2,1],3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/579", "requirement": "from typing import Tuple, Any\n\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    \"\"\"\n    Write a function to find the dissimilar elements in the given two tuples. The function should return a tuple containing the elements that are present in either of the tuples but not in both, sorted in ascending order.\n\n    Examples:\n    >>> find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10))\n    (3, 6, 7, 10)\n    >>> find_dissimilar(((1, 2), (3, 4)), ((1, 2), (5, 6)))\n    ((3, 4), (5, 6))\n\n    Args:\n        test_tup1 (Tuple[Any, ...]): The first tuple.\n        test_tup2 (Tuple[Any, ...]): The second tuple.\n\n    Returns:\n        Tuple[Any, ...]: A tuple containing the dissimilar elements sorted in ascending order.\n    \"\"\"", "generated_programs": ["from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(set(test_tup2))))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    dissimilar_elements = set(test_tup1).symmetric_difference(set(test_tup2))\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    dissimilar_set = set(test_tup1).symmetric_difference(set(test_tup2))\n    return tuple(sorted(dissimilar_set))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    dissimilar = set(test_tup1).symmetric_difference(set(test_tup2))\n    return tuple(sorted(dissimilar))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    dissimilar_set = set(test_tup1).symmetric_difference(test_tup2)\n    return tuple(sorted(dissimilar_set))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_set = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_set))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_set = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_set))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    dissimilar_set = set(test_tup1) ^ set(test_tup2)\n    return tuple(sorted(dissimilar_set))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.9}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Write a function to remove non-integer elements and uneven integers from a nested mixed tuple. \n    The function should recursively process nested tuples, retaining only even integers at all levels of nesting.\n    Non-integer elements (e.g., floats, strings) should be removed, and nested tuples should be processed to retain only even integers.\n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even_integers(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return True\n        elif isinstance(element, tuple):\n            return True\n        return False\n\n    def process_tuple(tpl):\n        new_tuple = []\n        for item in tpl:\n            if isinstance(item, tuple):\n                nested_result = process_tuple(item)\n                if nested_result:\n                    new_tuple.append(nested_result)\n            elif filter_even_integers(item):\n                new_tuple.append(item)\n        return tuple(new_tuple)\n    return process_tuple(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_tuple(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                nested_result = process_tuple(item)\n                if nested_result:\n                    result.append(nested_result)\n            elif isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n        return tuple(result)\n    return process_tuple(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def is_even_integer(value):\n        return isinstance(value, int) and value % 2 == 0\n\n    def process_tuple(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                processed = process_tuple(item)\n                if processed:\n                    result.append(processed)\n            elif is_even_integer(item):\n                result.append(item)\n        return tuple(result)\n    return process_tuple(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even(item):\n        if isinstance(item, int) and item % 2 == 0:\n            return True\n        if isinstance(item, tuple):\n            return True\n\n    def process(item):\n        if isinstance(item, int):\n            return item\n        elif isinstance(item, tuple):\n            return extract_even(item)\n        else:\n            return None\n    return tuple((process(i) for i in test_tuple if filter_even(i)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return element\n        elif isinstance(element, tuple):\n            return extract_even(element)\n        return None\n    filtered_elements = tuple(filter(lambda x: x is not None, map(process_element, test_tuple)))\n    return filtered_elements", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even(t: tuple):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                filtered = filter_even(item)\n                if filtered:\n                    result.append(filtered)\n            elif isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n        return tuple(result)\n    return filter_even(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even_elements(item):\n        if isinstance(item, int) and item % 2 == 0:\n            return item\n        if isinstance(item, tuple):\n            filtered = tuple(filter(filter_even_elements, map(filter_even_elements, item)))\n            return filtered if filtered else None\n        return None\n    return tuple(filter(filter_even_elements, map(filter_even_elements, test_tuple)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even_elements(t):\n        result = []\n        for element in t:\n            if isinstance(element, int) and element % 2 == 0:\n                result.append(element)\n            elif isinstance(element, tuple):\n                filtered = filter_even_elements(element)\n                if filtered:\n                    result.append(filtered)\n        return tuple(result)\n    return filter_even_elements(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even(elements):\n        result = []\n        for item in elements:\n            if isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n            elif isinstance(item, tuple):\n                filtered_tuple = filter_even(item)\n                if filtered_tuple:\n                    result.append(filtered_tuple)\n        return tuple(result)\n    return filter_even(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def recursive_filter(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                filtered = recursive_filter(item)\n                if filtered:\n                    result.append(filtered)\n            elif isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n        return tuple(result)\n    return recursive_filter(test_tuple)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.7}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n    \"\"\"\n    Write a Python function to find the surface area of a square pyramid with a given base edge and slant height.\n    The slant height (s) is the distance along the lateral face from the base edge to the apex of the pyramid.\n    The surface area is calculated as the sum of the base area (b ** 2) and the lateral area (2 * b * s).\n    assert surface_Area(3, 4) == 33\n    \"\"\"", "generated_programs": ["def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/583", "requirement": "def catalan_number(num: int) -> int:\n    \"\"\"\n    Write a function which returns the nth Catalan number for a non-negative integer n. \n    The function should raise a ValueError if the input is a negative integer.\n    \n    Args:\n        num (int): A non-negative integer representing the index of the Catalan number.\n    \n    Returns:\n        int: The nth Catalan number.\n    \n    Raises:\n        ValueError: If the input num is a negative integer.\n    \n    Examples:\n        >>> catalan_number(10)\n        16796\n        >>> catalan_number(-1)\n        ValueError\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input should be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input should be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Convert polar coordinates to rectangular coordinates and return both the polar and rectangular representations.\n    \n    The function takes two inputs:\n    - r: The magnitude (radius) of the polar coordinate.\n    - theta: The angle (in radians) of the polar coordinate.\n    \n    The function returns a tuple containing:\n    - A tuple of the polar coordinates (magnitude, angle) calculated from the rectangular coordinates.\n    - A complex number representing the rectangular coordinates (x + yj), where x = r * cos(theta) and y = r * sin(theta).\n    \n    Example:\n    >>> polar_rect(3, 4)\n    ((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect = complex(x, y)\n    polar_r, polar_theta = (abs(rect), cmath.phase(rect))\n    return ((polar_r, polar_theta), rect)", "from typing import Tuple\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect = complex(x, y)\n    magnitude = abs(rect)\n    angle = math.atan2(y, x)\n    polar = (magnitude, angle)\n    return (polar, rect)", "from typing import Tuple\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect = complex(x, y)\n    magnitude = abs(rect)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), rect)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect = complex(x, y)\n    polar = cmath.polar(rect)\n    return (polar, rect)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rectangular = complex(x, y)\n    magnitude, angle = cmath.polar(rectangular)\n    polar = (magnitude, angle)\n    return (polar, rectangular)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect = complex(x, y)\n    rect_polar = cmath.polar(rect)\n    return (rect_polar, rect)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect = complex(x, y)\n    polar = cmath.polar(rect)\n    return (polar, rect)", "from typing import Tuple\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect = complex(x, y)\n    polar_mag, polar_angle = cmath.polar(rect)\n    return ((polar_mag, polar_angle), rect)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    rectangular_coords = r * cmath.exp(1j * theta)\n    x, y = (rectangular_coords.real, rectangular_coords.imag)\n    magnitude = abs(rectangular_coords)\n    angle = cmath.phase(rectangular_coords)\n    polar_coords = (magnitude, angle)\n    return (polar_coords, complex(x, y))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/592", "requirement": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given integer n.\n    Specifically, the function computes the sum of the product of comb(n, i) and comb(n, i + 1) for i ranging from 0 to n-1.\n    assert sum_Of_product(3) == 15\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the difference between the first even number and the first odd number in a given list.\n    The function should return the difference if both an even and an odd number are found; otherwise, it should return 0.\n    assert diff_even_odd([1,3,5,7,4,1,6,8])==3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if num % 2 == 0 and (not even_found):\n            first_even = num\n            even_found = True\n        elif num % 2 != 0 and (not odd_found):\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            break\n    return first_even - first_odd if even_found and odd_found else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for number in list1:\n        if number % 2 == 0:\n            first_even = number\n            break\n    else:\n        return 0\n    for number in list1:\n        if number % 2 != 0:\n            first_odd = number\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_number = None\n    odd_number = None\n    for number in list1:\n        if even_number is None and number % 2 == 0:\n            even_number = number\n        if odd_number is None and number % 2 != 0:\n            odd_number = number\n        if even_number is not None and odd_number is not None:\n            return abs(even_number - odd_number)\n    return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the k-th smallest element from the combined sorted array formed by merging the two given sorted arrays, arr1 and arr2. \n    The function should consider duplicates and return the k-th element when both arrays are merged in sorted order. \n    If k is out of bounds (i.e., k is less than 1 or greater than the total number of elements in the combined array), the function should raise an IndexError.\n    \n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise IndexError('k is out of bounds')\n    index1, index2 = (0, 0)\n    while k > 0:\n        if index1 < len(arr1) and (index2 >= len(arr2) or arr1[index1] < arr2[index2]):\n            if k == 1:\n                return arr1[index1]\n            index1 += 1\n        else:\n            if k == 1:\n                return arr2[index2]\n            index2 += 1\n        k -= 1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise IndexError('k is out of bounds')\n    index1, index2 = (0, 0)\n    while k > 0:\n        if index1 < len(arr1) and (index2 >= len(arr2) or arr1[index1] < arr2[index2]):\n            current_value = arr1[index1]\n            index1 += 1\n        else:\n            current_value = arr2[index2]\n            index2 += 1\n        k -= 1\n    return current_value", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise IndexError('k is out of bounds')\n    index1, index2 = (0, 0)\n    while index1 < len(arr1) and index2 < len(arr2):\n        if index1 + index2 == k - 1:\n            return min(arr1[index1], arr2[index2])\n        if arr1[index1] < arr2[index2]:\n            index1 += 1\n        else:\n            index2 += 1\n    while index1 < len(arr1):\n        if index1 + index2 == k - 1:\n            return arr1[index1]\n        index1 += 1\n    while index2 < len(arr2):\n        if index1 + index2 == k - 1:\n            return arr2[index2]\n        index2 += 1\n    raise IndexError('k is out of bounds')", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise IndexError('k is out of bounds')\n    i, j = (0, 0)\n    count = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == k:\n                return arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return arr2[j]\n            j += 1\n    while i < len(arr1):\n        count += 1\n        if count == k:\n            return arr1[i]\n        i += 1\n    while j < len(arr2):\n        count += 1\n        if count == k:\n            return arr2[j]\n        j += 1\n    raise IndexError('Unexpected index error')", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged_array = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged_array.append(arr1[i])\n            i += 1\n        else:\n            merged_array.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged_array.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged_array.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged_array):\n        raise IndexError('k is out of bounds')\n    return merged_array[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged_array = []\n    i, j = (0, 0)\n    total_length = len(arr1) + len(arr2)\n    if k < 1 or k > total_length:\n        raise IndexError('k is out of bounds')\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged_array.append(arr1[i])\n            i += 1\n        else:\n            merged_array.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged_array.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged_array.append(arr2[j])\n        j += 1\n    return merged_array[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise IndexError('k is out of bounds')\n\n    def kth_smallest(a, b, k):\n        if not a:\n            return b[k - 1]\n        if not b:\n            return a[k - 1]\n        mid_a, mid_b = (len(a) // 2, len(b) // 2)\n        if mid_a + mid_b < k - 1:\n            if a[mid_a] > b[mid_b]:\n                return kth_smallest(a, b[mid_b + 1:], k - mid_b - 1)\n            else:\n                return kth_smallest(a[mid_a + 1:], b, k - mid_a - 1)\n        elif a[mid_a] > b[mid_b]:\n            return kth_smallest(a[:mid_a], b, k)\n        else:\n            return kth_smallest(a, b[:mid_b], k)\n    return kth_smallest(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise IndexError('k is out of bounds')\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if k == 1:\n            return min(arr1[i], arr2[j])\n        if arr1[i] < arr2[j]:\n            i += 1\n        else:\n            j += 1\n        k -= 1\n    while i < len(arr1):\n        if k == 1:\n            return arr1[i]\n        i += 1\n        k -= 1\n    while j < len(arr2):\n        if k == 1:\n            return arr2[j]\n        j += 1\n        k -= 1\n    raise IndexError('k is out of bounds')", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise IndexError('k is out of bounds')\n    index1, index2 = (0, 0)\n    while index1 < len(arr1) and index2 < len(arr2):\n        if k == 1:\n            return min(arr1[index1], arr2[index2])\n        middle = k // 2\n        new_index1 = min(index1 + middle, len(arr1)) - 1\n        new_index2 = min(index2 + middle, len(arr2)) - 1\n        if arr1[new_index1] <= arr2[new_index2]:\n            k -= new_index1 - index1 + 1\n            index1 = new_index1 + 1\n        else:\n            k -= new_index2 - index2 + 1\n            index2 = new_index2 + 1\n    if index1 < len(arr1):\n        return arr1[index1 + k - 1]\n    return arr2[index2 + k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise IndexError('k is out of bounds')\n    index1, index2, count = (0, 0, 0)\n    while index1 < len(arr1) and index2 < len(arr2):\n        if arr1[index1] < arr2[index2]:\n            count += 1\n            if count == k:\n                return arr1[index1]\n            index1 += 1\n        else:\n            count += 1\n            if count == k:\n                return arr2[index2]\n            index2 += 1\n    while index1 < len(arr1):\n        count += 1\n        if count == k:\n            return arr1[index1]\n        index1 += 1\n    while index2 < len(arr2):\n        count += 1\n        if count == k:\n            return arr2[index2]\n        index2 += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/602", "requirement": "def first_repeated_char(str1: str) -> str:\n    \"\"\"\n    Write a python function to find the first repeated character in a given string. \n    If no characters are repeated, return an empty string.\n    assert first_repeated_char(\"abcabc\") == \"a\"\n    \"\"\"", "generated_programs": ["def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "from typing import Dict\n\ndef first_repeated_char(str1: str) -> str:\n    seen: Dict[str, bool] = {}\n    for char in str1:\n        if char in seen:\n            return char\n        seen[char] = True\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen_chars = set()\n    for char in str1:\n        if char in seen_chars:\n            return char\n        seen_chars.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/604", "requirement": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse the order of words in a given string, where words are separated by one or more spaces. \n    The function should remove any leading, trailing, or multiple consecutive spaces between words before reversing the order.\n    assert reverse_words(\"python program\")==(\"program python\")\n    \"\"\"", "generated_programs": ["def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "def reverse_words(s: str) -> str:\n    words = s.split()\n    return ' '.join(reversed(words))", "def reverse_words(s: str) -> str:\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = reversed(words)\n    return ' '.join(reversed_words)", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/620", "requirement": "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    \"\"\"\n    Write a function to find the size of the largest subset of a list of numbers where for every pair of numbers in the subset, one number is divisible by the other.\n    The function should return 0 if the input list is empty.\n    \n    Examples:\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n    \"\"\"\n    Write a Python function to find the area of the largest right-angled triangle that can be inscribed in a semicircle with a given radius. \n    The triangle has its hypotenuse equal to the diameter of the semicircle and its legs equal to the radius of the semicircle. \n    The area of the triangle is calculated as the square of the radius. \n    The function should return `None` if the radius is negative.\n    assert triangle_area(-1) == None\n    \"\"\"", "generated_programs": ["def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/630", "requirement": "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given 2D coordinate tuple, including the original coordinate.\n    The function should raise a ValueError if the input tuple does not have exactly two dimensions.\n    \n    Args:\n        test_tup (Tuple[int, ...]): A tuple representing a 2D coordinate. The tuple must have exactly two elements.\n    \n    Returns:\n        List[List[int]]: A list of lists, where each inner list represents an adjacent coordinate, including the original coordinate.\n    \n    Raises:\n        ValueError: If the input tuple does not have exactly two dimensions.\n    \n    Examples:\n        >>> get_coordinates((3, 4))\n        [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n        \n        >>> get_coordinates((1, 1, 1))\n        ValueError\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two dimensions.')\n    x, y = test_tup\n    coordinates = []\n    for i in range(x - 1, x + 2):\n        for j in range(y - 1, y + 2):\n            coordinates.append([i, j])\n    return coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('The input tuple must have exactly two elements.')\n    x, y = test_tup\n    adjacent_coordinates = [[x - 1, y - 1], [x - 1, y], [x - 1, y + 1], [x, y - 1], [x, y], [x, y + 1], [x + 1, y - 1], [x + 1, y], [x + 1, y + 1]]\n    return adjacent_coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two dimensions.')\n    x, y = test_tup\n    adjacent_coordinates = []\n    for dx in (-1, 0, 1):\n        for dy in (-1, 0, 1):\n            adjacent_coordinates.append([x + dx, y + dy])\n    return adjacent_coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('The input tuple must have exactly two dimensions.')\n    x, y = test_tup\n    coordinates = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            coordinates.append([x + dx, y + dy])\n    return coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two dimensions.')\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('The input tuple must have exactly two dimensions.')\n    x, y = test_tup\n    adjacent_coordinates = []\n    for i in range(x - 1, x + 2):\n        for j in range(y - 1, y + 2):\n            adjacent_coordinates.append([i, j])\n    return adjacent_coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('The input tuple must have exactly two dimensions.')\n    x, y = test_tup\n    coordinates = [[x + dx, y + dy] for dx in [-1, 0, 1] for dy in [-1, 0, 1]]\n    return coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    adjacent_coordinates = [[x + dx, y + dy] for dx in (-1, 0, 1) for dy in (-1, 0, 1)]\n    return adjacent_coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two dimensions.')\n    x, y = test_tup\n    adjacent_coords = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            adjacent_coords.append([x + dx, y + dy])\n    return adjacent_coords", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two dimensions.')\n    x, y = test_tup\n    adjacent_coordinates = [[x - 1, y - 1], [x - 1, y], [x - 1, y + 1], [x, y - 1], [x, y], [x, y + 1], [x + 1, y - 1], [x + 1, y], [x + 1, y + 1]]\n    return adjacent_coordinates"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/631", "requirement": "def replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace all whitespaces with underscores in a given string.\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    \"\"\"", "generated_programs": ["def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the nearest integer given the wind velocity in km/h and a temperature in celsius.\n    assert wind_chill(120,35)==40\n    \"\"\"", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wc_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wc_index)", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n    return round(wci)", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n    return round(wind_chill_index)", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wind_chill_index)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.4}}
{"task_id": "Mbpp/722", "requirement": "def filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    Filters students whose height and weight are both greater than or equal to the specified minimum values.\n    The function returns a dictionary containing only those students who meet both the height and weight criteria.\n    \n    Args:\n        students: A dictionary where the key is the student's name and the value is a tuple of (height, weight).\n        h: The minimum height threshold. Students must have a height greater than or equal to this value.\n        w: The minimum weight threshold. Students must have a weight greater than or equal to this value.\n    \n    Returns:\n        A dictionary of students who meet both the height and weight criteria, with their names as keys and (height, weight) tuples as values.\n    \n    Example:\n        >>> filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70)\n        {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: dimensions for name, dimensions in students.items() if dimensions[0] >= h and dimensions[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: hw for name, hw in students.items() if hw[0] >= h and hw[1] >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/735", "requirement": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Write a Python function to toggle all bits of the number except the most significant bit (MSB) and the least significant bit (LSB).\n    - If the number has 2 or fewer bits, return the number as-is.\n    - If the input is 0, return 1.\n    assert toggle_middle_bits(9) == 15\n    \"\"\"", "generated_programs": ["def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) <= 2:\n        return n\n    toggled_middle = ''.join(('1' if bit == '0' else '0' for bit in binary[1:-1]))\n    result_binary = binary[0] + toggled_middle + binary[-1]\n    return int(result_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) <= 2:\n        return n\n    toggled_middle = ''.join(('1' if bit == '0' else '0' for bit in binary_representation[1:-1]))\n    new_binary = binary_representation[0] + toggled_middle + binary_representation[-1]\n    return int(new_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) <= 2:\n        return n\n    middle_bits_toggled = ''.join(('1' if bit == '0' else '0' for bit in binary_representation[1:-1]))\n    toggled_binary = binary_representation[0] + middle_bits_toggled + binary_representation[-1]\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_rep = bin(n)[2:]\n    if len(binary_rep) <= 2:\n        return n\n    msb = binary_rep[0]\n    lsb = binary_rep[-1]\n    middle_bits = binary_rep[1:-1]\n    toggled_middle_bits = ''.join(('1' if bit == '0' else '0' for bit in middle_bits))\n    result_binary = msb + toggled_middle_bits + lsb\n    return int(result_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) <= 2:\n        return n\n    msb = binary_representation[0]\n    lsb = binary_representation[-1]\n    middle_bits = ''.join(('1' if b == '0' else '0' for b in binary_representation[1:-1]))\n    toggled_binary = msb + middle_bits + lsb\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) <= 2:\n        return n\n    msb = binary[0]\n    lsb = binary[-1]\n    middle_bits = binary[1:-1]\n    toggled_middle_bits = ''.join(('1' if bit == '0' else '0' for bit in middle_bits))\n    toggled_binary = msb + toggled_middle_bits + lsb\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) <= 2:\n        return n\n    msb = binary[0]\n    lsb = binary[-1]\n    middle_bits = ''.join(('1' if bit == '0' else '0' for bit in binary[1:-1]))\n    toggled_binary = msb + middle_bits + lsb\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) <= 2:\n        return n\n    toggled = binary[0] + ''.join(('1' if b == '0' else '0' for b in binary[1:-1])) + binary[-1]\n    return int(toggled, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) <= 2:\n        return n\n    msb = binary[0]\n    lsb = binary[-1]\n    middle_bits = binary[1:-1]\n    toggled_middle_bits = ''.join(('1' if bit == '0' else '0' for bit in middle_bits))\n    toggled_binary = msb + toggled_middle_bits + lsb\n    return int(toggled_binary, 2)", "from typing import Optional\n\ndef toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    bin_str = bin(n)[2:]\n    if len(bin_str) <= 2:\n        return n\n    msb = bin_str[0]\n    lsb = bin_str[-1]\n    middle_bits = ''.join(('1' if b == '0' else '0' for b in bin_str[1:-1]))\n    toggled_bin_str = msb + middle_bits + lsb\n    return int(toggled_bin_str, 2)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/740", "requirement": "from typing import Dict\nfrom typing import Tuple\nfrom typing import Any\n\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    \"\"\"\n    Write a function to convert the given tuple to a key-value dictionary by pairing every two consecutive elements.\n    The first element of each pair becomes the key, and the second element becomes the value. \n    The function assumes the tuple has an even number of elements. If the tuple has an odd number of elements, \n    the last element is ignored.\n    \n    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/743", "requirement": "from typing import List\n\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotates the given list `l` by `m` items to the right in a cyclic manner. \n    If the list is empty, a `ZeroDivisionError` will be raised. \n    The rotation is cyclic, meaning that if `m` exceeds the length of the list, \n    it wraps around using the modulo operation (`m % len(l)`). \n    If `m` is zero or negative, the function will still perform a cyclic rotation \n    based on the modulo result.\n\n    Examples:\n    >>> rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n    [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    >>> rotate_right([], 3)\n    ZeroDivisionError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    m %= len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('List is empty')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('List is empty')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('The list is empty, rotation is undefined.')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Attempting to rotate an empty list.')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Attempt to rotate an empty list.')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('List is empty')\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('List is empty')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list')\n    length = len(l)\n    m = m % length\n    return l[-m:] + l[:-m]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\"\"\"\nWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. \nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(num: int) -> bool:\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                return False\n        return True\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(n: int) -> bool:\n        digits = [int(d) for d in str(n) if d != '0']\n        return all((n % d == 0 for d in digits))\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        num_str = str(num)\n        if all((d != '0' and num % int(d) == 0 for d in num_str)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(num: int) -> bool:\n        original_num = num\n        while num > 0:\n            digit = num % 10\n            if digit == 0 or original_num % digit != 0:\n                return False\n            num //= 10\n        return True\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(n: int) -> bool:\n        original_number = n\n        while n > 0:\n            digit = n % 10\n            if digit == 0 or original_number % digit != 0:\n                return False\n            n //= 10\n        return True\n    result = []\n    for number in range(startnum, endnum + 1):\n        if is_divisible_by_digits(number):\n            result.append(number)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if '0' in str_num:\n            continue\n        if all((num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(number: int) -> bool:\n        for digit in str(number):\n            if digit == '0' or number % int(digit) != 0:\n                return False\n        return True\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        is_divisible = True\n        str_num = str(num)\n        for char in str_num:\n            digit = int(char)\n            if digit == 0 or num % digit != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.7, "original_passk": 0.4}}
{"task_id": "Mbpp/752", "requirement": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Compute the nth Jacobsthal number using an iterative approach.\n    The Jacobsthal sequence is defined as:\n    J(0) = 0, J(1) = 1, and J(n) = J(n-1) + 2 * J(n-2) for n >= 2.\n    The function should handle non-negative integer inputs and return the nth Jacobsthal number.\n    For invalid inputs (e.g., negative integers), the behavior is undefined.\n\n    Examples:\n    >>> jacobsthal_num(5)\n    11\n    >>> jacobsthal_num(0)\n    0\n    >>> jacobsthal_num(1)\n    1\n    \"\"\"", "generated_programs": ["def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = (0, 1)\n    for i in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    prev2, prev1 = (0, 1)\n    for _ in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2, prev1 = (prev1, current)\n    return prev1", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    j_prev2, j_prev1 = (0, 1)\n    for _ in range(2, n + 1):\n        j_curr = j_prev1 + 2 * j_prev2\n        j_prev2, j_prev1 = (j_prev1, j_curr)\n    return j_prev1", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    j_prev = 0\n    j_curr = 1\n    for _ in range(2, n + 1):\n        j_next = j_curr + 2 * j_prev\n        j_prev = j_curr\n        j_curr = j_next\n    return j_curr", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    j_prev, j_curr = (0, 1)\n    for _ in range(2, n + 1):\n        j_next = j_curr + 2 * j_prev\n        j_prev, j_curr = (j_curr, j_next)\n    return j_curr", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    j_2 = 0\n    j_1 = 1\n    j_n = 0\n    for i in range(2, n + 1):\n        j_n = j_1 + 2 * j_2\n        j_2 = j_1\n        j_1 = j_n\n    return j_n", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    j_minus_two, j_minus_one = (0, 1)\n    for i in range(2, n + 1):\n        j_current = j_minus_one + 2 * j_minus_two\n        j_minus_two = j_minus_one\n        j_minus_one = j_current\n    return j_minus_one", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    j0, j1 = (0, 1)\n    for i in range(2, n + 1):\n        jn = j1 + 2 * j0\n        j0, j1 = (j1, jn)\n    return j1", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    j_minus_2 = 0\n    j_minus_1 = 1\n    for i in range(2, n + 1):\n        j_current = j_minus_1 + 2 * j_minus_2\n        j_minus_2 = j_minus_1\n        j_minus_1 = j_current\n    return j_minus_1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int = None) -> int:\n    \"\"\"\n    Write a Python function to find the minimum difference between any two elements in a given array or tuple.\n    The function should handle both lists and tuples as input. The parameter `n` is optional and should be ignored.\n    The array or tuple should be sorted before calculating the minimum difference.\n    \n    Examples:\n    >>> find_min_diff((1, 5, 3, 19, 18, 25), 6)\n    1\n    \"\"\"", "generated_programs": ["from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(sorted_arr) - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(sorted_arr) - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        min_diff = min(min_diff, diff)\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(arr_sorted) - 1):\n        min_diff = min(min_diff, arr_sorted[i + 1] - arr_sorted[i])\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    if not arr:\n        return float('inf')\n    sorted_arr = sorted(arr)\n    return min((sorted_arr[i + 1] - sorted_arr[i] for i in range(len(sorted_arr) - 1)))", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    arr = sorted(arr)\n    return min((arr[i + 1] - arr[i] for i in range(len(arr) - 1)))", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        min_diff = min(min_diff, diff)\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number. A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers. The sequence of polite numbers starts as 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, ... \n    The function should return the nth number in this sequence.\n    \n    assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef is_polite(n: int) -> int:\n\n    def is_polite_num(num: int) -> bool:\n        for length in range(2, num):\n            if length * (length - 1) // 2 < num and (num - length * (length - 1) // 2) % length == 0:\n                return True\n        return False\n    polite_numbers: List[int] = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if is_polite_num(current):\n            polite_numbers.append(current)\n    return polite_numbers[n - 1]", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        for start in range(1, x):\n            total = 0\n            for consecutive in range(start, x):\n                total += consecutive\n                if total == x:\n                    return True\n                elif total > x:\n                    break\n        return False\n    count = 0\n    current = 1\n    while count < n:\n        current += 1\n        if is_polite_number(current):\n            count += 1\n    return current", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        for k in range(2, x):\n            if k * (k + 1) // 2 > x:\n                break\n            if (x - k * (k + 1) // 2) % k == 0:\n                return True\n        return False\n    polite_numbers = []\n    candidate = 1\n    while len(polite_numbers) < n:\n        candidate += 1\n        if is_polite_number(candidate):\n            polite_numbers.append(candidate)\n    return polite_numbers[-1]", "def is_polite(n: int) -> int:\n\n    def is_polite_number(number):\n        for start in range(1, number):\n            sum_seq = 0\n            for num in range(start, number):\n                sum_seq += num\n                if sum_seq == number:\n                    return True\n                if sum_seq > number:\n                    break\n        return False\n    count, current = (0, 1)\n    while count < n:\n        current += 1\n        if is_polite_number(current):\n            count += 1\n    return current", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        for start in range(1, x):\n            total = 0\n            inc = start\n            while total < x:\n                total += inc\n                inc += 1\n            if total == x:\n                return True\n        return False\n    count = 0\n    current = 1\n    while count < n:\n        current += 1\n        if is_polite_number(current):\n            count += 1\n    return current", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x: int) -> bool:\n        for start in range(1, x):\n            total = 0\n            consecutive = start\n            while total < x:\n                total += consecutive\n                consecutive += 1\n            if total == x:\n                return True\n        return False\n    count = 0\n    number = 1\n    while count < n:\n        number += 1\n        if is_polite_number(number):\n            count += 1\n    return number", "def is_polite(n: int) -> int:\n\n    def is_polite_number(number):\n        for start in range(1, number):\n            total = 0\n            num = start\n            while total < number:\n                total += num\n                num += 1\n                if total == number:\n                    return True\n        return False\n    polite_numbers = []\n    candidate = 1\n    while len(polite_numbers) < n:\n        if is_polite_number(candidate):\n            polite_numbers.append(candidate)\n        candidate += 1\n    return polite_numbers[n - 1]", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        return x & x - 1 != 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if is_polite_number(current):\n            polite_numbers.append(current)\n    return polite_numbers[-1]", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        return x & x - 1 != 0\n    polite_numbers = []\n    i = 1\n    while len(polite_numbers) < n:\n        i += 1\n        if is_polite_number(i):\n            polite_numbers.append(i)\n    return polite_numbers[n - 1]", "def is_polite(n: int) -> int:\n\n    def is_polite_number(num: int) -> bool:\n        for start in range(1, num // 2 + 1):\n            total = 0\n            for next_num in range(start, num):\n                total += next_num\n                if total == num:\n                    return True\n                if total > num:\n                    break\n        return False\n    count = 0\n    current = 1\n    while count < n:\n        current += 1\n        if is_polite_number(current):\n            count += 1\n    return current"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2)) + list(set(li2) - set(li1))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even number and the first odd number in a given list.\n    If either an even or odd number is not found in the list, the function should return 0.\n    \n    Examples:\n    >>> mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8])\n    4\n    >>> mul_even_odd([2, 4, 6, 8])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if not even_found and num % 2 == 0:\n            first_even = num\n            even_found = True\n        if not odd_found and num % 2 != 0:\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            break\n    if even_found and odd_found:\n        return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    found_even = False\n    found_odd = False\n    even = odd = 0\n    for num in list1:\n        if not found_even and num % 2 == 0:\n            even = num\n            found_even = True\n        if not found_odd and num % 2 != 0:\n            odd = num\n            found_odd = True\n        if found_even and found_odd:\n            break\n    if found_even and found_odd:\n        return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = None\n    odd_found = None\n    for num in list1:\n        if num % 2 == 0 and even_found is None:\n            even_found = num\n        elif num % 2 != 0 and odd_found is None:\n            odd_found = num\n        if even_found is not None and odd_found is not None:\n            break\n    if even_found is not None and odd_found is not None:\n        return even_found * odd_found\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and (not even_found):\n            first_even = num\n            even_found = True\n        elif num % 2 != 0 and (not odd_found):\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            break\n    if even_found and odd_found:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    found_even = False\n    found_odd = False\n    even_num = 0\n    odd_num = 0\n    for num in list1:\n        if not found_even and num % 2 == 0:\n            even_num = num\n            found_even = True\n        elif not found_odd and num % 2 != 0:\n            odd_num = num\n            found_odd = True\n        if found_even and found_odd:\n            return even_num * odd_num\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if not even_found and num % 2 == 0:\n            first_even = num\n            even_found = True\n        if not odd_found and num % 2 != 0:\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    even_number = 0\n    odd_number = 0\n    for num in list1:\n        if num % 2 == 0 and (not even_found):\n            even_number = num\n            even_found = True\n        elif num % 2 != 0 and (not odd_found):\n            odd_number = num\n            odd_found = True\n        if even_found and odd_found:\n            return even_number * odd_number\n    return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/785", "requirement": "def tuple_str_int(test_str: str) -> tuple:\n\"\"\"\nWrite a function to convert tuple string to integer tuple.\nassert tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)\n\"\"\"", "generated_programs": ["def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(',')))", "import ast\n\ndef tuple_str_int(test_str: str) -> tuple:\n    return tuple(ast.literal_eval(test_str))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(', ')))", "def tuple_str_int(test_str: str) -> tuple:\n    result = tuple(map(int, test_str.strip('()').split(',')))\n    return result", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(', ')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(', ')))", "import ast\nfrom typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, ...]:\n    return ast.literal_eval(test_str)", "from typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, ...]:\n    return tuple(map(int, test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(', ')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(', ')))"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.8, "original_passk": 0.9}}
{"task_id": "Mbpp/787", "requirement": "def text_match_three(text: str) -> re.Match:\n\"\"\"\nWrite a function that matches a string that has an a followed by three 'b'.\nassert not text_match_three(\"ac\")\n\"\"\"", "generated_programs": ["import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    return re.search(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    match = re.search(pattern, text)\n    return match", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    return re.search(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    return re.search(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    return re.search(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.fullmatch('.*ab{3}.*', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    return re.search(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    return re.search(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    return re.search(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n\"\"\"\nWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\nassert text_starta_endb(\"aabbbb\")\n\"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.search('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.search('a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = 'a.*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.match(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/16", "requirement": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if the input string contains any occurrence of one or more lowercase letters followed by an underscore and then one or more lowercase letters, and False otherwise.\n    assert text_lowercase_underscore(\"aab_cbbbc\")==(True)\n    \"\"\"", "generated_programs": ["import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "Mbpp/63", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute difference between the two elements within each tuple in the given list.\n    If the list is empty, the function should return 0.\n\n    Example:\n    >>> max_difference([(3, 5), (1, 7), (10, 3), (1, 2)])\n    7\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    max_diff = 0\n    for a, b in test_list:\n        current_diff = abs(a - b)\n        if current_diff > max_diff:\n            max_diff = current_diff\n    return max_diff", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/72", "requirement": "def dif_Square(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given number can be represented as the difference of two squares or not. \n    The function should handle both positive and negative integers. For negative inputs, the function should return `False` \n    since the difference of two squares cannot be negative. For positive integers, the function should return `True` if \n    the number can be expressed as `j^2 - i^2` where `j` and `i` are non-negative integers. The function should use the \n    mathematical property that a number `n` can be represented as the difference of two squares if and only if `n % 4 != 2`.\n\n    Examples:\n    assert dif_Square(5) == True\n    assert dif_Square(-3) == False\n    assert dif_Square(8) == True\n    assert dif_Square(10) == False\n    \"\"\"", "generated_programs": ["def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n    \"\"\"\n    Determine whether a given integer is divisible by 11 using the modulo operation.\n    This function handles both positive and negative integers correctly.\n    \n    Args:\n        n (int): The integer to check for divisibility by 11.\n    \n    Returns:\n        bool: True if the integer is divisible by 11, False otherwise.\n    \n    Examples:\n        >>> is_Diff(12345)\n        False\n        >>> is_Diff(-121)\n        True\n    \"\"\"", "generated_programs": ["def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/92", "requirement": "def is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not. \n    An undulating number is defined as a number where the digits strictly alternate between two distinct values. \n    For example, in the number `1212121`, the digits alternate between `1` and `2`.\n    The function should return `True` if the number follows this strict alternating pattern, and `False` otherwise.\n    \n    assert is_undulating(1212121) == True\n    \"\"\"", "generated_programs": ["def is_undulating(n: int) -> bool:\n    digits = str(n)\n    if len(digits) < 2:\n        return False\n    distinct_digits = {digits[0], digits[1]}\n    if len(distinct_digits) != 2:\n        return False\n    for i in range(len(digits)):\n        if digits[i] != digits[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    digits = str(n)\n    if len(digits) < 3:\n        return False\n    first, second = (digits[0], digits[1])\n    if first == second:\n        return False\n    for i in range(len(digits)):\n        if i % 2 == 0 and digits[i] != first:\n            return False\n        if i % 2 == 1 and digits[i] != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    digits = str(n)\n    if len(digits) < 2:\n        return False\n    distinct_digits = (digits[0], digits[1])\n    if distinct_digits[0] == distinct_digits[1]:\n        return False\n    for i in range(len(digits)):\n        if digits[i] != distinct_digits[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    digit_str = str(n)\n    if len(digit_str) < 2:\n        return False\n    first_digit = digit_str[0]\n    second_digit = digit_str[1]\n    if first_digit == second_digit:\n        return False\n    for i in range(len(digit_str)):\n        if i % 2 == 0 and digit_str[i] != first_digit:\n            return False\n        elif i % 2 == 1 and digit_str[i] != second_digit:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    digits = list(str(n))\n    if len(digits) < 3:\n        return False\n    first_digit, second_digit = (digits[0], digits[1])\n    if first_digit == second_digit:\n        return False\n    for i in range(2, len(digits)):\n        if digits[i] != digits[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    digits = str(n)\n    if len(digits) < 2:\n        return False\n    unique_digits = set(digits)\n    if len(unique_digits) != 2:\n        return False\n    for i in range(len(digits) - 1):\n        if digits[i] == digits[i + 1]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    num_str = str(n)\n    if len(num_str) < 2:\n        return False\n    first_digit, second_digit = (num_str[0], num_str[1])\n    if first_digit == second_digit:\n        return False\n    for i in range(len(num_str)):\n        if i % 2 == 0 and num_str[i] != first_digit:\n            return False\n        elif i % 2 != 0 and num_str[i] != second_digit:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    digits = list(str(n))\n    if len(digits) < 2:\n        return False\n    first, second = (digits[0], digits[1])\n    if first == second:\n        return False\n    for i in range(len(digits)):\n        if i % 2 == 0 and digits[i] != first:\n            return False\n        elif i % 2 == 1 and digits[i] != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    digits = str(n)\n    if len(digits) < 3:\n        return False\n    distinct_values = {digits[0], digits[1]}\n    if len(distinct_values) != 2:\n        return False\n    return all((digits[i] != digits[i - 1] and digits[i] in distinct_values for i in range(2, len(digits))))", "def is_undulating(n: int) -> bool:\n    digits = str(n)\n    if len(digits) < 2:\n        return False\n    first_digit = digits[0]\n    second_digit = digits[1]\n    if first_digit == second_digit:\n        return False\n    for i in range(len(digits)):\n        if i % 2 == 0:\n            if digits[i] != first_digit:\n                return False\n        elif digits[i] != second_digit:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given positive integer.\n    The function should raise a ValueError if the input is not a positive integer.\n\n    Parameters:\n    n (int): A positive integer for which to find the number of positive divisors.\n\n    Returns:\n    int: The number of positive divisors of the given integer.\n\n    Raises:\n    ValueError: If the input `n` is not a positive integer.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer.\n    \"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/99", "requirement": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Write a function to convert the given decimal number to its binary equivalent, represented as a string.\n    The binary string should start with the first non-zero digit, and if the input is 0, the function should return '0'.\n    assert decimal_to_binary(8) == '1000'\n    \"\"\"", "generated_programs": ["def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n //= 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = bin(n)[2:]\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_string = ''\n    while n > 0:\n        binary_string = str(n % 2) + binary_string\n        n = n // 2\n    return binary_string", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/103", "requirement": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m), which represents the number of permutations of the set {1, 2, ..., n} \n    with exactly m ascents. The function should handle the following constraints:\n    \n    - `n` must be a non-negative integer.\n    - `m` must be a non-negative integer such that `0 <= m < n`.\n    - If `n` is 0, the function should return 0.\n    - If `m` is negative or `m >= n`, the function should return 0.\n    \n    The Eulerian number can be computed using the following formula:\n    a(n, m) = sum_{k=0}^{m+1} (-1)^k * C(n + 1, k) * (m + 1 - k)^n,\n    where C(n, k) is the binomial coefficient.\n    \n    Examples:\n    >>> eulerian_num(3, 1)\n    4\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n <= 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n <= 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    result = 0\n    for k in range(m + 2):\n        result += (-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n\n    return result", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n <= 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n <= 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n <= 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n <= 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "import math\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    result = 0\n    for k in range(m + 2):\n        sign = (-1) ** k\n        binomial_coeff = math.comb(n + 1, k)\n        term = (m + 1 - k) ** n\n        result += sign * binomial_coeff * term\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements in all inner lists of the given nested list. \n    The function should return the intersection of all inner lists. \n    If the nested list is empty or contains any empty inner list, the function should raise a TypeError.\n\n    Examples:\n    >>> assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    >>> common_in_nested_lists([[]])\n    TypeError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not lst for lst in nestedlist)):\n        raise TypeError('Nested list is empty or contains empty inner lists.')\n    common_elements = set(nestedlist[0])\n    for lst in nestedlist[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(inner_list) == 0 for inner_list in nestedlist)):\n        raise TypeError('Empty nested list or empty inner list found.')\n    common_elements = set(nestedlist[0])\n    for inner_list in nestedlist[1:]:\n        common_elements.intersection_update(inner_list)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not lst for lst in nestedlist)):\n        raise TypeError('Nested list is empty or contains an empty inner list.')\n    common_elements = set(nestedlist[0])\n    for lst in nestedlist[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(inner) == 0 for inner in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for inner_list in nestedlist[1:]:\n        common_elements.intersection_update(inner_list)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not inner_list for inner_list in nestedlist)):\n        raise TypeError('The nested list cannot be empty, nor can it contain empty inner lists.')\n    common_elements = set(nestedlist[0])\n    for inner_list in nestedlist[1:]:\n        common_elements &= set(inner_list)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(inner_list) == 0 for inner_list in nestedlist)):\n        raise TypeError('Nested list is empty or contains empty inner list')\n    common_set = set(nestedlist[0])\n    for inner_list in nestedlist[1:]:\n        common_set.intersection_update(inner_list)\n    return list(common_set)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(inner) == 0 for inner in nestedlist)):\n        raise TypeError('Empty nested list or empty inner list found')\n    common_elements = set(nestedlist[0])\n    for inner_list in nestedlist[1:]:\n        common_elements.intersection_update(inner_list)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not inner_list for inner_list in nestedlist)):\n        raise TypeError('Empty nested list or inner list found.')\n    result_set = set(nestedlist[0])\n    for inner_list in nestedlist[1:]:\n        result_set.intersection_update(inner_list)\n    return list(result_set)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(inner) == 0 for inner in nestedlist)):\n        raise TypeError('Nested list is empty or contains an empty inner list.')\n    common_elements = set(nestedlist[0])\n    for inner in nestedlist[1:]:\n        common_elements.intersection_update(inner)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not inner_list for inner_list in nestedlist)):\n        raise TypeError('Input list is empty or contains an empty inner list.')\n    common_elements = set(nestedlist[0])\n    for inner_list in nestedlist[1:]:\n        common_elements.intersection_update(inner_list)\n    return list(common_elements)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/120", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute value of the product of the two numbers in each tuple within a given list.\n    The function should calculate the product of the two numbers in each tuple and then take the absolute value of that product.\n    Finally, it should return the maximum of these absolute products.\n    \n    Example:\n    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n\"\"\"\nWrite a function to sum all amicable numbers from 1 to a specified number.\n\n\nassert amicable_numbers_sum(999)==504\n\"\"\"", "generated_programs": ["def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    total_sum = 0\n    for num in range(2, limit):\n        div_sum = sum_of_divisors(num)\n        if div_sum != num and div_sum < limit and (sum_of_divisors(div_sum) == num):\n            total_sum += num\n    return total_sum", "from typing import List\n\ndef divisors_sum(n: int) -> int:\n    return sum((i for i in range(1, n) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def is_amicable(a: int, b: int) -> bool:\n        return a != b and divisors_sum(a) == b and (divisors_sum(b) == a)\n    amicable_sum = 0\n    for number in range(2, limit):\n        potential_pair = divisors_sum(number)\n        if potential_pair < limit and is_amicable(number, potential_pair):\n            amicable_sum += number\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    sum_amicable = 0\n    for number in range(2, limit):\n        partner = sum_of_divisors(number)\n        if partner != number and partner < limit and (sum_of_divisors(partner) == number):\n            sum_amicable += number\n    return sum_amicable", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    total_sum = 0\n    for num in range(2, limit + 1):\n        partner = sum_of_divisors(num)\n        if partner != num and partner <= limit and (sum_of_divisors(partner) == num):\n            total_sum += num\n    return total_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for num in range(2, limit):\n        partner = sum_of_divisors(num)\n        if partner != num and partner < limit and (sum_of_divisors(partner) == num):\n            amicable_sum += num\n    return amicable_sum", "import math\n\ndef sum_of_divisors(n: int) -> int:\n    divisors_sum = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                divisors_sum += i\n            else:\n                divisors_sum += i + n // i\n    return divisors_sum\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for number in range(2, limit):\n        partner = sum_of_divisors(number)\n        if partner != number and partner < limit and (sum_of_divisors(partner) == number):\n            amicable_sum += number\n    return amicable_sum", "import math\n\ndef sum_of_divisors(n: int) -> int:\n    total = 1\n    sqrt_n = int(math.sqrt(n))\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def is_amicable(a: int) -> bool:\n        b = sum_of_divisors(a)\n        return b != a and sum_of_divisors(b) == a\n    return sum((a for a in range(2, limit) if is_amicable(a)))", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for number in range(2, limit + 1):\n        sum_div = sum_of_divisors(number)\n        if sum_div != number and sum_of_divisors(sum_div) == number:\n            amicable_sum += number\n    return amicable_sum", "import math\n\ndef divisors_sum(n: int) -> int:\n    if n < 2:\n        return 0\n    s = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            s += i\n            if i != n // i:\n                s += n // i\n    return s\n\ndef amicable_numbers_sum(limit: int) -> int:\n    visited = set()\n    total_sum = 0\n    for num in range(2, limit):\n        if num not in visited:\n            sum_div = divisors_sum(num)\n            if sum_div != num and divisors_sum(sum_div) == num:\n                total_sum += num + sum_div\n                visited.add(num)\n                visited.add(sum_div)\n    return total_sum", "from typing import List\n\ndef sum_of_divisors(n: int) -> int:\n    divisors_sum = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def is_amicable(a: int) -> bool:\n        b = sum_of_divisors(a)\n        return a != b and sum_of_divisors(b) == a\n    total_sum = 0\n    for number in range(2, limit + 1):\n        if is_amicable(number):\n            total_sum += number\n    return total_sum"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Write a function to get the angle (in radians) of the difference between two complex numbers `b` and `a`.\n    The angle is calculated as the phase of the complex number resulting from `b - a`.\n    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\nfrom cmath import phase\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return phase(b - a)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\nfrom cmath import phase\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return phase(b - a)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2((b - a).imag, (b - a).real)", "import math\nfrom typing import Complex\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.phase(b - a)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/126", "requirement": "def sum_of_common_divisors(a: int, b: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of all unique positive common divisors of two given positive integers.\n    The function should handle only positive integers and return the sum of the unique positive divisors that divide both numbers.\n    The function should not consider negative numbers or zero as valid inputs.\n    assert sum_of_common_divisors(10, 15) == 6\n    \"\"\"", "generated_programs": ["import math\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    if a <= 0 or b <= 0:\n        raise ValueError('Inputs must be positive integers')\n    gcd_value = math.gcd(a, b)\n    divisor_sum = 0\n    for i in range(1, int(math.sqrt(gcd_value)) + 1):\n        if gcd_value % i == 0:\n            divisor_sum += i\n            if i != gcd_value // i:\n                divisor_sum += gcd_value // i\n    return divisor_sum", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_divisor_sum = 0\n    greatest_common_divisor = gcd(a, b)\n    for i in range(1, greatest_common_divisor + 1):\n        if greatest_common_divisor % i == 0:\n            common_divisor_sum += i\n    return common_divisor_sum", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    common_divisors = get_divisors(gcd(a, b))\n    return sum(common_divisors)", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_divisor_sum = 0\n    g = gcd(a, b)\n    for i in range(1, g + 1):\n        if g % i == 0:\n            common_divisor_sum += i\n    return common_divisor_sum", "import math\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    return sum((d for d in range(1, math.gcd(a, b) + 1) if math.gcd(a, b) % d == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_divisor_sum = 0\n    greatest_common_divisor = gcd(a, b)\n    for i in range(1, greatest_common_divisor + 1):\n        if greatest_common_divisor % i == 0:\n            common_divisor_sum += i\n    return common_divisor_sum", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_divisor_sum = 0\n    gcd_ab = gcd(a, b)\n    for i in range(1, gcd_ab + 1):\n        if gcd_ab % i == 0:\n            common_divisor_sum += i\n    return common_divisor_sum", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    return sum((i for i in range(1, gcd(a, b) + 1) if a % i == 0 and b % i == 0))", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_gcd = gcd(a, b)\n    return sum([i for i in range(1, common_gcd + 1) if common_gcd % i == 0])", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n    common_divisor_sum = 0\n    common_gcd = gcd(a, b)\n    for i in range(1, common_gcd + 1):\n        if common_gcd % i == 0:\n            common_divisor_sum += i\n    return common_divisor_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether the given square matrix is a magic square.\n    A magic square is a square matrix where the sums of the numbers in each row, each column, and both main diagonals are all equal to the magic sum.\n    The magic sum for an n x n matrix is calculated as n * (n^2 + 1) / 2.\n    The function should return True if the matrix is a magic square, otherwise False.\n    The function assumes that the input is a square matrix (i.e., all rows have the same length as the number of rows).\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if n == 0:\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix:\n        return False\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col_idx in range(n):\n        column_sum = sum((my_matrix[row_idx][col_idx] for row_idx in range(n)))\n        if column_sum != magic_sum:\n            return False\n    main_diagonal_sum = sum((my_matrix[i][i] for i in range(n)))\n    if main_diagonal_sum != magic_sum:\n        return False\n    anti_diagonal_sum = sum((my_matrix[i][n - i - 1] for i in range(n)))\n    if anti_diagonal_sum != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if n == 0:\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/130", "requirement": "from typing import List\n\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with the maximum frequency in a given non-empty list of integers.\n    If the list is empty, the function will raise an IndexError.\n    \n    Args:\n        nums (List[int]): A non-empty list of integers.\n    \n    Returns:\n        int: The item with the maximum frequency in the list.\n    \n    Raises:\n        IndexError: If the input list is empty.\n    \n    Examples:\n        >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n        2\n        >>> max_occurrences([])\n        IndexError\n    \"\"\"", "generated_programs": ["from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The input list is empty')\n    frequency = Counter(nums)\n    return frequency.most_common(1)[0][0]", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The list is empty.')\n    count = Counter(nums)\n    return max(count, key=count.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The input list is empty.')\n    count = Counter(nums)\n    return max(count, key=count.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The input list is empty.')\n    counter = Counter(nums)\n    max_item = max(counter, key=counter.get)\n    return max_item", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The list is empty')\n    count = Counter(nums)\n    return max(count, key=count.get)", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The input list is empty')\n    counter = Counter(nums)\n    max_freq_item = max(counter, key=counter.get)\n    return max_freq_item", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The list is empty')\n    counter = Counter(nums)\n    return counter.most_common(1)[0][0]", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The list is empty')\n    frequency_counter = Counter(nums)\n    return frequency_counter.most_common(1)[0][0]", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The input list is empty')\n    counter = Counter(nums)\n    max_occurrence = max(counter.values())\n    for num, count in counter.items():\n        if count == max_occurrence:\n            return num", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError('The input list is empty.')\n    frequency = Counter(nums)\n    max_item = max(frequency, key=frequency.get)\n    return max_item"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/137", "requirement": "from typing import List\n\n\ndef zero_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of the number of zeroes to the number of non-zero elements in an array of integers.\n    The ratio is calculated as the number of zeroes divided by the number of non-zero elements.\n    If there are no non-zero elements, the function should return 0.0.\n    assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    return 0.0 if non_zeroes == 0 else zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len([num for num in nums if num != 0])\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeros = nums.count(0)\n    non_zeros = len(nums) - zeros\n    if non_zeros == 0:\n        return 0.0\n    return zeros / non_zeros", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return 0.0\n    return zeroes / non_zeroes"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given integer can be represented as the sum of at least two distinct non-zero powers of 2. \n    Non-zero powers of 2 are defined as 2^k where k is a positive integer (i.e., 2^1, 2^2, 2^3, ...). \n    The function should handle both positive and negative integers as inputs.\n    assert is_Sum_Of_Powers_Of_Two(10) == True\n    \"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n == 0:\n        return False\n    abs_n = abs(n)\n    powers = []\n    k = 1\n    while 2 ** k <= abs_n:\n        powers.append(2 ** k)\n        k += 1\n    for i in range(2, len(powers) + 1):\n        for combination in combinations(powers, i):\n            if sum(combination) == abs_n:\n                return True\n    return False\nfrom itertools import combinations", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if abs(n) < 3:\n        return False\n    count = 0\n    while n != 0:\n        count += n & 1\n        n >>= 1\n        if count >= 2:\n            return True\n    return False", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if abs(n) < 3:\n        return False\n    abs_n = abs(n)\n    powers_of_two = []\n    power = 0\n    while abs_n > 0:\n        if abs_n & 1:\n            powers_of_two.append(2 ** power)\n        abs_n >>= 1\n        power += 1\n    return len(powers_of_two) >= 2", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if abs(n) <= 0:\n        return False\n    powers_count = 0\n    abs_n = abs(n)\n    while abs_n > 0:\n        if abs_n & 1:\n            powers_count += 1\n        if powers_count >= 2:\n            return True\n        abs_n >>= 1\n    return False", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    abs_n = abs(n)\n    distinct_powers_count = 0\n    while abs_n > 0:\n        if abs_n % 2 == 1:\n            distinct_powers_count += 1\n        abs_n //= 2\n        if distinct_powers_count >= 2:\n            return True\n    return False", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n == 0:\n        return False\n    count = 0\n    value = abs(n)\n    while value > 0:\n        if value & 1:\n            count += 1\n        value >>= 1\n    return count >= 2", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if abs(n) < 3:\n        return False\n\n    def count_powers_of_two(x):\n        count = 0\n        while x:\n            if x & 1:\n                count += 1\n            x >>= 1\n        return count\n    return count_powers_of_two(abs(n)) > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if abs(n) < 2:\n        return False\n    distinct_powers = []\n    abs_n = abs(n)\n    for i in range(1, int(abs_n).bit_length() + 1):\n        power_of_two = 2 ** i\n        if abs_n >= power_of_two:\n            distinct_powers.append(power_of_two)\n            abs_n -= power_of_two\n            if abs_n == 0 and len(distinct_powers) >= 2:\n                return True\n    return False", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if abs(n) < 6:\n        return False\n    n = abs(n)\n    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        if count >= 2:\n            return True\n        n >>= 1\n    return False", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if abs(n) < 3:\n        return False\n    powers_of_two = []\n    k = 1\n    while 2 ** k <= abs(n):\n        powers_of_two.append(2 ** k)\n        k += 1\n\n    def can_form_sum_from_distinct_powers(target, options, idx):\n        if target == 0:\n            return True\n        if target < 0 or idx >= len(options):\n            return False\n        return can_form_sum_from_distinct_powers(target - options[idx], options, idx + 1) or can_form_sum_from_distinct_powers(target, options, idx + 1)\n    for i in range(len(powers_of_two)):\n        if can_form_sum_from_distinct_powers(abs(n), powers_of_two, i):\n            return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/145", "requirement": "from typing import List\n\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the maximum absolute difference between the maximum and minimum values in a given array.\n    If the array is empty, the function should return 0.\n\n    Examples:\n    >>> max_Abs_Diff((2,1,5,3))\n    4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return abs(max_val - min_val)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return abs(max_val - min_val)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return abs(max_val - min_val)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_value = max(arr)\n    min_value = min(arr)\n    return max_value - min_value", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return abs(max_val - min_val)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"\n    Write a function that returns non-negative integers x and y that satisfy the equation ax + by = n as a tuple (x, y), \n    where x is iterated from 0 upwards. If multiple solutions exist, return the first solution encountered. \n    Return None if no non-negative integer solution exists.\n    \n    The function assumes that a and b are positive integers. If a or b is zero, the behavior is undefined.\n    Additionally, the function ensures that both x and y are non-negative, even if b or n is negative.\n    \n    assert find_solution(2, 3, 7) == (2, 1)\n    assert find_solution(2, -3, 7) == None\n    assert find_solution(0, 1, 1) == (0, 1)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    x = 0\n    while a * x <= n:\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n        x += 1\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    x = 0\n    while a * x <= n:\n        y = (n - a * x) // b\n        if a * x + b * y == n and y >= 0:\n            return (x, y)\n        x += 1\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    x = 0\n    while True:\n        if a * x > n:\n            return None\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n        x += 1", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0:\n        if b > 0 and n >= 0 and (n % b == 0):\n            return (0, n // b)\n        return None\n    x = 0\n    while a * x <= n:\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n        x += 1\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0:\n        if b != 0 and n % b == 0:\n            y = n // b\n            if y >= 0:\n                return (0, y)\n        return None\n    for x in range(0, n // a + 1):\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    x = 0\n    while a * x <= n:\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            if y >= 0:\n                return (x, y)\n        x += 1\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    x = 0\n    while a * x <= n:\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n        x += 1\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    x = 0\n    while a * x <= n:\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n        x += 1\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    x = 0\n    while True:\n        if a * x > n:\n            return None\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            if y >= 0:\n                return (x, y)\n        x += 1", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    x = 0\n    while x * a <= n:\n        if (n - x * a) % b == 0:\n            y = (n - x * a) // b\n            if y >= 0:\n                return (x, y)\n        x += 1\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n    \"\"\"\n    Write a Python function to set all bits of a given number to 1.\n    assert even_bit_set_number(10) == 10\n    \"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    return n | (1 << n.bit_length()) - 1", "def even_bit_set_number(n: int) -> int:\n    return n | 2863311530", "def even_bit_set_number(n: int) -> int:\n    return n | 0", "def even_bit_set_number(n: int) -> int:\n    max_bit_length = n.bit_length()\n    all_ones = (1 << max_bit_length) - 1\n    return n | all_ones", "def even_bit_set_number(n: int) -> int:\n    return n | int('10101010101010101010101010101010', 2)", "def even_bit_set_number(n: int) -> int:\n    return (1 << n.bit_length()) - 1 if n > 0 else 0", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n | 12297829382473034410", "def even_bit_set_number(n: int) -> int:\n    return n | 77194726158210796949047323339125271902179989777093709359638389338608753093290"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, \n    such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    Specifically, for each element in the sequence (starting from the second element), it must satisfy the condition: \n    element >= 2 * previous_element and element <= m.\n    \n    The first element in the sequence can be any positive integer from 1 to m. \n    If n is 1, the function should return m, as there are m possible sequences of length 1.\n    If n is 0, the function should raise an IndexError, as sequences of length 0 are not valid.\n    \n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n\n    def count_sequences(previous: int, length: int) -> int:\n        if length == 0:\n            return 1\n        total = 0\n        for current in range(2 * previous, m + 1):\n            total += count_sequences(current, length - 1)\n        return total\n    total_sequences = 0\n    for first in range(1, m + 1):\n        total_sequences += count_sequences(first, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n\n    def count_sequences(current_element: int, length_left: int) -> int:\n        if length_left == 0:\n            return 1\n        total = 0\n        for next_element in range(2 * current_element, m + 1):\n            total += count_sequences(next_element, length_left - 1)\n        return total\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(first_element, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_number in range(max(2 * current, 1), m + 1):\n            total += count_sequences(next_number, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n < 1:\n        raise IndexError('Sequences of length 0 are not valid.')\n\n    def count_sequences(current_value, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total_count = 0\n        for next_value in range(2 * current_value, m + 1):\n            total_count += count_sequences(next_value, remaining_length - 1)\n        return total_count\n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(start_value, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n\n    def count_sequences(start, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_val in range(2 * start, m + 1):\n            total += count_sequences(next_val, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for first_val in range(1, m + 1):\n        total_sequences += count_sequences(first_val, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n\n    def count_sequences(start: int, remaining_length: int) -> int:\n        if remaining_length == 1:\n            return 1\n        total = 0\n        for next_num in range(2 * start, m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for first_num in range(1, m + 1):\n        if n == 1:\n            total_sequences += 1\n        else:\n            total_sequences += count_sequences(first_num, n)\n    return total_sequences", "from functools import lru_cache\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequence length cannot be 0.')\n    if n == 1:\n        return m\n\n    def count_sequences(previous: int, remaining_length: int) -> int:\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for current in range(max(2 * previous, 1), m + 1):\n            total += count_sequences(current, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(first_element, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n\n    def count_sequences(current_element: int, remaining_length: int) -> int:\n        if remaining_length == 0:\n            return 1\n        total = 0\n        next_element = 2 * current_element\n        while next_element <= m:\n            total += count_sequences(next_element, remaining_length - 1)\n            next_element += 1\n        return total\n    total_sequences = 0\n    for start_element in range(1, m + 1):\n        total_sequences += count_sequences(start_element, n - 1)\n    return total_sequences", "from functools import lru_cache\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start, length):\n        if length == 1:\n            return 1\n        total = 0\n        for next_value in range(2 * start, m + 1):\n            total += count_sequences(next_value, length - 1)\n        return total\n    total_sequences = 0\n    for first_value in range(1, m + 1):\n        total_sequences += count_sequences(first_value, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(previous: int, length_remaining: int) -> int:\n        if length_remaining == 0:\n            return 1\n        total = 0\n        start = max(2 * previous, 1)\n        for next_element in range(start, m + 1):\n            total += count_sequences(next_element, length_remaining - 1)\n        return total\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(first_element, n - 1)\n    return total_sequences"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/253", "requirement": "from typing import List, Any\n\n\ndef count_integer(lst: List[Any]) -> int:\n    \"\"\"\n    Write a Python function that returns the number of elements in a given list that are instances of the `int` type, excluding `bool` values.\n    assert count_integer([1,2,'abc',1.2]) == 2\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(x, int) and (not isinstance(x, bool)) for x in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(x, int) and (not isinstance(x, bool)) for x in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(x, int) and (not isinstance(x, bool)) for x in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(x, int) and (not isinstance(x, bool)) for x in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((isinstance(x, int) and (not isinstance(x, bool)) for x in lst))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for x in lst if isinstance(x, int) and (not isinstance(x, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Newman–Shanks–Williams prime number.\n    \n    The Newman–Shanks–Williams prime sequence is defined by the following recurrence relation:\n    - Initial conditions: a = 1, b = 1\n    - Recurrence relation: c = 2 * b + a\n    - The sequence starts with 1, 1, 3, 7, 17, 41, ...\n    - For n = 1, the function should return 3.\n    \n    assert newman_prime(3) == 7\n    \"\"\"", "generated_programs": ["def newman_prime(n: int) -> int:\n    a, b = (1, 1)\n    if n == 1:\n        return 3\n    for _ in range(n - 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer.')\n    a, b = (1, 1)\n    for _ in range(n):\n        a, b = (b, 2 * b + a)\n    return a", "def newman_prime(n: int) -> int:\n    a, b = (1, 1)\n    for _ in range(n):\n        c = 2 * b + a\n        a, b = (b, c)\n    return a", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(n - 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n):\n        a, b = (b, 2 * b + a)\n    return 2 * b + a", "def newman_prime(n: int) -> int:\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return c", "def newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    a, b = (1, 1)\n    for _ in range(1, n):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/264", "requirement": "def dog_age(h_age: float) -> float:\n    \"\"\"\n    Calculate a dog's age in dog's years based on the given human age.\n    \n    The conversion follows these rules:\n    - If the human age is less than or equal to 0, the dog's age is 0.\n    - If the human age is less than or equal to 2, the dog's age is calculated as human age multiplied by 10.5.\n    - If the human age is greater than 2, the dog's age is calculated as 21 plus (human age minus 2) multiplied by 4.\n    \n    Examples:\n    >>> dog_age(12)\n    61\n    >>> dog_age(-5.0)\n    0.0\n    \"\"\"", "generated_programs": ["def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21.0 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 0:\n        return 0.0\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/265", "requirement": "from typing import List, Any\n\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Write a function that takes in a list `S` and an integer `step`, and distributes the elements of `S` into `step` sublists. \n    Each sublist should contain elements spaced `step` apart, starting from consecutive initial indices. \n    Specifically, the first sublist contains elements at indices 0, step, 2*step, etc., \n    the second sublist contains elements at indices 1, step+1, 2*step+1, etc., and so on until the `step`-th sublist.\n    The function returns a list of these sublists.\n    \n    Example:\n    assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for index, element in enumerate(S):\n        result[index % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for i in range(len(S)):\n        result[i % step].append(S[i])\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for i, elem in enumerate(S):\n        result[i % step].append(elem)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for i in range(len(S)):\n        result[i % step].append(S[i])\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for i, value in enumerate(S):\n        result[i % step].append(value)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for index, element in enumerate(S):\n        result[index % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for idx, element in enumerate(S):\n        result[idx % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for i in range(len(S)):\n        result[i % step].append(S[i])\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for index, element in enumerate(S):\n        result[index % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i] for i in range(start, len(S), step)] for start in range(step)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/286", "requirement": "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the largest sum of a contiguous subarray in the modified array formed by concatenating the given array `a` `k` times.\n    \n    The function should handle the following cases:\n    - If `k` is 1, the maximum subarray sum is calculated within the original array `a`.\n    - If the total sum of the array `a` is non-positive, the maximum subarray sum is calculated within one or two concatenated instances of `a`.\n    - If the total sum of the array `a` is positive, the maximum subarray sum is calculated as the total sum multiplied by `(k - 2)` plus the maximum subarray sum of the concatenated array `a + a`.\n    \n    Examples:\n    >>> max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3)\n    30\n    >>> max_sub_array_sum_repeated([5, -2, 3, 1], 4, 4)\n    28\n    >>> max_sub_array_sum_repeated([1, 2, 3], 3, 1)\n    6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_single = max_sub_array_sum(a)\n    if k == 1:\n        return max_single\n    max_double = max_sub_array_sum(a + a)\n    if total_sum <= 0:\n        return max_double\n    else:\n        return max_double + (k - 2) * total_sum", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    array_sum = sum(a)\n    max_sum_single = kadane(a)\n    if k == 1:\n        return max_sum_single\n    max_sum_two_concat = kadane(a * 2)\n    if array_sum <= 0:\n        return max_sum_two_concat\n    return max_sum_two_concat + (k - 2) * array_sum", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_subarray_sum(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_single = max_subarray_sum(a)\n    if k == 1:\n        return max_single\n    else:\n        max_double = max_subarray_sum(a + a)\n        if total_sum <= 0:\n            return max_double\n        else:\n            return max_double + (k - 2) * total_sum", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_so_far = float('-inf')\n        max_ending_here = 0\n        for x in arr:\n            max_ending_here += x\n            if max_so_far < max_ending_here:\n                max_so_far = max_ending_here\n            if max_ending_here < 0:\n                max_ending_here = 0\n        return max_so_far\n    max_sum_single = kadane(a)\n    if k == 1:\n        return max_sum_single\n    total_sum = sum(a)\n    max_sum_double = kadane(a * 2)\n    if total_sum > 0:\n        return max(max_sum_double, max_sum_double + total_sum * (k - 2))\n    else:\n        return max_sum_double", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    single_max = kadane(a)\n    if k == 1:\n        return single_max\n    array_sum = sum(a)\n    two_times_max = kadane(a + a)\n    if array_sum <= 0:\n        return two_times_max\n    return max(two_times_max, (k - 2) * array_sum + two_times_max)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_sum_single = max_sub_array_sum(a)\n    if k == 1:\n        return max_sum_single\n    max_sum_two = max_sub_array_sum(a + a)\n    if total_sum <= 0:\n        return max(max_sum_single, max_sum_two)\n    return max_sum_two + total_sum * (k - 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr: List[int]) -> int:\n        max_so_far, max_ending_here = (float('-inf'), 0)\n        for x in arr:\n            max_ending_here += x\n            if max_ending_here > max_so_far:\n                max_so_far = max_ending_here\n            if max_ending_here < 0:\n                max_ending_here = 0\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return max_sub_array_sum(a)\n    max_sum_twice = max_sub_array_sum(a * 2)\n    if total_sum > 0:\n        return max_sum_twice + (k - 2) * total_sum\n    else:\n        return max_sum_twice", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_kadane_single = kadane(a)\n    if k == 1:\n        return max_kadane_single\n    max_kadane_double = kadane(a + a)\n    if total_sum <= 0:\n        return max_kadane_double\n    return total_sum * (k - 2) + max_kadane_double", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_single_kadane = kadane(a)\n    if k == 1:\n        return max_single_kadane\n    max_double_kadane = kadane(a + a)\n    if total_sum <= 0:\n        return max_double_kadane\n    return max_double_kadane + total_sum * (k - 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr: List[int]) -> int:\n        current_sum = max_sum = arr[0]\n        for num in arr[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    total_sum = sum(a)\n    if k == 1:\n        return max_sub_array_sum(a)\n    max_sub_sum_twice = max_sub_array_sum(a + a)\n    if total_sum <= 0:\n        return max_sub_sum_twice\n    return (k - 2) * total_sum + max_sub_sum_twice"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n    \"\"\"\n    Calculate the depth of a dictionary recursively. The depth is defined as the maximum number of nested dictionaries within the input dictionary. \n    \n    - An empty dictionary or a non-dictionary input has a depth of 0.\n    - Non-dictionary values within the dictionary do not contribute to the depth.\n    - The depth is calculated by recursively traversing all dictionary values and finding the maximum depth among them, then adding 1 for the current level.\n    \n    Examples:\n    >>> dict_depth({'a':1, 'b': {'c': {'d': {}}}})\n    4\n    >>> dict_depth({})\n    0\n    >>> dict_depth({'a': 1, 'b': [1, 2, 3]})\n    1\n    >>> dict_depth({'a': {'b': {'c': 1}}, 'd': 2})\n    3\n    \"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for key, value in d.items() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.4}}
{"task_id": "Mbpp/306", "requirement": "```python\nfrom typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum of an increasing subsequence from the start of the array up to the given `index` (inclusive), \n    and extend this subsequence to include the `kth` element (where `k > index`), ensuring the subsequence remains valid in increasing order.\n\n    The function computes the maximum sum of increasing subsequences for the prefix (elements from index 0 to `index`) using dynamic programming. \n    Then, it checks which elements in the prefix can form a valid increasing subsequence with the `kth` element (`a[k]`), \n    and selects the subsequence with the maximum sum. The value of `a[k]` is added to this sum to include the `kth` element.\n\n    If no valid increasing subsequence exists in the prefix that can be extended to include `a[k]`, the result will be the value of `a[k]` alone.\n\n    Constraints:\n    - `k > index` must hold true.\n    - The input array `a` contains integers, and `n` is the length of the array.\n    - The function assumes valid input, meaning:\n        - `a` must be a non-empty list.\n        - `index` and `k` must be within bounds (0 <= index < n and 0 <= k < n).\n        - `k > index` must hold true.\n    - If invalid input is provided (e.g., empty array, out-of-bounds indices, or `k <= index`), the function will raise a `ValueError`.\n\n    Methodology:\n    - Dynamic programming is applied only to the prefix `a[:index + 1]` to compute the maximum sum of increasing subsequences.\n    - The function does not extend the dynamic programming logic beyond the prefix.\n\n    Examples:\n    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    assert max_sum_increasing_subseq([5, 4, 3, 2, 1], 5, 2, 4) == 1\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or k < 0 or (n <= max(index, k)) or (k <= index):\n        raise ValueError('Invalid input')\n    dp = a[:index + 1]\n    for i in range(1, index + 1):\n        for j in range(0, i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise ValueError('Invalid input')\n    dp = a[:index + 1]\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    final_sum = max_sum + a[k]\n    return final_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise ValueError('Invalid input: ensure non-empty list and 0 <= index < n, 0 <= k < n, k > index')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n    for i in range(index + 1):\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum_with_k = a[k]\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum_with_k = max(max_sum_with_k, dp[i] + a[k])\n    return max_sum_with_k", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n == 0 or index >= n or k >= n or (k <= index):\n        raise ValueError('Invalid input values.')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum_with_k = a[k]\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum_with_k = max(max_sum_with_k, dp[i] + a[k])\n    return max_sum_with_k", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k <= index or index >= n or k >= n or (n == 0):\n        raise ValueError('Invalid input parameters.')\n    max_sum = a[:index + 1]\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[i] > a[j]:\n                max_sum[i] = max(max_sum[i], max_sum[j] + a[i])\n    result = a[k]\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            result = max(result, max_sum[i] + a[k])\n    return result", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or n <= 0 or index >= n or (k >= n) or (k <= index):\n        raise ValueError('Invalid input')\n    max_sum = [0] * (index + 1)\n    for i in range(index + 1):\n        max_sum[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                max_sum[i] = max(max_sum[i], max_sum[j] + a[i])\n    max_subseq_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_subseq_sum = max(max_subseq_sum, max_sum[i])\n    max_subseq_sum += a[k]\n    return max_subseq_sum if max_subseq_sum > 0 else a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise ValueError('Provided indices are out of bounds or invalid constraints.')\n    max_sum = [0] * (index + 1)\n    for i in range(index + 1):\n        max_sum[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                max_sum[i] = max(max_sum[i], max_sum[j] + a[i])\n    result = a[k]\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            result = max(result, max_sum[i] + a[k])\n    return result", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise ValueError('Invalid input: check that 0 <= index < n, 0 <= k < n, and k > index.')\n    dp = a[:index + 1]\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    max_sum += a[k]\n    return max(max_sum, a[k])", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (index < 0) or (k <= index):\n        raise ValueError('Invalid input parameters')\n    max_sum = [0] * (index + 1)\n    for i in range(index + 1):\n        max_sum[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                max_sum[i] = max(max_sum[i], max_sum[j] + a[i])\n    max_increase_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_increase_sum = max(max_increase_sum, max_sum[i])\n    return max_increase_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n == 0 or not 0 <= index < n or (not 0 <= k < n) or (not k > index):\n        raise ValueError('Invalid input: check that 0 <= index < n, 0 <= k < n, and k > index.')\n    dp = a[:index + 1]\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum_with_k = a[k]\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum_with_k = max(max_sum_with_k, dp[i] + a[k])\n    return max_sum_with_k"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.125}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n    \"\"\"\n    Write a function to convert a given string to a tuple of characters, excluding spaces.\n    assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((ch for ch in str1 if ch != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the highest-order unset bit in the binary representation of the integer `n`.\n    The function should find the leftmost bit that is currently 0 (starting from the highest-order bit) and set it to 1.\n    Leading zeros are not considered in the binary representation of `n`. If all bits are set, the function should return `n` unchanged.\n    For example, for the input `10` (binary `1010`), the leftmost unset bit is the third bit from the left, and setting it results in `14` (binary `1110`).\n    assert set_left_most_unset_bit(10) == 14\n    \"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    mask = 1 << n.bit_length()\n    while mask > 0:\n        if n & mask == 0:\n            n |= mask\n            break\n        mask >>= 1\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            return n\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            return n\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            return n\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_count = n.bit_length()\n    for i in range(bit_count - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            return n\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "Mbpp/391", "requirement": "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    \"\"\"\n    Convert three lists into a list of nested dictionaries where each dictionary maps an element from `list1` to a dictionary that maps an element from `list2` to an element from `list3`. \n    The function assumes that all three lists are of the same length. If the lists are of unequal lengths, an `IndexError` will be raised.\n    \n    Args:\n        list1 (List[Any]): A list of keys for the outer dictionary.\n        list2 (List[Any]): A list of keys for the inner dictionary.\n        list3 (List[Any]): A list of values for the inner dictionary.\n    \n    Returns:\n        List[Dict[Any, Dict[Any, Any]]]: A list of dictionaries where each dictionary contains a single key-value pair. The key is an element from `list1`, and the value is another dictionary with a key from `list2` and a value from `list3`.\n    \n    Examples:\n        >>> convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"], [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"], [85, 98, 89, 92])\n        [{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]\n        \n        >>> convert_list_dictionary(['B001', 'B002'], ['Alice Smith'], [90, 95])\n        IndexError\n    \"\"\"\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "generated_programs": ["from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError('Input lists have unequal lengths')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise IndexError('All input lists must have the same length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise IndexError('All lists must be of the same length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError('All input lists must have the same length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise IndexError('Lists must be of equal length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise IndexError('All lists must have the same length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError('All input lists must be of the same length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError('All input lists must have the same length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError('All input lists must be of the same length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise IndexError('All input lists must have the same length.')\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.6}}
{"task_id": "Mbpp/415", "requirement": "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Write a python function to find a pair with the highest product from a given array of integers.\n    \n    The function assumes that the input array will always have at least two elements. If the array\n    contains fewer than two elements, the function will raise an `IndexError`.\n    \n    The function sorts the array and compares the product of the two largest elements with the product\n    of the two smallest elements (to handle negative numbers) and returns the pair with the highest product.\n    \n    Examples:\n    >>> max_Product([1,2,3,4,7,0,8,4])\n    (7, 8)\n    >>> max_Product([5])\n    IndexError: list index out of range\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('list index out of range')\n    arr.sort()\n    high_pair = (arr[-2], arr[-1])\n    low_pair = (arr[0], arr[1])\n    return high_pair if arr[-2] * arr[-1] > arr[0] * arr[1] else low_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('list index out of range')\n    arr.sort()\n    max1, max2 = (arr[-1], arr[-2])\n    min1, min2 = (arr[0], arr[1])\n    if max1 * max2 >= min1 * min2:\n        return (max2, max1)\n    else:\n        return (min1, min2)", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('list index out of range')\n    arr.sort()\n    max_product_pair = max((arr[-1], arr[-2]), (arr[0], arr[1]), key=lambda pair: pair[0] * pair[1])\n    return max_product_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('list index out of range')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 >= product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('list index out of range')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 >= product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('list index out of range')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 >= product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('list index out of range')\n    arr.sort()\n    product_1 = arr[-1] * arr[-2]\n    product_2 = arr[0] * arr[1]\n    if product_1 > product_2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('list index out of range')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 >= product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('list index out of range')\n    arr.sort()\n    max_product_pair = (arr[-2], arr[-1]) if arr[-1] * arr[-2] > arr[0] * arr[1] else (arr[0], arr[1])\n    return max_product_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        raise IndexError('list index out of range')\n    arr.sort()\n    product1 = arr[-1] * arr[-2]\n    product2 = arr[0] * arr[1]\n    if product1 >= product2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Calculate the directrix of a parabola given its coefficients in the form y = ax² + bx + c.\n    The directrix is calculated using the formula: y = - (b² - 4ac + 1) / (4a) - 199.\n    \n    Args:\n        a (int): Coefficient of x² in the parabola equation.\n        b (int): Coefficient of x in the parabola equation.\n        c (int): Constant term in the parabola equation.\n    \n    Returns:\n        int: The y-coordinate of the directrix of the parabola.\n    \n    Examples:\n        >>> parabola_directrix(5, 3, 2)\n        -198\n    \"\"\"\n    assert parabola_directrix(5, 3, 2) == -198", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix_y = -(b ** 2 - 4 * a * c + 1) / (4 * a) - 199\n    return int(directrix_y)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return int(-(b ** 2 - 4 * a * c + 1) / (4 * a) - 199)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return int(-(b ** 2 - 4 * a * c + 1) / (4 * a) - 199)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n+1 Perrin numbers, including the nth Perrin number.\n    The Perrin sequence starts with P(0) = 3, P(1) = 0, and P(2) = 2.\n    For n < 0, the function should raise an IndexError.\n    For n = 0, the function should return 0.\n    For n = 1, the function should return 2.\n    For n = 2, the function should return 3.\n    For n > 2, the function should return the sum of the first n+1 Perrin numbers.\n\n    Examples:\n    >>> cal_sum(2)\n    3\n    >>> cal_sum(-1)\n    IndexError\n    >>> cal_sum(0)\n    0\n    >>> cal_sum(9)\n    49\n    \"\"\"", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index cannot be negative')\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index should be non-negative')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    sum_perrin = sum(perrin)\n    for i in range(3, n + 1):\n        next_value = perrin[i - 2] + perrin[i - 3]\n        perrin.append(next_value)\n        sum_perrin += next_value\n    return sum_perrin", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be a non-negative integer')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    sum_perrin = 3\n    for i in range(3, n + 1):\n        next_perrin = perrin[i - 2] + perrin[i - 3]\n        perrin.append(next_perrin)\n        sum_perrin += next_perrin\n    return sum_perrin", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index out of bounds: n cannot be negative')\n    perrin = [3, 0, 2]\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    sum_perrin = 3\n    for i in range(3, n + 1):\n        next_perrin = perrin[i - 2] + perrin[i - 3]\n        perrin.append(next_perrin)\n        sum_perrin += next_perrin\n    return sum_perrin", "from typing import List\n\ndef cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be non-negative')\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    perrin: List[int] = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index must be non-negative')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    total_sum = 3\n    for i in range(3, n + 1):\n        next_perrin = perrin[i - 2] + perrin[i - 3]\n        perrin.append(next_perrin)\n        total_sum += next_perrin\n    return total_sum", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be non-negative')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    sum_perrin = 5\n    for i in range(3, n + 1):\n        p = perrin[i - 2] + perrin[i - 3]\n        perrin.append(p)\n        sum_perrin += p\n    return sum_perrin", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index must be non-negative')\n    perrin = [3, 0, 2]\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('Index must be a non-negative integer')\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        next_perrin = perrin[i - 2] + perrin[i - 3]\n        perrin.append(next_perrin)\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError('IndexError')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        p = perrin[i - 2] + perrin[i - 3]\n        perrin.append(p)\n    return sum(perrin[:n + 1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of even positive factors of a given positive integer `n`. \n    The function should consider only positive factors and should return 0 for negative inputs or if no even factors are found.\n    The function should check all numbers from 1 to `n` to determine the factors.\n\n    Examples:\n    >>> sumofFactors(18)\n    26\n    >>> sumofFactors(-12)\n    0\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_factors += i\n    return sum_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing at least one 'z' anywhere in the word.\n    assert text_match_wordz(\"pythonz.\")==True\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return re.search('\\\\b\\\\w*z\\\\w*\\\\b', text) is not None", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\bz\\\\w*|\\\\w*z\\\\w*|\\\\w*\\\\bz', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "def text_match_wordz(text: str) -> bool:\n    import re\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    \"\"\"\n    Write a function to find all possible combinations of the elements of a given list, including the empty list.\n    The function should return a list of lists, where each inner list represents a combination of elements from the input list.\n    The order of combinations should be based on the order of elements in the input list, and combinations should include all possible lengths from 0 to the length of the input list.\n    \n    Example:\n    assert combinations_list(['orange', 'red', 'green', 'blue']) == [\n        [], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'],\n        ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'],\n        ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']\n    ]\n    \"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nimport itertools\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        for combination in itertools.combinations(lst, r):\n            all_combinations.append(list(combination))\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    comb_list = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            comb_list.append(list(combo))\n    return comb_list", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    all_combinations = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            all_combinations.append(list(combo))\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            all_combinations.append(list(combo))\n    return all_combinations", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n\n    def backtrack(start: int, current: List[str]):\n        result.append(current.copy())\n        for i in range(start, len(lst)):\n            current.append(lst[i])\n            backtrack(i + 1, current)\n            current.pop()\n    result = []\n    backtrack(0, [])\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/465", "requirement": "def drop_empty(dict1: dict) -> dict:\n    \"\"\"\n    Write a function to drop key-value pairs from a given dictionary where the value is None.\n\n    Args:\n        dict1 (dict): The input dictionary from which to drop key-value pairs with None values.\n\n    Returns:\n        dict: A new dictionary with all key-value pairs where the value is not None.\n\n    Examples:\n        >>> drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None})\n        {'c1': 'Red', 'c2': 'Green'}\n    \"\"\"", "generated_programs": ["def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n\"\"\"\nWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nassert max_product([3, 100, 4, 5, 150, 6]) == 3000\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [0] * n\n    max_product = 0\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n        max_product = max(max_product, dp[i])\n    return max_product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    max_product = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                max_product[i] = max(max_product[i], max_product[j] * arr[i])\n    return max(max_product)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    max_product_value = 0\n    product = [0] * n\n    for i in range(n):\n        product[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                product[i] = max(product[i], product[j] * arr[i])\n        max_product_value = max(max_product_value, product[i])\n    return max_product_value", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    max_product_ends_at = [0] * n\n    for i in range(n):\n        max_product_ends_at[i] = arr[i]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and max_product_ends_at[i] < max_product_ends_at[j] * arr[i]:\n                max_product_ends_at[i] = max_product_ends_at[j] * arr[i]\n    return max(max_product_ends_at)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    max_prod = [0] * n\n    for i in range(n):\n        max_prod[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                max_prod[i] = max(max_prod[i], max_prod[j] * arr[i])\n    return max(max_prod)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = arr.copy()\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    max_prod = [0] * n\n    for i in range(n):\n        max_prod[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                max_prod[i] = max(max_prod[i], max_prod[j] * arr[i])\n    return max(max_prod)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    max_product = [0] * n\n    for i in range(n):\n        max_product[i] = arr[i]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                max_product[i] = max(max_product[i], max_product[j] * arr[i])\n    return max(max_product)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    max_product_end = arr[:]\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                max_product_end[i] = max(max_product_end[i], max_product_end[j] * arr[i])\n    return max(max_product_end)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/471", "requirement": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function to compute the product of all elements in the array and then return the result modulo n.\n    The function should handle edge cases such as an empty array by returning 1 % n.\n    \n    Examples:\n    >>> find_remainder([100, 10, 5, 25, 35, 14], 11)\n    9\n    >>> find_remainder([], 10)\n    1\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = 1\n    for number in arr:\n        product *= number\n    return product % n", "from typing import List\nfrom functools import reduce\nimport operator\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = reduce(operator.mul, arr, 1)\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\nfrom functools import reduce\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = reduce(lambda x, y: x * y, arr)\n    return product % n", "from typing import List\nfrom functools import reduce\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = reduce(lambda x, y: x * y, arr)\n    return product % n", "from typing import List\nfrom functools import reduce\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = reduce(lambda x, y: x * y, arr)\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n if n != 0 else 0", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    if not arr:\n        return 1 % n\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/479", "requirement": "def first_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the first digit of a given integer, including the sign if the number is negative.\n    The function should process the number as is, without converting it to its absolute value.\n    The first digit should be returned as an integer.\n    \n    Examples:\n    >>> first_Digit(123)\n    1\n    >>> first_Digit(-456)\n    -4\n    >>> first_Digit(0)\n    0\n    \"\"\"", "generated_programs": ["def first_Digit(n: int) -> int:\n    n_str = str(n)\n    if n_str[0] == '-':\n        return int(n_str[:2])\n    else:\n        return int(n_str[0])", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    first_digit = int(str(n)[0]) if n > 0 else -int(str(n)[1])\n    return first_digit", "def first_Digit(n: int) -> int:\n    n_str = str(n)\n    if n_str[0] == '-':\n        return int(n_str[:2])\n    else:\n        return int(n_str[0])", "def first_Digit(n: int) -> int:\n    n_str = str(n)\n    if n_str[0] == '-':\n        return int(n_str[:2])\n    return int(n_str[0])", "def first_Digit(n: int) -> int:\n    n_str = str(n)\n    if n_str[0] == '-':\n        return int(n_str[0] + n_str[1])\n    return int(n_str[0])", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    str_n = str(n)\n    if str_n[0] == '-':\n        return int(str_n[:2])\n    return int(str_n[0])", "def first_Digit(n: int) -> int:\n    number_str = str(n)\n    if n < 0:\n        return int(number_str[:2])\n    return int(number_str[0])", "def first_Digit(n: int) -> int:\n    n_str = str(n)\n    if n_str[0] == '-':\n        return int(n_str[:2])\n    return int(n_str[0])", "def first_Digit(n: int) -> int:\n    n_str = str(n)\n    if n_str[0] == '-':\n        return int(n_str[:2])\n    else:\n        return int(n_str[0])", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    num_str = str(n)\n    if num_str[0] == '-':\n        return int(num_str[:2])\n    return int(num_str[0])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/558", "requirement": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of the absolute differences between corresponding digits of two integers.\n    If the integers have different lengths, the shorter integer is padded with leading zeros to match the length of the longer integer.\n    The function then calculates the absolute difference between each pair of corresponding digits and returns the sum of these differences.\n    assert digit_distance_nums(1,2) == 1\n    \"\"\"", "generated_programs": ["def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1), str(n2))\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_length = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_length)\n    str_n2 = str_n2.zfill(max_length)\n    total_distance = sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))\n    return total_distance", "def digit_distance_nums(n1: int, n2: int) -> int:\n    s1, s2 = (str(n1), str(n2))\n    max_len = max(len(s1), len(s2))\n    s1 = s1.zfill(max_len)\n    s2 = s2.zfill(max_len)\n    return sum((abs(int(a) - int(b)) for a, b in zip(s1, s2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    s1, s2 = (str(n1), str(n2))\n    max_len = max(len(s1), len(s2))\n    s1, s2 = (s1.zfill(max_len), s2.zfill(max_len))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(s1, s2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1), str(n2))\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    total_distance = sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))\n    return total_distance", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_length = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_length)\n    str_n2 = str_n2.zfill(max_length)\n    total_distance = sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))\n    return total_distance", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    max_length = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_length)\n    str_n2 = str_n2.zfill(max_length)\n    return sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1), str(n2))\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1), str(n2))\n    max_length = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_length)\n    str_n2 = str_n2.zfill(max_length)\n    return sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1), str(n2))\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    return sum((abs(int(a) - int(b)) for a, b in zip(str_n1, str_n2)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/559", "requirement": "from typing import List\n\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum achievable by any contiguous sublist in the given list. \n    If the list is empty, the function should return negative infinity (`-inf`).\n\n    Args:\n        a (List[int]): The list of integers.\n        size (int): The size of the list.\n\n    Returns:\n        int: The maximum sum achievable by any contiguous sublist, or `-inf` if the list is empty.\n\n    Examples:\n        >>> max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8)\n        7\n        >>> max_sub_array_sum([], 0)\n        -inf\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_sum = -math.inf\n    current_sum = 0\n    for num in a:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum", "from typing import List\nfrom math import inf\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -inf\n    max_so_far = -inf\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here += a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far", "from typing import List\nimport sys\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -sys.maxsize - 1\n    max_so_far = -sys.maxsize - 1\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here += a[i]\n        if max_ending_here > max_so_far:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_current = a[0]\n    max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = -math.inf\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here += a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = -math.inf\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here += a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far", "from typing import List\nimport sys\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -sys.float_info.max\n    max_ending_here = a[0]\n    max_so_far = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport sys\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -sys.maxsize - 1\n    max_sum = -sys.maxsize - 1\n    current_sum = 0\n    for x in a:\n        current_sum += x\n        if max_sum < current_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = -math.inf\n    max_ending_here = 0\n    for num in a:\n        max_ending_here += num\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/563", "requirement": "def extract_values(text: str) -> List[str]:\n    \"\"\"Extract all substrings that are enclosed within double quotation marks from the input string.\n    Each substring should be captured without the surrounding quotes.\n    assert extract_values('\"Python\", \"PHP\", \"Java\"')==['Python', 'PHP', 'Java']\n    \"\"\"", "generated_programs": ["from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    matches = re.findall('\"(.*?)\"', text)\n    return matches", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"([^\"]*)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\\\\\"(.*?)\\\\\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "def count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Counts the number of unordered pairs (i, j) where i < j and arr[i] != arr[j].\n    The function iterates through all possible pairs in the list and increments the count if the elements in the pair are not equal.\n    assert count_Pairs([1,2,1],3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    pair_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                pair_count += 1\n    return pair_count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/579", "requirement": "from typing import Tuple, Any\n\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    \"\"\"\n    Write a function to find the unique dissimilar elements in the given two tuples. \n    The function should return a sorted tuple containing elements that are present in \n    either of the tuples but not in both. The output should be sorted in ascending order.\n\n    assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    unique_elements = set(test_tup1).symmetric_difference(set(test_tup2))\n    return tuple(sorted(unique_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1, set2 = (set(test_tup1), set(test_tup2))\n    dissimilar = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(set(test_tup2))))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1, set2 = (set(test_tup1), set(test_tup2))\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1) ^ set(test_tup2)))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    unique_in_tup1 = set(test_tup1)\n    unique_in_tup2 = set(test_tup2)\n    dissimilar_elements = unique_in_tup1.symmetric_difference(unique_in_tup2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    result = set1.symmetric_difference(set2)\n    return tuple(sorted(result))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    return tuple(sorted(set(test_tup1).symmetric_difference(set(test_tup2))))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.9}}
{"task_id": "Mbpp/580", "requirement": "```python\ndef extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Write a function to recursively remove all uneven integers from a nested mixed tuple while preserving the original structure, including empty tuples.\n\n    Requirements:\n    1. The function should recursively traverse all levels of the nested tuple.\n    2. Uneven integers (odd numbers) should be removed from all levels of the tuple.\n    3. Non-integer elements (e.g., strings, floats) should be ignored and excluded from the output.\n    4. The structure of the nested tuple must be preserved, including retaining empty tuples (`()`).\n    5. The output should only contain even integers and tuple structures, maintaining all original nesting levels.\n\n    Example:\n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"\n```", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n\n    def recurse(t):\n        if isinstance(t, tuple):\n            filtered = tuple((recurse(item) for item in t if isinstance(item, (int, tuple))))\n            return tuple((item for item in filtered if item != ()))\n        elif isinstance(t, int):\n            return t if t % 2 == 0 else ()\n        return ()\n    return recurse(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_elements(t):\n        if isinstance(t, tuple):\n            filtered = tuple((filter_elements(item) for item in t))\n            return tuple(filter(None, filtered))\n        elif isinstance(t, int) and t % 2 == 0:\n            return (t,)\n        return ()\n    return filter_elements(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(t):\n        if isinstance(t, int):\n            return (t,) if t % 2 == 0 else ()\n        elif isinstance(t, tuple):\n            result = tuple((helper(item) for item in t))\n            return tuple((x for x in result if x or isinstance(x, tuple)))\n        else:\n            return ()\n    return helper(test_tuple)", "from typing import Any, Tuple\n\ndef extract_even(test_tuple: Tuple[Any, ...]) -> Tuple[Any, ...]:\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            return extract_even(element)\n        elif isinstance(element, int) and element % 2 == 0:\n            return (element,)\n        else:\n            return ()\n    result = tuple()\n    for item in test_tuple:\n        result += process_element(item)\n    return result", "from typing import Union\n\ndef extract_even(test_tuple: Union[tuple, int]) -> Union[tuple, int]:\n    if isinstance(test_tuple, int):\n        return test_tuple if test_tuple % 2 == 0 else ()\n    result = tuple((extract_even(item) for item in test_tuple if isinstance(item, (int, tuple))))\n    return tuple((item for item in result if item != () or isinstance(item, int)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even_elements(t: tuple) -> tuple:\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                filtered_tuple = filter_even_elements(item)\n                result.append(filtered_tuple)\n            elif isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n        return tuple(result)\n    return filter_even_elements(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(t):\n        if isinstance(t, int):\n            return (t,) if t % 2 == 0 else ()\n        elif isinstance(t, tuple):\n            result = tuple((helper(ele) for ele in t))\n            return tuple((ele for ele in result if ele or isinstance(ele, tuple)))\n        return ()\n    result = helper(test_tuple)\n    return result", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, tuple]]) -> tuple:\n\n    def filter_even(inner_tuple):\n        result = []\n        for item in inner_tuple:\n            if isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n            elif isinstance(item, tuple):\n                nested_result = filter_even(item)\n                result.append(nested_result)\n        return tuple(result)\n    return filter_even(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def recursive_extraction(t):\n        result = []\n        for item in t:\n            if isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n            elif isinstance(item, tuple):\n                nested_result = recursive_extraction(item)\n                result.append(nested_result)\n        return tuple(result)\n    return recursive_extraction(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def is_even_integer(n):\n        return isinstance(n, int) and n % 2 == 0\n\n    def process_tuple(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                result.append(process_tuple(item))\n            elif is_even_integer(item):\n                result.append(item)\n        return tuple(filter(lambda x: x != (), result))\n    return process_tuple(test_tuple)"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.6, "original_passk": 0.7}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n    \"\"\"\n    Write a Python function to find the surface area of a square pyramid with a given base edge and slant height.\n    The surface area is calculated as the sum of the base area and the lateral area, where the lateral area is computed using the slant height.\n    assert surface_Area(3,4) == 33\n    \"\"\"", "generated_programs": ["import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    total_surface_area = base_area + lateral_area\n    return total_surface_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    total_surface_area = base_area + lateral_area\n    return total_surface_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "from typing import Tuple\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/583", "requirement": "def catalan_number(num: int) -> int:\n    \"\"\"\n    Calculate the nth Catalan number for a given non-negative integer n.\n    \n    The Catalan number is computed using the formula: C(n) = (2n choose n) / (n + 1).\n    \n    Args:\n        num (int): A non-negative integer representing the position in the Catalan sequence.\n        \n    Returns:\n        int: The nth Catalan number.\n        \n    Raises:\n        ValueError: If the input `num` is a negative integer.\n        \n    Examples:\n        >>> catalan_number(10)\n        16796\n        >>> catalan_number(-1)\n        ValueError\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('The input `num` must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('The input `num` must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('The input `num` must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "import math\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('The input must be a non-negative integer.')\n    return math.comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError('The input must be a non-negative integer')\n    return comb(2 * num, num) // (num + 1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Given rectangular coordinates (x, y), calculate the corresponding polar coordinates (magnitude, angle) and return them along with the original rectangular coordinates as a complex number.\n    \n    The function computes the magnitude as the distance from the origin using `math.hypot(x, y)` and the angle in radians using `math.atan2(y, x)`. The rectangular coordinates are represented as a complex number `complex(x, y)`.\n    \n    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_as_complex = complex(x, y)\n    return ((magnitude, angle), rect_as_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_as_complex = complex(x, y)\n    return ((magnitude, angle), rect_as_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_as_complex = complex(x, y)\n    return ((magnitude, angle), rect_as_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_as_complex = complex(x, y)\n    return ((magnitude, angle), rect_as_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_as_complex = complex(x, y)\n    return ((magnitude, angle), rect_as_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/592", "requirement": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given integer n.\n    Specifically, the function computes the sum of the product of comb(n, i) and comb(n, i + 1) for i ranging from 0 to n-1.\n    assert sum_Of_product(3) == 15\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the difference between the first even and first odd number in a given list.\n    \n    The function iterates through the list to find the first even and first odd numbers.\n    If both an even and an odd number are found, it returns the difference (even - odd).\n    If either an even or an odd number is not found, the function returns 0.\n    \n    Examples:\n    >>> diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8])\n    3\n    >>> diff_even_odd([2, 4, 6, 8, 10])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_found = odd_found = False\n    even = odd = 0\n    for number in list1:\n        if number % 2 == 0 and (not even_found):\n            even = number\n            even_found = True\n        elif number % 2 != 0 and (not odd_found):\n            odd = number\n            odd_found = True\n        if even_found and odd_found:\n            return even - odd\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_found = None\n    odd_found = None\n    for num in list1:\n        if even_found is not None and odd_found is not None:\n            break\n        if even_found is None and num % 2 == 0:\n            even_found = num\n        if odd_found is None and num % 2 != 0:\n            odd_found = num\n    if even_found is not None and odd_found is not None:\n        return even_found - odd_found\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for number in list1:\n        if not even_found and number % 2 == 0:\n            first_even = number\n            even_found = True\n        if not odd_found and number % 2 != 0:\n            first_odd = number\n            odd_found = True\n        if even_found and odd_found:\n            break\n    if even_found and odd_found:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for number in list1:\n        if not even_found and number % 2 == 0:\n            first_even = number\n            even_found = True\n        if not odd_found and number % 2 != 0:\n            first_odd = number\n            odd_found = True\n        if even_found and odd_found:\n            return first_even - first_odd\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if num % 2 == 0 and (not even_found):\n            first_even = num\n            even_found = True\n        if num % 2 != 0 and (not odd_found):\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            break\n    if even_found and odd_found:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for number in list1:\n        if number % 2 == 0 and first_even is None:\n            first_even = number\n        elif number % 2 != 0 and first_odd is None:\n            first_odd = number\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even - odd\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even - odd\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the k-th element in the combined sorted order of the given two sorted arrays.\n    The function assumes 1-based indexing for `k`, meaning the first element is considered as `k=1`.\n    If `k` is out of bounds (i.e., greater than the total number of elements in `arr1` and `arr2` combined),\n    the function should return -1. The function should handle cases where one or both of the arrays are empty.\n\n    Examples:\n    >>> find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5)\n    6\n    >>> find_kth([], [1, 2, 3], 2)\n    2\n    >>> find_kth([1, 2, 3], [], 4)\n    -1\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    total_length = len(arr1) + len(arr2)\n    if k < 1 or k > total_length:\n        return -1\n    index1, index2 = (0, 0)\n    while k > 0:\n        if index1 < len(arr1) and (index2 >= len(arr2) or arr1[index1] < arr2[index2]):\n            result = arr1[index1]\n            index1 += 1\n        else:\n            result = arr2[index2]\n            index2 += 1\n        k -= 1\n    return result", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if i + j == k - 1:\n            return min(arr1[i], arr2[j])\n        if arr1[i] < arr2[j]:\n            i += 1\n        else:\n            j += 1\n    if i < len(arr1):\n        if i + j == k - 1:\n            return arr1[i]\n        return arr1[i + (k - (i + j + 1))]\n    if j < len(arr2):\n        if i + j == k - 1:\n            return arr2[j]\n        return arr2[j + (k - (i + j + 1))]\n    return -1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k <= 0:\n        return -1\n    n1, n2 = (len(arr1), len(arr2))\n    total_len = n1 + n2\n    if k > total_len:\n        return -1\n    i, j = (0, 0)\n    while i < n1 and j < n2:\n        if k == 1:\n            return min(arr1[i], arr2[j])\n        mid = k // 2\n        new_i = min(i + mid, n1) - 1\n        new_j = min(j + mid, n2) - 1\n        if arr1[new_i] <= arr2[new_j]:\n            k -= new_i - i + 1\n            i = new_i + 1\n        else:\n            k -= new_j - j + 1\n            j = new_j + 1\n    if i < n1:\n        return arr1[i + k - 1]\n    if j < n2:\n        return arr2[j + k - 1]\n    return -1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        return -1\n    index1, index2 = (0, 0)\n    while index1 < len(arr1) and index2 < len(arr2):\n        if k == 1:\n            return min(arr1[index1], arr2[index2])\n        mid1 = index1 + k // 2 - 1 if index1 + k // 2 - 1 < len(arr1) else len(arr1) - 1\n        mid2 = index2 + k // 2 - 1 if index2 + k // 2 - 1 < len(arr2) else len(arr2) - 1\n        if arr1[mid1] < arr2[mid2]:\n            k -= mid1 - index1 + 1\n            index1 = mid1 + 1\n        else:\n            k -= mid2 - index2 + 1\n            index2 = mid2 + 1\n    if index1 < len(arr1):\n        return arr1[index1 + k - 1]\n    if index2 < len(arr2):\n        return arr2[index2 + k - 1]\n    return -1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        return -1\n    index1, index2 = (0, 0)\n    while k > 0:\n        if index1 < len(arr1) and (index2 >= len(arr2) or arr1[index1] <= arr2[index2]):\n            kth_element = arr1[index1]\n            index1 += 1\n        else:\n            kth_element = arr2[index2]\n            index2 += 1\n        k -= 1\n    return kth_element", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k <= 0:\n        return -1\n    i, j, count = (0, 0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == k:\n                return arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return arr2[j]\n            j += 1\n    while i < len(arr1):\n        count += 1\n        if count == k:\n            return arr1[i]\n        i += 1\n    while j < len(arr2):\n        count += 1\n        if count == k:\n            return arr2[j]\n        j += 1\n    return -1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    n1, n2 = (len(arr1), len(arr2))\n    if k > n1 + n2 or k < 1:\n        return -1\n    index1, index2 = (0, 0)\n    while True:\n        if index1 == n1:\n            return arr2[index2 + k - 1]\n        if index2 == n2:\n            return arr1[index1 + k - 1]\n        if k == 1:\n            return min(arr1[index1], arr2[index2])\n        new_index1 = min(index1 + k // 2 - 1, n1 - 1)\n        new_index2 = min(index2 + k // 2 - 1, n2 - 1)\n        if arr1[new_index1] <= arr2[new_index2]:\n            k -= new_index1 - index1 + 1\n            index1 = new_index1 + 1\n        else:\n            k -= new_index2 - index2 + 1\n            index2 = new_index2 + 1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    n, m = (len(arr1), len(arr2))\n    if k <= 0 or k > n + m:\n        return -1\n    i, j, count = (0, 0, 0)\n    while i < n and j < m:\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == k:\n                return arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return arr2[j]\n            j += 1\n    while i < n:\n        count += 1\n        if count == k:\n            return arr1[i]\n        i += 1\n    while j < m:\n        count += 1\n        if count == k:\n            return arr2[j]\n        j += 1\n    return -1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    n, m = (len(arr1), len(arr2))\n    if k > n + m or k < 1:\n        return -1\n    i, j, count = (0, 0, 0)\n    while i < n and j < m:\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == k:\n                return arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return arr2[j]\n            j += 1\n    while i < n:\n        count += 1\n        if count == k:\n            return arr1[i]\n        i += 1\n    while j < m:\n        count += 1\n        if count == k:\n            return arr2[j]\n        j += 1\n    return -1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    n, m = (len(arr1), len(arr2))\n    if k > n + m:\n        return -1\n    index1, index2 = (0, 0)\n    while index1 < n and index2 < m:\n        if k == 1:\n            return min(arr1[index1], arr2[index2])\n        mid = k // 2\n        new_index1 = min(index1 + mid, n) - 1\n        new_index2 = min(index2 + mid, m) - 1\n        if arr1[new_index1] <= arr2[new_index2]:\n            k -= new_index1 - index1 + 1\n            index1 = new_index1 + 1\n        else:\n            k -= new_index2 - index2 + 1\n            index2 = new_index2 + 1\n    if index1 < n:\n        return arr1[index1 + k - 1]\n    if index2 < m:\n        return arr2[index2 + k - 1]\n    return -1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/602", "requirement": "def first_repeated_char(str1: str) -> str:\n    \"\"\"\n    Write a python function to find the first repeated character in a given string. \n    If no character is repeated, the function should return an empty string ('').\n\n    Examples:\n    >>> first_repeated_char(\"abcabc\")\n    'a'\n    >>> first_repeated_char(\"abcdef\")\n    ''\n    \"\"\"", "generated_programs": ["def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen_chars = set()\n    for char in str1:\n        if char in seen_chars:\n            return char\n        seen_chars.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/604", "requirement": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse the order of words in a given string, where words are separated by one or more spaces. \n    Leading, trailing, and multiple spaces between words should be normalized to a single space in the output.\n    assert reverse_words(\"python program\")==(\"program python\")\n    \"\"\"", "generated_programs": ["def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "import re\n\ndef reverse_words(s: str) -> str:\n    s = re.sub('\\\\s+', ' ', s.strip())\n    words = s.split(' ')\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/620", "requirement": "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    \"\"\"\n    Write a function to find the size of the largest subset of a list of numbers such that for every pair of numbers in the subset, one number is divisible by the other.\n    Specifically, for any two numbers `x` and `y` in the subset, either `x % y == 0` or `y % x == 0`.\n    If the input list is empty, the function should return 0.\n    \n    Examples:\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n    \"\"\"\n    Write a python function to find the area of the largest right-angled triangle that can be inscribed in a semicircle with a given radius.\n    The largest right-angled triangle inscribed in a semicircle has its hypotenuse as the diameter of the semicircle.\n    The area is calculated using the formula: radius ** 2 * 2.\n    assert triangle_area(-1) == None\n    \"\"\"", "generated_programs": ["def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2 * 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/630", "requirement": "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given 2D coordinate tuple.\n    The function assumes that the input tuple has exactly two elements, representing a 2D coordinate.\n    If the input tuple has more than two elements, the function raises a ValueError.\n    \n    Args:\n        test_tup (Tuple[int, ...]): A tuple representing a 2D coordinate. Must have exactly two elements.\n    \n    Returns:\n        List[List[int]]: A list of lists, where each inner list represents an adjacent coordinate in a 3x3 grid around the given coordinate.\n    \n    Raises:\n        ValueError: If the input tuple does not have exactly two elements.\n    \n    Examples:\n        >>> get_coordinates((3, 4))\n        [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n        >>> get_coordinates((1, 1, 1))\n        ValueError\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two elements.')\n    x, y = test_tup\n    adjacent_coords = [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]\n    return adjacent_coords", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two elements.')\n    x, y = test_tup\n    coord_list = []\n    for i in range(x - 1, x + 2):\n        for j in range(y - 1, y + 2):\n            coord_list.append([i, j])\n    return coord_list", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two elements.')\n    x, y = test_tup\n    adjacent_coordinates = [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]\n    return adjacent_coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two elements.')\n    x, y = test_tup\n    adjacent_coords = []\n    for i in range(x - 1, x + 2):\n        for j in range(y - 1, y + 2):\n            adjacent_coords.append([i, j])\n    return adjacent_coords", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two elements.')\n    x, y = test_tup\n    adjacent_coordinates = [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]\n    return adjacent_coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two elements.')\n    x, y = test_tup\n    adjacent_coords = []\n    for i in range(x - 1, x + 2):\n        for j in range(y - 1, y + 2):\n            adjacent_coords.append([i, j])\n    return adjacent_coords", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two elements.')\n    x, y = test_tup\n    adjacent_coords = []\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            adjacent_coords.append([x + dx, y + dy])\n    return adjacent_coords", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two elements representing a 2D coordinate.')\n    x, y = test_tup\n    adjacent_coordinates = [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]\n    return adjacent_coordinates", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two elements.')\n    x, y = test_tup\n    adjacent_coords = [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]\n    return adjacent_coords", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError('Input tuple must have exactly two elements.')\n    x, y = test_tup\n    adjacent_coordinates = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            adjacent_coordinates.append([x + dx, y + dy])\n    return adjacent_coordinates"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/631", "requirement": "def replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace all whitespace characters with underscores in a given string.\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    \"\"\"", "generated_programs": ["def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the nearest integer given the wind velocity in km/h and a temperature in celsius.\n    assert wind_chill(120,35)==40\n    \"\"\"", "generated_programs": ["from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16))", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n    return round(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wind_chill_index)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.4}}
{"task_id": "Mbpp/722", "requirement": "def filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    Filters students whose height and weight are both greater than or equal to the specified minimum values.\n    \n    Args:\n        students: A dictionary where the key is the student's name and the value is a tuple of (height, weight).\n        h: The minimum height threshold.\n        w: The minimum weight threshold.\n    \n    Returns:\n        A dictionary containing only the students who meet or exceed both the height and weight thresholds.\n    \n    Example:\n        >>> filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70)\n        {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: metrics for name, metrics in students.items() if metrics[0] >= h and metrics[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: stats for name, stats in students.items() if stats[0] >= h and stats[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: stats for name, stats in students.items() if stats[0] >= h and stats[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: stats for name, stats in students.items() if stats[0] >= h and stats[1] >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/735", "requirement": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Write a Python function to toggle all bits of the number except the most significant bit (MSB) and the least significant bit (LSB) in its binary representation. \n    If the number has fewer than 3 bits, return the number unchanged. For the special case where the number is 0, return 1.\n    \n    assert toggle_middle_bits(9) == 15\n    \"\"\"", "generated_programs": ["def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) < 3:\n        return n\n    msb = binary[0]\n    lsb = binary[-1]\n    toggled_middle = ''.join(('1' if bit == '0' else '0' for bit in binary[1:-1]))\n    result_binary = msb + toggled_middle + lsb\n    return int(result_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_rep = bin(n)[2:]\n    if len(binary_rep) < 3:\n        return n\n    toggled_binary = binary_rep[0] + ''.join(('1' if bit == '0' else '0' for bit in binary_rep[1:-1])) + binary_rep[-1]\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) < 3:\n        return n\n    msb = binary[0]\n    lsb = binary[-1]\n    middle_bits = binary[1:-1]\n    toggled_middle_bits = ''.join(('1' if bit == '0' else '0' for bit in middle_bits))\n    toggled_binary = msb + toggled_middle_bits + lsb\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_str = bin(n)[2:]\n    if len(binary_str) < 3:\n        return n\n    msb = binary_str[0]\n    lsb = binary_str[-1]\n    middle_bits_toggled = ''.join(('0' if bit == '1' else '1' for bit in binary_str[1:-1]))\n    toggled_binary_str = msb + middle_bits_toggled + lsb\n    return int(toggled_binary_str, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) < 3:\n        return n\n    msb = binary_representation[0]\n    lsb = binary_representation[-1]\n    middle_bits = binary_representation[1:-1]\n    toggled_middle_bits = ''.join(('1' if bit == '0' else '0' for bit in middle_bits))\n    toggled_binary_representation = msb + toggled_middle_bits + lsb\n    return int(toggled_binary_representation, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) < 3:\n        return n\n    toggled_bits = binary[0] + ''.join(('1' if bit == '0' else '0' for bit in binary[1:-1])) + binary[-1]\n    return int(toggled_bits, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = f'{n:b}'\n    if len(binary) < 3:\n        return n\n    msb = binary[0]\n    lsb = binary[-1]\n    middle = ''.join(('1' if c == '0' else '0' for c in binary[1:-1]))\n    toggled_binary = msb + middle + lsb\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) < 3:\n        return n\n    msb = binary[0]\n    lsb = binary[-1]\n    toggled_middle = ''.join(('1' if bit == '0' else '0' for bit in binary[1:-1]))\n    toggled_binary = msb + toggled_middle + lsb\n    return int(toggled_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) < 3:\n        return n\n    toggled_bits = binary_representation[0] + ''.join(('1' if bit == '0' else '0' for bit in binary_representation[1:-1])) + binary_representation[-1]\n    return int(toggled_bits, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary = bin(n)[2:]\n    if len(binary) < 3:\n        return n\n    msb = binary[0]\n    lsb = binary[-1]\n    middle_bits = ''.join(('1' if bit == '0' else '0' for bit in binary[1:-1]))\n    toggled_binary = msb + middle_bits + lsb\n    return int(toggled_binary, 2)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/740", "requirement": "from typing import Dict, Tuple, Any\n\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    \"\"\"\n    Write a function to convert the given tuple to a key-value dictionary by pairing every two adjacent elements, starting from the first element.\n    If the tuple has an odd length, the last element should be ignored.\n    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/743", "requirement": "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    \"\"\"\n    Write a function to rotate a given list by a specified number of items to the right direction. \n    The function should handle the following cases:\n    1. If the list is empty (`[]`), return an empty list (`[]`) without raising an error.\n    2. If `m` exceeds the length of the list, use `m % len(l)` to determine the effective number of rotations.\n    3. If `m` is negative, treat it as rotating to the left by `abs(m)` positions. This is equivalent to rotating to the right by `len(l) - abs(m) % len(l)` positions. The modulo operation (`% len(l)`) ensures that the effective rotation index is within the bounds of the list length.\n    4. The function assumes valid input types: `l` is a list of integers, and `m` is an integer.\n\n    Example:\n    assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m %= n\n    if m < 0:\n        m = n - abs(m) % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n if m >= 0 else n - abs(m) % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m %= n\n    if m < 0:\n        m = n - -m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m %= n\n    if m < 0:\n        m = n - abs(m) % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m %= n\n    if m < 0:\n        m = n - abs(m) % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n if m >= 0 else n - abs(m) % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n if m >= 0 else n - abs(m) % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n\n    if m < 0:\n        m = (n - abs(m) % n) % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m %= n\n    if m < 0:\n        m = n - -m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n if m >= 0 else n - abs(m) % n\n    return l[-m:] + l[:-m]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\"\"\"\nWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. \nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_each_digit(num: int) -> bool:\n        original_num = num\n        while num > 0:\n            digit = num % 10\n            if digit == 0 or original_num % digit != 0:\n                return False\n            num //= 10\n        return True\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_each_digit(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef is_divisible_by_digits(number: int) -> bool:\n    original_number = number\n    while number > 0:\n        digit = number % 10\n        if digit == 0 or original_number % digit != 0:\n            return False\n        number //= 10\n    return True\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        num_str = str(num)\n        if '0' in num_str:\n            continue\n        if all((num % int(digit) == 0 for digit in num_str)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(num: int) -> bool:\n        original_num = num\n        while num > 0:\n            digit = num % 10\n            if digit == 0 or original_num % digit != 0:\n                return False\n            num //= 10\n        return True\n    result = []\n    for number in range(startnum, endnum + 1):\n        if is_divisible_by_digits(number):\n            result.append(number)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(number: int) -> bool:\n        for digit in str(number):\n            if digit == '0' or number % int(digit) != 0:\n                return False\n        return True\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(number: int) -> bool:\n        num_str = str(number)\n        for char in num_str:\n            digit = int(char)\n            if digit == 0 or number % digit != 0:\n                return False\n        return True\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_all_digits(number: int) -> bool:\n        num_str = str(number)\n        for char in num_str:\n            if char == '0':\n                return False\n            if number % int(char) != 0:\n                return False\n        return True\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_all_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\n    def is_divisible_by_digits(n: int) -> bool:\n        original = n\n        while n > 0:\n            digit = n % 10\n            if digit == 0 or original % digit != 0:\n                return False\n            n //= 10\n        return True\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if '0' in str_num:\n            continue\n        if all((num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.5, "original_passk": 0.4}}
{"task_id": "Mbpp/752", "requirement": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Jacobsthal number using the recurrence relation:\n    J(n) = J(n-1) + 2 * J(n-2), with base cases J(0) = 0 and J(1) = 1.\n    The function should return 1 for any negative input.\n    The sequence starts as 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    assert jacobsthal_num(5) == 11\n    \"\"\"", "generated_programs": ["def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    prev2, prev1 = (0, 1)\n    for _ in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2, prev1 = (prev1, current)\n    return prev1", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    prev2, prev1 = (0, 1)\n    for _ in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2, prev1 = (prev1, current)\n    return prev1", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    j2, j1 = (0, 1)\n    for i in range(2, n + 1):\n        jn = j1 + 2 * j2\n        j2, j1 = (j1, jn)\n    return j1", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = (0, 1)\n    for i in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    j_n_minus_2, j_n_minus_1 = (0, 1)\n    j_n = 0\n    for _ in range(2, n + 1):\n        j_n = j_n_minus_1 + 2 * j_n_minus_2\n        j_n_minus_2, j_n_minus_1 = (j_n_minus_1, j_n)\n    return j_n", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    prev2 = 0\n    prev1 = 1\n    for _ in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    return current", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    j0, j1 = (0, 1)\n    for _ in range(2, n + 1):\n        jn = j1 + 2 * j0\n        j0, j1 = (j1, jn)\n    return j1", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    prev2 = 0\n    prev1 = 1\n    current = 0\n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    return current", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List\n\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function to find the minimum difference between any two adjacent elements in a sorted version of the given array.\n    The function should first sort the array and then calculate the smallest difference between consecutive elements.\n    assert find_min_diff((1,5,3,19,18,25),6) == 1\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    if n <= 1:\n        return 0\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        diff = arr[i] - arr[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        diff = sorted_arr[i] - sorted_arr[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, sorted_arr[i] - sorted_arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        diff = arr[i] - arr[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.30000000000000004, "original_passk": 0.0}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number. Polite numbers are positive integers that can be expressed as the sum of two or more consecutive positive integers. The nth polite number can be calculated using the formula: polite(n) = n + floor(0.5 + sqrt(2 * n)).\n\n    Reference: geeksforgeeks.org/n-th-polite-number/\n\n    Examples:\n    >>> assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(0.5 + math.sqrt(2 * n))", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(0.5 + math.sqrt(2 * n))", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(0.5 + math.sqrt(2 * n))", "from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(0.5 + math.sqrt(2 * n))", "import math\n\ndef is_polite(n: int) -> int:\n    return n + int(0.5 + math.sqrt(2 * n))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Write a Python function to get the elements in `li1` that are not present in `li2`, preserving the original order of elements in `li1`. \n    Duplicates in `li1` should be retained unless they are present in `li2`, in which case all occurrences should be removed.\n    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [x for x in li1 if x not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [x for x in li1 if x not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set_li2 = set(li2)\n    return [x for x in li1 if x not in set_li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [element for element in li1 if element not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [x for x in li1 if x not in set(li2)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even number and the first odd number in a given list.\n    If either an even or odd number is not found in the list, the function should return 0.\n    \n    Examples:\n    >>> mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8])\n    4\n    >>> mul_even_odd([2, 4, 6, 8])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for number in list1:\n        if number % 2 == 0 and first_even is None:\n            first_even = number\n        elif number % 2 != 0 and first_odd is None:\n            first_odd = number\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for number in list1:\n        if even is None and number % 2 == 0:\n            even = number\n        elif odd is None and number % 2 != 0:\n            odd = number\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    found_even = None\n    found_odd = None\n    for num in list1:\n        if num % 2 == 0:\n            if found_even is None:\n                found_even = num\n        elif found_odd is None:\n            found_odd = num\n        if found_even is not None and found_odd is not None:\n            break\n    if found_even is None or found_odd is None:\n        return 0\n    return found_even * found_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for number in list1:\n        if not even_found and number % 2 == 0:\n            first_even = number\n            even_found = True\n        if not odd_found and number % 2 != 0:\n            first_odd = number\n            odd_found = True\n        if even_found and odd_found:\n            break\n    if even_found and odd_found:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    even_number = 0\n    odd_number = 0\n    for number in list1:\n        if not even_found and number % 2 == 0:\n            even_number = number\n            even_found = True\n        if not odd_found and number % 2 != 0:\n            odd_number = number\n            odd_found = True\n        if even_found and odd_found:\n            return even_number * odd_number\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for number in list1:\n        if not even_found and number % 2 == 0:\n            first_even = number\n            even_found = True\n        elif not odd_found and number % 2 != 0:\n            first_odd = number\n            odd_found = True\n        if even_found and odd_found:\n            return first_even * first_odd\n    return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/785", "requirement": "def tuple_str_int(test_str: str) -> tuple:\n    \"\"\"\n    Convert a string representation of a tuple of integers into a tuple of integers.\n    The input string is expected to be in the format '(a, b, c, ...)', where a, b, c, etc., are integers.\n    Single-element tuples should be handled as tuples, e.g., '(1)' should be converted to (1,).\n    The function processes the string by stripping the parentheses and splitting by commas, then mapping the elements to integers.\n    \n    Examples:\n    >>> tuple_str_int(\"(7, 8, 9)\")\n    (7, 8, 9)\n    >>> tuple_str_int(\"(1)\")\n    (1,)\n    \"\"\"", "generated_programs": ["def tuple_str_int(test_str: str) -> tuple:\n    return eval(test_str)", "def tuple_str_int(test_str: str) -> tuple:\n    import ast\n    return ast.literal_eval(test_str)", "def tuple_str_int(test_str: str) -> tuple:\n    test_str = test_str.strip()[1:-1]\n    if not test_str:\n        return ()\n    elements = test_str.split(',')\n    elements = [int(elem.strip()) for elem in elements]\n    return tuple(elements)", "from typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, ...]:\n    test_str = test_str.strip('()')\n    if not test_str:\n        return ()\n    return tuple(map(int, test_str.split(', ')))", "def tuple_str_int(test_str: str) -> tuple:\n    test_str = test_str.strip('()')\n    elements = test_str.split(',')\n    elements = [int(e.strip()) for e in elements if e.strip()]\n    return tuple(elements)", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(', '))) if ', ' in test_str else (int(test_str.strip('()')),)", "def tuple_str_int(test_str: str) -> tuple:\n    from ast import literal_eval\n    return literal_eval(test_str)", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(','))) if ',' in test_str else (int(test_str.strip('()')),)", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(','))) if ',' in test_str else (int(test_str.strip('()')),)", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.strip('()').split(', '))) if ',' in test_str else (int(test_str.strip('()')),)"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.6, "original_passk": 0.9}}
{"task_id": "Mbpp/787", "requirement": "def text_match_three(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches a string that contains an 'a' followed by exactly three 'b's anywhere in the string.\n    The function should use `re.search` to find the match anywhere in the string.\n    assert not text_match_three(\"ac\")\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('ab{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('a.*b{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('a.*?bbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('a.*?b{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'a\\\\.*?b{3}'\n    return re.search(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('a.*?b{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('a(?!b*?[^b])b{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('a.*?b{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('a.*?bbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    return re.search(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches a string that starts with 'a', followed by zero or more characters, and ends with a single 'b'.\n    The entire string must conform to this pattern.\n    assert text_starta_endb(\"aabbbb\")\n    \"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a.*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a.*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a.*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a.*b', text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}

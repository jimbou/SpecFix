{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that starts with the given string by appending the minimum necessary characters to its end.\n    \n    The function identifies the longest palindromic suffix of the input string and appends the reverse of the non-palindromic prefix to the end of the string.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n):\n        if string[i:] == string[i:][::-1]:\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    for i in range(n):\n        if string[i:] == string[i:][::-1]:\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "code\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    reversed_string = string[::-1]\n    for i in range(len(string)):\n        if string.startswith(reversed_string[i:]):\n            return string + reversed_string[:i]\n    return string + reversed_string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    for i in range(n):\n        if string[i:] == string[i:][::-1]:\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    for i in range(len(string), -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    for i in range(n):\n        if string[i:] == string[i:][::-1]:\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string + string[:-1][::-1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.4, "original_passk": 0.0}}
{"task_id": "HumanEval/32", "requirement": "def find_zero(xs: List[float]) -> float:\n    \"\"\"Finds a zero of the polynomial with coefficients xs using the bisection method within the interval [-100, 100].\n    The function assumes that xs has an even number of coefficients and that there is at least one real root within the interval.\n    Returns only one zero point, even if there are multiple. The bisection method stops when the value of the polynomial at the midpoint is exactly zero or when the interval is smaller than 1e-07.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    left, right = (-100.0, 100.0)\n    while right - left > 1e-07:\n        mid = (left + right) / 2\n        val = polynomial(mid)\n        if val == 0:\n            return mid\n        elif polynomial(left) * val < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    left, right = (-100.0, 100.0)\n    while right - left > 1e-07:\n        mid = (left + right) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(left) * polynomial(mid) < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    a, b = (-100, 100)\n    while b - a > 1e-07:\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    left, right = (-100, 100)\n    while right - left > 1e-07:\n        mid = (left + right) / 2\n        val = polynomial(mid)\n        if val == 0:\n            return mid\n        if polynomial(left) * val < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100.0, 100.0)\n    while b - a > 1e-07:\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100.0, 100.0)\n    while b - a > 1e-07:\n        mid = (a + b) / 2\n        val = polynomial(mid)\n        if val == 0:\n            return mid\n        if polynomial(a) * val < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def evaluate_poly(x):\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    a, b = (-100.0, 100.0)\n    while abs(b - a) > 1e-07:\n        midpoint = (a + b) / 2\n        val = evaluate_poly(midpoint)\n        if val == 0:\n            return midpoint\n        if evaluate_poly(a) * val < 0:\n            b = midpoint\n        else:\n            a = midpoint\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    left, right = (-100.0, 100.0)\n    while right - left > 1e-07:\n        mid = (left + right) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(left) * polynomial(mid) < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    a, b = (-100, 100)\n    while abs(a - b) > 1e-07:\n        mid = (a + b) / 2\n        p_mid = polynomial(mid)\n        if abs(p_mid) < 1e-07:\n            return mid\n        p_a = polynomial(a)\n        if p_a * p_mid < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    a, b = (-100, 100)\n    while b - a > 1e-07:\n        mid = (a + b) / 2\n        p_mid = polynomial(mid)\n        if p_mid == 0:\n            return mid\n        if polynomial(a) * p_mid < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    if n % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        return (l_sorted[n // 2 - 1] + l_sorted[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    half = n // 2\n    if n % 2 == 1:\n        return sorted_l[half]\n    else:\n        return (sorted_l[half - 1] + sorted_l[half]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2\n    else:\n        return l_sorted[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/59", "requirement": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of the given integer n. \n    The function assumes that n is greater than 1 and is not a prime number itself.\n    \n    The largest prime factor is the greatest prime number that divides n without leaving a remainder.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"", "generated_programs": ["def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n        i += 1\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_prime = -1\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n    if n > 2:\n        largest_prime = n\n    return largest_prime", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_factor = -1\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_prime = -1\n    while n % 2 == 0:\n        largest_prime = 2\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n    if n > 2:\n        largest_prime = n\n    return largest_prime", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_factor = -1\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_factor = 1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_prime = -1\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n    if n > 2:\n        largest_prime = n\n    return largest_prime", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_factor = -1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "def largest_prime_factor(n: int) -> int:\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    largest_factor = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            if is_prime(n // i):\n                largest_factor = n // i\n    return largest_factor"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/60", "requirement": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n. If n is negative, the function returns 0.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    >>> sum_to_n(-5)\n    0\n    \"\"\"", "generated_programs": ["def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/65", "requirement": "def circular_shift(x: int, shift: int) -> str:\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"", "generated_programs": ["def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    shift = shift % n\n    return s[-shift:] + s[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    shift = shift % n\n    return s[-shift:] + s[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    shift = shift % n\n    return s[-shift:] + s[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    shifted = digits[-shift:] + digits[:-shift]\n    return shifted", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    '''\n    Write a function that takes an integer a and returns True \n    if there exists an integer n such that n^3 equals a.\n    The function should correctly handle both positive and negative integers.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    n = round(abs(a) ** (1 / 3)) if a != 0 else 0\n    return n ** 3 == a or (-n) ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        n = -round(abs(a) ** (1 / 3))\n    else:\n        n = round(a ** (1 / 3))\n    return n ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        n = -round(abs(a) ** (1 / 3))\n    else:\n        n = round(a ** (1 / 3))\n    return n ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        n = -round(abs(a) ** (1 / 3))\n    else:\n        n = round(a ** (1 / 3))\n    return n ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        n = -round(abs(a) ** (1 / 3))\n    else:\n        n = round(a ** (1 / 3))\n    return n ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        n = -round(abs(a) ** (1 / 3))\n    else:\n        n = round(a ** (1 / 3))\n    return n ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        n = -round(abs(a) ** (1 / 3))\n    else:\n        n = round(a ** (1 / 3))\n    return n ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        n = -round(abs(a) ** (1 / 3))\n    else:\n        n = round(a ** (1 / 3))\n    return n ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        n = -round(abs(a) ** (1 / 3))\n    else:\n        n = round(a ** (1 / 3))\n    return n ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    n = round(abs(a) ** (1 / 3))\n    if a < 0:\n        n = -n\n    return n ** 3 == a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1. Numbers that both start and end\n    with 1 should be counted only once.\n    \n    Examples:\n    >>> starts_one_ends(1)\n    1\n    >>> starts_one_ends(2)\n    18\n    >>> starts_one_ends(3)\n    180\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    both = 10 ** (n - 2)\n    return start_with_one + end_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    both_with_one = 10 ** (n - 2)\n    return start_with_one + end_with_one - both_with_one", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    count_start = 10 ** (n - 1)\n    count_end = 10 ** (n - 1)\n    count_both = 10 ** (n - 2)\n    return count_start + count_end - count_both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 2)\n    both_start_and_end_with_one = 10 ** (n - 2)\n    return start_with_one + end_with_one - both_start_and_end_with_one", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    count_start_with_one = 10 ** (n - 1)\n    count_end_with_one = 10 ** (n - 1)\n    count_both = 10 ** (n - 2)\n    return count_start_with_one + count_end_with_one - count_both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    numbers_start_with_1 = 10 ** (n - 1)\n    numbers_end_with_1 = 10 ** (n - 1)\n    numbers_start_and_end_with_1 = 10 ** (n - 2)\n    return numbers_start_with_1 + numbers_end_with_1 - numbers_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_start_with_1 = 10 ** (n - 1)\n    total_end_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 10 ** (n - 2)\n    return total_start_with_1 + total_end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total = 0\n    total += 10 ** (n - 1)\n    total += 9 * 10 ** (n - 2)\n    total -= 10 ** (n - 2)\n    return total", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total = 0\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    both = 10 ** (n - 2)\n    total = start_with_one + end_with_one - both\n    return total", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total = 0\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 2) + (10 ** (n - 1) if n > 1 else 0)\n    both = 10 ** (n - 2)\n    total = start_with_one + end_with_one - both\n    return total"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by four places. The rotation should be applied separately \n    for uppercase and lowercase letters.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for c in s:\n        if 'a' <= c <= 'z':\n            rotated = chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n            result.append(rotated)\n        elif 'A' <= c <= 'Z':\n            rotated = chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n            result.append(rotated)\n        else:\n            result.append(c)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            encrypted_char = char\n        encrypted.append(encrypted_char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)", "import string\n\ndef encrypt(s: str) -> str:\n\n    def shift_char(c, shift):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join([shift_char(c, 4) for c in s])", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted_char)\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            encrypted_char = char\n        encrypted.append(encrypted_char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is defined as a sentence that starts with the exact\n    sequence 'I ' (the letter 'I' followed by a space). Sentences are delimited by '.', '?',\n    or '!'. Consecutive delimiters or delimiters within words should not affect sentence separation.\n    Duplicate sentences are counted separately.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n\n    ### Test 1\n    Input: ['I am here. You are there. They are everywhere.']\n    Expected Output: [3]\n\n    ### Test 2\n    Input: ['I. I! I?']\n    Expected Output: [0]\n\n    ### Test 3\n    Input: ['I am bored. Are you? I certainly am!']\n    Expected Output: [4]\n    \"\"\"", "generated_programs": ["code\nimport re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/92", "requirement": "def any_int(x: int, y: int, z: int) -> bool:\n    '''\n    Create a function that takes 3 integers.\n    Returns true if one of the numbers is equal to the sum of the other two.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n    '''", "generated_programs": ["def any_int(x: int, y: int, z: int) -> bool:\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not isinstance(x, int) or not isinstance(y, int) or (not isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not isinstance(x, int) or not isinstance(y, int) or (not isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not isinstance(x, int) or not isinstance(y, int) or (not isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not isinstance(x, int) or not isinstance(y, int) or (not isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message consisting solely of letters, and encodes it by first swapping the case of all letters and then replacing each vowel with the letter that appears two places ahead of it in the English alphabet, considering the case (uppercase or lowercase) of the vowel.\n\n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in message:\n        if char.isalpha():\n            char = char.swapcase()\n            if char in vowels:\n                if char == 'Y':\n                    char = 'A'\n                elif char == 'y':\n                    char = 'a'\n                else:\n                    char = chr(ord(char) + 2)\n        result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(vowels[char])\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in message:\n        if char.isalpha():\n            swapped_char = char.swapcase()\n            if swapped_char in vowels:\n                shifted_char = chr(ord(swapped_char) + 2) if swapped_char.lower() != 'u' else chr(ord(swapped_char) - 4)\n                result.append(shifted_char)\n            else:\n                result.append(swapped_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(vowels[char])\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in message:\n        swapped_char = char.swapcase()\n        if swapped_char in vowels:\n            if swapped_char.islower():\n                new_char = chr((ord(swapped_char) - ord('a') + 2) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(swapped_char) - ord('A') + 2) % 26 + ord('A'))\n            result.append(new_char)\n        else:\n            result.append(swapped_char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in message:\n        swapped_char = char.swapcase()\n        if swapped_char in vowels:\n            if swapped_char.islower():\n                new_char = chr((ord(swapped_char) - ord('a') + 2) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(swapped_char) - ord('A') + 2) % 26 + ord('A'))\n            result.append(new_char)\n        else:\n            result.append(swapped_char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            swapped_char = char.swapcase()\n            if swapped_char in vowels:\n                new_char = chr(ord(swapped_char) + 2) if ord(swapped_char) + 2 <= ord('z') else chr(ord(swapped_char) + 2 - 26)\n                encoded_message.append(new_char)\n            else:\n                encoded_message.append(swapped_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n    for char in message:\n        swapped_char = char.swapcase()\n        if swapped_char in vowels:\n            if swapped_char.islower():\n                new_char = chr((ord(swapped_char) - ord('a') + 2) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(swapped_char) - ord('A') + 2) % 26 + ord('A'))\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(swapped_char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in message:\n        if char.isalpha():\n            swapped_char = char.swapcase()\n            if swapped_char in vowels:\n                if swapped_char.islower():\n                    new_char = chr((ord(swapped_char) - ord('a') + 2) % 26 + ord('a'))\n                else:\n                    new_char = chr((ord(swapped_char) - ord('A') + 2) % 26 + ord('A'))\n                result.append(new_char)\n            else:\n                result.append(swapped_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            if char in vowels:\n                if char == 'y' or char == 'Y':\n                    encoded_message.append(char)\n                else:\n                    if char.islower():\n                        encoded_char = chr((ord(char) - ord('a') + 2) % 26 + ord('a'))\n                    else:\n                        encoded_char = chr((ord(char) - ord('A') + 2) % 26 + ord('A'))\n                    encoded_message.append(encoded_char)\n            else:\n                encoded_message.append(char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.6, "original_passk": 0.0}}
{"task_id": "HumanEval/94", "requirement": "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value in the list and return the sum of its digits.\n    If there are no prime numbers in the list, return 0.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        return 0\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        return 0\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        return 0\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        return 0\n    largest_prime = max(primes)\n    return sum(map(int, str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        return 0\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        return 0\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        return 0\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum((int(digit) for digit in str(n)))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        return 0\n    max_prime = max(primes)\n    return sum_of_digits(max_prime)", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    if max_prime == 0:\n        return 0\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum((int(digit) for digit in str(n)))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    if max_prime == 0:\n        return 0\n    return sum_of_digits(max_prime)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/95", "requirement": "from typing import Dict\n\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"", "generated_programs": ["from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key.islower() for key in keys))\n    upper_case = all((key.isupper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    is_lower = all((key.islower() for key in keys))\n    is_upper = all((key.isupper() for key in keys))\n    return is_lower or is_upper", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    is_lower = all((key.islower() for key in keys))\n    is_upper = all((key.isupper() for key in keys))\n    return is_lower or is_upper", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key.islower() for key in keys))\n    upper_case = all((key.isupper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    all_lower = all((key.islower() for key in keys))\n    all_upper = all((key.isupper() for key in keys))\n    return all_lower or all_upper", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key.islower() for key in keys))\n    upper_case = all((key.isupper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    first_key = next(iter(keys))\n    is_lower = first_key.islower()\n    for key in keys:\n        if is_lower != key.islower():\n            return False\n    return True", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    first_key = next(iter(keys))\n    if not isinstance(first_key, str):\n        return False\n    is_lower = first_key.islower()\n    for key in keys:\n        if not isinstance(key, str):\n            return False\n        if is_lower != key.islower():\n            return False\n    return True", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    first_key = next(iter(keys))\n    if not isinstance(first_key, str):\n        return False\n    is_lower = first_key.islower()\n    for key in keys:\n        if not isinstance(key, str):\n            return False\n        if key.islower() != is_lower:\n            return False\n    return True", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    first_key_case = keys[0].islower() if keys[0].islower() else keys[0].isupper()\n    for key in keys:\n        if key.islower() != first_key_case and key.isupper() != first_key_case:\n            return False\n    return True"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.6, "original_passk": 0.8}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if the current number of stones is odd.\n        - the next even number if the current number of stones is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        current = current + 1 if current % 2 == 0 else current + 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    current = n\n    for _ in range(1, n):\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 2\n        pile.append(current)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    for i in range(1, n):\n        if pile[-1] % 2 == 1:\n            pile.append(pile[-1] + 2)\n        else:\n            pile.append(pile[-1] + 1)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    for i in range(1, n):\n        if pile[-1] % 2 == 1:\n            pile.append(pile[-1] + 2)\n        else:\n            pile.append(pile[-1] + 1)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        if current_stones % 2 == 1:\n            current_stones += 2\n        else:\n            current_stones += 1\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.30000000000000004, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements whose sum of digits (considering the sign of the first digit for negative numbers) is greater than 0.\n    If a number is negative, then its first digit is considered negative:\n    e.g., -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        digits = list(str(abs(num)))\n        sum_digits = sum((int(d) if i == 0 and num < 0 else int(d) for i, d in enumerate(digits)))\n        if sum_digits > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        total = 0\n        if s[0] == '-':\n            total -= int(s[1])\n            for c in s[2:]:\n                total += int(c)\n        else:\n            for c in s:\n                total += int(c)\n        if total > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(abs(num))\n        if num < 0:\n            digit_sum = -int(s[0])\n            for digit in s[1:]:\n                digit_sum += int(digit)\n        else:\n            digit_sum = sum((int(digit) for digit in s))\n        if digit_sum > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            digit_sum = -int(s[1]) + sum((int(d) for d in s[2:]))\n        else:\n            digit_sum = sum((int(d) for d in s))\n        if digit_sum > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            sum_digits = -int(s[1]) + sum((int(d) for d in s[2:]))\n        else:\n            sum_digits = sum((int(d) for d in s))\n        if sum_digits > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            digit_sum = -int(s[1])\n            for c in s[2:]:\n                digit_sum += int(c)\n        else:\n            digit_sum = sum((int(c) for c in s))\n        if digit_sum > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            digit_sum = -int(s[1])\n            for d in s[2:]:\n                digit_sum += int(d)\n        else:\n            digit_sum = sum((int(d) for d in s))\n        if digit_sum > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        if num < 0:\n            digits = [int(d) for d in str(num)[1:]]\n            sum_digits = -digits[0] + sum(digits[1:]) if digits else 0\n        else:\n            sum_digits = sum((int(d) for d in str(num)))\n        if sum_digits > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            sum_digits = -int(s[1])\n            for c in s[2:]:\n                sum_digits += int(c)\n        else:\n            sum_digits = 0\n            for c in s:\n                sum_digits += int(c)\n        if sum_digits > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        digits = str(num)\n        sum_digits = 0\n        if digits[0] == '-':\n            sum_digits += -int(digits[1])\n            for d in digits[2:]:\n                sum_digits += int(d)\n        else:\n            for d in digits:\n                sum_digits += int(d)\n        if sum_digits > 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.9}}
{"task_id": "HumanEval/109", "requirement": "def move_one_ball(arr: List[int]) -> bool:\n    \"\"\"Determine if the array can be sorted in non-decreasing order by performing\n    zero or more right shift operations. A right shift operation moves each element\n    of the array one position to the right, with the last element moving to the\n    first position.\n\n    Specifically, check if there is at most one place in the array where a larger\n    number is followed by a smaller number, which would indicate that the array\n    can be rotated to become sorted. An empty array is considered sorted, so return True.\n\n    Note: The array is guaranteed to contain unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2]) ==> True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2]) ==> False\n    Explanation: It is not possible to get non-decreasing order for the given\n                 array by performing any number of right shift operations.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n    return count <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "code\nfrom typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n    return count <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            count += 1\n            if count > 1:\n                return False\n    return count == 0 or arr[-1] <= arr[0]", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            count += 1\n            if count > 1:\n                return False\n    if count == 0:\n        return True\n    return arr[-1] <= arr[0]", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            count += 1\n    if count == 0:\n        return True\n    if count == 1 and arr[-1] <= arr[0]:\n        return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/110", "requirement": "def exchange(lst1: List[int], lst2: List[int]) -> str:\n    \"\"\"Determine if it is possible to make all elements of lst1 even by exchanging\n    elements with lst2. You can move any number of elements from lst2 to lst1.\n    If all elements in lst1 can be made even through exchanges, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if odd_count1 <= even_count2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if odd_count1 <= even_count2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if odd_count_lst1 <= even_count_lst2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count2 = sum((1 for num in lst2 if num % 2 == 0))\n    if odd_count1 <= even_count2:\n        return 'YES'\n    else:\n        return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    count_odd_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    count_even_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if count_odd_lst1 <= count_even_lst2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    count_odd_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    count_even_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if count_odd_lst1 <= count_even_lst2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if odd_count1 <= even_count2 + (len(lst2) - even_count2) else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    count_odd_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    count_even_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    if count_odd_lst1 == 0:\n        return 'YES'\n    if count_even_lst2 >= count_odd_lst1:\n        return 'YES'\n    return 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/115", "requirement": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells. The number of times you need to lower the buckets\n    is calculated independently for each well and then summed up. This means that for each well, you determine\n    how many full bucket loads are required to remove all the water, considering the bucket's capacity.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        if water > 0:\n            total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for row in grid:\n        water = sum(row)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for row in grid:\n        water = sum(row)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for row in grid:\n        water = sum(row)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "code\nfrom typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        full_loads = (water + capacity - 1) // capacity\n        total += full_loads\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water_units = sum(well)\n        if water_units == 0:\n            continue\n        total += (water_units + capacity - 1) // capacity\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of integers according to the following rules:\n    - Non-negative integers should be sorted based on the number of ones in their binary representation in ascending order.\n    - For non-negative integers with the same number of ones, sort them based on their decimal value.\n    - Negative integers should be placed before any non-negative integers and sorted among themselves based on their decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n\n    def sort_key(n):\n        if n < 0:\n            return (0, n)\n        else:\n            return (1, count_ones(n), n)\n    return sorted(arr, key=sort_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(n).count('1')\n    return sorted(arr, key=lambda x: (x >= 0, -x) if x < 0 else (0, count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    return sorted(arr, key=lambda x: (x >= 0, count_ones(x) if x >= 0 else 0, x) if x >= 0 else (False, 0, x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(n).count('1')\n\n    def custom_sort_key(x: int):\n        if x < 0:\n            return (-1, x)\n        else:\n            return (0, count_ones(x), x)\n    return sorted(arr, key=custom_sort_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(num):\n        return bin(num).count('1')\n\n    def key_func(num):\n        if num < 0:\n            return (-float('inf'), num)\n        else:\n            return (count_ones(num), num)\n    return sorted(arr, key=key_func)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(n).count('1') if n >= 0 else 0\n\n    def sorting_key(x: int):\n        if x < 0:\n            return (0, x)\n        else:\n            return (1, count_ones(x), x)\n    return sorted(arr, key=sorting_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(n).count('1')\n    negative = sorted([x for x in arr if x < 0])\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    negative_numbers = sorted([x for x in arr if x < 0], reverse=True)\n    non_negative_numbers = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    return negative_numbers + non_negative_numbers", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(n).count('1') if n >= 0 else 0\n\n    def sort_key(n: int) -> tuple:\n        if n < 0:\n            return (0, n)\n        else:\n            return (1, count_ones(n), n)\n    return sorted(arr, key=sort_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(n).count('1') if n >= 0 else 0\n\n    def sort_key(n: int) -> tuple:\n        return (n >= 0, count_ones(n), n) if n >= 0 else (False, 0, n)\n    return sorted(arr, key=sort_key)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The date should be in the exact format 'mm-dd-yyyy' with leading zeros for single-digit months and days. Any deviation from this format will result in an invalid date.\n    3. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2, considering leap years.\n    4. The months should not be less than 1 or higher than 12.\n    5. The year should be a valid year greater than '0000'.\n\n    For example:\n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["import re\n\ndef valid_date(date: str) -> bool:\n    if not date or not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if year <= 0 or month < 1 or month > 12 or (day < 1) or (day > 31):\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2:\n        is_leap = year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n        if day > 29 or (day == 29 and (not is_leap)):\n            return False\n    return True", "import re\nfrom calendar import isleap\n\ndef valid_date(date: str) -> bool:\n    if not date or not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month < 1 or month > 12:\n        return False\n    if year <= 0:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        return 1 <= day <= 31\n    elif month in {4, 6, 9, 11}:\n        return 1 <= day <= 30\n    elif month == 2:\n        return 1 <= day <= 29 if isleap(year) else 1 <= day <= 28\n    return False", "import re\nfrom calendar import isleap\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month < 1 or month > 12:\n        return False\n    if year < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        max_days = 31\n    elif month in {4, 6, 9, 11}:\n        max_days = 30\n    else:\n        max_days = 29 if isleap(year) else 28\n    if day < 1 or day > max_days:\n        return False\n    return True", "import re\nfrom calendar import isleap\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    month, day, year = date.split('-')\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if year <= 0 or month < 1 or month > 12 or (day < 1):\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day > 30:\n            return False\n    elif month == 2:\n        if isleap(year):\n            if day > 29:\n                return False\n        elif day > 28:\n            return False\n    return True", "import re\nfrom calendar import isleap\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^\\\\d{2}-\\\\d{2}-\\\\d{4}$'\n    if not re.match(pattern, date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month < 1 or month > 12:\n        return False\n    if year <= 0:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif isleap(year):\n        if day < 1 or day > 29:\n            return False\n    elif day < 1 or day > 28:\n        return False\n    return True", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if year <= 0 or month < 1 or month > 12 or (day < 1):\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day > 30:\n                return False\n        elif year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            if day > 29:\n                return False\n        elif day > 28:\n            return False\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if year < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            if day < 1 or day > 29:\n                return False\n        elif day < 1 or day > 28:\n            return False\n    return True", "code\nimport re\nfrom calendar import isleap\n\ndef valid_date(date: str) -> bool:\n    if not date or not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if len(mm) != 2 or len(dd) != 2 or len(yyyy) != 4:\n        return False\n    try:\n        month = int(mm)\n        day = int(dd)\n        year = int(yyyy)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if year < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if isleap(year):\n            if day < 1 or day > 29:\n                return False\n        elif day < 1 or day > 28:\n            return False\n    return True", "import re\nfrom calendar import isleap\n\ndef valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    month, day, year = parts\n    if not month.isdigit() or not day.isdigit() or (not year.isdigit()):\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12 or year <= 0 or (year > 9999):\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif isleap(year):\n        if day < 1 or day > 29:\n            return False\n    elif day < 1 or day > 28:\n        return False\n    return True", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    try:\n        month, day, year = date.split('-')\n        if len(month) != 2 or len(day) != 2 or len(year) != 4:\n            return False\n        month = int(month)\n        day = int(day)\n        year = int(year)\n        if month < 1 or month > 12:\n            return False\n        if year <= 0:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day < 1 or day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day < 1 or day > 30:\n                return False\n        elif month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                if day < 1 or day > 29:\n                    return False\n            elif day < 1 or day > 28:\n                return False\n        return True\n    except ValueError:\n        return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/125", "requirement": "from typing import List\nfrom typing import Union\n\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exist in the text you\n    should split on commas ','. If no commas exist, you should return the number of lowercase letters with even order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25.\n    \n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 1))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 1))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "code\nfrom typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower():\n                if (ord(char) - ord('a')) % 2 == 0:\n                    count += 1\n        return count", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower():\n                if (ord(char) - ord('a')) % 2 == 0:\n                    count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower():\n                if (ord(char) - ord('a')) % 2 == 0:\n                    count += 1\n        return count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.5}}
{"task_id": "HumanEval/127", "requirement": "from typing import Tuple\n\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    a = max(start1, start2)\n    b = min(end1, end2)\n    if a > b:\n        return 'NO'\n    length = b - a + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(math.sqrt(length)) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start\n    if is_prime(length + 1):\n        return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start\n    if is_prime(length + 1):\n        return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a unique value from the range [1, N * N].\n    \n    The task is to find the lexicographically smallest path of length k in the grid. \n    You can start from any cell and move to any of its neighboring cells (sharing an edge). \n    A path of length k means visiting exactly k cells, which can include revisiting the same cell.\n    You must stay within the boundaries of the grid.\n    \n    A path A is lexicographically smaller than a path B if the sequence of values in A is \n    lexicographically smaller than the sequence of values in B. The answer is guaranteed to be unique.\n    \n    Return the sequence of values representing the lexicographically smallest path.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    min_heap = []\n    for i in range(n):\n        for j in range(n):\n            heappush(min_heap, ([grid[i][j]], i, j))\n    while min_heap:\n        path, x, y = heappop(min_heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [grid[nx][ny]]\n                if len(new_path) <= k:\n                    heappush(min_heap, (new_path, nx, ny))\n    return []", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    visited = set()\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heappush(heap, ([grid[i][j]], (i, j), 1))\n    while heap:\n        path, (i, j), length = heappop(heap)\n        if length == k:\n            return path\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < n and 0 <= y < n:\n                new_path = path.copy()\n                new_path.append(grid[x][y])\n                heappush(heap, (new_path, (x, y), length + 1))\n    return []", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    visited = set()\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heappop(heap)\n        if len(path) == k:\n            return path\n        if (tuple(path), x, y) in visited:\n            continue\n        visited.add((tuple(path), x, y))\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path.copy()\n                new_path.append(grid[nx][ny])\n                heappush(heap, (new_path, nx, ny))\n    return []", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    visited = set()\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            path = [grid[i][j]]\n            heappush(heap, (tuple(path), i, j))\n    while heap:\n        current_path, x, y = heappop(heap)\n        if len(current_path) == k:\n            return list(current_path)\n        if (x, y, current_path) in visited:\n            continue\n        visited.add((x, y, current_path))\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = list(current_path)\n                new_path.append(grid[nx][ny])\n                heappush(heap, (tuple(new_path), nx, ny))\n    return []", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_val = float('inf')\n    start_cell = None\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                start_cell = (i, j)\n    if k == 1:\n        return [min_val]\n    heap = []\n    heappush(heap, ([min_val], start_cell[0], start_cell[1]))\n    while heap:\n        path, x, y = heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [grid[nx][ny]]\n                heappush(heap, (new_path, nx, ny))\n    return []", "from typing import List\nfrom collections import deque\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_value = float('inf')\n    start_pos = (0, 0)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_value:\n                min_value = grid[i][j]\n                start_pos = (i, j)\n    result = [min_value]\n    x, y = start_pos\n    for _ in range(k - 1):\n        neighbors = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                neighbors.append((grid[nx][ny], nx, ny))\n        neighbors.sort()\n        min_neighbor = neighbors[0][0]\n        min_x, min_y = (neighbors[0][1], neighbors[0][2])\n        result.append(min_neighbor)\n        x, y = (min_x, min_y)\n    return result", "from typing import List\nfrom collections import deque\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    min_val = float('inf')\n    for row in grid:\n        min_val = min(min_val, min(row))\n    start_positions = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == min_val:\n                start_positions.append((i, j))\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    result = [float('inf')] * k\n    for x, y in start_positions:\n        queue = deque()\n        queue.append((x, y, [grid[x][y]]))\n        while queue:\n            cx, cy, path = queue.popleft()\n            if len(path) == k:\n                if path < result:\n                    result = path\n                continue\n            for dx, dy in directions:\n                nx, ny = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N:\n                    queue.append((nx, ny, path + [grid[nx][ny]]))\n    return result", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def dfs(x, y, path, visited):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                if (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    res = dfs(nx, ny, path + [grid[nx][ny]], visited)\n                    if min_path is None or res < min_path:\n                        min_path = res\n                    visited.remove((nx, ny))\n        return min_path\n    min_result = None\n    for i, j in product(range(n), range(n)):\n        start = grid[i][j]\n        result = dfs(i, j, [start], set([(i, j)]))\n        if min_result is None or result < min_result:\n            min_result = result\n    return min_result", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_val = float('inf')\n    min_cell = None\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                min_cell = (i, j)\n    if k == 1:\n        return [min_val]\n    paths = []\n    heap = []\n    heappush(heap, ([min_val], min_cell[0], min_cell[1]))\n    while heap:\n        path, x, y = heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path.copy()\n                new_path.append(grid[nx][ny])\n                heappush(heap, (new_path, nx, ny))\n    return []", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_value = min((min(row) for row in grid))\n    min_cells = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == min_value]\n    visited = {}\n    heap = []\n    for i, j in min_cells:\n        path = [grid[i][j]]\n        heappush(heap, (tuple(path), i, j, path))\n    while heap:\n        _, i, j, path = heappop(heap)\n        if len(path) == k:\n            return path\n        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            ni, nj = (i + di, j + dj)\n            if 0 <= ni < n and 0 <= nj < n:\n                new_path = path.copy()\n                new_path.append(grid[ni][nj])\n                key = (ni, nj, tuple(new_path))\n                if key not in visited:\n                    visited[key] = True\n                    heappush(heap, (tuple(new_path), ni, nj, new_path))\n    return []"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.9, "original_passk": 0.5}}
{"task_id": "HumanEval/130", "requirement": "from typing import List\n\ndef tri(n: int) -> List[float]:\n    \"\"\"Everyone knows the Fibonacci sequence, studied deeply by mathematicians over the last few centuries. \n    However, the Tribonacci sequence is less known. It is defined by the following rules:\n    \n    - tri(0) = 1\n    - tri(1) = 3\n    - For even n > 1, tri(n) = 1 + n / 2.\n    - For odd n > 1, tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), where tri(n + 1) = 1 + (n + 1) / 2 if n + 1 exceeds the sequence length.\n    \n    You are given a non-negative integer n, and you must return a list of the first n + 1 numbers of the Tribonacci sequence.\n    \n    Examples:\n    tri(2) = [1, 3, 2]\n    tri(4) = [1, 3, 2, 8, 3]\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            sequence.append(sequence[i - 1] + sequence[i - 2] + (1 + (i + 1) / 2))\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    result = []\n    for i in range(n + 1):\n        if i == 0:\n            result.append(1)\n        elif i == 1:\n            result.append(3)\n        elif i % 2 == 0:\n            result.append(1 + i / 2)\n        else:\n            if i + 1 > n:\n                next_val = 1 + (i + 1) / 2\n            else:\n                next_val = result[i + 1]\n            result.append(result[i - 1] + result[i - 2] + next_val)\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > n:\n                next_val = 1 + (i + 1) / 2\n            else:\n                next_val = sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_val)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    sequence = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > n:\n                next_term = 1 + (i + 1) / 2\n            else:\n                next_term = sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_term)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    sequence = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > n:\n                next_val = 1 + (i + 1) / 2\n            else:\n                next_val = sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_val)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    seq = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            seq.append(1 + i / 2)\n        else:\n            if i + 1 > n:\n                tri_n_plus_1 = 1 + (i + 1) / 2\n            else:\n                tri_n_plus_1 = seq[i + 1]\n            seq.append(seq[i - 1] + seq[i - 2] + tri_n_plus_1)\n    return seq[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n < 0:\n        return []\n    sequence = [1.0] if n >= 0 else []\n    if n >= 1:\n        sequence.append(3.0)\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > n:\n                tri_n_plus_1 = 1 + (i + 1) / 2\n            else:\n                tri_n_plus_1 = sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + tri_n_plus_1)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > n:\n                tri_n_plus_1 = 1 + (i + 1) / 2\n            else:\n                tri_n_plus_1 = sequence[i + 1] if i + 1 < len(sequence) else 1 + (i + 1) / 2\n            sequence.append(sequence[i - 1] + sequence[i - 2] + tri_n_plus_1)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    sequence = [0.0] * (n + 1)\n    sequence[0] = 1.0\n    sequence[1] = 3.0\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence[i] = 1 + i / 2\n        elif i - 1 >= 0 and i - 2 >= 0:\n            next_term = 1 + (i + 1) / 2 if i + 1 > n else sequence[i + 1]\n            sequence[i] = sequence[i - 1] + sequence[i - 2] + next_term\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    sequence = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            tri_n_minus_1 = sequence[i - 1]\n            tri_n_minus_2 = sequence[i - 2]\n            if i + 1 <= n:\n                tri_n_plus_1 = 1 + (i + 1) / 2\n            else:\n                tri_n_plus_1 = 1 + (i + 1) / 2\n            sequence.append(tri_n_minus_1 + tri_n_minus_2 + tri_n_plus_1)\n    return sequence[:n + 1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.30000000000000004, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if there exists a valid subsequence of brackets \n    within the string where at least one bracket is nested. A valid subsequence means \n    that for every opening bracket '[' there is a corresponding closing bracket ']', \n    but it does not require the entire string to be a valid bracket sequence.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n            else:\n                stack.append(char)\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n            else:\n                stack.append(char)\n    nested = False\n    temp_stack = []\n    for char in string:\n        if char == '[':\n            temp_stack.append(char)\n        elif char == ']':\n            if temp_stack and temp_stack[-1] == '[':\n                temp_stack.pop()\n                if temp_stack:\n                    nested = True\n                    break\n            else:\n                temp_stack.append(char)\n    return nested"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/134", "requirement": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''", "generated_programs": ["import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    return not txt.rstrip().endswith(last_char)", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) > 1 and txt[-2] != ' ':\n        return False\n    return True", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) > 1 and txt[-2] != ' ':\n        return False\n    return True", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    words = txt.split()\n    if not words:\n        return False\n    last_word = words[-1]\n    return last_word == last_char", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) > 1 and (txt[-2] != ' ' or not txt[:-1].rstrip().endswith(' ')):\n        return False\n    return True", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    words = txt.split()\n    if not words:\n        return False\n    if txt.rstrip().endswith(last_char) and (not txt.rstrip().endswith(words[-1])):\n        return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.6, "original_passk": 1.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(x):\n        return sum((int(d) for d in str(abs(x))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(num):\n        return sum((int(digit) for digit in str(abs(num))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "code\nfrom typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        n = abs(n)\n        return sum((int(digit) for digit in str(n)))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(num):\n        return sum((int(digit) for digit in str(abs(num))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    indexed_nums = [(sum_of_digits(num), i, num) for i, num in enumerate(nums)]\n    indexed_nums.sort()\n    return [num for _, _, num in indexed_nums]", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    indexed_nums = [(sum_of_digits(num), i, num) for i, num in enumerate(nums)]\n    indexed_nums.sort()\n    return [num for _, _, num in indexed_nums]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/147", "requirement": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n    Return the number of unique triples (a[i], a[j], a[k]) in a where i < j < k, \n    and the sum a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example:\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"", "generated_programs": ["from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/148", "requirement": "from typing import Tuple\n\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''", "generated_programs": ["from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return tuple()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2) + 1\n    end = max(idx1, idx2)\n    return tuple(planets[start:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start, end = (min(idx1, idx2), max(idx1, idx2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return tuple()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start = min(index1, index2)\n    end = max(index1, index2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    result = tuple(planets[start + 1:end])\n    return result", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2) + 1\n    end = max(idx1, idx2)\n    return tuple(planets[start:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2) + 1\n    end = max(idx1, idx2)\n    if start >= end:\n        return ()\n    return tuple(planets[start:end])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/151", "requirement": "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are non-negative and odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    If the input list is empty, return 0.\n    '''", "generated_programs": ["from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((num * num for num in lst if num > 0 and num % 2 != 0 and isinstance(num, int)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0))) if lst else 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if any substring of the first word of the same length as the second word is a rotation of the second word. This is checked by seeing if any such substring from the first word appears in the second word concatenated with itself.\n    \n    Examples:\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    len_b = len(b)\n    double_b = b + b\n    for i in range(len(a) - len_b + 1):\n        substring = a[i:i + len_b]\n        if substring in double_b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if len(b) == 0:\n        return True\n    n = len(b)\n    double_b = b + b\n    for i in range(len(a) - n + 1):\n        substring = a[i:i + n]\n        if substring in double_b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    len_b = len(b)\n    doubled_b = b + b\n    for i in range(len(a) - len_b + 1):\n        substring = a[i:i + len_b]\n        if substring in doubled_b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b or len(b) > len(a):\n        return False\n    b_doubled = b + b\n    for i in range(len(a) - len(b) + 1):\n        substring = a[i:i + len(b)]\n        if substring in b_doubled:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    len_b = len(b)\n    concatenated_b = b + b\n    for i in range(len(a) - len_b + 1):\n        substring = a[i:i + len_b]\n        if substring in concatenated_b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b or len(b) > len(a):\n        return False\n    b_concat = b + b\n    for i in range(len(a) - len(b) + 1):\n        substring = a[i:i + len(b)]\n        if substring in b_concat:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    len_b = len(b)\n    doubled_b = b + b\n    for i in range(len(a) - len_b + 1):\n        substring = a[i:i + len_b]\n        if substring in doubled_b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b or len(b) > len(a):\n        return False\n    b_doubled = b + b\n    for i in range(len(a) - len(b) + 1):\n        substring = a[i:i + len(b)]\n        if substring in b_doubled:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if len(b) == 0:\n        return False\n    n = len(b)\n    doubled_b = b + b\n    for i in range(len(a) - n + 1):\n        substring = a[i:i + n]\n        if substring in doubled_b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if len(a) < len(b):\n        return False\n    window = len(b)\n    concatenated_b = b + b\n    for i in range(len(a) - window + 1):\n        substring = a[i:i + window]\n        if substring in concatenated_b:\n            return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.6, "original_passk": 0.8}}
{"task_id": "HumanEval/160", "requirement": "from typing import List\n\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "code\nfrom typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or len(operand) < 2:\n        return 0\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "code\nfrom typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or len(operand) < 2:\n        return 0\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or len(operand) < 2:\n        return 0\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return the even single-digit numbers between a\n    and b, in ascending order. The even single-digit numbers are considered to be 2, 4, 6, and 8.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_digits = [2, 4, 6, 8]\n    return sorted([x for x in even_digits if start <= x <= end])", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    return [num for num in range(start, end + 1) if num in {2, 4, 6, 8}]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_digits = [2, 4, 6, 8]\n    return [num for num in even_digits if start <= num <= end]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    return [x for x in range(start, end + 1) if x in {2, 4, 6, 8}]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_digits = [num for num in range(start, end + 1) if num in {2, 4, 6, 8}]\n    return even_digits", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    return [num for num in range(start, end + 1) if num in {2, 4, 6, 8}]", "code\nfrom typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_digits = [2, 4, 6, 8]\n    result = [x for x in even_digits if start <= x <= end]\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_single_digits = [2, 4, 6, 8]\n    return [num for num in even_single_digits if start <= num <= end]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    even_digits = {2, 4, 6, 8}\n    start, end = (min(a, b), max(a, b))\n    return sorted([x for x in range(start, end + 1) if x in even_digits])", "code\nfrom typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    even_digits = {2, 4, 6, 8}\n    start = min(a, b)\n    end = max(a, b)\n    result = [num for num in range(start, end + 1) if num in even_digits]\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that starts with the supplied string by appending the minimum necessary characters to its end.\n    \n    The algorithm works as follows:\n    - Identify the longest suffix of the input string that is a palindrome.\n    - Append to the string the reverse of the prefix that precedes this palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    for i in range(len(string), -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    for i in range(len(string), -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n):\n        if string[i:] == string[i:][::-1]:\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string + string[::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    for i in range(len(string), -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n - 1, -1, -1):\n        if string[:i + 1] == string[:i + 1][::-1]:\n            return string + string[i + 1:][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n, -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[i:][::-1]\n    return string"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.4, "original_passk": 0.0}}
{"task_id": "HumanEval/32", "requirement": "def find_zero(xs: List[float]) -> float:\n    \"\"\" \n    Finds a zero of the polynomial with coefficients xs using the bisection method.\n    The function assumes that xs has an even number of coefficients and that there is at least one real root within the interval [-100, 100].\n    Only one zero is returned, even if there are multiple.\n    \n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    left = -100\n    right = 100\n    while abs(right - left) > 1e-07:\n        mid = (left + right) / 2\n        if polynomial(mid) * polynomial(left) > 0:\n            left = mid\n        else:\n            right = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    a, b = (-100, 100)\n    while b - a > 1e-07:\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        elif polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100, 100)\n    for _ in range(100):\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100, 100)\n    for _ in range(100):\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        elif polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def poly(x: float) -> float:\n        return sum((c * x ** i for i, c in enumerate(xs)))\n    left, right = (-100.0, 100.0)\n    while right - left > 1e-07:\n        mid = (left + right) / 2\n        if poly(mid) * poly(left) <= 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100, 100)\n    for _ in range(100):\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100, 100)\n    while abs(a - b) > 1e-07:\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    left, right = (-100, 100)\n    tolerance = 1e-06\n    while abs(right - left) > tolerance:\n        mid = (left + right) / 2\n        if polynomial(mid) == 0:\n            return mid\n        elif polynomial(left) * polynomial(mid) < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def poly(x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100, 100)\n    while abs(b - a) > 1e-07:\n        mid = (a + b) / 2\n        if poly(mid) == 0:\n            return mid\n        if poly(a) * poly(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    left, right = (-100, 100)\n    while abs(right - left) > 1e-07:\n        mid = (left + right) / 2\n        if polynomial(mid) == 0:\n            return mid\n        elif polynomial(left) * polynomial(mid) < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["code\nfrom typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    if n % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        return (l_sorted[n // 2 - 1] + l_sorted[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 1:\n        return l_sorted[mid]\n    else:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    if n % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        return (l_sorted[n // 2 - 1] + l_sorted[n // 2]) / 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/59", "requirement": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of the given integer n. \n    It is assumed that n is greater than 1 and is not a prime number itself.\n    The function should iteratively divide n by its smallest factors until the largest prime factor remains.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"", "generated_programs": ["def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        while n % factor == 0:\n            n //= factor\n        factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n = n // factor\n        else:\n            factor += 1\n    return n", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_factor = -1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_prime = -1\n    while n % 2 == 0:\n        largest_prime = 2\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n    if n > 2:\n        largest_prime = n\n    return largest_prime", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_factor = 1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 2:\n        largest_factor = n\n    return largest_factor"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/60", "requirement": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n. If n is negative, the function returns 0.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    >>> sum_to_n(-5)\n    0\n    \"\"\"", "generated_programs": ["def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/65", "requirement": "def circular_shift(x: int, shift: int) -> str:\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift is greater than the number of digits, return digits reversed.\n    If shift is equal to the number of digits, return the digits unchanged.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"", "generated_programs": ["def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift >= n:\n        return digits[::-1]\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    elif shift == n:\n        return digits\n    else:\n        return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    length = len(digits)\n    shift = shift % length\n    if shift == 0:\n        return digits\n    else:\n        return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    elif shift == n:\n        return digits\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    elif shift == n:\n        return digits\n    else:\n        return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    length = len(digits)\n    if shift > length:\n        return digits[::-1]\n    elif shift == length:\n        return digits\n    else:\n        shift = shift % length\n        return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    elif shift == n:\n        return s\n    else:\n        shift = shift % n\n        return s[-shift:] + s[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    num_digits = len(digits)\n    if shift > num_digits:\n        return digits[::-1]\n    elif shift == num_digits:\n        return digits\n    else:\n        shift = shift % num_digits\n        return digits[-shift:] + digits[:-shift]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    '''\n    Write a function that takes an integer a and returns True \n    if a is a perfect cube of some integer number. \n    For negative inputs, the function should correctly compute the cube root \n    by negating the cube root of the absolute value of the input.\n    The function uses rounding to determine if the cube root is an integer \n    before verifying if cubing that integer results in the original number.\n    Note: you may assume the input is always a valid integer.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3))\n    if a < 0:\n        cube_root = -cube_root\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3))\n    if a < 0:\n        cube_root = -cube_root\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = -round(abs(a) ** (1 / 3))\n    else:\n        cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = -round(abs(a) ** (1 / 3))\n    else:\n        cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3)) if a != 0 else 0\n    if a < 0:\n        cube_root *= -1\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = -round(abs(a) ** (1 / 3))\n    else:\n        cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = -round(abs(a) ** (1 / 3))\n    else:\n        cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = -round(abs(a) ** (1 / 3))\n    else:\n        cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = math.pow(abs(a), 1 / 3)\n    rounded_root = round(cube_root)\n    if rounded_root ** 3 == abs(a):\n        return a == rounded_root ** 3 or a == -rounded_root ** 3\n    return False", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = -round(abs(a) ** (1 / 3)) if round(abs(a) ** (1 / 3)) ** 3 == abs(a) else -math.ceil(abs(a) ** (1 / 3))\n    else:\n        cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1. Numbers that both start and end\n    with 1 should be counted only once.\n    \n    Examples:\n    >>> starts_one_ends(1)\n    1\n    >>> starts_one_ends(2)\n    18\n    >>> starts_one_ends(3)\n    180\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    both_start_and_end_with_one = 10 ** (n - 2)\n    return start_with_one + end_with_one - both_start_and_end_with_one", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_numbers = 10 ** (n - 1)\n    starts_with_one = total_numbers\n    ends_with_one = total_numbers\n    starts_and_ends_with_one = 10 ** (n - 2)\n    return starts_with_one + ends_with_one - starts_and_ends_with_one", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    count_start = 1 * 10 ** (n - 1)\n    count_end = 1 * 10 ** (n - 1)\n    count_both = 1 * 10 ** (n - 2) if n > 1 else 0\n    return count_start + count_end - count_both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_numbers = 9 * 10 ** (n - 1)\n    starts_with_one = 1 * 10 ** (n - 1)\n    ends_with_one = 9 * 10 ** (n - 2)\n    both = 1 * 10 ** (n - 2)\n    return starts_with_one + ends_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_numbers = 9 * 10 ** (n - 1)\n    starts_with_one = 1 * 10 ** (n - 1)\n    ends_with_one = 9 * 10 ** (n - 2)\n    both = 1 * 10 ** (n - 2)\n    return starts_with_one + ends_with_one - both", "code\n\ndef starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_numbers = 10 ** n\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_numbers = 9 * 10 ** (n - 1)\n    start_with_one = 1 * 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 2)\n    both_start_and_end_with_one = 1 * 10 ** (n - 2)\n    return start_with_one + end_with_one - both_start_and_end_with_one", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total = 0\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    both_start_end_with_one = 10 ** (n - 2)\n    total = start_with_one + end_with_one - both_start_end_with_one\n    return total", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total = 0\n    start_with_one = 1 * 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 2) * 1\n    both = 1 * 10 ** (n - 2) * 1\n    total = start_with_one + end_with_one - both\n    return total", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total = 0\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    start_and_end_with_1 = 10 ** (n - 2)\n    total = start_with_1 + end_with_1 - start_and_end_with_1\n    return total"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    Each letter in the alphabet should be shifted forward by four positions.\n    Uppercase and lowercase letters should be handled appropriately, maintaining their case.\n    Non-alphabetic characters should remain unchanged.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    encrypt('HelloWorld') returns 'LippsAsvph'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if char.isalpha():\n            shift = 4\n            if char.islower():\n                base = ord('a')\n            else:\n                base = ord('A')\n            result.append(chr((ord(char) - base + shift) % 26 + base))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        elif 'A' <= char <= 'Z':\n            new_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "import string\n\ndef encrypt(s: str) -> str:\n\n    def shift_char(c, shift, base):\n        return chr((ord(c) - base + shift) % 26 + base)\n    result = []\n    for c in s:\n        if c in string.ascii_lowercase:\n            result.append(shift_char(c, 4, ord('a')))\n        elif c in string.ascii_uppercase:\n            result.append(shift_char(c, 4, ord('A')))\n        else:\n            result.append(c)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        elif 'A' <= char <= 'Z':\n            shifted = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "code\n\ndef encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        elif 'A' <= char <= 'Z':\n            shifted = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted_char)\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I \" (note the space).\n    Sentences are delimited by '.', '?' or '!', and consecutive delimiters should be treated\n    as a single delimiter. Leading and trailing spaces around sentences should be ignored.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"", "generated_programs": ["import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    boredom_count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    boredom_count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]\\\\s*', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    boredom_count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]\\\\s*', S)\n    count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]\\\\s*', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]\\\\s*', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/92", "requirement": "def any_int(x: int, y: int, z: int) -> bool:\n    '''\n    Create a function that takes 3 numbers as input.\n    The function should first check if all inputs are integers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false if any of the inputs are not integers or if no number is equal to the sum of the other two.\n    \n    Examples\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n    '''", "generated_programs": ["def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(num, int) for num in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(num, int) for num in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(n, int) for n in [x, y, z])):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(num, int) for num in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(num, int) for num in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message and encodes it by swapping the case of all letters \n    and then replacing each vowel with the letter that appears two places ahead of it in the English alphabet, \n    considering only lowercase vowels for the initial shift. Non-alphabetic characters remain unchanged.\n    \n    Specifically, after swapping the case of all letters:\n    - If a character is a lowercase vowel ('a', 'e', 'i', 'o', 'u'), it is shifted two places ahead in the alphabet and remains lowercase.\n    - If a character is an uppercase vowel ('A', 'E', 'I', 'O', 'U'), it is first converted to lowercase, shifted two places ahead, and then converted back to uppercase.\n    - All other alphabetic characters remain in their swapped case without modification.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    result = []\n    for char in message:\n        if char.isalpha():\n            swapped_char = char.swapcase()\n            if swapped_char.lower() in vowels:\n                shifted_char = chr((ord(swapped_char.lower()) - ord('a') + 2) % 26 + ord('a'))\n                if swapped_char.isupper():\n                    result.append(shifted_char.upper())\n                else:\n                    result.append(shifted_char)\n            else:\n                result.append(swapped_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    result = []\n    for char in message:\n        if char.isalpha():\n            swapped_char = char.swapcase()\n            if swapped_char.lower() in vowels:\n                shifted_char = chr(ord(swapped_char.lower()) + 2)\n                if shifted_char > 'z':\n                    shifted_char = chr(ord(shifted_char) - 26)\n                if swapped_char.isupper():\n                    shifted_char = shifted_char.upper()\n                result.append(shifted_char)\n            else:\n                result.append(swapped_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    result = []\n    for char in message:\n        if char.isalpha():\n            swapped_char = char.swapcase()\n            if swapped_char.lower() in vowels:\n                if swapped_char.islower():\n                    shifted_char = chr((ord(swapped_char) - ord('a') + 2) % 26 + ord('a'))\n                else:\n                    shifted_char = chr((ord(swapped_char.lower()) - ord('a') + 2) % 26 + ord('a')).upper()\n                result.append(shifted_char)\n            else:\n                result.append(swapped_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = {'a', 'e', 'i', 'o', 'u'}\n        if c.lower() in vowels:\n            if c.islower():\n                return chr((ord(c) - ord('a') + 2) % 26 + ord('a'))\n            else:\n                shifted = chr((ord(c.lower()) - ord('a') + 2) % 26 + ord('a'))\n                return shifted.upper()\n        return c\n    encoded_message = []\n    for char in message:\n        swapped_case = char.swapcase()\n        shifted_char = shift_vowel(swapped_case)\n        encoded_message.append(shifted_char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels_lower = {'a', 'e', 'i', 'o', 'u'}\n    vowels_upper = {'A', 'E', 'I', 'O', 'U'}\n    result = []\n    for char in message:\n        if char in vowels_lower:\n            new_char = chr((ord(char) - ord('a') + 2) % 26 + ord('a'))\n            result.append(new_char)\n        elif char in vowels_upper:\n            new_char = chr((ord(char.lower()) - ord('a') + 2) % 26 + ord('a'))\n            result.append(new_char.upper())\n        elif char.isalpha():\n            result.append(char.swapcase())\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels_lower = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    vowels_upper = {'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            if char in vowels_lower:\n                encoded_message.append(vowels_lower[char])\n            elif char in vowels_upper:\n                encoded_message.append(vowels_upper[char])\n            elif char.islower():\n                encoded_message.append(char.upper())\n            else:\n                encoded_message.append(char.lower())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels_lower = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    vowels_upper = {'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in message:\n        if char in vowels_lower:\n            encoded_message.append(vowels_lower[char])\n        elif char in vowels_upper:\n            encoded_message.append(vowels_upper[char])\n        elif char.isalpha():\n            if char.islower():\n                encoded_message.append(char.upper())\n            else:\n                encoded_message.append(char.lower())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    shifted_vowel_mapping = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    encoded_message = []\n    for char in message:\n        if char.lower() in vowels:\n            if char.isupper():\n                shifted_char = shifted_vowel_mapping[char.lower()].upper()\n            else:\n                shifted_char = shifted_vowel_mapping[char]\n            encoded_message.append(shifted_char)\n        elif char.isalpha():\n            if char.isupper():\n                encoded_message.append(char.lower())\n            else:\n                encoded_message.append(char.upper())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels_lower = {'a', 'e', 'i', 'o', 'u'}\n    vowels_upper = {'A', 'E', 'I', 'O', 'U'}\n    encoded_message = []\n    for char in message:\n        if char in vowels_upper:\n            lower_char = char.lower()\n            shifted_char = chr((ord(lower_char) - ord('a') + 2) % 26 + ord('a'))\n            encoded_message.append(shifted_char.upper())\n        elif char in vowels_lower:\n            shifted_char = chr((ord(char) - ord('a') + 2) % 26 + ord('a'))\n            encoded_message.append(shifted_char)\n        elif char.isalpha():\n            encoded_message.append(char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels_lower = {'a', 'e', 'i', 'o', 'u'}\n    vowels_upper = {'A', 'E', 'I', 'O', 'U'}\n    result = []\n    for char in message:\n        if char in vowels_lower:\n            new_char = chr((ord(char) - ord('a') + 2) % 26 + ord('a'))\n            result.append(new_char)\n        elif char in vowels_upper:\n            lower_char = char.lower()\n            new_char = chr((ord(lower_char) - ord('a') + 2) % 26 + ord('a'))\n            result.append(new_char.upper())\n        elif char.isalpha():\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n        else:\n            result.append(char)\n    return ''.join(result)"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.4, "original_passk": 0.0}}
{"task_id": "HumanEval/94", "requirement": "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n    If there are no prime numbers in the list, the function should raise a ValueError.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    max_prime = max(primes)\n    return sum(map(int, str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers found in the list.')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list.')\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum((int(digit) for digit in str(n)))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum_of_digits(largest_prime)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/95", "requirement": "from typing import Dict\n\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"", "generated_programs": ["from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key == key.lower() for key in keys))\n    upper_case = all((key == key.upper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key.islower() for key in keys))\n    upper_case = all((key.isupper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key == key.lower() for key in keys))\n    upper_case = all((key == key.upper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(d: Dict[Any, Any]) -> bool:\n    if not d:\n        return False\n    keys = [key for key in d.keys() if isinstance(key, str)]\n    if not keys:\n        return False\n    lower_case = all((key.islower() for key in keys))\n    upper_case = all((key.isupper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dct: Dict[Any, Any]) -> bool:\n    if not dct:\n        return False\n    keys = list(dct.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key.islower() for key in keys))\n    upper_case = all((key.isupper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key.islower() for key in keys))\n    upper_case = all((key.isupper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    if all((key.islower() for key in keys)):\n        return True\n    if all((key.isupper() for key in keys)):\n        return True\n    return False", "from typing import Dict, Any\n\ndef check_dict_case(d: Dict[Any, Any]) -> bool:\n    if not d:\n        return False\n    keys = list(d.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key.islower() for key in keys))\n    upper_case = all((key.isupper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    first_key_case = next(iter(keys)).islower()\n    for key in keys:\n        if key.islower() != first_key_case:\n            return False\n    return True", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    first_key = keys[0]\n    if not isinstance(first_key, str):\n        return False\n    is_lower = first_key.islower()\n    if is_lower:\n        return all((isinstance(key, str) and key.islower() for key in keys))\n    is_upper = first_key.isupper()\n    if is_upper:\n        return all((isinstance(key, str) and key.isupper() for key in keys))\n    return False"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.7, "original_passk": 0.8}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has exactly n stones.\n    Each subsequent level has:\n        - the next odd number of stones if n is odd.\n        - the next even number of stones if n is even.\n    Return the number of stones in each level in a list, where the element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        current += 2 if current % 2 == 0 else 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        current += 2 if current % 2 != 0 else 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        current = current + 2 if current % 2 != 0 else current + 1\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    for i in range(1, n):\n        if n % 2 == 1:\n            pile.append(pile[-1] + 2)\n        else:\n            pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    current = n\n    for _ in range(1, n):\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 2\n        pile.append(current)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 1\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        if current_stones % 2 == 1:\n            current_stones += 2\n        else:\n            current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    for i in range(1, n):\n        if n % 2 == 1:\n            pile.append(pile[i - 1] + 2)\n        else:\n            pile.append(pile[i - 1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        if current_stones % 2 == 1:\n            current_stones += 2\n        else:\n            current_stones += 2\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements whose sum of digits (considering the sign of the entire number) is greater than 0.\n    If a number is negative, the sum of its digits should be negative as well:\n    e.g., -123 has a sum of digits -6.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(n):\n        return sum((int(digit) for digit in str(abs(n)))) * (1 if n >= 0 else -1)\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        sign = -1 if n < 0 else 1\n        return sign * sum((int(d) for d in str(abs(n))))\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_digits(n: int) -> int:\n        sign = -1 if n < 0 else 1\n        return sign * sum((int(digit) for digit in str(abs(n))))\n    return sum((1 for num in arr if sum_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_digits(n):\n        sign = -1 if n < 0 else 1\n        return sign * sum((int(d) for d in str(abs(n))))\n    return sum((1 for num in arr if sum_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_digits(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n)))) * (1 if n >= 0 else -1)\n    return sum((1 for num in arr if sum_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_digits(num):\n        sign = -1 if num < 0 else 1\n        return sign * sum((int(digit) for digit in str(abs(num))))\n    return sum((1 for num in arr if sum_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_digits(n: int) -> int:\n        sign = -1 if n < 0 else 1\n        return sign * sum((int(digit) for digit in str(abs(n))))\n    return sum((1 for num in arr if sum_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_digits(n: int) -> int:\n        sign = 1 if n >= 0 else -1\n        return sign * sum((int(d) for d in str(abs(n))))\n    return sum((1 for num in arr if sum_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_digits(n: int) -> int:\n        sign = -1 if n < 0 else 1\n        return sign * sum((int(digit) for digit in str(abs(n))))\n    return sum((1 for num in arr if sum_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_digits(n: int) -> int:\n        sign = -1 if n < 0 else 1\n        return sign * sum((int(d) for d in str(abs(n))))\n    return sum((1 for num in arr if sum_digits(num) > 0))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.9}}
{"task_id": "HumanEval/109", "requirement": "def move_one_ball(arr: List[int]) -> bool:\n    \"\"\"Determine if it is possible to sort the array in non-decreasing order by performing\n    any number of right shift operations. A right shift operation moves each element of the\n    array one position to the right, with the last element moving to the first position.\n    \n    The array can be sorted using right shifts if there is at most one place where a larger number\n    is followed by a smaller number (considering the array circularly). If the array meets this\n    condition, return True; otherwise, return False. An empty array is considered sorted, so return True.\n\n    Note: The array is guaranteed to contain unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2]) ==> True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2]) ==> False\n    Explanation: It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n    return count <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] > arr[(i + 1) % len(arr)]:\n            count += 1\n            if count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] > arr[(i + 1) % len(arr)]:\n            count += 1\n            if count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] > arr[(i + 1) % len(arr)]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] > arr[(i + 1) % len(arr)]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n            if count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] > arr[(i + 1) % len(arr)]:\n            count += 1\n            if count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/110", "requirement": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform exchanges of elements\n    between them to make lst1 a list of only even numbers.\n    Multiple exchanges are allowed, and the goal is to ensure all elements of lst1 are even.\n    If it is possible to exchange elements between lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if odd_count1 <= even_count2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count1 = sum((1 for num in lst1 if num % 2 != 0))\n    odd_count2 = sum((1 for num in lst2 if num % 2 != 0))\n    return 'YES' if odd_count1 <= odd_count2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if odd_count1 <= even_count2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    lst1_odds = sum((1 for x in lst1 if x % 2 != 0))\n    lst2_evens = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if lst1_odds <= lst2_evens else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if odd_count_lst1 <= even_count_lst2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if odd_in_lst1 <= even_in_lst2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    count_odd_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    count_even_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    if count_odd_lst1 <= count_even_lst2:\n        return 'YES'\n    else:\n        return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    if odd_in_lst1 <= even_in_lst2:\n        return 'YES'\n    else:\n        return 'NO'"], "result": {"repaired_passk": 0.09999999999999998, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/115", "requirement": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the total number of times you need to lower the buckets, considering each well individually.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for row in grid:\n        water = sum(row)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for row in grid:\n        water = sum(row)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for row in grid:\n        water = sum(row)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for row in grid:\n        water = sum(row)\n        if water > 0:\n            total_buckets += (water + capacity - 1) // capacity\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_trips = 0\n    for well in grid:\n        water_units = sum(well)\n        if water_units == 0:\n            continue\n        trips = (water_units + capacity - 1) // capacity\n        total_trips += trips\n    return total_trips", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for row in grid:\n        water_units = sum(row)\n        if water_units == 0:\n            continue\n        buckets = (water_units + capacity - 1) // capacity\n        total_buckets += buckets\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_lowers = 0\n    for row in grid:\n        water_units = sum(row)\n        if water_units == 0:\n            continue\n        full_buckets = water_units // capacity\n        remainder = water_units % capacity\n        total_lowers += full_buckets\n        if remainder > 0:\n            total_lowers += 1\n    return total_lowers"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of integers. Non-negative integers should be sorted according to the number of ones in their binary representation in ascending order. For non-negative integers with the same number of ones, sort them based on their decimal value. Negative integers should be sorted in ascending order without considering their binary representation.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1') if n >= 0 else 0\n    return sorted(arr, key=lambda x: (count_ones(x), x) if x >= 0 else x)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1') if n >= 0 else 0\n    return sorted(arr, key=lambda x: (x < 0, count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1') if n >= 0 else 0\n    return sorted(arr, key=lambda x: (count_ones(x), x) if x >= 0 else x)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n\n    def sort_key(n):\n        if n >= 0:\n            return (count_ones(n), n)\n        else:\n            return (float('-inf'), n)\n    return sorted(arr, key=sort_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n\n    def sort_key(x):\n        if x < 0:\n            return (0, x)\n        else:\n            return (1, count_ones(x), x)\n    return sorted(arr, key=sort_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1') if n >= 0 else 0\n\n    def sort_key(n):\n        if n < 0:\n            return (0, n)\n        else:\n            return (count_ones(n), n)\n    return sorted(arr, key=sort_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(n).count('1')\n\n    def sort_key(n: int):\n        if n < 0:\n            return (0, n)\n        else:\n            return (1, count_ones(n), n)\n    return sorted(arr, key=sort_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(n).count('1')\n\n    def sort_key(n: int):\n        if n >= 0:\n            return (count_ones(n), n)\n        else:\n            return (float('-inf'), n)\n    return sorted(arr, key=sort_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1') if n >= 0 else 0\n\n    def sort_key(n):\n        if n >= 0:\n            return (count_ones(n), n)\n        else:\n            return (float('-inf'), n)\n    return sorted(arr, key=sort_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    sorted_non_neg = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    sorted_neg = sorted([x for x in arr if x < 0])\n    return sorted_neg + sorted_non_neg"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The date should be in the format 'mm-dd-yyyy' with leading zeros for single-digit months and days (e.g., '01-01-2000').\n    3. The number of days is not less than 1 or higher than 31 days for months 1, 3, 5, 7, 8, 10, 12. The number of days is not less than 1 or higher than 30 days for months 4, 6, 9, 11. The number of days is not less than 1 or higher than 29 for the month 2 in a leap year, and 28 in a non-leap year.\n    4. The months should not be less than 1 or higher than 12.\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        datetime(year, month, day)\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        datetime.strptime(date, '%m-%d-%Y')\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        datetime(year=year, month=month, day=day)\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date or not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if day < 1 or day > 31:\n            return False\n        if month in {4, 6, 9, 11} and day > 30:\n            return False\n        if month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                if day > 29:\n                    return False\n            elif day > 28:\n                return False\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date or not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if day < 1 or day > 31:\n            return False\n        if month in {4, 6, 9, 11} and day > 30:\n            return False\n        if month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                if day > 29:\n                    return False\n            elif day > 28:\n                return False\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if day < 1 or day > 31:\n            return False\n        if month in {4, 6, 9, 11} and day > 30:\n            return False\n        if month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                if day > 29:\n                    return False\n            elif day > 28:\n                return False\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if day < 1 or day > 31:\n            return False\n        if month in {4, 6, 9, 11} and day > 30:\n            return False\n        if month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                if day > 29:\n                    return False\n            elif day > 28:\n                return False\n        return True\n    except ValueError:\n        return False", "import re\nfrom calendar import isleap\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^\\\\d{2}-\\\\d{2}-\\\\d{4}$'\n    if not re.match(pattern, date):\n        return False\n    mm, dd, yyyy = map(int, date.split('-'))\n    if mm < 1 or mm > 12:\n        return False\n    if mm in {1, 3, 5, 7, 8, 10, 12}:\n        if dd < 1 or dd > 31:\n            return False\n    elif mm in {4, 6, 9, 11}:\n        if dd < 1 or dd > 30:\n            return False\n    elif isleap(yyyy):\n        if dd < 1 or dd > 29:\n            return False\n    elif dd < 1 or dd > 28:\n        return False\n    return True", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if day < 1:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day > 30:\n                return False\n        elif year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            if day > 29:\n                return False\n        elif day > 28:\n            return False\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day < 1 or day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day < 1 or day > 30:\n                return False\n        elif year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            if day < 1 or day > 29:\n                return False\n        elif day < 1 or day > 28:\n            return False\n        return True\n    except ValueError:\n        return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/125", "requirement": "from typing import List\nfrom typing import Union\n\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exist in the text you\n    should split on commas ','. If no commas exist, you should return the number of lowercase letters with even order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25.\n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 == 1))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 1))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if 'a' <= char <= 'z':\n                if (ord(char) - ord('a')) % 2 == 0:\n                    count += 1\n        return count", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        lowercase_letters = [char for char in txt if char.islower()]\n        even_letters = [char for char in lowercase_letters if (ord(char) - ord('a')) % 2 == 0]\n        return len(even_letters)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.5}}
{"task_id": "HumanEval/127", "requirement": "from typing import Tuple\n\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    if is_prime(length):\n        return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    if length < 0:\n        return 'NO'\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start\n    if is_prime(length + 1):\n        return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    lower_bound = max(start1, start2)\n    upper_bound = min(end1, end2)\n    if lower_bound > upper_bound:\n        return 'NO'\n    length = upper_bound - lower_bound + 1\n    if is_prime(length):\n        return 'YES'\n    return 'NO'"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a unique value from the range [1, N * N].\n    \n    The task is to find the lexicographically smallest path of length k in the grid. \n    You can start from any cell and move to any of its neighboring cells (sharing an edge).\n    A path of length k means visiting exactly k cells, which can include revisiting cells.\n    You cannot move off the grid.\n    \n    A path A is considered lexicographically smaller than a path B if the sequence of values\n    in path A is lexicographically smaller than the sequence of values in path B when compared\n    element-wise.\n    \n    It is guaranteed that there is a unique lexicographically smallest path.\n    \n    Return the sequence of values on the cells that form the lexicographically smallest path.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_heap = []\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    for i in range(n):\n        for j in range(n):\n            heappush(min_heap, ([grid[i][j]], i, j))\n    while min_heap:\n        path, x, y = heappop(min_heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                heappush(min_heap, (path + [grid[nx][ny]], nx, ny))\n    return []", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    min_val = float('inf')\n    start_pos = (0, 0)\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                start_pos = (i, j)\n    path = [min_val]\n    current_pos = start_pos\n    for _ in range(1, k):\n        next_pos = None\n        next_val = float('inf')\n        i, j = current_pos\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            x, y = (i + dx, j + dy)\n            if 0 <= x < N and 0 <= y < N and (grid[x][y] < next_val):\n                next_val = grid[x][y]\n                next_pos = (x, y)\n        path.append(next_val)\n        current_pos = next_pos\n    return path", "from typing import List\nfrom collections import deque\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_val = float('inf')\n    start_pos = None\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                start_pos = (i, j)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = deque()\n    queue.append((start_pos[0], start_pos[1], [grid[start_pos[0]][start_pos[1]]]))\n    while queue:\n        i, j, path = queue.popleft()\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            x, y = (i + dx, j + dy)\n            if 0 <= x < n and 0 <= y < n:\n                new_path = path + [grid[x][y]]\n                queue.append((x, y, new_path))", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    visited = set()\n    min_heap = []\n    for i in range(n):\n        for j in range(n):\n            path = [grid[i][j]]\n            heappush(min_heap, (tuple(path), i, j, path))\n    while min_heap:\n        _, x, y, current_path = heappop(min_heap)\n        if len(current_path) == k:\n            return current_path\n        if (x, y, tuple(current_path)) in visited:\n            continue\n        visited.add((x, y, tuple(current_path)))\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = current_path + [grid[nx][ny]]\n                heappush(min_heap, (tuple(new_path), nx, ny, new_path))", "from typing import List\nfrom collections import deque\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_val = float('inf')\n    min_pos = (-1, -1)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                min_pos = (i, j)\n    res = [min_val]\n    current = min_pos\n    for _ in range(k - 1):\n        neighbors = []\n        i, j = current\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = (i + di, j + dj)\n            if 0 <= ni < n and 0 <= nj < n:\n                neighbors.append((grid[ni][nj], ni, nj))\n        neighbors.sort()\n        min_neighbor = neighbors[0]\n        res.append(min_neighbor[0])\n        current = (min_neighbor[1], min_neighbor[2])\n    return res", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                heappush(heap, (path + [grid[nx][ny]], nx, ny))\n    return []", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_val = float('inf')\n    start_pos = (-1, -1)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                start_pos = (i, j)\n    x, y = start_pos\n    path = [grid[x][y]]\n    for _ in range(k - 1):\n        neighbors = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                heappush(neighbors, (grid[nx][ny], nx, ny))\n        if neighbors:\n            val, nx, ny = heappop(neighbors)\n            path.append(val)\n            x, y = (nx, ny)\n    return path", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    visited = set()\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heappush(pq, (grid[i][j], [grid[i][j]], i, j))\n    while pq:\n        val, path, x, y = heappop(pq)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [grid[nx][ny]]\n                if (nx, ny, tuple(new_path)) not in visited:\n                    visited.add((nx, ny, tuple(new_path)))\n                    heappush(pq, (new_path[0], new_path, nx, ny))\n    return []", "from typing import List\nfrom collections import deque\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    min_val = float('inf')\n    start_positions = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                start_positions = [(i, j)]\n            elif grid[i][j] == min_val:\n                start_positions.append((i, j))\n    min_path = [min_val] * k\n    visited = set()\n    queue = deque([(start_positions[0][0], start_positions[0][1], [min_val])])\n    while queue:\n        i, j, path = queue.popleft()\n        if len(path) == k:\n            if path < min_path:\n                min_path = path\n            continue\n        for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= ni < N and 0 <= nj < N:\n                next_path = path + [grid[ni][nj]]\n                if tuple(next_path) not in visited:\n                    visited.add(tuple(next_path))\n                    queue.append((ni, nj, next_path))\n    return min_path", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    min_val = float('inf')\n    start_positions = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                start_positions = [(i, j)]\n            elif grid[i][j] == min_val:\n                start_positions.append((i, j))\n    min_path = None\n    for start in start_positions:\n        i, j = start\n        visited = [(i, j)]\n        current_path = [grid[i][j]]\n        queue = []\n        heappush(queue, (tuple(current_path), i, j, 1, visited))\n        while queue:\n            path_tuple, row, col, steps, path_visited = heappop(queue)\n            if steps == k:\n                if min_path is None or path_tuple < tuple(min_path):\n                    min_path = list(path_tuple)\n                continue\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_row, new_col = (row + dx, col + dy)\n                if 0 <= new_row < N and 0 <= new_col < N:\n                    new_path = list(path_tuple) + [grid[new_row][new_col]]\n                    heappush(queue, (tuple(new_path), new_row, new_col, steps + 1, path_visited + [(new_row, new_col)]))\n    return min_path"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.5}}
{"task_id": "HumanEval/130", "requirement": "from typing import List\n\ndef tri(n: int) -> List[float]:\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(0) = [1], if n is 0.\n    tri(1) = 3, if n is 1.\n    tri(n) = 1 + n / 2, if n is even and n > 1.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd and n + 1 is within bounds.\n    If n + 1 is out of bounds, tri(n + 1) is calculated as 1 + (n + 1) / 2.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 1 + (4 / 2) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    res = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            res.append(1 + i / 2)\n        else:\n            tri_n_plus_1 = 1 + (i + 1) / 2 if i + 1 > n else res[i + 1]\n            res.append(res[i - 1] + res[i - 2] + tri_n_plus_1)\n    return res", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    sequence = [1.0, 3.0]\n    if n == 1:\n        return sequence\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > n:\n                next_term = 1 + (i + 1) / 2\n            else:\n                next_term = sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_term)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    elif n == 1:\n        return [1.0, 3.0]\n    result = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result.append(1.0 + i / 2)\n        else:\n            tri_n_plus_1 = 1.0 + (i + 1) / 2 if i + 1 > n else result[i + 1]\n            result.append(result[i - 1] + result[i - 2] + tri_n_plus_1)\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    result = [0.0] * (n + 1)\n    result[0] = 1.0\n    result[1] = 3.0\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result[i] = 1 + i / 2\n        elif i + 1 <= n:\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1]\n        else:\n            result[i] = result[i - 1] + result[i - 2] + (1 + (i + 1) / 2)\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    sequence = [0.0] * (n + 1)\n    sequence[0] = 1.0\n    if n >= 1:\n        sequence[1] = 3.0\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence[i] = 1 + i / 2\n        elif i + 1 <= n:\n            sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1]\n        else:\n            sequence[i] = sequence[i - 1] + sequence[i - 2] + (1 + (i + 1) / 2)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    sequence = [0.0] * (n + 1)\n    sequence[0] = 1.0\n    if n >= 1:\n        sequence[1] = 3.0\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence[i] = 1 + i / 2\n        else:\n            if i + 1 > n:\n                tri_plus_1 = 1 + (i + 1) / 2\n            else:\n                tri_plus_1 = sequence[i + 1]\n            sequence[i] = sequence[i - 1] + sequence[i - 2] + tri_plus_1\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    sequence = [0.0] * (n + 1)\n    sequence[0] = 1.0\n    if n >= 1:\n        sequence[1] = 3.0\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence[i] = 1 + i / 2\n        else:\n            if i + 1 <= n:\n                tri_n_plus_1 = sequence[i + 1]\n            else:\n                tri_n_plus_1 = 1 + (i + 1) / 2\n            sequence[i] = sequence[i - 1] + sequence[i - 2] + tri_n_plus_1\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    result = [0.0] * (n + 1)\n    result[0] = 1.0\n    if n >= 1:\n        result[1] = 3.0\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result[i] = 1 + i / 2\n        else:\n            if i + 1 > n:\n                tri_plus_1 = 1 + (i + 1) / 2\n            else:\n                tri_plus_1 = result[i + 1]\n            result[i] = result[i - 1] + result[i - 2] + tri_plus_1\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    seq = [0.0] * (n + 1)\n    seq[0] = 1.0\n    if n >= 1:\n        seq[1] = 3.0\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            seq[i] = 1 + i / 2\n        elif i + 1 <= n:\n            seq[i] = seq[i - 1] + seq[i - 2] + seq[i + 1]\n        else:\n            seq[i] = seq[i - 1] + seq[i - 2] + (1 + (i + 1) / 2)\n    return seq", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    if n == 1:\n        return [1.0, 3.0]\n    result = [0.0] * (n + 1)\n    result[0] = 1.0\n    result[1] = 3.0\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result[i] = 1 + i / 2\n        elif i + 1 <= n:\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1]\n        else:\n            result[i] = result[i - 1] + result[i - 2] + (1 + (i + 1) / 2)\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there exists a valid subsequence of brackets \n    within the string that contains at least one nested bracket pair. A valid subsequence means \n    that there is at least one pair of matching opening and closing brackets, and a nested bracket pair \n    is defined as one bracket being enclosed within another, such as in '[[]]'.\n\n    The function should not require the entire string to be a valid sequence of brackets; it only needs \n    to find at least one valid subsequence with nested brackets.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    has_nested = True\n    return has_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                if len(stack) >= 2 and stack[-2] == '[':\n                    return True\n                stack.pop()\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                if stack[-1] == '[':\n                    stack.pop()\n                    if stack and stack[-1] == '[':\n                        return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            if len(stack) >= 2 and stack[-2] == '[' and (stack[-1] == '['):\n                return True\n            stack.pop()\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                if len(stack) >= 2 and stack[-1] == '[':\n                    return True\n                stack.pop()\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            if stack[-1] == '[':\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n            else:\n                stack.append(char)\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                if len(stack) >= 2 and stack[-1] == '[' and (stack[-2] == '['):\n                    return True\n                stack.pop()\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/134", "requirement": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''", "generated_programs": ["def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if last_char == ' ':\n        return False\n    return last_char.isalpha() and (len(txt) == 1 or txt[-2] == ' ')", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if last_char == ' ':\n        return False\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt.split()) == 0:\n        return True\n    last_word = txt.split()[-1]\n    return last_char != last_word[-1] or len(last_word) == 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(num):\n        return sum((int(digit) for digit in str(abs(num))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "code\nfrom typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(num: int) -> int:\n        return sum((int(digit) for digit in str(abs(num))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(d) for d in str(abs(n))))\n    indexed_nums = [(i, num) for i, num in enumerate(nums)]\n    sorted_nums = sorted(indexed_nums, key=lambda x: (digit_sum(x[1]), x[0]))\n    return [num for _, num in sorted_nums]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/147", "requirement": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n    Return the number of unique triples (a[i], a[j], a[k]) in a where i < j < k, \n    and the sum a[i] + a[j] + a[k] is divisible by 3.\n\n    Example:\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"", "generated_programs": ["from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(trio) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/148", "requirement": "from typing import Tuple\n\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''", "generated_programs": ["from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2) + 1\n    end = max(idx1, idx2)\n    return tuple(planets[start:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2) + 1\n    end = max(idx1, idx2)\n    return tuple(planets[start:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return tuple()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2) + 1\n    end = max(idx1, idx2)\n    return tuple(planets[start:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    if idx1 < idx2:\n        return tuple(planets[idx1 + 1:idx2])\n    else:\n        return tuple(planets[idx2 + 1:idx1])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return tuple()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        return tuple(planets[index1 + 1:index2])\n    else:\n        return tuple(planets[index2 + 1:index1])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return tuple()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    if idx1 < idx2:\n        return tuple(planets[idx1 + 1:idx2])\n    else:\n        return tuple(planets[idx2 + 1:idx1])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    if start == end:\n        return ()\n    return tuple(planets[start + 1:end])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/151", "requirement": "from typing import List\n\n\ndef double_the_difference(lst: List[int]) -> int:\n    '''\n    Given a list of integers, return the sum of squares of the numbers\n    in the list that are odd and non-negative. Ignore numbers that are negative.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    If the input list is empty, return 0.\n    '''", "generated_programs": ["from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum([num ** 2 for num in lst if num >= 0 and num % 2 != 0])", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((num * num for num in lst if num >= 0 and num % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x % 2 != 0 and x >= 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if x >= 0 and x % 2 != 0))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if any rotation of the second word is a substring in the first word.\n    \n    To achieve this, you can concatenate the second word with itself and check if any substring of the first word of the same length as the second word appears in this concatenated string.\n    \n    Examples:\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    len_b = len(b)\n    for i in range(len(concatenated_b) - len_b + 1):\n        if concatenated_b[i:i + len_b] in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated = b + b\n    len_b = len(b)\n    for i in range(len(concatenated) - len_b + 1):\n        if concatenated[i:i + len_b] in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated = b + b\n    len_b = len(b)\n    for i in range(len(concatenated) - len_b + 1):\n        if concatenated[i:i + len_b] in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated = b + b\n    len_b = len(b)\n    for i in range(len(concatenated) - len_b + 1):\n        substring = concatenated[i:i + len_b]\n        if substring in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated = b + b\n    len_b = len(b)\n    for i in range(len(concatenated) - len_b + 1):\n        substring = concatenated[i:i + len_b]\n        if substring in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated = b + b\n    for i in range(len(concatenated) - len(b) + 1):\n        substring = concatenated[i:i + len(b)]\n        if substring in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated = b + b\n    len_b = len(b)\n    for i in range(len(concatenated) - len_b + 1):\n        if concatenated[i:i + len_b] in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated_b = b + b\n    len_b = len(b)\n    for i in range(len(concatenated_b) - len_b + 1):\n        if concatenated_b[i:i + len_b] in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated = b + b\n    len_b = len(b)\n    for i in range(len(concatenated) - len_b + 1):\n        if concatenated[i:i + len_b] in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated_b = b + b\n    len_b = len(b)\n    for i in range(len(concatenated_b) - len_b + 1):\n        substring = concatenated_b[i:i + len_b]\n        if substring in a:\n            return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "HumanEval/160", "requirement": "from typing import List\n\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists, `operator` and `operand`. The `operator` list contains basic algebra operations, and \n    the `operand` list is a list of integers. Use the two given lists to construct an algebraic expression \n    as a string and evaluate it, respecting the standard operator precedence.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of the `operator` list is equal to the length of the `operand` list minus one.\n        The `operand` list consists of non-negative integers.\n        The `operator` list contains at least one operator, and the `operand` list contains at least two operands.\n\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += op + str(num)\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "code\nfrom typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\nimport operator as op\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    ops = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}\n    i = 0\n    while len(operand) > 1:\n        if i >= len(operator):\n            break\n        if operator[i] in '**':\n            if i < len(operator) and operator[i] == '**':\n                res = ops[operator[i]](operand[i], operand[i + 1])\n                operand[i] = res\n                del operand[i + 1]\n                del operator[i]\n                i -= 1\n        i += 1\n    i = 0\n    while len(operand) > 1:\n        if i >= len(operator):\n            break\n        if operator[i] in ('*', '//'):\n            res = ops[operator[i]](operand[i], operand[i + 1])\n            operand[i] = res\n            del operand[i + 1]\n            del operator[i]\n            i -= 1\n        i += 1\n    i = 0\n    while len(operand) > 1:\n        if i >= len(operator):\n            break\n        if operator[i] in ('+', '-'):\n            res = ops[operator[i]](operand[i], operand[i + 1])\n            operand[i] = res\n            del operand[i + 1]\n            del operator[i]\n            i -= 1\n        i += 1\n    return operand[0]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "from typing import List\n\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return the numbers between a\n    and b (inclusive) that consist entirely of even digits, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all((digit in {'0', '2', '4', '6', '8'} for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start = min(a, b)\n    end = max(a, b)\n    return [num for num in range(start, end + 1) if all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_even_digits(n):\n        return all((int(d) % 2 == 0 for d in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [n for n in range(start, end + 1) if all_even_digits(n)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_even_digits(num)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that starts with the supplied string by appending the minimum necessary characters to its end.\n    \n    The algorithm works as follows:\n    - Identify the longest suffix of the input string that is a palindrome.\n    - Append the reverse of the prefix (the part of the string before the palindromic suffix) to the end of the string.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    for i in range(len(string), -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string + string[::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string + string[::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n - 1, -1, -1):\n        if string[:i + 1] == string[:i + 1][::-1]:\n            return string + string[i + 1:][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    for i in range(len(string), -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[i - 1::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n, -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    longest_palindrome_suffix = ''\n    for i in range(len(string)):\n        if string[i:] == string[i:][::-1]:\n            longest_palindrome_suffix = string[i:]\n            break\n    prefix = string[:len(string) - len(longest_palindrome_suffix)]\n    return string + prefix[::-1]", "def make_palindrome(string: str) -> str:\n    if string == '':\n        return ''\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n, -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    if not string:\n        return string\n    n = len(string)\n    longest_palindromic_suffix = n\n    for i in range(n + 1):\n        if is_palindrome(string[i:]):\n            longest_palindromic_suffix = i\n            break\n    prefix = string[:longest_palindromic_suffix]\n    return string + prefix[::-1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "HumanEval/32", "requirement": "def find_zero(xs: List[float]) -> float:\n    \"\"\" \n    Finds a zero of the polynomial with coefficients xs using the bisection method within the interval [-100, 100].\n    The function assumes that xs has an even number of coefficients and that there is at least one real root within the interval.\n    Returns only one zero point, even if there are multiple.\n    The bisection method checks if the product of the polynomial values at the current interval endpoints is strictly less than zero to determine the subinterval containing the root.\n    \n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100, 100)\n    for _ in range(100):\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100, 100)\n    for _ in range(100):\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "code\nfrom typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    left, right = (-100, 100)\n    while right - left > 1e-07:\n        mid = (left + right) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(left) * polynomial(mid) < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100, 100)\n    while b - a > 1e-07:\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        elif polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef evaluate_poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n\ndef find_zero(xs: List[float]) -> float:\n    a, b = (-100, 100)\n    while abs(a - b) > 1e-07:\n        mid = (a + b) / 2\n        if evaluate_poly(xs, a) * evaluate_poly(xs, mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100, 100)\n    while b - a > 1e-07:\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        elif polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x):\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100, 100)\n    for _ in range(100):\n        mid = (a + b) / 2\n        if polynomial(mid) == 0 or (b - a) / 2 < 1e-07:\n            return mid\n        if polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    a, b = (-100.0, 100.0)\n    while b - a > 1e-07:\n        mid = (a + b) / 2\n        if polynomial(mid) == 0:\n            return mid\n        if polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef evaluate_polynomial(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n\ndef find_zero(xs: List[float]) -> float:\n    a, b = (-100, 100)\n    fa = evaluate_polynomial(xs, a)\n    fb = evaluate_polynomial(xs, b)\n    for _ in range(100):\n        mid = (a + b) / 2\n        fmid = evaluate_polynomial(xs, mid)\n        if fmid == 0:\n            return mid\n        if fa * fmid < 0:\n            b, fb = (mid, fmid)\n        else:\n            a, fa = (mid, fmid)\n    return (a + b) / 2", "from typing import List\n\ndef evaluate_polynomial(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n\ndef find_zero(xs: List[float]) -> float:\n    left, right = (-100.0, 100.0)\n    epsilon = 1e-07\n    while right - left > epsilon:\n        mid = (left + right) / 2\n        f_left = evaluate_polynomial(xs, left)\n        f_mid = evaluate_polynomial(xs, mid)\n        if f_mid == 0:\n            return mid\n        if f_left * f_mid < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2\n    else:\n        return l_sorted[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    if n % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        return (l_sorted[n // 2 - 1] + l_sorted[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    if n % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        return (l_sorted[n // 2 - 1] + l_sorted[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2\n    else:\n        return l_sorted[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 1:\n        return l_sorted[mid]\n    else:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2.0", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    if n % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        return (l_sorted[n // 2 - 1] + l_sorted[n // 2]) / 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/59", "requirement": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of the given integer n. It is guaranteed that n > 1 and n is not a prime number.\n    \n    The function should iteratively divide n by its smallest factors until n itself becomes a prime number, which is then returned as the largest prime factor.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"", "generated_programs": ["def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            n = n // i\n        i += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            n = n // i\n        i += 1\n    return n", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        while n % factor == 0:\n            n = n // factor\n        factor += 1\n    return n", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_prime = 2\n    while largest_prime * largest_prime <= n:\n        while n % largest_prime == 0:\n            n = n // largest_prime\n        largest_prime += 1\n    return n if n > 1 else largest_prime - 1", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_factor = 1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    while n % 2 == 0:\n        largest_prime = 2\n        n = n // 2\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n        i += 2\n    if n > 2:\n        largest_prime = n\n    return largest_prime", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_prime = -1\n    while n % 2 == 0:\n        largest_prime = 2\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n    if n > 2:\n        largest_prime = n\n    return largest_prime"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 1.0}}
{"task_id": "HumanEval/60", "requirement": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that calculates the sum of all natural numbers from 1 to n.\n    If n is less than 1, the function returns 0.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"", "generated_programs": ["def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/65", "requirement": "def circular_shift(x: int, shift: int) -> str:\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"", "generated_programs": ["def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    shift = shift % n\n    return s[-shift:] + s[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    shift = shift % n\n    return s[-shift:] + s[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    shift = shift % n\n    return s[-shift:] + s[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    shift = shift % n\n    return s[-shift:] + s[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    x_str = str(x)\n    n = len(x_str)\n    if shift > n:\n        return x_str[::-1]\n    shift = shift % n\n    return x_str[-shift:] + x_str[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    shift = shift % n\n    return s[-shift:] + s[:-shift]", "code\n\ndef circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    return s[n - shift:] + s[:n - shift]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    \"\"\"Determine if the given integer is a perfect cube of another integer, considering both positive and negative numbers.\n    \n    The function should return True if 'a' is a cube of any integer, otherwise False.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    \"\"\"", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = -round(abs(a) ** (1 / 3))\n    else:\n        cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = -abs(round(a ** (1 / 3)))\n    else:\n        cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3)) if a != 0 else 0\n    return cube_root ** 3 == a or (-cube_root) ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    c = int(round(abs(a) ** (1 / 3)))\n    return c ** 3 == a or (-c) ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        x = -abs(round((-a) ** (1 / 3)))\n    else:\n        x = round(a ** (1 / 3))\n    return x ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = -round(abs(a) ** (1 / 3))\n    else:\n        cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == a or (-cube_root) ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        return round((-a) ** (1 / 3)) ** 3 == -a\n    elif a == 0:\n        return True\n    else:\n        return round(a ** (1 / 3)) ** 3 == a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.8}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of n-digit positive integers\n    that start with 1 or end with 1, without double-counting those that both\n    start and end with 1.\n\n    Examples:\n    >>> starts_one_ends(1)\n    1\n    >>> starts_one_ends(2)\n    18\n    >>> starts_one_ends(3)\n    180\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    both = 10 ** (n - 2)\n    return start_with_one + end_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 10 ** (n - 1)\n    both = 10 ** (n - 2)\n    return starts_with_one + ends_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 10 ** (n - 1)\n    both = 10 ** (n - 2)\n    return starts_with_one + ends_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 2)\n    both = 10 ** (n - 2)\n    return start_with_one + end_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 2) * 1\n    both = 10 ** (n - 2)\n    return start_with_one + end_with_one - both", "code\n\ndef starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    both_start_and_end_with_one = 10 ** (n - 2)\n    return start_with_one + end_with_one - both_start_and_end_with_one", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 2)\n    both = 10 ** (n - 2)\n    return start_with_one + end_with_one - both", "def starts_one_ends(n: int) -> int:\n    total = 0\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    both_start_and_end_with_one = 10 ** (n - 2)\n    total = start_with_one + end_with_one - both_start_and_end_with_one\n    return total", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    first_digit = 1\n    last_digit = 1\n    total_numbers = 10 ** (n - 1)\n    starts_with_one = total_numbers\n    ends_with_one = total_numbers\n    both = 1 * 10 ** (n - 2) if n > 1 else 1\n    return starts_with_one + ends_with_one - both"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    Each letter in the string should be shifted forward by four positions in the alphabet.\n    The function should handle both lowercase and uppercase letters appropriately, wrapping around the alphabet if necessary.\n    Non-alphabet characters should remain unchanged.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if char.islower():\n            encrypted.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif char.isupper():\n            encrypted.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str, shift: int) -> str:\n        if c.islower():\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        elif c.isupper():\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((shift_char(c, 4) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c, shift):\n        if 'a' <= c <= 'z':\n            return chr(ord('a') + (ord(c) - ord('a') + shift) % 26)\n        elif 'A' <= c <= 'Z':\n            return chr(ord('A') + (ord(c) - ord('A') + shift) % 26)\n        else:\n            return c\n    return ''.join((shift_char(c, 4) for c in s))", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        elif 'A' <= char <= 'Z':\n            new_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\" followed by a space.\n    Sentences are delimited by '.', '?', or '!', and consecutive delimiters are treated as a single delimiter.\n    Leading and trailing spaces around sentences are ignored when checking if a sentence starts with \"I\".\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n\n    ### Test 1\n    Input: ['I am here. You are there. They are everywhere.']\n    Expected Output: [3]\n\n    ### Test 2\n    Input: ['I. I! I?']\n    Expected Output: [0]\n\n    ### Test 3\n    Input: ['I am bored. Are you? I certainly am!']\n    Expected Output: [4]\n    \"\"\"", "generated_programs": ["import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]\\\\s*', S)\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    if not S:\n        return 0\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]\\\\s*', S)\n    count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]\\\\s*', S)\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredoms = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            boredoms += 1\n    return boredoms", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+\\\\s*', S.strip())\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/92", "requirement": "def any_int(x: int, y: int, z: int) -> bool:\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false if any of the numbers are not integers or if none of the numbers is equal to the sum of the other two.\n    \n    Examples\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n    '''", "generated_programs": ["def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in [x, y, z])):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(num, int) for num in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not isinstance(x, int) or not isinstance(y, int) or (not isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not isinstance(x, int) or not isinstance(y, int) or (not isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(num, int) for num in [x, y, z])):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not isinstance(x, int) or not isinstance(y, int) or (not isinstance(z, int)):\n        return False\n    if x == y + z or y == x + z or z == x + y:\n        return True\n    return False", "def any_int(x: int, y: int, z: int) -> bool:\n    if not isinstance(x, int) or not isinstance(y, int) or (not isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message consisting solely of letters, \n    and encodes it by swapping the case of all letters and replacing \n    each vowel with the letter that appears two places ahead of it in \n    the English alphabet, considering both lowercase and uppercase vowels. \n    Vowels are 'a', 'e', 'i', 'o', 'u'.\n\n    For example, 'a' becomes 'C', 'A' becomes 'c', 'e' becomes 'G', etc.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n    vowels = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(vowels[char])\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(vowels[char])\n        elif char.isalpha():\n            encoded_message.append(char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(vowels[char])\n        elif char.isalpha():\n            encoded_message.append(char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(vowels[char])\n        elif char.isalpha():\n            encoded_message.append(char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a': 'C', 'A': 'c', 'e': 'G', 'E': 'g', 'i': 'K', 'I': 'k', 'o': 'Q', 'O': 'q', 'u': 'W', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(vowels[char])\n        elif char.isalpha():\n            encoded_message.append(char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result = []\n    for char in message:\n        if char in vowels:\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + 2) % 26 + ord('A'))\n            else:\n                new_char = chr((ord(char) - ord('A') + 2) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char.swapcase())\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result = []\n    for char in message:\n        if char in vowels:\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + 2) % 26 + ord('A'))\n            else:\n                new_char = chr((ord(char) - ord('A') + 2) % 26 + ord('a'))\n            result.append(new_char)\n        elif char.islower():\n            result.append(char.upper())\n        else:\n            result.append(char.lower())\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    vowel_map = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'Y', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'y'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(vowel_map[char])\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels_lower = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'm', 'u': 'w'}\n    vowels_upper = {'A': 'C', 'E': 'G', 'I': 'K', 'O': 'M', 'U': 'W'}\n    encoded_message = []\n    for char in message:\n        if char in vowels_lower:\n            encoded_message.append(vowels_lower[char].upper())\n        elif char in vowels_upper:\n            encoded_message.append(vowels_upper[char].lower())\n        elif char.isalpha():\n            encoded_message.append(char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels_lower = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W'}\n    vowels_upper = {'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels_lower:\n            encoded_message.append(vowels_lower[char])\n        elif char in vowels_upper:\n            encoded_message.append(vowels_upper[char])\n        elif char.isalpha():\n            encoded_message.append(char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.0}}
{"task_id": "HumanEval/94", "requirement": "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n    If there are no prime numbers in the list, the function should raise a ValueError.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum(map(int, str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum(map(int, str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    max_prime = max(primes)\n    return sum((int(digit) for digit in str(max_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/95", "requirement": "from typing import Dict\n\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"", "generated_programs": ["from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    lowercase = all((isinstance(key, str) and key.islower() for key in keys))\n    uppercase = all((isinstance(key, str) and key.isupper() for key in keys))\n    return lowercase or uppercase", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(key, str) for key in keys)):\n        if all((key.islower() for key in keys)):\n            return True\n        if all((key.isupper() for key in keys)):\n            return True\n    return False", "from typing import Dict, Any\n\ndef check_dict_case(d: Dict[Any, Any]) -> bool:\n    if not d:\n        return False\n    keys = list(d.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key.islower() for key in keys))\n    upper_case = all((key.isupper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = [key for key in dict.keys() if isinstance(key, str)]\n    if not keys:\n        return False\n    is_lower = all((key.islower() for key in keys))\n    is_upper = all((key.isupper() for key in keys))\n    return is_lower or is_upper", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key == key.lower() for key in keys))\n    upper_case = all((key == key.upper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key.islower() for key in keys))\n    upper_case = all((key.isupper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    lower_case = all((key == key.lower() for key in keys))\n    upper_case = all((key == key.upper() for key in keys))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    is_lower = all((key.islower() for key in keys))\n    is_upper = all((key.isupper() for key in keys))\n    return is_lower or is_upper", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    if all((key.islower() for key in keys)):\n        return True\n    if all((key.isupper() for key in keys)):\n        return True\n    return False", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    is_lower = all((key == key.lower() for key in keys))\n    is_upper = all((key == key.upper() for key in keys))\n    return is_lower or is_upper"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.7, "original_passk": 0.8}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    Each subsequent level has 2 more stones than the previous level.\n    \n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        current += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    for i in range(1, n):\n        pile.append(pile[i - 1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        current += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements whose sum of digits (considering the sign of the first digit if negative) is greater than 0.\n    For example, for a negative number like -123, the sum of digits is calculated as -1 + 2 + 3 = 4.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    return sum((1 for num in arr if sum((int(digit) if idx == 0 and num < 0 else int(digit) for idx, digit in enumerate(str(abs(num))))) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(n: int) -> int:\n        sign = -1 if n < 0 else 1\n        return sign * sum((int(digit) for digit in str(abs(n))))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(abs(num))\n        digit_sum = sum((int(digit) for digit in s))\n        if num < 0:\n            digit_sum = -int(s[0]) + sum((int(digit) for digit in s[1:]))\n        if digit_sum > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            digit_sum = -int(s[1]) + sum((int(c) for c in s[2:]))\n        else:\n            digit_sum = sum((int(c) for c in s))\n        if digit_sum > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        sum_digits = int(s[0]) if s[0] == '-' else 0\n        for c in s[1:] if s[0] == '-' else s:\n            sum_digits += int(c)\n        if sum_digits > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            digit_sum = -int(s[1]) + sum((int(d) for d in s[2:]))\n        else:\n            digit_sum = sum((int(d) for d in s))\n        if digit_sum > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_digits(num):\n        if num < 0:\n            digits = [int(d) for d in str(abs(num))]\n            return -digits[0] + sum(digits[1:])\n        else:\n            return sum((int(d) for d in str(num)))\n    count = 0\n    for num in arr:\n        if sum_digits(num) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        sign = -1 if num < 0 else 1\n        num = abs(num)\n        total = 0\n        while num > 0:\n            total += num % 10\n            num //= 10\n        return total * sign\n    count = 0\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n    return count", "code\nfrom typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        num_str = str(num)\n        if num_str[0] == '-':\n            sum_digits = int(num_str[0] + num_str[1]) + sum((int(digit) for digit in num_str[2:]))\n        else:\n            sum_digits = sum((int(digit) for digit in num_str))\n        if sum_digits > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        digit_sum = 0\n        for i, ch in enumerate(s):\n            if i == 0 and ch == '-':\n                continue\n            digit_sum += int(ch)\n        if s[0] == '-':\n            digit_sum = -int(s[1]) + sum((int(ch) for ch in s[2:]))\n        if digit_sum > 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.9}}
{"task_id": "HumanEval/109", "requirement": "def move_one_ball(arr: List[int]) -> bool:\n    \"\"\"Determine if the array can be sorted in non-decreasing order by performing\n    zero or more right shift operations. A right shift operation moves each element\n    of the array one position to the right, with the last element moving to the\n    first position.\n\n    The function returns True if it is possible to sort the array using at most one\n    \"rotation point\" (where an element is greater than the next element), otherwise\n    it returns False. An empty array is considered sorted and thus the function\n    returns True.\n\n    Note: The array is guaranteed to contain unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2]) ==> True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2]) ==> False\n    Explanation: It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    rotation_points = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_points += 1\n    return rotation_points <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    rotation_points = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_points += 1\n    return rotation_points <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    rotation_points = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_points += 1\n    return rotation_points <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    pivot = 0\n    for i in range(1, n):\n        if arr[i - 1] > arr[i]:\n            pivot += 1\n            if pivot > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    cnt = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            cnt += 1\n            if cnt > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/110", "requirement": "from typing import List\n\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them such that lst1 becomes a list of only even numbers.\n    The exchange allows any number of elements to be moved between lst1 and lst2.\n    To achieve the goal, the number of even numbers in lst2 must be at least\n    equal to the number of odd numbers in lst1.\n    If it is possible to make all the elements of lst1 even through such exchanges,\n    return \"YES\". Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for num in lst1 if num % 2 != 0))\n    even_count = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_in_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    count_odd_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    count_even_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if count_even_lst2 >= count_odd_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_in_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_in_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_in_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/115", "requirement": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the total number of times you need to lower the buckets across all wells.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        units = sum(well)\n        total += (units + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for row in grid:\n        water = sum(row)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for row in grid:\n        water = sum(row)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_dips = 0\n    for well in grid:\n        water = sum(well)\n        dips = (water + capacity - 1) // capacity\n        total_dips += dips\n    return total_dips", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        buckets = (water + capacity - 1) // capacity\n        total_buckets += buckets\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        total += (water + capacity - 1) // capacity\n    return total", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        total_buckets += (water + capacity - 1) // capacity\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for well in grid:\n        water = sum(well)\n        if water == 0:\n            continue\n        buckets = (water + capacity - 1) // capacity\n        total_buckets += buckets\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for well in grid:\n        water_units = sum(well)\n        if water_units == 0:\n            continue\n        buckets = (water_units + capacity - 1) // capacity\n        total_buckets += buckets\n    return total_buckets"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of integers. Non-negative integers should be sorted according to\n    the number of ones in their binary representation in ascending order. For numbers with the same count of ones,\n    sort them by their decimal value. Negative integers should be sorted by their absolute values in descending order\n    and placed before the sorted non-negative integers.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1') if n >= 0 else 0\n\n    def sort_key(n):\n        if n < 0:\n            return (0, -n)\n        else:\n            return (1, count_ones(n), n)\n    return sorted(arr, key=sort_key)", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    negatives = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    positives = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    return negatives + positives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    negatives = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    negatives = sorted((x for x in arr if x < 0), key=lambda x: abs(x), reverse=True)\n    non_negatives = sorted((x for x in arr if x >= 0), key=lambda x: (count_ones(x), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    negative = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    negatives = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1') if n >= 0 else 0\n    negative = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    negatives = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    negatives = sorted([x for x in arr if x < 0], key=lambda x: -abs(x))\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        return bin(n).count('1')\n    negatives = [x for x in arr if x < 0]\n    non_negatives = [x for x in arr if x >= 0]\n    negatives_sorted = sorted(negatives, key=lambda x: abs(x), reverse=True)\n    non_negatives_sorted = sorted(non_negatives, key=lambda x: (count_ones(x), x))\n    return negatives_sorted + non_negatives_sorted"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The date is in the format: mm-dd-yyyy, where mm is the two-digit month, dd is the two-digit day, and yyyy is the four-digit year.\n    3. The months should be between 01 and 12.\n    4. The days should be appropriate for the given month, considering leap years:\n       - For months 01, 03, 05, 07, 08, 10, 12, the day should be between 01 and 31.\n       - For months 04, 06, 09, 11, the day should be between 01 and 30.\n       - For month 02, the day should be between 01 and 29 in leap years and between 01 and 28 in non-leap years.\n\n    For example:\n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        datetime.strptime(date, '%m-%d-%Y')\n    except ValueError:\n        return False\n    return True", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-(\\\\d{4})$'\n    if not re.match(pattern, date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        datetime(year=year, month=month, day=day)\n        return True\n    except ValueError:\n        return False", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n        if day < 1 or day > 29:\n            return False\n    elif day < 1 or day > 28:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    mm, dd, yyyy = map(int, date.split('-'))\n    if mm < 1 or mm > 12:\n        return False\n    if mm in {1, 3, 5, 7, 8, 10, 12}:\n        if dd < 1 or dd > 31:\n            return False\n    elif mm in {4, 6, 9, 11}:\n        if dd < 1 or dd > 30:\n            return False\n    elif yyyy % 4 == 0 and yyyy % 100 != 0 or yyyy % 400 == 0:\n        if dd < 1 or dd > 29:\n            return False\n    elif dd < 1 or dd > 28:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    mm, dd, yyyy = map(int, date.split('-'))\n    if mm < 1 or mm > 12:\n        return False\n    if mm in {1, 3, 5, 7, 8, 10, 12}:\n        if dd < 1 or dd > 31:\n            return False\n    elif mm in {4, 6, 9, 11}:\n        if dd < 1 or dd > 30:\n            return False\n    elif yyyy % 4 == 0 and yyyy % 100 != 0 or yyyy % 400 == 0:\n        if dd < 1 or dd > 29:\n            return False\n    elif dd < 1 or dd > 28:\n        return False\n    return True", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day < 1 or day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day < 1 or day > 30:\n                return False\n        elif year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            if day < 1 or day > 29:\n                return False\n        elif day < 1 or day > 28:\n            return False\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day < 1 or day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day < 1 or day > 30:\n                return False\n        elif month == 2:\n            is_leap = year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n            if day < 1 or day > (29 if is_leap else 28):\n                return False\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day < 1 or day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day < 1 or day > 30:\n                return False\n        elif month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                if day < 1 or day > 29:\n                    return False\n            elif day < 1 or day > 28:\n                return False\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day < 1 or day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day < 1 or day > 30:\n                return False\n        elif year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            if day < 1 or day > 29:\n                return False\n        elif day < 1 or day > 28:\n            return False\n        return True\n    except ValueError:\n        return False", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = re.compile('^\\\\d{2}-\\\\d{2}-\\\\d{4}$')\n    if not pattern.match(date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    mm = int(mm)\n    dd = int(dd)\n    yyyy = int(yyyy)\n    if mm < 1 or mm > 12:\n        return False\n    if mm in {1, 3, 5, 7, 8, 10, 12}:\n        if dd < 1 or dd > 31:\n            return False\n    elif mm in {4, 6, 9, 11}:\n        if dd < 1 or dd > 30:\n            return False\n    elif mm == 2:\n        leap = yyyy % 4 == 0 and yyyy % 100 != 0 or yyyy % 400 == 0\n        if leap and (dd < 1 or dd > 29):\n            return False\n        elif not leap and (dd < 1 or dd > 28):\n            return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/125", "requirement": "from typing import List\nfrom typing import Union\n\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on any whitespace characters (spaces, tabs, newlines). \n    If no whitespace exists in the text, you should split on commas ','. If no commas exist, you should return \n    the number of lowercase letters that are at odd positions in the alphabet (considering ord('a') = 0, \n    ord('b') = 1, ..., ord('z') = 25). This means count letters like 'b', 'd', 'f', etc.\n    \n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for i, c in enumerate(txt) if c.islower() and (ord(c) - ord('a')) % 2 != 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for i, char in enumerate(txt) if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    if ',' in txt:\n        return txt.split(',')\n    count = 0\n    for i, c in enumerate(txt):\n        if c.islower() and (ord(c) - ord('a')) % 2 == 1:\n            count += 1\n    return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for i, char in enumerate(txt):\n            if char.islower() and (ord(char) - ord('a')) % 2 == 1:\n                count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for i, char in enumerate(txt):\n            if char.islower() and (ord(char) - ord('a')) % 2 != 0:\n                count += 1\n        return count", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for i, char in enumerate(txt):\n            if char.islower() and (ord(char) - ord('a')) % 2 == 1:\n                count += 1\n        return count", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for i, char in enumerate(txt):\n            if char.islower() and (ord(char) - ord('a')) % 2 == 1:\n                count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for i, char in enumerate(txt):\n            if char.islower() and (ord(char) - ord('a')) % 2 != 0:\n                count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    import re\n    if re.search('\\\\s', txt):\n        return re.split('\\\\s+', txt)\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for i, char in enumerate(txt):\n            if char.islower() and (ord(char) - ord('a')) % 2 == 1:\n                count += 1\n        return count", "code\nfrom typing import List, Union\nimport re\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return re.split('\\\\s+', txt)\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for i, c in enumerate(txt):\n            if c.islower() and (ord(c) - ord('a')) % 2 == 1:\n                count += 1\n        return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.5}}
{"task_id": "HumanEval/127", "requirement": "from typing import Tuple\n\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    if is_prime(length):\n        return 'YES'\n    else:\n        return 'NO'"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a unique value from 1 to N*N. \n\n    The task is to find the lexicographically smallest path of length k in the grid. \n    You can start from any cell and move to any of its neighboring cells (up, down, left, right), \n    but you cannot move off the grid. A path of length k means visiting exactly k cells, \n    which can be distinct or the same.\n\n    A path A is considered lexicographically smaller than a path B if the sequence of values \n    along path A is lexicographically smaller than the sequence of values along path B. \n    It is guaranteed that there is a unique lexicographically smallest path.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [grid[nx][ny]]\n                heappush(heap, (new_path, nx, ny))", "from typing import List\nfrom collections import deque\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_path = None\n    neighbors = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    for i in range(n):\n        for j in range(n):\n            queue = deque()\n            queue.append((i, j, [grid[i][j]]))\n            while queue:\n                x, y, path = queue.popleft()\n                if len(path) == k:\n                    if min_path is None or path < min_path:\n                        min_path = path\n                    continue\n                for dx, dy in neighbors:\n                    nx, ny = (x + dx, y + dy)\n                    if 0 <= nx < n and 0 <= ny < n:\n                        queue.append((nx, ny, path + [grid[nx][ny]]))\n    return min_path", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    min_heap = []\n    for i in range(N):\n        for j in range(N):\n            heappush(min_heap, (grid[i][j], i, j, [grid[i][j]]))\n    while min_heap:\n        _, x, y, path = heappop(min_heap)\n        if len(path) == k:\n            return path\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                heappush(min_heap, (grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n    return []", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path.copy()\n                new_path.append(grid[nx][ny])\n                heappush(heap, (new_path, nx, ny))\n    return []", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    visited = set()\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heappop(heap)\n        if len(path) == k:\n            return path\n        if (x, y, tuple(path)) in visited:\n            continue\n        visited.add((x, y, tuple(path)))\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [grid[nx][ny]]\n                heappush(heap, (new_path, nx, ny))\n    return []", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_path = [float('inf')] * k\n\n    def dfs(x, y, path, visited):\n        nonlocal min_path\n        if len(path) == k:\n            if path < min_path:\n                min_path = path.copy()\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                visited.add((nx, ny))\n                dfs(nx, ny, path + [grid[nx][ny]], visited)\n                visited.remove((nx, ny))\n    for i, j in product(range(n), range(n)):\n        dfs(i, j, [grid[i][j]], {(i, j)})\n    return min_path", "from typing import List\nfrom heapq import heappush, heappop\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heappush(heap, (grid[i][j], [grid[i][j]], i, j, {(i, j)}))\n    while heap:\n        current_sum, current_path, x, y, visited = heappop(heap)\n        if len(current_path) == k:\n            return current_path\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                new_visited = set(visited)\n                new_visited.add((nx, ny))\n                heappush(heap, (grid[nx][ny], current_path + [grid[nx][ny]], nx, ny, new_visited))\n    return []", "code\nfrom typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, path, visited):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                visited.add((nx, ny))\n                current_path = dfs(nx, ny, path + [grid[nx][ny]], visited)\n                visited.remove((nx, ny))\n                if current_path is not None:\n                    if min_path is None or current_path < min_path:\n                        min_path = current_path\n        return min_path\n    min_path = None\n    for i in range(n):\n        for j in range(n):\n            visited = set()\n            visited.add((i, j))\n            current_path = dfs(i, j, [grid[i][j]], visited)\n            if current_path is not None:\n                if min_path is None or current_path < min_path:\n                    min_path = current_path\n    return min_path", "from typing import List\nfrom collections import deque\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_value = float('inf')\n    for row in grid:\n        min_value = min(min_value, min(row))\n    if k == 1:\n        return [min_value]\n    min_path = [float('inf')] * k\n    queue = deque()\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == min_value:\n                queue.append((i, j, [grid[i][j]]))\n    while queue:\n        i, j, path = queue.popleft()\n        if len(path) == k:\n            if path < min_path:\n                min_path = path\n            continue\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            x, y = (i + dx, j + dy)\n            if 0 <= x < n and 0 <= y < n:\n                new_path = path + [grid[x][y]]\n                if len(new_path) <= k:\n                    queue.append((x, y, new_path))\n    return min_path", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n\n\n    def dfs(x, y, path, visited):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if is_valid(nx, ny) and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                new_path = dfs(nx, ny, path + [grid[nx][ny]], visited)\n                if new_path:\n                    if min_path is None or new_path < min_path:\n                        min_path = new_path\n                visited.remove((nx, ny))\n        return min_path\n    min_overall = None\n    for i, j in product(range(n), range(n)):\n        current_path = dfs(i, j, [grid[i][j]], set([(i, j)]))\n        if current_path:\n            if min_overall is None or current_path < min_overall:\n                min_overall = current_path\n    return min_overall"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.5}}
{"task_id": "HumanEval/130", "requirement": "from typing import List\n\ndef tri(n: int) -> List[float]:\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    - tri(0) = 1\n    - tri(1) = 3\n    - tri(n) = 1 + n / 2, if n is even and n > 1.\n    - tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd, where tri(n + 1) is calculated as 1 + (n + 1) / 2 if n + 1 is greater than the current length of the sequence being constructed.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 1 + (4 / 2) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    result = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result.append(1 + i / 2)\n        else:\n            next_term = 1 + (i + 1) / 2\n            result.append(result[i - 1] + result[i - 2] + next_term)\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    sequence = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1.0 + i / 2)\n        else:\n            next_term = 1.0 + (i + 1) / 2 if i + 1 > len(sequence) else sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_term)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    sequence = [1.0, 3.0]\n    if n == 1:\n        return sequence\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1.0 + i / 2)\n        else:\n            next_item = 1.0 + (i + 1) / 2 if i + 1 > len(sequence) else sequence[i + 1]\n            trib = sequence[i - 1] + sequence[i - 2] + next_item\n            sequence.append(trib)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n < 0:\n        return []\n    sequence = []\n    for i in range(n + 1):\n        if i == 0:\n            sequence.append(1.0)\n        elif i == 1:\n            sequence.append(3.0)\n        elif i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > len(sequence):\n                next_term = 1 + (i + 1) / 2\n            else:\n                next_term = sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_term)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    if n == 1:\n        return [1.0, 3.0]\n    sequence = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1.0 + i / 2)\n        else:\n            next_term = 1.0 + (i + 1) / 2 if i + 1 > len(sequence) else sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_term)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n < 0:\n        return []\n    trib = [1.0]\n    if n == 0:\n        return trib\n    trib.append(3.0)\n    if n == 1:\n        return trib\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            trib.append(1 + i / 2)\n        else:\n            if i + 1 > len(trib):\n                trib.append(1 + (i + 1) / 2)\n            trib.append(trib[i - 1] + trib[i - 2] + trib[i + 1])\n    return trib[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    if n == 1:\n        return [1.0, 3.0]\n    sequence = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1.0 + i / 2)\n        else:\n            if i + 1 > len(sequence):\n                next_term = 1.0 + (i + 1) / 2\n            else:\n                next_term = sequence[i + 1]\n            current_term = sequence[i - 1] + sequence[i - 2] + next_term\n            sequence.append(current_term)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n < 0:\n        return []\n    sequence = [1.0]\n    if n >= 1:\n        sequence.append(3.0)\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > len(sequence):\n                tri_n_plus_1 = 1 + (i + 1) / 2\n            else:\n                tri_n_plus_1 = sequence[i + 1]\n            tri_n = sequence[i - 1] + sequence[i - 2] + tri_n_plus_1\n            sequence.append(tri_n)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    elif n == 1:\n        return [1.0, 3.0]\n    sequence = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1.0 + i / 2)\n        else:\n            if i + 1 > len(sequence):\n                next_val = 1.0 + (i + 1) / 2\n            else:\n                next_val = sequence[i + 1] if i + 1 < len(sequence) else 1.0 + (i + 1) / 2\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_val)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = []\n    for i in range(n + 1):\n        if i == 0:\n            sequence.append(1.0)\n        elif i == 1:\n            sequence.append(3.0)\n        elif i % 2 == 0:\n            sequence.append(1.0 + i / 2)\n        else:\n            if i - 2 >= 0:\n                a = sequence[i - 2]\n            else:\n                a = 0.0\n            if i - 1 >= 0:\n                b = sequence[i - 1]\n            else:\n                b = 0.0\n            if i + 1 <= n:\n                if i + 1 == 0:\n                    c = 1.0\n                elif i + 1 == 1:\n                    c = 3.0\n                elif (i + 1) % 2 == 0:\n                    c = 1.0 + (i + 1) / 2\n                else:\n                    c = 0.0\n            else:\n                c = 1.0 + (i + 1) / 2\n            sequence.append(a + b + c)\n    return sequence"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if there is any subsequence of brackets within the string\n    where at least one bracket is nested. A bracket is considered nested if it is enclosed by another pair of brackets.\n    The function does not require the entire string to be balanced.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n            if stack:\n                return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n    return len(stack) > 0", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if len(stack) > 1:\n                nested = True\n            if stack:\n                stack.pop()\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            if stack and stack[-1] == '[':\n                return True\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if len(stack) > 1:\n                return True\n            if stack:\n                stack.pop()\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                if stack[-1] == '[':\n                    stack.pop()\n                    if stack:\n                        return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/134", "requirement": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''", "generated_programs": ["import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    return not re.search('\\\\B\\\\w$', txt)", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if last_char.isalpha():\n        if len(txt) == 1:\n            return True\n        if txt[-2] == ' ':\n            return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if len(txt) > 1 and txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    preceding_char = txt[-2]\n    if preceding_char.isspace():\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    words = txt.split()\n    if not words:\n        return False\n    last_word = words[-1]\n    if last_word[-1] != last_char:\n        return True\n    return False", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    words = txt.split()\n    if not words:\n        return False\n    last_word = words[-1]\n    if last_char == last_word[-1] and len(last_word) == 1:\n        return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.6, "original_passk": 1.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "code\nfrom typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "code\nfrom typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    indexed_nums = [(sum_of_digits(num), idx, num) for idx, num in enumerate(nums)]\n    indexed_nums.sort()\n    return [num for _, _, num in indexed_nums]", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    indexed_nums = [(num, i, sum_of_digits(num)) for i, num in enumerate(nums)]\n    sorted_nums = sorted(indexed_nums, key=lambda x: (x[2], x[1]))\n    return [x[0] for x in sorted_nums]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/147", "requirement": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, create an integer array a of length n where each element a[i] is calculated as i * i - i + 1 for 1 ≤ i ≤ n.\n    Return the number of unique triples (a[i], a[j], a[k]) in the array such that i < j < k and the sum a[i] + a[j] + a[k] is divisible by 3.\n\n    Example:\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"", "generated_programs": ["from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/148", "requirement": "from typing import Tuple\n\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''", "generated_programs": ["from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start, end = (min(idx1, idx2), max(idx1, idx2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start, end = (min(idx1, idx2), max(idx1, idx2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start = min(index1, index2)\n    end = max(index1, index2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2) + 1\n    end = max(idx1, idx2)\n    return tuple(planets[start:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start = min(index1, index2)\n    end = max(index1, index2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return tuple()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start = min(index1, index2)\n    end = max(index1, index2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start = min(index1, index2)\n    end = max(index1, index2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    if idx1 < idx2:\n        return tuple(planets[idx1 + 1:idx2])\n    else:\n        return tuple(planets[idx2 + 1:idx1])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/151", "requirement": "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd and non-negative integers. Ignore any numbers\n    that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    If the input list is empty, return 0.\n    \n    Note: Only integer values are considered. Non-integer numbers are ignored.\n    '''", "generated_programs": ["from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((num * num for num in lst if isinstance(num, int) and num >= 0 and (num % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x * x for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given two words. You need to return True if any rotation of the second word is a substring of the first word.\n    \n    To achieve this, concatenate the second word with itself and check if any substring of the first word of length equal to the second word is found within this concatenated string.\n    \n    Examples:\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    concatenated = b + b\n    return any((a[i:i + len(b)] in concatenated for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    return any((a[i:i + len(b)] in concatenated_b for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated = b + b\n    for i in range(len(concatenated) - len(b) + 1):\n        if a == concatenated[i:i + len(b)]:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    concat_b = b + b\n    len_b = len(b)\n    for i in range(len(concat_b) - len_b + 1):\n        if concat_b[i:i + len_b] in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated = b + b\n    for i in range(len(concatenated) - len(b) + 1):\n        if a.find(concatenated[i:i + len(b)]) != -1:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    len_b = len(b)\n    for i in range(len(concatenated_b) - len_b + 1):\n        substring = concatenated_b[i:i + len_b]\n        if substring in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated = b + b\n    len_b = len(b)\n    for i in range(len(concatenated) - len_b + 1):\n        if concatenated[i:i + len_b] in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated = b + b\n    len_b = len(b)\n    for i in range(len(concatenated) - len_b + 1):\n        if concatenated[i:i + len_b] in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated = b + b\n    len_b = len(b)\n    if len_b == 0:\n        return True\n    for i in range(len(concatenated) - len_b + 1):\n        if a.find(concatenated[i:i + len_b]) != -1:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    concatenated_b = b + b\n    len_b = len(b)\n    for i in range(len(concatenated_b) - len_b + 1):\n        if a.find(concatenated_b[i:i + len_b]) != -1:\n            return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.8}}
{"task_id": "HumanEval/160", "requirement": "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Given two lists, `operators` and `operands`, construct an algebraic expression using these lists and evaluate it \n    while respecting standard operator precedence rules. The operators should be evaluated in the following order of \n    precedence: exponentiation (**), multiplication (*), floor division (//), addition (+), and subtraction (-). When \n    multiple operators of the same precedence level appear consecutively, they should be evaluated from left to right.\n\n    The basic algebra operations supported are:\n    - Addition ( + ) \n    - Subtraction ( - ) \n    - Multiplication ( * ) \n    - Floor division ( // ) \n    - Exponentiation ( ** ) \n\n    Example:\n    operators = ['+', '*', '-']\n    operands = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        - The length of the `operators` list is always one less than the length of the `operands` list.\n        - The `operands` list contains at least two integers.\n        - The `operators` list contains at least one operator.\n        - The function must respect the standard operator precedence rules during evaluation, evaluating \n          from left to right for operators of the same precedence level.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    tokens = []\n    tokens.append(str(operands[0]))\n    for op, num in zip(operators, operands[1:]):\n        tokens.append(op)\n        tokens.append(str(num))\n    expression = ' '.join(tokens)\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    if not operators or not operands:\n        return 0\n    precedence = {'**': 4, '*': 3, '//': 3, '+': 2, '-': 1}\n    stack = []\n    i = 0\n    while i < len(operators):\n        current_op = operators[i]\n        next_op = operators[i + 1] if i + 1 < len(operators) else None\n        if next_op and precedence[current_op] < precedence[next_op]:\n            stack.append(operands[i])\n            stack.append(current_op)\n            i += 1\n        else:\n            right = operands[i + 1]\n            left = operands[i]\n            result = eval(f'{left}{current_op}{right}')\n            operands[i + 1] = result\n            i += 1\n    return operands[-1]", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    precedence = {'**': 4, '*': 3, '//': 3, '+': 2, '-': 1}\n    i = 0\n    while i < len(operators):\n        if i + 1 < len(operators) and precedence[operators[i]] < precedence[operators[i + 1]]:\n            i += 1\n            continue\n        op = operators.pop(i)\n        a = operands.pop(i)\n        b = operands.pop(i)\n        if op == '+':\n            operands.insert(i, a + b)\n        elif op == '-':\n            operands.insert(i, a - b)\n        elif op == '*':\n            operands.insert(i, a * b)\n        elif op == '//':\n            operands.insert(i, a // b)\n        elif op == '**':\n            operands.insert(i, a ** b)\n        if i > 0:\n            i -= 1\n    return operands[0]", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    precedence = {'**': 4, '*': 3, '//': 3, '+': 2, '-': 2}\n    stack = []\n    op_stack = []\n    stack.append(operands[0])\n    for i in range(len(operators)):\n        current_op = operators[i]\n        while op_stack and precedence[op_stack[-1]] >= precedence[current_op]:\n            operator = op_stack.pop()\n            b = stack.pop()\n            a = stack.pop()\n            if operator == '**':\n                stack.append(a ** b)\n            elif operator == '*':\n                stack.append(a * b)\n            elif operator == '//':\n                stack.append(a // b)\n            elif operator == '+':\n                stack.append(a + b)\n            elif operator == '-':\n                stack.append(a - b)\n        op_stack.append(current_op)\n        stack.append(operands[i + 1])\n    while op_stack:\n        operator = op_stack.pop()\n        b = stack.pop()\n        a = stack.pop()\n        if operator == '**':\n            stack.append(a ** b)\n        elif operator == '*':\n            stack.append(a * b)\n        elif operator == '//':\n            stack.append(a // b)\n        elif operator == '+':\n            stack.append(a + b)\n        elif operator == '-':\n            stack.append(a - b)\n    return stack[0]", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    precedence = {'**': 4, '*': 3, '//': 3, '+': 2, '-': 1}\n    stack = []\n    num_stack = [operands[0]]\n    for i, op in enumerate(operators):\n        current_op = op\n        current_num = operands[i + 1]\n        while stack and precedence.get(stack[-1], 0) >= precedence.get(current_op, 0):\n            prev_op = stack.pop()\n            b = num_stack.pop()\n            a = num_stack.pop()\n            if prev_op == '+':\n                num_stack.append(a + b)\n            elif prev_op == '-':\n                num_stack.append(a - b)\n            elif prev_op == '*':\n                num_stack.append(a * b)\n            elif prev_op == '//':\n                num_stack.append(a // b)\n            elif prev_op == '**':\n                num_stack.append(a ** b)\n        stack.append(current_op)\n        num_stack.append(current_num)\n    while stack:\n        op = stack.pop()\n        b = num_stack.pop()\n        a = num_stack.pop()\n        if op == '+':\n            num_stack.append(a + b)\n        elif op == '-':\n            num_stack.append(a - b)\n        elif op == '*':\n            num_stack.append(a * b)\n        elif op == '//':\n            num_stack.append(a // b)\n        elif op == '**':\n            num_stack.append(a ** b)\n    return num_stack[0]", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    if not operators or not operands:\n        return 0\n    precedence = {'**': 4, '*': 3, '//': 3, '+': 2, '-': 2}\n    operator_stack = []\n    operand_stack = [operands[0]]\n    for i in range(len(operators)):\n        op = operators[i]\n        while operator_stack and precedence.get(operator_stack[-1], 0) >= precedence.get(op, 0):\n            operator = operator_stack.pop()\n            b = operand_stack.pop()\n            a = operand_stack.pop()\n            if operator == '+':\n                operand_stack.append(a + b)\n            elif operator == '-':\n                operand_stack.append(a - b)\n            elif operator == '*':\n                operand_stack.append(a * b)\n            elif operator == '//':\n                operand_stack.append(a // b)\n            elif operator == '**':\n                operand_stack.append(a ** b)\n        operator_stack.append(op)\n        operand_stack.append(operands[i + 1])\n    while operator_stack:\n        operator = operator_stack.pop()\n        b = operand_stack.pop()\n        a = operand_stack.pop()\n        if operator == '+':\n            operand_stack.append(a + b)\n        elif operator == '-':\n            operand_stack.append(a - b)\n        elif operator == '*':\n            operand_stack.append(a * b)\n        elif operator == '//':\n            operand_stack.append(a // b)\n        elif operator == '**':\n            operand_stack.append(a ** b)\n    return operand_stack[0]", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    if not operators or not operands:\n        return 0\n    precedence = {'**': 4, '*': 3, '//': 3, '+': 2, '-': 1}\n    values = []\n    ops = []\n    values.append(operands[0])\n    for i in range(len(operators)):\n        current_op = operators[i]\n        current_val = operands[i + 1]\n        while ops and precedence.get(ops[-1], 0) >= precedence.get(current_op, 0):\n            operator = ops.pop()\n            val2 = values.pop()\n            val1 = values.pop()\n            if operator == '+':\n                values.append(val1 + val2)\n            elif operator == '-':\n                values.append(val1 - val2)\n            elif operator == '*':\n                values.append(val1 * val2)\n            elif operator == '//':\n                values.append(val1 // val2)\n            elif operator == '**':\n                values.append(val1 ** val2)\n        ops.append(current_op)\n        values.append(current_val)\n    while ops:\n        operator = ops.pop()\n        val2 = values.pop()\n        val1 = values.pop()\n        if operator == '+':\n            values.append(val1 + val2)\n        elif operator == '-':\n            values.append(val1 - val2)\n        elif operator == '*':\n            values.append(val1 * val2)\n        elif operator == '//':\n            values.append(val1 // val2)\n        elif operator == '**':\n            values.append(val1 ** val2)\n    return values[0]", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    precedence = {'**': 4, '*': 3, '//': 3, '+': 2, '-': 2}\n    num_stack = []\n    op_stack = []\n    num_stack.append(operands[0])\n    for i in range(len(operators)):\n        op = operators[i]\n        num = operands[i + 1]\n        while op_stack and precedence[op_stack[-1]] >= precedence[op]:\n            operator = op_stack.pop()\n            b = num_stack.pop()\n            a = num_stack.pop()\n            if operator == '**':\n                num_stack.append(a ** b)\n            elif operator == '*':\n                num_stack.append(a * b)\n            elif operator == '//':\n                num_stack.append(a // b)\n            elif operator == '+':\n                num_stack.append(a + b)\n            elif operator == '-':\n                num_stack.append(a - b)\n        op_stack.append(op)\n        num_stack.append(num)\n    while op_stack:\n        operator = op_stack.pop()\n        b = num_stack.pop()\n        a = num_stack.pop()\n        if operator == '**':\n            num_stack.append(a ** b)\n        elif operator == '*':\n            num_stack.append(a * b)\n        elif operator == '//':\n            num_stack.append(a // b)\n        elif operator == '+':\n            num_stack.append(a + b)\n        elif operator == '-':\n            num_stack.append(a - b)\n    return num_stack[0]", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    if not operators or not operands:\n        return 0\n    precedence = {'**': 4, '*': 3, '//': 3, '+': 2, '-': 1}\n    stack_operands = []\n    stack_operators = []\n    stack_operands.append(operands[0])\n    i = 0\n    while i < len(operators):\n        current_op = operators[i]\n        while stack_operators and precedence.get(stack_operators[-1], 0) >= precedence.get(current_op, 0):\n            op = stack_operators.pop()\n            b = stack_operands.pop()\n            a = stack_operands.pop()\n            if op == '+':\n                stack_operands.append(a + b)\n            elif op == '-':\n                stack_operands.append(a - b)\n            elif op == '*':\n                stack_operands.append(a * b)\n            elif op == '//':\n                stack_operands.append(a // b)\n            elif op == '**':\n                stack_operands.append(a ** b)\n        stack_operators.append(current_op)\n        stack_operands.append(operands[i + 1])\n        i += 1\n    while stack_operators:\n        op = stack_operators.pop()\n        b = stack_operands.pop()\n        a = stack_operands.pop()\n        if op == '+':\n            stack_operands.append(a + b)\n        elif op == '-':\n            stack_operands.append(a - b)\n        elif op == '*':\n            stack_operands.append(a * b)\n        elif op == '//':\n            stack_operands.append(a // b)\n        elif op == '**':\n            stack_operands.append(a ** b)\n    return stack_operands[0]", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    precedence = {'**': 4, '*': 3, '//': 3, '+': 2, '-': 2}\n    operand_stack = []\n    operator_stack = []\n    operand_stack.append(operands[0])\n    for i in range(len(operators)):\n        current_operator = operators[i]\n        current_operand = operands[i + 1]\n        while operator_stack and precedence.get(operator_stack[-1], 0) >= precedence.get(current_operator, 0):\n            operator = operator_stack.pop()\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            if operator == '+':\n                result = operand1 + operand2\n            elif operator == '-':\n                result = operand1 - operand2\n            elif operator == '*':\n                result = operand1 * operand2\n            elif operator == '//':\n                result = operand1 // operand2\n            elif operator == '**':\n                result = operand1 ** operand2\n            else:\n                raise ValueError(f'Unsupported operator: {operator}')\n            operand_stack.append(result)\n        operator_stack.append(current_operator)\n        operand_stack.append(current_operand)\n    while operator_stack:\n        operator = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n        if operator == '+':\n            result = operand1 + operand2\n        elif operator == '-':\n            result = operand1 - operand2\n        elif operator == '*':\n            result = operand1 * operand2\n        elif operator == '//':\n            result = operand1 // operand2\n        elif operator == '**':\n            result = operand1 ** operand2\n        else:\n            raise ValueError(f'Unsupported operator: {operator}')\n        operand_stack.append(result)\n    return operand_stack[0]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return the numbers between a and b\n    (inclusive) that are composed entirely of even digits, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_even_digits(n: int) -> bool:\n        for digit in str(n):\n            if int(digit) % 2 != 0:\n                return False\n        return True\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start = min(a, b)\n    end = max(a, b)\n    result = [num for num in range(start, end + 1) if is_all_even_digits(num)]\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        for digit in str(n):\n            if int(digit) % 2 != 0:\n                return False\n        return True\n    start = min(a, b)\n    end = max(a, b)\n    result = [num for num in range(start, end + 1) if is_all_even_digits(num)]\n    return sorted(result)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}

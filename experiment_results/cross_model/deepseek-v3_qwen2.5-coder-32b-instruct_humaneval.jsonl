{"task_id": "HumanEval/1", "requirement": "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \n    Input to this function is a string containing multiple groups of nested parentheses. \n    The function separates these groups into individual balanced parentheses strings and returns them as a list. \n    Each group is balanced (each opening parenthesis is properly closed) and not nested within another group. \n    Spaces in the input string are ignored and should not be included in the output. \n    The function processes the string sequentially, identifying groups by tracking the depth of nesting using a stack.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            depth += 1\n        if depth > 0:\n            current_group.append(char)\n        if char == ')':\n            depth -= 1\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            depth += 1\n        if depth > 0:\n            current_group.append(char)\n        if char == ')':\n            depth -= 1\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n        current_group.append(char)\n        if depth == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            depth += 1\n        if depth > 0:\n            current_group.append(char)\n        if char == ')':\n            depth -= 1\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/10", "requirement": "def is_palindrome(string: str) -> bool:\n    \"\"\"Test if the given string is a palindrome.\"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that begins with the supplied string by appending the reverse of the prefix before the longest palindromic suffix.\n    \n    The algorithm works as follows:\n    1. Identify the longest palindromic suffix in the supplied string.\n    2. Append the reverse of the prefix that comes before this palindromic suffix to the original string.\n    3. Return the resulting string, which is the shortest palindrome starting with the supplied string.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/11", "requirement": "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s. The function performs a binary XOR operation on the corresponding characters of the two strings. If the strings are of different lengths, the operation is performed only on the overlapping parts, and the extra characters in the longer string are ignored. The result is returned as a string.\n    >>> string_xor('010', '110')\n    '100'\n    >>> string_xor('101', '11')\n    '01'\n    \"\"\"", "generated_programs": ["def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = '1' if a[i] != b[i] else '0'\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/13", "requirement": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b as a non-negative integer.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(6, -4)\n    2\n    \"\"\"", "generated_programs": ["def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/32", "requirement": "from typing import List\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/43", "requirement": "from typing import List\n\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, where distinct elements are defined as having different values.\n    The pair (0, 0) is considered a valid pair that sums to zero.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2.0\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2.0\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return l[mid]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/54", "requirement": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same set of unique characters, regardless of the frequency of each character.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"", "generated_programs": ["def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/67", "requirement": "def fruit_distribution(s: str, n: int) -> int:\n    \"\"\"\n    Given a string `s` that describes the number of apples and oranges in a basket, and an integer `n` \n    representing the total number of fruits in the basket, return the number of mango fruits in the basket.\n    \n    The string `s` will contain the number of apples and oranges in the format \"X apples and Y oranges\", \n    where X and Y are non-negative integers. If either \"apples\" or \"oranges\" is missing from the string, \n    the corresponding count is assumed to be 0.\n    \n    The number of mango fruits is calculated by subtracting the number of apples and oranges from the total \n    number of fruits `n`.\n    \n    Examples:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) -> 8\n    fruit_distribution(\"0 apples and 1 oranges\", 3) -> 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 95\n    fruit_distribution(\"100 apples and 1 oranges\", 120) -> 19\n    \"\"\"", "generated_programs": ["def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - (apples + oranges)", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/76", "requirement": "def is_simple_power(x: int, n: int) -> bool:\n    \"\"\"Your task is to write a function that returns true if a number x is a simple power of n and false in other cases.\n    x is a simple power of n if there exists a non-negative integer k such that n^k = x.\n    Specifically:\n    - If n == 1, x must also be 1 to return True.\n    - For other values of n, the function iteratively calculates n^k until n^k >= x. If n^k == x, it returns True; otherwise, False.\n    - The function assumes x and n are non-negative integers.\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"", "generated_programs": ["def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    '''\n    Write a function that takes an integer a and returns True \n    if this integer is a perfect cube of some integer number. \n    A perfect cube is an integer that can be expressed as the cube of another integer, \n    including negative integers and zero. The function should compute the cube root of the input, \n    round it to the nearest integer, and then check if cubing this rounded integer equals the original input.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "generated_programs": ["def iscube(a: int) -> bool:\n    import math\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    import math\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    import math\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    import math\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    from math import round\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    import math\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    import math\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    import math\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    import math\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    import math\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start with 1, end with 1, or both. \n    The count should include numbers that start with 1, end with 1, and those that both start and end with 1, \n    but the overlap (numbers that both start and end with 1) should be counted only once.\n    For n=1, the number 1 should be counted once since it both starts and ends with 1.\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return 9 * 10 ** (n - 2) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 9 * 10 ** (n - 2)\n    end_with_1 = 9 * 10 ** (n - 2)\n    start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 9 * 10 ** (n - 2)\n    end_with_1 = 9 * 10 ** (n - 2)\n    start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 9 * 10 ** (n - 2)\n    end_with_1 = 9 * 10 ** (n - 2)\n    start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return 9 * 10 ** (n - 2) + 9 * 10 ** (n - 2) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 9 * 10 ** (n - 2)\n    end_with_1 = 9 * 10 ** (n - 2)\n    start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 9 * 10 ** (n - 2)\n    end_with_1 = 9 * 10 ** (n - 2)\n    start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 9 * 10 ** (n - 2)\n    end_with_1 = 9 * 10 ** (n - 2)\n    start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 9 * 10 ** (n - 2)\n    end_with_1 = 9 * 10 ** (n - 2)\n    start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        start_with_1 = 9 * 10 ** (n - 2)\n        end_with_1 = 9 * 10 ** (n - 2)\n        start_and_end_with_1 = 10 ** (n - 2)\n        return start_with_1 + end_with_1 - start_and_end_with_1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string where each lowercase letter is shifted by 4 positions \n    in the alphabet, wrapping around if necessary. Uppercase letters and \n    other characters remain unchanged.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    encrypt('z') returns 'd'\n    encrypt('ABCDEF') returns 'ABCDEF'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = (ord(char) - ord('a') + 4) % 26 + ord('a')\n            result.append(chr(shifted))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = (ord(char) - ord('a') + 4) % 26 + ord('a')\n            result.append(chr(shifted))\n        else:\n            result.append(char)\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\", where\n    \"I\" is considered a word if it is followed by a space or is the end of the sentence.\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    >>> is_bored(\"I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.\")\n    20\n    \"\"\"", "generated_programs": ["def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n        elif stripped_sentence == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n        elif stripped_sentence == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n        elif stripped_sentence == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I ') or stripped_sentence == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n        elif stripped_sentence == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n        elif stripped_sentence == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n        elif stripped_sentence == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n        elif stripped_sentence == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n        elif stripped_sentence == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I ') or stripped_sentence == 'I':\n            count += 1\n    return count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message, and encodes it by swapping the case of all letters. \n    Additionally, replace all vowels in the message with the letter that appears 2 places ahead \n    of that vowel in the English alphabet. If the replacement character goes beyond 'z' or 'Z', \n    it wraps around to the beginning of the alphabet. The case of the replacement character should \n    be swapped as well. Assume the input contains only letters.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted_vowels = 'cgkqwCGKQW'\n        return shifted_vowels[vowels.index(c)] if c in vowels else c\n    return ''.join((shift_vowel(c).swapcase() for c in message))", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted_vowels = 'cgkqwCGKQW'\n        return shifted_vowels[vowels.index(c)] if c in vowels else c\n    return ''.join((shift_vowel(c).swapcase() for c in message))", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'c', 'A': 'C', 'e': 'g', 'E': 'G', 'i': 'k', 'I': 'K', 'o': 'q', 'O': 'Q', 'u': 'w', 'U': 'W'}\n    encoded_message = ''\n    for char in message:\n        if char in vowels:\n            new_char = shift[char]\n        else:\n            new_char = char\n        encoded_message += new_char.swapcase()\n    return encoded_message", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    result = []\n    for char in message:\n        if char in vowels:\n            new_char = shift[char]\n        else:\n            new_char = char\n        result.append(new_char.swapcase())\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return shifted.get(c, c)\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            swapped_case = char.swapcase()\n            shifted_char = shift_vowel(swapped_case)\n            encoded_message.append(shifted_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return shifted.get(c, c)\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            new_char = shift_vowel(char)\n            encoded_message.append(new_char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            new_char = shift[char]\n        else:\n            new_char = char\n        encoded_message.append(new_char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted_vowels = 'cgkqwCGKQW'\n        return shifted_vowels[vowels.index(c)] if c in vowels else c\n    return ''.join((shift_vowel(c).swapcase() for c in message))", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'c', 'A': 'C', 'e': 'g', 'E': 'G', 'i': 'k', 'I': 'K', 'o': 'q', 'O': 'Q', 'u': 'w', 'U': 'W'}\n    encoded_message = ''\n    for char in message:\n        if char in vowels:\n            new_char = shift[char]\n        else:\n            new_char = char\n        encoded_message += new_char.swapcase()\n    return encoded_message", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'c', 'A': 'C', 'e': 'g', 'E': 'G', 'i': 'k', 'I': 'K', 'o': 'q', 'O': 'Q', 'u': 'w', 'U': 'W'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            new_char = shift[char]\n        else:\n            new_char = char\n        encoded_message.append(new_char.swapcase())\n    return ''.join(encoded_message)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    Each subsequent level has 2 more stones than the previous level, ensuring that all levels maintain the same parity (odd or even) as the starting number n.\n    Return the number of stones in each level in a list, where the element at index i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(4)\n    [4, 6, 8, 10]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/101", "requirement": "from typing import List\n\n\ndef words_string(s: str) -> List[str]:\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    - Leading and trailing spaces or commas should be stripped before processing.\n    - If the string is empty or consists only of spaces or commas, return an empty list.\n    - Multiple consecutive delimiters (commas or spaces) should be treated as a single delimiter.\n    - Empty strings resulting from splitting at the boundaries or multiple consecutive delimiters should be excluded from the final list.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip().replace(',', ' ')\n    return [word for word in s.split(' ') if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.strip().split(', ') if word] or [word for word in s.strip().split(' ') if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip().strip(',')\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.strip().split(', ') if word] or [word for word in s.strip().split(' ') if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.strip().split(', ') if word] or [word for word in s.strip().split(' ') if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip().replace(',', ' ')\n    words = [word for word in s.split(' ') if word]\n    return words", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip().strip(',')\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip().replace(',', ' ')\n    return [word for word in s.split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip().replace(',', ' ')\n    return [word for word in s.split(' ') if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip().replace(',', ' ')\n    words = [word for word in s.split(' ') if word]\n    return words"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.09999999999999998, "original_passk": 1.0}}
{"task_id": "HumanEval/102", "requirement": "def choose_num(x: int, y: int) -> int:\n    \"\"\"This function takes two positive integers x and y and returns the largest even integer within the range [x, y] inclusive. If x is greater than y, or if there are no even numbers in the range, the function returns -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"", "generated_programs": ["def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    For negative numbers, only the first digit of the absolute value is negated, \n    and the rest of the digits remain positive. For example, -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(num)\n        if num_str[0] == '-':\n            return -int(num_str[1]) + sum((int(digit) for digit in num_str[2:]))\n        else:\n            return sum((int(digit) for digit in num_str))\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(num)\n        if num_str[0] == '-':\n            return -int(num_str[1]) + sum((int(digit) for digit in num_str[2:]))\n        else:\n            return sum((int(digit) for digit in num_str))\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(num)\n        if num_str[0] == '-':\n            return -int(num_str[1]) + sum((int(digit) for digit in num_str[2:]))\n        else:\n            return sum((int(digit) for digit in num_str))\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(n: int) -> int:\n        n_str = str(n)\n        if n_str[0] == '-':\n            return -int(n_str[0] + n_str[1]) + sum((int(digit) for digit in n_str[2:]))\n        else:\n            return sum((int(digit) for digit in n_str))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(num)\n        if num_str[0] == '-':\n            return -int(num_str[0] + num_str[1]) + sum((int(digit) for digit in num_str[2:]))\n        else:\n            return sum((int(digit) for digit in num_str))\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(num)\n        if num_str[0] == '-':\n            return -int(num_str[0] + num_str[1]) + sum((int(digit) for digit in num_str[2:]))\n        else:\n            return sum((int(digit) for digit in num_str))\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(num)\n        if num_str[0] == '-':\n            return -int(num_str[0] + num_str[1]) + sum((int(digit) for digit in num_str[2:]))\n        else:\n            return sum((int(digit) for digit in num_str))\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(num)\n        if num_str[0] == '-':\n            return -int(num_str[0] + num_str[1]) + sum((int(digit) for digit in num_str[2:]))\n        else:\n            return sum((int(digit) for digit in num_str))\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(num)\n        if num_str[0] == '-':\n            return -int(num_str[0] + num_str[1]) + sum((int(digit) for digit in num_str[2:]))\n        else:\n            return sum((int(digit) for digit in num_str))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        str_num = str(num)\n        if str_num[0] == '-':\n            return -int(str_num[1]) + sum((int(digit) for digit in str_num[2:]))\n        else:\n            return sum((int(digit) for digit in str_num))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.4, "original_passk": 0.11111111111111116}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of integers according to the number of ones in their binary representation in ascending order. \n    For non-negative integers, the number of ones is counted directly in their binary representation. \n    For negative integers, the number of ones is counted in their 32-bit binary representation (using a bitwise AND operation with 4294967295).\n    For integers with the same number of ones, sort based on their decimal value in ascending order.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        if x >= 0:\n            return bin(x).count('1')\n        else:\n            return bin(x & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        if x >= 0:\n            return bin(x).count('1')\n        else:\n            return bin(x & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        if x >= 0:\n            return bin(x).count('1')\n        else:\n            return bin(x & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        if x >= 0:\n            return bin(x).count('1')\n        else:\n            return bin(x & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        if x >= 0:\n            return bin(x).count('1')\n        else:\n            return bin(x & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        if x >= 0:\n            return bin(x).count('1')\n        else:\n            return bin(x & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "HumanEval/120", "requirement": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array arr of integers and a non-negative integer k, return a sorted list \n    of length k containing the maximum k numbers from arr. The list should be sorted \n    in ascending order. If k is 0, return an empty list.\n\n    The function first selects the maximum k numbers from arr, then sorts these selected \n    numbers in ascending order to produce the final result.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr)[-k:])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2, regardless of whether the year is a leap year.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/125", "requirement": "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on any whitespace (including spaces, tabs, and newlines).\n    If no whitespaces exist in the text, split on commas ','. If no commas exist, return the number of lowercase letters\n    whose position in the alphabet is odd, where 'a' is position 0, 'b' is position 1, ..., 'z' is position 25.\n    Examples\n    split_words(\"Hello world!\")  [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\")  [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "HumanEval/127", "requirement": "def intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two closed intervals, where each interval is a pair of integers (start, end) with start <= end.\n    The intersection of the two intervals is the set of all integers that are common to both intervals.\n    If the intervals do not intersect, return \"NO\".\n    If they intersect, calculate the length of the intersection as (intersection_end - intersection_start).\n    If the length is a prime number, return \"YES\"; otherwise, return \"NO\".\n    \n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    intersection_length = end - start\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a unique value in the range [1, N * N].\n\n    Find the lexicographically smallest path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighboring cells\n    that share an edge with the current cell. The path must consist of exactly k cells,\n    and cells can be revisited. The path must stay within the grid boundaries.\n\n    A path A is considered lexicographically smaller than path B if there exists an index i\n    such that A[i] < B[i] and for all j < i, A[j] = B[j]. It is guaranteed that the answer is unique.\n\n    Return an ordered list of the values on the cells that the lexicographically smallest path visits.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path[:]\n        min_found = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [grid[nx][ny]]\n                candidate = dfs(nx, ny, new_path)\n                if candidate:\n                    if min_found is None or candidate < min_found:\n                        min_found = candidate\n        return min_found\n    min_path = None\n    for i in range(N):\n        for j in range(N):\n            start_path = [grid[i][j]]\n            candidate_path = dfs(i, j, start_path)\n            if min_path is None or candidate_path < min_path:\n                min_path = candidate_path\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from heapq import heappush, heappop\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    for start_x in range(N):\n        for start_y in range(N):\n            pq = [(grid[start_x][start_y], start_x, start_y, [grid[start_x][start_y]])]\n            while pq:\n                value, x, y, path = heappop(pq)\n                if len(path) == k:\n                    if min_path is None or path < min_path:\n                        min_path = path\n                    continue\n                for dx, dy in directions:\n                    nx, ny = (x + dx, y + dy)\n                    if is_valid(nx, ny):\n                        new_path = path + [grid[nx][ny]]\n                        heappush(pq, (grid[nx][ny], nx, ny, new_path))\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from heapq import heappush, heappop\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    min_start_value = min((min(row) for row in grid))\n    start_positions = [(i, j) for i in range(N) for j in range(N) if grid[i][j] == min_start_value]\n    for sx, sy in start_positions:\n        dfs(sx, sy, [grid[sx][sy]])\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from heapq import heappush, heappop\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heappush(pq, (grid[i][j], [(i, j)]))\n    while pq:\n        current_value, path = heappop(pq)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        last_x, last_y = path[-1]\n        for dx, dy in directions:\n            new_x, new_y = (last_x + dx, last_y + dy)\n            if is_valid(new_x, new_y):\n                new_path = path + [(new_x, new_y)]\n                new_value = current_value * (N * N) + grid[new_x][new_y]\n                heappush(pq, (new_value, new_path))", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from heapq import heappush, heappop\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    min_start_value = min((min(row) for row in grid))\n    start_positions = [(i, j) for i in range(N) for j in range(N) if grid[i][j] == min_start_value]\n    for sx, sy in start_positions:\n        dfs(sx, sy, [grid[sx][sy]])\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    return min_path"], "result": {"repaired_passk": 0.5, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/130", "requirement": "def tri(n: int) -> List[float]:\n    \"\"\"Generate the first n + 1 numbers of a custom sequence defined as follows:\n    - tri(0) = 1\n    - tri(1) = 3\n    - For even n > 1, tri(n) = 1 + n / 2\n    - For odd n > 1, tri(n) = tri(n - 1) + tri(n - 2) + (1 + (n + 1) / 2 if (n + 1) is even else tri(n + 1))\n    \n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                next_value += 1 + (i + 2) / 2\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                next_next_value = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0\n                next_value += sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2 if (i + 2) % 2 == 0 else next_next_value)\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n < 0:\n        return []\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                pass\n            sequence.append(next_value)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                predicted_next = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else sequence[i - 1] + sequence[i - 2] + (1 + (i + 3) / 2 if (i + 3) % 2 == 0 else 0)\n                next_value += predicted_next\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                next_value += 1 + (i + 2) / 2\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                next_value += 1 + (i + 2) / 2\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                predicted_next = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else sequence[i - 1] + sequence[i - 2] + (1 + (i + 3) / 2 if (i + 3) % 2 == 0 else 0)\n                next_value += predicted_next\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                predicted_next_next_value = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0\n                next_value += sequence[i - 1] + sequence[i - 2] + (1 + (i + 1) / 2 if (i + 1) % 2 == 0 else predicted_next_next_value)\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i] + sequence[i - 1] + (1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is at least one pair of square brackets \n    that is nested within another pair of square brackets. A pair of brackets is considered nested \n    if there is at least one '[' that is closed by a ']' and there is another '[' in between them.\n\n    is_nested('[[]]')  True\n    is_nested('[]]]]]]][[[[[]')  False\n    is_nested('[][]')  False\n    is_nested('[]')  False\n    is_nested('[[][]]')  True\n    is_nested('[[]][[')  True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if max_depth > 1:\n            return True\n    return False", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if max_depth > 1:\n            return True\n    return False", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if max_depth > 1:\n            return True\n    return False", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if max_depth > 1:\n            return True\n    return False", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/140", "requirement": "def fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, replace all single spaces with underscores, \n    and replace sequences of three or more consecutive spaces with a single '-'.\n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"", "generated_programs": ["def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    result = []\n    i = 0\n    while i < len(text):\n        if text[i] == ' ':\n            space_count = 0\n            while i < len(text) and text[i] == ' ':\n                space_count += 1\n                i += 1\n            if space_count == 1:\n                result.append('_')\n            elif space_count >= 3:\n                result.append('-')\n        else:\n            result.append(text[i])\n            i += 1\n    return ''.join(result)", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "def fix_spaces(text: str) -> str:\n    result = []\n    i = 0\n    while i < len(text):\n        if text[i] == ' ':\n            space_count = 0\n            while i < len(text) and text[i] == ' ':\n                space_count += 1\n                i += 1\n            if space_count == 1:\n                result.append('_')\n            elif space_count >= 3:\n                result.append('-')\n        else:\n            result.append(text[i])\n            i += 1\n    return ''.join(result)", "def fix_spaces(text: str) -> str:\n    result = []\n    i = 0\n    while i < len(text):\n        if text[i] == ' ':\n            space_count = 0\n            while i < len(text) and text[i] == ' ':\n                space_count += 1\n                i += 1\n            if space_count == 1:\n                result.append('_')\n            elif space_count >= 3:\n                result.append('-')\n        else:\n            result.append(text[i])\n            i += 1\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 1.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/153", "requirement": "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is calculated as the difference between the number\n    of uppercase letters (CAP) and the number of lowercase letters (SM) in the\n    extension's name, i.e., strength = CAP - SM. You should find the strongest\n    extension and return a string in this format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that appears first in the list.\n    The function assumes that the list of extensions is non-empty. If an empty list\n    is provided, the function will raise an IndexError.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for char in extension if char.isupper()))\n        sm_count = sum((1 for char in extension if char.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    max_strength = float('-inf')\n    strongest_extension = ''\n    for extension in extensions:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        strength = cap_count - sm_count\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for char in extension if char.isupper()))\n        sm_count = sum((1 for char in extension if char.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for char in extension if char.isupper()))\n        sm_count = sum((1 for char in extension if char.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if the second word is empty or if any of its rotations is a substring in the first word.\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    bb = b + b\n    return any((a[i:i + len(b)] in bb for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    bb = b + b\n    return any((a[i:i + len(b)] in bb for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    doubled_b = b + b\n    return any((a[i:i + len(b)] == doubled_b[j:j + len(b)] for i in range(len(a) - len(b) + 1) for j in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    double_b = b + b\n    return any((a[i:i + len(b)] == b for i in range(len(a) - len(b) + 1))) or any((double_b[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    bb = b + b\n    return any((a[i:i + len(b)] == b for i in range(len(a) - len(b) + 1))) or any((bb[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    bb = b + b\n    return any((a[i:i + len(b)] == b for i in range(len(a) - len(b) + 1))) or any((bb[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    bb = b + b\n    return any((a[i:i + len(b)] in bb for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    bb = b + b\n    return any((a[i:i + len(b)] == b for i in range(len(a) - len(b) + 1))) or any((bb[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    doubled_b = b + b\n    return any((a[i:i + len(b)] == doubled_b[j:j + len(b)] for i in range(len(a) - len(b) + 1) for j in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    bb = b + b\n    return any((a[i:i + len(b)] == b for i in range(len(a) - len(b) + 1))) or any((bb[i:i + len(b)] in a for i in range(len(b))))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "HumanEval/160", "requirement": "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists operator, and operand. The first list contains basic algebra operations, and \n    the second list is a list of integers. Construct the algebraic expression by combining the \n    operators and operands in the order they appear, and evaluate the expression respecting the \n    standard order of operations (PEMDAS/BODMAS). Return the result of the evaluation.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\nimport operator as op\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    ops = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}\n    expression = list(zip(operators, operands[1:]))\n    i = 0\n    while i < len(expression):\n        if expression[i][0] == '**':\n            operands[i] = ops['**'](operands[i], expression[i][1])\n            del expression[i]\n        else:\n            i += 1\n    i = 0\n    while i < len(expression):\n        if expression[i][0] in ('*', '//'):\n            operands[i] = ops[expression[i][0]](operands[i], expression[i][1])\n            del expression[i]\n        else:\n            i += 1\n    result = operands[0]\n    for op_str, num in expression:\n        result = ops[op_str](result, num)\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "def generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return a list of integers between the smaller and larger of a and b (inclusive) \n    where all digits of the integer are even. The list should be in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    even_digit_numbers = [num for num in range(start, end + 1) if all((int(digit) % 2 == 0 for digit in str(num)))]\n    return even_digit_numbers", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all((int(digit) % 2 == 0 for digit in str(num)))]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all((int(digit) % 2 == 0 for digit in str(num)))]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all((int(digit) % 2 == 0 for digit in str(num)))]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all((int(digit) % 2 == 0 for digit in str(num)))]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all((int(digit) % 2 == 0 for digit in str(num)))]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    even_digit_numbers = [num for num in range(start, end + 1) if all((int(digit) % 2 == 0 for digit in str(num)))]\n    return even_digit_numbers", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/1", "requirement": "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \n    Input to this function is a string containing multiple groups of nested parentheses. \n    The function separates these groups into individual balanced parentheses strings and returns them as a list. \n    Each group is balanced (each opening parenthesis is properly closed) and not nested within any other group. \n    Spaces in the input string are ignored and should not be included in the output.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that begins with the supplied string by appending the reverse of the prefix before the longest palindromic suffix.\n    \n    The function works as follows:\n    - It iterates through the string to find the longest palindromic suffix starting at each index.\n    - Once the longest palindromic suffix is found, it appends the reverse of the prefix that precedes this suffix to the end of the string.\n    - This ensures the resulting string is the shortest possible palindrome that begins with the supplied string.\n    \n    Examples:\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/11", "requirement": "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s. The strings can be of different lengths.\n    Perform binary XOR on the corresponding characters of these inputs and return the result as a string.\n    If the strings are of different lengths, only the overlapping part is considered, and the rest is ignored.\n    >>> string_xor('010', '110')\n    '100'\n    >>> string_xor('101', '11')\n    '01'\n    \"\"\"", "generated_programs": ["def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_value = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_value)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = '1' if a[i] != b[i] else '0'\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/13", "requirement": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b. The result is always non-negative, regardless of the signs of the inputs.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(6, -4)\n    2\n    \"\"\"", "generated_programs": ["def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/32", "requirement": "from typing import List\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/43", "requirement": "from typing import List\n\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list (at different positions) that\n    sum to zero, and False otherwise. This includes the case where both elements are zero.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2.0\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2.0\n    else:\n        return sorted_l[mid]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/54", "requirement": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words contain exactly the same set of characters, regardless of the frequency or order of the characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"", "generated_programs": ["def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/67", "requirement": "def fruit_distribution(s: str, n: int) -> int:\n    \"\"\"\n    Given a string `s` that describes the number of apples and oranges in a basket, and an integer `n` \n    representing the total number of fruits in the basket, return the number of mango fruits in the basket.\n    \n    The string `s` will contain the number of apples and oranges in the format \"X apples and Y oranges\", \n    where X and Y are non-negative integers. If either \"apples\" or \"oranges\" is missing from the string, \n    the corresponding count is assumed to be 0.\n    \n    The number of mango fruits is calculated by subtracting the number of apples and oranges from the total \n    number of fruits `n`.\n    \n    Examples:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) -> 8\n    fruit_distribution(\"0 apples and 1 oranges\", 3) -> 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 95\n    fruit_distribution(\"100 apples and 1 oranges\", 120) -> 19\n    \"\"\"", "generated_programs": ["def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - (apples + oranges)", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/76", "requirement": "def is_simple_power(x: int, n: int) -> bool:\n    \"\"\"Your task is to write a function that returns true if a number x is a simple power of n and false in other cases.\n    x is a simple power of n if there exists a non-negative integer k such that n^k = x.\n    The function assumes that x and n are positive integers.\n    Special cases:\n    - If n is 1, the function returns true only if x is also 1.\n    - If x is 0, the function returns false.\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"", "generated_programs": ["def is_simple_power(x: int, n: int) -> bool:\n    if x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n        if power == x:\n            return True\n    return False", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    '''\n    Write a function that takes an integer a and returns True \n    if this integer is a perfect cube of some integer number, \n    considering both positive and negative inputs. \n    The function should correctly handle edge cases such as zero and negative numbers.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "generated_programs": ["def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start with 1, end with 1, or both. \n    Specifically, for n = 1, the count should be 1 since the only 1-digit number is 1 itself.\n    \n    The count is calculated by adding the numbers that start with 1 and the numbers that end with 1,\n    then subtracting the overlap (numbers that both start and end with 1) to avoid double-counting.\n    For n > 1, the formula used is: 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2).\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function `encrypt` that takes a string as an argument and returns a new string where each lowercase letter is shifted by 4 positions in the alphabet. The shift wraps around the alphabet, so 'z' becomes 'd'. Non-lowercase characters, including uppercase letters, remain unchanged.\n\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    encrypt('z') returns 'd'\n    encrypt('ABCDEF') returns 'ABCDEF'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = (ord(char) - ord('a') + 4) % 26 + ord('a')\n            result.append(chr(shifted))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = (ord(char) - ord('a') + 4) % 26 + ord('a')\n            result.append(chr(shifted))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\" as the first word, \n    where words are separated by spaces. Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"", "generated_programs": ["def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('?')\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('!')\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('?')\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('!')\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('?')\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('!')\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('?')\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('!')\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('?')\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('!')\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('?')\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    sentences = S.split('!')\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0] == 'I':\n            count += 1\n    return count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message, and encodes it by swapping the case of all letters. \n    For vowels (both lowercase and uppercase), replace each vowel with the letter that appears \n    2 places ahead of that vowel in the English alphabet. If the replacement character goes \n    beyond 'z' or 'Z', wrap around to the beginning of the alphabet. The case of the replacement \n    character should be the opposite of the original vowel. Non-vowel characters should only \n    have their case swapped. Assume the input contains only letters.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    result = []\n    for char in message:\n        if char in vowels:\n            result.append(shift[char])\n        else:\n            result.append(char.swapcase())\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n        return shifted.get(c, c)\n    encoded_message = []\n    for char in message:\n        if char in 'aeiouAEIOU':\n            encoded_message.append(shift_vowel(char))\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(shift[char])\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(shift[char])\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(shift[char])\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(shift[char])\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'C', 'A': 'c', 'e': 'G', 'E': 'g', 'i': 'K', 'I': 'k', 'o': 'Q', 'O': 'q', 'u': 'W', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(shift[char])\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            encoded_message.append(shift[char])\n        else:\n            encoded_message.append(char.swapcase())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'C', 'A': 'c', 'e': 'G', 'E': 'g', 'i': 'K', 'I': 'k', 'o': 'Q', 'O': 'q', 'u': 'W', 'U': 'w'}\n    result = []\n    for char in message:\n        if char in vowels:\n            result.append(shift[char])\n        else:\n            result.append(char.swapcase())\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        if c in vowels:\n            if c.islower():\n                base = ord('a')\n            else:\n                base = ord('A')\n            new_char = chr((ord(c) - base + 2) % 26 + base)\n            return new_char.upper() if c.islower() else new_char.lower()\n        return c\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            if char in 'aeiouAEIOU':\n                encoded_message.append(shift_vowel(char))\n            else:\n                encoded_message.append(char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a non-negative integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is determined by adding 2 to the current number of stones,\n    regardless of whether the current number is odd or even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n    If n is 0, return an empty list.\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(0)\n    []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    pile = [n]\n    for _ in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/101", "requirement": "from typing import List\n\n\ndef words_string(s: str) -> List[str]:\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words. Leading and trailing\n    whitespace should be stripped before processing, and multiple consecutive commas or spaces\n    should be treated as a single delimiter. If the stripped string is empty, return an empty list.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"", "generated_programs": ["from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return [word for word in s.split(', ') if word] or s.split()", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return [word for word in s.split(', ') if word] or s.split()", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return [word for word in s.replace(',', ' ').split() if word]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.11111111111111116, "original_passk": 1.0}}
{"task_id": "HumanEval/102", "requirement": "def choose_num(x: int, y: int) -> int:\n    \"\"\"This function takes two positive integers x and y and returns the largest even integer within the range [x, y] inclusive. If x is greater than y, or if there are no even numbers in the range, the function returns -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"", "generated_programs": ["def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    For negative numbers, only the first digit is considered negative when summing the digits.\n    For example, -123 has signed digits -1, 2, and 3, and their sum is -1 + 2 + 3 = 4.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        is_negative = num < 0\n        num_str = str(abs(num))\n        digit_sum = sum((int(digit) for digit in num_str))\n        if is_negative:\n            digit_sum = digit_sum - 2 * int(num_str[0])\n        return digit_sum\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num < 0:\n            return -int(str(num)[1]) + sum((int(digit) for digit in str(num)[2:]))\n        else:\n            return sum((int(digit) for digit in str(num)))\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num < 0:\n            return -int(str(num)[1]) + sum((int(digit) for digit in str(num)[2:]))\n        else:\n            return sum((int(digit) for digit in str(num)))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        is_negative = num < 0\n        num = abs(num)\n        digits_sum = sum((int(digit) for digit in str(num)))\n        if is_negative:\n            digits_sum = digits_sum - 2 * int(str(num)[0])\n        return digits_sum\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num < 0:\n            return -int(str(num)[1]) + sum((int(digit) for digit in str(num)[2:]))\n        else:\n            return sum((int(digit) for digit in str(num)))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num < 0:\n            return -int(str(num)[1]) + sum((int(digit) for digit in str(num)[2:]))\n        else:\n            return sum((int(digit) for digit in str(num)))\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        is_negative = num < 0\n        num = abs(num)\n        digits = [int(d) for d in str(num)]\n        if is_negative:\n            digits[0] *= -1\n        return sum(digits)\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        is_negative = n < 0\n        n = abs(n)\n        sum_digits = sum((int(digit) for digit in str(n)))\n        if is_negative:\n            sum_digits = sum_digits - 2 * int(str(n)[0])\n        return sum_digits\n    return sum((1 for num in arr if digit_sum(num) > 0))"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 0.11111111111111116}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sorts an array of integers based on the number of ones in their binary representation in ascending order.\n    For negative numbers, the bitwise NOT of the number is used to count the number of ones.\n    For similar number of ones, the elements are sorted based on their decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1') if x >= 0 else bin(~x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1') if x >= 0 else bin(~x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1') if x >= 0 else bin(~x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1') if x >= 0 else bin(~x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        if x >= 0:\n            return bin(x).count('1')\n        else:\n            return bin(~x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1') if x >= 0 else bin(~x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1') if x >= 0 else bin(~x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1') if x >= 0 else bin(~x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1') if x >= 0 else bin(~x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1') if x >= 0 else bin(~x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "HumanEval/120", "requirement": "from typing import List\n\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array arr of integers and a non-negative integer k, return a sorted list \n    of length k containing the maximum k numbers from arr in ascending order. \n    If k is 0, return an empty list.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr, reverse=True)\n    top_k = sorted_arr[:k]\n    return sorted(top_k)", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr, reverse=True)\n    top_k = sorted_arr[:k]\n    return sorted(top_k)", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(arr)[-k:]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2, regardless of whether the year is a leap year.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/125", "requirement": "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on spaces (' '), if no spaces exist in the text you\n    should split on commas (','). If neither spaces nor commas exist, return the number of lowercase letters with odd positions in the alphabet, where 'a' is position 0, 'b' is position 1, ..., 'z' is position 25. The position of a character is determined by its relative position in the alphabet, calculated as `ord(char) - ord('a')`, and oddness is checked on this relative position. Only lowercase letters are considered; uppercase letters and non-alphabetic characters are ignored.\n\n    Examples\n    split_words(\"Hello world!\")  [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\")  [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "HumanEval/127", "requirement": "def intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two closed intervals, where each interval is a pair of integers (start, end) with start <= end.\n    The intersection of the two intervals is the range [max(start1, start2), min(end1, end2)].\n    If the intervals do not overlap (i.e., max(start1, start2) > min(end1, end2)), return \"NO\".\n    Otherwise, calculate the length of the intersection as (min(end1, end2) - max(start1, start2)).\n    If the length is a prime number, return \"YES\"; otherwise, return \"NO\".\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersect = max(start1, start2)\n    end_intersect = min(end1, end2)\n    if start_intersect > end_intersect:\n        return 'NO'\n    length = end_intersect - start_intersect\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersection = max(start1, start2)\n    end_intersection = min(end1, end2)\n    if start_intersection > end_intersection:\n        return 'NO'\n    length = end_intersection - start_intersection\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersect = max(start1, start2)\n    end_intersect = min(end1, end2)\n    if start_intersect > end_intersect:\n        return 'NO'\n    length = end_intersect - start_intersect\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersect = max(start1, start2)\n    end_intersect = min(end1, end2)\n    if start_intersect > end_intersect:\n        return 'NO'\n    length = end_intersect - start_intersect\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersect = max(start1, start2)\n    end_intersect = min(end1, end2)\n    if start_intersect > end_intersect:\n        return 'NO'\n    length = end_intersect - start_intersect\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersection = max(start1, start2)\n    end_intersection = min(end1, end2)\n    if start_intersection > end_intersection:\n        return 'NO'\n    length = end_intersection - start_intersection\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersect = max(start1, start2)\n    end_intersect = min(end1, end2)\n    if start_intersect > end_intersect:\n        return 'NO'\n    length = end_intersect - start_intersect\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersect = max(start1, start2)\n    end_intersect = min(end1, end2)\n    if start_intersect > end_intersect:\n        return 'NO'\n    length = end_intersect - start_intersect\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersection = max(start1, start2)\n    end_intersection = min(end1, end2)\n    if start_intersection > end_intersection:\n        return 'NO'\n    length = end_intersection - start_intersection\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersect = max(start1, start2)\n    end_intersect = min(end1, end2)\n    if start_intersect > end_intersect:\n        return 'NO'\n    length = end_intersect - start_intersect\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given an N x N grid (N >= 2) where each cell contains a unique integer in the range [1, N * N], \n    find the lexicographically smallest path of length k. A path is a sequence of cells where each \n    consecutive cell is a neighbor (sharing an edge) of the previous cell. The path can start at any \n    cell and may revisit cells. The path's value is the ordered list of values from the cells it visits.\n\n    The path is considered lexicographically smaller if, when comparing the sequences of values, \n    the first differing value is smaller. It is guaranteed that the answer is unique.\n\n    The function uses a depth-first search (DFS) approach to explore all possible paths of length k, \n    starting from each cell in the grid. The DFS ensures that the lexicographically smallest path \n    is found by always choosing the smallest possible next step at each point in the path.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if new_path:\n                    if not min_path or new_path < min_path:\n                        min_path = new_path\n        return min_path\n    n = len(grid)\n    result = None\n    for i in range(n):\n        for j in range(n):\n            path = dfs(i, j, [grid[i][j]])\n            if not result or path < result:\n                result = path\n    return result", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if new_path:\n                    if not min_path or new_path < min_path:\n                        min_path = new_path\n        return min_path\n    result = None\n    for i in range(N):\n        for j in range(N):\n            path = dfs(i, j, [grid[i][j]])\n            if not result or path < result:\n                result = path\n    return result", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in sorted(directions, key=lambda d: grid[x + d[0]][y + d[1]] if 0 <= x + d[0] < N and 0 <= y + d[1] < N else float('inf')):\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if new_path:\n                    if not min_path or new_path < min_path:\n                        min_path = new_path\n        return min_path\n    overall_min_path = None\n    for i in range(N):\n        for j in range(N):\n            path = dfs(i, j, [grid[i][j]])\n            if not overall_min_path or path < overall_min_path:\n                overall_min_path = path\n    return overall_min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if new_path:\n                    if min_path is None or new_path < min_path:\n                        min_path = new_path\n        return min_path\n    result = None\n    for i in range(N):\n        for j in range(N):\n            path = dfs(i, j, [grid[i][j]])\n            if result is None or path < result:\n                result = path\n    return result", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if new_path:\n                    if min_path is None or new_path < min_path:\n                        min_path = new_path\n        return min_path\n    result = None\n    for i in range(N):\n        for j in range(N):\n            path = dfs(i, j, [grid[i][j]])\n            if result is None or path < result:\n                result = path\n    return result", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if new_path:\n                    if min_path is None or new_path < min_path:\n                        min_path = new_path\n        return min_path\n    result = None\n    for i in range(N):\n        for j in range(N):\n            path = dfs(i, j, [grid[i][j]])\n            if path:\n                if result is None or path < result:\n                    result = path\n    return result", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        neighbors = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                neighbors.append((grid[nx][ny], nx, ny))\n        neighbors.sort()\n        for _, nx, ny in neighbors:\n            result = dfs(nx, ny, path + [grid[nx][ny]])\n            if result:\n                return result\n        return None\n    n = len(grid)\n    min_path = None\n    for i in range(n):\n        for j in range(n):\n            path = dfs(i, j, [grid[i][j]])\n            if min_path is None or path < min_path:\n                min_path = path\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if new_path:\n                    if min_path is None or new_path < min_path:\n                        min_path = new_path\n        return min_path\n    n = len(grid)\n    min_lexicographic_path = None\n    for i in range(n):\n        for j in range(n):\n            path = dfs(i, j, [grid[i][j]])\n            if path:\n                if min_lexicographic_path is None or path < min_lexicographic_path:\n                    min_lexicographic_path = path\n    return min_lexicographic_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if new_path:\n                    if min_path is None or new_path < min_path:\n                        min_path = new_path\n        return min_path\n    n = len(grid)\n    min_lexicographic_path = None\n    for i in range(n):\n        for j in range(n):\n            path = dfs(i, j, [grid[i][j]])\n            if path:\n                if min_lexicographic_path is None or path < min_lexicographic_path:\n                    min_lexicographic_path = path\n    return min_lexicographic_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in sorted(directions, key=lambda d: grid[x + d[0]][y + d[1]] if 0 <= x + d[0] < N and 0 <= y + d[1] < N else float('inf')):\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if new_path:\n                    if not min_path or new_path < min_path:\n                        min_path = new_path\n        return min_path\n    overall_min_path = None\n    for i in range(N):\n        for j in range(N):\n            path = dfs(i, j, [grid[i][j]])\n            if path:\n                if not overall_min_path or path < overall_min_path:\n                    overall_min_path = path\n    return overall_min_path"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/130", "requirement": "def tri(n: int) -> List[float]:\n    \"\"\"Generate the first n + 1 numbers of a custom Tribonacci sequence.\n    \n    The sequence is defined as follows:\n    - tri(0) = 1\n    - tri(1) = 3\n    - For even n > 1, tri(n) = 1 + n / 2\n    - For odd n > 1, tri(n) = tri(n - 1) + tri(n - 2) + (1 + (n + 1) / 2 if (n + 1) is even else tri(n + 1))\n    \n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                predicted_next = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0\n                next_value += predicted_next\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = 1 + (i + 1) / 2 if (i + 1) % 2 == 0 else sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2)\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                predicted_next = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0\n                next_value += predicted_next\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                predicted_next_next_value = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0\n                next_value += sequence[i - 1] + sequence[i - 2] + (1 + (i + 1) / 2 if (i + 1) % 2 == 0 else predicted_next_next_value)\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i] + sequence[i - 1] + (1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                predicted_next = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0\n                next_value += predicted_next\n            sequence.append(next_value)\n    return sequence"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if the string contains at least one pair of square brackets that are nested within another pair of square brackets. \n    A pair of brackets is considered nested if there is at least one '[' that is closed by a ']' and is contained within another pair of '[' and ']'.\n\n    is_nested('[[]]')  True\n    is_nested('[]]]]]]][[[[[]')  False\n    is_nested('[][]')  False\n    is_nested('[]')  False\n    is_nested('[[][]]')  True\n    is_nested('[[]][[')  True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if max_depth > 1:\n            return True\n    return False", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if max_depth > 1:\n            return True\n    return False", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/140", "requirement": "def fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, replace all sequences of three or more consecutive spaces with a single dash '-'.\n    Then, replace all remaining single spaces with underscores '_'.\n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"", "generated_programs": ["def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text"], "result": {"repaired_passk": 0.7, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/153", "requirement": "from typing import List\n\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    \"\"\"Given the name of a class (a string) and a list of extensions, return the class name concatenated with the strongest extension.\n    \n    The strength of an extension is calculated as the difference between the number of uppercase letters (CAP) and the number of lowercase letters (SM) in the extension's name, i.e., strength = CAP - SM.\n    The strongest extension is the one with the highest strength value. If there are multiple extensions with the same strength, the first one in the list is chosen.\n    \n    If the list of extensions is empty, return the class name concatenated with an empty string (i.e., 'ClassName.').\n    \n    Example:\n    >>> Strongest_Extension('Slices', ['SErviNGSliCes', 'Cheese', 'StuFfed'])\n    'Slices.SErviNGSliCes'\n    >>> Strongest_Extension('my_class', ['AA', 'Be', 'CC'])\n    'my_class.AA'\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name + '.'\n    strongest_extension = ''\n    max_strength = float('-inf')\n    for extension in extensions:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        strength = cap_count - sm_count\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return class_name + '.' + strongest_extension", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name + '.'\n    strongest_extension = ''\n    max_strength = float('-inf')\n    for extension in extensions:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        strength = cap_count - sm_count\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return class_name + '.' + strongest_extension", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name + '.'\n    strongest_extension = ''\n    max_strength = float('-inf')\n    for extension in extensions:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        strength = cap_count - sm_count\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return class_name + '.' + strongest_extension", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name + '.'\n    strongest_extension = ''\n    max_strength = float('-inf')\n    for extension in extensions:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        strength = cap_count - sm_count\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return class_name + '.' + strongest_extension", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name + '.'\n    strongest_extension = ''\n    max_strength = float('-inf')\n    for extension in extensions:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        strength = cap_count - sm_count\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return class_name + '.' + strongest_extension", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name + '.'\n    strongest_extension = ''\n    max_strength = float('-inf')\n    for extension in extensions:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        strength = cap_count - sm_count\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return class_name + '.' + strongest_extension", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name + '.'\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return class_name + '.' + strongest_extension", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name + '.'\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for char in extension if char.isupper()))\n        sm_count = sum((1 for char in extension if char.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return class_name + '.' + strongest_extension", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name + '.'\n    strongest_extension = ''\n    max_strength = float('-inf')\n    for extension in extensions:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        strength = cap_count - sm_count\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return class_name + '.' + strongest_extension", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name + '.'\n    strongest_extension = ''\n    max_strength = float('-inf')\n    for extension in extensions:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        strength = cap_count - sm_count\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return class_name + '.' + strongest_extension"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word. If the second word is an empty string, the function should return True.\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((a[i:i + len(b)] in b_double for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((a[i:i + len(b)] in b_double for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    doubled_b = b + b\n    return any((a[i:i + len(b)] in doubled_b for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    bb = b + b\n    return any((a[i:i + len(b)] == b for i in range(len(a) - len(b) + 1))) or any((bb[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((b_double[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((b_double[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((b_double[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((b_double[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((a[i:i + len(b)] in b_double for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((a[i:i + len(b)] in b_double for i in range(len(a) - len(b) + 1)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "HumanEval/160", "requirement": "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebraic \n    expression and return the evaluation of this expression. The expression should be evaluated \n    using standard operator precedence rules, where multiplication and division have higher \n    precedence than addition and subtraction.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\nimport operator as op\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    ops = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}\n\n    def precedence(op):\n        return {'+': 1, '-': 1, '*': 2, '//': 2, '**': 3}[op]\n\n    def apply_operator(operators, values):\n        operator = operators.pop()\n        right = values.pop()\n        left = values.pop()\n        values.append(ops[operator](left, right))\n    values = []\n    op_stack = []\n    for token in operators + ['end']:\n        while op_stack and token != 'end' and (precedence(op_stack[-1]) >= precedence(token)):\n            apply_operator(op_stack, values)\n        if token == 'end':\n            break\n        op_stack.append(token)\n    for i, operand in enumerate(operands):\n        values.append(operand)\n        if i < len(operators):\n            while op_stack and precedence(op_stack[-1]) > precedence(operators[i]):\n                apply_operator(op_stack, values)\n            op_stack.append(operators[i])\n    while op_stack:\n        apply_operator(op_stack, values)\n    return values[0]", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "def generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return all integers between the smaller and larger of the two numbers (inclusive) \n    that are even and consist solely of even digits, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and has_only_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/1", "requirement": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/10", "requirement": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/11", "requirement": "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs up to the length of the shorter string and return the result as a string.\n    If the input strings are of unequal length, the function will only perform XOR on the characters up to the length of the shorter string, ignoring any extra characters in the longer string.\n    >>> string_xor('010', '110')\n    '100'\n    >>> string_xor('101', '11')\n    '01'\n    \"\"\"", "generated_programs": ["def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = '1' if a[i] != b[i] else '0'\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = '1' if a[i] != b[i] else '0'\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)", "def string_xor(a: str, b: str) -> str:\n    min_length = min(len(a), len(b))\n    result = []\n    for i in range(min_length):\n        xor_result = str(int(a[i]) ^ int(b[i]))\n        result.append(xor_result)\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/13", "requirement": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b. The GCD is always a non-negative integer, regardless of the signs of the inputs.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(6, -4)\n    2\n    \"\"\"", "generated_programs": ["def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b != 0:\n        a, b = (b, a % b)\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = (abs(a), abs(b))\n    while b:\n        a, b = (b, a % b)\n    return a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/32", "requirement": "from typing import List\nimport math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... + xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\"\n    Finds a zero point of the polynomial with coefficients xs using Newton's method.\n    The function returns the first zero point found within 100 iterations or when the difference between successive approximations is less than 1e-06.\n    If the derivative of the polynomial at any point is zero, a ZeroDivisionError is raised.\n    The function does not explicitly check for the number of coefficients or the largest non-zero coefficient, and it assumes that the polynomial has at least one zero point.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/43", "requirement": "from typing import List\n\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two distinct elements in the list (i.e., elements at different positions)\n    that sum to zero, and False otherwise. This includes the case where both elements are zero (0, 0).\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for number in l:\n        if -number in seen:\n            return True\n        seen.add(number)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for number in l:\n        if -number in seen:\n            return True\n        seen.add(number)\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return the median of elements in the list l. \n    For a list with an odd number of elements, the median is the middle element when the list is sorted. \n    For a list with an even number of elements, the median is the average of the two middle elements.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return float(l[n // 2])\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2.0", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/54", "requirement": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the exact same set of characters, regardless of the frequency or order of those characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"", "generated_programs": ["def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/67", "requirement": "def fruit_distribution(s: str, n: int) -> int:\n    \"\"\"\n    Given a string `s` that describes the number of apples and oranges in a basket, and an integer `n` \n    representing the total number of fruits in the basket, return the number of mango fruits in the basket.\n    \n    The string `s` will contain the number of apples and oranges in the format \"X apples and Y oranges\", \n    where X and Y are non-negative integers. If either \"apples\" or \"oranges\" is missing from the string, \n    the corresponding count is assumed to be 0.\n    \n    The number of mango fruits is calculated by subtracting the number of apples and oranges from the total \n    number of fruits `n`.\n    \n    Examples:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) -> 8\n    fruit_distribution(\"0 apples and 1 oranges\", 3) -> 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 95\n    fruit_distribution(\"100 apples and 1 oranges\", 120) -> 19\n    \"\"\"", "generated_programs": ["def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - (apples + oranges)", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[0]) if 'apples' in s else 0\n    oranges = int(parts[3]) if 'oranges' in s else 0\n    return n - apples - oranges", "def fruit_distribution(s: str, n: int) -> int:\n    parts = s.split()\n    apples = int(parts[parts.index('apples') - 1]) if 'apples' in parts else 0\n    oranges = int(parts[parts.index('oranges') - 1]) if 'oranges' in parts else 0\n    return n - apples - oranges"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/76", "requirement": "def is_simple_power(x: int, n: int) -> bool:\n    \"\"\"Your task is to write a function that returns true if a number x is a simple power of n and false in other cases.\n    x is a simple power of n if there exists an integer k such that n^k = x. The function should handle edge cases as follows:\n    - If n is 1, the function should return true only if x is also 1.\n    - If x is 0, the function should return false, as 0 is not a power of any positive integer n.\n    - If n is 0, the function should return false, as no positive integer x can be a power of 0.\n    The function should iteratively multiply n by itself until the product equals x or exceeds it, and then check if the product equals x.\n\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"", "generated_programs": ["def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0 or n == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0 or n == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 0 or n == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0 or n == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 0 or n == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0 or n == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 0 or n == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power_result = 1\n    while power_result < x:\n        power_result *= n\n    return power_result == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 0 or n == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0 or n == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 0 or n == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    '''\n    Write a function that takes an integer a and returns True \n    if this integer is a perfect cube of some integer number, \n    including negative integers and zero. The function should \n    correctly handle both positive and negative inputs.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "generated_programs": ["def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a >= 0:\n        return round(a ** (1 / 3)) ** 3 == a\n    else:\n        return round((-a) ** (1 / 3)) ** 3 == -a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a >= 0:\n        return round(a ** (1 / 3)) ** 3 == a\n    else:\n        return round((-a) ** (1 / 3)) ** 3 == -a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    if a >= 0:\n        return round(a ** (1 / 3)) ** 3 == a\n    else:\n        return round(-(-a) ** (1 / 3)) ** 3 == a", "def iscube(a: int) -> bool:\n    if a >= 0:\n        return round(a ** (1 / 3)) ** 3 == a\n    else:\n        return round(-(-a) ** (1 / 3)) ** 3 == a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return 18 * 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return 2 * 9 ** (n - 1) - 8 ** (n - 1)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 2 * 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 18 * 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 18 * 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return 18 * 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 18 * 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 2 * 9 ** (n - 1) - 8 ** (n - 1)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 2 * 9 ** (n - 1) - 8 ** (n - 1)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        return 2 * 9 ** (n - 1) - 8 ** (n - 1)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function `encrypt` that takes a string as an argument and returns a new string where each lowercase letter is rotated by 4 positions in the alphabet, wrapping around if necessary. Uppercase letters and other characters should remain unchanged.\n\n    The rotation should wrap around the alphabet, meaning 'z' should map to 'd'. The function should only modify lowercase letters and leave all other characters, including uppercase letters, unchanged.\n\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            rotated = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(rotated)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            rotated = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(rotated)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            rotated = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(rotated)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\", \n    regardless of what follows it (e.g., \"I.\", \"I!\", \"I?\"). \n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"", "generated_programs": ["def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    sentences = [s.strip() for s in sentences if s.strip()]\n    count = sum((1 for sentence in sentences if sentence.startswith('I ')))\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    sentences = [s.strip() for s in sentences if s.strip()]\n    count = sum((1 for sentence in sentences if sentence.startswith('I ')))\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        sub_sentences = sentence.split('?')\n        for sub_sentence in sub_sentences:\n            further_sub_sentences = sub_sentence.split('!')\n            for fs in further_sub_sentences:\n                stripped_sentence = fs.strip()\n                if stripped_sentence.startswith('I '):\n                    count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        sub_sentences = sentence.split('?')\n        for sub_sentence in sub_sentences:\n            further_sub_sentences = sub_sentence.split('!')\n            for fs in further_sub_sentences:\n                stripped_sentence = fs.strip()\n                if stripped_sentence.startswith('I '):\n                    count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        sub_sentences = sentence.split('?')\n        for sub_sentence in sub_sentences:\n            further_sub_sentences = sub_sentence.split('!')\n            for fs in further_sub_sentences:\n                stripped_sentence = fs.strip()\n                if stripped_sentence.startswith('I '):\n                    count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        sub_sentences = sentence.split('?')\n        for sub_sentence in sub_sentences:\n            further_sub_sentences = sub_sentence.split('!')\n            for fs in further_sub_sentences:\n                stripped_sentence = fs.strip()\n                if stripped_sentence.startswith('I '):\n                    count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        sub_sentences = sentence.split('?')\n        for sub_sentence in sub_sentences:\n            further_sub_sentences = sub_sentence.split('!')\n            for fs in further_sub_sentences:\n                stripped_sentence = fs.strip()\n                if stripped_sentence.startswith('I '):\n                    count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        sub_sentences = sentence.split('?')\n        for sub_sentence in sub_sentences:\n            further_sub_sentences = sub_sentence.split('!')\n            for fs in further_sub_sentences:\n                stripped_sentence = fs.strip()\n                if stripped_sentence.startswith('I '):\n                    count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    count = 0\n    for sentence in sentences:\n        sub_sentences = sentence.split('?')\n        for sub_sentence in sub_sentences:\n            further_sub_sentences = sub_sentence.split('!')\n            for f_sub_sentence in further_sub_sentences:\n                stripped_sentence = f_sub_sentence.strip()\n                if stripped_sentence.startswith('I '):\n                    count += 1\n    return count", "def is_bored(S: str) -> int:\n    sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in set(sentences):\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 0.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message, and encodes it by swapping the case of all letters. \n    Additionally, replace all vowels in the message with the letter that appears 2 places ahead \n    of that vowel in the English alphabet. If the replacement character goes beyond 'z' or 'Z', \n    it wraps around to the beginning of the alphabet. The function should handle only letters, \n    and non-letter characters should remain unchanged. After replacing the vowels, the case of \n    the resulting character should be swapped as well.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted_vowels = 'cgkqwCGKQW'\n        index = vowels.find(c)\n        return shifted_vowels[index] if index != -1 else c\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            shifted_char = shift_vowel(char)\n            encoded_message.append(shifted_char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    result = []\n    for char in message:\n        if char.isalpha():\n            if char in vowels:\n                new_char = shift[char]\n            else:\n                new_char = char\n            result.append(new_char.swapcase())\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift_map = {v: chr((ord(v.lower()) - ord('a') + 2) % 26 + ord('a')) for v in vowels}\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            new_char = shift_map.get(char, char)\n            encoded_message.append(new_char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted = {'a': 'c', 'A': 'C', 'e': 'g', 'E': 'G', 'i': 'k', 'I': 'K', 'o': 'q', 'O': 'Q', 'u': 'w', 'U': 'W'}\n        return shifted.get(c, c)\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            char = shift_vowel(char)\n            char = char.swapcase()\n        encoded_message += char\n    return encoded_message", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    result = []\n    for char in message:\n        if char in vowels:\n            new_char = shift[char]\n        else:\n            new_char = char\n        if new_char.isalpha():\n            new_char = new_char.swapcase()\n        result.append(new_char)\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return shifted.get(c, c)\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            shifted_char = shift_vowel(char)\n            encoded_message.append(shifted_char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return shifted.get(c, c)\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            shifted_char = shift_vowel(char)\n            encoded_message.append(shifted_char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return shifted.get(c, c)\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            shifted_char = shift_vowel(char)\n            encoded_message.append(shifted_char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n\n    def shift_vowel(c):\n        vowels = 'aeiouAEIOU'\n        shifted = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return shifted.get(c, c)\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            shifted_char = shift_vowel(char)\n            encoded_message.append(shifted_char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    shift = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            if char in vowels:\n                new_char = shift[char]\n            else:\n                new_char = char\n            encoded_message.append(new_char.swapcase())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a non-negative integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is determined by adding 2 to the current number of stones,\n    ensuring that the parity (odd or even) of the number of stones remains the same as the current level.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(0)\n    [0]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return [0]\n    pile = [n]\n    current_stones = n\n    for _ in range(1, n):\n        current_stones += 2\n        pile.append(current_stones)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return [0]\n    pile = [n]\n    for _ in range(1, n):\n        next_stones = pile[-1] + 2\n        pile.append(next_stones)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return [0]\n    pile = [n]\n    current_stones = n\n    for _ in range(1, n):\n        current_stones += 2\n        pile.append(current_stones)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return [0]\n    pile = [n]\n    current_stones = n\n    for _ in range(1, n):\n        current_stones += 2\n        pile.append(current_stones)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return [0]\n    pile = [n]\n    for _ in range(1, n):\n        next_stones = pile[-1] + 2\n        pile.append(next_stones)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return [0]\n    pile = [n]\n    for _ in range(1, n):\n        next_stones = pile[-1] + 2\n        pile.append(next_stones)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return [0]\n    pile = [n]\n    current_stones = n\n    for _ in range(1, n):\n        current_stones += 2\n        pile.append(current_stones)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return [0]\n    pile = [n]\n    current_stones = n\n    for _ in range(1, n):\n        current_stones += 2\n        pile.append(current_stones)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return [0]\n    pile = [n]\n    for _ in range(1, n):\n        next_stones = pile[-1] + 2\n        pile.append(next_stones)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return [0]\n    pile = [n]\n    current_stones = n\n    for _ in range(1, n):\n        current_stones += 2\n        pile.append(current_stones)\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/101", "requirement": "from typing import List\n\n\ndef words_string(s: str) -> List[str]:\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return a list of the words. The string may contain\n    leading or trailing whitespace, which should be ignored. If the string is empty or\n    contains only whitespace and/or commas, return an empty list.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.split(',') if word.strip()] + [word.strip() for word in s.split() if word.strip()]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.split(',') if word.strip()] + [word.strip() for word in s.split() if word.strip()]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.split(',') if word.strip()] + [word.strip() for word in s.split() if word.strip()]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.split(',') if word.strip()] + [word.strip() for word in s.split() if word.strip()]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.split(',') if word.strip()] + [word.strip() for word in s.split() if word.strip()]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.split(',') if word.strip()] + [word.strip() for word in s.split() if word.strip()]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.split(',') if word.strip()] + [word.strip() for word in s.split() if word.strip()]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.split(',') if word.strip()] + [word.strip() for word in s.split() if word.strip()]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.split(',') if word.strip()] if s.strip() else []", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.split(',') if word.strip()] + [word.strip() for word in s.split() if word.strip()]"], "result": {"repaired_passk": 0.5, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/102", "requirement": "def choose_num(x: int, y: int) -> int:\n    \"\"\"This function takes two positive integers x and y and returns the largest even integer within the range [x, y] inclusive. If x is greater than y, or if there are no even numbers in the range, the function returns -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"", "generated_programs": ["def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements whose sum of digits is greater than 0.\n    For positive numbers, the sum of digits is calculated as usual.\n    For negative numbers, only the first digit is treated as negative, and the remaining digits are treated as positive.\n    For example, -123 has signed digits -1, 2, and 3, and their sum is 4.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num >= 0:\n            return sum((int(digit) for digit in str(num)))\n        else:\n            digits = [int(d) for d in str(num)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num >= 0:\n            return sum((int(digit) for digit in str(num)))\n        else:\n            digits = list(str(num)[1:])\n            return -int(digits[0]) + sum((int(digit) for digit in digits[1:]))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num >= 0:\n            return sum((int(digit) for digit in str(num)))\n        else:\n            digits = [int(d) for d in str(num)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num >= 0:\n            return sum((int(digit) for digit in str(num)))\n        else:\n            digits = list(str(num)[1:])\n            return -int(digits[0]) + sum((int(digit) for digit in digits[1:]))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        if n >= 0:\n            return sum((int(digit) for digit in str(n)))\n        else:\n            digits = [int(d) for d in str(n)[1:]]\n            digits[0] = -digits[0]\n            return sum(digits)\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num >= 0:\n            return sum((int(digit) for digit in str(num)))\n        else:\n            digits = [int(d) for d in str(num)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num >= 0:\n            return sum((int(digit) for digit in str(num)))\n        else:\n            digits = [int(d) for d in str(num)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        if n >= 0:\n            return sum((int(digit) for digit in str(n)))\n        else:\n            digits = [int(d) for d in str(n)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num >= 0:\n            return sum((int(digit) for digit in str(num)))\n        else:\n            digits = [int(d) for d in str(num)[1:]]\n            digits[0] = -digits[0]\n            return sum(digits)\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        if n >= 0:\n            return sum((int(digit) for digit in str(n)))\n        else:\n            digits = [int(d) for d in str(n)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n    return sum((1 for num in arr if digit_sum(num) > 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.11111111111111116}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1') if x >= 0 else 0, x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1') if x >= 0 else 0, x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7777777777777778, "original_passk": 0.8}}
{"task_id": "HumanEval/120", "requirement": "from typing import List\n\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array arr of integers and a non-negative integer k, return a sorted list \n    of length k containing the k largest numbers from arr, sorted in ascending order. \n    If k is 0, return an empty list. If k is greater than or equal to the length of arr, \n    return the entire sorted array.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr)\n    return sorted_arr[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr)\n    return sorted_arr[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    elif k >= len(arr):\n        return sorted(arr)\n    else:\n        return sorted(sorted(arr)[-k:])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr, reverse=True)\n    top_k = sorted_arr[:k]\n    return sorted(top_k)", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr, reverse=True)\n    top_k = sorted_arr[:k]\n    return sorted(top_k)", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr)\n    return sorted_arr[-k:]", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr, reverse=True)\n    top_k = sorted_arr[:k]\n    return sorted(top_k)", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr, reverse=True)\n    top_k = sorted_arr[:k]\n    return sorted(top_k)", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr, reverse=True)\n    top_k = sorted_arr[:k]\n    return sorted(top_k)", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr, reverse=True)\n    top_k = sorted_arr[:k]\n    return sorted(top_k)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"Validates a given date string and returns True if the date is valid, otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1, 3, 5, 7, 8, 10, 12. \n       The number of days is not less than 1 or higher than 30 days for months 4, 6, 9, 11. \n       The number of days is not less than 1 or higher than 29 days for the month 2, regardless of whether the year is a leap year or not.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    Examples:\n    valid_date('03-11-2000') => True\n    valid_date('15-01-2012') => False\n    valid_date('04-0-2040') => False\n    valid_date('06-04-2020') => True\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = (int(parts[0]), int(parts[1]), int(parts[2]))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    try:\n        month, day, year = map(int, parts)\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/125", "requirement": "from typing import List\nfrom typing import Union\n\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on any whitespace (including spaces, tabs, and newlines). \n    If no whitespaces exist in the text, split on commas ','. \n    If no commas exist, return the number of lowercase letters where (ord(char) - ord('a')) % 2 != 0, \n    with ord('a') = 0, ord('b') = 1, ... ord('z') = 25.\n    \n    Examples\n    split_words(\"Hello world!\")  [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\")  [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt or '\\t' in txt or '\\n' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "HumanEval/127", "requirement": "def intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"Given two closed intervals, determine if the length of their intersection is a prime number.\n    \n    A closed interval includes both its start and end points. The intersection of two intervals is the set of all points that are common to both intervals. If the intervals do not intersect, return \"NO\". If they do intersect, calculate the length of the intersection (i.e., the difference between the end and start of the intersection). If this length is a prime number, return \"YES\"; otherwise, return \"NO\".\n    \n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    intersection_length = end_min - start_max + 1\n    if intersection_length > 0 and is_prime(intersection_length):\n        return 'YES'\n    else:\n        return 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    intersection_length = end - start + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    intersection_length = end - start + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    intersection_length = end_min - start_max + 1\n    if intersection_length > 0 and is_prime(intersection_length):\n        return 'YES'\n    else:\n        return 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    intersection_length = end_min - start_max + 1\n    if intersection_length > 0 and is_prime(intersection_length):\n        return 'YES'\n    else:\n        return 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given an N x N grid (N >= 2) where each cell contains a unique integer in the range [1, N * N], \n    and a positive integer k, find the lexicographically smallest path of length k. \n    A path is a sequence of cells where each consecutive cell is a neighbor (sharing an edge) of the previous cell. \n    The path can start at any cell and may revisit cells. \n    The lexicographical order is determined by the sequence of cell values in the path, and the path is constructed by always choosing the smallest available next cell value at each step. \n    It is guaranteed that the answer is unique.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    min_start_value = min((min(row) for row in grid))\n    start_positions = [(i, j) for i in range(N) for j in range(N) if grid[i][j] == min_start_value]\n    for x, y in start_positions:\n        dfs(x, y, [grid[x][y]])\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    min_start_value = min((min(row) for row in grid))\n    start_positions = [(i, j) for i in range(N) for j in range(N) if grid[i][j] == min_start_value]\n    for x, y in start_positions:\n        dfs(x, y, [grid[x][y]])\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    min_start_value = min((min(row) for row in grid))\n    start_positions = [(i, j) for i in range(N) for j in range(N) if grid[i][j] == min_start_value]\n    for sx, sy in start_positions:\n        dfs(sx, sy, [grid[sx][sy]])\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    start_values = sorted(((grid[i][j], i, j) for i in range(N) for j in range(N)))\n    for value, i, j in start_values:\n        dfs(i, j, [value])\n        if min_path and len(min_path) == k:\n            break\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from heapq import heappush, heappop\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = []\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heappush(pq, ([grid[i][j]], i, j))\n    while pq:\n        path, x, y = heappop(pq)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [grid[nx][ny]]\n                heappush(pq, (new_path, nx, ny))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def neighbors(x, y):\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                yield (nx, ny)\n    min_path = [float('inf')] * k\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], [(i, j)]))\n    while pq:\n        current_value, path = heapq.heappop(pq)\n        if len(path) == k:\n            result_path = [grid[x][y] for x, y in path]\n            return result_path if result_path < min_path else min_path\n        x, y = path[-1]\n        for nx, ny in neighbors(x, y):\n            new_path = path + [(nx, ny)]\n            new_value = current_value + grid[nx][ny]\n            heapq.heappush(pq, (new_value, new_path))", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from heapq import heappush, heappop\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    min_value = min((min(row) for row in grid))\n    start_positions = [(i, j) for i in range(N) for j in range(N) if grid[i][j] == min_value]\n    pq = []\n    for x, y in start_positions:\n        heappush(pq, (grid[x][y], [(x, y)]))\n    while pq:\n        current_value, path = heappop(pq)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        last_x, last_y = path[-1]\n        for dx, dy in directions:\n            new_x, new_y = (last_x + dx, last_y + dy)\n            if is_valid(new_x, new_y):\n                new_path = path + [(new_x, new_y)]\n                heappush(pq, (grid[new_x][new_y], new_path))", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from heapq import heappush, heappop\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    min_value = min((min(row) for row in grid))\n    start_positions = [(x, y) for x in range(N) for y in range(N) if grid[x][y] == min_value]\n    pq = []\n    for x, y in start_positions:\n        heappush(pq, (grid[x][y], [(x, y)]))\n    while pq:\n        current_value, path = heappop(pq)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        last_x, last_y = path[-1]\n        for dx, dy in directions:\n            new_x, new_y = (last_x + dx, last_y + dy)\n            if is_valid(new_x, new_y):\n                new_path = path + [(new_x, new_y)]\n                heappush(pq, (grid[new_x][new_y], new_path))", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        min_next_value = N * N + 1\n        next_positions = []\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if is_valid(nx, ny):\n                if grid[nx][ny] < min_next_value:\n                    min_next_value = grid[nx][ny]\n                    next_positions = [(nx, ny)]\n                elif grid[nx][ny] == min_next_value:\n                    next_positions.append((nx, ny))\n        for nx, ny in next_positions:\n            result = dfs(nx, ny, path + [grid[nx][ny]])\n            if result:\n                return result\n        return None\n    min_path = None\n    min_start_value = N * N + 1\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] < min_start_value:\n                min_start_value = grid[i][j]\n                min_path = dfs(i, j, [grid[i][j]])\n            elif grid[i][j] == min_start_value:\n                candidate_path = dfs(i, j, [grid[i][j]])\n                if candidate_path and candidate_path < min_path:\n                    min_path = candidate_path\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from heapq import heappush, heappop\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def get_neighbors(x, y):\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                yield (nx, ny)\n    min_path = None\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heappush(pq, (grid[i][j], [(i, j)]))\n    while pq:\n        current_value, path = heappop(pq)\n        if len(path) == k:\n            result_path = [grid[x][y] for x, y in path]\n            if min_path is None or result_path < min_path:\n                min_path = result_path\n            continue\n        last_x, last_y = path[-1]\n        for nx, ny in sorted(get_neighbors(last_x, last_y), key=lambda pos: grid[pos[0]][pos[1]]):\n            new_path = path + [(nx, ny)]\n            heappush(pq, (current_value + grid[nx][ny], new_path))\n    return min_path"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.7, "original_passk": 0.9}}
{"task_id": "HumanEval/130", "requirement": "def tri(n: int) -> List[float]:\n    \"\"\"Generates a list of the first n + 1 numbers of a custom sequence similar to the Tribonacci sequence.\n    The sequence is defined as follows:\n    - tri(0) = 1\n    - tri(1) = 3\n    - For even n > 1, tri(n) = 1 + n / 2\n    - For odd n > 1, tri(n) = tri(n - 1) + tri(n - 2) + (1 + (n + 1) / 2 if (n + 1) is even else tri(n + 1))\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i] + sequence[i - 1] + (1 + (i + 2) / 2)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                next_next_value = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else sequence[i - 1] + sequence[i - 2] + 1 + (i + 3) / 2\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i] + sequence[i - 1] + (1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                predicted_next = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0\n                next_value += predicted_next\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                next_next_value = 1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            else:\n                if i + 1 == 2:\n                    next_next_value = 2\n                else:\n                    next_next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 2) / 2 if (i + 2) % 2 == 0 else 0)\n                next_value += next_next_value\n            sequence.append(next_value)\n    return sequence"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')  True\n    is_nested('[]]]]]]][[[[[]')  False\n    is_nested('[][]')  False\n    is_nested('[]')  False\n    is_nested('[[][]]')  True\n    is_nested('[[]][[')  True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n        else:\n            return False\n    return len(stack) > 0 or string.count('[') != string.count(']')", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n        else:\n            continue\n        if len(stack) > 1:\n            return True\n    return False", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/140", "requirement": "def fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, first replace all sequences of three or more consecutive spaces with '-'.\n    Then, replace each remaining single space with '_'.\n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"", "generated_programs": ["def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    If two numbers have the same sum of digits, their order should be determined\n    by their original index in the list, preserving the relative order from the input.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/153", "requirement": "from typing import List\n\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    \"\"\"Given the name of a class and a list of extensions, determine the strongest extension based on the difference between the number of uppercase and lowercase letters in the extension's name. Return the class name concatenated with the strongest extension in the format 'ClassName.StrongestExtensionName'. If the list of extensions is empty, return the class name alone. If multiple extensions have the same strength, choose the one that comes first in the list.\n\n    The strength of an extension is calculated as the difference between the number of uppercase letters (CAP) and the number of lowercase letters (SM) in the extension's name, i.e., strength = CAP - SM. The extension with the highest strength is considered the strongest. Strength can be positive, negative, or zero.\n\n    Example:\n    >>> Strongest_Extension('Slices', ['SErviNGSliCes', 'Cheese', 'StuFfed'])\n    'Slices.SErviNGSliCes'\n    >>> Strongest_Extension('my_class', ['AA', 'Be', 'CC'])\n    'my_class.AA'\n    >>> Strongest_Extension('EmptyClass', [])\n    'EmptyClass'\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for c in extension if c.isupper()))\n        sm = sum((1 for c in extension if c.islower()))\n        return cap - sm\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for c in extension if c.isupper()))\n        sm = sum((1 for c in extension if c.islower()))\n        return cap - sm\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for c in extension if c.isupper()))\n        sm = sum((1 for c in extension if c.islower()))\n        return cap - sm\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for c in extension if c.isupper()))\n        sm = sum((1 for c in extension if c.islower()))\n        return cap - sm\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for char in extension if char.isupper()))\n        sm_count = sum((1 for char in extension if char.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for char in extension if char.isupper()))\n        sm_count = sum((1 for char in extension if char.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for c in extension if c.isupper()))\n        sm = sum((1 for c in extension if c.islower()))\n        return cap - sm\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word. \n    If the second word is an empty string, the function should return True, as an empty string is considered a valid substring of any string.\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    doubled_b = b + b\n    return any((doubled_b[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((b_double[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((a[i:i + len(b)] in b_double for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    doubled_b = b + b\n    return any((doubled_b[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((a[i:i + len(b)] in b_double for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((a[i:i + len(b)] in b_double for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((a[i:i + len(b)] in b_double for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((b_double[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((a[i:i + len(b)] in b_double for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    b_double = b + b\n    return any((a[i:i + len(b)] in b_double for i in range(len(a) - len(b) + 1)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "HumanEval/160", "requirement": "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists `operator` and `operand`, construct an algebraic expression using the operators and operands, \n    and return the evaluation of this expression. The expression should be evaluated according to standard mathematical \n    operator precedence, where multiplication and division take precedence over addition and subtraction.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of the `operator` list must be one less than the length of the `operand` list.\n        The `operand` list contains non-negative integers.\n        The `operator` list must contain at least one operator, and the `operand` list must contain at least two operands.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\nimport operator as op\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    ops = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}\n    i = 0\n    while i < len(operators):\n        if operators[i] in ('*', '//', '**'):\n            operands[i] = ops[operators[i]](operands[i], operands[i + 1])\n            del operands[i + 1]\n            del operators[i]\n        else:\n            i += 1\n    result = operands[0]\n    for i, operator in enumerate(operators):\n        result = ops[operator](result, operands[i + 1])\n    return result", "from typing import List\nimport operator as op\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    ops = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}\n    precedence = {'+': 1, '-': 1, '*': 2, '//': 2, '**': 3}\n    indexed_ops = [(precedence[op], i) for i, op in enumerate(operators)]\n    indexed_ops.sort()\n    while indexed_ops:\n        _, idx = indexed_ops.pop(0)\n        left_operand = operands[idx]\n        right_operand = operands[idx + 1]\n        operands[idx] = ops[operators[idx]](left_operand, right_operand)\n        del operands[idx + 1]\n        del operators[idx]\n        indexed_ops = [(precedence[op], i) for i, op in enumerate(operators)]\n        indexed_ops.sort()\n    return operands[0]", "from typing import List\nimport operator as op\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    ops = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}\n\n    def apply_operator(op_stack, num_stack):\n        right = num_stack.pop()\n        left = num_stack.pop()\n        op = op_stack.pop()\n        num_stack.append(ops[op](left, right))\n    precedence = {'+': 1, '-': 1, '*': 2, '//': 2, '**': 3}\n    op_stack = []\n    num_stack = [operands[0]]\n    for i, symbol in enumerate(operators):\n        while op_stack and precedence[op_stack[-1]] >= precedence[symbol]:\n            apply_operator(op_stack, num_stack)\n        op_stack.append(symbol)\n        num_stack.append(operands[i + 1])\n    while op_stack:\n        apply_operator(op_stack, num_stack)\n    return num_stack[0]", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "def generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return all integers between the smaller and larger of the two numbers (inclusive) \n    where every digit in the integer is even. The result should be in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    even_digit_numbers = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            even_digit_numbers.append(num)\n    return even_digit_numbers", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    even_digit_numbers = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            even_digit_numbers.append(num)\n    return even_digit_numbers", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if has_only_even_digits(num)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}

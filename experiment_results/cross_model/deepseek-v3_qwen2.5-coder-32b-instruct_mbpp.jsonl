{"task_id": "Mbpp/16", "requirement": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if the input string contains at least one sequence of one or more lowercase letters, followed by an underscore, followed by one or more lowercase letters. The function should return False otherwise.\n    The function should not require the entire string to match this pattern; it only needs to find at least one such substring.\n    assert text_lowercase_underscore(\"aab_cbbbc\") == (True)\n    \"\"\"", "generated_programs": ["import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/63", "requirement": "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute difference between the two elements within each tuple in the given list of tuples.\n    \n    The function assumes that each tuple in the list contains exactly two integers. If the input list is empty, the function raises a ValueError.\n    \n    Args:\n        test_list: A list of tuples, where each tuple contains exactly two integers.\n    \n    Returns:\n        The maximum absolute difference between the two elements within each tuple.\n    \n    Raises:\n        ValueError: If the input list is empty.\n    \n    Examples:\n        >>> max_difference([(3, 5), (1, 7), (10, 3), (1, 2)])\n        7\n        >>> max_difference([])\n        ValueError\n    \"\"\"", "generated_programs": ["from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        raise ValueError\n    return max((abs(a - b) for a, b in test_list))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/72", "requirement": "def dif_Square(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given integer `n` can be represented as the difference of two squares, i.e., `n = a² - b²`, where `a` and `b` are non-negative integers.\n\n    The function should return `True` if such a representation exists, otherwise `False`. The function should handle all integer inputs, including negative numbers, but should return `False` for negative inputs since the difference of two squares cannot be negative.\n\n    Examples:\n    assert dif_Square(5) == True\n    assert dif_Square(-1) == False\n    assert dif_Square(0) == True\n    assert dif_Square(3) == True\n    assert dif_Square(4) == True\n    \"\"\"", "generated_programs": ["def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or (n - 1) % 4 == 0", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 2 == 0 or n % 4 == 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n    \"\"\"\n    Write a Python function to determine if a number is divisible by 11 using the modulo operation.\n    The function should return True if the number is divisible by 11, otherwise False.\n    assert is_Diff(12345) == False\n    \"\"\"", "generated_programs": ["def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/92", "requirement": "def is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not. \n    A number is considered undulating if it strictly alternates between two distinct digits. \n    For example, `1212121` is undulating because it alternates between `1` and `2`.\n    The number must have at least two digits, and no two adjacent digits should be the same.\n    The alternation pattern must be consistent throughout the number.\n    \n    assert is_undulating(1212121) == True\n    \"\"\"", "generated_programs": ["def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given positive integer.\n    The function should raise a ValueError if the input is a non-positive integer (i.e., zero or negative).\n    The function should optimize the divisor counting process by limiting the loop to the square root of `n`.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer.\n    \"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/99", "requirement": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Write a function to convert the given decimal number to its binary equivalent, represented as a string. \n    The binary string should start with the first '1' encountered, ensuring no leading zeros. \n    If the input number is 0, the function should return '0'.\n    assert decimal_to_binary(8) == '1000'\n    \"\"\"", "generated_programs": ["def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/103", "requirement": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Write a function to find the Eulerian number a(n, m).\n    The Eulerian number a(n, m) is defined for integers n >= 0 and 0 <= m < n.\n    For m < 0 or m >= n, the function should return 0.\n    assert eulerian_num(3, 1) == 4\n    \"\"\"", "generated_programs": ["def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 and m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 and m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 and m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 and m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 and m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.5, "original_passk": 1.0}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements in given nested lists. \n    The function assumes that the input `nestedlist` contains at least one sublist and that all sublists are non-empty.\n    If the input is an empty list or contains empty sublists, the function will raise a `TypeError`.\n\n    Examples:\n    >>> assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    >>> common_in_nested_lists([[]])\n    TypeError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/120", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute product of the two numbers within each tuple in a given list of tuples.\n    The function should calculate the product of the two numbers within each tuple, take the absolute value of that product,\n    and then return the largest absolute product among these products.\n    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    \"\"\"", "generated_programs": ["from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n\"\"\"\nWrite a function to sum all amicable numbers from 1 to a specified number.\n\n\nassert amicable_numbers_sum(999)==504\n\"\"\"", "generated_programs": ["def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((d for d in range(1, n) if n % d == 0))\n    amicable_sum = 0\n    for num in range(2, limit):\n        partner = sum_of_divisors(num)\n        if partner > num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((d for d in range(1, n // 2 + 1) if n % d == 0))\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num in visited:\n            continue\n        partner = sum_of_divisors(num)\n        if partner != num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n            visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Write a function to calculate the angle of the vector from complex number `a` to complex number `b` in the complex plane.\n    The angle is calculated as the phase of the complex number resulting from the difference `b - a`.\n\n    Example:\n    >>> assert math.isclose(angle_complex(0, 1j), 1.5707963267948966, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/126", "requirement": "def sum_of_common_divisors(a: int, b: int) -> int:\n    \"\"\"\n    Write a Python function to calculate and return the sum of all common divisors of two given integers.\n    The function should return the sum as a single integer.\n\n    Example:\n    >>> sum_of_common_divisors(10, 15)\n    6\n    \"\"\"", "generated_programs": ["def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n    gcd_value = gcd(a, b)\n    sum_divisors = 0\n    for i in range(1, int(gcd_value ** 0.5) + 1):\n        if gcd_value % i == 0:\n            sum_divisors += i\n            if i != gcd_value // i:\n                sum_divisors += gcd_value // i\n    return sum_divisors", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def find_divisors(n):\n        divisors = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    common_divisors = find_divisors(gcd(a, b))\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def divisors(n):\n        result = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                result.add(i)\n                result.add(n // i)\n        return result\n    common_divisors = divisors(gcd(a, b))\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n    n = gcd(a, b)\n    total = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def find_gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n    gcd = find_gcd(a, b)\n    sum_divisors = 0\n    for i in range(1, int(gcd ** 0.5) + 1):\n        if gcd % i == 0:\n            sum_divisors += i\n            if i != gcd // i:\n                sum_divisors += gcd // i\n    return sum_divisors", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def find_divisors(n):\n        divisors = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    common_gcd = gcd(a, b)\n    common_divisors = find_divisors(common_gcd)\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def find_divisors(n):\n        divisors = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    gcd_value = gcd(a, b)\n    common_divisors = find_divisors(gcd_value)\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def find_divisors(n):\n        divisors = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    gcd_value = gcd(a, b)\n    common_divisors = find_divisors(gcd_value)\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def find_divisors(n):\n        divisors = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    common_gcd = gcd(a, b)\n    common_divisors = find_divisors(common_gcd)\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    common_gcd = gcd(a, b)\n    divisors_of_gcd = get_divisors(common_gcd)\n    return sum(divisors_of_gcd)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether the given matrix is a magic square.\n    A magic square is a square matrix where the sums of the numbers in each row, each column, and both main diagonals are equal to the magic sum.\n    The magic sum for an n x n matrix is calculated as n * (n ** 2 + 1) // 2.\n    Additionally, the matrix must be square (i.e., the number of rows equals the number of columns).\n    \n    Examples:\n    >>> magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])\n    True\n    >>> magic_square_test([[1, 1, 1], [1, 1, 1], [1, 1, 1]])\n    False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if sum(my_matrix[0]) != magic_sum:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if sum(my_matrix[0]) != magic_sum:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if sum(my_matrix[0]) != magic_sum:\n        return False\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_sum or sum((my_matrix[j][i] for j in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum or sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if sum(my_matrix[0]) != magic_sum:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if sum(my_matrix[0]) != magic_sum:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if sum(my_matrix[0]) != magic_sum:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/130", "requirement": "from typing import List\n\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list. \n    The function assumes that the input list is non-empty. If the list is empty, \n    the function will raise an IndexError when attempting to access the first element \n    of an empty list.\n\n    Examples:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    >>> max_occurrences([])\n    IndexError\n    \"\"\"", "generated_programs": ["from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return next((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_count = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_count))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    return count.most_common(1)[0][0]", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return next((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.30000000000000004, "original_passk": 1.0}}
{"task_id": "Mbpp/137", "requirement": "from typing import List\n\n\ndef zero_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of the number of zeroes to the number of non-zero elements in an array of integers.\n    assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else 0.0", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else 0.0", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else 0.0", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else 0", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else 0.0", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else 0.0", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else 0.0", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else 0.0", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else 0.0", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else 0.0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given integer can be represented as the sum of multiple non-zero powers of 2.\n    The function should return `True` if the number has more than one bit set in its binary representation, indicating it is a sum of multiple powers of 2.\n    The function should return `False` if the number is a single power of 2 (i.e., only one bit is set in its binary representation).\n    The function should handle negative integers by checking their binary representation in the same manner as positive integers.\n    assert is_Sum_Of_Powers_Of_Two(10) == True\n    \"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    n = abs(n)\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    n = abs(n)\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    n = abs(n)\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    n = abs(n)\n    return n & n - 1 != 0 and n != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    n = abs(n)\n    return n & n - 1 != 0 and n != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    n = abs(n)\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    n = abs(n)\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    n = abs(n)\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    n = abs(n)\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    n = abs(n)\n    return n & n - 1 != 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/145", "requirement": "from typing import List\n\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the maximum absolute difference between the maximum and minimum values in a given non-empty array of integers.\n    If the array is empty, the function should return 0.\n    \n    assert max_Abs_Diff((2,1,5,3)) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return abs(max(arr) - min(arr))", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return abs(max(arr) - min(arr))", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"\n    Write a function that returns non-negative integers x and y that satisfy ax + by = n as a tuple, or return None if no such solution exists.\n    \n    The function should handle the following cases:\n    1. If `a` or `b` is zero, the function should raise a ZeroDivisionError.\n    2. If `n` is zero, the function should return (0, 0) if both `a` and `b` are non-zero.\n    3. If `n` is not divisible by the greatest common divisor (GCD) of `a` and `b`, the function should return None.\n    4. If multiple solutions exist, the function should return the first solution where both `x` and `y` are non-negative, without prioritizing any specific solution (e.g., smallest `x` or smallest `y`).\n    \n    The function assumes that `a`, `b`, and `n` are positive integers. If `a`, `b`, or `n` is negative, the behavior is undefined.\n    \n    assert find_solution(2, 3, 7) == (2, 1)\n    \"\"\"", "generated_programs": ["from typing import Tuple\nfrom typing import Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if n == 0:\n        return (0, 0)\n    g = gcd(a, b)\n    if n % g != 0:\n        return None\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if n == 0:\n        return (0, 0)\n    g = gcd(a, b)\n    if n % g != 0:\n        return None\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if n == 0:\n        return (0, 0)\n    gcd = math.gcd(a, b)\n    if n % gcd != 0:\n        return None\n    s, t = extended_gcd(a, b)\n    x0 = s * (n // gcd)\n    y0 = t * (n // gcd)\n    k = -min(x0 // b, y0 // -a)\n    x = x0 + k * b\n    y = y0 - k * a\n    return (x, y)\n\ndef extended_gcd(a: int, b: int) -> Tuple[int, int]:\n    if a == 0:\n        return (0, 1)\n    else:\n        g, x, y = extended_gcd(b % a, a)\n        return (y - b // a * x, x)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if n == 0:\n        return (0, 0)\n    gcd = math.gcd(a, b)\n    if n % gcd != 0:\n        return None\n    s, t, _ = extended_gcd(a, b)\n    x = s * (n // gcd)\n    y = t * (n // gcd)\n    k = min(-x // b, -y // a)\n    x += k * b\n    y -= k * a\n    return (x, y) if x >= 0 and y >= 0 else None\n\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    if a == 0:\n        return (0, 1, b)\n    else:\n        g, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - b // a * x1\n        y = x1\n        return (x, y, g)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if n == 0:\n        return (0, 0)\n    gcd = math.gcd(a, b)\n    if n % gcd != 0:\n        return None\n    s, t, _ = extended_gcd(a, b)\n    x0 = s * (n // gcd)\n    y0 = t * (n // gcd)\n    x = x0\n    y = y0\n    while x < 0 or y < 0:\n        x += b // gcd\n        y -= a // gcd\n    return (x, y)\n\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    if a == 0:\n        return (0, 1, b)\n    else:\n        g, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - b // a * x1\n        y = x1\n        return (x, y, g)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if n == 0:\n        return (0, 0)\n    gcd = math.gcd(a, b)\n    if n % gcd != 0:\n        return None\n    s, t, _ = extended_gcd(a, b)\n    x0 = s * (n // gcd)\n    y0 = t * (n // gcd)\n    k = -min(x0 // b, y0 // -a)\n    x = x0 + k * b\n    y = y0 - k * a\n    return (x, y)\n\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    if a == 0:\n        return (0, 1, b)\n    else:\n        g, x, y = extended_gcd(b % a, a)\n        return (y - b // a * x, x, g)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if n == 0:\n        return (0, 0)\n    gcd = math.gcd(a, b)\n    if n % gcd != 0:\n        return None\n    s, t, _ = extended_gcd(a, b)\n    x = s * (n // gcd)\n    y = t * (n // gcd)\n    k = max(-x // b, -y // a)\n    x += k * b\n    y -= k * a\n    return (x, y)\n\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    if a == 0:\n        return (0, 1, b)\n    else:\n        g, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - b // a * x1\n        y = x1\n        return (x, y, g)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if n == 0:\n        return (0, 0)\n    gcd = math.gcd(a, b)\n    if n % gcd != 0:\n        return None\n    s, t = extended_gcd(a, b)\n    x0, y0 = (s * (n // gcd), t * (n // gcd))\n    x = x0 + b // gcd * t\n    y = y0 - a // gcd * t\n    k = -min(x // (b // gcd), y // -(a // gcd))\n    x += k * (b // gcd)\n    y -= k * (a // gcd)\n    return (x, y)\n\ndef extended_gcd(a: int, b: int) -> Tuple[int, int]:\n    if a == 0:\n        return (0, 1)\n    else:\n        g, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - b // a * x1\n        y = x1\n        return (g, x, y)", "from typing import Tuple\nfrom typing import Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if n == 0:\n        return (0, 0)\n    g = gcd(a, b)\n    if n % g != 0:\n        return None\n    s, t = extended_gcd(a, b)\n    x0 = s * (n // g)\n    y0 = t * (n // g)\n    k = (x0 * b - y0 * a) // (a * b)\n    x = x0 - k * b // g\n    y = y0 + k * a // g\n    if x < 0:\n        k += (abs(x) + b - 1) // b\n        x = x0 - k * b // g\n        y = y0 + k * a // g\n    if x >= 0 and y >= 0:\n        return (x, y)\n    return None\n\ndef extended_gcd(a: int, b: int) -> Tuple[int, int]:\n    if a == 0:\n        return (0, 1)\n    else:\n        g, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - b // a * x1\n        y = x1\n        return (g, x, y)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if n == 0:\n        return (0, 0)\n    gcd = math.gcd(a, b)\n    if n % gcd != 0:\n        return None\n    s, t = extended_gcd(a, b)\n    x = s * (n // gcd)\n    y = t * (n // gcd)\n    k = (x * b - y * a) // (a * b)\n    x -= k * b // gcd\n    y += k * a // gcd\n    if x < 0:\n        k = (x - b // gcd + 1) // (b // gcd)\n        x -= k * b // gcd\n        y += k * a // gcd\n    if y < 0:\n        k = (y - a // gcd + 1) // (a // gcd)\n        x -= k * b // gcd\n        y += k * a // gcd\n    return (x, y)\n\ndef extended_gcd(a: int, b: int) -> Tuple[int, int]:\n    if a == 0:\n        return (0, 1)\n    else:\n        g, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - b // a * x1\n        y = x1\n        return (g, x, y)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n    \"\"\"\n    Write a Python function to set all even bits of a given number to 1 if any of the even bits are not already set.\n    The function should return the original number if all even bits are already set.\n    assert even_bit_set_number(10) == 10\n    \"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length() + 1, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, 32, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length() + 1, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 64:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 64:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 64:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 64:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 64:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 64:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 64:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, \n    such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    The first element of the sequence can be any integer from 1 to m.\n    If n is 0, the function should raise an IndexError.\n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(max(i * 2, start), length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(i * 2, length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError\n\n    def count_sequences(start, length):\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(i * 2, length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(max(i * 2, start), length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(i * 2, length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(i * 2, length - 1)\n        return total\n    result = 0\n    for i in range(1, m + 1):\n        result += count_sequences(i, n)\n    return result", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError\n\n    def count_sequences(start, length):\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(i * 2, length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError\n\n    def count_sequences(start, length):\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(i * 2, length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError\n\n    def count_sequences(current, length):\n        if length == 1:\n            return 1\n        total = 0\n        next_start = max(current * 2, 1)\n        for i in range(next_start, m + 1):\n            total += count_sequences(i, length - 1)\n        return total\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError\n\n    def count_sequences(current, remaining):\n        if remaining == 0:\n            return 1\n        total = 0\n        for next_value in range(max(2 * current, 1), m + 1):\n            total += count_sequences(next_value, remaining - 1)\n        return total\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    return total_sequences"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/253", "requirement": "from typing import List, Any\n\n\ndef count_integer(lst: List[Any]) -> int:\n    \"\"\"\n    Write a Python function that returns the number of elements in a given list that are of type `int`, excluding `bool` values.\n    assert count_integer([1, 2, 'abc', 1.2]) == 2\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Newman-Shanks-Williams prime number.\n    \n    The Newman-Shanks-Williams prime sequence is defined as follows:\n    - The first Newman-Shanks-Williams prime (n=1) is 3.\n    - The second Newman-Shanks-Williams prime (n=2) is 5.\n    - The third Newman-Shanks-Williams prime (n=3) is 7.\n    - For n > 1, the nth Newman-Shanks-Williams prime is generated using the recurrence relation: c = 2 * b + a, where a and b are the previous two primes in the sequence.\n    \n    The function should return the nth Newman-Shanks-Williams prime number.\n    \n    Examples:\n    >>> newman_prime(1)\n    3\n    >>> newman_prime(2)\n    5\n    >>> newman_prime(3)\n    7\n    \"\"\"", "generated_programs": ["def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    elif n == 3:\n        return 7\n    a, b = (3, 5)\n    for _ in range(4, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/265", "requirement": "from typing import List, Any\n\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Splits the list `S` into `step` number of sublists, where each sublist contains elements spaced by `step` intervals. \n    The first sublist contains elements at positions 0, step, 2*step, etc., the second sublist contains elements at positions 1, step+1, 2*step+1, etc., and so on.\n    \n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for i in range(step) if i + j * step < len(S)] for j in range((len(S) + step - 1) // step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for i in range(step) if i + j * step < len(S)] for j in range((len(S) + step - 1) // step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for i in range(step) if i + j * step < len(S)] for j in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for j in range((len(S) - i - 1) // step + 1)] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for i in range(step) if i + j * step < len(S)] for j in range((len(S) + step - 1) // step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for i in range(step) if i + j * step < len(S)] for j in range((len(S) + step - 1) // step)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 1.0}}
{"task_id": "Mbpp/286", "requirement": "from typing import List\n\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the largest sum of a contiguous subarray in the modified array formed by repeating the given array `k` times. \n    The function should treat the repeated array as a single continuous sequence, allowing the subarray to span across multiple repetitions if necessary.\n    \n    The function should handle the following cases:\n    - If `k` is 1, it should return the maximum subarray sum of the original array.\n    - If the total sum of the array is positive, the maximum subarray sum could be significantly larger when the array is repeated multiple times.\n    - If the total sum of the array is non-positive, the maximum subarray sum should be calculated by considering at most two repetitions of the array.\n    \n    assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum > 0:\n        return kadane(a * 2) + (k - 2) * total_sum\n    else:\n        return kadane(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum > 0:\n        return kadane(a * 2) + (k - 2) * total_sum\n    else:\n        return kadane(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum > 0:\n        return kadane(a * 2) + (k - 2) * total_sum\n    else:\n        return kadane(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum > 0:\n        return kadane(a * 2) + (k - 2) * total_sum\n    else:\n        return kadane(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum > 0:\n        return kadane(a * 2) + (k - 2) * total_sum\n    else:\n        return kadane(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_kadane = kadane(a)\n    if k == 1:\n        return max_kadane\n    max_prefix_sum = max_suffix_sum = float('-inf')\n    current_prefix_sum = current_suffix_sum = 0\n    for i in range(n):\n        current_prefix_sum += a[i]\n        max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n    for i in range(n - 1, -1, -1):\n        current_suffix_sum += a[i]\n        max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n    if total_sum > 0:\n        return max(max_kadane, max_prefix_sum + max_suffix_sum + (k - 2) * total_sum)\n    else:\n        return max(max_kadane, max_prefix_sum + max_suffix_sum)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum > 0:\n        return kadane(a * 2) + (k - 2) * total_sum\n    else:\n        return kadane(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum > 0:\n        return kadane(a * 2) + (k - 2) * total_sum\n    else:\n        return kadane(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_kadane = kadane(a)\n    if k == 1:\n        return max_kadane\n    max_prefix_sum = max_suffix_sum = float('-inf')\n    current_prefix_sum = current_suffix_sum = 0\n    for i in range(n):\n        current_prefix_sum += a[i]\n        max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n    for i in range(n - 1, -1, -1):\n        current_suffix_sum += a[i]\n        max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n    if total_sum > 0:\n        return max(max_kadane, max_prefix_sum + max_suffix_sum + (k - 2) * total_sum)\n    else:\n        return max(max_kadane, max_prefix_sum + max_suffix_sum)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    max_kadane = kadane(a)\n    if k == 1:\n        return max_kadane\n    max_prefix_sum = max_suffix_sum = float('-inf')\n    current_prefix_sum = current_suffix_sum = 0\n    for i in range(n):\n        current_prefix_sum += a[i]\n        max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n    for i in range(n - 1, -1, -1):\n        current_suffix_sum += a[i]\n        max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n    if total_sum > 0:\n        return max(max_kadane, max_prefix_sum + max_suffix_sum + (k - 2) * total_sum)\n    else:\n        return max(max_kadane, max_prefix_sum + max_suffix_sum)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n    \"\"\"\n    Write a function to find the depth of a dictionary. The depth is defined as the number of nested dictionaries plus one. \n    An empty dictionary has a depth of 1. Non-dictionary inputs should return a depth of 0.\n\n    Examples:\n    >>> dict_depth({'a':1, 'b': {'c': {'d': {}}}})\n    4\n    >>> dict_depth({})\n    1\n    >>> dict_depth(123)\n    0\n    \"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Find the maximum sum of an increasing subsequence from the prefix of the list up to the ith index, \n    and then add the kth element to this sum. The kth element must be strictly after the ith index (k > i).\n    \n    The function calculates the maximum sum of increasing subsequences up to each index using dynamic programming.\n    It then finds the maximum sum among the subsequences up to the ith index where the last element is less than the kth element.\n    If no such subsequence exists, the function returns the value of the kth element alone.\n    \n    Args:\n        a (List[int]): The input list of integers.\n        n (int): The length of the list.\n        index (int): The index up to which the increasing subsequence is considered.\n        k (int): The index of the element to be added to the sum, must be greater than index.\n    \n    Returns:\n        int: The maximum sum of the increasing subsequence up to the ith index plus the kth element, or the kth element alone if no valid subsequence is found.\n    \n    Examples:\n        >>> max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6)\n        11\n        >>> max_sum_increasing_subseq([5, 4, 3, 2, 1], 5, 1, 3)\n        2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k] if max_sum > 0 else a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k >= n or index >= n or k <= index:\n        return a[k]\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k <= index or k >= n:\n        return a[k]\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k >= n or index >= n:\n        return a[k] if k < n else 0\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k >= n or index >= k:\n        return a[k]\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n    \"\"\"\n    Write a function to convert a given string to a tuple of characters, excluding spaces.\n    assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n    \"\"\"", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the highest unset bit (i.e., the leftmost bit that is 0) in the binary representation of the number.\n    The function should traverse the bits from the highest bit position down to the lowest, find the first unset bit, set it to 1, and return the result.\n    If no unset bit is found below the highest bit, set the next higher bit.\n    assert set_left_most_unset_bit(10) == 14\n    \"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/391", "requirement": "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    \"\"\"\n    Convert three lists of equal length into a list of nested dictionaries. Each element of the first list becomes a key in the outer dictionary, and the corresponding elements from the second and third lists form the inner dictionary. \n    \n    Args:\n        list1 (List[Any]): The list of keys for the outer dictionary.\n        list2 (List[Any]): The list of keys for the inner dictionary.\n        list3 (List[Any]): The list of values for the inner dictionary.\n    \n    Returns:\n        List[Dict[Any, Dict[Any, Any]]]: A list of nested dictionaries where each dictionary has the structure {list1[i]: {list2[i]: list3[i]}}.\n    \n    Raises:\n        IndexError: If the input lists are not of equal length.\n    \n    Examples:\n        >>> convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"], [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"], [85, 98, 89, 92])\n        [{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]\n        \n        >>> convert_list_dictionary([\"B001\", \"B002\"], [\"Alice Smith\"], [90, 95])\n        IndexError\n    \"\"\"", "generated_programs": ["from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError\n    return [{k: {l: m}} for k, l, m in zip(list1, list2, list3)]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if not len(list1) == len(list2) == len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{k1: {k2: v3}} for k1, k2, v3 in zip(list1, list2, list3)]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{k: {l: m}} for k, l, m in zip(list1, list2, list3)]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{k: {l: m}} for k, l, m in zip(list1, list2, list3)]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find the directrix of a parabola given in the standard form \\( y = ax^2 + bx + c \\).\n    The directrix is calculated using the formula derived from the standard form:\n    - \\( h = -b / (2 * a) \\)\n    - \\( k = c - b^2 / (4 * a) \\)\n    - \\( directrix = k - 1 / (4 * a) \\)\n    The result should be converted to an integer by truncating the decimal part.\n    assert parabola_directrix(5,3,2)==-198\n    \"\"\"", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    h = -b / (2 * a)\n    k = c - b ** 2 / (4 * a)\n    directrix = k - 1 / (4 * a)\n    return int(directrix)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.5}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first (n + 1) Perrin numbers, including the nth Perrin number.\n    \n    The Perrin sequence is defined as follows:\n    - P(0) = 3, P(1) = 0, P(2) = 2\n    - P(n) = P(n-2) + P(n-3) for n >= 3\n    \n    Edge cases:\n    - If n == 0, return 0.\n    - If n == 1, return 2.\n    - If n == 2, return 3.\n    \n    Input validation:\n    - The function does not handle negative inputs and will raise an IndexError if n is negative.\n    \n    Args:\n        n (int): The index of the Perrin number up to which the sum is calculated.\n        \n    Returns:\n        int: The sum of the first (n + 1) Perrin numbers.\n        \n    Examples:\n        >>> cal_sum(2)\n        3\n        >>> cal_sum(-1)\n        IndexError\n        >>> cal_sum(0)\n        0\n    \"\"\"\n    assert cal_sum(9) == 49", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1]) if n > 0 else 0", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1]) if n > 2 else [0, 2, 3][n]", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of even positive factors of a given positive integer.\n    The function should return 0 for non-positive integers or invalid inputs (e.g., negative numbers or zero).\n    Factors are defined as positive divisors of the number, and the range of factors considered should be from 1 to the number itself (inclusive).\n    \n    Examples:\n    >>> sumofFactors(18)\n    26\n    >>> sumofFactors(-12)\n    0\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            sum_even_factors += i\n    return sum_even_factors"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/465", "requirement": "def drop_empty(dict1: dict) -> dict:\n    \"\"\"\n    Write a function to drop items from a given dictionary where the value is None.\n\n    Parameters:\n    dict1 (dict): The input dictionary from which items with None values will be removed.\n\n    Returns:\n    dict: A new dictionary with all key-value pairs retained except those where the value is None.\n\n    Examples:\n    >>> drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None})\n    {'c1': 'Red', 'c2': 'Green'}\n    \"\"\"", "generated_programs": ["def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product formed by multiplying all numbers of the longest increasing subsequence in the array.\n    The function should consider the entire subsequence to calculate the product, not just any subset of the subsequence.\n    assert max_product([3, 100, 4, 5, 150, 6]) == 3000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    lis = [1] * n\n    product = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n                product[i] = product[j] * arr[i]\n            elif arr[i] > arr[j] and lis[i] == lis[j] + 1:\n                product[i] = max(product[i], product[j] * arr[i])\n    return max(product)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    lis = [1] * n\n    product = arr[:]\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n                product[i] = product[j] * arr[i]\n            elif arr[i] > arr[j] and lis[i] == lis[j] + 1:\n                product[i] = max(product[i], product[j] * arr[i])\n    return max(product)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    product = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                product[i] = product[j] * arr[i]\n            elif arr[i] > arr[j] and dp[i] == dp[j] + 1:\n                product[i] = max(product[i], product[j] * arr[i])\n    return max(product)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    lis = [1] * n\n    product = arr[:]\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n                product[i] = product[j] * arr[i]\n            elif arr[i] > arr[j] and lis[i] == lis[j] + 1:\n                product[i] = max(product[i], product[j] * arr[i])\n    max_product_value = max(product)\n    return max_product_value", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = arr[:]\n    max_product = arr[0]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n        max_product = max(max_product, dp[i])\n    return max_product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    product = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                product[i] = product[j] * arr[i]\n        if dp[i] == 1:\n            product[i] = arr[i]\n    max_product = max(product)\n    return max_product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    lis = [1] * n\n    product = arr[:]\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n                product[i] = product[j] * arr[i]\n            elif arr[i] > arr[j] and lis[i] == lis[j] + 1:\n                product[i] = max(product[i], product[j] * arr[i])\n    return max(product)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    lis = [1] * n\n    product = arr[:]\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n                product[i] = product[j] * arr[i]\n            elif arr[i] > arr[j] and lis[i] == lis[j] + 1:\n                product[i] = max(product[i], product[j] * arr[i])\n    return max(product)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    lis = [1] * n\n    product = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n                product[i] = product[j] * arr[i]\n            elif arr[i] > arr[j] and lis[i] == lis[j] + 1:\n                product[i] = max(product[i], product[j] * arr[i])\n    return max(product)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [(1, arr[i]) for i in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                new_length = dp[j][0] + 1\n                new_product = dp[j][1] * arr[i]\n                if new_length > dp[i][0]:\n                    dp[i] = (new_length, new_product)\n                elif new_length == dp[i][0] and new_product > dp[i][1]:\n                    dp[i] = (new_length, new_product)\n    max_product = max(dp, key=lambda x: x[1])[1]\n    return max_product"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/471", "requirement": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function to find the remainder of the product of all elements in the array when divided by n.\n    The product is computed first by multiplying all elements in the array, and then the modulo operation is applied to the final product.\n    If the array is empty, the function should return 1 % n, which is 1, as the product of an empty list is considered to be 1.\n    assert find_remainder([100, 10, 5, 25, 35, 14], 11) == 9\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product if product != 0 else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product if product != 0 else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product if product != 0 else 1 % n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 1.0}}
{"task_id": "Mbpp/479", "requirement": "def first_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the first digit of a given number. \n    For negative numbers, the first digit should include the negative sign and the first numerical digit (e.g., for -456, the first digit is -4).\n    The function should return the number itself if it is a single-digit number (including negative single-digit numbers).\n    assert first_Digit(123) == 1\n    assert first_Digit(-456) == -4\n    assert first_Digit(-7) == -7\n    \"\"\"", "generated_programs": ["def first_Digit(n: int) -> int:\n    if -9 <= n <= 9:\n        return n\n    elif n > 0:\n        while n >= 10:\n            n //= 10\n        return n\n    else:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n", "def first_Digit(n: int) -> int:\n    if -9 <= n <= 9:\n        return n\n    elif n > 0:\n        while n >= 10:\n            n //= 10\n        return n\n    else:\n        while n <= -10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if -9 <= n <= 9:\n        return n\n    elif n > 0:\n        while n >= 10:\n            n //= 10\n        return n\n    else:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n", "def first_Digit(n: int) -> int:\n    if -9 <= n <= 9:\n        return n\n    elif n > 0:\n        while n >= 10:\n            n //= 10\n        return n\n    else:\n        while n <= -10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if -9 <= n <= 9:\n        return n\n    elif n > 0:\n        while n >= 10:\n            n //= 10\n        return n\n    else:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n", "def first_Digit(n: int) -> int:\n    if -9 <= n <= 9:\n        return n\n    elif n > 0:\n        while n >= 10:\n            n //= 10\n        return n\n    else:\n        while n <= -10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if -9 <= n <= 9:\n        return n\n    elif n > 0:\n        while n >= 10:\n            n //= 10\n        return n\n    else:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n", "def first_Digit(n: int) -> int:\n    if -9 <= n <= 9:\n        return n\n    elif n > 0:\n        while n >= 10:\n            n //= 10\n        return n\n    else:\n        while n <= -10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if -9 <= n <= 9:\n        return n\n    elif n > 0:\n        while n >= 10:\n            n //= 10\n        return n\n    else:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n", "def first_Digit(n: int) -> int:\n    if -9 <= n <= 9:\n        return n\n    elif n > 0:\n        while n >= 10:\n            n //= 10\n        return n\n    else:\n        while n <= -10:\n            n //= 10\n        return n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/558", "requirement": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of the absolute differences between corresponding digits of two integers.\n    The function should pad the shorter integer with leading zeros to make the lengths equal before performing the comparison.\n    \n    Examples:\n    >>> digit_distance_nums(100, 1)\n    2\n    >>> digit_distance_nums(1, 2)\n    1\n    \"\"\"", "generated_programs": ["def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/559", "requirement": "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum of any contiguous sublist in the given list.\n    The function should handle edge cases such as an empty list by returning negative infinity.\n    \n    Parameters:\n    a (List[int]): The list of integers.\n    size (int): The size of the list.\n    \n    Returns:\n    int: The maximum sum of any contiguous sublist. If the list is empty, returns negative infinity.\n    \n    Examples:\n    >>> max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8)\n    7\n    >>> max_sub_array_sum([], 0)\n    -inf\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/563", "requirement": "def extract_values(text: str) -> List[str]:\n    \"\"\"Extract all substrings that are enclosed within double quotation marks from the input string.\n    Each substring should be captured without the surrounding quotes.\n    assert extract_values('\"Python\", \"PHP\", \"Java\"')==['Python', 'PHP', 'Java']\n    \"\"\"", "generated_programs": ["from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "def count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Counts the number of unordered pairs (i, j) in the list `arr` where `i < j` and `arr[i] != arr[j]`.\n    The function takes a list of integers `arr` and an integer `n` representing the length of the list.\n    assert count_Pairs([1,2,1],3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/579", "requirement": "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    \"\"\"\n    Write a function to find the dissimilar elements in the given two tuples and return them in sorted order.\n    \n    The function should return a tuple containing elements that are not common between the two input tuples, \n    sorted in ascending order.\n    \n    assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Write a function to remove uneven integer elements in the nested mixed tuple. \n    The function should recursively process nested tuples and only retain even integers. \n    Non-integer types (e.g., floats, strings) should be removed from the result unless they are nested tuples, which are processed recursively.\n    \n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            return tuple((process_element(item) for item in element if process_element(item) is not None))\n        elif isinstance(element, int) and element % 2 == 0:\n            return element\n    return process_element(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            processed = tuple(filter(None, (process_element(sub_el) for sub_el in element)))\n            return processed if processed else None\n        return False\n    return tuple(filter(None, (process_element(el) for el in test_tuple)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            return tuple((process_element(sub_elem) for sub_elem in element if process_element(sub_elem) != ()))\n        elif isinstance(element, int) and element % 2 == 0:\n            return element\n        return ()\n    return tuple((process_element(elem) for elem in test_tuple if process_element(elem) != ()))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            processed = tuple(filter(None, map(process_element, element)))\n            return processed if processed else None\n        return False\n    result = tuple(filter(None, map(process_element, test_tuple)))\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            processed = tuple(filter(process_element, element))\n            return processed if processed else None\n        return False\n    result = tuple(filter(lambda x: x is not None, map(process_element, test_tuple)))\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            return extract_even(element)\n        elif isinstance(element, int) and element % 2 == 0:\n            return element\n    return tuple(filter(None, (process_element(item) for item in test_tuple)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            return tuple((process_element(e) for e in element if process_element(e) is not None))\n        elif isinstance(element, int) and element % 2 == 0:\n            return element\n        return None\n    return process_element(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, tuple):\n            return tuple((helper(item) for item in element if helper(item) != ()))\n        elif isinstance(element, int) and element % 2 == 0:\n            return element\n        return ()\n    return helper(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            processed = tuple(filter(None, (process_element(sub_el) for sub_el in element)))\n            return processed if processed else None\n        return False\n    return tuple(filter(None, (process_element(el) for el in test_tuple)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            return tuple((process_element(sub_elem) for sub_elem in element if process_element(sub_elem) != ()))\n        elif isinstance(element, int) and element % 2 == 0:\n            return element\n        return ()\n    return tuple((process_element(elem) for elem in test_tuple if process_element(elem) != ()))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.9}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n    \"\"\"\n    Write a Python function to find the surface area of a square pyramid with a given base edge `b` and slant height `s`.\n    The surface area is calculated using the formula: b ** 2 + 2 * b * s.\n    assert surface_Area(3, 4) == 33\n    \"\"\"", "generated_programs": ["def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/583", "requirement": "def catalan_number(num: int) -> int:\n    \"\"\"\n    Write a function which returns the nth Catalan number. The function should raise a ValueError if the input is a negative integer.\n    \n    Args:\n        num (int): The index of the Catalan number to compute.\n    \n    Returns:\n        int: The nth Catalan number.\n    \n    Raises:\n        ValueError: If the input is a negative integer.\n    \n    Examples:\n        >>> catalan_number(10)\n        16796\n        >>> catalan_number(-1)\n        ValueError\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0], catalan[1] = (1, 1)\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    for i in range(2, num + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0], catalan[1] = (1, 1)\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0], catalan[1] = (1, 1)\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0], catalan[1] = (1, 1)\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0], catalan[1] = (1, 1)\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Given rectangular coordinates (x, y), calculate and return both polar coordinates (radius, angle) and the original rectangular coordinates as a complex number.\n    \n    The polar coordinates are calculated as follows:\n    - Radius (r) is the Euclidean distance from the origin to the point (x, y).\n    - Angle (theta) is the angle in radians between the positive x-axis and the line connecting the origin to the point (x, y).\n    \n    The function returns a tuple containing:\n    - A tuple of polar coordinates (r, theta).\n    - The original rectangular coordinates as a complex number (x + yj).\n    \n    Examples:\n    >>> polar_rect(3, 4)\n    ((5.0, 0.9272952180016122), (3+4j))\n    \"\"\"", "generated_programs": ["from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    return ((r, theta), complex(x, y))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/592", "requirement": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given integer n.\n    Specifically, the function computes the sum of the product of C(n, i) and C(n, i+1) for i ranging from 0 to n-1.\n    assert sum_Of_product(3) == 15\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the difference between the first even and first odd number of a given list.\n    If either the first even or the first odd number is not found, the function should return 0.\n    \n    Examples:\n    >>> assert diff_even_odd([1,3,5,7,4,1,6,8]) == 3\n    >>> assert diff_even_odd([2,4,6,8,10]) == 0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    return first_odd - first_even", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_odd - first_even\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return abs(first_even - first_odd)\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return abs(first_even - first_odd)\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_odd - first_even\n    else:\n        return 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.5, "original_passk": 1.0}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the k-th smallest element in the merged sorted array of the given two sorted arrays.\n    The merged sorted array is formed by combining `arr1` and `arr2` in sorted order, considering all elements including duplicates.\n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/604", "requirement": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse the order of words in a given string, where words are separated by one or more spaces. \n    Leading, trailing, and multiple spaces between words should be normalized to a single space in the output.\n    assert reverse_words(\"python program\")==(\"program python\")\n    \"\"\"", "generated_programs": ["def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/620", "requirement": "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    \"\"\"\n    Write a function to find the size of the largest subset of a list of numbers such that for every pair of numbers in the subset, one number is divisible by the other. \n    The function should return 0 if the input list is empty.\n    \n    Examples:\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n    \"\"\"\n    Write a Python function to find the area of the largest right-angled triangle that can be inscribed in a semicircle with a given radius. \n    The largest right-angled triangle inscribed in a semicircle has its hypotenuse as the diameter of the semicircle.\n    The area of such a triangle is given by the formula: radius^2 * 2.\n    If the radius is negative, the function should return None.\n    assert triangle_area(-1) == None\n    \"\"\"", "generated_programs": ["def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/630", "requirement": "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given 2D coordinate tuple, including the original coordinate itself.\n    \n    The function should handle only tuples of length 2, representing 2D coordinates. For tuples of any other length, the function should raise a ValueError.\n    \n    The adjacent coordinates are defined as the 8 surrounding coordinates (including diagonals) and the original coordinate itself.\n    \n    Examples:\n    >>> get_coordinates((3, 4))\n    [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    \n    >>> get_coordinates((1, 1, 1))\n    ValueError\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x + dx, y + dy] for dx in range(-1, 2) for dy in range(-1, 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x + dx, y + dy] for dx in range(-1, 2) for dy in range(-1, 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x + dx, y + dy] for dx in range(-1, 2) for dy in range(-1, 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[dx, dy] for dx in range(x - 1, x + 2) for dy in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x + dx, y + dy] for dx in range(-1, 2) for dy in range(-1, 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x + dx, y + dy] for dx in range(-1, 2) for dy in range(-1, 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x + dx, y + dy] for dx in range(-1, 2) for dy in range(-1, 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x + dx, y + dy] for dx in range(-1, 2) for dy in range(-1, 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x - 1, y - 1], [x - 1, y], [x - 1, y + 1], [x, y - 1], [x, y], [x, y + 1], [x + 1, y - 1], [x + 1, y], [x + 1, y + 1]]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x - 1, y - 1], [x - 1, y], [x - 1, y + 1], [x, y - 1], [x, y], [x, y + 1], [x + 1, y - 1], [x + 1, y], [x + 1, y + 1]]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/631", "requirement": "def replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace all whitespaces with underscores in a given string.\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    \"\"\"", "generated_programs": ["def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the nearest integer given the wind velocity in km/h and a temperature in celsius.\n    assert wind_chill(120,35)==40\n    \"\"\"", "generated_programs": ["def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -45 <= t <= 10:\n        wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n        return round(wci)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -50 < t < 50:\n        wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n        return round(wc)\n    else:\n        return t", "def wind_chill(v: float, t: float) -> int:\n    from math import pow\n    if v > 4.8 and t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -50 < t < 50:\n        wc = 13.12 + 0.6215 * t - 11.37 * (v / 3.6) ** 0.16 + 0.3965 * t * (v / 3.6) ** 0.16\n        return round(wc)\n    else:\n        return t", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -50 < t < 50:\n        wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n        return round(wci)\n    else:\n        return t", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -50 < t < 50:\n        wc = 13.12 + 0.6215 * t - 11.37 * (v / 3.6) ** 0.16 + 0.3965 * t * (v / 3.6) ** 0.16\n    else:\n        wc = t\n    return round(wc)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -45 <= t <= 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n        return round(wc)\n    else:\n        return round(t)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/722", "requirement": "def filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    Filters the input dictionary of students, retaining only those whose height is greater than or equal to the minimum height `h` and whose weight is greater than or equal to the minimum weight `w`.\n    \n    The input is given as:\n    - a dictionary with a student name as a key and a tuple of floats (student_height, student_weight) as a value,\n    - a minimum height `h`,\n    - a minimum weight `w`.\n    \n    The function returns a new dictionary containing only the students who meet both the height and weight criteria.\n    \n    Example:\n    >>> filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70)\n    {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/735", "requirement": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Write a Python function to toggle the middle bits of the number, excluding the most significant bit (MSB) and the least significant bit (LSB) in its binary representation.\n    \n    - If the input number is 0, return 1.\n    - If the number has fewer than 3 bits, return the number as-is.\n    - For numbers with 3 or more bits, toggle all bits except the MSB and LSB.\n    \n    Examples:\n    >>> toggle_middle_bits(9)  # Binary: 1001 → 1111 (15)\n    15\n    >>> toggle_middle_bits(0)  # Binary: 0 → 1 (1)\n    1\n    >>> toggle_middle_bits(3)  # Binary: 11 → 11 (3)\n    3\n    \"\"\"", "generated_programs": ["def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    bin_rep = bin(n)[2:]\n    if len(bin_rep) < 3:\n        return n\n    middle_bits = ''.join(('1' if b == '0' else '0' for b in bin_rep[1:-1]))\n    return int(bin_rep[0] + middle_bits + bin_rep[-1], 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) < 3:\n        return n\n    middle_bits = binary_representation[1:-1]\n    toggled_middle_bits = ''.join(('1' if bit == '0' else '0' for bit in middle_bits))\n    result_binary = binary_representation[0] + toggled_middle_bits + binary_representation[-1]\n    return int(result_binary, 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) < 3:\n        return n\n    middle_bits_length = len(binary_representation) - 2\n    mask = (1 << middle_bits_length) - 1\n    mask <<= 1\n    toggled_middle_bits = n ^ mask\n    return toggled_middle_bits", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) < 3:\n        return n\n    middle_bits_length = len(binary_representation) - 2\n    mask = (1 << middle_bits_length) - 1\n    mask <<= 1\n    toggled_middle_bits = n ^ mask\n    return toggled_middle_bits", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n < 4:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) < 3:\n        return n\n    middle_bits_length = len(binary_representation) - 2\n    middle_bits_mask = (1 << middle_bits_length) - 1\n    middle_bits_mask <<= 1\n    toggled_middle_bits = n ^ middle_bits_mask\n    return toggled_middle_bits", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    bin_rep = bin(n)[2:]\n    if len(bin_rep) < 3:\n        return n\n    toggled_middle = ''.join(('1' if b == '0' else '0' for b in bin_rep[1:-1]))\n    return int(bin_rep[0] + toggled_middle + bin_rep[-1], 2)", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    binary_representation = bin(n)[2:]\n    if len(binary_representation) < 3:\n        return n\n    middle_bits = ''.join(('1' if b == '0' else '0' for b in binary_representation[1:-1]))\n    result_binary = binary_representation[0] + middle_bits + binary_representation[-1]\n    return int(result_binary, 2)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/740", "requirement": "from typing import Dict, Tuple, Any\n\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    \"\"\"\n    Write a function to convert the given tuple to a dictionary where each pair of adjacent elements \n    is treated as a key-value pair. The function should iterate through the tuple in steps of 2, \n    creating a dictionary entry for each pair. If the tuple has an odd number of elements, \n    the last element should be ignored.\n\n    Example:\n    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/743", "requirement": "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotate a given list by a specified number of items to the right direction. \n    If the input list is empty, a ZeroDivisionError will be raised.\n\n    Args:\n        l (List[int]): The list to be rotated.\n        m (int): The number of items to rotate the list by.\n\n    Returns:\n        List[int]: The rotated list.\n\n    Raises:\n        ZeroDivisionError: If the input list is empty.\n\n    Examples:\n        >>> rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n        [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n        >>> rotate_right([], 3)\n        ZeroDivisionError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\"\"\"\nWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. \nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        digits = [int(d) for d in str(num)]\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num)]\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.5, "original_passk": 0.8}}
{"task_id": "Mbpp/752", "requirement": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Jacobsthal number using the recurrence relation:\n    J(n) = J(n-1) + 2 * J(n-2), with base cases J(0) = 0 and J(1) = 1.\n    The sequence of Jacobsthal numbers is: 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    \n    The function should handle non-negative integer inputs. For negative inputs, the function should return 1.\n    \n    assert jacobsthal_num(5) == 11\n    \"\"\"", "generated_programs": ["def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j_prev2, j_prev1 = (0, 1)\n        for i in range(2, n + 1):\n            j_current = j_prev1 + 2 * j_prev2\n            j_prev2, j_prev1 = (j_prev1, j_current)\n        return j_prev1", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j_prev2, j_prev1 = (0, 1)\n        for _ in range(2, n + 1):\n            j_current = j_prev1 + 2 * j_prev2\n            j_prev2, j_prev1 = (j_prev1, j_current)\n        return j_prev1", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j_prev2, j_prev1 = (0, 1)\n        for _ in range(2, n + 1):\n            j_current = j_prev1 + 2 * j_prev2\n            j_prev2, j_prev1 = (j_prev1, j_current)\n        return j_prev1", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number using the formula: nth polite number = n + floor(log2(n + 1)) + 1.\n    A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers.\n    For more details, refer to: geeksforgeeks.org/n-th-polite-number/\n    \n    Parameters:\n    n (int): The position of the polite number in the sequence (1-based index).\n    \n    Returns:\n    int: The nth polite number.\n    \n    Examples:\n    >>> assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "from math import log2, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(log2(n + 1)) + 1", "from math import log2, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even number and the first odd number in a given list.\n    If either an even or an odd number is not found in the list, the function should return 0.\n    \n    Examples:\n    >>> mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8])\n    4\n    >>> mul_even_odd([2, 4, 6, 8])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    else:\n        return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/785", "requirement": "def tuple_str_int(test_str: str) -> tuple:\n    \"\"\"\n    Write a function to convert a tuple string to a tuple of integers. The function should strip the parentheses from the string, split the string by commas, and explicitly convert each element to an integer.\n    assert tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)\n    \"\"\"", "generated_programs": ["def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num.strip()) for num in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num.strip()) for num in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches a string that starts with 'a', is immediately followed by 'b', and ends with 'b'. The string must contain at least two characters: 'a' and 'b', and the last character must be 'b'.\n    assert text_starta_endb(\"aabbbb\")\n    \"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^ab.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^ab.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^ab.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^ab.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^ab.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^ab.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^ab.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^ab.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^ab.*b$', text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/16", "requirement": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if the input string contains at least one sequence of lowercase letters joined by a single underscore, and False otherwise. The string may contain other characters or sequences that do not follow this pattern.\n\n    Examples:\n    >>> text_lowercase_underscore(\"aab_cbbbc\")\n    True\n    >>> text_lowercase_underscore(\"abc_def_ghi_\")\n    True\n    \"\"\"", "generated_programs": ["def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.search('[a-z]+_[a-z]+', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.search('[a-z]+_[a-z]+', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.search('[a-z]+_[a-z]+', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.search('[a-z]+_[a-z]+', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.search('[a-z]+_[a-z]+', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.search('[a-z]+_[a-z]+', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.search('[a-z]+_[a-z]+', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.search('[a-z]+_[a-z]+', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.search('[a-z]+_[a-z]+', text))", "def text_lowercase_underscore(text: str) -> bool:\n    import re\n    return bool(re.search('[a-z]+_[a-z]+', text))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/63", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute difference between the two numbers in each tuple within the given list.\n    assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n    \"\"\"", "generated_programs": ["from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(x - y) for x, y in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(x - y) for x, y in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(x - y) for x, y in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(b - a) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(x - y) for x, y in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(b - a) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(x - y) for x, y in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(x - y) for x, y in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(x - y) for x, y in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    return max((abs(b - a) for a, b in test_list))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/72", "requirement": "def dif_Square(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given number can be represented as the difference of two squares, \n    i.e., whether there exist integers `a` and `b` such that `a² - b² = n`. The function should return `True` if such \n    a representation exists and `False` otherwise. The function should handle both positive and negative integers, \n    considering that the difference of squares can be positive, negative, or zero. The integers `a` and `b` can be \n    positive, negative, or zero. The function should iterate `a` from `0` to `abs(n) + 1` to ensure all possible \n    combinations are considered.\n\n    Examples:\n    - `dif_Square(5)` returns `True` because 3² - 2² = 9 - 4 = 5.\n    - `dif_Square(-4)` returns `True` because 0² - 2² = 0 - 4 = -4.\n    - `dif_Square(2)` returns `False` because no such integers `a` and `b` exist.\n\n    assert dif_Square(5) == True\n    \"\"\"", "generated_programs": ["def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        for b in range(abs(n) + 1):\n            if a ** 2 - b ** 2 == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        b_squared = a * a - n\n        if b_squared >= 0 and int(b_squared ** 0.5) ** 2 == b_squared:\n            return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        for b in range(abs(n) + 1):\n            if a ** 2 - b ** 2 == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        b_squared = a * a - n\n        if b_squared >= 0 and int(b_squared ** 0.5) ** 2 == b_squared:\n            return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        b_squared = a * a - n\n        if b_squared >= 0 and int(b_squared ** 0.5) ** 2 == b_squared:\n            return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        for b in range(abs(n) + 1):\n            if a ** 2 - b ** 2 == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        for b in range(abs(n) + 1):\n            if a ** 2 - b ** 2 == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        for b in range(abs(n) + 1):\n            if a ** 2 - b ** 2 == n:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        b_squared = a * a - n\n        if b_squared >= 0:\n            b = int(b_squared ** 0.5)\n            if b * b == b_squared:\n                return True\n    return False", "def dif_Square(n: int) -> bool:\n    for a in range(abs(n) + 1):\n        for b in range(abs(n) + 1):\n            if a ** 2 - b ** 2 == n:\n                return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n    \"\"\"\n    Determine if a given integer is divisible by 11. The function should consider the actual value of the integer, including negative numbers, and return True if the number is divisible by 11, otherwise False. The input is guaranteed to be a valid integer.\n\n    Examples:\n    >>> is_Diff(12345)\n    False\n    >>> is_Diff(-121)\n    True\n    \"\"\"", "generated_programs": ["def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/92", "requirement": "def is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not.\n    An undulating number is defined as a number where the digits strictly alternate between two distinct digits, \n    starting with the first digit being different from the second. For example, `1212121` is undulating because \n    it alternates between `1` and `2`. The number must have at least two digits to be considered undulating.\n    \n    assert is_undulating(1212121) == True\n    \"\"\"", "generated_programs": ["def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    if len(str(n)) < 2:\n        return False\n    digits = str(n)\n    first_digit = digits[0]\n    second_digit = digits[1]\n    if first_digit == second_digit:\n        return False\n    for i in range(2, len(digits)):\n        if i % 2 == 0 and digits[i] != first_digit:\n            return False\n        if i % 2 == 1 and digits[i] != second_digit:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    if n < 10:\n        return False\n    s = str(n)\n    if len(set(s)) != 2:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] != s[i + 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 2:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given positive integer.\n    The function should raise a ValueError if the input is not a positive integer.\n    \n    Parameters:\n    n (int): A positive integer for which the number of positive divisors is to be found.\n    \n    Returns:\n    int: The count of positive divisors of the input integer.\n    \n    Raises:\n    ValueError: If the input is not a positive integer.\n    \n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(-10)\n    ValueError\n    \"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/99", "requirement": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n    For the input `n = 0`, the function should return the string \"0\".\n    assert decimal_to_binary(8) == '1000'\n    \"\"\"", "generated_programs": ["def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/103", "requirement": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m), which is the number of permutations of the set {1, 2, ..., n} \n    with exactly m ascents. The function returns 0 if m is negative or if m is greater than or equal to n.\n    The Eulerian number is computed using dynamic programming, where the recurrence relation is defined as:\n    - dp[i][j] = 1 if j == 0 or j == i - 1\n    - dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j] if i > 1 and j < i\n    - dp[i][j] = 0 otherwise\n\n    Parameters:\n    n (int): The size of the set, must be a non-negative integer.\n    m (int): The number of ascents, must be a non-negative integer.\n\n    Returns:\n    int: The Eulerian number a(n, m), or 0 if m is invalid.\n\n    Examples:\n    >>> eulerian_num(3, 1)\n    4\n    \"\"\"", "generated_programs": ["def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(min(i, m + 1)):\n            if j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(min(i, m + 1)):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(min(i, m + 1)):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            elif i > 1 and j < i:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n - 1][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(min(i, m + 1)):\n            if j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(min(i, m + 1)):\n            if j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            elif i > 1 and j < i:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n - 1][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(min(i, m + 1)):\n            if j == 0 or j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(min(i, m + 1)):\n            if j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[i][i] = 1\n    for i in range(2, n):\n        for j in range(1, i):\n            dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n - 1][m]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 1.0}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements that are present in all nested lists.\n    The function should return a list of integers that are common to every nested list in the input.\n    If the input is an empty list or contains any empty nested list, the function should raise a TypeError.\n    \n    Examples:\n    >>> assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    >>> common_in_nested_lists([[]])\n    TypeError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/120", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute product of the two numbers in each tuple within a given list of tuples. Each tuple in the list must contain exactly two integers. The function calculates the product of the two numbers in each tuple, takes the absolute value of that product, and returns the maximum value among these absolute products.\n\n    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    \"\"\"", "generated_programs": ["from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n\"\"\"\nWrite a function to sum all amicable numbers from 1 to a specified number.\n\n\nassert amicable_numbers_sum(999)==504\n\"\"\"", "generated_programs": ["def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num in visited:\n            continue\n        partner = sum_of_divisors(num)\n        if partner != num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n            visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    checked = set()\n    for num in range(2, limit):\n        if num in checked:\n            continue\n        partner = sum_of_divisors(num)\n        if partner != num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n            checked.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((d for d in range(1, n) if n % d == 0))\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    checked = set()\n    for num in range(2, limit + 1):\n        if num in checked:\n            continue\n        partner = sum_of_divisors(num)\n        if partner != num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n            checked.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n    amicable_sum = 0\n    checked = set()\n    for num in range(2, limit + 1):\n        if num in checked:\n            continue\n        partner = sum_of_divisors(num)\n        if partner != num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n            checked.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Calculate the phase angle of the difference between two complex numbers `b` and `a`.\n\n    The function computes the phase angle (in radians) of the complex number resulting from the difference `b - a`.\n\n    Args:\n        a (complex): The first complex number.\n        b (complex): The second complex number.\n\n    Returns:\n        float: The phase angle of the complex number `b - a`.\n\n    Examples:\n        >>> import math\n        >>> math.isclose(angle_complex(0, 1j), 1.5707963267948966, rel_tol=0.001)\n        True\n    \"\"\"", "generated_programs": ["def angle_complex(a: complex, b: complex) -> float:\n    import cmath\n    return cmath.phase(b - a)", "def angle_complex(a: complex, b: complex) -> float:\n    import cmath\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    diff = b - a\n    return cmath.phase(diff)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    diff = b - a\n    return cmath.phase(diff)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "def angle_complex(a: complex, b: complex) -> float:\n    import cmath\n    return cmath.phase(b - a)", "def angle_complex(a: complex, b: complex) -> float:\n    import cmath\n    return cmath.phase(b - a)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/126", "requirement": "def sum_of_common_divisors(a: int, b: int) -> int:\n    \"\"\"\n    Write a Python function to calculate the sum of all common divisors of two given numbers.\n    The function should first determine the greatest common divisor (GCD) of the two numbers,\n    then find all divisors of the GCD, and finally return the sum of these divisors.\n    \n    Example:\n    assert sum_of_common_divisors(10, 15) == 6\n    \"\"\"", "generated_programs": ["def sum_of_common_divisors(a: int, b: int) -> int:\n    from math import gcd\n\n    def divisors(n):\n        result = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                result.add(i)\n                result.add(n // i)\n        return result\n    gcd_value = gcd(a, b)\n    common_divisors = divisors(gcd_value)\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n    from math import gcd\n\n    def sum_divisors(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                total += i\n        return total\n    common_gcd = gcd(a, b)\n    return sum_divisors(common_gcd)", "def sum_of_common_divisors(a: int, b: int) -> int:\n    from math import gcd\n\n    def sum_divisors(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                total += i\n        return total\n    common_gcd = gcd(a, b)\n    return sum_divisors(common_gcd)", "def sum_of_common_divisors(a: int, b: int) -> int:\n    from math import gcd\n\n    def divisors(n):\n        result = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                result.add(i)\n                result.add(n // i)\n        return result\n    g = gcd(a, b)\n    return sum(divisors(g))", "def sum_of_common_divisors(a: int, b: int) -> int:\n    from math import gcd\n\n    def sum_divisors(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                total += i\n        return total\n    common_gcd = gcd(a, b)\n    return sum_divisors(common_gcd)", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n\n    def sum_divisors(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                total += i\n        return total\n    common_gcd = gcd(a, b)\n    return sum_divisors(common_gcd)", "from math import gcd\n\ndef sum_of_common_divisors(a: int, b: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                total += i\n        return total\n    gcd_value = gcd(a, b)\n    return sum_of_divisors(gcd_value)", "def sum_of_common_divisors(a: int, b: int) -> int:\n    from math import gcd\n\n    def divisors(n):\n        result = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                result.add(i)\n                result.add(n // i)\n        return result\n    gcd_value = gcd(a, b)\n    common_divisors = divisors(gcd_value)\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n    from math import gcd\n\n    def sum_divisors(n):\n        total = 0\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    g = gcd(a, b)\n    return sum_divisors(g)", "def sum_of_common_divisors(a: int, b: int) -> int:\n    from math import gcd\n\n    def sum_divisors(n: int) -> int:\n        total = 0\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    return sum_divisors(gcd(a, b))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether the matrix is a magic square.\n    \n    A magic square is a square matrix where the sum of each row, each column, and both diagonals are equal to the magic sum, \n    which is calculated as `n * (n ** 2 + 1) // 2`, where `n` is the size of the matrix. Additionally, the matrix must be a \n    square (i.e., the number of rows equals the number of columns), and all elements must be unique.\n    \n    Args:\n        my_matrix (List[List[int]]): A square matrix of integers.\n    \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \n    Examples:\n        >>> magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])\n        True\n        >>> magic_square_test([[1, 1, 1], [1, 1, 1], [1, 1, 1]])\n        False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if len(set((num for row in my_matrix for num in row))) != n ** 2:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    flat_list = [num for row in my_matrix for num in row]\n    if len(flat_list) != len(set(flat_list)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if not all((sum(row) == magic_sum for row in my_matrix)):\n        return False\n    if not all((sum((my_matrix[i][j] for i in range(n))) == magic_sum for j in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    numbers = set()\n    for i in range(n):\n        row_sum = col_sum = 0\n        for j in range(n):\n            if my_matrix[i][j] in numbers:\n                return False\n            numbers.add(my_matrix[i][j])\n            row_sum += my_matrix[i][j]\n            col_sum += my_matrix[j][i]\n        if row_sum != magic_sum or col_sum != magic_sum:\n            return False\n    diag1_sum = diag2_sum = 0\n    for i in range(n):\n        diag1_sum += my_matrix[i][i]\n        diag2_sum += my_matrix[i][n - 1 - i]\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    elements = set()\n    for i in range(n):\n        row_sum = col_sum = 0\n        for j in range(n):\n            row_sum += my_matrix[i][j]\n            col_sum += my_matrix[j][i]\n            elements.add(my_matrix[i][j])\n        if row_sum != magic_sum or col_sum != magic_sum:\n            return False\n    if len(elements) != n ** 2:\n        return False\n    main_diag_sum = sum((my_matrix[i][i] for i in range(n)))\n    secondary_diag_sum = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    if main_diag_sum != magic_sum or secondary_diag_sum != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if len(set((num for row in my_matrix for num in row))) != n ** 2:\n        return False\n    if any((sum(row) != magic_sum for row in my_matrix)):\n        return False\n    if any((sum((my_matrix[i][j] for i in range(n))) != magic_sum for j in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if len(set((num for row in my_matrix for num in row))) != n ** 2:\n        return False\n    if any((sum(row) != magic_sum for row in my_matrix)):\n        return False\n    if any((sum((my_matrix[i][j] for i in range(n))) != magic_sum for j in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    flat_list = [num for row in my_matrix for num in row]\n    if len(flat_list) != len(set(flat_list)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if any((sum(row) != magic_sum for row in my_matrix)):\n        return False\n    if any((sum((my_matrix[i][j] for i in range(n))) != magic_sum for j in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    if len(set((num for row in my_matrix for num in row))) != n ** 2:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    numbers = set()\n    for i in range(n):\n        row_sum = col_sum = 0\n        for j in range(n):\n            if my_matrix[i][j] in numbers:\n                return False\n            numbers.add(my_matrix[i][j])\n            row_sum += my_matrix[i][j]\n            col_sum += my_matrix[j][i]\n        if row_sum != magic_sum or col_sum != magic_sum:\n            return False\n    main_diag_sum = sum((my_matrix[i][i] for i in range(n)))\n    sec_diag_sum = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    if main_diag_sum != magic_sum or sec_diag_sum != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = n * (n ** 2 + 1) // 2\n    elements = set()\n    for i in range(n):\n        row_sum = col_sum = 0\n        for j in range(n):\n            if my_matrix[i][j] in elements:\n                return False\n            elements.add(my_matrix[i][j])\n            row_sum += my_matrix[i][j]\n            col_sum += my_matrix[j][i]\n        if row_sum != magic_sum or col_sum != magic_sum:\n            return False\n    main_diag_sum = sum((my_matrix[i][i] for i in range(n)))\n    anti_diag_sum = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    return main_diag_sum == magic_sum and anti_diag_sum == magic_sum"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/137", "requirement": "from typing import List\n\n\ndef zero_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of zeroes to the number of non-zero elements in an array of integers.\n    The ratio is calculated as the number of zeroes divided by the number of non-zero elements.\n    If there are no non-zero elements, the function should return 0.0.\n    assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given number can be represented as a sum of distinct non-zero powers of 2.\n    A number can be represented as a sum of distinct non-zero powers of 2 if its binary representation contains more than one '1'.\n    For example, 10 (binary '1010') can be represented as 8 + 2, which are distinct non-zero powers of 2.\n    The function should return `False` if the number is a single non-zero power of 2 (e.g., 1, 2, 4, 8, etc.).\n    assert is_Sum_Of_Powers_Of_Two(10) == True\n    \"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/145", "requirement": "from typing import List\n\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the maximum absolute difference between any two elements in a given array.\n    The maximum absolute difference is defined as the difference between the maximum and minimum values in the array.\n    If the array is empty, the function should return 0.\n    \n    Examples:\n    >>> max_Abs_Diff((2, 1, 5, 3))\n    4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"\n    Write a function that returns the smallest non-negative integers x and y that satisfy the equation ax + by = n as a tuple, or return None if no such solution exists.\n    The solution should be the smallest non-negative solution, meaning both x and y should be non-negative and as small as possible, with x being minimized first, followed by y.\n    If either a or b is zero, the function should raise a ZeroDivisionError.\n    If either a or b is negative, the function should return None, as no non-negative solution exists in such cases.\n    assert find_solution(2, 3, 7) == (2, 1)\n    \"\"\"", "generated_programs": ["from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if a < 0 or b < 0:\n        return None\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if a < 0 or b < 0:\n        return None\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if a < 0 or b < 0:\n        return None\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if a < 0 or b < 0:\n        return None\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    if a < 0 or b < 0:\n        return None\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n    \"\"\"\n    Write a Python function to set all even bits of a given number to 1 only if they are not already set. \n    The function should return the original number if all even bits are already set.\n    \n    assert even_bit_set_number(10) == 10\n    \"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length() + 1, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position == 0:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position == 0:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 64:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position == 0:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position == 0:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 64:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position < 64:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position == 0:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_position = 0\n    while 1 << bit_position <= n or bit_position == 0:\n        if bit_position % 2 == 0:\n            mask |= 1 << bit_position\n        bit_position += 1\n    return n | mask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, \n    such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    \n    The sequence starts with any positive integer from 1 to m. For the first element, there is no previous element, \n    so it can be any integer from 1 to m. For each subsequent element, it must be at least twice the previous element \n    and at most m. The function should return 0 if n is 0, as there are no valid sequences of length 0.\n    \n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        next_start = start * 2\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        next_start = start * 2\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        next_start = start * 2\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        next_start = start * 2\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        next_start = start * 2\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        next_start = start * 2\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, remaining_length: int) -> int:\n        if remaining_length == 1:\n            return 1\n        total = 0\n        next_start = start * 2\n        while next_start <= m:\n            total += count_sequences(next_start, remaining_length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        next_start = start * 2\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        next_start = start * 2\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, remaining_length: int) -> int:\n        if remaining_length == 1:\n            return 1\n        total = 0\n        next_start = start * 2\n        while next_start <= m:\n            total += count_sequences(next_start, remaining_length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/253", "requirement": "from typing import List, Any\n\n\ndef count_integer(lst: List[Any]) -> int:\n    \"\"\"\n    Write a Python function that returns the number of integer elements in a given list, excluding boolean values.\n    The function should only count elements that are instances of `int` and not instances of `bool`.\n    \n    Example:\n    >>> count_integer([1, 2, 'abc', 1.2])\n    2\n    \"\"\"\n    pass", "generated_programs": ["from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Newman–Shanks–Williams prime number.\n    The sequence starts with the first element, where the initial values are `(1, 1)`.\n    For n == 1, the function should return 3.\n    The iteration starts from 2 to n + 1, updating the sequence values as follows:\n    c = 2 * b + a, where a and b are the previous two values in the sequence.\n    After the iteration, the function should return the last computed value `c`.\n    assert newman_prime(3) == 7\n    \"\"\"", "generated_programs": ["def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/265", "requirement": "from typing import List, Any\n\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Write a function that takes in a list `S` and an integer `step`, and splits the list into `step` sublists. \n    Each sublist contains elements spaced `step` apart, starting from different offsets. Specifically, the first \n    sublist contains elements at indices `0, step, 2*step, ...`, the second sublist contains elements at indices \n    `1, step+1, 2*step+1, ...`, and so on. The function returns a list of these sublists.\n\n    Example:\n    assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == \n    [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[offset::step] for offset in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[offset::step] for offset in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[offset::step] for offset in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[offset::step] for offset in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[offset::step] for offset in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for j in range((len(S) - i - 1) // step + 1)] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for j in range((len(S) - i - 1) // step + 1)] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[offset::step] for offset in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[offset::step] for offset in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for j in range((len(S) - i - 1) // step + 1)] for i in range(step)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/286", "requirement": "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the largest sum of a contiguous subarray in the modified array formed by repeating the given array k times. \n    The function should consider the possibility of wrapping around the array when calculating the maximum sum. \n    Specifically:\n    - If k == 1, the function should return the maximum subarray sum of the original array.\n    - If the total sum of the array is less than or equal to zero, the function should return the maximum subarray sum of the array repeated twice.\n    - If the total sum of the array is positive, the function should return the maximum of:\n        - The maximum subarray sum of the original array.\n        - The sum of the array repeated (k - 2) times plus the maximum subarray sum of the array concatenated with itself.\n    \n    assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * 2)\n    else:\n        max_kadane = kadane(a)\n        max_prefix_sum = max_suffix_sum = float('-inf')\n        current_prefix_sum = current_suffix_sum = 0\n        for i in range(n):\n            current_prefix_sum += a[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        for i in range(n - 1, -1, -1):\n            current_suffix_sum += a[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        return max(max_kadane, max_suffix_sum + max_prefix_sum + total_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * 2)\n    else:\n        max_kadane = kadane(a)\n        max_prefix_sum = max_suffix_sum = float('-inf')\n        current_prefix_sum = current_suffix_sum = 0\n        for i in range(n):\n            current_prefix_sum += a[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        for i in range(n - 1, -1, -1):\n            current_suffix_sum += a[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        return max(max_kadane, max_suffix_sum + max_prefix_sum + total_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * 2)\n    else:\n        max_kadane = kadane(a)\n        max_prefix_sum = max_suffix_sum = float('-inf')\n        current_prefix_sum = current_suffix_sum = 0\n        for i in range(n):\n            current_prefix_sum += a[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        for i in range(n - 1, -1, -1):\n            current_suffix_sum += a[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        return max(max_kadane, max_suffix_sum + max_prefix_sum + total_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * 2)\n    else:\n        max_kadane = kadane(a)\n        max_prefix_sum = max_suffix_sum = float('-inf')\n        current_prefix_sum = current_suffix_sum = 0\n        for i in range(n):\n            current_prefix_sum += a[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        for i in range(n - 1, -1, -1):\n            current_suffix_sum += a[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        return max(max_kadane, max_suffix_sum + max_prefix_sum + total_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * 2)\n    else:\n        max_kadane = kadane(a)\n        max_prefix_sum = max_suffix_sum = float('-inf')\n        current_prefix_sum = current_suffix_sum = 0\n        for i in range(n):\n            current_prefix_sum += a[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        for i in range(n - 1, -1, -1):\n            current_suffix_sum += a[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        return max(max_kadane, max_suffix_sum + max_prefix_sum + total_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * 2)\n    else:\n        max_kadane = kadane(a)\n        max_prefix_sum = max_suffix_sum = float('-inf')\n        current_prefix_sum = current_suffix_sum = 0\n        for i in range(n):\n            current_prefix_sum += a[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        for i in range(n - 1, -1, -1):\n            current_suffix_sum += a[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        return max(max_kadane, max_suffix_sum + max_prefix_sum + total_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * 2)\n    else:\n        max_kadane = kadane(a)\n        max_prefix_sum = max_suffix_sum = float('-inf')\n        current_prefix_sum = current_suffix_sum = 0\n        for i in range(n):\n            current_prefix_sum += a[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        for i in range(n - 1, -1, -1):\n            current_suffix_sum += a[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        return max(max_kadane, max_suffix_sum + max_prefix_sum + total_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    if k == 1:\n        return kadane(a)\n    total_sum = sum(a)\n    if total_sum <= 0:\n        return kadane(a * 2)\n    else:\n        max_kadane = kadane(a)\n        max_prefix_sum = max_suffix_sum = float('-inf')\n        current_prefix_sum = current_suffix_sum = 0\n        for i in range(n):\n            current_prefix_sum += a[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        for i in range(n - 1, -1, -1):\n            current_suffix_sum += a[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        return max(max_kadane, total_sum * (k - 2) + max_prefix_sum + max_suffix_sum)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    if k == 1:\n        return kadane(a)\n    total_sum = sum(a)\n    if total_sum <= 0:\n        return kadane(a * 2)\n    else:\n        max_kadane = kadane(a)\n        max_prefix_sum = max_suffix_sum = float('-inf')\n        current_prefix_sum = current_suffix_sum = 0\n        for i in range(n):\n            current_prefix_sum += a[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        for i in range(n - 1, -1, -1):\n            current_suffix_sum += a[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        return max(max_kadane, max_suffix_sum + max_prefix_sum + total_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    if total_sum <= 0:\n        return kadane(a * 2)\n    else:\n        max_kadane = kadane(a)\n        max_prefix_sum = max_suffix_sum = 0\n        current_prefix_sum = current_suffix_sum = 0\n        for i in range(n):\n            current_prefix_sum += a[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        for i in range(n - 1, -1, -1):\n            current_suffix_sum += a[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        return max(max_kadane, max_suffix_sum + max_prefix_sum + total_sum * (k - 2))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n    \"\"\"\n    Write a function to find the depth of a dictionary. \n    The depth of a dictionary is defined as the number of nested dictionaries it contains, including itself. \n    An empty dictionary is considered to have a depth of 1. \n    Non-dictionary inputs should return a depth of 0.\n    \n    Examples:\n    >>> dict_depth({'a':1, 'b': {'c': {'d': {}}}})\n    4\n    >>> dict_depth({})\n    1\n    >>> dict_depth(123)\n    0\n    \"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum of a strictly increasing subsequence that ends at the kth element, \n    where the subsequence is formed from the prefix of the list up to the ith index (i <= index) and must include \n    the kth element. The function should return the sum of this subsequence. If index >= k, the function should \n    return -1, as it is not possible to form such a subsequence.\n\n    Args:\n        a (List[int]): The input list of integers.\n        n (int): The length of the list.\n        index (int): The index up to which the prefix is considered.\n        k (int): The index of the element that must be included in the subsequence.\n\n    Returns:\n        int: The maximum sum of the strictly increasing subsequence ending at the kth element, or -1 if index >= k.\n\n    Examples:\n        >>> max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6)\n        11\n        >>> max_sum_increasing_subseq([5, 4, 3, 2, 1], 5, 1, 3)\n        -1\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, k + 1):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, k + 1):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, k + 1):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, k + 1):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, k + 1):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, k + 1):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, k + 1):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, k + 1):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, k + 1):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= k:\n        return -1\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(1, k + 1):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    return dp[k]"], "result": {"repaired_passk": 0.19999999999999996, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n    \"\"\"\n    Write a function to convert a given string to a tuple of characters, excluding spaces.\n    assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n    \"\"\"", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the most significant unset bit in the binary representation of the given integer.\n    The most significant unset bit is the highest-order bit that is unset, starting from the leftmost bit (MSB) to the rightmost bit (LSB).\n    assert set_left_most_unset_bit(10) == 14\n    \"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask & n:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask & n:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask & n:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/391", "requirement": "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    \"\"\"\n    Converts three lists of equal length into a list of nested dictionaries. Each nested dictionary contains a single key-value pair, where the key is an element from `list1` and the value is another dictionary. The inner dictionary has a key from `list2` and a value from `list3`.\n\n    The function assumes that all three input lists are of equal length. If the lists are of unequal length, the behavior is undefined and may result in an `IndexError`.\n\n    Args:\n        list1 (List[Any]): A list of keys for the outer dictionary.\n        list2 (List[Any]): A list of keys for the inner dictionary.\n        list3 (List[Any]): A list of values for the inner dictionary.\n\n    Returns:\n        List[Dict[Any, Dict[Any, Any]]]: A list of nested dictionaries, where each dictionary has the structure {list1[i]: {list2[i]: list3[i]}}.\n\n    Examples:\n        >>> convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"], [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"], [85, 98, 89, 92])\n        [{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]\n\n        >>> convert_list_dictionary(['B001', 'B002'], ['Alice Smith'], [90, 95])\n        ['IndexError']\n    \"\"\"", "generated_programs": ["from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]\n    except IndexError:\n        return ['IndexError']", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]\n    except IndexError:\n        return ['IndexError']", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]\n    except IndexError:\n        return ['IndexError']", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        return [{k1: {k2: v3}} for k1, k2, v3 in zip(list1, list2, list3)]\n    except IndexError:\n        return ['IndexError']", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]\n    except IndexError:\n        return ['IndexError']", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        return [{k1: {k2: v3}} for k1, k2, v3 in zip(list1, list2, list3)]\n    except IndexError:\n        return ['IndexError']", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]\n    except IndexError:\n        return ['IndexError']", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]\n    except IndexError:\n        return ['IndexError']", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        return [{k1: {k2: v}} for k1, k2, v in zip(list1, list2, list3)]\n    except IndexError:\n        return ['IndexError']", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    try:\n        return [{k1: {k2: v3}} for k1, k2, v3 in zip(list1, list2, list3)]\n    except IndexError:\n        return ['IndexError']"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.4, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find the directrix of a parabola given in the form y = ax^2 + bx + c.\n    The directrix is calculated using the formula: directrix = -1000 // (4 * a) - 148.\n    The coefficients b and c are not used in the calculation.\n    assert parabola_directrix(5,3,2)==-198\n    \"\"\"", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -1000 // (4 * a) - 148"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.5}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n    \"\"\"\n    Calculate the sum of Perrin numbers up to the nth index (inclusive).\n    \n    The Perrin sequence is defined as:\n    P(0) = 3, P(1) = 0, P(2) = 2,\n    and for n > 2, P(n) = P(n-2) + P(n-3).\n    \n    The function returns the sum of Perrin numbers from P(0) to P(n).\n    \n    Edge cases:\n    - If n is 0, the function returns 3.\n    - If n is 1, the function returns 3.\n    - If n is 2, the function returns 5.\n    - If n is negative, the function raises an IndexError.\n    \n    Examples:\n    >>> cal_sum(2)\n    5\n    >>> cal_sum(-1)\n    IndexError\n    >>> cal_sum(0)\n    3\n    \n    assert cal_sum(9) == 49\n    \"\"\"", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    p0, p1, p2 = (3, 0, 2)\n    total_sum = p0 + p1 + p2\n    for i in range(3, n + 1):\n        p_next = p0 + p1\n        total_sum += p_next\n        p0, p1, p2 = (p1, p2, p_next)\n    return total_sum", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    p0, p1, p2 = (3, 0, 2)\n    total_sum = p0 + p1 + p2\n    for i in range(3, n + 1):\n        p_next = p0 + p1\n        total_sum += p_next\n        p0, p1, p2 = (p1, p2, p_next)\n    return total_sum", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    p0, p1, p2 = (3, 0, 2)\n    total_sum = p0 + p1 + p2\n    for i in range(3, n + 1):\n        p_next = p0 + p1\n        total_sum += p_next\n        p0, p1, p2 = (p1, p2, p_next)\n    return total_sum"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of positive even factors of a given non-negative integer.\n    A factor is considered even if it is divisible by 2. The function should return 0 for negative inputs.\n    \n    Examples:\n    >>> sumofFactors(18)\n    26\n    >>> sumofFactors(-12)\n    0\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n < 0:\n        return 0\n    total = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            total += i\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/465", "requirement": "def drop_empty(dict1: dict) -> dict:\n    \"\"\"\n    Write a function to drop key-value pairs from a given dictionary where the value is `None`.\n\n    Args:\n        dict1 (dict): The input dictionary from which to remove `None` values.\n\n    Returns:\n        dict: A new dictionary with all key-value pairs where the value is not `None`.\n\n    Examples:\n        >>> drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None})\n        {'c1': 'Red', 'c2': 'Green'}\n    \"\"\"", "generated_programs": ["def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product of any two numbers in the array where the second number is greater than the first.\n    The function should consider all pairs of numbers (i, j) where i < j and arr[j] > arr[i], and return the maximum product of such pairs.\n    \n    Examples:\n    >>> max_product([3, 100, 4, 5, 150, 6])\n    3000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/471", "requirement": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function to find the remainder of the product of all elements in the array when divided by n.\n    The product of an empty array is considered to be 1. The modulo operation is applied after computing the entire product.\n    \n    Examples:\n    >>> find_remainder([100, 10, 5, 25, 35, 14], 11)\n    9\n    >>> find_remainder([], 10)\n    1\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/479", "requirement": "def first_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the first digit of a given number, retaining the sign of the original number.\n    For example, for the input -456, the function should return -456.\n    assert first_Digit(123) == 1\n    \"\"\"", "generated_programs": ["def first_Digit(n: int) -> int:\n    while n >= 10 or n <= -10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    while n >= 10 or n <= -10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    n = abs(n)\n    while n >= 10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    while n >= 10 or n <= -10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    while n >= 10 or n <= -10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    while n >= 10 or n <= -10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    while n >= 10 or n <= -10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    n = abs(n)\n    while n >= 10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    while n >= 10 or n <= -10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    while n >= 10 or n <= -10:\n        n //= 10\n    return n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/558", "requirement": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of the per-digit difference between two integers. \n    The function should pad the shorter number with leading zeros to match the length of the longer number \n    before calculating the absolute difference for each digit position.\n    \n    assert digit_distance_nums(1,2) == 1\n    \"\"\"", "generated_programs": ["def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/559", "requirement": "from typing import List\n\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Find the maximum sum of any contiguous sublist in the given list. \n    If the list is empty, return negative infinity (`-inf`). \n    The function should handle cases where all elements are negative by returning the maximum sum of any sublist, which could be a single element.\n\n    Examples:\n    >>> max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8)\n    7\n    >>> max_sub_array_sum([], 0)\n    -inf\n    \"\"\"", "generated_programs": ["from typing import List, Union\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> Union[int, float]:\n    if not a:\n        return -math.inf\n    max_ending_here = max_so_far = a[0]\n    for x in a[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_ending_here = max_so_far = a[0]\n    for x in a[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List, Union\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> Union[int, float]:\n    if not a:\n        return -math.inf\n    max_so_far = max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List, Union\n\ndef max_sub_array_sum(a: List[int], size: int) -> Union[int, float]:\n    if not a:\n        return float('-inf')\n    max_so_far = max_ending_here = a[0]\n    for x in a[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_ending_here = max_so_far = a[0]\n    for x in a[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List, Union\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> Union[int, float]:\n    if not a:\n        return -math.inf\n    max_ending_here = max_so_far = a[0]\n    for x in a[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List, Union\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> Union[int, float]:\n    if not a:\n        return -math.inf\n    max_so_far = max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/563", "requirement": "def extract_values(text: str) -> List[str]:\n    \"\"\"Extract all substrings that are enclosed within double quotation marks from the input string.\n    Each substring should be captured without the surrounding quotes.\n    assert extract_values('\"Python\", \"PHP\", \"Java\"')==['Python', 'PHP', 'Java']\n    \"\"\"", "generated_programs": ["from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "def count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Counts the number of unordered pairs (i, j) where i < j and arr[i] != arr[j].\n    The function iterates through all possible pairs in the list and increments the count if the elements in the pair are not equal.\n    assert count_Pairs([1,2,1],3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/579", "requirement": "from typing import Tuple, Any\n\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    \"\"\"\n    Write a function to find the dissimilar elements in the given two tuples. The function should return a tuple containing the elements that are present in either of the tuples but not in both, sorted in ascending order.\n\n    Examples:\n    >>> find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10))\n    (3, 6, 7, 10)\n    >>> find_dissimilar(((1, 2), (3, 4)), ((1, 2), (5, 6)))\n    ((3, 4), (5, 6))\n\n    Args:\n        test_tup1 (Tuple[Any, ...]): The first tuple.\n        test_tup2 (Tuple[Any, ...]): The second tuple.\n\n    Returns:\n        Tuple[Any, ...]: A tuple containing the dissimilar elements sorted in ascending order.\n    \"\"\"", "generated_programs": ["from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Write a function to remove non-integer elements and uneven integers from a nested mixed tuple. \n    The function should recursively process nested tuples, retaining only even integers at all levels of nesting.\n    Non-integer elements (e.g., floats, strings) should be removed, and nested tuples should be processed to retain only even integers.\n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return element\n        elif isinstance(element, tuple):\n            processed = tuple((process_element(item) for item in element))\n            return tuple(filter(None, processed))\n        return None\n    result = process_element(test_tuple)\n    return tuple(filter(None, result))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            processed = tuple(filter(process_element, element))\n            return processed if processed else None\n        return False\n    result = tuple(filter(lambda x: x is not None, map(process_element, test_tuple)))\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return element\n        elif isinstance(element, tuple):\n            processed = tuple((process_element(item) for item in element))\n            return tuple(filter(lambda x: x is not None, processed))\n        return None\n    return process_element(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return (element,)\n        elif isinstance(element, tuple):\n            return tuple((item for sub_element in element for item in helper(sub_element)))\n        return ()\n    return tuple((item for sub_element in test_tuple for item in helper(sub_element)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return element\n        elif isinstance(element, tuple):\n            processed = tuple((process_element(item) for item in element))\n            return tuple(filter(lambda x: x is not None, processed))\n        return None\n    return process_element(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return element\n        elif isinstance(element, tuple):\n            processed = tuple((process_element(e) for e in element))\n            return tuple(filter(lambda x: x is not None, processed))\n        else:\n            return None\n    return process_element(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return element\n        elif isinstance(element, tuple):\n            result = tuple((helper(item) for item in element))\n            return result if any((isinstance(item, int) for item in result)) else ()\n        return None\n    return tuple(filter(None, helper(test_tuple)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return element\n        elif isinstance(element, tuple):\n            result = tuple((helper(item) for item in element))\n            return result if any((isinstance(item, int) for item in result)) else ()\n        return None\n    return tuple(filter(lambda x: x is not None, helper(test_tuple)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            processed = tuple(filter(None, (process_element(sub_el) for sub_el in element)))\n            return processed if processed else None\n        return None\n    return tuple(filter(None, (process_element(el) for el in test_tuple)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            processed = tuple(filter(None, (process_element(item) for item in element)))\n            return processed if processed else None\n        return None\n    result = tuple(filter(None, (process_element(item) for item in test_tuple)))\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.30000000000000004, "original_passk": 0.9}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n    \"\"\"\n    Write a Python function to find the surface area of a square pyramid with a given base edge and slant height.\n    The slant height (s) is the distance along the lateral face from the base edge to the apex of the pyramid.\n    The surface area is calculated as the sum of the base area (b ** 2) and the lateral area (2 * b * s).\n    assert surface_Area(3, 4) == 33\n    \"\"\"", "generated_programs": ["def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/583", "requirement": "def catalan_number(num: int) -> int:\n    \"\"\"\n    Write a function which returns the nth Catalan number for a non-negative integer n. \n    The function should raise a ValueError if the input is a negative integer.\n    \n    Args:\n        num (int): A non-negative integer representing the index of the Catalan number.\n    \n    Returns:\n        int: The nth Catalan number.\n    \n    Raises:\n        ValueError: If the input num is a negative integer.\n    \n    Examples:\n        >>> catalan_number(10)\n        16796\n        >>> catalan_number(-1)\n        ValueError\n    \"\"\"", "generated_programs": ["def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0], catalan[1] = (1, 1)\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0], catalan[1] = (1, 1)\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import factorial\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return factorial(2 * num) // (factorial(num + 1) * factorial(num))", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0], catalan[1] = (1, 1)\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0], catalan[1] = (1, 1)\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0], catalan[1] = (1, 1)\n    for i in range(2, num + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]", "def catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    if num == 0 or num == 1:\n        return 1\n    catalan = [0] * (num + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    for i in range(2, num + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[num]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Convert polar coordinates to rectangular coordinates and return both the polar and rectangular representations.\n    \n    The function takes two inputs:\n    - r: The magnitude (radius) of the polar coordinate.\n    - theta: The angle (in radians) of the polar coordinate.\n    \n    The function returns a tuple containing:\n    - A tuple of the polar coordinates (magnitude, angle) calculated from the rectangular coordinates.\n    - A complex number representing the rectangular coordinates (x + yj), where x = r * cos(theta) and y = r * sin(theta).\n    \n    Example:\n    >>> polar_rect(3, 4)\n    ((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_complex = complex(x, y)\n    polar_magnitude = abs(rect_complex)\n    polar_angle = cmath.phase(rect_complex)\n    return ((polar_magnitude, polar_angle), rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_complex = complex(x, y)\n    mag = abs(rect_complex)\n    angle = cmath.phase(rect_complex)\n    return ((mag, angle), rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_complex = complex(x, y)\n    magnitude = abs(rect_complex)\n    angle = cmath.phase(rect_complex)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_complex = complex(x, y)\n    polar_magnitude = abs(rect_complex)\n    polar_angle = cmath.phase(rect_complex)\n    return ((polar_magnitude, polar_angle), rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_complex = complex(x, y)\n    polar_magnitude = abs(rect_complex)\n    polar_angle = cmath.phase(rect_complex)\n    return ((polar_magnitude, polar_angle), rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_complex = complex(x, y)\n    magnitude = abs(rect_complex)\n    angle = cmath.phase(rect_complex)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_complex = complex(x, y)\n    polar_magnitude = abs(rect_complex)\n    polar_angle = cmath.phase(rect_complex)\n    return ((polar_magnitude, polar_angle), rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_complex = complex(x, y)\n    mag = abs(rect_complex)\n    angle = cmath.phase(rect_complex)\n    return ((mag, angle), rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_complex = complex(x, y)\n    magnitude = abs(rect_complex)\n    angle = cmath.phase(rect_complex)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_complex = complex(x, y)\n    polar_magnitude = abs(rect_complex)\n    polar_angle = cmath.phase(rect_complex)\n    return ((polar_magnitude, polar_angle), rect_complex)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/592", "requirement": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given integer n.\n    Specifically, the function computes the sum of the product of comb(n, i) and comb(n, i + 1) for i ranging from 0 to n-1.\n    assert sum_Of_product(3) == 15\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the difference between the first even number and the first odd number in a given list.\n    The function should return the difference if both an even and an odd number are found; otherwise, it should return 0.\n    assert diff_even_odd([1,3,5,7,4,1,6,8])==3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the k-th smallest element from the combined sorted array formed by merging the two given sorted arrays, arr1 and arr2. \n    The function should consider duplicates and return the k-th element when both arrays are merged in sorted order. \n    If k is out of bounds (i.e., k is less than 1 or greater than the total number of elements in the combined array), the function should raise an IndexError.\n    \n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged):\n        raise IndexError\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged):\n        raise IndexError('k is out of bounds')\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged):\n        raise IndexError\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged):\n        raise IndexError\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged):\n        raise IndexError('k is out of bounds')\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged):\n        raise IndexError\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged):\n        raise IndexError\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged):\n        raise IndexError('k is out of bounds')\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged):\n        raise IndexError('k is out of bounds')\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k < 1 or k > len(merged):\n        raise IndexError('k is out of bounds')\n    return merged[k - 1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/620", "requirement": "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    \"\"\"\n    Write a function to find the size of the largest subset of a list of numbers where for every pair of numbers in the subset, one number is divisible by the other.\n    The function should return 0 if the input list is empty.\n    \n    Examples:\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n    \"\"\"\n    Write a Python function to find the area of the largest right-angled triangle that can be inscribed in a semicircle with a given radius. \n    The triangle has its hypotenuse equal to the diameter of the semicircle and its legs equal to the radius of the semicircle. \n    The area of the triangle is calculated as the square of the radius. \n    The function should return `None` if the radius is negative.\n    assert triangle_area(-1) == None\n    \"\"\"", "generated_programs": ["def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius * radius", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius * radius", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius * radius", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius * radius", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius < 0:\n        return None\n    return radius * radius"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/630", "requirement": "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given 2D coordinate tuple, including the original coordinate.\n    The function should raise a ValueError if the input tuple does not have exactly two dimensions.\n    \n    Args:\n        test_tup (Tuple[int, ...]): A tuple representing a 2D coordinate. The tuple must have exactly two elements.\n    \n    Returns:\n        List[List[int]]: A list of lists, where each inner list represents an adjacent coordinate, including the original coordinate.\n    \n    Raises:\n        ValueError: If the input tuple does not have exactly two dimensions.\n    \n    Examples:\n        >>> get_coordinates((3, 4))\n        [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n        \n        >>> get_coordinates((1, 1, 1))\n        ValueError\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x + dx, y + dy] for dx in range(-1, 2) for dy in range(-1, 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x + dx, y + dy] for dx in range(-1, 2) for dy in range(-1, 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[x + dx, y + dy] for dx in range(-1, 2) for dy in range(-1, 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/631", "requirement": "def replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace all whitespaces with underscores in a given string.\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    \"\"\"", "generated_programs": ["def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the nearest integer given the wind velocity in km/h and a temperature in celsius.\n    assert wind_chill(120,35)==40\n    \"\"\"", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    if v < 5 or t > 10:\n        return round(t)\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wc)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and t < 10:\n        wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    else:\n        wci = t\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    from math import pow\n    if v > 4.8 and -45 <= t <= 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n    else:\n        wc = t\n    return round(wc)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -45 <= t <= 10:\n        wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n        return round(wci)\n    else:\n        return round(t)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    if v < 4.8 or t > 10:\n        return round(t)\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * math.pow(v / 3.6, 0.16) + 0.3965 * t * math.pow(v / 3.6, 0.16)\n        return round(wc)\n    else:\n        return round(t)", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    if v > 4.8 and t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -45 < t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    from math import pow\n    if v > 4.8 and -45 <= t <= 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n        return round(wc)\n    else:\n        return round(t)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/722", "requirement": "def filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    Filters students whose height and weight are both greater than or equal to the specified minimum values.\n    The function returns a dictionary containing only those students who meet both the height and weight criteria.\n    \n    Args:\n        students: A dictionary where the key is the student's name and the value is a tuple of (height, weight).\n        h: The minimum height threshold. Students must have a height greater than or equal to this value.\n        w: The minimum weight threshold. Students must have a weight greater than or equal to this value.\n    \n    Returns:\n        A dictionary of students who meet both the height and weight criteria, with their names as keys and (height, weight) tuples as values.\n    \n    Example:\n        >>> filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70)\n        {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/735", "requirement": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Write a Python function to toggle all bits of the number except the most significant bit (MSB) and the least significant bit (LSB).\n    - If the number has 2 or fewer bits, return the number as-is.\n    - If the input is 0, return 1.\n    assert toggle_middle_bits(9) == 15\n    \"\"\"", "generated_programs": ["def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() <= 2:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() <= 2:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() <= 2:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() <= 2:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() <= 2:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() <= 2:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() <= 2:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() <= 2:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() <= 2:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() <= 2:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/740", "requirement": "from typing import Dict\nfrom typing import Tuple\nfrom typing import Any\n\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    \"\"\"\n    Write a function to convert the given tuple to a key-value dictionary by pairing every two consecutive elements.\n    The first element of each pair becomes the key, and the second element becomes the value. \n    The function assumes the tuple has an even number of elements. If the tuple has an odd number of elements, \n    the last element is ignored.\n    \n    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict\nfrom typing import Tuple\nfrom typing import Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict\nfrom typing import Tuple\nfrom typing import Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict\nfrom typing import Tuple\nfrom typing import Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict\nfrom typing import Tuple\nfrom typing import Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict\nfrom typing import Tuple\nfrom typing import Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict\nfrom typing import Tuple\nfrom typing import Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/743", "requirement": "from typing import List\n\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotates the given list `l` by `m` items to the right in a cyclic manner. \n    If the list is empty, a `ZeroDivisionError` will be raised. \n    The rotation is cyclic, meaning that if `m` exceeds the length of the list, \n    it wraps around using the modulo operation (`m % len(l)`). \n    If `m` is zero or negative, the function will still perform a cyclic rotation \n    based on the modulo result.\n\n    Examples:\n    >>> rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n    [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    >>> rotate_right([], 3)\n    ZeroDivisionError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    return l[-m:] + l[:-m]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\"\"\"\nWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. \nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num)]\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num)]\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if not any(map(lambda x: int(x) == 0 or num % int(x) != 0, str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num)]\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if not num:\n            continue\n        num_str = str(num)\n        divisible = True\n        for digit in num_str:\n            if digit == '0' or num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.7, "original_passk": 0.8}}
{"task_id": "Mbpp/752", "requirement": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Compute the nth Jacobsthal number using an iterative approach.\n    The Jacobsthal sequence is defined as:\n    J(0) = 0, J(1) = 1, and J(n) = J(n-1) + 2 * J(n-2) for n >= 2.\n    The function should handle non-negative integer inputs and return the nth Jacobsthal number.\n    For invalid inputs (e.g., negative integers), the behavior is undefined.\n\n    Examples:\n    >>> jacobsthal_num(5)\n    11\n    >>> jacobsthal_num(0)\n    0\n    >>> jacobsthal_num(1)\n    1\n    \"\"\"", "generated_programs": ["def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    prev, curr = (0, 1)\n    for _ in range(2, n + 1):\n        prev, curr = (curr, curr + 2 * prev)\n    return curr", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    j_prev2 = 0\n    j_prev1 = 1\n    for i in range(2, n + 1):\n        j_current = j_prev1 + 2 * j_prev2\n        j_prev2 = j_prev1\n        j_prev1 = j_current\n    return j_prev1", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        prev, curr = (0, 1)\n        for _ in range(2, n + 1):\n            prev, curr = (curr, curr + 2 * prev)\n        return curr", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j0, j1 = (0, 1)\n        for i in range(2, n + 1):\n            j_next = j1 + 2 * j0\n            j0, j1 = (j1, j_next)\n        return j1", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        prev2, prev1 = (0, 1)\n        for i in range(2, n + 1):\n            current = prev1 + 2 * prev2\n            prev2, prev1 = (prev1, current)\n        return prev1", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    prev, curr = (0, 1)\n    for _ in range(2, n + 1):\n        prev, curr = (curr, curr + 2 * prev)\n    return curr", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    prev, curr = (0, 1)\n    for _ in range(2, n + 1):\n        prev, curr = (curr, curr + 2 * prev)\n    return curr", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j_prev2, j_prev1 = (0, 1)\n        for i in range(2, n + 1):\n            j_current = j_prev1 + 2 * j_prev2\n            j_prev2, j_prev1 = (j_prev1, j_current)\n        return j_current", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    prev, curr = (0, 1)\n    for _ in range(2, n + 1):\n        prev, curr = (curr, curr + 2 * prev)\n    return curr", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    j_prev2 = 0\n    j_prev1 = 1\n    j_current = 0\n    for i in range(2, n + 1):\n        j_current = j_prev1 + 2 * j_prev2\n        j_prev2 = j_prev1\n        j_prev1 = j_current\n    return j_current"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int = None) -> int:\n    \"\"\"\n    Write a Python function to find the minimum difference between any two elements in a given array or tuple.\n    The function should handle both lists and tuples as input. The parameter `n` is optional and should be ignored.\n    The array or tuple should be sorted before calculating the minimum difference.\n    \n    Examples:\n    >>> find_min_diff((1, 5, 3, 19, 18, 25), 6)\n    1\n    \"\"\"", "generated_programs": ["from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] < min_diff:\n            min_diff = arr[i + 1] - arr[i]\n    return min_diff", "from typing import List, Tuple, Union\n\ndef find_min_diff(arr: Union[List[int], Tuple[int, ...]], n: int=None) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] < min_diff:\n            min_diff = arr[i + 1] - arr[i]\n    return min_diff"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number. A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers. The sequence of polite numbers starts as 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, ... \n    The function should return the nth number in this sequence.\n    \n    assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["def is_polite(n: int) -> int:\n\n    def is_not_powers_of_two(x):\n        return x & x - 1\n    count = 0\n    num = 1\n    while count < n:\n        num += 1\n        if is_not_powers_of_two(num):\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n\n    def is_not_powers_of_two(x):\n        return x & x - 1 != 0\n    count = 0\n    num = 1\n    while count < n:\n        num += 1\n        if is_not_powers_of_two(num):\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x: int) -> bool:\n        return x & x - 1 != 0\n    count = 0\n    num = 2\n    while True:\n        num += 1\n        if is_polite_number(num):\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x: int) -> bool:\n        return x & x - 1 != 0\n    count = 0\n    num = 2\n    while count < n:\n        num += 1\n        if is_polite_number(num):\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        return x & x - 1 != 0\n    count = 0\n    num = 2\n    while True:\n        num += 1\n        if is_polite_number(num):\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        return x & x - 1 != 0\n    count = 0\n    num = 2\n    while True:\n        num += 1\n        if is_polite_number(num):\n            count += 1\n        if count == n:\n            return num", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        return x & x - 1 != 0\n    count = 0\n    num = 2\n    while True:\n        num += 1\n        if is_polite_number(num):\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        return x & x - 1 != 0\n    count = 0\n    num = 2\n    while count < n:\n        num += 1\n        if is_polite_number(num):\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n\n    def is_not_powers_of_two(x):\n        return x & x - 1 != 0\n    count = 0\n    num = 2\n    while True:\n        num += 1\n        if is_not_powers_of_two(num):\n            count += 1\n        if count == n:\n            return num", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        return x & x - 1 != 0\n    count = 0\n    num = 2\n    while True:\n        num += 1\n        if is_polite_number(num):\n            count += 1\n            if count == n:\n                return num"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even number and the first odd number in a given list.\n    If either an even or odd number is not found in the list, the function should return 0.\n    \n    Examples:\n    >>> mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8])\n    4\n    >>> mul_even_odd([2, 4, 6, 8])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    else:\n        return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    else:\n        return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    else:\n        return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    else:\n        return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    else:\n        return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    else:\n        return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/785", "requirement": "def tuple_str_int(test_str: str) -> tuple:\n\"\"\"\nWrite a function to convert tuple string to integer tuple.\nassert tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)\n\"\"\"", "generated_programs": ["def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num) for num in test_str.replace('(', '').replace(')', '').split(', ')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num) for num in test_str.replace('(', '').replace(')', '').split(', ')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num) for num in test_str.replace('(', '').replace(')', '').split(', ')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num.strip()) for num in test_str[1:-1].split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num) for num in test_str.replace('(', '').replace(')', '').split(', ')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num) for num in test_str.replace('(', '').replace(')', '').split(', ')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num.strip()) for num in test_str[1:-1].split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple(map(int, test_str.replace('(', '').replace(')', '').split(', ')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num.strip()) for num in test_str.replace('(', '').replace(')', '').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(num) for num in test_str.replace('(', '').replace(')', '').split(', ')))"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.8, "original_passk": 0.8}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n\"\"\"\nWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\nassert text_starta_endb(\"aabbbb\")\n\"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/16", "requirement": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if the input string contains any occurrence of one or more lowercase letters followed by an underscore and then one or more lowercase letters, and False otherwise.\n    assert text_lowercase_underscore(\"aab_cbbbc\")==(True)\n    \"\"\"", "generated_programs": ["import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.search('[a-z]+_[a-z]+', text))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/63", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute difference between the two elements within each tuple in the given list.\n    If the list is empty, the function should return 0.\n\n    Example:\n    >>> max_difference([(3, 5), (1, 7), (10, 3), (1, 2)])\n    7\n    \"\"\"", "generated_programs": ["from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))", "from typing import List\nfrom typing import Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    return max((abs(a - b) for a, b in test_list))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/72", "requirement": "def dif_Square(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given number can be represented as the difference of two squares or not. \n    The function should handle both positive and negative integers. For negative inputs, the function should return `False` \n    since the difference of two squares cannot be negative. For positive integers, the function should return `True` if \n    the number can be expressed as `j^2 - i^2` where `j` and `i` are non-negative integers. The function should use the \n    mathematical property that a number `n` can be represented as the difference of two squares if and only if `n % 4 != 2`.\n\n    Examples:\n    assert dif_Square(5) == True\n    assert dif_Square(-3) == False\n    assert dif_Square(8) == True\n    assert dif_Square(10) == False\n    \"\"\"", "generated_programs": ["def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    return n % 4 != 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n    \"\"\"\n    Determine whether a given integer is divisible by 11 using the modulo operation.\n    This function handles both positive and negative integers correctly.\n    \n    Args:\n        n (int): The integer to check for divisibility by 11.\n    \n    Returns:\n        bool: True if the integer is divisible by 11, False otherwise.\n    \n    Examples:\n        >>> is_Diff(12345)\n        False\n        >>> is_Diff(-121)\n        True\n    \"\"\"", "generated_programs": ["def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/92", "requirement": "def is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not. \n    An undulating number is defined as a number where the digits strictly alternate between two distinct values. \n    For example, in the number `1212121`, the digits alternate between `1` and `2`.\n    The function should return `True` if the number follows this strict alternating pattern, and `False` otherwise.\n    \n    assert is_undulating(1212121) == True\n    \"\"\"", "generated_programs": ["def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    return all((s[i] == s[0] if i % 2 == 0 else s[i] == s[1] for i in range(len(s))))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    return all((s[i] == s[0] if i % 2 == 0 else s[i] == s[1] for i in range(len(s))))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    return all((s[i] == s[0] if i % 2 == 0 else s[i] == s[1] for i in range(len(s))))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    return all((s[i] == s[0] if i % 2 == 0 else s[i] == s[1] for i in range(len(s))))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    return all((s[i] == s[0] if i % 2 == 0 else s[i] == s[1] for i in range(len(s))))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    return all((s[i] == s[0] if i % 2 == 0 else s[i] == s[1] for i in range(len(s))))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    return all((s[i] == s[0] if i % 2 == 0 else s[i] == s[1] for i in range(len(s))))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    return all((s[i] == s[0] if i % 2 == 0 else s[i] == s[1] for i in range(len(s))))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    return all((s[i] == s[0] if i % 2 == 0 else s[i] == s[1] for i in range(len(s))))", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or len(set(s)) != 2:\n        return False\n    return all((s[i] == s[0] if i % 2 == 0 else s[i] == s[1] for i in range(len(s))))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given positive integer.\n    The function should raise a ValueError if the input is not a positive integer.\n\n    Parameters:\n    n (int): A positive integer for which to find the number of positive divisors.\n\n    Returns:\n    int: The number of positive divisors of the given integer.\n\n    Raises:\n    ValueError: If the input `n` is not a positive integer.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer.\n    \"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/99", "requirement": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Write a function to convert the given decimal number to its binary equivalent, represented as a string.\n    The binary string should start with the first non-zero digit, and if the input is 0, the function should return '0'.\n    assert decimal_to_binary(8) == '1000'\n    \"\"\"", "generated_programs": ["def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary", "def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/103", "requirement": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m), which represents the number of permutations of the set {1, 2, ..., n} \n    with exactly m ascents. The function should handle the following constraints:\n    \n    - `n` must be a non-negative integer.\n    - `m` must be a non-negative integer such that `0 <= m < n`.\n    - If `n` is 0, the function should return 0.\n    - If `m` is negative or `m >= n`, the function should return 0.\n    \n    The Eulerian number can be computed using the following formula:\n    a(n, m) = sum_{k=0}^{m+1} (-1)^k * C(n + 1, k) * (m + 1 - k)^n,\n    where C(n, k) is the binomial coefficient.\n    \n    Examples:\n    >>> eulerian_num(3, 1)\n    4\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    result = 0\n    for k in range(m + 1):\n        result += (-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n\n    return result", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0:\n        return 0\n    if m < 0 or m >= n:\n        return 0\n    result = 0\n    for k in range(m + 1):\n        result += (-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n\n    return result", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    result = 0\n    for k in range(m + 2):\n        result += (-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n\n    return result", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0:\n        return 0\n    if m < 0 or m >= n:\n        return 0\n    result = 0\n    for k in range(m + 1):\n        result += (-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n\n    return result", "from math import comb\n\ndef eulerian_num(n: int, m: int) -> int:\n    if n == 0 or m < 0 or m >= n:\n        return 0\n    return sum(((-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n for k in range(m + 2)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements in all inner lists of the given nested list. \n    The function should return the intersection of all inner lists. \n    If the nested list is empty or contains any empty inner list, the function should raise a TypeError.\n\n    Examples:\n    >>> assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    >>> common_in_nested_lists([[]])\n    TypeError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/120", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute value of the product of the two numbers in each tuple within a given list.\n    The function should calculate the product of the two numbers in each tuple and then take the absolute value of that product.\n    Finally, it should return the maximum of these absolute products.\n    \n    Example:\n    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    \"\"\"", "generated_programs": ["from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List\nfrom typing import Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(x * y) for x, y in list1))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n\"\"\"\nWrite a function to sum all amicable numbers from 1 to a specified number.\n\n\nassert amicable_numbers_sum(999)==504\n\"\"\"", "generated_programs": ["def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((d for d in range(1, n) if n % d == 0))\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num in visited:\n            continue\n        partner = sum_of_divisors(num)\n        if partner != num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n            visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    checked = set()\n    for num in range(2, limit):\n        if num not in checked:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                checked.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    checked = set()\n    for num in range(2, limit + 1):\n        if num not in checked:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                checked.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    visited = set()\n    for num in range(2, limit + 1):\n        if num not in visited:\n            partner = sum_of_divisors(num)\n            if partner != num and sum_of_divisors(partner) == num:\n                amicable_sum += num + partner\n                visited.add(partner)\n    return amicable_sum"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Write a function to get the angle (in radians) of the difference between two complex numbers `b` and `a`.\n    The angle is calculated as the phase of the complex number resulting from `b - a`.\n    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/126", "requirement": "def sum_of_common_divisors(a: int, b: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of all unique positive common divisors of two given positive integers.\n    The function should handle only positive integers and return the sum of the unique positive divisors that divide both numbers.\n    The function should not consider negative numbers or zero as valid inputs.\n    assert sum_of_common_divisors(10, 15) == 6\n    \"\"\"", "generated_programs": ["def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def sum_of_divisors(n):\n        total = 0\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    gcd_value = gcd(a, b)\n    return sum_of_divisors(gcd_value)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def sum_of_divisors(n):\n        total = 0\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    common_gcd = gcd(a, b)\n    return sum_of_divisors(common_gcd)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n    gcd_value = gcd(a, b)\n    sum_divisors = 0\n    for i in range(1, int(gcd_value ** 0.5) + 1):\n        if gcd_value % i == 0:\n            sum_divisors += i\n            if i != gcd_value // i:\n                sum_divisors += gcd_value // i\n    return sum_divisors", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def sum_of_divisors(n):\n        total = 0\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    common_divisor_sum = sum_of_divisors(gcd(a, b))\n    return common_divisor_sum", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def divisors(n):\n        result = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                result.add(i)\n                result.add(n // i)\n        return result\n    gcd_value = gcd(a, b)\n    common_divisors = divisors(gcd_value)\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def divisors(n):\n        result = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                result.add(i)\n                result.add(n // i)\n        return result\n    gcd_value = gcd(a, b)\n    common_divisors = divisors(gcd_value)\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def divisors(n):\n        result = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                result.add(i)\n                result.add(n // i)\n        return result\n    gcd_value = gcd(a, b)\n    common_divisors = divisors(gcd_value)\n    return sum(common_divisors)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def divisors(n):\n        result = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                result.add(i)\n                result.add(n // i)\n        return result\n    common_gcd = gcd(a, b)\n    common_divs = divisors(common_gcd)\n    return sum(common_divs)", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def sum_of_divisors(n):\n        total = 0\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    common_divisor_sum = sum_of_divisors(gcd(a, b))\n    return common_divisor_sum", "def sum_of_common_divisors(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def sum_divisors(n):\n        total = 0\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    common_gcd = gcd(a, b)\n    return sum_divisors(common_gcd)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether the given square matrix is a magic square.\n    A magic square is a square matrix where the sums of the numbers in each row, each column, and both main diagonals are all equal to the magic sum.\n    The magic sum for an n x n matrix is calculated as n * (n^2 + 1) / 2.\n    The function should return True if the matrix is a magic square, otherwise False.\n    The function assumes that the input is a square matrix (i.e., all rows have the same length as the number of rows).\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/130", "requirement": "from typing import List\n\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with the maximum frequency in a given non-empty list of integers.\n    If the list is empty, the function will raise an IndexError.\n    \n    Args:\n        nums (List[int]): A non-empty list of integers.\n    \n    Returns:\n        int: The item with the maximum frequency in the list.\n    \n    Raises:\n        IndexError: If the input list is empty.\n    \n    Examples:\n        >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n        2\n        >>> max_occurrences([])\n        IndexError\n    \"\"\"", "generated_programs": ["from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    counter = Counter(nums)\n    max_count = max(counter.values())\n    return max((num for num, count in counter.items() if count == max_count))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))", "from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise IndexError\n    count = Counter(nums)\n    max_freq = max(count.values())\n    return max((num for num, freq in count.items() if freq == max_freq))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/137", "requirement": "from typing import List\n\n\ndef zero_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of the number of zeroes to the number of non-zero elements in an array of integers.\n    The ratio is calculated as the number of zeroes divided by the number of non-zero elements.\n    If there are no non-zero elements, the function should return 0.0.\n    assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return 0.0\n    return zero_count / non_zero_count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given integer can be represented as the sum of at least two distinct non-zero powers of 2. \n    Non-zero powers of 2 are defined as 2^k where k is a positive integer (i.e., 2^1, 2^2, 2^3, ...). \n    The function should handle both positive and negative integers as inputs.\n    assert is_Sum_Of_Powers_Of_Two(10) == True\n    \"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n & n - 1:\n        n &= n - 1\n    return n > 0 and n.bit_length() < 32", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    count = 0\n    while n > 0:\n        n &= n - 1\n        count += 1\n    return count >= 2", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n & 1:\n            n -= 1\n            if n & 1:\n                return True\n            else:\n                return False\n        n >>= 1\n    return False", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n & n - 1:\n        n &= n - 1\n    return n > 0 and (n - 1).bit_count() > 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    count = 0\n    while n > 0:\n        n &= n - 1\n        count += 1\n    return count >= 2", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count >= 2", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count >= 2", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    count = 0\n    while n > 0:\n        n &= n - 1\n        count += 1\n    return count >= 2", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n & 1 == 1:\n            n -= 1\n            break\n        n >>= 1\n    while n > 0:\n        if n & 1 == 1:\n            return True\n        n >>= 1\n    return False", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n & 1 == 1:\n            n -= 1\n            if n & n - 1 == 0:\n                return False\n            else:\n                return True\n        n >>= 1\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/145", "requirement": "from typing import List\n\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the maximum absolute difference between the maximum and minimum values in a given array.\n    If the array is empty, the function should return 0.\n\n    Examples:\n    >>> max_Abs_Diff((2,1,5,3))\n    4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return abs(max(arr) - min(arr))", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return abs(max(arr) - min(arr))", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return abs(max(arr) - min(arr))", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return abs(max(arr) - min(arr))", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    return abs(max(arr) - min(arr))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"\n    Write a function that returns non-negative integers x and y that satisfy the equation ax + by = n as a tuple (x, y), \n    where x is iterated from 0 upwards. If multiple solutions exist, return the first solution encountered. \n    Return None if no non-negative integer solution exists.\n    \n    The function assumes that a and b are positive integers. If a or b is zero, the behavior is undefined.\n    Additionally, the function ensures that both x and y are non-negative, even if b or n is negative.\n    \n    assert find_solution(2, 3, 7) == (2, 1)\n    assert find_solution(2, -3, 7) == None\n    assert find_solution(0, 1, 1) == (0, 1)\n    \"\"\"", "generated_programs": ["from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y.is_integer() and y >= 0:\n            return (x, int(y))\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y.is_integer() and y >= 0:\n            return (x, int(y))\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y.is_integer() and y >= 0:\n            return (x, int(y))\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y.is_integer() and y >= 0:\n            return (x, int(y))\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n    \"\"\"\n    Write a Python function to set all bits of a given number to 1.\n    assert even_bit_set_number(10) == 10\n    \"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, \n    such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    Specifically, for each element in the sequence (starting from the second element), it must satisfy the condition: \n    element >= 2 * previous_element and element <= m.\n    \n    The first element in the sequence can be any positive integer from 1 to m. \n    If n is 1, the function should return m, as there are m possible sequences of length 1.\n    If n is 0, the function should raise an IndexError, as sequences of length 0 are not valid.\n    \n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(max(2 * i, start), length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(max(i * 2, start), length - 1)\n        return total\n    return sum((count_sequences(i, n) for i in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(max(2 * i, start), length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(i * 2, length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        next_start = max(start * 2, 1)\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for next_start in range(start * 2, m + 1):\n            total += count_sequences(next_start, length - 1)\n        return total\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(first_element, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        next_start = max(start * 2, 1)\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(max(i * 2, start), length - 1)\n        return total\n    return count_sequences(1, n)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        for i in range(start, m + 1):\n            total += count_sequences(max(i * 2, start), length - 1)\n        return total\n    return sum((count_sequences(i, n) for i in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        raise IndexError('Sequences of length 0 are not valid.')\n    if n == 1:\n        return m\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return m - start + 1\n        total = 0\n        next_start = max(start * 2, 1)\n        while next_start <= m:\n            total += count_sequences(next_start, length - 1)\n            next_start += 1\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/253", "requirement": "from typing import List, Any\n\n\ndef count_integer(lst: List[Any]) -> int:\n    \"\"\"\n    Write a Python function that returns the number of elements in a given list that are instances of the `int` type, excluding `bool` values.\n    assert count_integer([1,2,'abc',1.2]) == 2\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for element in lst if isinstance(element, int) and (not isinstance(element, bool))))", "from typing import List, Any\n\ndef count_integer(lst: List[Any]) -> int:\n    return sum((1 for item in lst if isinstance(item, int) and (not isinstance(item, bool))))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Newman–Shanks–Williams prime number.\n    \n    The Newman–Shanks–Williams prime sequence is defined by the following recurrence relation:\n    - Initial conditions: a = 1, b = 1\n    - Recurrence relation: c = 2 * b + a\n    - The sequence starts with 1, 1, 3, 7, 17, 41, ...\n    - For n = 1, the function should return 3.\n    \n    assert newman_prime(3) == 7\n    \"\"\"", "generated_programs": ["def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if n == 1:\n        return 3\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/265", "requirement": "from typing import List, Any\n\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Write a function that takes in a list `S` and an integer `step`, and distributes the elements of `S` into `step` sublists. \n    Each sublist should contain elements spaced `step` apart, starting from consecutive initial indices. \n    Specifically, the first sublist contains elements at indices 0, step, 2*step, etc., \n    the second sublist contains elements at indices 1, step+1, 2*step+1, etc., and so on until the `step`-th sublist.\n    The function returns a list of these sublists.\n    \n    Example:\n    assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for j in range((len(S) - i + step - 1) // step)] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for j in range((len(S) + i) // step)] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for j in range((len(S) + i) // step)] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for i in range(step) if i + j * step < len(S)] for j in range((len(S) + step - 1) // step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    result = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        result[i % step].append(item)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [[S[i + j * step] for j in range((len(S) - i + step - 1) // step)] for i in range(step)]", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    return [S[i::step] for i in range(step)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 1.0}}
{"task_id": "Mbpp/286", "requirement": "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the largest sum of a contiguous subarray in the modified array formed by concatenating the given array `a` `k` times.\n    \n    The function should handle the following cases:\n    - If `k` is 1, the maximum subarray sum is calculated within the original array `a`.\n    - If the total sum of the array `a` is non-positive, the maximum subarray sum is calculated within one or two concatenated instances of `a`.\n    - If the total sum of the array `a` is positive, the maximum subarray sum is calculated as the total sum multiplied by `(k - 2)` plus the maximum subarray sum of the concatenated array `a + a`.\n    \n    Examples:\n    >>> max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3)\n    30\n    >>> max_sub_array_sum_repeated([5, -2, 3, 1], 4, 4)\n    28\n    >>> max_sub_array_sum_repeated([1, 2, 3], 3, 1)\n    6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * min(k, 2))\n    else:\n        max_kadane = kadane(a * 2)\n        return max_kadane + total_sum * (k - 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    if k == 1:\n        return kadane(a)\n    total_sum = sum(a)\n    if total_sum <= 0:\n        return kadane(a * min(k, 2))\n    max_kadane = kadane(a + a)\n    return total_sum * (k - 2) + max_kadane", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    if k == 1:\n        return kadane(a)\n    total_sum = sum(a)\n    if total_sum <= 0:\n        return max(kadane(a), kadane(a + a))\n    max_kadane = kadane(a + a)\n    return max_kadane + total_sum * (k - 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * min(2, k))\n    else:\n        return total_sum * (k - 2) + kadane(a + a)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * min(k, 2))\n    else:\n        max_kadane = kadane(a + a)\n        return max_kadane + total_sum * (k - 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    if k == 1:\n        return kadane(a)\n    total_sum = sum(a)\n    if total_sum <= 0:\n        return kadane(a * min(2, k))\n    else:\n        max_kadane = kadane(a * 2)\n        return max_kadane + (k - 2) * total_sum", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * min(k, 2))\n    else:\n        return total_sum * (k - 2) + kadane(a + a)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    if k == 1:\n        return kadane(a)\n    total_sum = sum(a)\n    if total_sum <= 0:\n        return kadane(a * min(k, 2))\n    else:\n        return total_sum * (k - 2) + kadane(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    if k == 1:\n        return kadane(a)\n    total_sum = sum(a)\n    max_kadane = kadane(a * 2)\n    if total_sum <= 0:\n        return max_kadane\n    else:\n        return total_sum * (k - 2) + max_kadane", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * min(k, 2))\n    else:\n        return total_sum * (k - 2) + kadane(a + a)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n    \"\"\"\n    Calculate the depth of a dictionary recursively. The depth is defined as the maximum number of nested dictionaries within the input dictionary. \n    \n    - An empty dictionary or a non-dictionary input has a depth of 0.\n    - Non-dictionary values within the dictionary do not contribute to the depth.\n    - The depth is calculated by recursively traversing all dictionary values and finding the maximum depth among them, then adding 1 for the current level.\n    \n    Examples:\n    >>> dict_depth({'a':1, 'b': {'c': {'d': {}}}})\n    4\n    >>> dict_depth({})\n    0\n    >>> dict_depth({'a': 1, 'b': [1, 2, 3]})\n    1\n    >>> dict_depth({'a': {'b': {'c': 1}}, 'd': 2})\n    3\n    \"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "Mbpp/306", "requirement": "```python\nfrom typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum of an increasing subsequence from the start of the array up to the given `index` (inclusive), \n    and extend this subsequence to include the `kth` element (where `k > index`), ensuring the subsequence remains valid in increasing order.\n\n    The function computes the maximum sum of increasing subsequences for the prefix (elements from index 0 to `index`) using dynamic programming. \n    Then, it checks which elements in the prefix can form a valid increasing subsequence with the `kth` element (`a[k]`), \n    and selects the subsequence with the maximum sum. The value of `a[k]` is added to this sum to include the `kth` element.\n\n    If no valid increasing subsequence exists in the prefix that can be extended to include `a[k]`, the result will be the value of `a[k]` alone.\n\n    Constraints:\n    - `k > index` must hold true.\n    - The input array `a` contains integers, and `n` is the length of the array.\n    - The function assumes valid input, meaning:\n        - `a` must be a non-empty list.\n        - `index` and `k` must be within bounds (0 <= index < n and 0 <= k < n).\n        - `k > index` must hold true.\n    - If invalid input is provided (e.g., empty array, out-of-bounds indices, or `k <= index`), the function will raise a `ValueError`.\n\n    Methodology:\n    - Dynamic programming is applied only to the prefix `a[:index + 1]` to compute the maximum sum of increasing subsequences.\n    - The function does not extend the dynamic programming logic beyond the prefix.\n\n    Examples:\n    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    assert max_sum_increasing_subseq([5, 4, 3, 2, 1], 5, 2, 4) == 1\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or index >= n or (k < 0) or (k >= n) or (k <= index):\n        raise ValueError('Invalid input')\n    dp = a.copy()\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or index >= n or (k < 0) or (k >= n) or (k <= index):\n        raise ValueError('Invalid input')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or index >= n or (k < 0) or (k >= n) or (k <= index):\n        raise ValueError('Invalid input')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or k >= n or (k <= index):\n        raise ValueError('Invalid input')\n    dp = a[:]\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or index >= n or (k < 0) or (k >= n) or (k <= index):\n        raise ValueError('Invalid input')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or k < 0 or (index >= n) or (k >= n) or (k <= index):\n        raise ValueError('Invalid input')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or k < 0 or (index >= n) or (k >= n) or (k <= index):\n        raise ValueError('Invalid input')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or index >= n or (k < 0) or (k >= n) or (k <= index):\n        raise ValueError('Invalid input')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or index >= n or (k < 0) or (k >= n) or (k <= index):\n        raise ValueError('Invalid input')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index < 0 or k < 0 or (index >= n) or (k >= n) or (k <= index):\n        raise ValueError('Invalid input')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n    \"\"\"\n    Write a function to convert a given string to a tuple of characters, excluding spaces.\n    assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n    \"\"\"", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the highest-order unset bit in the binary representation of the integer `n`.\n    The function should find the leftmost bit that is currently 0 (starting from the highest-order bit) and set it to 1.\n    Leading zeros are not considered in the binary representation of `n`. If all bits are set, the function should return `n` unchanged.\n    For example, for the input `10` (binary `1010`), the leftmost unset bit is the third bit from the left, and setting it results in `14` (binary `1110`).\n    assert set_left_most_unset_bit(10) == 14\n    \"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask & n:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        mask <<= 1\n    return n | mask >> 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        mask <<= 1\n    return n | mask >> 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        mask <<= 1\n    return n | mask >> 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        mask <<= 1\n    return n | mask >> 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/391", "requirement": "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    \"\"\"\n    Convert three lists into a list of nested dictionaries where each dictionary maps an element from `list1` to a dictionary that maps an element from `list2` to an element from `list3`. \n    The function assumes that all three lists are of the same length. If the lists are of unequal lengths, an `IndexError` will be raised.\n    \n    Args:\n        list1 (List[Any]): A list of keys for the outer dictionary.\n        list2 (List[Any]): A list of keys for the inner dictionary.\n        list3 (List[Any]): A list of values for the inner dictionary.\n    \n    Returns:\n        List[Dict[Any, Dict[Any, Any]]]: A list of dictionaries where each dictionary contains a single key-value pair. The key is an element from `list1`, and the value is another dictionary with a key from `list2` and a value from `list3`.\n    \n    Examples:\n        >>> convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"], [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"], [85, 98, 89, 92])\n        [{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]\n        \n        >>> convert_list_dictionary(['B001', 'B002'], ['Alice Smith'], [90, 95])\n        IndexError\n    \"\"\"\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "generated_programs": ["from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]", "from typing import List, Dict, Any\n\ndef convert_list_dictionary(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Dict[Any, Dict[Any, Any]]]:\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise IndexError\n    return [{list1[i]: {list2[i]: list3[i]}} for i in range(len(list1))]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Calculate the directrix of a parabola given its coefficients in the form y = ax² + bx + c.\n    The directrix is calculated using the formula: y = - (b² - 4ac + 1) / (4a) - 199.\n    \n    Args:\n        a (int): Coefficient of x² in the parabola equation.\n        b (int): Coefficient of x in the parabola equation.\n        c (int): Constant term in the parabola equation.\n    \n    Returns:\n        int: The y-coordinate of the directrix of the parabola.\n    \n    Examples:\n        >>> parabola_directrix(5, 3, 2)\n        -198\n    \"\"\"\n    assert parabola_directrix(5, 3, 2) == -198", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a) - 199"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.5}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n+1 Perrin numbers, including the nth Perrin number.\n    The Perrin sequence starts with P(0) = 3, P(1) = 0, and P(2) = 2.\n    For n < 0, the function should raise an IndexError.\n    For n = 0, the function should return 0.\n    For n = 1, the function should return 2.\n    For n = 2, the function should return 3.\n    For n > 2, the function should return the sum of the first n+1 Perrin numbers.\n\n    Examples:\n    >>> cal_sum(2)\n    3\n    >>> cal_sum(-1)\n    IndexError\n    >>> cal_sum(0)\n    0\n    >>> cal_sum(9)\n    49\n    \"\"\"", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of even positive factors of a given positive integer `n`. \n    The function should consider only positive factors and should return 0 for negative inputs or if no even factors are found.\n    The function should check all numbers from 1 to `n` to determine the factors.\n\n    Examples:\n    >>> sumofFactors(18)\n    26\n    >>> sumofFactors(-12)\n    0\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors", "def sumofFactors(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing at least one 'z' anywhere in the word.\n    assert text_match_wordz(\"pythonz.\")==True\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "def text_match_wordz(text: str) -> bool:\n    import re\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    \"\"\"\n    Write a function to find all possible combinations of the elements of a given list, including the empty list.\n    The function should return a list of lists, where each inner list represents a combination of elements from the input list.\n    The order of combinations should be based on the order of elements in the input list, and combinations should include all possible lengths from 0 to the length of the input list.\n    \n    Example:\n    assert combinations_list(['orange', 'red', 'green', 'blue']) == [\n        [], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'],\n        ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'],\n        ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']\n    ]\n    \"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend(combinations(lst, r))\n    return [list(comb) for comb in result]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/465", "requirement": "def drop_empty(dict1: dict) -> dict:\n    \"\"\"\n    Write a function to drop key-value pairs from a given dictionary where the value is None.\n\n    Args:\n        dict1 (dict): The input dictionary from which to drop key-value pairs with None values.\n\n    Returns:\n        dict: A new dictionary with all key-value pairs where the value is not None.\n\n    Examples:\n        >>> drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None})\n        {'c1': 'Red', 'c2': 'Green'}\n    \"\"\"", "generated_programs": ["def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n\"\"\"\nWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nassert max_product([3, 100, 4, 5, 150, 6]) == 3000\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    mprod = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and mprod[i] < mprod[j] * arr[i]:\n                mprod[i] = mprod[j] * arr[i]\n    return max(mprod)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    mpis = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and mpis[i] < mpis[j] * arr[i]:\n                mpis[i] = mpis[j] * arr[i]\n    return max(mpis)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    mpis = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and mpis[i] < mpis[j] * arr[i]:\n                mpis[i] = mpis[j] * arr[i]\n    return max(mpis)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and dp[i] < dp[j] * arr[i]:\n                dp[i] = dp[j] * arr[i]\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and dp[i] < dp[j] * arr[i]:\n                dp[i] = dp[j] * arr[i]\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and dp[i] < dp[j] * arr[i]:\n                dp[i] = dp[j] * arr[i]\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and dp[i] < dp[j] * arr[i]:\n                dp[i] = dp[j] * arr[i]\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    mprod = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and mprod[i] < mprod[j] * arr[i]:\n                mprod[i] = mprod[j] * arr[i]\n    return max(mprod)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    mprod = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and mprod[i] < mprod[j] * arr[i]:\n                mprod[i] = mprod[j] * arr[i]\n    return max(mprod)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and dp[i] < dp[j] * arr[i]:\n                dp[i] = dp[j] * arr[i]\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/471", "requirement": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function to compute the product of all elements in the array and then return the result modulo n.\n    The function should handle edge cases such as an empty array by returning 1 % n.\n    \n    Examples:\n    >>> find_remainder([100, 10, 5, 25, 35, 14], 11)\n    9\n    >>> find_remainder([], 10)\n    1\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n if arr else 1 % n", "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    product = 1\n    for num in arr:\n        product = product * num % n\n    return product % n if arr else 1 % n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/479", "requirement": "def first_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the first digit of a given integer, including the sign if the number is negative.\n    The function should process the number as is, without converting it to its absolute value.\n    The first digit should be returned as an integer.\n    \n    Examples:\n    >>> first_Digit(123)\n    1\n    >>> first_Digit(-456)\n    -4\n    >>> first_Digit(0)\n    0\n    \"\"\"", "generated_programs": ["def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    while abs(n) >= 10:\n        n //= 10\n    return n", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n < 0:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n\n    else:\n        while n >= 10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n < 0:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n\n    else:\n        while n >= 10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n < 0:\n        while n <= -10:\n            n //= 10\n        return n\n    else:\n        while n >= 10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n < 0:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n\n    else:\n        while n >= 10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n < 0:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n\n    else:\n        while n >= 10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n < 0:\n        while n <= -10:\n            n //= 10\n        return n\n    else:\n        while n >= 10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n < 0:\n        while n <= -10:\n            n //= 10\n        return n\n    else:\n        while n >= 10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n < 0:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n\n    else:\n        while n >= 10:\n            n //= 10\n        return n", "def first_Digit(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n < 0:\n        n = -n\n        while n >= 10:\n            n //= 10\n        return -n\n    else:\n        while n >= 10:\n            n //= 10\n        return n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/558", "requirement": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of the absolute differences between corresponding digits of two integers.\n    If the integers have different lengths, the shorter integer is padded with leading zeros to match the length of the longer integer.\n    The function then calculates the absolute difference between each pair of corresponding digits and returns the sum of these differences.\n    assert digit_distance_nums(1,2) == 1\n    \"\"\"", "generated_programs": ["def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))", "def digit_distance_nums(n1: int, n2: int) -> int:\n    str_n1, str_n2 = (str(n1).zfill(max(len(str(n1)), len(str(n2)))), str(n2).zfill(max(len(str(n1)), len(str(n2)))))\n    return sum((abs(int(d1) - int(d2)) for d1, d2 in zip(str_n1, str_n2)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/559", "requirement": "from typing import List\n\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum achievable by any contiguous sublist in the given list. \n    If the list is empty, the function should return negative infinity (`-inf`).\n\n    Args:\n        a (List[int]): The list of integers.\n        size (int): The size of the list.\n\n    Returns:\n        int: The maximum sum achievable by any contiguous sublist, or `-inf` if the list is empty.\n\n    Examples:\n        >>> max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8)\n        7\n        >>> max_sub_array_sum([], 0)\n        -inf\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_ending_here = max_so_far = a[0]\n    for x in a[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_ending_here = max_so_far = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_ending_here = max_so_far = a[0]\n    for x in a[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\nimport math\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return -math.inf\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/563", "requirement": "def extract_values(text: str) -> List[str]:\n    \"\"\"Extract all substrings that are enclosed within double quotation marks from the input string.\n    Each substring should be captured without the surrounding quotes.\n    assert extract_values('\"Python\", \"PHP\", \"Java\"')==['Python', 'PHP', 'Java']\n    \"\"\"", "generated_programs": ["from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)", "from typing import List\nimport re\n\ndef extract_values(text: str) -> List[str]:\n    return re.findall('\"(.*?)\"', text)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "def count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Counts the number of unordered pairs (i, j) where i < j and arr[i] != arr[j].\n    The function iterates through all possible pairs in the list and increments the count if the elements in the pair are not equal.\n    assert count_Pairs([1,2,1],3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/579", "requirement": "from typing import Tuple, Any\n\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    \"\"\"\n    Write a function to find the unique dissimilar elements in the given two tuples. \n    The function should return a sorted tuple containing elements that are present in \n    either of the tuples but not in both. The output should be sorted in ascending order.\n\n    assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))", "from typing import Tuple, Any\n\ndef find_dissimilar(test_tup1: Tuple[Any, ...], test_tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(sorted(dissimilar_elements))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/580", "requirement": "```python\ndef extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Write a function to recursively remove all uneven integers from a nested mixed tuple while preserving the original structure, including empty tuples.\n\n    Requirements:\n    1. The function should recursively traverse all levels of the nested tuple.\n    2. Uneven integers (odd numbers) should be removed from all levels of the tuple.\n    3. Non-integer elements (e.g., strings, floats) should be ignored and excluded from the output.\n    4. The structure of the nested tuple must be preserved, including retaining empty tuples (`()`).\n    5. The output should only contain even integers and tuple structures, maintaining all original nesting levels.\n\n    Example:\n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"\n```", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            result = tuple((helper(item) for item in element if helper(item) is not None))\n            return result if result or element == () else None\n        return None\n    return helper(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            result = tuple((helper(item) for item in element if helper(item) is not None))\n            return result if result else ()\n        return None\n    return helper(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            result = tuple((helper(item) for item in element))\n            return result if any((isinstance(x, tuple) or x for x in result)) else ()\n        return False\n    return helper(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            result = tuple((helper(item) for item in element))\n            return result if any(result) else ()\n        return False\n    return helper(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(item):\n        if isinstance(item, int):\n            return item % 2 == 0\n        elif isinstance(item, tuple):\n            result = tuple((helper(sub_item) for sub_item in item))\n            return tuple(filter(lambda x: x is not None, result))\n        else:\n            return None\n    return helper(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(item):\n        if isinstance(item, int):\n            return item % 2 == 0\n        elif isinstance(item, tuple):\n            result = tuple((helper(sub_item) for sub_item in item))\n            return tuple((x for x in result if x is not None))\n        else:\n            return None\n    return helper(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            result = tuple((helper(item) for item in element))\n            return tuple(filter(lambda x: x is not None, result))\n        else:\n            return None\n    return helper(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            result = tuple((helper(item) for item in element))\n            return result if any((isinstance(item, tuple) or item for item in result)) else ()\n        return False\n    return helper(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int):\n            return element % 2 == 0\n        elif isinstance(element, tuple):\n            return tuple((helper(item) for item in element if helper(item) is not None or item == ()))\n        return None\n    return helper(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(element):\n        if isinstance(element, int) and element % 2 == 0:\n            return element\n        elif isinstance(element, tuple):\n            result = tuple((helper(item) for item in element))\n            return tuple((x for x in result if x is not None))\n        return None\n    return helper(test_tuple)"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.09999999999999998, "original_passk": 0.9}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n    \"\"\"\n    Write a Python function to find the surface area of a square pyramid with a given base edge and slant height.\n    The surface area is calculated as the sum of the base area and the lateral area, where the lateral area is computed using the slant height.\n    assert surface_Area(3,4) == 33\n    \"\"\"", "generated_programs": ["def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/583", "requirement": "def catalan_number(num: int) -> int:\n    \"\"\"\n    Calculate the nth Catalan number for a given non-negative integer n.\n    \n    The Catalan number is computed using the formula: C(n) = (2n choose n) / (n + 1).\n    \n    Args:\n        num (int): A non-negative integer representing the position in the Catalan sequence.\n        \n    Returns:\n        int: The nth Catalan number.\n        \n    Raises:\n        ValueError: If the input `num` is a negative integer.\n        \n    Examples:\n        >>> catalan_number(10)\n        16796\n        >>> catalan_number(-1)\n        ValueError\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)", "from math import comb\n\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        raise ValueError\n    return comb(2 * num, num) // (num + 1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Given rectangular coordinates (x, y), calculate the corresponding polar coordinates (magnitude, angle) and return them along with the original rectangular coordinates as a complex number.\n    \n    The function computes the magnitude as the distance from the origin using `math.hypot(x, y)` and the angle in radians using `math.atan2(y, x)`. The rectangular coordinates are represented as a complex number `complex(x, y)`.\n    \n    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = complex(x, y)\n    return ((magnitude, angle), rect_complex)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/592", "requirement": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given integer n.\n    Specifically, the function computes the sum of the product of comb(n, i) and comb(n, i + 1) for i ranging from 0 to n-1.\n    assert sum_Of_product(3) == 15\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the difference between the first even and first odd number in a given list.\n    \n    The function iterates through the list to find the first even and first odd numbers.\n    If both an even and an odd number are found, it returns the difference (even - odd).\n    If either an even or an odd number is not found, the function returns 0.\n    \n    Examples:\n    >>> diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8])\n    3\n    >>> diff_even_odd([2, 4, 6, 8, 10])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the k-th element in the combined sorted order of the given two sorted arrays.\n    The function assumes 1-based indexing for `k`, meaning the first element is considered as `k=1`.\n    If `k` is out of bounds (i.e., greater than the total number of elements in `arr1` and `arr2` combined),\n    the function should return -1. The function should handle cases where one or both of the arrays are empty.\n\n    Examples:\n    >>> find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5)\n    6\n    >>> find_kth([], [1, 2, 3], 2)\n    2\n    >>> find_kth([1, 2, 3], [], 4)\n    -1\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    combined = sorted(arr1 + arr2)\n    if k <= 0 or k > len(combined):\n        return -1\n    return combined[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    m, n = (len(arr1), len(arr2))\n    if k > m + n:\n        return -1\n    i, j = (0, 0)\n    while True:\n        if i == m:\n            return arr2[j + k - 1]\n        if j == n:\n            return arr1[i + k - 1]\n        if k == 1:\n            return min(arr1[i], arr2[j])\n        mid1 = min(k // 2, m - i)\n        mid2 = min(k // 2, n - j)\n        if arr1[i + mid1 - 1] < arr2[j + mid2 - 1]:\n            i += mid1\n            k -= mid1\n        else:\n            j += mid2\n            k -= mid2", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    len1, len2 = (len(arr1), len(arr2))\n    if k > len1 + len2:\n        return -1\n    i, j = (0, 0)\n    while True:\n        if i == len1:\n            return arr2[j + k - 1]\n        if j == len2:\n            return arr1[i + k - 1]\n        if k == 1:\n            return min(arr1[i], arr2[j])\n        mid1 = min(k // 2, len1 - i)\n        mid2 = min(k // 2, len2 - j)\n        if arr1[i + mid1 - 1] < arr2[j + mid2 - 1]:\n            i += mid1\n            k -= mid1\n        else:\n            j += mid2\n            k -= mid2", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    combined = sorted(arr1 + arr2)\n    if k > len(combined):\n        return -1\n    return combined[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    m, n = (len(arr1), len(arr2))\n    if k > m + n:\n        return -1\n    i, j = (0, 0)\n    while True:\n        if i == m:\n            return arr2[j + k - 1]\n        if j == n:\n            return arr1[i + k - 1]\n        if k == 1:\n            return min(arr1[i], arr2[j])\n        mid1 = min(k // 2, m - i)\n        mid2 = min(k // 2, n - j)\n        if arr1[i + mid1 - 1] < arr2[j + mid2 - 1]:\n            i += mid1\n            k -= mid1\n        else:\n            j += mid2\n            k -= mid2", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2):\n        return -1\n    i, j = (0, 0)\n    while True:\n        if i == len(arr1):\n            return arr2[j + k - 1]\n        if j == len(arr2):\n            return arr1[i + k - 1]\n        if k == 1:\n            return min(arr1[i], arr2[j])\n        mid = k // 2\n        new_i = min(i + mid - 1, len(arr1) - 1)\n        new_j = min(j + mid - 1, len(arr2) - 1)\n        if arr1[new_i] <= arr2[new_j]:\n            k -= new_i - i + 1\n            i = new_i + 1\n        else:\n            k -= new_j - j + 1\n            j = new_j + 1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k <= len(merged):\n        return merged[k - 1]\n    else:\n        return -1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    if k <= len(merged):\n        return merged[k - 1]\n    else:\n        return -1", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    m, n = (len(arr1), len(arr2))\n    if k > m + n:\n        return -1\n    i, j = (0, 0)\n    while True:\n        if i == m:\n            return arr2[j + k - 1]\n        if j == n:\n            return arr1[i + k - 1]\n        if k == 1:\n            return min(arr1[i], arr2[j])\n        mid1 = min(k // 2, m - i)\n        mid2 = min(k // 2, n - j)\n        if arr1[i + mid1 - 1] < arr2[j + mid2 - 1]:\n            i += mid1\n            k -= mid1\n        else:\n            j += mid2\n            k -= mid2", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    len1, len2 = (len(arr1), len(arr2))\n    if k > len1 + len2:\n        return -1\n    i, j = (0, 0)\n    while True:\n        if i == len1:\n            return arr2[j + k - 1]\n        if j == len2:\n            return arr1[i + k - 1]\n        if k == 1:\n            return min(arr1[i], arr2[j])\n        mid1 = min(k // 2, len1 - i)\n        mid2 = min(k // 2, len2 - j)\n        if arr1[i + mid1 - 1] < arr2[j + mid2 - 1]:\n            i += mid1\n            k -= mid1\n        else:\n            j += mid2\n            k -= mid2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "Mbpp/604", "requirement": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse the order of words in a given string, where words are separated by one or more spaces. \n    Leading, trailing, and multiple spaces between words should be normalized to a single space in the output.\n    assert reverse_words(\"python program\")==(\"program python\")\n    \"\"\"", "generated_programs": ["def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/620", "requirement": "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    \"\"\"\n    Write a function to find the size of the largest subset of a list of numbers such that for every pair of numbers in the subset, one number is divisible by the other.\n    Specifically, for any two numbers `x` and `y` in the subset, either `x % y == 0` or `y % x == 0`.\n    If the input list is empty, the function should return 0.\n    \n    Examples:\n    >>> largest_subset([1, 3, 6, 13, 17, 18])\n    4\n    >>> largest_subset([])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a.sort()\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n    \"\"\"\n    Write a python function to find the area of the largest right-angled triangle that can be inscribed in a semicircle with a given radius.\n    The largest right-angled triangle inscribed in a semicircle has its hypotenuse as the diameter of the semicircle.\n    The area is calculated using the formula: radius ** 2 * 2.\n    assert triangle_area(-1) == None\n    \"\"\"", "generated_programs": ["def triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return radius ** 2", "def triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return radius ** 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/630", "requirement": "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given 2D coordinate tuple.\n    The function assumes that the input tuple has exactly two elements, representing a 2D coordinate.\n    If the input tuple has more than two elements, the function raises a ValueError.\n    \n    Args:\n        test_tup (Tuple[int, ...]): A tuple representing a 2D coordinate. Must have exactly two elements.\n    \n    Returns:\n        List[List[int]]: A list of lists, where each inner list represents an adjacent coordinate in a 3x3 grid around the given coordinate.\n    \n    Raises:\n        ValueError: If the input tuple does not have exactly two elements.\n    \n    Examples:\n        >>> get_coordinates((3, 4))\n        [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n        >>> get_coordinates((1, 1, 1))\n        ValueError\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]", "from typing import List, Tuple\n\ndef get_coordinates(test_tup: Tuple[int, ...]) -> List[List[int]]:\n    if len(test_tup) != 2:\n        raise ValueError\n    x, y = test_tup\n    return [[i, j] for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/631", "requirement": "def replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace all whitespace characters with underscores in a given string.\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    \"\"\"", "generated_programs": ["def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '_')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the nearest integer given the wind velocity in km/h and a temperature in celsius.\n    assert wind_chill(120,35)==40\n    \"\"\"", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    if v < 4.8 or t > 10:\n        return round(t)\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wc)", "def wind_chill(v: float, t: float) -> int:\n    from math import pow\n    if v > 4.8 and -50 < t < 50:\n        wc = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n        return round(wc)\n    else:\n        return t", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -50 < t < 50:\n        wc = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n        return round(wc)\n    else:\n        return t", "def wind_chill(v: float, t: float) -> int:\n    from math import pow\n    if v > 4.8 and t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    from math import pow\n    if v > 4.8 and t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -40 < t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    from math import pow\n    if v > 4.8 and t < 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n        return round(wc)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    import math\n    if v > 4.8 and -40 < t < 10:\n        wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n        return round(wci)\n    else:\n        return round(t)", "def wind_chill(v: float, t: float) -> int:\n    from math import pow\n    if v > 4.8 and -50 < t < 50:\n        wc = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n        return round(wc)\n    else:\n        return None", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    if v > 4.8 and -45 <= t <= 10:\n        wc = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n        return round(wc)\n    else:\n        return t"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/722", "requirement": "def filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    Filters students whose height and weight are both greater than or equal to the specified minimum values.\n    \n    Args:\n        students: A dictionary where the key is the student's name and the value is a tuple of (height, weight).\n        h: The minimum height threshold.\n        w: The minimum weight threshold.\n    \n    Returns:\n        A dictionary containing only the students who meet or exceed both the height and weight thresholds.\n    \n    Example:\n        >>> filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70)\n        {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/735", "requirement": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Write a Python function to toggle all bits of the number except the most significant bit (MSB) and the least significant bit (LSB) in its binary representation. \n    If the number has fewer than 3 bits, return the number unchanged. For the special case where the number is 0, return 1.\n    \n    assert toggle_middle_bits(9) == 15\n    \"\"\"", "generated_programs": ["def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 2) - 1\n    return n ^ mask << 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/740", "requirement": "from typing import Dict, Tuple, Any\n\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    \"\"\"\n    Write a function to convert the given tuple to a key-value dictionary by pairing every two adjacent elements, starting from the first element.\n    If the tuple has an odd length, the last element should be ignored.\n    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    res = dict((test_tup[idx:idx + 2] for idx in range(0, len(test_tup) - 1, 2)))\n    return res", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    res = dict((test_tup[idx:idx + 2] for idx in range(0, len(test_tup) - 1, 2)))\n    return res", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    res = dict((test_tup[idx:idx + 2] for idx in range(0, len(test_tup) - 1, 2)))\n    return res", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    res = dict((test_tup[idx:idx + 2] for idx in range(0, len(test_tup) - 1, 2)))\n    return res", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    res = {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}\n    return res", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    res = dict((test_tup[idx:idx + 2] for idx in range(0, len(test_tup) - 1, 2)))\n    return res", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    res = {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}\n    return res"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/743", "requirement": "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    \"\"\"\n    Write a function to rotate a given list by a specified number of items to the right direction. \n    The function should handle the following cases:\n    1. If the list is empty (`[]`), return an empty list (`[]`) without raising an error.\n    2. If `m` exceeds the length of the list, use `m % len(l)` to determine the effective number of rotations.\n    3. If `m` is negative, treat it as rotating to the left by `abs(m)` positions. This is equivalent to rotating to the right by `len(l) - abs(m) % len(l)` positions. The modulo operation (`% len(l)`) ensures that the effective rotation index is within the bounds of the list length.\n    4. The function assumes valid input types: `l` is a list of integers, and `m` is an integer.\n\n    Example:\n    assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n\n    if m < 0:\n        m = n - abs(m) % n\n    return l[-m:] + l[:-m]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\"\"\"\nWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. \nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num)]\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if not any(map(lambda x: int(x) == 0 or num % int(x) != 0, str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if all((int(digit) != 0 and num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num)]\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        temp = num\n        while temp > 0:\n            digit = temp % 10\n            if digit == 0 or num % digit != 0:\n                break\n            temp //= 10\n        else:\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.8, "original_passk": 0.8}}
{"task_id": "Mbpp/752", "requirement": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Jacobsthal number using the recurrence relation:\n    J(n) = J(n-1) + 2 * J(n-2), with base cases J(0) = 0 and J(1) = 1.\n    The function should return 1 for any negative input.\n    The sequence starts as 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    assert jacobsthal_num(5) == 11\n    \"\"\"", "generated_programs": ["def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            a, b = (b, b + 2 * a)\n        return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j_prev2, j_prev1 = (0, 1)\n        for _ in range(2, n + 1):\n            j_current = j_prev1 + 2 * j_prev2\n            j_prev2, j_prev1 = (j_prev1, j_current)\n        return j_prev1", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            a, b = (b, b + 2 * a)\n        return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            a, b = (b, b + 2 * a)\n        return b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number. Polite numbers are positive integers that can be expressed as the sum of two or more consecutive positive integers. The nth polite number can be calculated using the formula: polite(n) = n + floor(0.5 + sqrt(2 * n)).\n\n    Reference: geeksforgeeks.org/n-th-polite-number/\n\n    Examples:\n    >>> assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(0.5 + math.sqrt(2 * n))", "from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(0.5 + math.sqrt(2 * n))", "from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))", "import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(0.5 + math.sqrt(2 * n))", "from math import sqrt, floor\n\ndef is_polite(n: int) -> int:\n    return n + floor(0.5 + sqrt(2 * n))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Write a Python function to get the elements in `li1` that are not present in `li2`, preserving the original order of elements in `li1`. \n    Duplicates in `li1` should be retained unless they are present in `li2`, in which case all occurrences should be removed.\n    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even number and the first odd number in a given list.\n    If either an even or odd number is not found in the list, the function should return 0.\n    \n    Examples:\n    >>> mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8])\n    4\n    >>> mul_even_odd([2, 4, 6, 8])\n    0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    else:\n        return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    else:\n        return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/785", "requirement": "def tuple_str_int(test_str: str) -> tuple:\n    \"\"\"\n    Convert a string representation of a tuple of integers into a tuple of integers.\n    The input string is expected to be in the format '(a, b, c, ...)', where a, b, c, etc., are integers.\n    Single-element tuples should be handled as tuples, e.g., '(1)' should be converted to (1,).\n    The function processes the string by stripping the parentheses and splitting by commas, then mapping the elements to integers.\n    \n    Examples:\n    >>> tuple_str_int(\"(7, 8, 9)\")\n    (7, 8, 9)\n    >>> tuple_str_int(\"(1)\")\n    (1,)\n    \"\"\"", "generated_programs": ["def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))", "def tuple_str_int(test_str: str) -> tuple:\n    return tuple((int(x.strip()) for x in test_str.strip('()').split(',')))"], "result": {"repaired_passk": 0.8, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches a string that starts with 'a', followed by zero or more characters, and ends with a single 'b'.\n    The entire string must conform to this pattern.\n    assert text_starta_endb(\"aabbbb\")\n    \"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('^a.*b$', text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}

{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that starts with the given string by appending the minimum necessary characters to its end.\n    \n    The function identifies the longest palindromic suffix of the input string and appends the reverse of the non-palindromic prefix to the end of the string.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string), -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[:len(string) - i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix_to_append = string[:i][::-1]\n            return string + prefix_to_append\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string), 0, -1):\n        if is_palindrome(string[:i]):\n            break\n    prefix_to_add = string[:i - 1:-1]\n    return string + prefix_to_add", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "import re\n\ndef make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if is_palindrome(string):\n        return string\n    for i in range(len(string)):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix = string[:i]\n            return string + prefix[::-1]", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "from typing import List\n\ndef make_palindrome(string: str) -> str:\n\n    def is_palindrome(substring: str) -> bool:\n        return substring == substring[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "from typing import List\n\ndef make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/32", "requirement": "def find_zero(xs: List[float]) -> float:\n    \"\"\"Finds a zero of the polynomial with coefficients xs using the bisection method within the interval [-100, 100].\n    The function assumes that xs has an even number of coefficients and that there is at least one real root within the interval.\n    Returns only one zero point, even if there are multiple. The bisection method stops when the value of the polynomial at the midpoint is exactly zero or when the interval is smaller than 1e-07.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def evaluate_polynomial(coefficients, x):\n        return sum((coefficient * x ** i for i, coefficient in enumerate(coefficients)))\n    left, right = (-100.0, 100.0)\n    tolerance = 1e-07\n    while right - left > tolerance:\n        midpoint = (left + right) / 2.0\n        value_midpoint = evaluate_polynomial(xs, midpoint)\n        if abs(value_midpoint) < tolerance:\n            return midpoint\n        value_left = evaluate_polynomial(xs, left)\n        if value_left * value_midpoint < 0:\n            right = midpoint\n        else:\n            left = midpoint\n    return (left + right) / 2.0", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial_value(x, coefficients):\n        return sum((coeff * x ** i for i, coeff in enumerate(coefficients)))\n\n    def bisection_method(coefficients, a, b, tol):\n        while abs(b - a) > tol:\n            mid = (a + b) / 2\n            val_a = polynomial_value(a, coefficients)\n            val_mid = polynomial_value(mid, coefficients)\n            if abs(val_mid) < tol:\n                return mid\n            elif val_a * val_mid < 0:\n                b = mid\n            else:\n                a = mid\n        return (a + b) / 2\n    a, b = (-100, 100)\n    tolerance = 1e-07\n    return bisection_method(xs, a, b, tolerance)", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial_value(coefficients: List[float], x: float) -> float:\n        result = 0\n        for i, coef in enumerate(coefficients):\n            result += coef * x ** i\n        return result\n\n    def bisection_method(coefficients: List[float], low: float, high: float) -> float:\n        while high - low > 1e-07:\n            mid = (low + high) / 2\n            value_at_mid = polynomial_value(coefficients, mid)\n            if abs(value_at_mid) < 1e-07:\n                return mid\n            value_at_low = polynomial_value(coefficients, low)\n            if value_at_low * value_at_mid < 0:\n                high = mid\n            else:\n                low = mid\n        return (low + high) / 2\n    return bisection_method(xs, -100, 100)", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(xs)))\n    left, right = (-100, 100)\n    while right - left > 1e-07:\n        mid = (left + right) / 2\n        value = polynomial(mid)\n        if abs(value) < 1e-07:\n            return mid\n        elif value * polynomial(left) < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial_value(coefficients, x):\n        return sum((coef * x ** idx for idx, coef in enumerate(coefficients)))\n    a, b = (-100, 100)\n    while b - a > 1e-07:\n        midpoint = (a + b) / 2\n        value_mid = polynomial_value(xs, midpoint)\n        if abs(value_mid) < 1e-07:\n            return midpoint\n        value_a = polynomial_value(xs, a)\n        if value_a * value_mid < 0:\n            b = midpoint\n        else:\n            a = midpoint\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def evaluate_polynomial(coefficients, x):\n        return sum((c * x ** i for i, c in enumerate(coefficients)))\n\n    def bisection_method(lower, upper, coefficients, tolerance=1e-07):\n        while upper - lower > tolerance:\n            midpoint = (lower + upper) / 2\n            value_at_midpoint = evaluate_polynomial(coefficients, midpoint)\n            if abs(value_at_midpoint) < tolerance:\n                return midpoint\n            if value_at_midpoint * evaluate_polynomial(coefficients, lower) < 0:\n                upper = midpoint\n            else:\n                lower = midpoint\n        return (lower + upper) / 2\n    return bisection_method(-100, 100, xs)", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(coeffs, x):\n        return sum((c * x ** i for i, c in enumerate(coeffs)))\n    left, right = (-100, 100)\n    tolerance = 1e-07\n    while right - left > tolerance:\n        mid = (left + right) / 2\n        f_mid = polynomial(xs, mid)\n        if f_mid == 0:\n            return mid\n        f_left = polynomial(xs, left)\n        if f_left * f_mid < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def evaluate_polynomial(coefficients: List[float], x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(coefficients)))\n    a, b = (-100, 100)\n    epsilon = 1e-07\n    while b - a > epsilon:\n        midpoint = (a + b) / 2\n        f_midpoint = evaluate_polynomial(xs, midpoint)\n        if abs(f_midpoint) < epsilon:\n            return midpoint\n        f_a = evaluate_polynomial(xs, a)\n        if f_a * f_midpoint < 0:\n            b = midpoint\n        else:\n            a = midpoint\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial_value(coefficients, x):\n        return sum((c * x ** i for i, c in enumerate(coefficients)))\n    left, right = (-100, 100)\n    tolerance = 1e-07\n    while right - left > tolerance:\n        midpoint = (left + right) / 2\n        value = polynomial_value(xs, midpoint)\n        if abs(value) < tolerance:\n            return midpoint\n        if polynomial_value(xs, left) * value < 0:\n            right = midpoint\n        else:\n            left = midpoint\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def evaluate_polynomial(coefficients, x):\n        return sum((c * x ** i for i, c in enumerate(coefficients)))\n    a, b = (-100, 100)\n    while b - a > 1e-07:\n        midpoint = (a + b) / 2\n        f_mid = evaluate_polynomial(xs, midpoint)\n        if abs(f_mid) < 1e-07:\n            return midpoint\n        f_a = evaluate_polynomial(xs, a)\n        if f_a * f_mid < 0:\n            b = midpoint\n        else:\n            a = midpoint\n    return (a + b) / 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_list[mid - 1] + sorted_list[mid]) / 2\n    else:\n        return float(sorted_list[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_list[mid - 1] + sorted_list[mid]) / 2\n    else:\n        return float(sorted_list[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_list[mid - 1] + sorted_list[mid]) / 2\n    else:\n        return float(sorted_list[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "import typing\nfrom typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2.0\n    else:\n        return l_sorted[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/59", "requirement": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of the given integer n. \n    The function assumes that n is greater than 1 and is not a prime number itself.\n    \n    The largest prime factor is the greatest prime number that divides n without leaving a remainder.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"", "generated_programs": ["import math\n\ndef largest_prime_factor(n: int) -> int:\n    largest_factor = -1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    factor = 2\n    while n > 1:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return factor", "from math import sqrt\n\ndef largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n //= i\n        else:\n            i += 1\n    return n", "from math import isqrt\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, isqrt(num) + 1):\n            if num % i == 0:\n                return False\n        return True\n    largest_factor = 1\n    factor = 2\n    while n % factor == 0:\n        largest_factor = factor\n        n //= factor\n    factor = 3\n    while factor <= isqrt(n):\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "from math import isqrt\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, isqrt(num) + 1):\n            if num % i == 0:\n                return False\n        return True\n    factor = 2\n    while n > 1:\n        if n % factor == 0:\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n        if factor * factor > n and n > 1:\n            return n\n    return factor", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "from math import sqrt\n\ndef largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    factor = 2\n    while n % factor == 0:\n        n //= factor\n    factor = 3\n    while factor <= math.sqrt(n):\n        while n % factor == 0:\n            n //= factor\n        factor += 2\n    return n if n > 2 else factor"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.9}}
{"task_id": "HumanEval/60", "requirement": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n. If n is negative, the function returns 0.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    >>> sum_to_n(-5)\n    0\n    \"\"\"", "generated_programs": ["def sum_to_n(n: int) -> int:\n    return sum(range(1, n + 1)) if n > 0 else 0", "from typing import Union\n\ndef sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum(range(1, n + 1))", "def sum_to_n(n: int) -> int:\n    return sum(range(1, n + 1)) if n > 0 else 0", "def sum_to_n(n: int) -> int:\n    return sum(range(1, n + 1)) if n > 0 else 0", "def sum_to_n(n: int) -> int:\n    return sum(range(1, n + 1)) if n > 0 else 0", "def sum_to_n(n: int) -> int:\n    return sum(range(1, n + 1)) if n >= 0 else 0", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "from typing import Any\n\ndef sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum(range(1, n + 1))", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/65", "requirement": "def circular_shift(x: int, shift: int) -> str:\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef circular_shift(x: int, shift: int) -> str:\n    digits = list(str(x))\n    num_digits = len(digits)\n    if shift > num_digits:\n        return ''.join(reversed(digits))\n    shift %= num_digits\n    shifted_digits = digits[-shift:] + digits[:-shift]\n    return ''.join(shifted_digits)", "def circular_shift(x: int, shift: int) -> str:\n    digits = list(str(x))\n    n = len(digits)\n    if shift > n:\n        return ''.join(reversed(digits))\n    result = digits[-shift % n:] + digits[:-shift % n]\n    return ''.join(result)", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = list(str(x))\n    n = len(digits)\n    if shift > n:\n        return ''.join(digits[::-1])\n    shift %= n\n    return ''.join(digits[-shift:] + digits[:-shift])", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    num_digits = len(digits)\n    if shift > num_digits:\n        return digits[::-1]\n    shift %= num_digits\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    x_str = str(x)\n    n = len(x_str)\n    if shift > n:\n        return x_str[::-1]\n    shift %= n\n    return x_str[-shift:] + x_str[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    length = len(digits)\n    if shift > length:\n        return digits[::-1]\n    shift = shift % length\n    return digits[-shift:] + digits[:-shift]", "from typing import List\n\ndef circular_shift(x: int, shift: int) -> str:\n    digits = list(str(x))\n    num_digits = len(digits)\n    if shift > num_digits:\n        return ''.join(reversed(digits))\n    shift = shift % num_digits\n    shifted_digits = digits[-shift:] + digits[:-shift]\n    return ''.join(shifted_digits)", "def circular_shift(x: int, shift: int) -> str:\n    x_str = str(x)\n    num_digits = len(x_str)\n    if shift > num_digits:\n        return x_str[::-1]\n    shift %= num_digits\n    return x_str[-shift:] + x_str[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    x_str = str(x)\n    n = len(x_str)\n    if shift > n:\n        return x_str[::-1]\n    shift %= n\n    return x_str[-shift:] + x_str[:-shift]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    '''\n    Write a function that takes an integer a and returns True \n    if there exists an integer n such that n^3 equals a.\n    The function should correctly handle both positive and negative integers.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "generated_programs": ["def iscube(a: int) -> bool:\n    n = round(abs(a) ** (1 / 3))\n    return n ** 3 == abs(a)", "def iscube(a: int) -> bool:\n    n = round(abs(a) ** (1 / 3))\n    return n ** 3 == abs(a) or (-n ** 3 == a if a < 0 else False)", "def iscube(a: int) -> bool:\n    n = round(abs(a) ** (1 / 3))\n    return n ** 3 == abs(a) and (a >= 0 or n % 2 == 1)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    n = round(abs(a) ** (1 / 3))\n    return n ** 3 == abs(a)", "def iscube(a: int) -> bool:\n    n = round(abs(a) ** (1 / 3))\n    return n ** 3 == abs(a) if a >= 0 else (-n) ** 3 == a", "def iscube(a: int) -> bool:\n    n = round(a ** (1 / 3))\n    return n ** 3 == a", "def iscube(a: int) -> bool:\n    n = round(abs(a) ** (1 / 3))\n    return n ** 3 == abs(a)", "from math import isclose\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3))\n    return isclose(cube_root ** 3, abs(a), rel_tol=1e-09) and (a >= 0 or cube_root ** 3 == -a)", "import math\n\ndef iscube(a: int) -> bool:\n    n = round(a ** (1 / 3))\n    return n ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    n = round(a ** (1 / 3))\n    return n ** 3 == a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.6}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1. Numbers that both start and end\n    with 1 should be counted only once.\n    \n    Examples:\n    >>> starts_one_ends(1)\n    1\n    >>> starts_one_ends(2)\n    18\n    >>> starts_one_ends(3)\n    180\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = starts_with_1\n    starts_and_ends_with_1 = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - starts_and_ends_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_with_start_1 = 10 ** (n - 1)\n    total_with_end_1 = 10 ** (n - 1)\n    total_with_start_and_end_1 = 10 ** (n - 2)\n    return total_with_start_1 + total_with_end_1 - total_with_start_and_end_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_start_ends_with_1 = 2 * 10 ** (n - 1) - 10 ** (n - 2)\n    return total_start_ends_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    both_start_and_end_with_1 = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 9 * 10 ** (n - 1)\n    overlap = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 9 * 10 ** (n - 1)\n    both_start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_start_or_end_1 = 9 * 10 ** (n - 1) + 9 * 10 ** (n - 1) - 10 ** (n - 2)\n    return total_start_or_end_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_start_with_1 = 10 ** (n - 1)\n    total_end_with_1 = 10 ** (n - 1)\n    overlap_start_and_end_with_1 = 10 ** (n - 2)\n    return total_start_with_1 + total_end_with_1 - overlap_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_start_1 = 10 ** (n - 1)\n    total_end_1 = 10 ** (n - 1)\n    overlap = total_start_1 // 10\n    return total_start_1 + total_end_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - both_start_and_end_with_1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by four places. The rotation should be applied separately \n    for uppercase and lowercase letters.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n\n    def rotate_char(c, rotation):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + rotation) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + rotation) % 26 + ord('A'))\n        return c\n    return ''.join((rotate_char(c, 4) for c in s))", "def encrypt(s: str) -> str:\n    res = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            res.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            res.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            res.append(char)\n    return ''.join(res)", "def encrypt(s: str) -> str:\n\n    def rotate_char(c, shift, start):\n        return chr((ord(c) - start + shift) % 26 + start)\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(rotate_char(char, 4, ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(rotate_char(char, 4, ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            encrypted.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((rotate_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def rotate_char(c: str, shift: int, start: int) -> str:\n        return chr((ord(c) - start + shift) % 26 + start)\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(rotate_char(char, 4, ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(rotate_char(char, 4, ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n\n    def rotate_char(c, offset):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + offset) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + offset) % 26 + ord('A'))\n        return c\n    return ''.join((rotate_char(c, 4) for c in s))", "def encrypt(s: str) -> str:\n\n    def rotate_char(c, shift, start):\n        return chr((ord(c) - start + shift) % 26 + start)\n    shift = 4\n    encrypted = ''\n    for char in s:\n        if char.islower():\n            encrypted += rotate_char(char, shift, ord('a'))\n        elif char.isupper():\n            encrypted += rotate_char(char, shift, ord('A'))\n        else:\n            encrypted += char\n    return encrypted", "def encrypt(s: str) -> str:\n\n    def rotate_char(c, offset):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + offset) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + offset) % 26 + ord('A'))\n        return c\n    return ''.join((rotate_char(c, 4) for c in s))", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            result.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is defined as a sentence that starts with the exact\n    sequence 'I ' (the letter 'I' followed by a space). Sentences are delimited by '.', '?',\n    or '!'. Consecutive delimiters or delimiters within words should not affect sentence separation.\n    Duplicate sentences are counted separately.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n\n    ### Test 1\n    Input: ['I am here. You are there. They are everywhere.']\n    Expected Output: [3]\n\n    ### Test 2\n    Input: ['I. I! I?']\n    Expected Output: [0]\n\n    ### Test 3\n    Input: ['I am bored. Are you? I certainly am!']\n    Expected Output: [4]\n    \"\"\"", "generated_programs": ["def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.!?]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return boredom_count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    boredom_count = sum((sentence.strip().startswith('I ') for sentence in sentences))\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]', S)\n    count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/92", "requirement": "def any_int(x: int, y: int, z: int) -> bool:\n    '''\n    Create a function that takes 3 integers.\n    Returns true if one of the numbers is equal to the sum of the other two.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n    '''", "generated_programs": ["from typing import List\n\ndef any_int(x: int, y: int, z: int) -> bool:\n    if not isinstance(x, int) or not isinstance(y, int) or (not isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "from typing import Tuple\n\ndef any_int(x: int, y: int, z: int) -> bool:\n    return x == y + z or y == x + z or z == x + y", "from typing import Any\n\ndef any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in [x, y, z])):\n        return False\n    return x == y + z or y == x + z or z == x + y", "from typing import Union\n\ndef any_int(x: int, y: int, z: int) -> bool:\n    return x == y + z or y == x + z or z == x + y", "from typing import Tuple\n\ndef any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(arg, int) for arg in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        return x == y + z or y == x + z or z == x + y\n    return False", "from typing import Any\n\ndef any_int(x: int, y: int, z: int) -> bool:\n    return x == y + z or y == x + z or z == x + y", "from typing import Any\n\ndef any_int(x: int, y: int, z: int) -> bool:\n    return x == y + z or y == x + z or z == x + y", "from typing import Tuple\n\ndef any_int(x: int, y: int, z: int) -> bool:\n    return x + y == z or x + z == y or y + z == x", "from typing import List\n\ndef any_int(x: int, y: int, z: int) -> bool:\n    return x == y + z or y == x + z or z == x + y"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.4, "original_passk": 1.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message consisting solely of letters, and encodes it by first swapping the case of all letters and then replacing each vowel with the letter that appears two places ahead of it in the English alphabet, considering the case (uppercase or lowercase) of the vowel.\n\n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        mapping = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return mapping[vowel]\n    swapped_case = ''.join((c.lower() if c.isupper() else c.upper() for c in message))\n    encoded_message = ''.join((shift_vowel(c) if c.lower() in 'aeiou' else c for c in swapped_case))\n    return encoded_message", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        vowels = 'aeiouAEIOU'\n        shifted_vowels = 'cgkqwCGKQW'\n        return shifted_vowels[vowels.index(vowel)]\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            char = char.swapcase()\n            if char in 'aeiouAEIOU':\n                char = shift_vowel(char)\n        encoded_message += char\n    return encoded_message", "def encode(message: str) -> str:\n\n    def swap_case_and_transform_vowel(character: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if character.isalpha():\n            if character in vowels:\n                offset = 2\n                new_char = chr(ord(character) + offset)\n                return new_char.lower() if character.islower() else new_char.upper()\n            else:\n                return character.swapcase()\n        return character\n    return ''.join((swap_case_and_transform_vowel(c) for c in message))", "def encode(message: str) -> str:\n\n    def swap_case(char):\n        return char.lower() if char.isupper() else char.upper()\n\n    def replace_vowel(char):\n        vowels = 'aeiouAEIOU'\n        replacements = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return replacements[char] if char in vowels else char\n    swapped_message = ''.join((swap_case(c) for c in message))\n    encoded_message = ''.join((replace_vowel(c) for c in swapped_message))\n    return encoded_message", "def encode(message: str) -> str:\n\n    def get_encoded_char(c: str) -> str:\n        vowels_lower = 'aeiou'\n        vowels_upper = 'AEIOU'\n        if c in vowels_lower:\n            return chr((ord(c) - ord('a') + 2) % 26 + ord('a'))\n        elif c in vowels_upper:\n            return chr((ord(c) - ord('A') + 2) % 26 + ord('A'))\n        return c\n    swapped_message = ''.join((c.lower() if c.isupper() else c.upper() for c in message))\n    encoded_message = ''.join((get_encoded_char(c) for c in swapped_message))\n    return encoded_message", "def encode(message: str) -> str:\n\n    def is_vowel(char: str) -> bool:\n        return char.lower() in 'aeiou'\n\n    def shift_vowel(vowel: str) -> str:\n        shift_dict = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return shift_dict[vowel]\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            char = char.swapcase()\n            if is_vowel(char):\n                char = shift_vowel(char)\n        encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n\n    def is_vowel(char):\n        return char.lower() in 'aeiou'\n\n    def replace_vowel(vowel):\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        index = alphabet.index(vowel.lower())\n        new_char = alphabet[(index + 2) % 26]\n        return new_char.upper() if vowel.isupper() else new_char\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            swapped_case = char.swapcase()\n            if is_vowel(swapped_case):\n                encoded_message += replace_vowel(swapped_case)\n            else:\n                encoded_message += swapped_case\n        else:\n            encoded_message += char\n    return encoded_message", "def encode(message: str) -> str:\n\n    def shift_vowel(char):\n        vowels = 'aeiouAEIOU'\n        if char in vowels:\n            shift = 2\n            if char.islower():\n                return chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                return chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        return char\n    swapped_case = [char.lower() if char.isupper() else char.upper() for char in message]\n    encoded_message = ''.join((shift_vowel(char) for char in swapped_case))\n    return encoded_message", "def encode(message: str) -> str:\n\n    def swap_case_and_transform_vowel(char: str) -> str:\n        if char.isupper():\n            swapped = char.lower()\n        else:\n            swapped = char.upper()\n        vowels = 'aeiouAEIOU'\n        if swapped in vowels:\n            if swapped.islower():\n                return chr((ord(swapped) - ord('a') + 2) % 26 + ord('a'))\n            else:\n                return chr((ord(swapped) - ord('A') + 2) % 26 + ord('A'))\n        return swapped\n    return ''.join((swap_case_and_transform_vowel(char) for char in message))", "def encode(message: str) -> str:\n\n    def process_char(c: str) -> str:\n        if c.lower() in 'aeiou':\n            shift = 2\n            new_char = chr(ord(c) + shift)\n            if c.isupper():\n                return new_char.upper()\n            else:\n                return new_char.lower()\n        return c\n    swapped_message = ''.join((c.lower() if c.isupper() else c.upper() for c in message))\n    encoded_message = ''.join((process_char(c) for c in swapped_message))\n    return encoded_message"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.9, "original_passk": 0.4}}
{"task_id": "HumanEval/94", "requirement": "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value in the list and return the sum of its digits.\n    If there are no prime numbers in the list, return 0.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        return 0\n    largest_prime = max(primes)\n    return sum(map(int, str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        return 0\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        return 0\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        return 0\n    largest_prime = max(primes)\n    return sum(map(int, str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    prime_numbers = [num for num in lst if is_prime(num)]\n    if not prime_numbers:\n        return 0\n    largest_prime = max(prime_numbers)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    prime_values = [value for value in lst if is_prime(value)]\n    if not prime_values:\n        return 0\n    largest_prime = max(prime_values)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\nimport math\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        for i in range(5, int(math.sqrt(n)) + 1, 6):\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n        return True\n    largest_prime = max((x for x in lst if is_prime(x)), default=0)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\nimport math\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(math.sqrt(n)) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    prime_numbers = [num for num in lst if is_prime(num)]\n    if not prime_numbers:\n        return 0\n    largest_prime = max(prime_numbers)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    largest_prime = max((x for x in lst if is_prime(x)), default=0)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        return 0\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/95", "requirement": "from typing import Dict\n\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"", "generated_programs": ["from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(key, str) and key.islower() for key in keys)):\n        return True\n    elif all((isinstance(key, str) and key.isupper() for key in keys)):\n        return True\n    else:\n        return False", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    if all((key.islower() for key in keys)) or all((key.isupper() for key in keys)):\n        return True\n    return False", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(key, str) and key.islower() for key in keys)):\n        return True\n    elif all((isinstance(key, str) and key.isupper() for key in keys)):\n        return True\n    return False", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    all_lower = all((key.islower() for key in keys))\n    all_upper = all((key.isupper() for key in keys))\n    return all_lower or all_upper", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    lowercase = all((isinstance(key, str) and key.islower() for key in dict.keys()))\n    uppercase = all((isinstance(key, str) and key.isupper() for key in dict.keys()))\n    return lowercase or uppercase", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    all_lowercase = all((key.islower() for key in keys))\n    all_uppercase = all((key.isupper() for key in keys))\n    return all_lowercase or all_uppercase", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if not all((isinstance(key, str) for key in keys)):\n        return False\n    all_lower = all((key.islower() for key in keys))\n    all_upper = all((key.isupper() for key in keys))\n    return all_lower or all_upper", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    str_keys = [key for key in dict.keys() if isinstance(key, str)]\n    if not str_keys or len(str_keys) != len(dict.keys()):\n        return False\n    all_lower = all((key.islower() for key in str_keys))\n    all_upper = all((key.isupper() for key in str_keys))\n    return all_lower or all_upper", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(k, str) and k.islower() for k in keys)):\n        return True\n    if all((isinstance(k, str) and k.isupper() for k in keys)):\n        return True\n    return False", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(k, str) and k.islower() for k in keys)):\n        return True\n    elif all((isinstance(k, str) and k.isupper() for k in keys)):\n        return True\n    else:\n        return False"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if the current number of stones is odd.\n        - the next even number if the current number of stones is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    for i in range(n):\n        pile.append(n + 2 * i)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n\n    def next_number(current: int) -> int:\n        return current + 2\n    pile = []\n    for _ in range(n):\n        pile.append(n)\n        n = next_number(n)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    for _ in range(1, n):\n        if n % 2 == 0:\n            n += 2\n        else:\n            n += 2\n        pile.append(n)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        if current_stones % 2 == 0:\n            current_stones += 2\n        else:\n            current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    result = []\n    current = n\n    for _ in range(n):\n        result.append(current)\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 2\n    return result", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    result = []\n    current_stones = n\n    for _ in range(n):\n        result.append(current_stones)\n        if current_stones % 2 == 0:\n            current_stones += 2\n        else:\n            current_stones += 2\n    return result", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + i * 2 for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    for i in range(1, n):\n        if pile[-1] % 2 == 0:\n            pile.append(pile[-1] + 2)\n        else:\n            pile.append(pile[-1] + 2)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    current = n\n    for _ in range(n - 1):\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 2\n        pile.append(current)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        if current_stones % 2 == 0:\n            current_stones += 2\n        else:\n            current_stones += 2\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements whose sum of digits (considering the sign of the first digit for negative numbers) is greater than 0.\n    If a number is negative, then its first digit is considered negative:\n    e.g., -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def signed_digit_sum(num: int) -> int:\n        num_str = str(num)\n        sign = -1 if num_str[0] == '-' else 1\n        digits = [int(char) for char in num_str if char.isdigit()]\n        if num < 0:\n            digits[0] *= sign\n        return sum(digits)\n    return sum((1 for num in arr if signed_digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def signed_digit_sum(n: int) -> int:\n        num_str = str(n)\n        if n < 0:\n            digits = [-int(num_str[1])] + [int(c) for c in num_str[2:]]\n        else:\n            digits = [int(c) for c in num_str]\n        return sum(digits)\n    return sum((1 for n in arr if signed_digit_sum(n) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_signed_digits(num):\n        str_num = str(num)\n        if num < 0:\n            return sum([-int(str_num[1])] + [int(d) for d in str_num[2:]])\n        return sum((int(d) for d in str_num))\n    return sum((1 for num in arr if sum_of_signed_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def signed_digit_sum(number: int) -> int:\n        str_num = str(abs(number))\n        if number < 0:\n            signed_digits = [-int(str_num[0])] + [int(d) for d in str_num[1:]]\n        else:\n            signed_digits = [int(d) for d in str_num]\n        return sum(signed_digits)\n    return sum((1 for num in arr if signed_digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        str_num = str(num)\n        if str_num[0] == '-':\n            return int(str_num[1]) * -1 + sum((int(digit) for digit in str_num[2:]))\n        return sum((int(digit) for digit in str_num))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def signed_digit_sum(num: int) -> int:\n        str_num = str(num)\n        if num < 0:\n            digit_sum = sum((int(str_num[i]) for i in range(1, len(str_num)))) - int(str_num[1])\n            return int(str_num[0]) + digit_sum\n        return sum((int(ch) for ch in str_num))\n    return sum((1 for number in arr if signed_digit_sum(number) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def signed_sum(number: int) -> int:\n        str_num = str(number)\n        if str_num[0] == '-':\n            digits = [-int(str_num[1])] + [int(d) for d in str_num[2:]]\n        else:\n            digits = [int(d) for d in str_num]\n        return sum(digits)\n    return sum((1 for num in arr if signed_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_signed_digits(num: int) -> int:\n        if num < 0:\n            num_str = str(num)\n            signed_digits = [int(num_str[0])] + [int(d) for d in num_str[1:]]\n        else:\n            signed_digits = [int(d) for d in str(num)]\n        return sum(signed_digits)\n    return sum((1 for num in arr if sum_of_signed_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def signed_digit_sum(n: int) -> int:\n        digits = [int(d) for d in str(abs(n))]\n        if n < 0:\n            digits[0] *= -1\n        return sum(digits)\n    return sum((1 for num in arr if signed_digit_sum(num) > 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7777777777777778, "original_passk": 0.5}}
{"task_id": "HumanEval/109", "requirement": "def move_one_ball(arr: List[int]) -> bool:\n    \"\"\"Determine if the array can be sorted in non-decreasing order by performing\n    zero or more right shift operations. A right shift operation moves each element\n    of the array one position to the right, with the last element moving to the\n    first position.\n\n    Specifically, check if there is at most one place in the array where a larger\n    number is followed by a smaller number, which would indicate that the array\n    can be rotated to become sorted. An empty array is considered sorted, so return True.\n\n    Note: The array is guaranteed to contain unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2]) ==> True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2]) ==> False\n    Explanation: It is not possible to get non-decreasing order for the given\n                 array by performing any number of right shift operations.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    n = len(arr)\n    if n <= 1:\n        return True\n    count_breaks = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count_breaks += 1\n            if count_breaks > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    n = len(arr)\n    if n <= 1:\n        return True\n    count_breaks = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count_breaks += 1\n        if count_breaks > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count_breakpoints = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count_breakpoints += 1\n    return count_breakpoints <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    n = len(arr)\n    if n <= 1:\n        return True\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n            if count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n    return count <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n    return count <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count_breakpoints = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count_breakpoints += 1\n            if count_breakpoints > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    n = len(arr)\n    if n == 0:\n        return True\n    drops = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            drops += 1\n            if drops > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    n = len(arr)\n    if n <= 1:\n        return True\n    count_breaks = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count_breaks += 1\n            if count_breaks > 1:\n                return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/110", "requirement": "def exchange(lst1: List[int], lst2: List[int]) -> str:\n    \"\"\"Determine if it is possible to make all elements of lst1 even by exchanging\n    elements with lst2. You can move any number of elements from lst2 to lst1.\n    If all elements in lst1 can be made even through exchanges, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    even_elements = [x for x in lst2 if x % 2 == 0]\n    for element in lst1:\n        if element % 2 != 0:\n            if not even_elements:\n                return 'NO'\n            even_elements.pop()\n    return 'YES'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    if all((x % 2 == 0 for x in lst1)):\n        return 'YES'\n    for x in lst2:\n        if x % 2 == 0:\n            lst1.append(x)\n            if all((element % 2 == 0 for element in lst1)):\n                return 'YES'\n            lst1.pop()\n    return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    total_even_elements = [x for x in lst1 + lst2 if x % 2 == 0]\n    if len(total_even_elements) >= len(lst1):\n        return 'YES'\n    return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = [x for x in lst1 if x % 2 != 0]\n    even_in_lst2 = [x for x in lst2 if x % 2 == 0]\n    return 'YES' if len(odd_in_lst1) <= len(even_in_lst2) else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    even_from_lst2 = [num for num in lst2 if num % 2 == 0]\n    odd_from_lst1 = [num for num in lst1 if num % 2 != 0]\n    if len(even_from_lst2) >= len(odd_from_lst1):\n        return 'YES'\n    return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    if all((x % 2 == 0 for x in lst1)):\n        return 'YES'\n    odd_lst1 = [x for x in lst1 if x % 2 != 0]\n    even_lst2 = [x for x in lst2 if x % 2 == 0]\n    if len(even_lst2) >= len(odd_lst1):\n        return 'YES'\n    else:\n        return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_lst1 = [x for x in lst1 if x % 2 != 0]\n    even_lst2 = [x for x in lst2 if x % 2 == 0]\n    if len(odd_lst1) <= len(even_lst2):\n        return 'YES'\n    return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if odd_count_lst1 <= even_count_lst2 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    lst1_odd = [x for x in lst1 if x % 2 != 0]\n    lst2_even = [x for x in lst2 if x % 2 == 0]\n    if len(lst1_odd) <= len(lst2_even):\n        return 'YES'\n    return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_elements_lst1 = [x for x in lst1 if x % 2 != 0]\n    even_elements_lst2 = [x for x in lst2 if x % 2 == 0]\n    if len(odd_elements_lst1) <= len(even_elements_lst2):\n        return 'YES'\n    return 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.9}}
{"task_id": "HumanEval/115", "requirement": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells. The number of times you need to lower the buckets\n    is calculated independently for each well and then summed up. This means that for each well, you determine\n    how many full bucket loads are required to remove all the water, considering the bucket's capacity.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum((math.ceil(sum(row) / capacity) for row in grid))", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum(((sum(row) + capacity - 1) // capacity for row in grid))", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum((math.ceil(sum(row) / capacity) for row in grid))", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum(((sum(row) + capacity - 1) // capacity for row in grid))", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum(((sum(row) + capacity - 1) // capacity for row in grid))", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum(((sum(row) + capacity - 1) // capacity for row in grid))", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum(((sum(row) + capacity - 1) // capacity for row in grid))", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_loads = 0\n    for well in grid:\n        water_units = sum(well)\n        total_loads += -(-water_units // capacity)\n    return total_loads", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_bucket_loads = 0\n    for well in grid:\n        water_units = sum(well)\n        total_bucket_loads += (water_units + capacity - 1) // capacity\n    return total_bucket_loads", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum(((sum(row) + capacity - 1) // capacity for row in grid))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of integers according to the following rules:\n    - Non-negative integers should be sorted based on the number of ones in their binary representation in ascending order.\n    - For non-negative integers with the same number of ones, sort them based on their decimal value.\n    - Negative integers should be placed before any non-negative integers and sorted among themselves based on their decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (x < 0, bin(x).count('1') if x >= 0 else 0, x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (x < 0, bin(x).count('1') if x >= 0 else 0, x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negatives = sorted([x for x in arr if x < 0])\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative_numbers = list(filter(lambda x: x < 0, arr))\n    non_negative_numbers = list(filter(lambda x: x >= 0, arr))\n    negative_numbers.sort()\n    non_negative_numbers.sort(key=lambda x: (bin(x).count('1'), x))\n    return negative_numbers + non_negative_numbers", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (x < 0, bin(x).count('1') if x >= 0 else 0, abs(x)))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative_numbers = sorted([x for x in arr if x < 0])\n    non_negative_numbers = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative_numbers + non_negative_numbers", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(num):\n        return bin(num).count('1')\n    negative = sorted(filter(lambda x: x < 0, arr))\n    non_negative = sorted(filter(lambda x: x >= 0, arr), key=lambda x: (count_ones(x), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative = sorted([num for num in arr if num < 0])\n    non_negative = sorted([num for num in arr if num >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative_nums = sorted(filter(lambda x: x < 0, arr))\n    non_negative_nums = sorted(filter(lambda x: x >= 0, arr), key=lambda x: (bin(x).count('1'), x))\n    return negative_nums + non_negative_nums", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negatives = sorted([x for x in arr if x < 0])\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negatives + non_negatives"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The date should be in the exact format 'mm-dd-yyyy' with leading zeros for single-digit months and days. Any deviation from this format will result in an invalid date.\n    3. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2, considering leap years.\n    4. The months should not be less than 1 or higher than 12.\n    5. The year should be a valid year greater than '0000'.\n\n    For example:\n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        date_obj = datetime.strptime(date, '%m-%d-%Y')\n        month = date_obj.month\n        day = date_obj.day\n        year = date_obj.year\n        if year <= 0:\n            return False\n        if month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                return 1 <= day <= 29\n            else:\n                return 1 <= day <= 28\n        elif month in {4, 6, 9, 11}:\n            return 1 <= day <= 30\n        elif month in {1, 3, 5, 7, 8, 10, 12}:\n            return 1 <= day <= 31\n        else:\n            return False\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        parsed_date = datetime.strptime(date, '%m-%d-%Y')\n        month, day, year = (parsed_date.month, parsed_date.day, parsed_date.year)\n        if year <= 0:\n            return False\n        if month < 1 or month > 12:\n            return False\n        if month in {4, 6, 9, 11} and (day < 1 or day > 30):\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12} and (day < 1 or day > 31):\n            return False\n        if month == 2:\n            if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n                if day < 1 or day > 29:\n                    return False\n            elif day < 1 or day > 28:\n                return False\n        return True\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        parsed_date = datetime.strptime(date, '%m-%d-%Y')\n        month = parsed_date.month\n        day = parsed_date.day\n        year = parsed_date.year\n        if year <= 0:\n            return False\n        if month < 1 or month > 12:\n            return False\n        days_in_month = {1: 31, 3: 31, 5: 31, 7: 31, 8: 31, 10: 31, 12: 31, 4: 30, 6: 30, 9: 30, 11: 30, 2: 29 if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) else 28}\n        if day < 1 or day > days_in_month.get(month, 0):\n            return False\n        return True\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        datetime.strptime(date, '%m-%d-%Y')\n    except ValueError:\n        return False\n    month, day, year = map(int, date.split('-'))\n    if year <= 0:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1 or day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2:\n        if day > 29:\n            return False\n        if day == 29:\n            if not (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)):\n                return False\n    return True", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date or len(date) != 10:\n        return False\n    try:\n        date_obj = datetime.strptime(date, '%m-%d-%Y')\n        month, day, year = (date_obj.month, date_obj.day, date_obj.year)\n        if year <= 0 or month < 1 or month > 12 or (day < 1):\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n            return False\n        if month in {4, 6, 9, 11} and day > 30:\n            return False\n        if month == 2:\n            is_leap = year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n            if is_leap and day > 29:\n                return False\n            if not is_leap and day > 28:\n                return False\n        return True\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        parsed_date = datetime.strptime(date, '%m-%d-%Y')\n    except ValueError:\n        return False\n    month = parsed_date.month\n    day = parsed_date.day\n    year = parsed_date.year\n    if year <= 0:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and (day < 1 or day > 31):\n        return False\n    elif month in {4, 6, 9, 11} and (day < 1 or day > 30):\n        return False\n    elif month == 2:\n        is_leap = year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n        if is_leap and (day < 1 or day > 29):\n            return False\n        if not is_leap and (day < 1 or day > 28):\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    date_pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-(\\\\d{4})$'\n    match = re.match(date_pattern, date)\n    if not match:\n        return False\n    month, day, year = (int(match.group(1)), int(match.group(2)), int(match.group(3)))\n    if year <= 0:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day > 30:\n            return False\n    else:\n        is_leap_year = year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n        if is_leap_year:\n            if day > 29:\n                return False\n        elif day > 28:\n            return False\n    return True", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        parsed_date = datetime.strptime(date, '%m-%d-%Y')\n        month = parsed_date.month\n        day = parsed_date.day\n        year = parsed_date.year\n        if year <= 0:\n            return False\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12} and (day < 1 or day > 31):\n            return False\n        if month in {4, 6, 9, 11} and (day < 1 or day > 30):\n            return False\n        if month == 2:\n            if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n                if day < 1 or day > 29:\n                    return False\n            elif day < 1 or day > 28:\n                return False\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12 or year <= 0:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day < 1 or day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day < 1 or day > 30:\n                return False\n        elif month == 2:\n            if day < 1 or day > 29:\n                return False\n            if day == 29 and (not (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0))):\n                return False\n        return True\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        parsed_date = datetime.strptime(date, '%m-%d-%Y')\n    except ValueError:\n        return False\n    month = parsed_date.month\n    day = parsed_date.day\n    year = parsed_date.year\n    if year <= 0:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and (not 1 <= day <= 31):\n        return False\n    if month in {4, 6, 9, 11} and (not 1 <= day <= 30):\n        return False\n    if month == 2:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            if not 1 <= day <= 29:\n                return False\n        elif not 1 <= day <= 28:\n            return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/125", "requirement": "from typing import List\nfrom typing import Union\n\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exist in the text you\n    should split on commas ','. If no commas exist, you should return the number of lowercase letters with even order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25.\n    \n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(((ord(char) - ord('a')) % 2 == 0 for char in txt if char.islower()))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        even_order_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return even_order_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for ch in txt if ch.islower() and (ord(ch) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        even_order_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return even_order_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        even_lowercase_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return even_lowercase_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(((ord(c) - ord('a')) % 2 == 0 for c in txt if 'a' <= c <= 'z'))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        even_order_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return even_order_count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "HumanEval/127", "requirement": "from typing import Tuple\n\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start + 1\n    if is_prime(intersection_length):\n        return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(number: int) -> bool:\n        if number < 2:\n            return False\n        for i in range(2, int(number ** 0.5) + 1):\n            if number % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(number: int) -> bool:\n        if number <= 1:\n            return False\n        for i in range(2, int(number ** 0.5) + 1):\n            if number % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length_of_intersection = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length_of_intersection) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start <= intersection_end:\n        length = intersection_end - intersection_start + 1\n        return 'YES' if is_prime(length) else 'NO'\n    return 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    intersection_length = end - start + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a unique value from the range [1, N * N].\n    \n    The task is to find the lexicographically smallest path of length k in the grid. \n    You can start from any cell and move to any of its neighboring cells (sharing an edge). \n    A path of length k means visiting exactly k cells, which can include revisiting the same cell.\n    You must stay within the boundaries of the grid.\n    \n    A path A is lexicographically smaller than a path B if the sequence of values in A is \n    lexicographically smaller than the sequence of values in B. The answer is guaranteed to be unique.\n    \n    Return the sequence of values representing the lexicographically smallest path.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def neighbors(r, c):\n        for dr, dc in directions:\n            nr, nc = (r + dr, c + dc)\n            if 0 <= nr < n and 0 <= nc < n:\n                yield (nr, nc)\n    min_heap = [(grid[r][c], [(r, c)], grid[r][c]) for r in range(n) for c in range(n)]\n    heapq.heapify(min_heap)\n    while True:\n        _, path, curr_value = heapq.heappop(min_heap)\n        if len(path) == k:\n            return [grid[r][c] for r, c in path]\n        last_r, last_c = path[-1]\n        for nr, nc in neighbors(last_r, last_c):\n            new_path = path + [(nr, nc)]\n            heapq.heappush(min_heap, (curr_value + grid[nr][nc], new_path, curr_value + grid[nr][nc]))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            heapq.heappush(min_heap, path[:])\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    n = len(grid)\n    min_heap = []\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, [grid[i][j]])\n    return heapq.heappop(min_heap)", "from typing import List\nimport itertools\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    flattened_grid = [grid[i][j] for i in range(N) for j in range(N)]\n    flattened_grid.sort()\n\n    def valid_path(path):\n        if len(path) != k:\n            return False\n        indexes = list(itertools.product(range(N), range(N)))\n        positions = [indexes[flattened_grid.index(val)] for val in path]\n        for i in range(len(positions) - 1):\n            x1, y1 = positions[i]\n            x2, y2 = positions[i + 1]\n            if abs(x1 - x2) + abs(y1 - y2) != 1:\n                return False\n        return True\n    for candidate in itertools.permutations(flattened_grid, k):\n        candidate_list = list(candidate)\n        if valid_path(candidate_list):\n            return candidate_list", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n\n    def neighbors(row, col):\n        for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n            nr, nc = (row + dr, col + dc)\n            if 0 <= nr < N and 0 <= nc < N:\n                yield (nr, nc)\n\n    def dfs(path, row, col):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for nr, nc in neighbors(row, col):\n            dfs(path + [grid[nr][nc]], nr, nc)\n    start_cells = [(r, c) for r, c in product(range(N), repeat=2)]\n    paths = []\n    for r, c in start_cells:\n        dfs([grid[r][c]], r, c)\n    return min(paths)", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], [(i, j)]))\n    while pq:\n        _, path = heapq.heappop(pq)\n        if len(path) == k:\n            return [grid[i][j] for i, j in path]\n        x, y = path[-1]\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [(nx, ny)]\n                new_values = [grid[i][j] for i, j in new_path]\n                heapq.heappush(pq, (new_values, new_path))", "from typing import List, Tuple\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n\n    def neighbors(x, y):\n        for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < n and 0 <= ny < n:\n                yield (nx, ny)\n    pq = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(pq, (grid[i][j], [(i, j)]))\n    while pq:\n        value, path = heapq.heappop(pq)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        last_x, last_y = path[-1]\n        for nx, ny in neighbors(last_x, last_y):\n            new_path = path + [(nx, ny)]\n            heapq.heappush(pq, (tuple((grid[x][y] for x, y in new_path)), new_path))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def in_bounds(x, y):\n        return 0 <= x < N and 0 <= y < N\n    min_heap = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(min_heap, (grid[i][j], [grid[i][j]], i, j))\n    while min_heap:\n        value, path, x, y = heapq.heappop(min_heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if in_bounds(nx, ny):\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(min_heap, (new_path, new_path, nx, ny))", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    import heapq\n\n    def neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                yield (nx, ny)\n    n = len(grid)\n    pq = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(pq, (grid[i][j], i, j, [grid[i][j]]))\n    while pq:\n        value, x, y, path = heapq.heappop(pq)\n        if len(path) == k:\n            return path\n        for nx, ny in neighbors(x, y):\n            heapq.heappush(pq, (grid[nx][ny], nx, ny, path + [grid[nx][ny]]))", "from typing import List\nimport itertools\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    n = len(grid)\n    paths = []\n    for i, j in itertools.product(range(n), repeat=2):\n        dfs(i, j, [grid[i][j]])\n    return min(paths)", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(path, x, y):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid):\n                dfs(path + [grid[nx][ny]], nx, ny)\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    paths = []\n    for i, j in product(range(N), range(N)):\n        dfs([grid[i][j]], i, j)\n    return min(paths)"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.4, "original_passk": 0.0}}
{"task_id": "HumanEval/130", "requirement": "from typing import List\n\ndef tri(n: int) -> List[float]:\n    \"\"\"Everyone knows the Fibonacci sequence, studied deeply by mathematicians over the last few centuries. \n    However, the Tribonacci sequence is less known. It is defined by the following rules:\n    \n    - tri(0) = 1\n    - tri(1) = 3\n    - For even n > 1, tri(n) = 1 + n / 2.\n    - For odd n > 1, tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), where tri(n + 1) = 1 + (n + 1) / 2 if n + 1 exceeds the sequence length.\n    \n    You are given a non-negative integer n, and you must return a list of the first n + 1 numbers of the Tribonacci sequence.\n    \n    Examples:\n    tri(2) = [1, 3, 2]\n    tri(4) = [1, 3, 2, 8, 3]\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = []\n    for i in range(n + 1):\n        if i == 0:\n            sequence.append(1)\n        elif i == 1:\n            sequence.append(3)\n        elif i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > n:\n                next_val = 1 + (i + 1) / 2\n            else:\n                next_val = sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_val)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def get_tri_value(i: int, cache: List[float]) -> float:\n        if i <= n and cache[i] is not None:\n            return cache[i]\n        if i == 0:\n            return 1\n        elif i == 1:\n            return 3\n        elif i > 1 and i % 2 == 0:\n            return 1 + i / 2\n        else:\n            tri_n1 = 1 + (i + 1) / 2 if i + 1 > n else get_tri_value(i + 1, cache)\n            tri_n2 = get_tri_value(i - 1, cache)\n            tri_n3 = get_tri_value(i - 2, cache)\n            return tri_n1 + tri_n2 + tri_n3\n    cache = [None] * (n + 1)\n    result = []\n    for i in range(n + 1):\n        value = get_tri_value(i, cache)\n        cache[i] = value\n        result.append(value)\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    result = [0] * (n + 1)\n    for i in range(n + 1):\n        if i == 0:\n            result[i] = 1\n        elif i == 1:\n            result[i] = 3\n        elif i % 2 == 0:\n            result[i] = 1 + i / 2\n        else:\n            next_val = 1 + (i + 1) / 2 if i + 1 > n else result[i + 1]\n            result[i] = result[i - 1] + result[i - 2] + next_val\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_val = 1 + (i + 1) / 2\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_val)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    tribonacci = []\n    for i in range(n + 1):\n        if i == 0:\n            tribonacci.append(1)\n        elif i == 1:\n            tribonacci.append(3)\n        elif i % 2 == 0:\n            tribonacci.append(1 + i / 2)\n        else:\n            if i + 1 <= n:\n                tri_next = 1 + (i + 1) / 2\n            else:\n                tri_next = 1 + (i + 1) / 2\n            tribonacci.append(tribonacci[i - 1] + tribonacci[i - 2] + tri_next)\n    return tribonacci", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = []\n    for i in range(n + 1):\n        if i == 0:\n            sequence.append(1)\n        elif i == 1:\n            sequence.append(3)\n        elif i % 2 == 0:\n            sequence.append(1 + i / 2)\n        elif i + 1 < len(sequence):\n            sequence.append(sequence[i - 1] + sequence[i - 2] + sequence[i + 1])\n        else:\n            tri_next = 1 + (i + 1) / 2\n            sequence.append(sequence[i - 1] + sequence[i - 2] + tri_next)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = []\n    for i in range(n + 1):\n        if i == 0:\n            sequence.append(1)\n        elif i == 1:\n            sequence.append(3)\n        elif i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = 1 + (i + 1) / 2 if i + 1 > n else sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > n:\n                next_value = 1 + (i + 1) / 2\n            else:\n                next_value = sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_value)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    result = []\n    for i in range(n + 1):\n        if i == 0:\n            result.append(1)\n        elif i == 1:\n            result.append(3)\n        elif i % 2 == 0:\n            result.append(1 + i / 2)\n        else:\n            next_term = 1 + (i + 1) / 2 if i + 1 > n else result[i + 1]\n            result.append(result[i - 1] + result[i - 2] + next_term)\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_val = 1 + (i + 1) / 2 if i + 1 > len(sequence) else sequence[i + 1]\n            sequence.append(sequence[i - 1] + sequence[i - 2] + next_val)\n    return sequence"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.4, "original_passk": 0.11111111111111116}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if there exists a valid subsequence of brackets \n    within the string where at least one bracket is nested. A valid subsequence means \n    that for every opening bracket '[' there is a corresponding closing bracket ']', \n    but it does not require the entire string to be a valid bracket sequence.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            if stack:\n                nested_found = True\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                nested_found = True if stack else nested_found\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "from typing import List\n\ndef is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    has_nested = True\n    return has_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_found = True\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    found_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    found_nested = True\n    return found_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    has_nested = True\n    return has_nested"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/134", "requirement": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''", "generated_programs": ["def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt or txt[-1].isspace():\n        return False\n    if txt[-1].isalpha() and (len(txt.split()) == 0 or txt[-1] not in txt.split()[-1]):\n        return True\n    return False", "import string\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt or txt[-1] not in string.ascii_letters:\n        return False\n    return len(txt.split()[-1]) == 1", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt.strip():\n        return False\n    txt = txt.rstrip()\n    return txt[-1].isalpha() and ' ' in txt[:txt.rfind(txt[-1])]", "import string\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if last_char in string.ascii_letters:\n        words = txt.split()\n        return last_char not in words[-1]\n    return False", "import string\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt or txt[-1] not in string.ascii_letters:\n        return False\n    words = txt.split()\n    return len(words) > 0 and txt[-1] == words[-1][-1]", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    if stripped_txt[-1].isalpha():\n        return len(stripped_txt.split()[-1]) == 1\n    return False", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt or txt[-1].isalpha() == False:\n        return False\n    return ' ' in txt and txt.split()[-1] == txt[-1]", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    return txt[-1].isalpha() and (len(txt.split()) == 0 or len(txt.split()[-1]) == 1)", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    last_char = stripped_txt[-1]\n    return last_char.isalpha() and ' ' not in stripped_txt.split()[-1]", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    if txt[-1].isalpha():\n        return txt[-2].isspace() if len(txt) > 1 else True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((abs(int(digit)) for digit in str(abs(x)))), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/147", "requirement": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n    Return the number of unique triples (a[i], a[j], a[k]) in a where i < j < k, \n    and the sum a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example:\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"", "generated_programs": ["from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triples = combinations(a, 3)\n    count = sum((1 for triple in triples if sum(triple) % 3 == 0))\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from itertools import combinations\nfrom typing import List\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triples = combinations(a, 3)\n    count = sum((1 for triple in triples if sum(triple) % 3 == 0))\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triples = combinations(a, 3)\n    count = sum((1 for triple in triples if sum(triple) % 3 == 0))\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triples = combinations(a, 3)\n    count = sum((1 for triple in triples if sum(triple) % 3 == 0))\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from typing import List\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/148", "requirement": "from typing import Tuple\n\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''", "generated_programs": ["from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        return tuple(planets[index1 + 1:index2])\n    else:\n        return tuple(planets[index2 + 1:index1])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1, index2 = (planets.index(planet1), planets.index(planet2))\n    start, end = sorted((index1, index2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start, end = sorted([index1, index2])\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start, end = sorted((idx1, idx2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planet_order = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planet_order or planet2 not in planet_order:\n        return ()\n    index1 = planet_order.index(planet1)\n    index2 = planet_order.index(planet2)\n    start, end = sorted((index1, index2))\n    return tuple(planet_order[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start, end = sorted((index1, index2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        return tuple(planets[index1 + 1:index2])\n    else:\n        return tuple(planets[index2 + 1:index1])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1, index2 = (planets.index(planet1), planets.index(planet2))\n    start, end = (min(index1, index2), max(index1, index2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start, end = sorted((index1, index2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 > index2:\n        index1, index2 = (index2, index1)\n    return tuple(planets[index1 + 1:index2])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/151", "requirement": "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are non-negative and odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    If the input list is empty, return 0.\n    '''", "generated_programs": ["from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 == 1))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 == 1)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and isinstance(x, int) and (x % 2 == 1)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 == 1)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x % 2 != 0 and (x >= 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 == 1)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 == 1)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((n ** 2 for n in lst if isinstance(n, int) and n >= 0 and (n % 2 == 1)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if any substring of the first word of the same length as the second word is a rotation of the second word. This is checked by seeing if any such substring from the first word appears in the second word concatenated with itself.\n    \n    Examples:\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    length_b = len(b)\n    b_concat = b + b\n    for i in range(len(a) - length_b + 1):\n        substring_a = a[i:i + length_b]\n        if substring_a in b_concat:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    for i in range(len(a) - len(b) + 1):\n        substring = a[i:i + len(b)]\n        if substring in b + b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    n = len(b)\n    b_rotated = b + b\n    for i in range(len(a) - n + 1):\n        substring = a[i:i + n]\n        if substring in b_rotated:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    n = len(b)\n    for i in range(len(a) - n + 1):\n        substring = a[i:i + n]\n        if substring in b + b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    length_b = len(b)\n    doubled_b = b + b\n    for i in range(len(a) - length_b + 1):\n        substring = a[i:i + length_b]\n        if substring in doubled_b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    for i in range(len(a) - len(b) + 1):\n        substring = a[i:i + len(b)]\n        if substring in b + b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    length_b = len(b)\n    for i in range(len(a) - length_b + 1):\n        substring = a[i:i + length_b]\n        if substring in b + b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    length_b = len(b)\n    b_doubled = b + b\n    for i in range(len(a) - length_b + 1):\n        if a[i:i + length_b] in b_doubled:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    for i in range(len(a) - len(b) + 1):\n        substring = a[i:i + len(b)]\n        if substring in b + b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    for i in range(len(a) - len(b) + 1):\n        substring = a[i:i + len(b)]\n        if substring in b + b:\n            return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/160", "requirement": "from typing import List\n\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return the even single-digit numbers between a\n    and b, in ascending order. The even single-digit numbers are considered to be 2, 4, 6, and 8.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    even_digits = {2, 4, 6, 8}\n    lower, upper = (min(a, b), max(a, b))\n    return [num for num in range(lower, upper + 1) if num in even_digits]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    return [x for x in (2, 4, 6, 8) if min(a, b) <= x <= max(a, b)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    return [x for x in [2, 4, 6, 8] if min(a, b) <= x <= max(a, b)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    even_single_digit_numbers = [2, 4, 6, 8]\n    lower_bound, upper_bound = (min(a, b), max(a, b))\n    return [num for num in even_single_digit_numbers if lower_bound <= num <= upper_bound]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    even_single_digits = [2, 4, 6, 8]\n    start, end = (min(a, b), max(a, b))\n    return [x for x in even_single_digits if start <= x <= end]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    even_single_digits = [2, 4, 6, 8]\n    start = min(a, b)\n    end = max(a, b)\n    return [num for num in even_single_digits if start <= num <= end]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    even_single_digits = [2, 4, 6, 8]\n    lower_bound = min(a, b)\n    upper_bound = max(a, b)\n    return [num for num in even_single_digits if lower_bound <= num <= upper_bound]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    even_single_digits = [2, 4, 6, 8]\n    lower_bound = min(a, b)\n    upper_bound = max(a, b)\n    return [x for x in even_single_digits if lower_bound <= x <= upper_bound]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    even_single_digit_numbers = {2, 4, 6, 8}\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num in even_single_digit_numbers]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    return [x for x in [2, 4, 6, 8] if min(a, b) <= x <= max(a, b)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that starts with the supplied string by appending the minimum necessary characters to its end.\n    \n    The algorithm works as follows:\n    - Identify the longest suffix of the input string that is a palindrome.\n    - Append to the string the reverse of the prefix that precedes this palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if string == '':\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            prefix_to_add = string[:i][::-1]\n            return string + prefix_to_add\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string), -1, -1):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return ''\n    for i in range(len(string)):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix_to_append = string[:i][::-1]\n            return string + prefix_to_append", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            prefix_to_reverse = string[:i]\n            return string + prefix_to_reverse[::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/32", "requirement": "def find_zero(xs: List[float]) -> float:\n    \"\"\" \n    Finds a zero of the polynomial with coefficients xs using the bisection method.\n    The function assumes that xs has an even number of coefficients and that there is at least one real root within the interval [-100, 100].\n    Only one zero is returned, even if there are multiple.\n    \n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef eval_polynomial(xs: List[float], x: float) -> float:\n    return sum((coef * x ** i for i, coef in enumerate(xs)))\n\ndef find_zero(xs: List[float]) -> float:\n    low, high = (-100, 100)\n    while high - low > 1e-07:\n        mid = (low + high) / 2\n        f_mid = eval_polynomial(xs, mid)\n        if abs(f_mid) < 1e-07:\n            return mid\n        f_low = eval_polynomial(xs, low)\n        if f_low * f_mid < 0:\n            high = mid\n        else:\n            low = mid\n    return (low + high) / 2", "from typing import List\n\ndef evaluate_polynomial(xs: List[float], x: float) -> float:\n    return sum((coef * x ** i for i, coef in enumerate(xs)))\n\ndef find_zero(xs: List[float]) -> float:\n    low, high = (-100, 100)\n    tolerance = 1e-06\n    while high - low > tolerance:\n        mid = (low + high) / 2\n        value = evaluate_polynomial(xs, mid)\n        if abs(value) < tolerance:\n            return mid\n        elif value > 0:\n            high = mid\n        else:\n            low = mid\n    return (low + high) / 2", "from typing import List\n\ndef evaluate_polynomial(coeffs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(coeffs)))\n\ndef find_zero(xs: List[float]) -> float:\n    left, right = (-100, 100)\n    tolerance = 1e-07\n    while right - left > tolerance:\n        mid = (left + right) / 2\n        f_left = evaluate_polynomial(xs, left)\n        f_mid = evaluate_polynomial(xs, mid)\n        if abs(f_mid) < tolerance:\n            return mid\n        elif f_left * f_mid < 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\nimport numpy as np\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float, coefficients: List[float]) -> float:\n        return sum((c * x ** i for i, c in enumerate(coefficients)))\n\n    def bisection_method(coefficients: List[float], a: float, b: float, tol: float=1e-06) -> float:\n        while abs(b - a) > tol:\n            mid = (a + b) / 2\n            f_a = polynomial(a, coefficients)\n            f_mid = polynomial(mid, coefficients)\n            if f_a * f_mid <= 0:\n                b = mid\n            else:\n                a = mid\n        return (a + b) / 2\n    return bisection_method(xs, -100, 100)", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(coefficients, x):\n        return sum((coeff * x ** i for i, coeff in enumerate(coefficients)))\n    left, right = (-100, 100)\n    while right - left > 1e-07:\n        mid = (left + right) / 2\n        mid_val = polynomial(xs, mid)\n        left_val = polynomial(xs, left)\n        if mid_val == 0:\n            return mid\n        elif mid_val * left_val < 0:\n            right = mid\n        else:\n            left = mid\n    return left", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(coefficients, x):\n        return sum((c * x ** i for i, c in enumerate(coefficients)))\n\n    def bisection(coefficients, low, high, tol=1e-06):\n        while high - low > tol:\n            mid = (low + high) / 2\n            f_low = polynomial(coefficients, low)\n            f_mid = polynomial(coefficients, mid)\n            if f_low * f_mid <= 0:\n                high = mid\n            else:\n                low = mid\n        return (low + high) / 2\n    return bisection(xs, -100, 100)", "from typing import List\nimport numpy as np\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((c * x ** i for i, c in enumerate(xs)))\n    left, right = (-100, 100)\n    while right - left > 1e-06:\n        mid = (left + right) / 2\n        if polynomial(left) * polynomial(mid) <= 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef evaluate_polynomial(xs: List[float], x: float) -> float:\n    return sum((coef * x ** i for i, coef in enumerate(xs)))\n\ndef find_zero(xs: List[float]) -> float:\n    left, right = (-100, 100)\n    while right - left > 1e-06:\n        mid = (left + right) / 2\n        f_left = evaluate_polynomial(xs, left)\n        f_mid = evaluate_polynomial(xs, mid)\n        if f_left * f_mid <= 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def evaluate_polynomial(coefficients, x):\n        return sum((c * x ** i for i, c in enumerate(coefficients)))\n\n    def bisection_method(coefficients, a, b, tol=1e-06):\n        while b - a > tol:\n            mid = (a + b) / 2\n            f_a = evaluate_polynomial(coefficients, a)\n            f_mid = evaluate_polynomial(coefficients, mid)\n            if f_a * f_mid <= 0:\n                b = mid\n            else:\n                a = mid\n        return (a + b) / 2\n    return bisection_method(xs, -100, 100)", "from typing import List\nimport numpy as np\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((xs[i] * x ** i for i in range(len(xs))))\n    a, b = (-100.0, 100.0)\n    tolerance = 1e-06\n    while b - a > tolerance:\n        midpoint = (a + b) / 2\n        if polynomial(a) * polynomial(midpoint) <= 0:\n            b = midpoint\n        else:\n            a = midpoint\n    return (a + b) / 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 1:\n        return float(l[mid])\n    else:\n        return (l[mid - 1] + l[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return float(l[n // 2])\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    middle = n // 2\n    if n % 2 == 0:\n        return (l[middle - 1] + l[middle]) / 2\n    else:\n        return l[middle]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    return l[mid]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/59", "requirement": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of the given integer n. \n    It is assumed that n is greater than 1 and is not a prime number itself.\n    The function should iteratively divide n by its smallest factors until the largest prime factor remains.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"", "generated_programs": ["def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while n > 1:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return factor", "import math\n\ndef largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    import math\n\n    def smallest_factor(x):\n        for i in range(2, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                return i\n        return x\n    while True:\n        factor = smallest_factor(n)\n        if factor < n:\n            n //= factor\n        else:\n            return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "def largest_prime_factor(n: int) -> int:\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/60", "requirement": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n. If n is negative, the function returns 0.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    >>> sum_to_n(-5)\n    0\n    \"\"\"", "generated_programs": ["def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum(range(1, n + 1))", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "from typing import List\n\ndef sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return sum(range(1, n + 1))", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    return 0 if n < 0 else n * (n + 1) // 2", "from typing import Any\n\ndef sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return sum(range(1, n + 1))", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    return 0 if n < 0 else n * (n + 1) // 2", "from typing import List\n\ndef sum_to_n(n: int) -> int:\n    return sum(range(1, n + 1)) if n >= 0 else 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/65", "requirement": "def circular_shift(x: int, shift: int) -> str:\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift is greater than the number of digits, return digits reversed.\n    If shift is equal to the number of digits, return the digits unchanged.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"", "generated_programs": ["def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    num_digits = len(digits)\n    if shift > num_digits:\n        return digits[::-1]\n    elif shift == num_digits:\n        return digits\n    else:\n        shift %= num_digits\n        return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    elif shift == n:\n        return digits\n    else:\n        shift = shift % n\n        return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    num_digits = len(digits)\n    if shift > num_digits:\n        return digits[::-1]\n    elif shift == num_digits:\n        return digits\n    else:\n        shift = shift % num_digits\n        return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = list(str(x))\n    n = len(digits)\n    if shift > n:\n        return ''.join(digits[::-1])\n    elif shift == n:\n        return ''.join(digits)\n    else:\n        shift = shift % n\n        return ''.join(digits[-shift:] + digits[:-shift])", "def circular_shift(x: int, shift: int) -> str:\n    x_str = str(x)\n    num_digits = len(x_str)\n    if shift > num_digits:\n        return x_str[::-1]\n    elif shift == num_digits:\n        return x_str\n    else:\n        shifted = x_str[-shift:] + x_str[:-shift]\n        return shifted", "def circular_shift(x: int, shift: int) -> str:\n    digits = list(str(x))\n    n = len(digits)\n    if shift > n:\n        return ''.join(digits[::-1])\n    elif shift == n:\n        return ''.join(digits)\n    else:\n        shift = shift % n\n        return ''.join(digits[-shift:] + digits[:-shift])", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    num_digits = len(digits)\n    if shift > num_digits:\n        return digits[::-1]\n    elif shift == num_digits:\n        return digits\n    else:\n        shift %= num_digits\n        return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    num_digits = len(digits)\n    if shift > num_digits:\n        return digits[::-1]\n    elif shift == num_digits:\n        return digits\n    else:\n        shift %= num_digits\n        return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    str_x = str(x)\n    n = len(str_x)\n    if shift > n:\n        return str_x[::-1]\n    elif shift == n:\n        return str_x\n    else:\n        shift %= n\n        return str_x[-shift:] + str_x[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    elif shift == n:\n        return digits\n    else:\n        shift %= n\n        return digits[-shift:] + digits[:-shift]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    '''\n    Write a function that takes an integer a and returns True \n    if a is a perfect cube of some integer number. \n    For negative inputs, the function should correctly compute the cube root \n    by negating the cube root of the absolute value of the input.\n    The function uses rounding to determine if the cube root is an integer \n    before verifying if cubing that integer results in the original number.\n    Note: you may assume the input is always a valid integer.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(math.pow(abs(a), 1 / 3))\n    if a < 0:\n        cube_root = -cube_root\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3)) if a >= 0 else -round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    import math\n    if a < 0:\n        cube_root = -round(math.pow(abs(a), 1 / 3))\n    else:\n        cube_root = round(math.pow(a, 1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(pow(abs(a), 1 / 3))\n    if a < 0:\n        cube_root = -cube_root\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3)) if a >= 0 else -round((-a) ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3)) if a >= 0 else -round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(pow(abs(a), 1 / 3))\n    if a < 0:\n        cube_root = -cube_root\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3)) if a >= 0 else round(-(-a) ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3)) if a >= 0 else -round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1. Numbers that both start and end\n    with 1 should be counted only once.\n    \n    Examples:\n    >>> starts_one_ends(1)\n    1\n    >>> starts_one_ends(2)\n    18\n    >>> starts_one_ends(3)\n    180\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 9 * 10 ** (n - 1)\n    both_start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 10 ** (n - 1)\n    starts_and_ends_with_1 = 1\n    return starts_with_1 + ends_with_1 - starts_and_ends_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_start_with_one = 10 ** (n - 1)\n    total_end_with_one = 10 ** (n - 1)\n    overlap_start_and_end = 10 ** (n - 2)\n    return total_start_with_one + total_end_with_one - overlap_start_and_end", "def starts_one_ends(n: int) -> int:\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 10 ** (n - 2) if n > 1 else 1\n    return start_with_1 + end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_numbers = 9 * 10 ** (n - 1)\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    both_start_end_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - both_start_end_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 1 * 10 ** (n - 2)\n    return start_with_1 + end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_count = 2 * 9 ** (n - 1) - 9 ** (n - 2)\n    return total_count", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1) - 1\n    both_start_end_1 = 1\n    return start_with_1 + end_with_1 - both_start_end_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    double_counted = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - double_counted"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    Each letter in the alphabet should be shifted forward by four positions.\n    Uppercase and lowercase letters should be handled appropriately, maintaining their case.\n    Non-alphabetic characters should remain unchanged.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    encrypt('HelloWorld') returns 'LippsAsvph'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n\n    def shift_char(c: str, shift: int) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((shift_char(c, 4) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(char: str, shift: int) -> str:\n        if 'a' <= char <= 'z':\n            return chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            return chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        return char\n    return ''.join((shift_char(char, 4) for char in s))", "import string\n\ndef encrypt(s: str) -> str:\n\n    def shift_char(c: str, shift: int) -> str:\n        if c.isupper():\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        elif c.islower():\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        else:\n            return c\n    shift = 4\n    return ''.join((shift_char(c, shift) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_letter(c: str, shift: int) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((shift_letter(c, 4) for c in s))", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        elif 'A' <= char <= 'Z':\n            encrypted.append(chr((ord(char) - ord('A') + 4) % 26 + ord('A')))\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n\n    def rotate_letter(c: str, shift: int) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        return c\n    return ''.join((rotate_letter(c, 4) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str, shift: int) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((shift_char(char, 4) for char in s))", "def encrypt(s: str) -> str:\n\n    def shift_letter(char: str, offset: int) -> str:\n        if 'a' <= char <= 'z':\n            return chr((ord(char) - ord('a') + offset) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            return chr((ord(char) - ord('A') + offset) % 26 + ord('A'))\n        return char\n    return ''.join((shift_letter(char, 4) for char in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str, shift: int) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        return c\n    return ''.join((shift_char(c, 4) for c in s))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I \" (note the space).\n    Sentences are delimited by '.', '?' or '!', and consecutive delimiters should be treated\n    as a single delimiter. Leading and trailing spaces around sentences should be ignored.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"", "generated_programs": ["import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S.strip())\n    sentences = [sentence.strip() for sentence in sentences if sentence.strip()]\n    return sum((1 for sentence in sentences if sentence.startswith('I ')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S.strip())\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S)\n    sentences = [sentence.strip() for sentence in sentences if sentence.strip()]\n    return sum((sentence.startswith('I ') for sentence in sentences))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    return sum((sentence.strip().startswith('I ') for sentence in sentences if sentence.strip()))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S.strip())\n    count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S.strip())\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S.strip())\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S.strip())\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/92", "requirement": "def any_int(x: int, y: int, z: int) -> bool:\n    '''\n    Create a function that takes 3 numbers as input.\n    The function should first check if all inputs are integers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false if any of the inputs are not integers or if no number is equal to the sum of the other two.\n    \n    Examples\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n    '''", "generated_programs": ["from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if all((isinstance(i, int) for i in (x, y, z))):\n        return x == y + z or y == x + z or z == x + y\n    return False", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if all((isinstance(i, int) for i in (x, y, z))):\n        return x == y + z or y == x + z or z == x + y\n    return False", "from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if all((isinstance(num, int) for num in (x, y, z))):\n        return x == y + z or y == x + z or z == x + y\n    return False", "from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if not all((isinstance(i, int) for i in [x, y, z])):\n        return False\n    return x == y + z or y == x + z or z == x + y", "from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if not all((isinstance(i, int) for i in [x, y, z])):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        return x == y + z or y == x + z or z == x + y\n    return False", "from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        return x == y + z or y == x + z or z == x + y\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message and encodes it by swapping the case of all letters \n    and then replacing each vowel with the letter that appears two places ahead of it in the English alphabet, \n    considering only lowercase vowels for the initial shift. Non-alphabetic characters remain unchanged.\n    \n    Specifically, after swapping the case of all letters:\n    - If a character is a lowercase vowel ('a', 'e', 'i', 'o', 'u'), it is shifted two places ahead in the alphabet and remains lowercase.\n    - If a character is an uppercase vowel ('A', 'E', 'I', 'O', 'U'), it is first converted to lowercase, shifted two places ahead, and then converted back to uppercase.\n    - All other alphabetic characters remain in their swapped case without modification.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n\n    def shift_vowel(ch: str) -> str:\n        vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n        return vowels.get(ch, ch)\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            swapped_char = char.lower() if char.isupper() else char.upper()\n            if swapped_char in 'aeiou':\n                shifted = shift_vowel(swapped_char)\n                if char.isupper():\n                    encoded_message += shifted.upper()\n                else:\n                    encoded_message += shifted\n            else:\n                encoded_message += swapped_char\n        else:\n            encoded_message += char\n    return encoded_message", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        shift = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n        is_upper = vowel.isupper()\n        vowel = vowel.lower()\n        shifted = shift.get(vowel, vowel)\n        return shifted.upper() if is_upper else shifted\n    result = []\n    for char in message:\n        if char.isalpha():\n            swapped_case = char.swapcase()\n            if swapped_case.lower() in 'aeiou':\n                result.append(shift_vowel(swapped_case))\n            else:\n                result.append(swapped_case)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n        return vowels[vowel]\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            swapped = char.lower() if char.isupper() else char.upper()\n            if swapped in 'aeiou':\n                if char.isupper():\n                    encoded_message.append(shift_vowel(swapped).upper())\n                else:\n                    encoded_message.append(shift_vowel(swapped))\n            else:\n                encoded_message.append(swapped)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        vowels_shift_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n        return vowels_shift_map[vowel]\n\n    def transform_character(ch: str) -> str:\n        if ch.isalpha():\n            swapped_case = ch.swapcase()\n            if swapped_case in 'aeiou':\n                return shift_vowel(swapped_case)\n            elif swapped_case in 'AEIOU':\n                shifted = shift_vowel(swapped_case.lower())\n                return shifted.upper()\n            else:\n                return swapped_case\n        else:\n            return ch\n    return ''.join((transform_character(ch) for ch in message))", "def encode(message: str) -> str:\n    vowels_mapping = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n\n    def process_char(c):\n        if c.islower():\n            if c in vowels_mapping:\n                return vowels_mapping[c]\n            else:\n                return c.swapcase()\n        elif c.isupper():\n            lower_c = c.lower()\n            if lower_c in vowels_mapping:\n                return vowels_mapping[lower_c].upper()\n            else:\n                return c.swapcase()\n        else:\n            return c\n    return ''.join((process_char(c) for c in message))", "def encode(message: str) -> str:\n\n    def swap_case_and_modify_vowel(char: str) -> str:\n        if char.isalpha():\n            swapped = char.lower() if char.isupper() else char.upper()\n            if swapped in 'aeiou':\n                shifted_vowel = chr((ord(swapped) - 97 + 2) % 26 + 97)\n                return shifted_vowel.upper() if char.isupper() else shifted_vowel\n            return swapped\n        return char\n    return ''.join((swap_case_and_modify_vowel(c) for c in message))", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        vowel_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return vowel_map[vowel]\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            swapped_case = char.swapcase()\n            if swapped_case.lower() in 'aeiou':\n                encoded_message += shift_vowel(swapped_case)\n            else:\n                encoded_message += swapped_case\n        else:\n            encoded_message += char\n    return encoded_message", "def encode(message: str) -> str:\n\n    def shift_vowel(ch: str) -> str:\n        vowels = 'aeiou'\n        if ch.lower() in vowels:\n            new_vowel = vowels[(vowels.index(ch.lower()) + 2) % len(vowels)]\n            return new_vowel.upper() if ch.isupper() else new_vowel\n        return ch\n    swapped_case_message = ''.join((ch.swapcase() for ch in message))\n    encoded_message = ''.join((shift_vowel(ch) if ch.lower() in 'aeiou' else ch for ch in swapped_case_message))\n    return encoded_message", "def encode(message: str) -> str:\n\n    def shift_vowel(ch: str) -> str:\n        if ch in 'aeiou':\n            return chr((ord(ch) - ord('a') + 2) % 26 + ord('a'))\n        elif ch in 'AEIOU':\n            shifted = chr((ord(ch.lower()) - ord('a') + 2) % 26 + ord('a'))\n            return shifted.upper()\n        return ch\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            swapped_case = char.lower() if char.isupper() else char.upper()\n            encoded_message += shift_vowel(swapped_case)\n        else:\n            encoded_message += char\n    return encoded_message", "def encode(message: str) -> str:\n\n    def shift_vowel(ch):\n        vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n        if ch in vowels:\n            return vowels[ch]\n        return ch\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            if char.islower():\n                swapped = char.upper()\n                if swapped.lower() in 'aeiou':\n                    encoded_message.append(shift_vowel(swapped.lower()))\n                else:\n                    encoded_message.append(swapped)\n            elif char.isupper():\n                swapped = char.lower()\n                if swapped in 'aeiou':\n                    encoded_message.append(shift_vowel(swapped).upper())\n                else:\n                    encoded_message.append(swapped.upper())\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.4, "original_passk": 0.4}}
{"task_id": "HumanEval/94", "requirement": "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n    If there are no prime numbers in the list, the function should raise a ValueError.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    prime_numbers = [num for num in lst if is_prime(num)]\n    if not prime_numbers:\n        raise ValueError('No prime numbers found in the list')\n    largest_prime = max(prime_numbers)\n    return sum((int(ch) for ch in str(largest_prime)))", "from typing import List\nimport math\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list.')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list.')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers found in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    prime_numbers = [num for num in lst if is_prime(num)]\n    if not prime_numbers:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(prime_numbers)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\nimport math\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        for i in range(5, int(math.sqrt(n)) + 1, 6):\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list.')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/95", "requirement": "from typing import Dict\n\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"", "generated_programs": ["from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if all((isinstance(key, str) and key.islower() for key in keys)):\n        return True\n    elif all((isinstance(key, str) and key.isupper() for key in keys)):\n        return True\n    return False", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(key, str) and key.islower() for key in keys)):\n        return True\n    elif all((isinstance(key, str) and key.isupper() for key in keys)):\n        return True\n    return False", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(k, str) and k.islower() for k in keys)):\n        return True\n    elif all((isinstance(k, str) and k.isupper() for k in keys)):\n        return True\n    else:\n        return False", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(key, str) and key.islower() for key in keys)):\n        return True\n    if all((isinstance(key, str) and key.isupper() for key in keys)):\n        return True\n    return False", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    key_strings = [key for key in dict.keys() if isinstance(key, str)]\n    if len(key_strings) != len(dict.keys()):\n        return False\n    all_lower = all((key.islower() for key in key_strings))\n    all_upper = all((key.isupper() for key in key_strings))\n    return all_lower or all_upper", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    all_lower_case = all((isinstance(k, str) and k.islower() for k in keys))\n    all_upper_case = all((isinstance(k, str) and k.isupper() for k in keys))\n    return all_lower_case or all_upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    str_keys = [key for key in dict.keys() if isinstance(key, str)]\n    if len(str_keys) != len(dict.keys()):\n        return False\n    if all((key.islower() for key in str_keys)) or all((key.isupper() for key in str_keys)):\n        return True\n    return False", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    string_keys = [key for key in keys if isinstance(key, str)]\n    if len(string_keys) != len(keys):\n        return False\n    all_lower = all((key.islower() for key in string_keys))\n    all_upper = all((key.isupper() for key in string_keys))\n    return all_lower or all_upper", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    lower_case_keys = all((isinstance(key, str) and key.islower() for key in dict.keys()))\n    upper_case_keys = all((isinstance(key, str) and key.isupper() for key in dict.keys()))\n    return lower_case_keys or upper_case_keys", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    key_strings = [key for key in dict.keys() if isinstance(key, str)]\n    if len(key_strings) != len(dict.keys()):\n        return False\n    all_lower = all((key.islower() for key in key_strings))\n    all_upper = all((key.isupper() for key in key_strings))\n    return all_lower or all_upper"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has exactly n stones.\n    Each subsequent level has:\n        - the next odd number of stones if n is odd.\n        - the next even number of stones if n is even.\n    Return the number of stones in each level in a list, where the element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stone = n\n    increment = 1 if n % 2 == 1 else 2\n    for _ in range(n):\n        pile.append(current_stone)\n        current_stone += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    result = []\n    for i in range(n):\n        result.append(n + i * 2)\n    return result", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    levels = []\n    current_stones = n\n    for i in range(n):\n        levels.append(current_stones)\n        if n % 2 == 0:\n            current_stones += 2\n        else:\n            current_stones += 2\n    return levels", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    result = []\n    current = n\n    step = 2 if n % 2 == 0 else 2\n    for _ in range(n):\n        result.append(current)\n        current += step\n    return result", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    result = []\n    stones = n\n    for _ in range(n):\n        result.append(stones)\n        stones += 2\n    return result", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    while len(pile) < n:\n        pile.append(current)\n        current += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    step = 2 if n % 2 == 0 else 2\n    for _ in range(n):\n        pile.append(current)\n        current += step\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    current = n\n    while len(pile) < n:\n        if n % 2 == 0:\n            current += 2\n        else:\n            current += 2\n        pile.append(current)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    while len(pile) < n:\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    current_stones = n\n    increment = 2 if n % 2 == 0 else 2\n    for _ in range(1, n):\n        current_stones += increment\n        pile.append(current_stones)\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements whose sum of digits (considering the sign of the entire number) is greater than 0.\n    If a number is negative, the sum of its digits should be negative as well:\n    e.g., -123 has a sum of digits -6.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(num: int) -> int:\n        sign = -1 if num < 0 else 1\n        return sign * sum((int(digit) for digit in str(abs(num))))\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        abs_sum = sum((int(d) for d in str(abs(n))))\n        return abs_sum if n > 0 else -abs_sum\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(abs(num))\n        digit_sum = sum((int(digit) for digit in num_str))\n        return digit_sum if num >= 0 else -digit_sum\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(num: int) -> int:\n        sign = 1 if num >= 0 else -1\n        num = abs(num)\n        return sign * sum((int(digit) for digit in str(num)))\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        is_negative = num < 0\n        digits = [int(d) for d in str(abs(num))]\n        digit_sum = sum(digits)\n        return -digit_sum if is_negative else digit_sum\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        is_negative = num < 0\n        num = abs(num)\n        digit_sum = sum((int(digit) for digit in str(num)))\n        return -digit_sum if is_negative else digit_sum\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        sign = -1 if num < 0 else 1\n        num = abs(num)\n        return sign * sum((int(d) for d in str(num)))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        sign = -1 if num < 0 else 1\n        return sign * sum((int(digit) for digit in str(abs(num))))\n    return sum((1 for x in arr if sum_of_digits(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        sign = -1 if num < 0 else 1\n        return sign * sum((int(digit) for digit in str(abs(num))))\n    return sum((1 for n in arr if sum_of_digits(n) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    return sum((1 for num in arr if sum((int(digit) if num >= 0 else -int(digit) for digit in str(abs(num)))) > 0))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.5}}
{"task_id": "HumanEval/109", "requirement": "def move_one_ball(arr: List[int]) -> bool:\n    \"\"\"Determine if it is possible to sort the array in non-decreasing order by performing\n    any number of right shift operations. A right shift operation moves each element of the\n    array one position to the right, with the last element moving to the first position.\n    \n    The array can be sorted using right shifts if there is at most one place where a larger number\n    is followed by a smaller number (considering the array circularly). If the array meets this\n    condition, return True; otherwise, return False. An empty array is considered sorted, so return True.\n\n    Note: The array is guaranteed to contain unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2]) ==> True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2]) ==> False\n    Explanation: It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n    return count <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n    return count <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count_breaks = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count_breaks += 1\n    return count_breaks <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n            if count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n    return count <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n            if count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n            if count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    n = len(arr)\n    if n == 0:\n        return True\n    breaks = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            breaks += 1\n        if breaks > 1:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/110", "requirement": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform exchanges of elements\n    between them to make lst1 a list of only even numbers.\n    Multiple exchanges are allowed, and the goal is to ensure all elements of lst1 are even.\n    If it is possible to exchange elements between lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    lst2_even = [x for x in lst2 if x % 2 == 0]\n    lst1_odd_count = sum((1 for x in lst1 if x % 2 != 0))\n    return 'YES' if len(lst2_even) >= lst1_odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_lst1 = [num for num in lst1 if num % 2 != 0]\n    even_lst2 = [num for num in lst2 if num % 2 == 0]\n    if len(odd_lst1) <= len(even_lst2):\n        return 'YES'\n    return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    lst2_even = [num for num in lst2 if num % 2 == 0]\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            if not lst2_even:\n                return 'NO'\n            lst1[i] = lst2_even.pop(0)\n    return 'YES' if all((num % 2 == 0 for num in lst1)) else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    lst2_odd = [x for x in lst2 if x % 2 != 0]\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            if lst2_odd:\n                lst1[i] = lst2_odd.pop()\n            else:\n                return 'NO'\n    return 'YES'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            found = False\n            for j in range(len(lst2)):\n                if lst2[j] % 2 == 0:\n                    lst1[i], lst2[j] = (lst2[j], lst1[i])\n                    found = True\n                    break\n            if not found:\n                return 'NO'\n    return 'YES'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = [num for num in lst1 if num % 2 != 0]\n    even_in_lst2 = [num for num in lst2 if num % 2 == 0]\n    if len(odd_in_lst1) <= len(even_in_lst2):\n        return 'YES'\n    return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n\n    def is_even(n: int) -> bool:\n        return n % 2 == 0\n    lst1_odd = [x for x in lst1 if not is_even(x)]\n    lst2_even = [x for x in lst2 if is_even(x)]\n    if len(lst1_odd) <= len(lst2_even):\n        return 'YES'\n    return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_elements_lst2 = [x for x in lst2 if x % 2 == 0]\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            if odd_elements_lst2:\n                lst1[i] = odd_elements_lst2.pop()\n            else:\n                return 'NO'\n    return 'YES'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n\n    def is_even(n: int) -> bool:\n        return n % 2 == 0\n    odd_lst1 = [x for x in lst1 if not is_even(x)]\n    even_lst2 = [x for x in lst2 if is_even(x)]\n    if len(odd_lst1) <= len(even_lst2):\n        return 'YES'\n    return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_lst1 = [x for x in lst1 if x % 2 != 0]\n    even_lst2 = [x for x in lst2 if x % 2 == 0]\n    if len(odd_lst1) <= len(even_lst2):\n        return 'YES'\n    else:\n        return 'NO'"], "result": {"repaired_passk": 0.09999999999999998, "cross_model_passk": 0.9, "original_passk": 0.9}}
{"task_id": "HumanEval/115", "requirement": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the total number of times you need to lower the buckets, considering each well individually.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n\n    def count_bucket_usage(row: List[int], capacity: int) -> int:\n        water_units = sum(row)\n        return (water_units + capacity - 1) // capacity\n    return sum((count_bucket_usage(row, capacity) for row in grid))", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for row in grid:\n        total_units = sum(row)\n        total_buckets += -(-total_units // capacity)\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_operations = 0\n    for row in grid:\n        water_units = sum(row)\n        total_operations += (water_units + capacity - 1) // capacity\n    return total_operations", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_bucket_uses = 0\n    for row in grid:\n        row_water_units = sum(row)\n        total_bucket_uses += (row_water_units + capacity - 1) // capacity\n    return total_bucket_uses", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_lowerings = 0\n    for well in grid:\n        water_units = sum(well)\n        total_lowerings += -(-water_units // capacity)\n    return total_lowerings", "from typing import List\nfrom math import ceil\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum((ceil(sum(well) / capacity) for well in grid))", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for well in grid:\n        water_units = sum(well)\n        total_buckets += -(-water_units // capacity)\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for row in grid:\n        water_units = sum(row)\n        total_buckets += -(-water_units // capacity)\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_count = 0\n    for row in grid:\n        water_count = sum(row)\n        total_count += (water_count + capacity - 1) // capacity\n    return total_count", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_operations = 0\n    for row in grid:\n        water_units = sum(row)\n        total_operations += (water_units + capacity - 1) // capacity\n    return total_operations"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of integers. Non-negative integers should be sorted according to the number of ones in their binary representation in ascending order. For non-negative integers with the same number of ones, sort them based on their decimal value. Negative integers should be sorted in ascending order without considering their binary representation.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    negative = sorted([x for x in arr if x < 0])\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    negatives = sorted([x for x in arr if x < 0])\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (x < 0, bin(x).count('1') if x >= 0 else 0, x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1') if x >= 0 else float('inf')\n    non_negative_sorted = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    negative_sorted = sorted([x for x in arr if x < 0])\n    return negative_sorted + non_negative_sorted", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        return bin(x).count('1')\n    non_negative_sorted = sorted([x for x in arr if x >= 0], key=lambda x: (count_ones(x), x))\n    negative_sorted = sorted([x for x in arr if x < 0])\n    return negative_sorted + non_negative_sorted", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def ones_in_binary(x: int) -> int:\n        return bin(x).count('1')\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (ones_in_binary(x), x))\n    negative = sorted((x for x in arr if x < 0))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x) if x >= 0 else (float('inf'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(n).count('1')\n    non_negative_numbers = [x for x in arr if x >= 0]\n    negative_numbers = [x for x in arr if x < 0]\n    sorted_non_negative = sorted(non_negative_numbers, key=lambda x: (count_ones(x), x))\n    sorted_negative = sorted(negative_numbers)\n    return sorted_negative + sorted_non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x)) + sorted([x for x in arr if x < 0])", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def key_func(x):\n        if x >= 0:\n            return (bin(x).count('1'), x)\n        return (float('-inf'), x)\n    return sorted(arr, key=key_func)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The date should be in the format 'mm-dd-yyyy' with leading zeros for single-digit months and days (e.g., '01-01-2000').\n    3. The number of days is not less than 1 or higher than 31 days for months 1, 3, 5, 7, 8, 10, 12. The number of days is not less than 1 or higher than 30 days for months 4, 6, 9, 11. The number of days is not less than 1 or higher than 29 for the month 2 in a leap year, and 28 in a non-leap year.\n    4. The months should not be less than 1 or higher than 12.\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        parts = date.split('-')\n        if len(parts) != 3:\n            return False\n        month, day, year = parts\n        if len(month) != 2 or len(day) != 2 or len(year) != 4:\n            return False\n        month = int(month)\n        day = int(day)\n        year = int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day < 1 or day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day < 1 or day > 30:\n                return False\n        elif month == 2:\n            is_leap = year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n            if is_leap and (day < 1 or day > 29) or (not is_leap and (day < 1 or day > 28)):\n                return False\n        datetime.strptime(date, '%m-%d-%Y')\n        return True\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        datetime.strptime(date, '%m-%d-%Y')\n    except ValueError:\n        return False\n    parts = date.split('-')\n    month = int(parts[0])\n    day = int(parts[1])\n    year = int(parts[2])\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        is_leap_year = year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n        if is_leap_year:\n            if day < 1 or day > 29:\n                return False\n        elif day < 1 or day > 28:\n            return False\n    return True", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        datetime_object = datetime.strptime(date, '%m-%d-%Y')\n        month, day, year = map(int, date.split('-'))\n        if not 1 <= month <= 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            return 1 <= day <= 31\n        elif month in {4, 6, 9, 11}:\n            return 1 <= day <= 30\n        elif month == 2:\n            is_leap = year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n            return 1 <= day <= (29 if is_leap else 28)\n    except ValueError:\n        return False\n    return False", "import re\n\ndef valid_date(date: str) -> bool:\n    pattern = '^(\\\\d{2})-(\\\\d{2})-(\\\\d{4})$'\n    match = re.match(pattern, date)\n    if not match:\n        return False\n    month, day, year = map(int, match.groups())\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        is_leap_year = year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n        max_days = 29 if is_leap_year else 28\n        if day < 1 or day > max_days:\n            return False\n    return True", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        if '-' not in date or len(date.split('-')) != 3:\n            return False\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if not 1 <= day <= 31:\n            return False\n        if month in {4, 6, 9, 11} and day > 30:\n            return False\n        if month == 2:\n            if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n                if day > 29:\n                    return False\n            elif day > 28:\n                return False\n        datetime(year, month, day)\n        return True\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        if len(date) != 10 or date[2] != '-' or date[5] != '-':\n            return False\n        month, day, year = map(int, date.split('-'))\n        if not 1 <= month <= 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12} and (not 1 <= day <= 31):\n            return False\n        if month in {4, 6, 9, 11} and (not 1 <= day <= 30):\n            return False\n        if month == 2:\n            if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) and (not 1 <= day <= 29):\n                return False\n            elif not (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) and (not 1 <= day <= 28):\n                return False\n        datetime.strptime(date, '%m-%d-%Y')\n        return True\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day > 30:\n            return False\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            if day > 29:\n                return False\n        elif day > 28:\n            return False\n    try:\n        datetime(year, month, day)\n        return True\n    except ValueError:\n        return False", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    match = re.match('^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\\d{4}$', date)\n    if not match:\n        return False\n    month, day, year = map(int, date.split('-'))\n    month_days = {1: 31, 3: 31, 5: 31, 7: 31, 8: 31, 10: 31, 12: 31, 4: 30, 6: 30, 9: 30, 11: 30, 2: 29 if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) else 28}\n    if day < 1 or day > month_days.get(month, 0):\n        return False\n    return True", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not isinstance(date, str) or len(date) != 10:\n        return False\n    if not date[2] == '-' or not date[5] == '-':\n        return False\n    try:\n        datetime_format = datetime.strptime(date, '%m-%d-%Y')\n        month = datetime_format.month\n        day = datetime_format.day\n        year = datetime_format.year\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            return 1 <= day <= 31\n        if month in {4, 6, 9, 11}:\n            return 1 <= day <= 30\n        if month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                return 1 <= day <= 29\n            else:\n                return 1 <= day <= 28\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        datetime_object = datetime.strptime(date, '%m-%d-%Y')\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if day < 1 or (month == 2 and (is_leap_year(year) and day > 29 or (not is_leap_year(year) and day > 28))) or (month in [4, 6, 9, 11] and day > 30) or (month in [1, 3, 5, 7, 8, 10, 12] and day > 31):\n            return False\n        return True\n    except ValueError:\n        return False\n\ndef is_leap_year(year: int) -> bool:\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/125", "requirement": "from typing import List\nfrom typing import Union\n\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exist in the text you\n    should split on commas ','. If no commas exist, you should return the number of lowercase letters with even order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25.\n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        even_order_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return even_order_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        alphabet_order = {chr(ord('a') + i): i % 2 == 0 for i in range(26)}\n        return sum((1 for char in txt if char in alphabet_order and alphabet_order[char]))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for ch in txt if ch.islower() and (ord(ch) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        even_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return even_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        even_order_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return even_order_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        even_order_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return even_order_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        lowercase_letters = [char for char in txt if char.islower()]\n        even_order_count = sum((1 for char in lowercase_letters if (ord(char) - ord('a')) % 2 == 0))\n        return even_order_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        even_order_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return even_order_count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "HumanEval/127", "requirement": "from typing import Tuple\n\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start <= intersect_end:\n        length = intersect_end - intersect_start + 1\n        return 'YES' if is_prime(length) else 'NO'\n    return 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start <= intersection_end:\n        length = intersection_end - intersection_start + 1\n        return 'YES' if is_prime(length) else 'NO'\n    else:\n        return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start <= intersection_end:\n        length = intersection_end - intersection_start + 1\n        return 'YES' if is_prime(length) else 'NO'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    length = end - start + 1\n    if length > 0 and is_prime(length):\n        return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start <= intersection_end:\n        length = intersection_end - intersection_start + 1\n        if is_prime(length):\n            return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start <= intersection_end:\n        length = intersection_end - intersection_start + 1\n        if is_prime(length):\n            return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start <= intersection_end:\n        length = intersection_end - intersection_start + 1\n        return 'YES' if is_prime(length) else 'NO'\n    else:\n        return 'NO'"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a unique value from the range [1, N * N].\n    \n    The task is to find the lexicographically smallest path of length k in the grid. \n    You can start from any cell and move to any of its neighboring cells (sharing an edge).\n    A path of length k means visiting exactly k cells, which can include revisiting cells.\n    You cannot move off the grid.\n    \n    A path A is considered lexicographically smaller than a path B if the sequence of values\n    in path A is lexicographically smaller than the sequence of values in path B when compared\n    element-wise.\n    \n    It is guaranteed that there is a unique lexicographically smallest path.\n    \n    Return the sequence of values on the cells that form the lexicographically smallest path.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nfrom itertools import product\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    min_heap = []\n    for row, col in product(range(n), repeat=2):\n        heapq.heappush(min_heap, (grid[row][col], [(row, col)], [grid[row][col]]))\n    while min_heap:\n        _, path, values = heapq.heappop(min_heap)\n        if len(values) == k:\n            return values\n        x, y = path[-1]\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [(nx, ny)]\n                new_values = values + [grid[nx][ny]]\n                heapq.heappush(min_heap, (new_values, new_path, new_values))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def neighbors(x, y):\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                yield (nx, ny)\n    heap = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(heap, (str(grid[i][j]), [(i, j)]))\n    while heap:\n        path_str, path = heapq.heappop(heap)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        x, y = path[-1]\n        for nx, ny in neighbors(x, y):\n            new_path = path + [(nx, ny)]\n            new_path_str = path_str + str(grid[nx][ny])\n            heapq.heappush(heap, (new_path_str, new_path))", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    values = sorted(((grid[i][j], i, j) for i, j in product(range(n), range(n))))\n    path = [values[0][0]]\n    pos = (values[0][1], values[0][2])\n    for _ in range(k - 1):\n        neighbors = []\n        x, y = pos\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                neighbors.append((grid[nx][ny], nx, ny))\n        neighbors.append((grid[x][y], x, y))\n        neighbors.sort()\n        selected = neighbors[0]\n        path.append(selected[0])\n        pos = (selected[1], selected[2])\n    return path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    min_heap = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(min_heap, (grid[i][j], [(i, j)]))\n    while min_heap:\n        _, path = heapq.heappop(min_heap)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        last_x, last_y = path[-1]\n        for dx, dy in directions:\n            nx, ny = (last_x + dx, last_y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [(nx, ny)]\n                heapq.heappush(min_heap, (tuple((grid[x][y] for x, y in new_path)), new_path))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(heap, (grid[i][j], [(i, j)]))\n    while heap:\n        _, path = heapq.heappop(heap)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        last_x, last_y = path[-1]\n        for dx, dy in directions:\n            nx, ny = (last_x + dx, last_y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [(nx, ny)]\n                heapq.heappush(heap, ([grid[row][col] for row, col in new_path], new_path))", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    import heapq\n\n    def neighbors(x, y):\n        for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:\n            if 0 <= nx < n and 0 <= ny < n:\n                yield (nx, ny)\n    n = len(grid)\n    heap = [(grid[i][j], [grid[i][j]], i, j) for i in range(n) for j in range(n)]\n    heapq.heapify(heap)\n    while heap:\n        value, path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for nx, ny in neighbors(x, y):\n            new_path = path + [grid[nx][ny]]\n            heapq.heappush(heap, (new_path, new_path, nx, ny))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], [(i, j)]))\n    while pq:\n        current_path = heapq.heappop(pq)\n        path_values = list((grid[i][j] for i, j in current_path))", "from typing import List\nimport itertools\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    flattened_grid = sorted([(grid[i][j], i, j) for i in range(n) for j in range(n)])\n    min_path = []\n    path = []\n\n    def dfs(x, y, depth):\n        if depth == k:\n            nonlocal min_path\n            if not min_path or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, depth + 1)\n                path.pop()\n    for value, i, j in flattened_grid:\n        path = [value]\n        dfs(i, j, 1)\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            heapq.heappush(min_heap, tuple(path))\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if is_valid(nx, ny):\n                dfs(nx, ny, path + [grid[nx][ny]])\n    min_heap = []\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    return list(heapq.heappop(min_heap))", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    values_with_coordinates = []\n    for i, j in product(range(n), range(n)):\n        values_with_coordinates.append((grid[i][j], i, j))\n    values_with_coordinates.sort(key=lambda x: x[0])\n    smallest_value, start_x, start_y = values_with_coordinates[0]\n    path = [smallest_value] * k\n    return path"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "HumanEval/130", "requirement": "from typing import List\n\ndef tri(n: int) -> List[float]:\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(0) = [1], if n is 0.\n    tri(1) = 3, if n is 1.\n    tri(n) = 1 + n / 2, if n is even and n > 1.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd and n + 1 is within bounds.\n    If n + 1 is out of bounds, tri(n + 1) is calculated as 1 + (n + 1) / 2.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 1 + (4 / 2) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tribonacci(m: int) -> float:\n        if m == 0:\n            return 1\n        elif m == 1:\n            return 3\n        elif m % 2 == 0:\n            return 1 + m / 2\n        else:\n            next_value = 1 + (m + 1) / 2 if m + 1 > n else compute_tribonacci(m + 1)\n            return compute_tribonacci(m - 1) + compute_tribonacci(m - 2) + next_value\n    return [compute_tribonacci(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tribonacci_value(k: int, seq: List[float]) -> float:\n        if k % 2 == 0:\n            return 1 + k / 2\n        if k + 1 < len(seq):\n            return seq[k - 1] + seq[k - 2] + seq[k + 1]\n        else:\n            return seq[k - 1] + seq[k - 2] + (1 + (k + 1) / 2)\n    if n == 0:\n        return [1]\n    tribonacci_sequence = [1, 3]\n    for i in range(2, n + 1):\n        tribonacci_sequence.append(tribonacci_value(i, tribonacci_sequence))\n    return tribonacci_sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def calculate_tribonacci(k: int, sequence: List[float]) -> float:\n        if k == len(sequence):\n            if k % 2 == 0:\n                return 1 + k / 2\n            else:\n                return sequence[k - 1] + sequence[k - 2] + calculate_tribonacci(k + 1, sequence)\n        else:\n            return sequence[k]\n    sequence = [1]\n    for i in range(1, n + 1):\n        val = calculate_tribonacci(i, sequence)\n        sequence.append(val)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tribonacci_value(k: int) -> float:\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            next_k = 1 + (k + 1) / 2 if k + 1 > n else tribonacci_value(k + 1)\n            return tribonacci_value(k - 1) + tribonacci_value(k - 2) + next_k\n    return [tribonacci_value(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tribonacci_val(m: int) -> float:\n        if m == 0:\n            return 1\n        elif m == 1:\n            return 3\n        elif m > 1 and m % 2 == 0:\n            return 1 + m / 2\n        elif m + 1 <= n:\n            return tribonacci_val(m - 1) + tribonacci_val(m - 2) + tribonacci_val(m + 1)\n        else:\n            return tribonacci_val(m - 1) + tribonacci_val(m - 2) + (1 + (m + 1) / 2)\n    return [tribonacci_val(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tribonacci(k: int) -> float:\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k > 1 and k % 2 == 0:\n            return 1 + k / 2\n        elif k + 1 > n:\n            return compute_tribonacci(k - 1) + compute_tribonacci(k - 2) + (1 + (k + 1) / 2)\n        else:\n            return compute_tribonacci(k - 1) + compute_tribonacci(k - 2) + compute_tribonacci(k + 1)\n    return [compute_tribonacci(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tribonacci_element(x: int) -> float:\n        if x == 0:\n            return 1\n        elif x == 1:\n            return 3\n        elif x > 1 and x % 2 == 0:\n            return 1 + x / 2\n        elif x % 2 != 0:\n            if x + 1 > n:\n                return tribonacci_element(x - 1) + tribonacci_element(x - 2) + (1 + (x + 1) / 2)\n            return tribonacci_element(x - 1) + tribonacci_element(x - 2) + tribonacci_element(x + 1)\n    return [tribonacci_element(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tribonacci_value(k: int) -> float:\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return tribonacci_value(k - 1) + tribonacci_value(k - 2) + (tribonacci_value(k + 1) if k + 1 <= n else 1 + (k + 1) / 2)\n    return [tribonacci_value(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tribonacci(num: int, seq: List[float]) -> float:\n        if num == 0:\n            return 1\n        elif num == 1:\n            return 3\n        elif num % 2 == 0:\n            return 1 + num / 2\n        elif num + 1 < len(seq):\n            return seq[num - 1] + seq[num - 2] + seq[num + 1]\n        else:\n            next_num = 1 + (num + 1) / 2\n            return seq[num - 1] + seq[num - 2] + next_num\n    sequence = []\n    for i in range(n + 1):\n        sequence.append(tribonacci(i, sequence))\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tribonacci_value(idx: int) -> float:\n        if idx == 0:\n            return 1\n        elif idx == 1:\n            return 3\n        elif idx % 2 == 0:\n            return 1 + idx / 2\n        elif idx + 1 <= n:\n            return tribonacci_value(idx - 1) + tribonacci_value(idx - 2) + tribonacci_value(idx + 1)\n        else:\n            return tribonacci_value(idx - 1) + tribonacci_value(idx - 2) + (1 + (idx + 1) / 2)\n    return [tribonacci_value(i) for i in range(n + 1)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.11111111111111116}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there exists a valid subsequence of brackets \n    within the string that contains at least one nested bracket pair. A valid subsequence means \n    that there is at least one pair of matching opening and closing brackets, and a nested bracket pair \n    is defined as one bracket being enclosed within another, such as in '[[]]'.\n\n    The function should not require the entire string to be a valid sequence of brackets; it only needs \n    to find at least one valid subsequence with nested brackets.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_found = True\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_found = True\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for bracket in string:\n        if bracket == '[':\n            stack.append(bracket)\n        elif bracket == ']' and stack:\n            stack.pop()\n            if stack:\n                return True\n    return False", "def is_nested(string: str) -> bool:\n    open_count = 0\n    nested_found = False\n    for char in string:\n        if char == '[':\n            open_count += 1\n        elif char == ']':\n            if open_count > 0:\n                open_count -= 1\n                if open_count > 0:\n                    nested_found = True\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_found = True\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append('[')\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append('[')\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_found = True\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append('[')\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/134", "requirement": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''", "generated_programs": ["def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    return txt[-1].isalpha() and (len(txt) < 2 or txt[-2].isspace())", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt.strip():\n        return False\n    txt = txt.rstrip()\n    if txt[-1].isalpha() and (len(txt.split()) == 0 or ' ' in txt[:txt.rfind(txt[-1])]):\n        return True\n    return False", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt or txt[-1] == ' ':\n        return False\n    last_char = txt.rstrip()[-1]\n    return last_char.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    return len(txt.split()[-1]) == 1 and txt[-1].isalpha()", "import string\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt.strip():\n        return False\n    txt = txt.rstrip()\n    last_char = txt[-1]\n    if last_char.isalpha():\n        parts = txt.split()\n        return parts[-1] == last_char\n    return False", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.strip()\n    if txt and txt[-1].isalpha():\n        return len(txt.split()[-1]) == 1\n    return False", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.strip()\n    if not txt or txt[-1].isspace() or (not txt[-1].isalpha()):\n        return False\n    return txt.split()[-1] == txt[-1]", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    return txt[-1].isalpha() and ' ' in txt", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.strip()\n    if txt and txt[-1].isalpha():\n        words = txt.split()\n        return txt[-1] == words[-1][-1]\n    return False", "import string\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    return txt[-1] in string.ascii_letters and ' ' in txt"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(c) for c in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/147", "requirement": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n    Return the number of unique triples (a[i], a[j], a[k]) in a where i < j < k, \n    and the sum a[i] + a[j] + a[k] is divisible by 3.\n\n    Example:\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"", "generated_programs": ["from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triples_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    triples_count += 1\n    return triples_count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from typing import List\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from typing import List\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from typing import List\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triples = combinations(a, 3)\n    count = sum((1 for triple in triples if sum(triple) % 3 == 0))\n    return count"], "result": {"repaired_passk": 0.8, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/148", "requirement": "from typing import Tuple\n\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''", "generated_programs": ["from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start, end = sorted([index1, index2])\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1, index2 = (planets.index(planet1), planets.index(planet2))\n    start, end = sorted((index1, index2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1, index2 = (planets.index(planet1), planets.index(planet2))\n    lower, upper = (min(index1, index2), max(index1, index2))\n    return tuple(planets[lower + 1:upper])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets_in_order = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets_in_order or planet2 not in planets_in_order:\n        return ()\n    index1 = planets_in_order.index(planet1)\n    index2 = planets_in_order.index(planet2)\n    if index1 < index2:\n        return tuple(planets_in_order[index1 + 1:index2])\n    else:\n        return tuple(planets_in_order[index2 + 1:index1])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets_order = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets_order or planet2 not in planets_order:\n        return ()\n    index1 = planets_order.index(planet1)\n    index2 = planets_order.index(planet2)\n    if index1 > index2:\n        index1, index2 = (index2, index1)\n    return tuple(planets_order[index1 + 1:index2])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start, end = sorted([index1, index2])\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start, end = (min(index1, index2) + 1, max(index1, index2))\n    return tuple(planets[start:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1, index2 = (planets.index(planet1), planets.index(planet2))\n    start, end = (min(index1, index2), max(index1, index2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start, end = (min(idx1, idx2), max(idx1, idx2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start = min(idx1, idx2) + 1\n    end = max(idx1, idx2)\n    return tuple(planets[start:end])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/151", "requirement": "from typing import List\n\n\ndef double_the_difference(lst: List[int]) -> int:\n    '''\n    Given a list of integers, return the sum of squares of the numbers\n    in the list that are odd and non-negative. Ignore numbers that are negative.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    If the input list is empty, return 0.\n    '''", "generated_programs": ["from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 == 1))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 == 1))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 == 1))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 == 1))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 == 1))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 != 0))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x >= 0 and x % 2 != 0))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if any rotation of the second word is a substring in the first word.\n    \n    To achieve this, you can concatenate the second word with itself and check if any substring of the first word of the same length as the second word appears in this concatenated string.\n    \n    Examples:\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    return any((a.find(concatenated_b[i:i + len(b)]) != -1 for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    if len(b) > len(a):\n        return False\n    b_concat = b + b\n    return any((b_concat[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    return any((concatenated_b[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    return any((a[i:i + len(b)] == b for i in range(len(a) - len(b) + 1))) if b in concatenated_b else False", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    return any((concatenated_b[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    length_b = len(b)\n    for i in range(len(concatenated_b) - length_b + 1):\n        if concatenated_b[i:i + length_b] in a:\n            return True\n    return False", "from typing import Tuple\n\ndef cycpattern_check(a: str, b: str) -> bool:\n    doubled_b = b + b\n    length_b = len(b)\n    return any((a[i:i + length_b] in doubled_b for i in range(len(a) - length_b + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    for i in range(len(b)):\n        if concatenated_b[i:i + len(b)] in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    return any((a[i:i + len(b)] == b for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    return any((concatenated_b[i:i + len(b)] in a for i in range(len(b))))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/160", "requirement": "from typing import List\n\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists, `operator` and `operand`. The `operator` list contains basic algebra operations, and \n    the `operand` list is a list of integers. Use the two given lists to construct an algebraic expression \n    as a string and evaluate it, respecting the standard operator precedence.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of the `operator` list is equal to the length of the `operand` list minus one.\n        The `operand` list consists of non-negative integers.\n        The `operator` list contains at least one operator, and the `operand` list contains at least two operands.\n\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i in range(len(operator)):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i in range(len(operator)):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i in range(len(operator)):\n        expression += f'{operand[i]}{operator[i]}'\n    expression += f'{operand[-1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i, op in enumerate(operator):\n        expression += str(operand[i]) + op\n    expression += str(operand[-1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "from typing import List\n\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return the numbers between a\n    and b (inclusive) that consist entirely of even digits, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_all_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if has_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(x: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(x)))\n    lower, upper = sorted((a, b))\n    return [num for num in range(lower, upper + 1) if has_only_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if has_only_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even(number: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(number)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if is_all_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    return [x for x in range(min(a, b), max(a, b) + 1) if all((int(d) % 2 == 0 for d in str(x)))]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [x for x in range(start, end + 1) if is_all_even_digits(x)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(n: int) -> bool:\n        return all((int(d) % 2 == 0 for d in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [number for number in range(start, end + 1) if has_only_even_digits(number)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if has_only_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_even_digit_only(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if is_even_digit_only(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [i for i in range(start, end + 1) if has_only_even_digits(i)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that starts with the supplied string by appending the minimum necessary characters to its end.\n    \n    The algorithm works as follows:\n    - Identify the longest suffix of the input string that is a palindrome.\n    - Append the reverse of the prefix (the part of the string before the palindromic suffix) to the end of the string.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(substring: str) -> bool:\n        return substring == substring[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string), 0, -1):\n        if is_palindrome(string[:i]):\n            prefix = string[i:]\n            return string + prefix[::-1]\n    return string + string[::-1]", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    import itertools\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            prefix = string[:i]\n            return string + prefix[::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/32", "requirement": "def find_zero(xs: List[float]) -> float:\n    \"\"\" \n    Finds a zero of the polynomial with coefficients xs using the bisection method within the interval [-100, 100].\n    The function assumes that xs has an even number of coefficients and that there is at least one real root within the interval.\n    Returns only one zero point, even if there are multiple.\n    The bisection method checks if the product of the polynomial values at the current interval endpoints is strictly less than zero to determine the subinterval containing the root.\n    \n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef evaluate_polynomial(xs: List[float], x: float) -> float:\n    return sum((coef * x ** i for i, coef in enumerate(xs)))\n\ndef find_zero(xs: List[float]) -> float:\n    low, high = (-100, 100)\n    while high - low > 1e-06:\n        mid = (low + high) / 2\n        f_low = evaluate_polynomial(xs, low)\n        f_mid = evaluate_polynomial(xs, mid)\n        if f_low * f_mid < 0:\n            high = mid\n        else:\n            low = mid\n    return (low + high) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def evaluate_polynomial(coefficients: List[float], x: float) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(coefficients)))\n    a, b = (-100, 100)\n    while b - a > 1e-06:\n        mid = (a + b) / 2\n        f_a = evaluate_polynomial(xs, a)\n        f_mid = evaluate_polynomial(xs, mid)\n        if f_a * f_mid < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float, coefficients: List[float]) -> float:\n        return sum((coeff * x ** i for i, coeff in enumerate(coefficients)))\n\n    def bisection_method(a: float, b: float, coefficients: List[float], tolerance: float=1e-07) -> float:\n        while abs(b - a) > tolerance:\n            mid = (a + b) / 2\n            f_a = polynomial(a, coefficients)\n            f_mid = polynomial(mid, coefficients)\n            if f_a * f_mid < 0:\n                b = mid\n            else:\n                a = mid\n        return (a + b) / 2\n    return bisection_method(-100, 100, xs)", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(coefficients, x):\n        return sum((coeff * x ** i for i, coeff in enumerate(coefficients)))\n    a, b = (-100, 100)\n    while b - a > 1e-06:\n        mid = (a + b) / 2\n        fa = polynomial(xs, a)\n        fm = polynomial(xs, mid)\n        if fa * fm < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def polynomial(x: float) -> float:\n        return sum((coef * x ** i for i, coef in enumerate(xs)))\n    a, b = (-100, 100)\n    while b - a > 1e-06:\n        mid = (a + b) / 2\n        if polynomial(a) * polynomial(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef evaluate_polynomial(coefficients: List[float], x: float) -> float:\n    return sum((coef * x ** i for i, coef in enumerate(coefficients)))\n\ndef find_zero(xs: List[float]) -> float:\n    low, high = (-100, 100)\n    tolerance = 1e-06\n    while high - low > tolerance:\n        mid = (low + high) / 2\n        f_low = evaluate_polynomial(xs, low)\n        f_mid = evaluate_polynomial(xs, mid)\n        if f_low * f_mid < 0:\n            high = mid\n        else:\n            low = mid\n    return (low + high) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def evaluate_polynomial(coeffs, x):\n        return sum((c * x ** i for i, c in enumerate(coeffs)))\n    a, b = (-100, 100)\n    tolerance = 1e-07\n    while b - a > tolerance:\n        midpoint = (a + b) / 2\n        f_a = evaluate_polynomial(xs, a)\n        f_mid = evaluate_polynomial(xs, midpoint)\n        if f_mid == 0:\n            return midpoint\n        if f_a * f_mid < 0:\n            b = midpoint\n        else:\n            a = midpoint\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def evaluate_polynomial(coeffs, x):\n        return sum((c * x ** i for i, c in enumerate(coeffs)))\n    a, b = (-100, 100)\n    while abs(b - a) > 1e-07:\n        mid = (a + b) / 2\n        f_a = evaluate_polynomial(xs, a)\n        f_mid = evaluate_polynomial(xs, mid)\n        if f_a * f_mid < 0:\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n\n    def evaluate_polynomial(coefficients, x):\n        return sum((c * x ** i for i, c in enumerate(coefficients)))\n\n    def has_root_in_interval(coefficients, a, b):\n        return evaluate_polynomial(coefficients, a) * evaluate_polynomial(coefficients, b) < 0\n    a, b = (-100, 100)\n    while b - a > 1e-07:\n        mid = (a + b) / 2\n        if has_root_in_interval(xs, a, mid):\n            b = mid\n        else:\n            a = mid\n    return (a + b) / 2", "from typing import List\n\ndef evaluate_polynomial(xs: List[float], x: float) -> float:\n    return sum((coef * x ** i for i, coef in enumerate(xs)))\n\ndef find_zero(xs: List[float]) -> float:\n    a, b = (-100, 100)\n    while abs(b - a) > 1e-07:\n        mid = (a + b) / 2\n        f_a = evaluate_polynomial(xs, a)\n        f_b = evaluate_polynomial(xs, b)\n        f_mid = evaluate_polynomial(xs, mid)\n        if f_a * f_mid < 0:\n            b = mid\n        elif f_b * f_mid < 0:\n            a = mid\n        else:\n            return mid\n    return (a + b) / 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2\n    else:\n        return float(l_sorted[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return float(l[n // 2])\n    else:\n        mid1 = n // 2\n        mid2 = mid1 - 1\n        return (l[mid1] + l[mid2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_list[mid - 1] + sorted_list[mid]) / 2\n    else:\n        return float(sorted_list[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return float(l[n // 2])\n    else:\n        mid1, mid2 = (n // 2 - 1, n // 2)\n        return (l[mid1] + l[mid2]) / 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/59", "requirement": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of the given integer n. It is guaranteed that n > 1 and n is not a prime number.\n    \n    The function should iteratively divide n by its smallest factors until n itself becomes a prime number, which is then returned as the largest prime factor.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"", "generated_programs": ["from math import isqrt\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(number: int) -> bool:\n        if number < 2:\n            return False\n        for i in range(2, isqrt(number) + 1):\n            if number % i == 0:\n                return False\n        return True\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n if is_prime(n) else factor", "from math import isqrt\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, isqrt(x) + 1):\n            if x % i == 0:\n                return False\n        return True\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "import math\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "from math import isqrt\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(x: int) -> bool:\n        if x <= 1:\n            return False\n        for i in range(2, isqrt(x) + 1):\n            if x % i == 0:\n                return False\n        return True\n    factor = 2\n    while n > 1:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n            while not is_prime(factor):\n                factor += 1\n    return factor", "import math\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        limit = math.isqrt(num)\n        for i in range(5, limit + 1, 6):\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n        return True\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "import math\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(x: int) -> bool:\n        if x <= 1:\n            return False\n        for i in range(2, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                return False\n        return True\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "import math\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(number: int) -> bool:\n        if number < 2:\n            return False\n        for i in range(2, int(math.sqrt(number)) + 1):\n            if number % i == 0:\n                return False\n        return True\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "from math import isqrt\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, isqrt(x) + 1):\n            if x % i == 0:\n                return False\n        return True\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n", "from math import isqrt\n\ndef largest_prime_factor(n: int) -> int:\n\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, isqrt(x) + 1):\n            if x % i == 0:\n                return False\n        return True\n    factor = 2\n    while factor <= isqrt(n):\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n if is_prime(n) else factor", "def largest_prime_factor(n: int) -> int:\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/60", "requirement": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that calculates the sum of all natural numbers from 1 to n.\n    If n is less than 1, the function returns 0.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"", "generated_programs": ["from typing import Union\n\ndef sum_to_n(n: int) -> Union[int, float]:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "from typing import Optional\n\ndef sum_to_n(n: int) -> int:\n    return sum(range(1, n + 1)) if n >= 1 else 0", "def sum_to_n(n: int) -> int:\n    return 0 if n < 1 else n * (n + 1) // 2", "from typing import List\n\ndef sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "def sum_to_n(n: int) -> int:\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/65", "requirement": "def circular_shift(x: int, shift: int) -> str:\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"", "generated_programs": ["def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    num_digits = len(digits)\n    if shift > num_digits:\n        return digits[::-1]\n    shift = shift % num_digits\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    shifted_digits = digits[-shift:] + digits[:-shift]\n    return shifted_digits", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift %= n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    x_str = str(x)\n    num_digits = len(x_str)\n    if shift > num_digits:\n        return x_str[::-1]\n    shift = shift % num_digits\n    return x_str[-shift:] + x_str[:-shift]", "from typing import List\n\ndef circular_shift(x: int, shift: int) -> str:\n    digits = list(str(x))\n    n = len(digits)\n    if shift > n:\n        return ''.join(digits[::-1])\n    shift = shift % n\n    return ''.join(digits[-shift:] + digits[:-shift])", "from typing import Union\n\ndef circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift = shift % n\n    return digits[-shift:] + digits[:-shift]", "from typing import List\n\ndef circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    num_digits = len(digits)\n    if shift > num_digits:\n        return digits[::-1]\n    shift = shift % num_digits\n    shifted_digits = digits[-shift:] + digits[:-shift]\n    return shifted_digits", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    n = len(digits)\n    if shift > n:\n        return digits[::-1]\n    shift %= n\n    return digits[-shift:] + digits[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    x_str = str(x)\n    n = len(x_str)\n    if shift > n:\n        return x_str[::-1]\n    shift %= n\n    return x_str[-shift:] + x_str[:-shift]", "def circular_shift(x: int, shift: int) -> str:\n    digits = str(x)\n    length = len(digits)\n    if shift > length:\n        return digits[::-1]\n    shift = shift % length\n    return digits[-shift:] + digits[:-shift]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    \"\"\"Determine if the given integer is a perfect cube of another integer, considering both positive and negative numbers.\n    \n    The function should return True if 'a' is a cube of any integer, otherwise False.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    \"\"\"", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        root = round(abs(a) ** (1 / 3))\n        return root ** 3 == abs(a)\n    else:\n        root = round(a ** (1 / 3))\n        return root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        root = round(-math.pow(-a, 1 / 3))\n    else:\n        root = round(math.pow(a, 1 / 3))\n    return root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = -round(abs(a) ** (1 / 3))\n    else:\n        cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        root = round(abs(a) ** (1 / 3))\n        return root ** 3 == abs(a)\n    else:\n        root = round(a ** (1 / 3))\n        return root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_root = round(abs(a) ** (1 / 3))\n    return abs_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    root = round(a ** (1 / 3))\n    return root ** 3 == a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.6}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of n-digit positive integers\n    that start with 1 or end with 1, without double-counting those that both\n    start and end with 1.\n\n    Examples:\n    >>> starts_one_ends(1)\n    1\n    >>> starts_one_ends(2)\n    18\n    >>> starts_one_ends(3)\n    180\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_starting_1 = 10 ** (n - 1)\n    total_ending_1 = 10 ** (n - 1)\n    total_start_and_end_1 = 10 ** (n - 2)\n    return total_starting_1 + total_ending_1 - total_start_and_end_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_numbers = 9 * 10 ** (n - 1)\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 10 ** (n - 1)\n    overlap = 10 ** (n - 2) if n > 1 else 1\n    return starts_with_one + ends_with_one - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_n_digit_numbers = 9 * 10 ** (n - 1)\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 1\n    return start_with_1 + end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_digits = 10 ** n\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 10 ** (n - 1)\n    starts_and_ends_with_1 = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - starts_and_ends_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_n_digit_numbers = 9 * 10 ** (n - 1)\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 10 ** (n - 1)\n    starts_and_ends_with_1 = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - starts_and_ends_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1_count = 10 ** (n - 1)\n    end_with_1_count = 10 ** (n - 1)\n    both_start_end_1_count = 10 ** (n - 2)\n    return start_with_1_count + end_with_1_count - both_start_end_1_count", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 9 * 10 ** (n - 1)\n    both_start_end_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - both_start_end_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_n_digit_numbers = 9 * 10 ** (n - 1)\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 1 if n > 1 else 0\n    return start_with_1 + end_with_1 - both_start_and_end_with_1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    Each letter in the string should be shifted forward by four positions in the alphabet.\n    The function should handle both lowercase and uppercase letters appropriately, wrapping around the alphabet if necessary.\n    Non-alphabet characters should remain unchanged.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n\n    def shift(char: str, offset: int) -> str:\n        if 'a' <= char <= 'z':\n            return chr((ord(char) - ord('a') + offset) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            return chr((ord(char) - ord('A') + offset) % 26 + ord('A'))\n        else:\n            return char\n    return ''.join((shift(char, 4) for char in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((shift_char(char) for char in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str, shift: int) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((shift_char(char, 4) for char in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str, shift: int) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        return c\n    return ''.join((shift_char(c, 4) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift(char: str, shift_amount: int) -> str:\n        if char.islower():\n            return chr((ord(char) - ord('a') + shift_amount) % 26 + ord('a'))\n        elif char.isupper():\n            return chr((ord(char) - ord('A') + shift_amount) % 26 + ord('A'))\n        else:\n            return char\n    return ''.join((shift(char, 4) for char in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        return c\n    return ''.join((shift_char(c) for c in s))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\" followed by a space.\n    Sentences are delimited by '.', '?', or '!', and consecutive delimiters are treated as a single delimiter.\n    Leading and trailing spaces around sentences are ignored when checking if a sentence starts with \"I\".\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n\n    ### Test 1\n    Input: ['I am here. You are there. They are everywhere.']\n    Expected Output: [3]\n\n    ### Test 2\n    Input: ['I. I! I?']\n    Expected Output: [0]\n\n    ### Test 3\n    Input: ['I am bored. Are you? I certainly am!']\n    Expected Output: [4]\n    \"\"\"", "generated_programs": ["import re\n\ndef is_bored(S: str) -> int:\n    delimiters = '[.!?]'\n    sentences = re.split(delimiters, S)\n    count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    boredom_count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I '):\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S)\n    count = sum((sentence.strip().startswith('I ') for sentence in sentences))\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S.strip())\n    boredom_count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S.strip())\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]+', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]+', S.strip())\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    delimiters = re.compile('[.?!]+')\n    sentences = delimiters.split(S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return boredom_count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/92", "requirement": "def any_int(x: int, y: int, z: int) -> bool:\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false if any of the numbers are not integers or if none of the numbers is equal to the sum of the other two.\n    \n    Examples\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n    '''", "generated_programs": ["from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(i, int) for i in [x, y, z])):\n        return False\n    return x == y + z or y == x + z or z == x + y", "from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if not all((isinstance(val, int) for val in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        return x == y + z or y == x + z or z == x + y\n    return False", "from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y", "def any_int(x: int, y: int, z: int) -> bool:\n    if not all((isinstance(num, int) for num in [x, y, z])):\n        return False\n    return x == y + z or y == x + z or z == x + y", "from typing import Union\n\ndef any_int(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -> bool:\n    if not all((isinstance(i, int) for i in (x, y, z))):\n        return False\n    return x == y + z or y == x + z or z == x + y"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message consisting solely of letters, \n    and encodes it by swapping the case of all letters and replacing \n    each vowel with the letter that appears two places ahead of it in \n    the English alphabet, considering both lowercase and uppercase vowels. \n    Vowels are 'a', 'e', 'i', 'o', 'u'.\n\n    For example, 'a' becomes 'C', 'A' becomes 'c', 'e' becomes 'G', etc.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n\n    def transform_char(char: str) -> str:\n        vowels_map = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n        if char in vowels_map:\n            return vowels_map[char]\n        elif char.isalpha():\n            return char.swapcase()\n        else:\n            return char\n    return ''.join((transform_char(char) for char in message))", "def encode(message: str) -> str:\n\n    def transform_char(c: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if c.isalpha():\n            if c in vowels:\n                offset = 2\n                if c.islower():\n                    return chr((ord(c) + offset - ord('a')) % 26 + ord('a')).upper()\n                else:\n                    return chr((ord(c) + offset - ord('A')) % 26 + ord('A')).lower()\n            else:\n                return c.swapcase()\n        return c\n    return ''.join((transform_char(c) for c in message))", "def encode(message: str) -> str:\n\n    def transform_char(char: str) -> str:\n        vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n        if char.lower() in vowels:\n            encoded = vowels[char.lower()]\n            return encoded.upper() if char.islower() else encoded.lower()\n        return char.swapcase()\n    return ''.join((transform_char(c) for c in message))", "def encode(message: str) -> str:\n\n    def encode_letter(char: str) -> str:\n        vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n        uppercase_vowels = {v.upper(): c.lower() for v, c in vowels.items()}\n        all_vowels = {**vowels, **uppercase_vowels}\n        if char.lower() in 'aeiou':\n            return all_vowels[char]\n        else:\n            return char.swapcase()\n    return ''.join((encode_letter(char) for char in message))", "def encode(message: str) -> str:\n    vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            swapped_case = char.swapcase()\n            lower_char = swapped_case.lower()\n            if lower_char in vowels:\n                encoded_message += vowels[lower_char] if swapped_case.islower() else vowels[lower_char].swapcase()\n            else:\n                encoded_message += swapped_case\n        else:\n            encoded_message += char\n    return encoded_message", "def encode(message: str) -> str:\n\n    def transform_char(char: str) -> str:\n        vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        if char in vowels:\n            return vowels[char]\n        return char.swapcase()\n    return ''.join((transform_char(char) for char in message))", "def encode(message: str) -> str:\n\n    def transform_char(c: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if c in vowels:\n            offset = 2\n            if c.islower():\n                return chr((ord(c) - ord('a') + offset) % 26 + ord('a')).swapcase()\n            else:\n                return chr((ord(c) - ord('A') + offset) % 26 + ord('A')).swapcase()\n        else:\n            return c.swapcase()\n    return ''.join((transform_char(c) for c in message))", "def encode(message: str) -> str:\n    vowels = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n    encoded_message = ''\n    for char in message:\n        if char in vowels:\n            encoded_message += vowels[char]\n        elif char.isalpha():\n            encoded_message += char.swapcase()\n        else:\n            encoded_message += char\n    return encoded_message", "def encode(message: str) -> str:\n\n    def encode_char(char):\n        vowels = {'a': 'C', 'e': 'G', 'i': 'K', 'o': 'Q', 'u': 'W', 'A': 'c', 'E': 'g', 'I': 'k', 'O': 'q', 'U': 'w'}\n        if char in vowels:\n            return vowels[char]\n        elif char.isalpha():\n            return char.swapcase()\n        return char\n    return ''.join((encode_char(char) for char in message))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7777777777777778, "original_passk": 0.4}}
{"task_id": "HumanEval/94", "requirement": "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n    If there are no prime numbers in the list, the function should raise a ValueError.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list.')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers found in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers found in the list')\n    largest_prime = max(primes)\n    return sum(map(int, str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    prime_numbers = [num for num in lst if is_prime(num)]\n    if not prime_numbers:\n        raise ValueError('No prime numbers in the list.')\n    largest_prime = max(prime_numbers)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers in the list')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        raise ValueError('No prime numbers in the list.')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers found in the list.')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))", "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [num for num in lst if is_prime(num)]\n    if not primes:\n        raise ValueError('No prime numbers found in the list.')\n    largest_prime = max(primes)\n    return sum((int(digit) for digit in str(largest_prime)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/95", "requirement": "from typing import Dict\n\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"", "generated_programs": ["from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(k, str) and k.islower() for k in keys)):\n        return True\n    if all((isinstance(k, str) and k.isupper() for k in keys)):\n        return True\n    return False", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    lower_case = all((isinstance(k, str) and k.islower() for k in dict.keys()))\n    upper_case = all((isinstance(k, str) and k.isupper() for k in dict.keys()))\n    return lower_case or upper_case", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict or not all((isinstance(key, str) for key in dict.keys())):\n        return False\n    all_lowercase = all((key.islower() for key in dict.keys()))\n    all_uppercase = all((key.isupper() for key in dict.keys()))\n    return all_lowercase or all_uppercase", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    lower_case_keys = all((isinstance(key, str) and key.islower() for key in dict.keys()))\n    upper_case_keys = all((isinstance(key, str) and key.isupper() for key in dict.keys()))\n    return lower_case_keys or upper_case_keys", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    if all((isinstance(key, str) and key.islower() for key in keys)):\n        return True\n    if all((isinstance(key, str) and key.isupper() for key in keys)):\n        return True\n    return False", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    lower_case = all((isinstance(key, str) and key.islower() for key in dict.keys()))\n    upper_case = all((isinstance(key, str) and key.isupper() for key in dict.keys()))\n    return lower_case or upper_case", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    if all((isinstance(key, str) and key.islower() for key in dict.keys())):\n        return True\n    if all((isinstance(key, str) and key.isupper() for key in dict.keys())):\n        return True\n    return False", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(key, str) for key in keys)):\n        if all((key.islower() for key in keys)) or all((key.isupper() for key in keys)):\n            return True\n    return False", "from typing import Dict, Any\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    string_keys = [key for key in keys if isinstance(key, str)]\n    if len(string_keys) != len(keys):\n        return False\n    all_lower_case = all((key.islower() for key in string_keys))\n    all_upper_case = all((key.isupper() for key in string_keys))\n    return all_lower_case or all_upper_case", "from typing import Any, Dict\n\ndef check_dict_case(dict: Dict[Any, Any]) -> bool:\n    if not dict:\n        return False\n    keys = dict.keys()\n    if all((isinstance(key, str) and key.islower() for key in keys)):\n        return True\n    if all((isinstance(key, str) and key.isupper() for key in keys)):\n        return True\n    return False"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    Each subsequent level has 2 more stones than the previous level.\n    \n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements whose sum of digits (considering the sign of the first digit if negative) is greater than 0.\n    For example, for a negative number like -123, the sum of digits is calculated as -1 + 2 + 3 = 4.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(num)\n        if num_str[0] == '-':\n            return int(num_str[0]) + sum((int(d) for d in num_str[1:]))\n        return sum((int(d) for d in num_str))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        sign = -1 if str(n).startswith('-') else 1\n        return sign * abs(n) % 10 + sum((int(d) for d in str(abs(n))[1:]))\n    return sum((1 for x in arr if digit_sum(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_digits(num: int) -> int:\n        digits = [int(d) for d in str(abs(num))]\n        if num < 0:\n            digits[0] *= -1\n        return sum(digits)\n    return sum((1 for num in arr if sum_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        digits = [int(d) for d in str(abs(num))]\n        if num < 0:\n            digits[0] = -digits[0]\n        return sum(digits)\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(num: int) -> int:\n        sign = -1 if str(num).startswith('-') else 1\n        num_str = str(abs(num))\n        total = sum((int(digit) for digit in num_str))\n        return total * sign\n    return sum((1 for x in arr if digit_sum(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        digits = [int(c) for c in str(abs(num))]\n        if num < 0:\n            digits[0] = -digits[0]\n        return sum(digits)\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        sign = -1 if str(num).startswith('-') else 1\n        digits = map(int, str(abs(num)))\n        return sign * sum(digits)\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        num_str = str(num)\n        if num_str[0] == '-':\n            return sum((int(d) for d in num_str[1:])) - int(num_str[1])\n        else:\n            return sum((int(d) for d in num_str))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(num: int) -> int:\n        if num < 0:\n            return sum((int(d) for d in str(abs(num)))) - int(str(num)[1])\n        else:\n            return sum((int(d) for d in str(num)))\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        str_num = str(num)\n        sign = -1 if str_num[0] == '-' else 1\n        digits = map(int, str_num.lstrip('-'))\n        return sign * sum(digits)\n    return sum((1 for num in arr if sum_of_digits(num) > 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.30000000000000004, "original_passk": 0.5}}
{"task_id": "HumanEval/109", "requirement": "def move_one_ball(arr: List[int]) -> bool:\n    \"\"\"Determine if the array can be sorted in non-decreasing order by performing\n    zero or more right shift operations. A right shift operation moves each element\n    of the array one position to the right, with the last element moving to the\n    first position.\n\n    The function returns True if it is possible to sort the array using at most one\n    \"rotation point\" (where an element is greater than the next element), otherwise\n    it returns False. An empty array is considered sorted and thus the function\n    returns True.\n\n    Note: The array is guaranteed to contain unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2]) ==> True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2]) ==> False\n    Explanation: It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    n = len(arr)\n    if n <= 1:\n        return True\n    rotation_point_count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_point_count += 1\n            if rotation_point_count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    rotation_point_count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_point_count += 1\n            if rotation_point_count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    rotation_points = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_points += 1\n            if rotation_points > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    rotation_point_count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_point_count += 1\n            if rotation_point_count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    rotation_point = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_point += 1\n            if rotation_point > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    rotation_point_count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_point_count += 1\n            if rotation_point_count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    rotation_point_count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_point_count += 1\n            if rotation_point_count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    rotation_point_count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_point_count += 1\n            if rotation_point_count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    n = len(arr)\n    if n == 0:\n        return True\n    rotation_point_count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            rotation_point_count += 1\n        if rotation_point_count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count_rotation_points = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count_rotation_points += 1\n            if count_rotation_points > 1:\n                return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/110", "requirement": "from typing import List\n\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them such that lst1 becomes a list of only even numbers.\n    The exchange allows any number of elements to be moved between lst1 and lst2.\n    To achieve the goal, the number of even numbers in lst2 must be at least\n    equal to the number of odd numbers in lst1.\n    If it is possible to make all the elements of lst1 even through such exchanges,\n    return \"YES\". Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odds_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    evens_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if evens_in_lst2 >= odds_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count_in_lst2 >= odd_count_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    count_odd_in_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    count_even_in_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if count_even_in_lst2 >= count_odd_in_lst1 else 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/115", "requirement": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the total number of times you need to lower the buckets across all wells.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_bucket_uses = 0\n    for row in grid:\n        total_units_of_water = sum(row)\n        total_bucket_uses += (total_units_of_water + capacity - 1) // capacity\n    return total_bucket_uses", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for row in grid:\n        water_units = sum(row)\n        total_buckets += (water_units + capacity - 1) // capacity\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_bucket_uses = 0\n    for row in grid:\n        water_in_row = sum(row)\n        total_bucket_uses += (water_in_row + capacity - 1) // capacity\n    return total_bucket_uses", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for row in grid:\n        water_units = sum(row)\n        buckets_needed = (water_units + capacity - 1) // capacity\n        total_buckets += buckets_needed\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for row in grid:\n        water_units = sum(row)\n        total_buckets += -(-water_units // capacity)\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_moves = 0\n    for row in grid:\n        total_water = sum(row)\n        total_moves += (total_water + capacity - 1) // capacity\n    return total_moves", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_buckets = 0\n    for row in grid:\n        water_units = sum(row)\n        total_buckets += (water_units + capacity - 1) // capacity\n    return total_buckets", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_units_of_water = sum((sum(row) for row in grid))\n    return (total_units_of_water + capacity - 1) // capacity", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_actions = 0\n    for row in grid:\n        water_in_row = sum(row)\n        total_actions += (water_in_row + capacity - 1) // capacity\n    return total_actions", "from math import ceil\nfrom typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum((ceil(sum(row) / capacity) for row in grid))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of integers. Non-negative integers should be sorted according to\n    the number of ones in their binary representation in ascending order. For numbers with the same count of ones,\n    sort them by their decimal value. Negative integers should be sorted by their absolute values in descending order\n    and placed before the sorted non-negative integers.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative_part = sorted(filter(lambda x: x < 0, arr), key=abs, reverse=True)\n    non_negative_part = sorted(filter(lambda x: x >= 0, arr), key=lambda x: (bin(x).count('1'), x))\n    return negative_part + non_negative_part", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negatives = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    negatives = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative_sorted = sorted([x for x in arr if x < 0], key=lambda x: -abs(x))\n    non_negative_sorted = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative_sorted + non_negative_sorted", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative_numbers = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    non_negative_numbers = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative_numbers + non_negative_numbers", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative_numbers = sorted([x for x in arr if x < 0], key=abs, reverse=True)\n    non_negative_numbers = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative_numbers + non_negative_numbers", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    neg_sorted = sorted(filter(lambda x: x < 0, arr), key=lambda x: abs(x), reverse=True)\n    non_neg_sorted = sorted(filter(lambda x: x >= 0, arr), key=lambda x: (bin(x).count('1'), x))\n    return neg_sorted + non_neg_sorted", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative_numbers = sorted([x for x in arr if x < 0], key=lambda x: abs(x), reverse=True)\n    non_negative_numbers = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative_numbers + non_negative_numbers"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The date is in the format: mm-dd-yyyy, where mm is the two-digit month, dd is the two-digit day, and yyyy is the four-digit year.\n    3. The months should be between 01 and 12.\n    4. The days should be appropriate for the given month, considering leap years:\n       - For months 01, 03, 05, 07, 08, 10, 12, the day should be between 01 and 31.\n       - For months 04, 06, 09, 11, the day should be between 01 and 30.\n       - For month 02, the day should be between 01 and 29 in leap years and between 01 and 28 in non-leap years.\n\n    For example:\n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-(\\\\d{4})$'\n    match = re.match(pattern, date)\n    if not match:\n        return False\n    month, day, year = map(int, date.split('-'))\n\n    def is_leap_year(y):\n        return y % 4 == 0 and (y % 100 != 0 or y % 400 == 0)\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 1 <= day <= 31\n    elif month in [4, 6, 9, 11]:\n        return 1 <= day <= 30\n    elif month == 2:\n        if is_leap_year(year):\n            return 1 <= day <= 29\n        else:\n            return 1 <= day <= 28\n    return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        date_object = datetime.strptime(date, '%m-%d-%Y')\n        month = date_object.month\n        day = date_object.day\n        year = date_object.year\n        if month < 1 or month > 12:\n            return False\n        if month in [1, 3, 5, 7, 8, 10, 12]:\n            return 1 <= day <= 31\n        elif month in [4, 6, 9, 11]:\n            return 1 <= day <= 30\n        elif month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                return 1 <= day <= 29\n            else:\n                return 1 <= day <= 28\n        return False\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        date_obj = datetime.strptime(date, '%m-%d-%Y')\n    except ValueError:\n        return False\n    month = date_obj.month\n    day = date_obj.day\n    year = date_obj.year\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        return 1 <= day <= 31\n    elif month in {4, 6, 9, 11}:\n        return 1 <= day <= 30\n    elif month == 2:\n        if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n            return 1 <= day <= 29\n        else:\n            return 1 <= day <= 28\n    return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        parts = date.split('-')\n        if len(parts) != 3:\n            return False\n        mm, dd, yyyy = parts\n        if len(mm) != 2 or len(dd) != 2 or len(yyyy) != 4:\n            return False\n        month = int(mm)\n        day = int(dd)\n        year = int(yyyy)\n        if not 1 <= month <= 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if not 1 <= day <= 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if not 1 <= day <= 30:\n                return False\n        elif month == 2:\n            if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n                if not 1 <= day <= 29:\n                    return False\n            elif not 1 <= day <= 28:\n                return False\n        datetime.strptime(date, '%m-%d-%Y')\n    except Exception:\n        return False\n    return True", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if year < 1:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12} and (day < 1 or day > 31):\n            return False\n        elif month in {4, 6, 9, 11} and (day < 1 or day > 30):\n            return False\n        elif month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                if day < 1 or day > 29:\n                    return False\n            elif day < 1 or day > 28:\n                return False\n        datetime(year=year, month=month, day=day)\n        return True\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if not 1 <= month <= 12:\n            return False\n        if not 1000 <= year <= 9999:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            return 1 <= day <= 31\n        elif month in {4, 6, 9, 11}:\n            return 1 <= day <= 30\n        elif month == 2:\n            if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:\n                return 1 <= day <= 29\n            else:\n                return 1 <= day <= 28\n        return False\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        parsed_date = datetime.strptime(date, '%m-%d-%Y')\n        month, day, year = (parsed_date.month, parsed_date.day, parsed_date.year)\n        if not 1 <= month <= 12:\n            return False\n        is_leap_year = year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            return 1 <= day <= 31\n        elif month in {4, 6, 9, 11}:\n            return 1 <= day <= 30\n        elif month == 2:\n            return 1 <= day <= (29 if is_leap_year else 28)\n        return False\n    except ValueError:\n        return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        datetime.strptime(date, '%m-%d-%Y')\n    except ValueError:\n        return False\n    month, day, year = map(int, date.split('-'))\n    if not 1 <= month <= 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        return 1 <= day <= 31\n    elif month in {4, 6, 9, 11}:\n        return 1 <= day <= 30\n    elif month == 2:\n        is_leap = year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n        return 1 <= day <= 29 if is_leap else 1 <= day <= 28\n    return False", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date or '-' not in date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    mm, dd, yyyy = parts\n    if not (mm.isdigit() and dd.isdigit() and yyyy.isdigit()):\n        return False\n    mm, dd, yyyy = (int(mm), int(dd), int(yyyy))\n    if mm < 1 or mm > 12:\n        return False\n    if yyyy < 1:\n        return False\n    try:\n        datetime(year=yyyy, month=mm, day=dd)\n    except ValueError:\n        return False\n    if mm == 2:\n        is_leap = yyyy % 4 == 0 and (yyyy % 100 != 0 or yyyy % 400 == 0)\n        if is_leap and dd > 29:\n            return False\n        if not is_leap and dd > 28:\n            return False\n    return True", "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$'\n    match = re.match(pattern, date)\n    if not match:\n        return False\n    month, day, year = map(int, match.groups())\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2:\n        is_leap_year = year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n        if is_leap_year and day > 29:\n            return False\n        if not is_leap_year and day > 28:\n            return False\n    if day > 31:\n        return False\n    try:\n        datetime(year, month, day)\n    except ValueError:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/125", "requirement": "from typing import List\nfrom typing import Union\n\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on any whitespace characters (spaces, tabs, newlines). \n    If no whitespace exists in the text, you should split on commas ','. If no commas exist, you should return \n    the number of lowercase letters that are at odd positions in the alphabet (considering ord('a') = 0, \n    ord('b') = 1, ..., ord('z') = 25). This means count letters like 'b', 'd', 'f', etc.\n    \n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 == 1))", "from typing import List, Union\nimport string\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_letters = {ch for ch in string.ascii_lowercase if (ord(ch) - ord('a')) % 2 == 1}\n        return sum((1 for ch in txt if ch in odd_position_letters))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = sum((1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 == 1))\n        return odd_position_count", "from typing import List, Union\nimport string\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_pos_lowercase_letters = set((ch for i, ch in enumerate(string.ascii_lowercase) if i % 2 != 0))\n        return sum((1 for c in txt if c in odd_pos_lowercase_letters))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.isalpha() and (ord(char.lower()) - ord('a')) % 2 == 1))", "from typing import List, Union\nimport string\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        lowercase_at_odd_positions = [c for c in txt if c in string.ascii_lowercase and (ord(c) - ord('a')) % 2 == 1]\n        return len(lowercase_at_odd_positions)", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    import string\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_positions = {chr(ord('a') + i) for i in range(26) if i % 2 == 1}\n        return sum((1 for char in txt if char in odd_positions))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_positions = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25}\n        count = sum((1 for char in txt if char.islower() and ord(char) - ord('a') in odd_positions))\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_lowercase_count = sum(((ord(char) - ord('a')) % 2 != 0 for char in txt if 'a' <= char <= 'z'))\n        return odd_lowercase_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_positions = set([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25])\n        lowercase_letters = sum((1 for c in txt if c.islower() and ord(c) - ord('a') in odd_positions))\n        return lowercase_letters"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.8}}
{"task_id": "HumanEval/127", "requirement": "from typing import Tuple\n\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    length = intersection_end - intersection_start + 1\n    if intersection_start <= intersection_end and is_prime(length):\n        return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start <= intersection_end:\n        length = intersection_end - intersection_start + 1\n        if is_prime(length):\n            return 'YES'\n        else:\n            return 'NO'\n    else:\n        return 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersection = max(start1, start2)\n    end_intersection = min(end1, end2)\n    if start_intersection > end_intersection:\n        return 'NO'\n    length = end_intersection - start_intersection + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    intersection_length = max(0, end - start + 1)\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start <= end:\n        length = end - start + 1\n        return 'YES' if is_prime(length) else 'NO'\n    return 'NO'"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a unique value from 1 to N*N. \n\n    The task is to find the lexicographically smallest path of length k in the grid. \n    You can start from any cell and move to any of its neighboring cells (up, down, left, right), \n    but you cannot move off the grid. A path of length k means visiting exactly k cells, \n    which can be distinct or the same.\n\n    A path A is considered lexicographically smaller than a path B if the sequence of values \n    along path A is lexicographically smaller than the sequence of values along path B. \n    It is guaranteed that there is a unique lexicographically smallest path.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nimport itertools\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    max_val = n * n\n    flat_grid = sorted([(grid[i][j], (i, j)) for i in range(n) for j in range(n)])\n    sorted_values = [val[0] for val in flat_grid]\n    smallest_path = sorted_values[:k]\n    return smallest_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    n = len(grid)\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, [grid[i][j]])\n    return min(paths)", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    values_positions = [(grid[i][j], i, j) for i, j in product(range(N), range(N))]\n    values_positions.sort()\n\n    def dfs(path, x, y):\n        if len(path) == k:\n            return path\n        neighbors = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                neighbors.append((grid[nx][ny], nx, ny))\n        neighbors.sort()\n        for value, nx, ny in neighbors:\n            result = dfs(path + [value], nx, ny)\n            if result:\n                return result\n    path = []\n    for value, i, j in values_positions:\n        path = dfs([value], i, j)\n        if path:\n            break\n    return path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def neighbors(r, c):\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N:\n                yield (nr, nc)\n    N = len(grid)\n    lexicographical_paths = []\n    for r in range(N):\n        for c in range(N):\n            heap = [([grid[r][c]], r, c)]\n            while heap:\n                path, x, y = heapq.heappop(heap)\n                if len(path) == k:\n                    heapq.heappush(lexicographical_paths, path)\n                    break\n                for nx, ny in neighbors(x, y):\n                    heapq.heappush(heap, (path + [grid[nx][ny]], nx, ny))\n    return min(lexicographical_paths)", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from itertools import product\n    n = len(grid)\n    values = {}\n    for i in range(n):\n        for j in range(n):\n            values[grid[i][j]] = (i, j)\n    sorted_values = sorted(values.keys())\n\n    def is_valid(path):\n        positions = [values[v] for v in path]\n        for i in range(1, len(positions)):\n            x1, y1 = positions[i - 1]\n            x2, y2 = positions[i]\n            if abs(x1 - x2) + abs(y1 - y2) > 1:\n                return False\n        return True\n    for combination in product(sorted_values, repeat=k):\n        path = list(combination)\n        if is_valid(path):\n            return path", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    values = [(grid[i][j], i, j) for i, j in product(range(N), range(N))]\n    values.sort()\n    result = []\n    for _ in range(k):\n        result.append(values[0][0])\n    return result", "from typing import List\nimport itertools\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    values_to_positions = {}\n    for i in range(n):\n        for j in range(n):\n            values_to_positions[grid[i][j]] = (i, j)\n    ordered_values = sorted(values_to_positions.keys())\n\n    def is_valid_path(path):\n        for i in range(len(path) - 1):\n            x1, y1 = path[i]\n            x2, y2 = path[i + 1]\n            if abs(x1 - x2) + abs(y1 - y2) != 1:\n                return False\n        return True\n    min_lex_path = None\n    min_lex_sequence = None\n    for start_value in ordered_values:\n        start_pos = values_to_positions[start_value]\n        paths = itertools.product([start_pos] * (k - 1), repeat=1)\n        for path in paths:\n            full_path = [start_pos] + list(path)\n            if len(full_path) == k and is_valid_path(full_path):\n                sequence = [grid[x][y] for x, y in full_path]\n                if min_lex_sequence is None or sequence < min_lex_sequence:\n                    min_lex_sequence = sequence\n                    min_lex_path = full_path\n    return min_lex_sequence", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from heapq import heappush, heappop\n    N = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    heap = []\n    for i in range(N):\n        for j in range(N):\n            heappush(heap, (grid[i][j], [(i, j)]))\n    while heap:\n        value, path = heappop(heap)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        last_x, last_y = path[-1]\n        for dx, dy in directions:\n            new_x, new_y = (last_x + dx, last_y + dy)\n            if 0 <= new_x < N and 0 <= new_y < N:\n                heappush(heap, (value * 10 ** len(path) + grid[new_x][new_y], path + [(new_x, new_y)]))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(path, x, y):\n        if len(path) == k:\n            paths.append(path)\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                dfs(path + [grid[nx][ny]], nx, ny)\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            dfs([grid[i][j]], i, j)\n    return min(paths)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5555555555555556, "original_passk": 0.0}}
{"task_id": "HumanEval/130", "requirement": "from typing import List\n\ndef tri(n: int) -> List[float]:\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    - tri(0) = 1\n    - tri(1) = 3\n    - tri(n) = 1 + n / 2, if n is even and n > 1.\n    - tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd, where tri(n + 1) is calculated as 1 + (n + 1) / 2 if n + 1 is greater than the current length of the sequence being constructed.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 1 + (4 / 2) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = []\n    for i in range(n + 1):\n        if i == 0:\n            sequence.append(1)\n        elif i == 1:\n            sequence.append(3)\n        elif i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            if i + 1 > len(sequence):\n                sequence.append(1 + (i + 1) / 2)\n            sequence.append(sequence[i - 1] + sequence[i - 2] + sequence[i + 1])\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tribonacci_rec(idx: int, sequence: List[float]) -> float:\n        if idx % 2 == 0:\n            return 1 + idx / 2\n        else:\n            if idx + 1 >= len(sequence):\n                next_value = 1 + (idx + 1) / 2\n                sequence.append(next_value)\n            return sequence[idx - 1] + sequence[idx - 2] + sequence[idx + 1]\n    sequence = [1, 3] if n >= 1 else [1]\n    for i in range(2, n + 1):\n        sequence.append(tribonacci_rec(i, sequence))\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def calculate_tribonacci(seq, index):\n        if index % 2 == 0:\n            return 1 + index / 2\n        else:\n            while len(seq) <= index + 1:\n                seq.append(1 + len(seq) / 2)\n            return seq[index - 1] + seq[index - 2] + seq[index + 1]\n    tribonacci_sequence = [1, 3]\n    for i in range(2, n + 1):\n        tribonacci_sequence.append(calculate_tribonacci(tribonacci_sequence, i))\n    return tribonacci_sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 1) / 2)\n            sequence.append(next_value)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    result = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result.append(1 + i / 2)\n        else:\n            next_value = result[i - 1] + result[i - 2] + (1 + (i + 1) / 2)\n            result.append(next_value)\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    result = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result.append(1 + i / 2)\n        else:\n            result.append(result[i - 1] + result[i - 2] + (1 + (i + 1) / 2))\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            future_value = 1 + (i + 1) / 2\n            next_value += future_value\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[-1] + sequence[-2] + (1 + (i + 1) / 2)\n            sequence.append(next_value)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = []\n    for i in range(n + 1):\n        if i == 0:\n            sequence.append(1)\n        elif i == 1:\n            sequence.append(3)\n        elif i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = 1 + (i + 1) / 2\n            if i + 1 >= len(sequence):\n                sequence.append(next_value)\n            sequence.append(sequence[i - 1] + sequence[i - 2] + sequence[i + 1])\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            extended_index = i + 1\n            if extended_index >= len(sequence):\n                sequence.append(1 + extended_index / 2)\n            tri_plus_one = sequence[extended_index]\n            sequence[i] = sequence[i - 1] + sequence[i - 2] + tri_plus_one\n    return sequence"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.11111111111111116}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if there is any subsequence of brackets within the string\n    where at least one bracket is nested. A bracket is considered nested if it is enclosed by another pair of brackets.\n    The function does not require the entire string to be balanced.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_found = True\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/134", "requirement": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''", "generated_programs": ["def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt or not txt.strip():\n        return False\n    txt = txt.rstrip()\n    last_word_split = txt.split()\n    last_char = txt[-1]\n    return last_char.isalpha() and len(last_word_split[-1]) == 1", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.strip()\n    if not txt or not txt[-1].isalpha():\n        return False\n    return ' ' in txt and txt[-1].isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt or txt[-1].isspace() or (not txt[-1].isalpha()):\n        return False\n    words = txt.strip().split()\n    return len(words) > 0 and words[-1][-1].isalpha() and txt[-1].isalpha()", "import string\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    return txt[-1] in string.ascii_letters", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt.strip() or not txt.strip()[-1].isalpha():\n        return False\n    return len(txt.strip().split()[-1]) == 1", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.strip()\n    if not txt or not txt[-1].isalpha():\n        return False\n    words = txt.split()\n    return txt[-1] == words[-1][-1]", "import string\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt or not txt[-1].isalpha():\n        return False\n    return len(txt.split()[-1]) == 1", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.strip()\n    if not txt or txt[-1] == ' ':\n        return False\n    return txt[-1].isalpha() and ' ' in txt.split(txt[-1])[0]", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    return txt[-1].isalpha() and len(txt.split()[-1]) == 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/147", "requirement": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, create an integer array a of length n where each element a[i] is calculated as i * i - i + 1 for 1 ≤ i ≤ n.\n    Return the number of unique triples (a[i], a[j], a[k]) in the array such that i < j < k and the sum a[i] + a[j] + a[k] is divisible by 3.\n\n    Example:\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"", "generated_programs": ["def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from typing import List\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from typing import List\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    from itertools import combinations\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triples = combinations(a, 3)\n    count = sum((1 for triple in triples if sum(triple) % 3 == 0))\n    return count", "from typing import List\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/148", "requirement": "from typing import Tuple\n\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''", "generated_programs": ["from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start, end = sorted([index1, index2])\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start, end = sorted([idx1, idx2])\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start, end = sorted((index1, index2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1, index2 = (planets.index(planet1), planets.index(planet2))\n    start, end = sorted([index1, index2])\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start, end = (min(index1, index2), max(index1, index2))\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1, index2 = (planets.index(planet1), planets.index(planet2))\n    start, end = (min(index1, index2) + 1, max(index1, index2))\n    return tuple(planets[start:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    start, end = sorted([idx1, idx2])\n    return tuple(planets[start + 1:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    start, end = (min(index1, index2) + 1, max(index1, index2))\n    return tuple(planets[start:end])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1, index2 = (planets.index(planet1), planets.index(planet2))\n    if index1 < index2:\n        return tuple(planets[index1 + 1:index2])\n    else:\n        return tuple(planets[index2 + 1:index1])", "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1, index2 = (planets.index(planet1), planets.index(planet2))\n    if index1 > index2:\n        index1, index2 = (index2, index1)\n    return tuple(planets[index1 + 1:index2])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/151", "requirement": "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd and non-negative integers. Ignore any numbers\n    that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    If the input list is empty, return 0.\n    \n    Note: Only integer values are considered. Non-integer numbers are ignored.\n    '''", "generated_programs": ["from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 == 1)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 == 1)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x % 2 != 0 and (x >= 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x % 2 != 0 and (x >= 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if x % 2 != 0 and x >= 0 and isinstance(x, int)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 == 1)))", "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    return sum((x ** 2 for x in lst if isinstance(x, int) and x >= 0 and (x % 2 != 0)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given two words. You need to return True if any rotation of the second word is a substring of the first word.\n    \n    To achieve this, concatenate the second word with itself and check if any substring of the first word of length equal to the second word is found within this concatenated string.\n    \n    Examples:\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    doubled_b = b + b\n    return any((a[i:i + len(b)] in doubled_b for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    doubled_b = b + b\n    return any((doubled_b[i:i + len(b)] in a for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_word = b + b\n    return any((a[i:i + len(b)] in concatenated_word for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    return any((a[i:i + len(b)] in b + b for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    return any((b in (b + b)[i:i + len(b)] for i in range(len(b)))) and b in a", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    return any((a.find(concatenated_b[i:i + len(b)]) != -1 for i in range(len(b))))", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated_b = b + b\n    return any((a[i:i + len(b)] in concatenated_b for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    return any((a[i:i + len(b)] in b + b for i in range(len(a) - len(b) + 1)))", "def cycpattern_check(a: str, b: str) -> bool:\n    doubled_b = b + b\n    for i in range(len(a) - len(b) + 1):\n        if a[i:i + len(b)] in doubled_b:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    concatenated = b + b\n    for i in range(len(a) - len(b) + 1):\n        if a[i:i + len(b)] in concatenated:\n            return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/160", "requirement": "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Given two lists, `operators` and `operands`, construct an algebraic expression using these lists and evaluate it \n    while respecting standard operator precedence rules. The operators should be evaluated in the following order of \n    precedence: exponentiation (**), multiplication (*), floor division (//), addition (+), and subtraction (-). When \n    multiple operators of the same precedence level appear consecutively, they should be evaluated from left to right.\n\n    The basic algebra operations supported are:\n    - Addition ( + ) \n    - Subtraction ( - ) \n    - Multiplication ( * ) \n    - Floor division ( // ) \n    - Exponentiation ( ** ) \n\n    Example:\n    operators = ['+', '*', '-']\n    operands = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        - The length of the `operators` list is always one less than the length of the `operands` list.\n        - The `operands` list contains at least two integers.\n        - The `operators` list contains at least one operator.\n        - The function must respect the standard operator precedence rules during evaluation, evaluating \n          from left to right for operators of the same precedence level.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = []\n    for i in range(len(operands)):\n        expression.append(str(operands[i]))\n        if i < len(operators):\n            expression.append(operators[i])\n    return eval(''.join(expression))", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = []\n    for i in range(len(operators)):\n        expression.append(str(operands[i]))\n        expression.append(operators[i])\n    expression.append(str(operands[-1]))\n    precedence = {'**': 3, '*': 2, '//': 2, '+': 1, '-': 1}\n    stack = []\n    postfix = []\n\n    def apply_operator(op_stack, postfix_stack):\n        operator = op_stack.pop()\n        right = postfix_stack.pop()\n        left = postfix_stack.pop()\n        if operator == '**':\n            postfix_stack.append(left ** right)\n        elif operator == '*':\n            postfix_stack.append(left * right)\n        elif operator == '//':\n            postfix_stack.append(left // right)\n        elif operator == '+':\n            postfix_stack.append(left + right)\n        elif operator == '-':\n            postfix_stack.append(left - right)", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = str(operands[0])\n    for i in range(len(operators)):\n        expression += f' {operators[i]} {operands[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = str(operands[0])\n    for i in range(len(operators)):\n        expression += f' {operators[i]} {operands[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = str(operands[0])\n    for i, operator in enumerate(operators):\n        expression += f' {operator} {operands[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = ''\n    for i, num in enumerate(operands):\n        expression += str(num)\n        if i < len(operators):\n            expression += operators[i]\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = []\n    for i in range(len(operands)):\n        expression.append(str(operands[i]))\n        if i < len(operators):\n            expression.append(operators[i])\n    return eval(''.join(expression))", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    elements = []\n    for i, operand in enumerate(operands):\n        elements.append(operand)\n        if i < len(operators):\n            elements.append(operators[i])\n    precedence = {'**': 3, '*': 2, '//': 2, '+': 1, '-': 1}\n\n    def evaluate_operator(oper1, oper2, operator):\n        if operator == '**':\n            return oper1 ** oper2\n        elif operator == '*':\n            return oper1 * oper2\n        elif operator == '//':\n            return oper1 // oper2\n        elif operator == '+':\n            return oper1 + oper2\n        elif operator == '-':\n            return oper1 - oper2\n\n    def evaluate_expression(tokens):\n        while '**' in tokens:\n            idx = tokens.index('**')\n            tokens[idx - 1] = evaluate_operator(tokens[idx - 1], tokens[idx + 1], tokens[idx])\n            del tokens[idx:idx + 2]\n        while any((op in tokens for op in ['*', '//'])):\n            for op in tokens:\n                if op in ['*', '//']:\n                    idx = tokens.index(op)\n                    tokens[idx - 1] = evaluate_operator(tokens[idx - 1], tokens[idx + 1], tokens[idx])\n                    del tokens[idx:idx + 2]\n                    break\n        while any((op in tokens for op in ['+', '-'])):\n            for op in tokens:\n                if op in ['+', '-']:\n                    idx = tokens.index(op)\n                    tokens[idx - 1] = evaluate_operator(tokens[idx - 1], tokens[idx + 1], tokens[idx])\n                    del tokens[idx:idx + 2]\n                    break\n        return tokens[0]\n    return evaluate_expression(elements)", "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = str(operands[0])\n    for i in range(len(operators)):\n        expression += f' {operators[i]} {operands[i + 1]}'\n    return eval(expression)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return the numbers between a and b\n    (inclusive) that are composed entirely of even digits, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_composed_of_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if is_composed_of_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if has_only_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if has_only_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if is_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_composed_of_even_digits(num: int) -> bool:\n        while num > 0:\n            if num % 10 % 2 != 0:\n                return False\n            num //= 10\n        return True\n    low, high = (min(a, b), max(a, b))\n    return [x for x in range(low, high + 1) if is_composed_of_even_digits(x)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if has_only_even_digits(num)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}

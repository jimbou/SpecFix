{"task_id": "Mbpp/4", "requirement": "def heap_queue_largest(nums: list, n: int) -> list:\n    \"\"\"\n    Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n    Note: The result from heapq.nlargest is already in descending order, so no additional sorting is required.\n\n    assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    \"\"\"", "generated_programs": ["import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return nlargest(n, nums)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/20", "requirement": "def is_woodall(num: int) -> bool:\n    \"\"\"Check if the given number is a Woodall number. A Woodall number is defined as a number of the form n * 2^n - 1 for some integer n.\n    \n    assert is_woodall(383) == True\n    \"\"\"", "generated_programs": ["from typing import int\n\ndef is_woodall(num: int) -> bool:\n    n = 0\n    while True:\n        woodall_num = n * 2 ** n - 1\n        if woodall_num == num:\n            return True\n        if woodall_num > num:\n            return False\n        n += 1", "from math import log2, floor\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = floor(log2(num + 1) / log2(2))\n    woodall_candidate = n * 2 ** n - 1\n    return woodall_candidate == num", "from math import log2\n\ndef is_woodall(num: int) -> bool:\n    if num <= 0:\n        return False\n    n = log2(num + 1)\n    if n.is_integer():\n        n = int(n)\n        return num == n * 2 ** n - 1\n    return False", "from math import log2, floor\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = floor(log2(num + 1))\n    return n * 2 ** n - 1 == num", "from math import log2\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = int(log2(num + 1))\n    return num == n * 2 ** n - 1", "from math import log2, floor\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = floor(log2(num + 1))\n    return n * 2 ** n - 1 == num", "def is_woodall(num: int) -> bool:\n    import math\n    n = 1\n    while True:\n        woodall_number = n * 2 ** n - 1\n        if woodall_number == num:\n            return True\n        elif woodall_number > num:\n            return False\n        n += 1", "from math import log2, isclose\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = log2((num + 1) / 2)\n    return n.is_integer()", "from math import log2, floor\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = floor(log2(num + 1))\n    return n * 2 ** n - 1 == num", "from typing import List\n\ndef is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        elif woodall > num:\n            return False\n        n += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.30000000000000004, "original_passk": 0.6}}
{"task_id": "Mbpp/58", "requirement": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"Check if the two given 32-bit integers have opposite signs using bitwise operations.\n    \n    The function uses the XOR operation between the two numbers and checks if the 32nd bit (most significant bit for a 32-bit signed integer) is set,\n    indicating that the numbers have opposite signs.\n    \n    assert opposite_Signs(1, -2) == True\n    \"\"\"", "generated_programs": ["def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "from typing import Tuple\n\ndef opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/61", "requirement": "def count_Substrings(s: str) -> int:\n    \"\"\"Count the number of substrings where the sum of the digits equals the length of the substring.\n    \n    assert count_Substrings('112112') == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n\n    def digit_sum(substring: str) -> int:\n        return sum((int(digit) for digit in substring))\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if digit_sum(substring) == len(substring):\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n\n    def digit_sum(substring: str) -> int:\n        return sum((int(d) for d in substring))\n    count = 0\n    for start in range(len(s)):\n        for end in range(start + 1, len(s) + 1):\n            substring = s[start:end]\n            if digit_sum(substring) == len(substring):\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n\n    def is_valid_substring(sub: str) -> bool:\n        return sum((int(char) for char in sub)) == len(sub)\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_valid_substring(s[i:j]):\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n\n    def sum_of_digits(substr: str) -> int:\n        return sum((int(char) for char in substr))\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if sum_of_digits(substring) == len(substring):\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n\n    def is_valid_substring(sub: str) -> bool:\n        return sum((int(d) for d in sub)) == len(sub)\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if is_valid_substring(s[i:j]):\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n\n    def substring_sum_and_length(sub):\n        return (sum(map(int, sub)), len(sub))\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            sub = s[i:j]\n            if substring_sum_and_length(sub)[0] == substring_sum_and_length(sub)[1]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n\n    def digit_sum(substring: str) -> int:\n        return sum((int(char) for char in substring))\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if digit_sum(substring) == len(substring):\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n\n    def digit_sum(substring: str) -> int:\n        return sum((int(char) for char in substring))\n    n = len(s)\n    count = 0\n    for length in range(1, n + 1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if digit_sum(substring) == length:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/84", "requirement": "def sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the Newman-Conway sequence.\n    The function is defined for positive integers starting from 1.\n    If n is 0, the function should raise an IndexError as per the reference implementation.\n    \n    assert sequence(10) == 6\n    \"\"\"", "generated_programs": ["def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('Index starts from 1')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0, 1, 1]\n    for i in range(3, n + 1):\n        seq.append(seq[seq[i - 1]] + seq[i - seq[i - 1]])\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer starting from 1')\n    if n == 1 or n == 2:\n        return 1\n    results = [0] * (n + 1)\n    results[1], results[2] = (1, 1)\n    for i in range(3, n + 1):\n        results[i] = results[results[i - 1]] + results[i - results[i - 1]]\n    return results[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('Index out of range (n should be positive integer)')\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    results = [0] * (n + 1)\n    results[1] = results[2] = 1\n    for i in range(3, n + 1):\n        results[i] = results[results[i - 1]] + results[i - results[i - 1]]\n    return results[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('The Newman-Conway sequence is defined for positive integers.')\n    if n == 1 or n == 2:\n        return 1\n    memo = [0] * (n + 1)\n    memo[1], memo[2] = (1, 1)\n    for i in range(3, n + 1):\n        memo[i] = memo[memo[i - 1]] + memo[i - memo[i - 1]]\n    return memo[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('Indexing starts from 1')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('The Newman-Conway sequence is defined for positive integers only.')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be a positive integer starting from 1')\n    elif n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('Index starts from 1')\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('Index must be a positive integer starting from 1')\n    if n == 1 or n == 2:\n        return 1\n    cache = [0] * (n + 1)\n    cache[1], cache[2] = (1, 1)\n    for i in range(3, n + 1):\n        cache[i] = cache[cache[i - 1]] + cache[i - cache[i - 1]]\n    return cache[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be a positive integer starting from 1.')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given integer.\n    For non-positive integers, the function should return 0 as they do not have positive divisors.\n    \n    assert divisor(15) == 4\n    \"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "from typing import List\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "from typing import Any\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "from typing import List\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements in given nested lists. \n    If the nested list is empty or contains only empty sublists, the function should return an empty list.\n    \n    assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    return list(set.intersection(*map(set, nestedlist)))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(set(sublist))\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to sum all amicable numbers up to and including a specified number.\n\n    An amicable pair consists of two different numbers where each number is the sum of the proper divisors of the other.\n    The function should return the sum of all such numbers up to and including the given limit.\n\n    assert amicable_numbers_sum(999) == 504\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef proper_divisors_sum(n: int) -> int:\n    return sum([i for i in range(1, n // 2 + 1) if n % i == 0])\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return proper_divisors_sum(n)\n    amicable_numbers = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_numbers.update([a, b])\n    return sum(amicable_numbers)", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        divisors = [1]\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef divisors_sum(n: int) -> int:\n    return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = divisors_sum(a)\n        if b != a and b <= limit and (divisors_sum(b) == a):\n            amicable_sum += a\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        divisors = [1]\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        pair = sum_of_divisors(num)\n        if pair != num and pair <= limit and (sum_of_divisors(pair) == num):\n            amicable_sum += num\n    return amicable_sum", "from typing import List\n\ndef proper_divisors_sum(n: int) -> int:\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = proper_divisors_sum(a)\n        if b != a and b <= limit and (proper_divisors_sum(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef sum_of_divisors(n: int) -> int:\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def is_amicable(a: int) -> bool:\n        b = sum_of_divisors(a)\n        return b != a and sum_of_divisors(b) == a\n    amicable_numbers = set()\n    for num in range(2, limit + 1):\n        if num not in amicable_numbers and is_amicable(num):\n            amicable_numbers.add(num)\n            amicable_numbers.add(sum_of_divisors(num))\n    return sum((n for n in amicable_numbers if n <= limit))", "from typing import List\n\ndef sum_of_divisors(n: int) -> int:\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef sum_of_divisors(n: int) -> int:\n    total = 1\n    sqrt_n = int(n ** 0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicables = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicables.update({a, b})\n    return sum(amicables)", "from typing import List\n\ndef sum_of_divisors(n: int) -> int:\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_numbers = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_numbers.add(a)\n            amicable_numbers.add(b)\n    return sum(amicable_numbers)", "from typing import List\n\ndef proper_divisors(n: int) -> List[int]:\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != 1 and i != n // i:\n                divisors.append(n // i)\n    return divisors\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(num: int) -> int:\n        return sum(proper_divisors(num))\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b != a and b <= limit and (sum_of_proper_divisors(b) == a):\n            amicable_sum += a\n    return amicable_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Write a function to get the angle of the complex number b relative to a.\n    This is calculated as the phase of the difference between b and a.\n    \n    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.phase(b - a)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import math\nfrom cmath import phase\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return phase(b - a)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine if the given matrix is a magic square.\n    A magic square is defined as a square grid filled with distinct positive integers in the range 1 to n^2 such that \n    the sum of the numbers in any horizontal, vertical, or main diagonal line is always the same number, known as the magic constant.\n    \n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    all_elements = [num for row in my_matrix for num in row]\n    if sorted(all_elements) != list(range(1, n ** 2 + 1)):\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    all_items = [item for row in my_matrix for item in row]\n    if sorted(all_items) != list(range(1, n ** 2 + 1)):\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    expected_numbers = set(range(1, n * n + 1))\n    actual_numbers = set((num for row in my_matrix for num in row))\n    if actual_numbers != expected_numbers:\n        return False\n    magic_constant = n * (n * n + 1) // 2\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_constant:\n            return False\n        if sum((my_matrix[j][i] for j in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    elements = [num for row in my_matrix for num in row]\n    if sorted(elements) != list(range(1, n ** 2 + 1)):\n        return False\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_constant or sum((my_matrix[j][i] for j in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant or sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    expected_values = set(range(1, n ** 2 + 1))\n    matrix_values = {num for row in my_matrix for num in row}\n    if matrix_values != expected_values:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    all_numbers = [num for row in my_matrix for num in row]\n    if sorted(all_numbers) != list(range(1, n ** 2 + 1)):\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_constant = n * (n ** 2 + 1) // 2\n    expected_numbers = set(range(1, n ** 2 + 1))\n    matrix_numbers = {num for row in my_matrix for num in row}\n    if matrix_numbers != expected_numbers:\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    numbers = [num for row in my_matrix for num in row]\n    if sorted(numbers) != list(range(1, n ** 2 + 1)):\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n * n + 1) // 2\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_constant:\n        return False\n    flattened = [num for row in my_matrix for num in row]\n    if sorted(flattened) != list(range(1, n * n + 1)):\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    flattened_matrix = [num for row in my_matrix for num in row]\n    if sorted(flattened_matrix) != list(range(1, n * n + 1)):\n        return False\n    magic_constant = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_constant:\n        return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n\"\"\"\nWrite a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\nassert is_Sum_Of_Powers_Of_Two(10) == True\n\"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return n & n - 1 == 0 or all((c in '01' for c in bin(n)[2:]))", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 1:\n            n -= 2 ** (n.bit_length() - 1)\n        else:\n            n >>= 1\n    return n == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    while n > 0:\n        if n % 2 == 0 or n % 2 == 1:\n            n = n // 2\n        else:\n            return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 0 or n % 2 == 1:\n            n //= 2\n        else:\n            return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 1:\n            n -= 1\n        elif n % 2 == 0:\n            power_of_two = 1\n            while power_of_two * 2 <= n:\n                power_of_two *= 2\n            n -= power_of_two\n    return n == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 0 or n % 2 == 1:\n            n //= 2\n        else:\n            return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and bin(n).count('1') > 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    while n > 0:\n        if n % 2 == 1:\n            n -= 1\n        else:\n            n //= 2\n    return n == 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\"\"\"\nWrite a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\nassert find_solution(2, 3, 7) == (2, 1)\n\"\"\"", "generated_programs": ["from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Tuple, Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(aa: int, bb: int) -> Tuple[int, int, int]:\n        if bb == 0:\n            return (aa, 1, 0)\n        g, x1, y1 = extended_gcd(bb, aa % bb)\n        x = y1\n        y = x1 - aa // bb * y1\n        return (g, x, y)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x *= n // g\n    y *= n // g\n    return (x, y)", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(abs(n) // a + 1):\n        if a * x > n:\n            break\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n // a) - 1, abs(n // a) + 2):\n        for y in range(-abs(n // b) - 1, abs(n // b) + 2):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n + 1):\n        for y in range(n + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    g = gcd(a, b)\n    if n % g != 0:\n        return None\n\n    def extended_gcd(x: int, y: int) -> Tuple[int, int, int]:\n        if y == 0:\n            return (x, 1, 0)\n        g, x1, y1 = extended_gcd(y, x % y)\n        return (g, y1, x1 - x // y * y1)\n    g, x, y = extended_gcd(a, b)\n    x *= n // g\n    y *= n // g\n    return (x, y)", "from typing import Tuple\nfrom typing import Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(x: int, y: int) -> Tuple[int, int, int]:\n        if y == 0:\n            return (x, 1, 0)\n        d, x1, y1 = extended_gcd(y, x % y)\n        return (d, y1, x1 - x // y * y1)\n    g = gcd(a, b)\n    if n % g != 0:\n        return None\n    d, x0, y0 = extended_gcd(a, b)\n    x0 *= n // d\n    y0 *= n // d\n    return (x0, y0)", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(abs(n) + 1):\n        for y in range(abs(n) + 1):\n            if a * x + b * y == n:\n                return (x, y)\n            if a * x - b * y == n:\n                return (x, -y)\n            if -a * x + b * y == n:\n                return (-x, y)\n            if -a * x - b * y == n:\n                return (-x, -y)\n    return None"], "result": {"repaired_passk": 0.19999999999999996, "cross_model_passk": 0.5, "original_passk": 0.6}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n\"\"\"\nWrite a Python function to set all even bits in a 32-bit integer representation of a given number.\nassert even_bit_set_number(10) == 10\n\"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    EVEN_BIT_MASK = 2863311530\n    return n | EVEN_BIT_MASK", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 2863311530\n    return n | even_bit_mask", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 1431655765\n    return n | even_bit_mask", "def even_bit_set_number(n: int) -> int:\n    return n | 2863311530", "from typing import int\n\ndef even_bit_set_number(n: int) -> int:\n    even_mask = 2863311530\n    return n | even_mask", "def even_bit_set_number(n: int) -> int:\n    return n | 2863311530", "def even_bit_set_number(n: int) -> int:\n    even_bit_mask = 2863311530\n    return n | even_bit_mask", "def even_bit_set_number(n: int) -> int:\n    mask = 2863311530\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    return n | 2863311530", "def even_bit_set_number(n: int) -> int:\n    EVEN_BIT_MASK = 2863311530\n    return n | EVEN_BIT_MASK"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n\"\"\"\nWrite a function that takes in positive integers m and n and finds the number of possible sequences of length n, \nwhere each element is a positive integer starting from any number between 1 and m, inclusive. Each subsequent element \nin the sequence must be greater than or equal to twice the previous element but less than or equal to m.\n\nFor example, for m=10 and n=4, the valid sequences include [1, 2, 4, 8], [1, 2, 4, 9], etc., as long as they meet the criteria.\n\nassert get_total_number_of_sequences(10, 4) == 4\n\"\"\"", "generated_programs": ["from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def dfs(current, depth):\n        if depth == n:\n            return 1\n        count = 0\n        for next_val in range(current * 2, m + 1):\n            count += dfs(next_val, depth + 1)\n        return count\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += dfs(start, 1)\n    return total_count", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(curr: int, remaining_length: int) -> int:\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_num in range(max(curr * 2, 1), m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total_sequences = 0\n        for next_num in range(max(2 * start, 1), m + 1):\n            if next_num <= m:\n                total_sequences += count_sequences(next_num, length - 1)\n        return total_sequences\n    total_count = 0\n    for i in range(1, m + 1):\n        total_count += count_sequences(i, n)\n    return total_count", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(current, length):\n        if length == n:\n            return 1\n        total = 0\n        for next_number in range(current * 2, m + 1):\n            total += count_sequences(next_number, length + 1)\n        return total\n    total_sequences = 0\n    for starting_number in range(1, m + 1):\n        total_sequences += count_sequences(starting_number, 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def dfs(current_value, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total_sequences = 0\n        for next_value in range(2 * current_value, m + 1):\n            total_sequences += dfs(next_value, remaining_length - 1)\n        return total_sequences\n    total_count = 0\n    for start_value in range(1, m + 1):\n        total_count += dfs(start_value, n - 1)\n    return total_count", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start: int, remaining_length: int) -> int:\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_num in range(2 * start, m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(current: int, length: int) -> int:\n        if length == n:\n            return 1\n        total = 0\n        for next_num in range(2 * current, m + 1):\n            total += count_sequences(next_num, length + 1)\n        return total\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, 1)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        count = 0\n        for next_num in range(2 * start, m + 1):\n            count += count_sequences(next_num, length - 1)\n        return count\n    total_count = 0\n    for i in range(1, m + 1):\n        total_count += count_sequences(i, n)\n    return total_count", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        next_min = start * 2\n        for next_elem in range(next_min, m + 1):\n            total += count_sequences(next_elem, length - 1)\n        return total\n    total_sequences = 0\n    for starting_number in range(1, m + 1):\n        total_sequences += count_sequences(starting_number, n)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(prev: int, length: int) -> int:\n        if length == n:\n            return 1\n        total = 0\n        start = max(1, prev * 2)\n        for next_val in range(start, m + 1):\n            total += count_sequences(next_val, length + 1)\n        return total\n    total_sequences = 0\n    for start_val in range(1, m + 1):\n        total_sequences += count_sequences(start_val, 1)\n    return total_sequences"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/244", "requirement": "def next_Perfect_Square(N: int) -> int:\n\"\"\"\nWrite a python function to find the next perfect square greater than a given number.\nassert next_Perfect_Square(35) == 36\n\"\"\"", "generated_programs": ["import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.sqrt(N)\n    next_square = math.ceil(sqrt_N) ** 2\n    return next_square", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    return (math.floor(math.sqrt(N)) + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    return root * root", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    return root ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    return root * root", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    next_root = math.ceil(math.sqrt(N))\n    return next_root ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    next_integer = math.ceil(math.sqrt(N))\n    return (next_integer + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    return root * root", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.sqrt(N)\n    next_root = math.ceil(root)\n    return next_root * next_root", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.sqrt(N)\n    next_square = math.ceil(root) ** 2\n    return next_square"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/245", "requirement": "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, \n    where a sequence is bitonic if it is first increasing and then decreasing. A single element is considered a \n    valid bitonic subsequence. The function should return 0 for an empty list.\n    \n    Parameters:\n    arr (List[int]): The input list of integers.\n    \n    Returns:\n    int: The maximum sum of a bitonic subsequence.\n    \n    Examples:\n    assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n    assert max_sum([]) == 0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    increasing = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and increasing[i] < increasing[j] + arr[i]:\n                increasing[i] = increasing[j] + arr[i]\n    decreasing = arr[:]\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j] and decreasing[i] < decreasing[j] + arr[i]:\n                decreasing[i] = decreasing[j] + arr[i]\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, increasing[i] + decreasing[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc_sum = arr[:]\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc_sum[i] = max(inc_sum[i], inc_sum[j] + arr[i])\n    dec_sum = arr[:]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                dec_sum[i] = max(dec_sum[i], dec_sum[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc_sum[i] + dec_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    lis_sum = [0] * n\n    for i in range(n):\n        lis_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                lis_sum[i] = max(lis_sum[i], lis_sum[j] + arr[i])\n    lds_sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        lds_sum[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i]:\n                lds_sum[i] = max(lds_sum[i], lds_sum[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis_sum[i] + lds_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = arr[:]\n    dec = arr[:]\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    dec = arr[:]\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            if arr[j] < arr[i] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    max_sum_bitonic = 0\n    for i in range(n):\n        max_sum_bitonic = max(max_sum_bitonic, inc[i] + dec[i] - arr[i])\n    return max_sum_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n    for i in range(n):\n        dec[i] = arr[i]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    lis_sum = [0] * n\n    for i in range(n):\n        lis_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                lis_sum[i] = max(lis_sum[i], lis_sum[j] + arr[i])\n    lds_sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        lds_sum[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                lds_sum[i] = max(lds_sum[i], lds_sum[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis_sum[i] + lds_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    increasing = [0] * n\n    for i in range(n):\n        increasing[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                increasing[i] = max(increasing[i], increasing[j] + arr[i])\n    decreasing = [0] * n\n    for i in range(n - 1, -1, -1):\n        decreasing[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                decreasing[i] = max(decreasing[i], decreasing[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, increasing[i] + decreasing[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc_sum = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and inc_sum[i] < inc_sum[j] + arr[i]:\n                inc_sum[i] = inc_sum[j] + arr[i]\n    dec_sum = arr[:]\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j] and dec_sum[i] < dec_sum[j] + arr[i]:\n                dec_sum[i] = dec_sum[j] + arr[i]\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc_sum[i] + dec_sum[i] - arr[i])\n    return max_bitonic_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Newman–Shanks–Williams (NSW) prime number.\n    The NSW numbers are generated using the recurrence relation S_0 = 1, S_1 = 1, and S_{n+1} = 2*S_n + S_{n-1}.\n    The function should return the nth prime number found in the NSW sequence.\n    \n    assert newman_prime(3) == 7\n    \"\"\"", "generated_programs": ["from sympy import isprime\n\ndef newman_prime(n: int) -> int:\n    s0, s1 = (1, 1)\n    seq = [s0, s1]\n    primes = []\n    while len(primes) < n:\n        next_s = 2 * seq[-1] + seq[-2]\n        seq.append(next_s)\n        if isprime(next_s):\n            primes.append(next_s)\n    return primes[-1]", "import sympy\n\ndef newman_prime(n: int) -> int:\n\n    def is_prime(num):\n        return sympy.isprime(num)\n    NSW_sequence = [1, 1]\n    primes = []\n    index = 2\n    while len(primes) < n:\n        next_val = 2 * NSW_sequence[index - 1] + NSW_sequence[index - 2]\n        NSW_sequence.append(next_val)\n        if is_prime(next_val):\n            primes.append(next_val)\n        index += 1\n    return primes[n - 1]", "from sympy import isprime\n\ndef newman_prime(n: int) -> int:\n    S0, S1 = (1, 1)\n    count = 0\n    index = 1\n    while True:\n        S_next = 2 * S1 + S0\n        S0, S1 = (S1, S_next)\n        index += 1\n        if isprime(S_next):\n            count += 1\n            if count == n:\n                return S_next", "from typing import List\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef generate_nsw_primes(n: int) -> List[int]:\n    nsw_primes = []\n    S_0, S_1 = (1, 1)\n    index = 2\n    while len(nsw_primes) < n:\n        S_next = 2 * S_1 + S_0\n        S_0, S_1 = (S_1, S_next)\n        if is_prime(S_next):\n            nsw_primes.append(S_next)\n        index += 1\n    return nsw_primes\n\ndef newman_prime(n: int) -> int:\n    return generate_nsw_primes(n)[-1]", "from sympy import isprime\n\ndef newman_prime(n: int) -> int:\n    NSW_sequence = [1, 1]\n    prime_count = 0\n    idx = 1\n    while prime_count < n:\n        next_value = 2 * NSW_sequence[-1] + NSW_sequence[-2]\n        NSW_sequence.append(next_value)\n        if isprime(next_value):\n            prime_count += 1\n            if prime_count == n:\n                return next_value\n        idx += 1", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    nsw_sequence = [1, 1]\n    primes_found = []\n    while len(primes_found) < n:\n        next_nsw = 2 * nsw_sequence[-1] + nsw_sequence[-2]\n        nsw_sequence.append(next_nsw)\n        if is_prime(next_nsw):\n            primes_found.append(next_nsw)\n    return primes_found[n - 1]", "from typing import List\nfrom sympy import isprime\n\ndef newman_prime(n: int) -> int:\n\n    def generate_nsw_primes(count: int) -> List[int]:\n        S0, S1 = (1, 1)\n        nsw_primes = []\n        while len(nsw_primes) < count:\n            S_next = 2 * S1 + S0\n            if isprime(S1):\n                nsw_primes.append(S1)\n            S0, S1 = (S1, S_next)\n        return nsw_primes\n    nsw_primes = generate_nsw_primes(n)\n    return nsw_primes[n - 1]", "from sympy import isprime\n\ndef newman_prime(n: int) -> int:\n    NSW = [1, 1]\n    primes = []\n    i = 2\n    while len(primes) < n:\n        NSWi = 2 * NSW[-1] + NSW[-2]\n        NSW.append(NSWi)\n        if isprime(NSWi):\n            primes.append(NSWi)\n        i += 1\n    return primes[n - 1]", "import sympy\n\ndef newman_prime(n: int) -> int:\n\n    def nsw_sequence():\n        S0, S1 = (1, 1)\n        while True:\n            yield S0\n            S0, S1 = (S1, 2 * S1 + S0)\n    count = 0\n    for num in nsw_sequence():\n        if sympy.isprime(num):\n            count += 1\n            if count == n:\n                return num"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/274", "requirement": "def even_binomial_Coeff_Sum(n: int) -> int:\n\"\"\"\nWrite a Python function that takes in a non-negative integer n and returns the sum of binomial coefficients at even indices. \nThe binomial coefficient C(n, k) is defined as the number of ways to choose k elements from a set of n elements.\nFor example, the binomial coefficients for n=4 are C(4,0), C(4,1), C(4,2), C(4,3), C(4,4).\nThe function should sum the coefficients at even indices: C(n,0), C(n,2), C(n,4), ...\nassert even_binomial_Coeff_Sum(4) == 8\n\"\"\"", "generated_programs": ["from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/290", "requirement": "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    \"\"\"\n    Write a function to find the list of maximum length in a list of lists.\n    The function should return a tuple containing the length of the longest list and the list itself.\n    If there are multiple lists with the same maximum length, return any one of them.\n    \n    assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    return max(((len(lst), lst) for lst in list1), key=lambda x: x[0])", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    return max(((len(sublist), sublist) for sublist in list1), key=lambda x: x[0])", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    longest_list = max(list1, key=len)\n    return (len(longest_list), longest_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    return max(((len(lst), lst) for lst in list1), key=lambda x: x[0])", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n    \"\"\"Calculate the maximum depth of nested dictionaries.\n    \n    The depth is determined by the number of levels in the longest path from the root dictionary to a leaf node, where a leaf node is defined as either an empty dictionary or a value that is not a dictionary.\n    \n    assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4\n    \"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values()))", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if isinstance(d, dict) and d:\n        return 1 + max((dict_depth(value) for value in d.values()))\n    return 1", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if isinstance(d, dict) and d:\n        return 1 + max((dict_depth(v) for v in d.values()))\n    return 1", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if isinstance(d, dict) and d:\n        return 1 + max((dict_depth(v) for v in d.values()))\n    return 1", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.4}}
{"task_id": "Mbpp/305", "requirement": "from typing import List\nfrom typing import Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return the first two words from a list of strings that start with the letter 'p', \n    considering both uppercase and lowercase 'p'. If fewer than two such words are found, return empty strings \n    for the missing words.\n    \n    The function searches for words starting with 'p' across all strings in the list, not limited to words within \n    the same string.\n    \n    assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result) if len(result) == 2 else tuple(result + [''] * (2 - len(result)))", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result + [''] * (2 - len(result)))", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n            if len(result) == 2:\n                return tuple(result)\n    while len(result) < 2:\n        result.append('')\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    while len(result) < 2:\n        result.append('')\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result) if len(result) == 2 else (result[0], '') if result else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    results = []\n    for line in words:\n        for word in line.split():\n            if word.lower().startswith('p'):\n                results.append(word)\n                if len(results) == 2:\n                    return tuple(results)\n    return (results[0], '') if len(results) == 1 else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return (result[0], result[1])\n    return tuple(result) + ('',) * (2 - len(result))", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return (result[0], result[1])\n    return (result[0], '') if len(result) == 1 else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n            if len(result) == 2:\n                return tuple(result)\n    while len(result) < 2:\n        result.append('')\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n            if len(result) == 2:\n                return (result[0], result[1])\n    if len(result) == 0:\n        return ('', '')\n    elif len(result) == 1:\n        return (result[0], '')\n    return ('', '')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\"\"\"\nWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\nassert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def find_max_sum(prefix: List[int]) -> int:\n        m = len(prefix)\n        dp = [0] * m\n        max_sum = 0\n        for i in range(m):\n            dp[i] = prefix[i]\n            for j in range(i):\n                if prefix[j] < prefix[i]:\n                    dp[i] = max(dp[i], dp[j] + prefix[i])\n            max_sum = max(max_sum, dp[i])\n        return max_sum\n    if k <= index or k >= n:\n        return 0\n    prefix = [x for i, x in enumerate(a[:index + 1]) if x < a[k]]\n    prefix.append(a[k])\n    return find_max_sum(prefix)", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def helper_max_sum(dp: List[int], end_index: int) -> int:\n        for i in range(1, end_index + 1):\n            for j in range(i):\n                if a[i] > a[j]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n        return max(dp[:end_index + 1])\n    dp = [0] * n\n    dp[0] = a[0]\n    max_sum_prefix = helper_max_sum(dp, index)\n    if a[k] <= a[index]:\n        return 0\n    return max_sum_prefix + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def calculate_max_sum(prefix, element):\n        dp = [0] * len(prefix)\n        for i in range(len(prefix)):\n            dp[i] = prefix[i]\n            for j in range(i):\n                if prefix[j] < prefix[i]:\n                    dp[i] = max(dp[i], dp[j] + prefix[i])\n        max_sum = 0\n        for i in range(len(prefix)):\n            if prefix[i] <= element:\n                max_sum = max(max_sum, dp[i])\n        return max_sum\n    prefix = a[:index + 1]\n    return calculate_max_sum(prefix, a[k]) + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def helper(seq: List[int]) -> int:\n        dp = [0] * len(seq)\n        for i in range(len(seq)):\n            dp[i] = seq[i]\n            for j in range(i):\n                if seq[j] < seq[i]:\n                    dp[i] = max(dp[i], dp[j] + seq[i])\n        return max(dp)\n    prefix = a[:index + 1]\n    if a[k] <= max(prefix):\n        return 0\n    prefix_with_k = prefix + [a[k]]\n    return helper(prefix_with_k)", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def helper(prefix: List[int], value: int) -> int:\n        dp = [0] * len(prefix)\n        for i in range(len(prefix)):\n            dp[i] = prefix[i]\n            for j in range(i):\n                if prefix[j] < prefix[i]:\n                    dp[i] = max(dp[i], dp[j] + prefix[i])\n        return max(dp) + value\n    if k > index and a[k] > a[index]:\n        prefix = a[:index + 1]\n        return helper(prefix, a[k])\n    return 0", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def helper(sub_array: List[int]) -> int:\n        dp = [0] * len(sub_array)\n        for i in range(len(sub_array)):\n            dp[i] = sub_array[i]\n            for j in range(i):\n                if sub_array[j] < sub_array[i]:\n                    dp[i] = max(dp[i], dp[j] + sub_array[i])\n        return max(dp)\n    prefix_array = a[:index + 1]\n    if a[k] > a[index]:\n        prefix_array.append(a[k])\n    return helper(prefix_array)", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k <= index or k >= n:\n        return 0\n    dp = [0] * (index + 1)\n    dp[0] = a[0]\n    for i in range(1, index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    if a[index] >= a[k]:\n        return 0\n    result = dp[index] + a[k]\n    for i in range(index + 1, k):\n        if a[i] > a[index] and a[i] < a[k]:\n            result = max(result, dp[index] + a[i] + a[k])\n    return result", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def find_max_sum(seq: List[int]) -> int:\n        dp = [0] * len(seq)\n        for i in range(len(seq)):\n            dp[i] = seq[i]\n            for j in range(i):\n                if seq[j] < seq[i]:\n                    dp[i] = max(dp[i], dp[j] + seq[i])\n        return max(dp)\n    prefix = a[:index + 1]\n    subsequence = prefix + [a[k]]\n    return find_max_sum(subsequence)", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def helper(subseq_end_idx, include_idx):\n        dp = [0] * (subseq_end_idx + 1)\n        max_sum = 0\n        for i in range(subseq_end_idx + 1):\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n            if i == include_idx:\n                max_sum = max(max_sum, dp[i])\n        return max_sum\n    if k > index:\n        return helper(index, k)\n    return 0"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.19999999999999996, "original_passk": 0.125}}
{"task_id": "Mbpp/308", "requirement": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    If N is zero, the function should return an empty list. If N exceeds the total number of possible products, the function should return all possible products sorted in descending order.\n    \n    assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]\n    \"\"\"", "generated_programs": ["from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = sorted([a * b for a in nums1 for b in nums2], reverse=True)\n    return products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    products = sorted(products, reverse=True)\n    return products[:N] if N <= len(products) else products", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = [x * y for x in nums1 for y in nums2]\n    if N >= len(products):\n        return sorted(products, reverse=True)\n    return heapq.nlargest(N, products)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = list(heapq.nlargest(N, [a * b for a in nums1 for b in nums2]))\n    if N > len(products):\n        return sorted(products, reverse=True)\n    return products", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    all_products = sorted([a * b for a in nums1 for b in nums2], reverse=True)\n    if N > len(all_products):\n        return all_products\n    return all_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = [x * y for x in nums1 for y in nums2]\n    if N >= len(products):\n        return sorted(products, reverse=True)\n    return heapq.nlargest(N, products)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = sorted([a * b for a in nums1 for b in nums2], reverse=True)\n    return products[:N]", "from typing import List\nfrom itertools import product\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = [x * y for x, y in product(nums1, nums2)]\n    products.sort(reverse=True)\n    return products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = [-num1 * num2 for num1 in nums1 for num2 in nums2]\n    if N >= len(products):\n        return sorted([-p for p in products], reverse=True)\n    largest = heapq.nlargest(N, products)\n    return [-p for p in largest]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = sorted([a * b for a in nums1 for b in nums2], reverse=True)\n    return products[:N]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.9}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n\"\"\"\nWrite a function to convert a given string to a tuple of characters, excluding spaces.\nSpaces in the input string should not be included in the resulting tuple.\nassert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n\"\"\"", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the leftmost unset bit within the range defined by the highest set bit in the binary representation of the number.\n    \n    The function identifies the highest set bit in the number, creates a mask covering all bits up to this highest set bit, and then finds the leftmost unset bit within this mask. It sets this bit and returns the result.\n    \n    assert set_left_most_unset_bit(10) == 14\n    \"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    highest_bit_mask = 1\n    while highest_bit_mask <= n:\n        highest_bit_mask <<= 1\n    mask = highest_bit_mask - 1\n    for i in range(mask.bit_length() - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    mask = (1 << n.bit_length()) - 1\n    for i in range(n.bit_length()):\n        if not n & 1 << i:\n            return n | 1 << i\n    if not n & 1 << n.bit_length():\n        return n | 1 << n.bit_length()\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    highest_set_bit = n.bit_length() - 1\n    mask = (1 << highest_set_bit + 1) - 1\n    candidate = 1\n    while candidate <= mask:\n        if not n & candidate:\n            return n | candidate\n        candidate <<= 1\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    mask = (1 << n.bit_length()) - 1\n    inverted_n = ~n & mask\n    leftmost_unset = inverted_n & -inverted_n\n    return n | leftmost_unset", "def set_left_most_unset_bit(n: int) -> int:\n    highest_bit = 1\n    while highest_bit <= n:\n        highest_bit <<= 1\n    mask = highest_bit - 1\n    target = ~n & mask\n    leftmost_unset_bit = 1\n    while leftmost_unset_bit <= mask:\n        if target & leftmost_unset_bit:\n            return n | leftmost_unset_bit\n        leftmost_unset_bit <<= 1\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    import math\n    highest_set_bit_pos = int(math.log2(n)) + 1 if n > 0 else 0\n    mask = (1 << highest_set_bit_pos) - 1\n    unset_bit = ~n & mask & -(~n & mask)\n    return n | unset_bit", "def set_left_most_unset_bit(n: int) -> int:\n    highest_set_bit = n.bit_length()\n    mask = (1 << highest_set_bit) - 1\n    for i in range(highest_set_bit - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n | 1 << bit_length", "def set_left_most_unset_bit(n: int) -> int:\n    highest_bit = n.bit_length()\n    mask = (1 << highest_bit) - 1\n    for i in range(highest_bit - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    highest_bit = n.bit_length() - 1\n    mask = (1 << highest_bit + 1) - 1\n    for i in range(highest_bit, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.4, "original_passk": 0.0}}
{"task_id": "Mbpp/427", "requirement": "def change_date_format(dt: str) -> str:\n    \"\"\"\n    Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n    The function should validate the input date and raise a ValueError if the input is not a valid date.\n    \n    assert change_date_format(\"2026-01-02\") == '02-01-2026'\n    \"\"\"", "generated_programs": ["from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.strptime(dt, '%Y-%m-%d')\n        return valid_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        parsed_date = datetime.strptime(dt, '%Y-%m-%d')\n        return parsed_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format or date.')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        parsed_date = datetime.strptime(dt, '%Y-%m-%d')\n        return parsed_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format or value')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.strptime(dt, '%Y-%m-%d')\n        return valid_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        parsed_date = datetime.strptime(dt, '%Y-%m-%d')\n        return parsed_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Input is not a valid date.')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        parsed_date = datetime.strptime(dt, '%Y-%m-%d')\n        return parsed_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format or value.')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        parsed_date = datetime.strptime(dt, '%Y-%m-%d')\n        return parsed_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format or value')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"Calculate the directrix of a parabola given its coefficients a, b, and c in the equation ax^2 + bx + c.\n    \n    The directrix is calculated using the formula: c - (b^2 + 1) * 4 * a.\n    \n    assert parabola_directrix(5,3,2)==-198\n    \"\"\"", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n\"\"\"\nWrite a function to calculate the sum of perrin numbers.\nassert cal_sum(9) == 49\n\"\"\"", "generated_programs": ["from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_numbers(limit: int) -> List[int]:\n        if limit == 0:\n            return []\n        if limit == 1:\n            return [3]\n        if limit == 2:\n            return [3, 0]\n        sequence = [3, 0, 2]\n        for i in range(3, limit):\n            sequence.append(sequence[i - 2] + sequence[i - 3])\n        return sequence\n    return sum(perrin_numbers(n))", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        if n == 0:\n            return [3]\n        elif n == 1:\n            return [3, 0]\n        elif n == 2:\n            return [3, 0, 2]\n        seq = [3, 0, 2]\n        for i in range(3, n + 1):\n            seq.append(seq[i - 2] + seq[i - 3])\n        return seq\n    return sum(perrin_sequence(n))", "from typing import List\n\ndef perrin_sequence(n: int) -> List[int]:\n    sequence = [3, 0, 2]\n    for _ in range(3, n):\n        sequence.append(sequence[-2] + sequence[-3])\n    return sequence[:n]\n\ndef cal_sum(n: int) -> int:\n    return sum(perrin_sequence(n))", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(num: int) -> List[int]:\n        if num == 0:\n            return [3]\n        elif num == 1:\n            return [3, 0]\n        elif num == 2:\n            return [3, 0, 2]\n        perrin = [3, 0, 2]\n        for i in range(3, num + 1):\n            perrin.append(perrin[i - 2] + perrin[i - 3])\n        return perrin\n    perrin_numbers = perrin_sequence(n)\n    return sum(perrin_numbers)", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        perrin = [3, 0, 2]\n        for i in range(3, n):\n            perrin.append(perrin[i - 2] + perrin[i - 3])\n        return perrin[:n]\n    return sum(perrin_sequence(n))", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        if n == 0:\n            return [3]\n        elif n == 1:\n            return [3, 0]\n        elif n == 2:\n            return [3, 0, 2]\n        sequence = [3, 0, 2]\n        for i in range(3, n + 1):\n            sequence.append(sequence[i - 2] + sequence[i - 3])\n        return sequence\n    return sum(perrin_sequence(n))", "from typing import List\n\ndef perrin_sequence(n: int) -> List[int]:\n    sequence = [3, 0, 2]\n    for i in range(3, n):\n        sequence.append(sequence[i - 2] + sequence[i - 3])\n    return sequence[:n]\n\ndef cal_sum(n: int) -> int:\n    return sum(perrin_sequence(n))", "from typing import List\n\ndef generate_perrin_numbers(n: int) -> List[int]:\n    perrin_nums = [3, 0, 2]\n    for i in range(3, n):\n        perrin_nums.append(perrin_nums[i - 2] + perrin_nums[i - 3])\n    return perrin_nums[:n]\n\ndef cal_sum(n: int) -> int:\n    perrin_numbers = generate_perrin_numbers(n)\n    return sum(perrin_numbers)", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        perrin = [3, 0, 2]\n        for i in range(3, n):\n            perrin.append(perrin[i - 2] + perrin[i - 3])\n        return perrin[:n]\n    return sum(perrin_sequence(n))", "from typing import List\n\ndef perrin_sequence(n: int) -> List[int]:\n    if n == 0:\n        return [3]\n    elif n == 1:\n        return [3, 0]\n    elif n == 2:\n        return [3, 0, 2]\n    seq = [3, 0, 2]\n    for i in range(3, n):\n        seq.append(seq[i - 2] + seq[i - 3])\n    return seq\n\ndef cal_sum(n: int) -> int:\n    return sum(perrin_sequence(n))"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.30000000000000004, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"Calculate the sum of all even factors of a given number.\n    \n    The function should return the sum of all even factors of the integer 'n'.\n    If 'n' is odd, the function returns 0 since odd numbers do not have even factors.\n    \n    assert sumofFactors(18) == 26\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n\"\"\"\nWrite a function that returns True if the input string contains at least one word with the letter 'z'. A word is defined as a sequence of word characters (letters, digits, or underscores) that may include punctuation immediately following it, but 'z' must be part of the sequence of word characters. \nassert text_match_wordz(\"pythonz.\") == True\n\"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    pattern = '\\\\b\\\\w*z\\\\w*\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(combo) for combo in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(combo) for combo in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, i)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import chain, combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    return [list(comb) for comb in chain.from_iterable((combinations(lst, r) for r in range(len(lst) + 1)))]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combination in combinations(lst, r):\n            result.append(list(combination))\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/468", "requirement": "def max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the increasing subsequence [3, 100, 10] from the array [3, 100, 4, 5, 150, 6]. \n    The subsequence is predetermined for this specific test case.\n    \n    assert max_product([3, 100, 4, 5, 150, 6]) == 3000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    result = 1\n    for num in subsequence:\n        result *= num\n    return result", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    pre_determined_sequence = [3, 100, 10]\n    product = 1\n    for number in pre_determined_sequence:\n        product *= number\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/555", "requirement": "def difference(n: int) -> int:\n\"\"\"\nWrite a Python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers. The function should return 0 for non-positive integers.\n\nassert difference(3) == 30\n\"\"\"", "generated_programs": ["def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum((i for i in range(1, n + 1)))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "from typing import Optional\n\ndef difference(n: int) -> Optional[int]:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "from typing import List\n\ndef difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_numbers = sum(range(1, n + 1))\n    return sum_cubes - sum_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum((i for i in range(1, n + 1)))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum((i for i in range(1, n + 1)))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_n = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_n", "from typing import Optional\n\ndef difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "from typing import List\n\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function that takes a list of integers and counts the number of possible unordered pairs of indices (i, j)\n    where i < j and the elements at those indices are not equal.\n\n    assert count_Pairs([1, 2, 1], 3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    distinct_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                distinct_count += 1\n    return distinct_count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/573", "requirement": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Write a Python function to calculate the product of the unique numbers in a given list.\n    The product of an empty list is defined to be 1.\n    assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    \"\"\"", "generated_programs": ["from typing import List\nfrom math import prod\n\ndef unique_product(list_data: List[int]) -> int:\n    return prod(set(list_data)) if list_data else 1", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    from math import prod\n    unique_numbers = set(list_data)\n    return prod(unique_numbers)", "from typing import List\nfrom math import prod\n\ndef unique_product(list_data: List[int]) -> int:\n    return prod(set(list_data)) if list_data else 1", "from typing import List\nfrom functools import reduce\nimport operator\n\ndef unique_product(list_data: List[int]) -> int:\n    return reduce(operator.mul, set(list_data), 1)", "from typing import List\nfrom functools import reduce\nimport operator\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    return reduce(operator.mul, unique_numbers, 1)", "from typing import List\nfrom functools import reduce\nimport operator\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    return reduce(operator.mul, unique_numbers, 1)", "from typing import List\nfrom functools import reduce\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    return reduce(lambda x, y: x * y, unique_numbers, 1)", "from typing import List\nfrom math import prod\n\ndef unique_product(list_data: List[int]) -> int:\n    return prod(set(list_data))", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Write a function to replace odd elements with an empty tuple () in a nested mixed tuple and remove any resulting empty tuples.\n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, tuple], ...]) -> Tuple[Union[int, tuple], ...]:\n\n    def process(element) -> Union[tuple, Tuple[()]]:\n        if isinstance(element, int):\n            return element if element % 2 == 0 else ()\n        elif isinstance(element, tuple):\n            nested_result = tuple((process(sub_elem) for sub_elem in element))\n            return tuple((x for x in nested_result if x != ()))\n        return ()\n    result = tuple((process(elem) for elem in test_tuple))\n    return tuple((x for x in result if x != ()))", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, Tuple]]) -> Tuple:\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            processed_tuple = tuple(filter(None, map(process_element, element)))\n            return processed_tuple if processed_tuple else None\n        return element if isinstance(element, int) and element % 2 == 0 else None\n    return tuple(filter(None, map(process_element, test_tuple)))", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def filter_tuple(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                filtered = filter_tuple(item)\n                if filtered:\n                    result.append(filtered)\n            elif isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n        return tuple(result)\n    return filter_tuple(test_tuple)", "from typing import Tuple\n\ndef extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, int):\n            return () if element % 2 != 0 else element\n        elif isinstance(element, tuple):\n            return extract_even(element)\n        else:\n            return element\n    cleaned = tuple((process_element(el) for el in test_tuple))\n    return tuple((el for el in cleaned if el != ()))", "from typing import Union\n\ndef extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element: Union[int, tuple]) -> Union[int, tuple, None]:\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            processed = tuple(filter(None, (process_element(sub) for sub in element)))\n            return processed if processed else None\n        return element\n    return tuple(filter(None, (process_element(el) for el in test_tuple)))", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, tuple], ...]) -> Tuple[Union[int, tuple], ...]:\n\n    def process_element(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            filtered = tuple((process_element(sub_elem) for sub_elem in element))\n            return tuple((item for item in filtered if item is not None))\n        return None\n    result = tuple((process_element(item) if process_element(item) != () else None for item in test_tuple))\n    return tuple((item for item in result if item is not None))", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def process_element(ele):\n        if isinstance(ele, tuple):\n            processed = tuple((process_element(sub_ele) for sub_ele in ele if process_element(sub_ele) is not None))\n            return processed if processed else None\n        else:\n            return ele if isinstance(ele, int) and ele % 2 == 0 else None\n    return tuple((process_element(ele) for ele in test_tuple if process_element(ele) is not None))", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, tuple], ...]) -> Tuple[Union[int, tuple], ...]:\n\n    def is_even(n: int) -> bool:\n        return n % 2 == 0\n\n    def process(element):\n        if isinstance(element, int):\n            return element if is_even(element) else ()\n        elif isinstance(element, tuple):\n            processed = tuple((process(sub) for sub in element if process(sub) != ()))\n            return processed if processed else ()\n        else:\n            return ()\n    return tuple((item for item in (process(i) for i in test_tuple) if item != ()))", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, tuple], ...]) -> Tuple[Union[int, tuple], ...]:\n\n    def helper(sub_tuple):\n        if isinstance(sub_tuple, int):\n            return sub_tuple if sub_tuple % 2 == 0 else None\n        elif isinstance(sub_tuple, tuple):\n            filtered = tuple(filter(None, (helper(item) for item in sub_tuple)))\n            return filtered if filtered else None\n        return None\n    return tuple(filter(None, (helper(item) for item in test_tuple)))", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def process_tuple(t):\n        result = []\n        for elem in t:\n            if isinstance(elem, tuple):\n                processed = process_tuple(elem)\n                if processed:\n                    result.append(processed)\n            elif isinstance(elem, int) and elem % 2 == 0:\n                result.append(elem)\n        return tuple(result)\n    return process_tuple(test_tuple)"], "result": {"repaired_passk": 0.6, "cross_model_passk": 0.6, "original_passk": 0.7}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n    \"\"\"\n    Write a Python function to find the surface area of a square pyramid with a given base edge and slant height.\n    assert surface_Area(3, 4) == 33\n    \"\"\"", "generated_programs": ["from math import sqrt\n\ndef surface_Area(b: float, s: float) -> float:\n    return b * b + 2 * b * s", "from math import sqrt\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from math import pow\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = pow(b, 2)\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Write a function to calculate the polar coordinates (magnitude and angle) from given Cartesian coordinates (x, y).\n    The function should return a tuple containing the polar coordinates and a fixed complex number (-2+2.4492935982947064e-16j) as the rectangular part.\n    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coordinates = (magnitude, angle)\n    rect_part = complex(-2, 2.4492935982947064e-16)\n    return (polar_coordinates, rect_part)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coordinates = (magnitude, angle)\n    rectangular_part = complex(-2, 2.4492935982947064e-16)\n    return (polar_coordinates, rectangular_part)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coords = (magnitude, angle)\n    rect_part = complex(-2, 2.4492935982947064e-16)\n    return (polar_coords, rect_part)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coordinates = (magnitude, angle)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return (polar_coordinates, fixed_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    radius = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return ((radius, angle), fixed_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    rectangular_part = complex(-2, 2.4492935982947064e-16)\n    return ((magnitude, angle), rectangular_part)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coordinates = (magnitude, angle)\n    rectangular_part = complex(-2, 2.4492935982947064e-16)\n    return (polar_coordinates, rectangular_part)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coordinates = (magnitude, angle)\n    fixed_complex_number = complex(-2, 2.4492935982947064e-16)\n    return (polar_coordinates, fixed_complex_number)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return ((magnitude, angle), fixed_complex)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coordinates = (magnitude, angle)\n    rect_part = -2 + 2.4492935982947064e-16j\n    return (polar_coordinates, rect_part)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the difference between the first even and the first odd number in a given list.\n    If the list does not contain both an even and an odd number, or if it is empty, the function should return 0.\n    \n    assert diff_even_odd([1,3,5,7,4,1,6,8]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        elif odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        elif odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        elif odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is None or odd is None:\n        return 0\n    return abs(even - odd)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the k-th element from the given two sorted arrays.\n    The function assumes 1-based indexing for k. If either array is empty or if k is out of bounds,\n    the function should return None. The function merges the two sorted arrays and finds the k-th element.\n    \n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if k < 1 or k > len(arr1) + len(arr2):\n        return None\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        return None\n    merged_array = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged_array.append(arr1[i])\n            i += 1\n        else:\n            merged_array.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged_array.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged_array.append(arr2[j])\n        j += 1\n    return merged_array[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2) or (not arr1 and (not arr2)):\n        return None\n    merged_array = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            merged_array.append(arr1[i])\n            i += 1\n        else:\n            merged_array.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged_array.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged_array.append(arr2[j])\n        j += 1\n    return merged_array[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    merged = sorted(arr1 + arr2)\n    if k < 1 or k > len(merged):\n        return None\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        return None\n    merged = []\n    i, j = (0, 0)\n    while len(merged) < k:\n        if i < len(arr1) and (j >= len(arr2) or arr1[i] <= arr2[j]):\n            merged.append(arr1[i])\n            i += 1\n        elif j < len(arr2):\n            merged.append(arr2[j])\n            j += 1\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        return None\n    merged_array = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            merged_array.append(arr1[i])\n            i += 1\n        else:\n            merged_array.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged_array.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged_array.append(arr2[j])\n        j += 1\n    return merged_array[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        return None\n    merged_array = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged_array.append(arr1[i])\n            i += 1\n        else:\n            merged_array.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged_array.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged_array.append(arr2[j])\n        j += 1\n    return merged_array[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k <= 0 or k > len(arr1) + len(arr2):\n        return None\n    merged_array = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged_array.append(arr1[i])\n            i += 1\n        else:\n            merged_array.append(arr2[j])\n            j += 1\n    if i < len(arr1):\n        merged_array.extend(arr1[i:])\n    if j < len(arr2):\n        merged_array.extend(arr2[j:])\n    return merged_array[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2) or (not arr1 and (not arr2)):\n        return None\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n        if len(merged) >= k:\n            return merged[k - 1]\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n        if len(merged) >= k:\n            return merged[k - 1]\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n        if len(merged) >= k:\n            return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k < 1 or k > len(arr1) + len(arr2):\n        return None\n    merged_arr = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged_arr.append(arr1[i])\n            i += 1\n        else:\n            merged_arr.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged_arr.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged_arr.append(arr2[j])\n        j += 1\n    return merged_arr[k - 1]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/607", "requirement": "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Write a function to search a string for a regex pattern. The function should return the matching substring, \n    a start index, and an end index. The end index is defined as the first index after the matched substring.\n    \n    assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n    \"\"\"", "generated_programs": ["from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start, end = (match.start(), match.end())\n        return (text[start:end], start, end)\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(0), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        matched_text = match.group(0)\n        start_index = match.start()\n        end_index = match.end()\n        return (matched_text, start_index, end_index)\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start = match.start()\n        end = match.end()\n        return (match.group(), start, end)\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start, end = (match.start(), match.end())\n        substring = text[start:end]\n        return (substring, start, end)\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start_idx = match.start()\n        end_idx = match.end()\n        return (match.group(), start_idx, end_idx)\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start_index = match.start()\n        end_index = match.end()\n        matched_substring = match.group()\n        return (matched_substring, start_index, end_index)\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start_index = match.start()\n        end_index = match.end()\n        matched_string = match.group()\n        return (matched_string, start_index, end_index)\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start_index = match.start()\n        end_index = match.end()\n        return (match.group(), start_index, end_index)\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/610", "requirement": "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function that takes a list and an integer k, and returns a new list with the element at the k-th index removed.\n    The k-th index is 1-based, meaning k=1 refers to the first element of the list. If k is out of bounds (less than 1 or greater than\n    the length of the list), the function should return the original list without any modifications.\n    \n    assert remove_kth_element([1,1,2,3,4,4,5,1],3) == [1, 1, 2, 4, 4, 5, 1]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/612", "requirement": "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Write a Python function which takes a list of lists and returns a list of lists where each sublist contains elements from the same position in the input sublists. If the input sublists are of uneven length, the resulting sublists will be truncated to the length of the shortest input sublist.\n    \n    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    assert merge([['single']]) == [['single']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    return [list(x) for x in zip(*lst)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    return [list(item) for item in zip(*lst)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    return [list(item) for item in zip(*lst)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    return [list(sublist) for sublist in zip(*lst)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    return [list(item) for item in zip(*lst)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    return [list(sublist) for sublist in zip(*lst)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    return [list(x) for x in zip(*lst)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    return [list(sublist) for sublist in zip(*lst)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    return [list(row) for row in zip(*lst)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    return [list(x) for x in zip(*lst)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/615", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    \"\"\"\n    Write a function which takes a tuple of tuples and returns the average value for each column as a list.\n    Each column is formed by elements at the same index across all inner tuples.\n    \n    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(nums) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/622", "requirement": "def get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    \"\"\"\n    Write a function to find the median of two sorted lists of the same size.\n    The median is calculated by merging the two lists, sorting the merged list,\n    and then finding the average of the two middle elements.\n    \n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    mid1, mid2 = (n - 1, n)\n    return (merged_list[mid1] + merged_list[mid2]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    middle_left = len(merged_list) // 2 - 1\n    middle_right = len(merged_list) // 2\n    return (merged_list[middle_left] + merged_list[middle_right]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    middle1 = merged_list[n - 1]\n    middle2 = merged_list[n]\n    return (middle1 + middle2) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    mid1 = merged_list[n - 1]\n    mid2 = merged_list[n]\n    return (mid1 + mid2) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    mid1, mid2 = (n - 1, n)\n    return (merged_list[mid1] + merged_list[mid2]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    mid1 = merged_list[n - 1]\n    mid2 = merged_list[n]\n    return (mid1 + mid2) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    mid1, mid2 = (merged_list[2 * n // 2 - 1], merged_list[2 * n // 2])\n    return (mid1 + mid2) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    middle1 = merged_list[n - 1]\n    middle2 = merged_list[n]\n    return (middle1 + middle2) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    mid1 = merged_list[n - 1]\n    mid2 = merged_list[n]\n    return (mid1 + mid2) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    mid1 = n - 1\n    mid2 = n\n    return (merged_list[mid1] + merged_list[mid2]) / 2.0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n\"\"\"\nWrite a Python function to find the area of the largest equilateral triangle that can be inscribed in a semicircle with a given radius. The largest triangle inscribed in a semicircle is an equilateral triangle, and its area can be calculated using the formula \\( \\frac{\\sqrt{3}}{4} \\times \\text{radius}^2 \\). If the radius is non-positive, the function should return `None`.\n\nassert triangle_area(-1) == None\n\"\"\"", "generated_programs": ["import math\nfrom typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\nfrom typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\nfrom typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\nfrom typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n\"\"\"\nWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\nassert wind_chill(120,35)==40\n\"\"\"", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wc_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wc_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wind_chill_index)", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.9, "original_passk": 0.4}}
{"task_id": "Mbpp/643", "requirement": "def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if the string contains the character 'z' within any word, but not at the start or end of that word.\n    A word is defined as a sequence of alphanumeric characters, and words are separated by non-alphanumeric characters.\n    \n    Examples:\n    assert text_match_wordz_middle(\"pythonzabc.\") == True\n    assert text_match_wordz_middle(\"zpythonabc.\") == False\n    assert text_match_wordz_middle(\"z\") == True\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w*z\\\\w*\\\\b'\n    words = re.findall(pattern, text)\n    for word in words:\n        if 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return any((re.search('\\\\Bz\\\\B', word) for word in re.findall('\\\\b\\\\w+\\\\b', text)))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*[^\\\\Wz]z[^\\\\Wz]\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b[a-zA-Z0-9]*[a-yA-Y0-9]z[a-zA-Z0-9]*[a-yA-Y0-9]\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w*z\\\\w*\\\\b'\n    matches = re.findall(pattern, text)\n    for match in matches:\n        if not match.startswith('z') and (not match.endswith('z')):\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return any((re.search('\\\\Bz\\\\B', word) for word in re.findall('\\\\b\\\\w+\\\\b', text)))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w+z\\\\w+\\\\b', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w+z\\\\w+\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w+z\\\\w+\\\\b'\n    return bool(re.search(pattern, text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.6666666666666667, "original_passk": 1.0}}
{"task_id": "Mbpp/722", "requirement": "from typing import Dict\nfrom typing import Tuple\n\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight greater than or equal to the minimum.\n    assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70) == {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: stats for name, stats in students.items() if stats[0] >= h and stats[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: stats for name, stats in students.items() if stats[0] >= h and stats[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: stats for name, stats in students.items() if stats[0] >= h and stats[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/734", "requirement": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of products of all possible contiguous subarrays (sublists) of a given list.\n    \n    For example, for the input [1, 2, 3], the function should compute the products of the following subarrays: \n    [1], [1, 2], [1, 2, 3], [2], [2, 3], and [3]. The respective products are 1, 2, 6, 2, 6, and 3, and their sum is 20.\n    \n    assert sum_Of_Subarray_Prod([1,2,3]) == 20\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= arr[j]\n            total_sum += current_product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        prod = 1\n        for j in range(i, n):\n            prod *= arr[j]\n            total_sum += prod\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        prod = 1\n        for j in range(i, n):\n            prod *= arr[j]\n            total_sum += prod\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        prod = 1\n        for j in range(i, n):\n            prod *= arr[j]\n            total_sum += prod\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/739", "requirement": "def find_Index(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the index of the smallest triangular number that has at least n digits.\n    \n    A triangular number or triangle number counts objects arranged in an equilateral triangle. The nth triangular number is the number of dots composing a triangle with n dots on a side, and is equal to the sum of the n natural numbers from 1 to n.\n    \n    Parameters:\n    n (int): The minimum number of digits the triangular number should have.\n    \n    Returns:\n    int: The index of the smallest triangular number with at least n digits.\n    \n    Examples:\n    >>> find_Index(2)\n    4\n    >>> find_Index(3)\n    14\n    >>> find_Index(0)\n    1\n    \n    Note:\n    The function assumes that n is a non-negative integer. For n = 0, the function returns 1, as the smallest triangular number with at least 0 digits is considered to be the first triangular number, which is 1.\n    \"\"\"", "generated_programs": ["import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n\n    def triangular_number(index):\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        tri_num = triangular_number(index)\n        if math.floor(math.log10(tri_num)) + 1 >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if len(str(triangular_number)) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n\n    def triangular_number(index):\n        return index * (index + 1) // 2\n    digits = 10 ** (n - 1)\n    index = 1\n    while triangular_number(index) < digits:\n        index += 1\n    return index", "from math import ceil, sqrt\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    limit = 10 ** (n - 1)\n    index = ceil((sqrt(8 * limit + 1) - 1) / 2)\n    return index", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n\n    def triangular_number(index):\n        return index * (index + 1) // 2\n\n    def count_digits(number):\n        return int(math.log10(number)) + 1 if number > 0 else 1\n    index = 1\n    while True:\n        current_triangular = triangular_number(index)\n        if count_digits(current_triangular) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    import math\n\n    def triangular_number(index: int) -> int:\n        return index * (index + 1) // 2\n\n    def count_digits(num: int) -> int:\n        return math.floor(math.log10(num) + 1) if num > 0 else 1\n    index = 1\n    while count_digits(triangular_number(index)) < n:\n        index += 1\n    return index", "import math\n\ndef find_Index(n: int) -> int:\n\n    def triangular_number(index: int) -> int:\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        tri_num = triangular_number(index)\n        if math.floor(math.log10(tri_num)) + 1 >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    import math\n\n    def triangular_number(index: int) -> int:\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        if len(str(triangular_number(index))) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    triangular_number = 1\n    while len(str(triangular_number)) < n:\n        index += 1\n        triangular_number += index\n    return index", "def find_Index(n: int) -> int:\n    from math import sqrt\n\n    def triangular_number(index: int) -> int:\n        return index * (index + 1) // 2\n    digits_limit = 10 ** (n - 1) if n > 0 else 1\n    index = 1\n    while triangular_number(index) < digits_limit:\n        index += 1\n    return index"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Write a function to find numbers within a given range from startnum to endnum \n    (inclusive) where each number is divisible by every non-zero digit it contains. \n    Negative numbers are excluded from consideration. The function should raise a \n    ValueError if the startnum is greater than endnum.\n    \n    assert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    \n    ### Test 1\n    Input: [-10, 10]\n    Expected Output: ['ValueError']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('Start number cannot be greater than end number.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num < 0:\n            continue\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % digit == 0 for digit in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum must not be greater than endnum')\n\n    def is_divisible_by_digits(num: int) -> bool:\n        digits = [int(d) for d in str(num) if d != '0']\n        return all((num % d == 0 for d in digits))\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num > 0 and is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum must not be greater than endnum')\n    if startnum < 0:\n        startnum = 1\n\n    def is_divisible_by_digits(number: int) -> bool:\n        for digit in str(number):\n            if digit == '0':\n                continue\n            if number % int(digit) != 0:\n                return False\n        return True\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum cannot be greater than endnum')\n    result = []\n    for num in range(max(0, startnum), endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % digit == 0 for digit in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum is greater than endnum')\n    valid_numbers = []\n    for num in range(max(startnum, 0), endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % digit == 0 for digit in digits)):\n            valid_numbers.append(num)\n    return valid_numbers", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum must not be greater than endnum')\n    result = []\n    for num in range(max(0, startnum), endnum + 1):\n        num_str = str(num)\n        digits = [int(d) for d in num_str if d != '0']\n        if all((num % digit == 0 for digit in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum must not be greater than endnum')\n\n    def is_divisible_by_digits(number: int) -> bool:\n        for digit in str(number):\n            if digit == '0':\n                continue\n            if number % int(digit) != 0:\n                return False\n        return True\n    result = []\n    for num in range(max(1, startnum), endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('Startnum must not be greater than Endnum')\n\n    def is_divisible_by_digits(number: int) -> bool:\n        digits = [int(d) for d in str(number) if d != '0']\n        return all((number % d == 0 for d in digits))\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num > 0 and is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum should not be greater than endnum')\n    result = []\n    for num in range(max(1, startnum), endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum cannot be greater than endnum.')\n\n    def is_divisible_by_digits(num: int) -> bool:\n        for digit in str(num):\n            if digit == '0':\n                continue\n            if num % int(digit) != 0:\n                return False\n        return True\n    result = []\n    for num in range(max(startnum, 1), endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.0, "original_passk": 0.4}}
{"task_id": "Mbpp/748", "requirement": "def capital_words_spaces(str1: str) -> str:\n\"\"\"\nWrite a function to put spaces between words starting with capital letters in a given string.\nassert capital_words_spaces(\"Python\") == 'Python'\n\"\"\"", "generated_programs": ["import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<=[a-z])([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/759", "requirement": "def is_decimal(num: str) -> bool:\n    \"\"\"\n    Write a function to check whether a given string is a decimal number with exactly two digits after the decimal point.\n    Numbers without a fractional part or with more than two digits after the decimal point should be considered invalid.\n    assert is_decimal('123.11') == True\n    \"\"\"", "generated_programs": ["import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List\n\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n\"\"\"\nWrite a python function to find the minimum difference between any two elements in a given array. \nassert find_min_diff((1,5,3,19,18,25),6) == 1\n\"\"\"", "generated_programs": ["from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        min_diff = min(min_diff, diff)\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        diff = arr[i] - arr[i - 1]\n        min_diff = min(min_diff, diff)\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, arr[i + 1] - arr[i])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, arr[i + 1] - arr[i])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, arr[i + 1] - arr[i])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, arr[i + 1] - arr[i])\n    return min_diff"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number. A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers. The sequence of polite numbers starts with 3, 5, 6, 7, 9, 10, 11, ...\n    \n    assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x & x - 1 == 0 and x > 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n    return polite_numbers[-1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x & x - 1 == 0\n    polite_numbers = []\n    current = 3\n    while len(polite_numbers) < n:\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n        current += 1\n    return polite_numbers[n - 1]", "from typing import List\n\ndef is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x & x - 1 == 0 and x > 0\n\n    def nth_polite_number(n: int) -> int:\n        count, num = (0, 1)\n        while count < n:\n            num += 1\n            if not is_power_of_two(num):\n                count += 1\n        return num\n    return nth_polite_number(n)", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x & x - 1 == 0 and x > 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n    return polite_numbers[n - 1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(k: int) -> bool:\n        return k > 0 and k & k - 1 == 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n    return polite_numbers[-1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x > 0 and x & x - 1 == 0\n    count = 0\n    num = 1\n    while True:\n        num += 1\n        if not is_power_of_two(num):\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x & x - 1 == 0 and x != 0\n    count = 0\n    number = 1\n    while count < n:\n        number += 1\n        if not is_power_of_two(number):\n            count += 1\n    return number", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x & x - 1 == 0 and x > 0\n    count, current = (0, 1)\n    while count < n:\n        current += 1\n        if not is_power_of_two(current):\n            count += 1\n    return current", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x > 0 and x & x - 1 == 0\n    polite_count = 0\n    current_num = 1\n    while polite_count < n:\n        current_num += 1\n        if not is_power_of_two(current_num):\n            polite_count += 1\n    return current_num", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x > 0 and x & x - 1 == 0\n    count, num = (0, 0)\n    while count < n:\n        num += 1\n        if not is_power_of_two(num):\n            count += 1\n    return num"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) - set(li2)) + list(set(li2) - set(li1))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/771", "requirement": "def check_expression(expression: str) -> bool:\n    \"\"\"Check if the given expression containing brackets is balanced.\n    \n    A string with balanced brackets means that each opening bracket has a corresponding closing bracket of the same type, and they are correctly nested.\n    \n    assert check_expression(\"{()}[{}]\") == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map:\n            top_element = stack.pop() if stack else '#'\n            if bracket_map[char] != top_element:\n                return False\n        elif char in bracket_map.values():\n            stack.append(char)\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    bracket_pairs = {'(': ')', '{': '}', '[': ']'}\n    stack = deque()\n    for char in expression:\n        if char in bracket_pairs:\n            stack.append(char)\n        elif char in bracket_pairs.values():\n            if not stack or bracket_pairs[stack.pop()] != char:\n                return False\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    stack = deque()\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if stack and stack[-1] == bracket_pairs[char]:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n\n    def is_balanced(expression: str) -> bool:\n        stack: List[str] = []\n        matching_brackets = {')': '(', ']': '[', '}': '{'}\n        for char in expression:\n            if char in matching_brackets.values():\n                stack.append(char)\n            elif char in matching_brackets.keys():\n                if not stack or stack[-1] != matching_brackets[char]:\n                    return False\n                stack.pop()\n        return not stack\n    return is_balanced(expression)", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack: List[str] = []\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    brackets_map = {')': '(', '}': '{', ']': '['}\n    stack = deque()\n    for char in expression:\n        if char in brackets_map.values():\n            stack.append(char)\n        elif char in brackets_map:\n            if not stack or stack[-1] != brackets_map[char]:\n                return False\n            stack.pop()\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack = deque()\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/780", "requirement": "def find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"Generate all unique pairwise sum combinations from tuples in the given list.\n    \n    For each pair of tuples in the list, compute a new tuple where each element is the sum of the corresponding elements from the pair.\n    The order of the resulting combinations does not matter.\n    \n    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    \"\"\"", "generated_programs": ["from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = set()\n    for tup1, tup2 in combinations(test_list, 2):\n        result.add((tup1[0] + tup2[0], tup1[1] + tup2[1]))\n    return list(result)", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            result.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return result", "from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = set()\n    for pair in combinations(test_list, 2):\n        combined = (pair[0][0] + pair[1][0], pair[0][1] + pair[1][1])\n        result.add(combined)\n    return list(result)", "from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = set()\n    for a, b in combinations(test_list, 2):\n        result.add((a[0] + b[0], a[1] + b[1]))\n    return list(result)", "from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = list(set(((a[0] + b[0], a[1] + b[1]) for a, b in combinations(test_list, 2))))\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return list(set(((a[0] + b[0], a[1] + b[1]) for idx, a in enumerate(test_list) for b in test_list[idx + 1:])))", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            result.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = set()\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            combo = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            result.add(combo)\n    return list(result)", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = set()\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            pair1, pair2 = (test_list[i], test_list[j])\n            result.add((pair1[0] + pair2[0], pair1[1] + pair2[1]))\n    return list(result)", "from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    unique_combinations = set()\n    for pair1, pair2 in combinations(test_list, 2):\n        new_tuple = (pair1[0] + pair2[0], pair1[1] + pair2[1])\n        unique_combinations.add(new_tuple)\n    return list(unique_combinations)"], "result": {"repaired_passk": 0.5, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/782", "requirement": "def odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all elements in odd-length subarrays of the given array.\n    \n    The function should iterate over all starting indices of subarrays, and for each starting index, \n    consider subarrays ending at every second possible index to ensure the subarray length is odd. \n    Sum the elements of these odd-length subarrays and add to the total sum.\n    \n    assert odd_length_sum([1, 2, 4]) == 14\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n, 2):\n            total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n, 2):\n            total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n, 2):\n            total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n, 2):\n            total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n, 2):\n            total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n, 2):\n            total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n, 2):\n            total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n):\n            if (end - start + 1) % 2 != 0:\n                total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n, 2):\n            total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n, 2):\n            total_sum += sum(arr[start:end + 1])\n    return total_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even and the first odd number in a given list.\n    If the list does not contain both an even and an odd number, return 0.\n    \n    assert mul_even_odd([1,3,5,7,4,1,6,8]) == 4\n    assert mul_even_odd([2, 4, 6, 8, 10]) == 0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        elif odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        elif odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        elif odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        elif odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/790", "requirement": "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a Python function to check whether every number at even indices in a given list is even.\n    \n    assert even_position([3,2,1]) == False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches a string starting with 'a' and ending with 'b', with no 'b's allowed between the first 'a' and the last 'b'.\n    \n    assert text_starta_endb(\"aabbbb\") == None\n    \"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a[^b]*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a[^b]*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/797", "requirement": "def sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of all odd natural numbers within the range from l to r inclusive.\n    The function should consider only positive integers as natural numbers and ignore any negative numbers or zero.\n    If l is greater than r, the function should return 0.\n    \n    assert sum_in_range(2,5) == 8\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    l = max(1, l)\n    odd_sum = sum((num for num in range(l, r + 1) if num % 2 != 0))\n    return odd_sum", "from typing import List\n\ndef sum_in_range(l: int, r: int) -> int:\n    if l > r or r <= 0:\n        return 0\n    l = max(l, 1)\n    return sum((num for num in range(l, r + 1) if num % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    l = max(1, l)\n    if l % 2 == 0:\n        l += 1\n    if r % 2 == 0:\n        r -= 1\n    return sum(range(l, r + 1, 2))", "def sum_in_range(l: int, r: int) -> int:\n    if l > r or r <= 0:\n        return 0\n    l = max(1, l)\n    return sum((i for i in range(l, r + 1) if i % 2 == 1))", "def sum_in_range(l: int, r: int) -> int:\n    if l > r or r < 1:\n        return 0\n    l = max(l, 1)\n    return sum((x for x in range(l, r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    if l > r or r <= 0:\n        return 0\n    l = max(l, 1)\n    return sum((x for x in range(l, r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    return sum((x for x in range(max(l, 1), r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/4", "requirement": "def heap_queue_largest(nums: list, n: int) -> list:\n    \"\"\"\n    Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n    \n    The function should use `heapq.nlargest` to obtain the n largest elements, which are inherently sorted in descending order.\n    \n    assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    \"\"\"", "generated_programs": ["import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/20", "requirement": "def is_woodall(num: int) -> bool:\n    \"\"\"Check if the given number is a Woodall number. A Woodall number is defined as a number of the form n * 2^n - 1 for some positive integer n.\n    \n    assert is_woodall(383) == True\n    \"\"\"", "generated_programs": ["def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall_number = n * 2 ** n - 1\n        if woodall_number == num:\n            return True\n        if woodall_number > num:\n            return False\n        n += 1", "from math import log2, floor\n\ndef is_woodall(num: int) -> bool:\n    if num <= 0:\n        return False\n    n = floor(log2(num + 1))\n    return n * 2 ** n - 1 == num", "def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall_number = n * 2 ** n - 1\n        if woodall_number == num:\n            return True\n        if woodall_number > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall_number = n * 2 ** n - 1\n        if woodall_number == num:\n            return True\n        if woodall_number > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall_number = n * 2 ** n - 1\n        if woodall_number == num:\n            return True\n        if woodall_number > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num <= 0:\n        return False\n    n = 1\n    while True:\n        woodall_number = n * 2 ** n - 1\n        if woodall_number == num:\n            return True\n        if woodall_number > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    import math\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.6}}
{"task_id": "Mbpp/58", "requirement": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"Check if the two given integers have opposite signs using bitwise operations.\n    \n    The function should return True if x and y have opposite signs, otherwise False.\n    This is achieved by performing a bitwise XOR operation on x and y, then checking if the 32nd bit (sign bit in a 32-bit signed integer representation) is set.\n    \n    assert opposite_Signs(1, -2) == True\n    \n    ### Test 1\n    Input: [0, 5]\n    Expected Output: [False]\n    \n    ### Test 2\n    Input: [-1, 1]\n    Expected Output: [True]\n    \"\"\"", "generated_programs": ["def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/61", "requirement": "def count_Substrings(s: str) -> int:\n    \"\"\"Count the number of substrings where the sum of the digits equals the length of the substring.\n    \n    assert count_Substrings('112112') == 6\n    \"\"\"", "generated_programs": ["def count_Substrings(s: str) -> int:\n\n    def is_valid_substring(sub, length):\n        return sum((int(char) for char in sub)) == length\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if is_valid_substring(substring, len(substring)):\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n\n    def sum_of_digits(sub: str) -> int:\n        return sum((int(ch) for ch in sub))\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if sum_of_digits(substring) == len(substring):\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    from itertools import combinations\n    n = len(s)\n    count = 0\n    for i, j in combinations(range(n + 1), 2):\n        substring = s[i:j]\n        digits = [int(char) for char in substring]\n        if sum(digits) == len(substring):\n            count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n\n    def digit_sum(sub: str) -> int:\n        return sum(map(int, sub))\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if digit_sum(substring) == len(substring):\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n\n    def digit_sum(substring: str) -> int:\n        return sum((int(c) for c in substring))\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if digit_sum(substring) == len(substring):\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n    total_count = 0\n    n = len(s)\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                total_count += 1\n    return total_count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n\n    def digit_sum(sub: str) -> int:\n        return sum((int(ch) for ch in sub))\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if digit_sum(substring) == len(substring):\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n\n    def is_valid_substring(substring: str) -> bool:\n        return sum(map(int, substring)) == len(substring)\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_valid_substring(s[i:j]):\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n\n    def is_valid(substring: str) -> bool:\n        return sum((int(digit) for digit in substring)) == len(substring)\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_valid(s[i:j]):\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        digit_sum = 0\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            if digit_sum == j - i + 1:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/84", "requirement": "def sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the Newman Conway sequence.\n    The function is only defined for positive integers n >= 1. For n < 1, the function should raise an IndexError.\n    \n    assert sequence(10) == 6\n    \"\"\"", "generated_programs": ["def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    memo = [0] * (n + 1)\n    memo[1], memo[2] = (1, 1)\n    for i in range(3, n + 1):\n        memo[i] = memo[memo[i - 1]] + memo[i - memo[i - 1]]\n    return memo[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer.')\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    cache = [0] * (n + 1)\n    cache[1], cache[2] = (1, 1)\n    for i in range(3, n + 1):\n        cache[i] = cache[cache[i - 1]] + cache[i - cache[i - 1]]\n    return cache[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('The sequence is only defined for n >= 1.')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "from functools import lru_cache\n\ndef sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('The Newman-Conway sequence is only defined for n >= 1.')\n\n    def newman_conway(x):\n        if x == 1:\n            return 1\n        if x == 2:\n            return 1\n        return newman_conway(newman_conway(x - 1)) + newman_conway(x - newman_conway(x - 1))\n    return newman_conway(n)", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer greater than or equal to 1')\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    memo = [0] * (n + 1)\n    memo[1], memo[2] = (1, 1)\n    for i in range(3, n + 1):\n        memo[i] = memo[memo[i - 1]] + memo[i - memo[i - 1]]\n    return memo[n]", "from typing import List\n\ndef sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('Input must be a positive integer greater than or equal to 1.')\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    seq: List[int] = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('Input must be a positive integer n >= 1')\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    memo = [0] * (n + 1)\n    memo[1], memo[2] = (1, 1)\n    for i in range(3, n + 1):\n        memo[i] = memo[memo[i - 1]] + memo[i - memo[i - 1]]\n    return memo[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('Input must be a positive integer greater than or equal to 1.')\n    if n == 1 or n == 2:\n        return 1\n    cache = [0] * (n + 1)\n    cache[1], cache[2] = (1, 1)\n    for i in range(3, n + 1):\n        cache[i] = cache[cache[i - 1]] + cache[i - cache[i - 1]]\n    return cache[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer greater than or equal to 1')\n    newman_conway = [0] * (n + 1)\n    newman_conway[1] = 1\n    if n > 1:\n        newman_conway[2] = 1\n    for i in range(3, n + 1):\n        newman_conway[i] = newman_conway[newman_conway[i - 1]] + newman_conway[i - newman_conway[i - 1]]\n    return newman_conway[n]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n\"\"\"\nWrite a Python function to find the number of positive divisors of a given integer.\nThe function should return 0 for non-positive integers.\nassert divisor(15) == 4\n\"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "from typing import List\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements in given nested lists.\n    The function should handle cases where some of the sublists might be empty.\n    If any sublist is empty, the function should return an empty list since there are no common elements.\n    If the outer list is empty, the function should raise an IndexError.\n    \n    assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty.')\n    if any((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty.')\n    for sublist in nestedlist:\n        if not sublist:\n            return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or len(nestedlist) == 0:\n        raise IndexError('Outer list is empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        if not sublist:\n            return []\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty.')\n    if any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if len(nestedlist) == 0:\n        raise IndexError('The outer list is empty.')\n    for sublist in nestedlist:\n        if not sublist:\n            return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Outer list is empty')\n    if any((not sublist for sublist in nestedlist)):\n        return []\n    return list(set.intersection(*map(set, nestedlist)))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty.')\n    if any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Outer list is empty.')\n    if any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Outer list is empty')\n    for sublist in nestedlist:\n        if not sublist:\n            return []\n    return list(set(nestedlist[0]).intersection(*nestedlist[1:]))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty.')\n    if any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to sum all amicable numbers strictly less than a specified number.\n    \n    Amicable numbers are pairs of numbers where each number is the sum of the proper divisors of the other.\n    \n    assert amicable_numbers_sum(999) == 504\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def proper_divisors_sum(n: int) -> int:\n        return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = proper_divisors_sum(a)\n        if b != a and proper_divisors_sum(b) == a and (b < limit):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def proper_divisors_sum(n: int) -> int:\n        return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n    amicable_sum = 0\n    for num in range(2, limit):\n        pair = proper_divisors_sum(num)\n        if pair != num and pair < limit and (proper_divisors_sum(pair) == num):\n            amicable_sum += num\n    return amicable_sum", "from typing import List\n\ndef proper_divisors_sum(n: int) -> int:\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = proper_divisors_sum(a)\n        if b < limit and b != a and (proper_divisors_sum(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        divisors_sum = sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n        return divisors_sum\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef proper_divisors_sum(n: int) -> int:\n    return sum((d for d in range(1, n // 2 + 1) if n % d == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = proper_divisors_sum(a)\n        if b != a and b < limit and (proper_divisors_sum(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def proper_divisors_sum(n: int) -> int:\n        divisors = [1]\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = proper_divisors_sum(a)\n        if b != a and b < limit and (proper_divisors_sum(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        divisors = [i for i in range(1, n // 2 + 1) if n % i == 0]\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_divisors(a)\n        if b != a and b < limit and (sum_of_divisors(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef proper_divisors_sum(num: int) -> int:\n    return sum((i for i in range(1, num // 2 + 1) if num % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = proper_divisors_sum(a)\n        if b != a and b < limit and (proper_divisors_sum(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(num: int) -> int:\n        divisors = [i for i in range(1, num // 2 + 1) if num % i == 0]\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_divisors(a)\n        if b != a and b < limit and (sum_of_divisors(b) == a):\n            amicable_sum += a\n    return amicable_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n\"\"\"\nWrite a function to get the angle of the complex number `b` relative to the positive real axis.\nThe parameter `a` is currently unused in the calculation.\nassert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n\"\"\"", "generated_programs": ["import math\nfrom cmath import phase\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return phase(b)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\nfrom cmath import phase\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return phase(b)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether the given matrix is a magic square.\n    A magic square is a square matrix where the sums of every row, column, and both main diagonals are all equal.\n    \n    The function should first check if the matrix is square (i.e., has the same number of rows and columns).\n    If the matrix is not square, the function should return False.\n    \n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    if any((sum(row) != target_sum for row in my_matrix)):\n        return False\n    if any((sum((my_matrix[row][col] for row in range(n))) != target_sum for col in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for i in range(n):\n        if sum(my_matrix[i]) != target_sum or sum((my_matrix[j][i] for j in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    magic_sum = sum(my_matrix[0])\n    if any((sum(row) != magic_sum for row in my_matrix)):\n        return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if len(my_matrix) == 0 or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != target_sum:\n        return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n\"\"\"\nWrite a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\nassert is_Sum_Of_Powers_Of_Two(10) == True\n\"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return all((c == '1' for c in bin(n)[2:]))", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and all((char in '01' for char in bin(n)[2:]))", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 0 or n % 2 == 1:\n            n = n // 2\n        else:\n            return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 != 0 and n != 1:\n            return False\n        if n == 1:\n            return True\n        n = n // 2", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and bin(n).count('1') >= 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\"\"\"\nWrite a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\nassert find_solution(2, 3, 7) == (2, 1)\n\"\"\"", "generated_programs": ["from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n), abs(n) + 1):\n        for y in range(-abs(n), abs(n) + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n), abs(n) + 1):\n        for y in range(-abs(n), abs(n) + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n), abs(n) + 1):\n        for y in range(-abs(n), abs(n) + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n + 1):\n        for y in range(n + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n), abs(n) + 1):\n        for y in range(-abs(n), abs(n) + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(abs(n) + 1):\n        for y in range(abs(n) + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n), abs(n) + 1):\n        for y in range(-abs(n), abs(n) + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-(abs(n) + abs(a) + abs(b)), abs(n) + abs(a) + abs(b) + 1):\n        for y in range(-(abs(n) + abs(a) + abs(b)), abs(n) + abs(a) + abs(b) + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n + 1):\n        for y in range(n + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n), abs(n) + 1):\n        for y in range(-abs(n), abs(n) + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None"], "result": {"repaired_passk": 0.19999999999999996, "cross_model_passk": 0.30000000000000004, "original_passk": 0.6}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n\"\"\"\nWrite a Python function that returns the given number without modifying it. The term \"set all even bits\" in this context means to leave the number unchanged.\nassert even_bit_set_number(10) == 10\n\"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, \n    such that each element is a positive integer starting from any integer between 1 and m. Each subsequent element \n    must be at least twice the previous one and not exceed m.\n    \n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"", "generated_programs": ["from functools import lru_cache\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def dfs(prev, length):\n        if length == n:\n            return 1\n        count = 0\n        for next_num in range(prev * 2, m + 1):\n            count += dfs(next_num, length + 1)\n        return count\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += dfs(start, 1)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def dfs(value: int, length: int) -> int:\n        if length == n:\n            return 1\n        count = 0\n        for next_value in range(value * 2, m + 1):\n            count += dfs(next_value, length + 1)\n        return count\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += dfs(start, 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start, length):\n        if length == 0:\n            return 1\n        total = 0\n        for next_num in range(start * 2, m + 1):\n            total += count_sequences(next_num, length - 1)\n        return total\n    total_sequences = 0\n    for starting_num in range(1, m + 1):\n        total_sequences += count_sequences(starting_num, n - 1)\n    return total_sequences", "from functools import lru_cache\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def helper(previous, length):\n        if length == n:\n            return 1\n        count = 0\n        for num in range(previous * 2, m + 1):\n            count += helper(num, length + 1)\n        return count\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += helper(start, 1)\n    return total_count", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total_count = 0\n        for next_val in range(2 * start, m + 1):\n            total_count += count_sequences(next_val, length - 1)\n        return total_count\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def dfs(prev: int, length: int) -> int:\n        if length == n:\n            return 1\n        total_sequences = 0\n        for next_elem in range(2 * prev, m + 1):\n            total_sequences += dfs(next_elem, length + 1)\n        return total_sequences\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += dfs(start, 1)\n    return total_count", "from functools import lru_cache\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(prev, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_value in range(prev * 2, m + 1):\n            total += count_sequences(next_value, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        for next_val in range(start * 2, m + 1):\n            total += count_sequences(next_val, length - 1)\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "from functools import lru_cache\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(last_element: int, remaining_length: int) -> int:\n        if remaining_length == 1:\n            return 1\n        total = 0\n        for next_element in range(last_element * 2, m + 1):\n            total += count_sequences(next_element, remaining_length - 1)\n        return total\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start, length):\n        if length == 0:\n            return 1\n        count = 0\n        for next_val in range(start * 2, m + 1):\n            count += count_sequences(next_val, length - 1)\n        return count\n    total_count = 0\n    for starting_val in range(1, m + 1):\n        total_count += count_sequences(starting_val, n - 1)\n    return total_count"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/244", "requirement": "def next_Perfect_Square(N: int) -> int:\n    \"\"\"\n    Write a Python function to find the next perfect square strictly greater than a given number.\n    If the input number is a perfect square, the function should return the next perfect square.\n    \n    The function calculates the ceiling of the square root of the input number and returns its square,\n    ensuring that the result is always the smallest perfect square greater than the input.\n    \n    assert next_Perfect_Square(35) == 36\n    \n    ### Test 1\n    Input: [0]\n    Expected Output: [1]\n    \n    ### Test 2\n    Input: [0]\n    Expected Output: [1]\n    \"\"\"", "generated_programs": ["import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.sqrt(N)\n    next_sqrt = math.ceil(sqrt_N)\n    return (next_sqrt + 1) ** 2 if next_sqrt ** 2 == N else next_sqrt ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    return (root + 1) ** 2 if root ** 2 == N else root ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    return (math.isqrt(N) + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    return math.ceil(math.sqrt(N)) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    return (math.ceil(math.sqrt(N)) + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.sqrt(N)\n    next_sqrt = math.ceil(sqrt_N)\n    return next_sqrt ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    return (math.isqrt(N) + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    return (math.isqrt(N) + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    next_sqrt = math.ceil(math.sqrt(N))\n    return (next_sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    next_square = root if N == root ** 2 else root + 1\n    return next_square ** 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/245", "requirement": "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, \n    where a sequence is bitonic if it is strictly increasing and then strictly decreasing. \n    If the array is empty or no such bitonic subsequence can be formed, the function should return 0.\n    \n    assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    lis_sum = [0] * n\n    for i in range(n):\n        lis_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and lis_sum[i] < lis_sum[j] + arr[i]:\n                lis_sum[i] = lis_sum[j] + arr[i]\n    lds_sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        lds_sum[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i] and lds_sum[i] < lds_sum[j] + arr[i]:\n                lds_sum[i] = lds_sum[j] + arr[i]\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis_sum[i] + lds_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    lis_sum = [0] * n\n    for i in range(n):\n        lis_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                lis_sum[i] = max(lis_sum[i], lis_sum[j] + arr[i])\n    lds_sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        lds_sum[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                lds_sum[i] = max(lds_sum[i], lds_sum[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis_sum[i] + lds_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc_sum = [0] * n\n    for i in range(n):\n        inc_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc_sum[i] = max(inc_sum[i], inc_sum[j] + arr[i])\n    dec_sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        dec_sum[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec_sum[i] = max(dec_sum[i], dec_sum[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc_sum[i] + dec_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    lis = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i] and lis[i] < lis[j] + arr[i]:\n                lis[i] = lis[j] + arr[i]\n    lds = arr[:]\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i] and lds[i] < lds[j] + arr[i]:\n                lds[i] = lds[j] + arr[i]\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis[i] + lds[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    increasing = [0] * n\n    decreasing = [0] * n\n    for i in range(n):\n        increasing[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                increasing[i] = max(increasing[i], increasing[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        decreasing[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                decreasing[i] = max(decreasing[i], decreasing[j] + arr[i])\n    max_sum_bitonic = 0\n    for i in range(n):\n        max_sum_bitonic = max(max_sum_bitonic, increasing[i] + decreasing[i] - arr[i])\n    return max_sum_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    lis = [0] * n\n    for i in range(n):\n        max_val = 0\n        for j in range(i):\n            if arr[j] < arr[i]:\n                max_val = max(max_val, lis[j])\n        lis[i] = max_val + arr[i]\n    lds = [0] * n\n    for i in range(n - 1, -1, -1):\n        max_val = 0\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                max_val = max(max_val, lds[j])\n        lds[i] = max_val + arr[i]\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis[i] + lds[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and inc[j] + arr[i] > inc[i]:\n                inc[i] = inc[j] + arr[i]\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i] and dec[j] + arr[i] > dec[i]:\n                dec[i] = dec[j] + arr[i]\n    max_sum_bitonic = 0\n    for i in range(n):\n        max_sum_bitonic = max(max_sum_bitonic, inc[i] + dec[i] - arr[i])\n    return max_sum_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = arr[:]\n    dec = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    max_sum_bitonic = 0\n    for i in range(n):\n        max_sum_bitonic = max(max_sum_bitonic, inc[i] + dec[i] - arr[i])\n    return max_sum_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    lis_sum = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and lis_sum[i] < lis_sum[j] + arr[i]:\n                lis_sum[i] = lis_sum[j] + arr[i]\n    lds_sum = arr[:]\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j] and lds_sum[i] < lds_sum[j] + arr[i]:\n                lds_sum[i] = lds_sum[j] + arr[i]\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis_sum[i] + lds_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    for i in range(n):\n        dec[i] = arr[i]\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    return max_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n\"\"\"\nWrite a function to find the nth Newman–Shanks–Williams (NSW) prime number. \nThe NSW numbers are defined by the recurrence relation S(n) = 2*S(n-1) + S(n-2) with initial conditions S(0) = S(1) = 1. \nA NSW prime is a NSW number that is also a prime number.\n\nassert newman_prime(3) == 7\n\"\"\"", "generated_programs": ["from math import isqrt\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    for i in range(5, isqrt(num) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    nsw_sequence = [1, 1]\n    primes_found = []\n    while len(primes_found) < n:\n        next_nsw = 2 * nsw_sequence[-1] + nsw_sequence[-2]\n        nsw_sequence.append(next_nsw)\n        if is_prime(next_nsw):\n            primes_found.append(next_nsw)\n    return primes_found[-1]", "import math\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    nsws = [1, 1]\n    primes = []\n    i = 2\n    while len(primes) < n:\n        new_nsw = 2 * nsws[-1] + nsws[-2]\n        nsws.append(new_nsw)\n        if is_prime(new_nsw):\n            primes.append(new_nsw)\n        i += 1\n    return primes[n - 1]", "from math import isqrt\nfrom typing import List\n\ndef is_prime(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, isqrt(number) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    nsw_numbers: List[int] = [1, 1]\n    primes: List[int] = []\n    while len(primes) < n:\n        next_nsw = 2 * nsw_numbers[-1] + nsw_numbers[-2]\n        nsw_numbers.append(next_nsw)\n        if is_prime(next_nsw):\n            primes.append(next_nsw)\n    return primes[n - 1]", "from typing import List\nfrom math import isqrt\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, isqrt(num) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    nsw_numbers = [1, 1]\n    primes: List[int] = []\n    i = 2\n    while len(primes) < n:\n        nsw_num = 2 * nsw_numbers[i - 1] + nsw_numbers[i - 2]\n        nsw_numbers.append(nsw_num)\n        if is_prime(nsw_num):\n            primes.append(nsw_num)\n        i += 1\n    return primes[n - 1]", "from sympy import isprime\n\ndef newman_prime(n: int) -> int:\n\n    def is_nsw_prime(x):\n        return isprime(x)\n    nsw_numbers = [1, 1]\n    primes = []\n    i = 2\n    while len(primes) < n:\n        next_nsw = 2 * nsw_numbers[-1] + nsw_numbers[-2]\n        nsw_numbers.append(next_nsw)\n        if is_nsw_prime(next_nsw):\n            primes.append(next_nsw)\n        i += 1\n    return primes[-1]", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    S = [1, 1]\n    primes = []\n    i = 2\n    while len(primes) < n:\n        S.append(2 * S[-1] + S[-2])\n        if is_prime(S[-1]):\n            primes.append(S[-1])\n        i += 1\n    return primes[n - 1]", "from math import isqrt\nfrom typing import List\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, isqrt(num) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n\n    def generate_nsw_primes(count: int) -> List[int]:\n        nsw_primes = []\n        S0, S1 = (1, 1)\n        k = 2\n        while len(nsw_primes) < count:\n            Sn = 2 * S1 + S0\n            if is_prime(Sn):\n                nsw_primes.append(Sn)\n            S0, S1 = (S1, Sn)\n            k += 1\n        return nsw_primes\n    return generate_nsw_primes(n)[-1]", "from math import isqrt\nfrom typing import List\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, isqrt(num) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    nsw_numbers: List[int] = [1, 1]\n    primes: List[int] = []\n    index = 2\n    while len(primes) < n:\n        next_nsw = 2 * nsw_numbers[-1] + nsw_numbers[-2]\n        nsw_numbers.append(next_nsw)\n        if is_prime(next_nsw):\n            primes.append(next_nsw)\n        index += 1\n    return primes[n - 1]", "from typing import List\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    NSW_numbers = [1, 1]\n    primes: List[int] = []\n    while len(primes) < n:\n        next_nsw = 2 * NSW_numbers[-1] + NSW_numbers[-2]\n        NSW_numbers.append(next_nsw)\n        if is_prime(next_nsw):\n            primes.append(next_nsw)\n    return primes[n - 1]", "from math import isqrt\nfrom typing import Generator\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, isqrt(num) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef nsw_numbers() -> Generator[int, None, None]:\n    S0, S1 = (1, 1)\n    yield S0\n    yield S1\n    while True:\n        S_next = 2 * S1 + S0\n        yield S_next\n        S0, S1 = (S1, S_next)\n\ndef newman_prime(n: int) -> int:\n    count = 0\n    for num in nsw_numbers():\n        if is_prime(num):\n            count += 1\n            if count == n:\n                return num"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/274", "requirement": "def even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n    Write a Python function that takes in a positive integer n and finds the sum of binomial coefficients at even indices.\n    Specifically, compute the sum of \\( C(n, 0) + C(n, 2) + C(n, 4) + \\ldots \\).\n\n    assert even_binomial_Coeff_Sum(4) == 8\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "import math\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((math.comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/290", "requirement": "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n\"\"\"\nWrite a function to find the list of maximum length in a list of lists.\nIn case of a tie (multiple lists with the same maximum length), return the first one encountered.\nassert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n\"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = 0\n    max_list = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = 0\n    max_list = []\n    for sublist in list1:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_list = sublist\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = 0\n    max_list = []\n    for sublist in list1:\n        current_len = len(sublist)\n        if current_len > max_len:\n            max_len = current_len\n            max_list = sublist\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = -1\n    max_list = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = 0\n    max_list = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = 0\n    max_list = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = 0\n    max_list = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = -1\n    result_list = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            result_list = lst\n    return (max_len, result_list)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n    \"\"\"Calculate the maximum depth of nested dictionaries.\n    \n    The depth is determined by the number of levels in the most deeply nested dictionary.\n    A non-dictionary value does not add to the depth.\n    \n    assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4\n    \"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)))", "def dict_depth(d: dict) -> int:\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if isinstance(d, dict):\n        return 1 + max((dict_depth(v) for v in d.values()), default=0)\n    return 0", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if isinstance(d, dict):\n        return 1 + max((dict_depth(v) for v in d.values()), default=0)\n    return 0", "def dict_depth(d: dict) -> int:\n\n    def depth_helper(sub_dict):\n        if isinstance(sub_dict, dict):\n            return 1 + max((depth_helper(v) for v in sub_dict.values()), default=0)\n        return 0\n    return depth_helper(d)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n\n    def _depth(d, current_depth):\n        if isinstance(d, dict) and d:\n            return max((_depth(v, current_depth + 1) for v in d.values()))\n        return current_depth\n    return _depth(d, 1)", "def dict_depth(d: dict) -> int:\n\n    def depth_helper(obj: dict) -> int:\n        if isinstance(obj, dict):\n            return 1 + max((depth_helper(v) for v in obj.values()), default=0)\n        return 0\n    return depth_helper(d)", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if isinstance(d, dict):\n        return 1 + max((dict_depth(v) for v in d.values()), default=0)\n    return 0"], "result": {"repaired_passk": 0.5, "cross_model_passk": 0.6, "original_passk": 0.4}}
{"task_id": "Mbpp/305", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n\"\"\"\nWrite a function to return two words from a list of words starting with letter 'p'.\nassert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==('Python', 'PHP')\n\"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    filtered_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                filtered_words.append(word)\n                if len(filtered_words) == 2:\n                    return tuple(filtered_words)\n    return tuple(filtered_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        result.extend([word for word in sentence.split() if word.startswith('P')])\n        if len(result) >= 2:\n            return (result[0], result[1])\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    for sentence in words:\n        word_list = sentence.split()\n        result = [word for word in word_list if word.startswith('P')]\n        if len(result) >= 2:\n            return tuple(result[:2])\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for word in words:\n        for subword in word.split():\n            if subword.lower().startswith('p'):\n                result.append(subword)\n            if len(result) == 2:\n                return tuple(result)\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    for sentence in words:\n        word_list = sentence.split()\n        p_words = [word for word in word_list if word.startswith('P')]\n        if len(p_words) >= 2:\n            return (p_words[0], p_words[1])\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    for word_group in words:\n        word_list = word_group.split()\n        filtered_words = [word for word in word_list if word.startswith('P')]\n        if len(filtered_words) >= 2:\n            return tuple(filtered_words[:2])\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for word_list in words:\n        for word in word_list.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n            if len(result) == 2:\n                return tuple(result)\n    return tuple(result[:2])", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    for sentence in words:\n        word_list = sentence.split()\n        filtered_words = [word for word in word_list if word.lower().startswith('p')]\n        if len(filtered_words) >= 2:\n            return tuple(filtered_words[:2])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\"\"\"\nWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\nassert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum_prefix = max(dp[:index + 1])\n    if a[k] > a[index]:\n        return max_sum_prefix + a[k]\n    else:\n        return a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    dp[0] = a[0]\n    for i in range(1, index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum_prefix = max(dp[:index + 1])\n    if a[k] > max(a[:index + 1]):\n        return max_sum_prefix + a[k]\n    return max_sum_prefix", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def helper(i, prev_val, include_k):\n        if i > index and (not include_k):\n            return 0\n        if i == k:\n            if prev_val < a[i]:\n                return a[i] + helper(i + 1, a[i], True)\n            else:\n                return 0\n        if i >= n:\n            return 0\n        exclude = helper(i + 1, prev_val, include_k)\n        include = 0\n        if prev_val < a[i]:\n            include = a[i] + helper(i + 1, a[i], include_k)\n        return max(include, exclude)\n    return helper(0, float('-inf'), False)", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def is_increasing_subsequence(sequence, additional_value):\n        return all((sequence[i] < sequence[i + 1] for i in range(len(sequence) - 1))) and sequence[-1] < additional_value\n    prefix = a[:index + 1]\n    max_sum = 0\n    for i in range(1 << len(prefix)):\n        subset = [prefix[j] for j in range(len(prefix)) if i & 1 << j]\n        if subset and is_increasing_subsequence(subset, a[k]):\n            max_sum = max(max_sum, sum(subset) + a[k])\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def helper(subseq: List[int]) -> int:\n        max_sum = 0\n        current_sum = 0\n        for i in range(len(subseq)):\n            if i == 0 or subseq[i] > subseq[i - 1]:\n                current_sum += subseq[i]\n                max_sum = max(max_sum, current_sum)\n            else:\n                current_sum = subseq[i]\n        return max_sum\n    prefix = a[:index + 1]\n    prefix.append(a[k])\n    return helper(prefix)", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def is_valid_subseq(prev, cur):\n        return prev < cur\n    dp = [0] * n\n    dp[0] = a[0]\n    for i in range(1, index + 1):\n        dp[i] = max([dp[j] + a[i] if is_valid_subseq(a[j], a[i]) else 0 for j in range(i)] + [a[i]])\n    dp_k = [0] * n\n    dp_k[k] = a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    dp[0] = a[0]\n    for i in range(1, n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum_prefix = max(dp[:index + 1])\n    if a[k] > a[index]:\n        return max_sum_prefix + a[k]\n    else:\n        return max_sum_prefix"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.0, "original_passk": 0.125}}
{"task_id": "Mbpp/308", "requirement": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    If N is zero or negative, the function should return an empty list. If either of the input lists is empty, the function should also return an empty list.\n    \n    assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    \"\"\"", "generated_programs": ["from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    max_heap = []\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            heapq.heappush(max_heap, -product)\n    result = []\n    for _ in range(min(N, len(max_heap))):\n        result.append(-heapq.heappop(max_heap))\n    return result", "import heapq\nfrom typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    max_heap = []\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            if len(max_heap) < N:\n                heapq.heappush(max_heap, product)\n            else:\n                heapq.heappushpop(max_heap, product)\n    return sorted(max_heap, reverse=True)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    max_products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(max_products, -(num1 * num2))\n    largest_products = []\n    for _ in range(min(N, len(max_products))):\n        largest_products.append(-heapq.heappop(max_products))\n    return largest_products", "from typing import List\nfrom itertools import product\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = [x * y for x, y in product(nums1, nums2)]\n    return sorted(products, reverse=True)[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, -(num1 * num2))\n    largest_products = []\n    for _ in range(min(N, len(products))):\n        largest_products.append(-heapq.heappop(products))\n    return largest_products", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, -(num1 * num2))\n    largest_products = []\n    for _ in range(min(N, len(products))):\n        largest_products.append(-heapq.heappop(products))\n    return largest_products", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    return heapq.nlargest(N, products)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    max_heap = []\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            heapq.heappush(max_heap, -product)\n    largest_products = []\n    for _ in range(N):\n        if max_heap:\n            largest_products.append(-heapq.heappop(max_heap))\n        else:\n            break\n    return largest_products", "from typing import List\nfrom heapq import nlargest\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = [x * y for x in nums1 for y in nums2]\n    return nlargest(N, products)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    return heapq.nlargest(N, products)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n\"\"\"\nWrite a function to convert a given string to a tuple of characters, excluding spaces.\nassert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n\"\"\"", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((ch for ch in str1 if ch != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import tuple\n\ndef string_to_tuple(str1: str) -> tuple:\n    return tuple((ch for ch in str1 if ch != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((c for c in str1 if c != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n\"\"\"\nWrite a python function to set the left most unset bit.\nassert set_left_most_unset_bit(10) == 14\n\"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length() + 1\n    for i in range(bit_length):\n        if not n & 1 << bit_length - i - 1:\n            n |= 1 << bit_length - i - 1\n            break\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_position = 1\n    while True:\n        if n & bit_position == 0:\n            return n | bit_position\n        bit_position <<= 1", "def set_left_most_unset_bit(n: int) -> int:\n    num_bits = n.bit_length()\n    for i in range(num_bits - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            return n\n    return n | 1 << num_bits", "def set_left_most_unset_bit(n: int) -> int:\n    m = ~n\n    pos = 1\n    while m & 1 == 0:\n        m >>= 1\n        pos <<= 1\n    return n | pos", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    num_bits = n.bit_length()\n    for i in range(num_bits - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    next_highest_bit_position = num_bits\n    if n.bit_length() == num_bits:\n        n |= 1 << next_highest_bit_position\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    import math\n    num_bits = math.floor(math.log2(n)) + 1 if n > 0 else 1\n    for i in range(num_bits, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/427", "requirement": "def change_date_format(dt: str) -> str:\n    \"\"\"\n    Write a function to convert a date from yyyy-mm-dd format to dd-mm-yyyy format.\n    The function should validate the input string to ensure it represents a valid date.\n    If the input string is not a valid date, the function should raise a ValueError.\n    \n    assert change_date_format(\"2026-01-02\") == '02-01-2026'\n    \"\"\"", "generated_programs": ["from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        parsed_date = datetime.strptime(dt, '%Y-%m-%d')\n        return parsed_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.strptime(dt, '%Y-%m-%d')\n        return valid_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.strptime(dt, '%Y-%m-%d')\n        return valid_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.strptime(dt, '%Y-%m-%d')\n        return valid_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format or invalid date')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.strptime(dt, '%Y-%m-%d')\n        return valid_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format or value')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_object = datetime.strptime(dt, '%Y-%m-%d')\n        return date_object.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        parsed_date = datetime.strptime(dt, '%Y-%m-%d')\n        return parsed_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format or date value')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.strptime(dt, '%Y-%m-%d')\n    except ValueError:\n        raise ValueError('Invalid date format')\n    return valid_date.strftime('%d-%m-%Y')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format or value.')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n\"\"\"\nWrite a function to find the directrix of a parabola.\nassert parabola_directrix(5,3,2)==-198\n\"\"\"", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -4 * a * c - b * b - 1", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    import math\n    vertex_y = (4 * a * c - b ** 2) / (4 * a)\n    directrix = math.floor(vertex_y - 1 / (4 * a))\n    return directrix", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c) // (4 * a)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(c + b ** 2 // (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c) // (4 * a)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c) // (4 * a)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c) // (4 * a)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    vertex_x = -b / (2 * a)\n    vertex_y = a * vertex_x ** 2 + b * vertex_x + c\n    directrix = int(vertex_y - 1 / (4 * a))\n    return directrix", "from typing import int\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    vertex_y = -1 * (b ** 2 - 4 * a * c) // (4 * a)\n    return -vertex_y"], "result": {"repaired_passk": 0.5, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n\"\"\"\nWrite a function to calculate the sum of perrin numbers.\nassert cal_sum(9) == 49\n\"\"\"", "generated_programs": ["from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        seq = [3, 0, 2]\n        while len(seq) < n:\n            seq.append(seq[-2] + seq[-3])\n        return seq[:n]\n    return sum(perrin_sequence(n))", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_numbers(limit: int) -> List[int]:\n        if limit == 0:\n            return []\n        if limit == 1:\n            return [3]\n        if limit == 2:\n            return [3, 0]\n        perrin = [3, 0, 2]\n        for i in range(3, limit):\n            perrin.append(perrin[i - 2] + perrin[i - 3])\n        return perrin\n    perrin = perrin_numbers(n)\n    return sum(perrin)", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        if n == 0:\n            return [3]\n        if n == 1:\n            return [3, 0]\n        if n == 2:\n            return [3, 0, 2]\n        seq = [3, 0, 2]\n        for i in range(3, n):\n            seq.append(seq[i - 2] + seq[i - 3])\n        return seq\n    seq = perrin_sequence(n)\n    return sum(seq)", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        if n == 0:\n            return [3]\n        if n == 1:\n            return [3, 0]\n        if n == 2:\n            return [3, 0, 2]\n        seq = [3, 0, 2]\n        for i in range(3, n + 1):\n            seq.append(seq[i - 2] + seq[i - 3])\n        return seq\n    sequence = perrin_sequence(n)\n    return sum(sequence)", "def cal_sum(n: int) -> int:\n\n    def perrin_number(index: int) -> int:\n        if index == 0:\n            return 3\n        elif index == 1:\n            return 0\n        elif index == 2:\n            return 2\n        return perrin_number(index - 2) + perrin_number(index - 3)\n    return sum((perrin_number(i) for i in range(n)))", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        if n < 3:\n            seq = [3, 0, 2][:n + 1]\n        else:\n            seq = [3, 0, 2]\n            for _ in range(3, n + 1):\n                seq.append(seq[-2] + seq[-3])\n        return seq\n    return sum(perrin_sequence(n))", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_number_series(n: int) -> List[int]:\n        if n == 0:\n            return []\n        if n == 1:\n            return [3]\n        if n == 2:\n            return [3, 0]\n        series = [3, 0, 2]\n        for i in range(3, n):\n            series.append(series[i - 2] + series[i - 3])\n        return series\n    return sum(perrin_number_series(n))", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        seq = [3, 0, 2]\n        for i in range(3, n + 1):\n            seq.append(seq[i - 2] + seq[i - 3])\n        return seq[:n]\n    return sum(perrin_sequence(n))", "import functools\n\ndef cal_sum(n: int) -> int:\n\n    def perrin(k: int) -> int:\n        if k == 0:\n            return 3\n        elif k == 1:\n            return 0\n        elif k == 2:\n            return 2\n        return perrin(k - 2) + perrin(k - 3)\n    return sum((perrin(i) for i in range(n)))", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_numbers(n: int) -> List[int]:\n        if n <= 0:\n            return []\n        nums = [3, 0, 2]\n        while len(nums) < n:\n            nums.append(nums[-2] + nums[-3])\n        return nums[:n]\n    return sum(perrin_numbers(n))"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.09999999999999998, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"Calculate the sum of all even factors of a given number n.\n    \n    The function should return 0 if the number is odd, as it has no even factors.\n    The sum includes only the even factors of the number.\n    \n    assert sumofFactors(18) == 26\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    sum_of_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_of_factors += i\n    return sum_of_factors", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "from typing import List\n\ndef sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    even_factors_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            even_factors_sum += i\n    return even_factors_sum", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "from typing import List\n\ndef sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if there is at least one word in the input string that contains the letter 'z'.\n    A word is defined as a sequence of word characters (alphanumeric and underscore) bounded by word boundaries.\n    \n    assert text_match_wordz(\"pythonz.\") == True\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    return any(('z' in word for word in re.findall('\\\\b\\\\w+\\\\b', text)))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return any((re.search('\\\\bz\\\\w*|\\\\w*z\\\\b', word) for word in re.findall('\\\\b\\\\w+\\\\b', text)))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return any((re.search('\\\\b\\\\w*z\\\\w*\\\\b', word) for word in re.findall('\\\\w+', text)))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return any(('z' in word for word in re.findall('\\\\b\\\\w+\\\\b', text)))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    pattern = '\\\\b\\\\w*z\\\\w*\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return any(('z' in word for word in re.findall('\\\\b\\\\w+\\\\b', text)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.9}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(combo) for combo in combinations(lst, r)])\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(combo) for combo in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combination in combinations(lst, r):\n            result.append(list(combination))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    return [list(comb) for r in range(len(lst) + 1) for comb in combinations(lst, r)]", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(comb) for comb in combinations(lst, r)])\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n\"\"\"\nWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nassert max_product([3, 100, 4, 5, 150, 6]) == 3000\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = arr[:]\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/555", "requirement": "def difference(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers. \n    The function should assume that n is a positive integer. If n is zero or negative, the function should return 0.\n    \n    assert difference(3) == 30\n    \"\"\"", "generated_programs": ["def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum((i for i in range(1, n + 1)))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((x ** 3 for x in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum((i for i in range(1, n + 1)))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "from typing import List\n\ndef difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum((i for i in range(1, n + 1)))\n    return sum_of_cubes - sum_of_numbers"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function which takes a list of integers and counts the number of possible unordered pairs of indices (i, j) where i < j and the elements at these indices are not equal.\n    \n    assert count_Pairs([1, 2, 1], 3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    pair_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                pair_count += 1\n    return pair_count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\nfrom collections import Counter\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    freq = Counter(arr)\n    total_pairs = n * (n - 1) // 2\n    same_pairs = sum((f * (f - 1) // 2 for f in freq.values()))\n    return total_pairs - same_pairs", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    pair_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                pair_count += 1\n    return pair_count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for i in range(n) for j in range(i + 1, n) if arr[i] != arr[j]))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "Mbpp/573", "requirement": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Write a Python function to calculate the product of the unique numbers in a given list.\n    If the list is empty, the function should return 1.\n    \n    assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    product = 1\n    for number in unique_numbers:\n        product *= number\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    from functools import reduce\n    if not list_data:\n        return 1\n    unique_numbers = set(list_data)\n    return reduce(lambda x, y: x * y, unique_numbers)", "from typing import List\nfrom math import prod\n\ndef unique_product(list_data: List[int]) -> int:\n    return prod(set(list_data)) if list_data else 1", "from typing import List\nfrom functools import reduce\n\ndef unique_product(list_data: List[int]) -> int:\n    if not list_data:\n        return 1\n    unique_numbers = set(list_data)\n    return reduce(lambda x, y: x * y, unique_numbers)", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    from functools import reduce\n    return reduce(lambda x, y: x * y, set(list_data), 1)", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    if not list_data:\n        return 1\n    unique_numbers = set(list_data)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    from functools import reduce\n    if not list_data:\n        return 1\n    unique_numbers = set(list_data)\n    return reduce(lambda x, y: x * y, unique_numbers)", "from typing import List\nfrom functools import reduce\nimport operator\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    return reduce(operator.mul, unique_numbers, 1)", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    from math import prod\n    return prod(set(list_data)) if list_data else 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Recursively remove elements from a nested mixed tuple that do not contain even numbers.\n    Specifically, this involves removing all odd numbers and any nested tuples that do not contain at least one even number.\n    \n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, tuple]]) -> Tuple[Union[int, tuple]]:\n\n    def filter_tuple(t):\n        if isinstance(t, int):\n            return t if t % 2 == 0 else None\n        elif isinstance(t, tuple):\n            filtered = tuple((x for x in (filter_tuple(x) for x in t) if x is not None))\n            return filtered if any((isinstance(x, int) and x % 2 == 0 for x in filtered)) else None\n    result = filter_tuple(test_tuple)\n    return result if isinstance(result, tuple) else (result,)", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, Tuple]]) -> Tuple[Union[int, Tuple]]:\n\n    def helper(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            filtered = tuple(filter(None, map(helper, element)))\n            return filtered if any((isinstance(sub, int) and sub % 2 == 0 for sub in filtered)) else None\n        return None\n    return tuple(filter(None, map(helper, test_tuple)))", "from typing import Tuple\n\ndef extract_even(test_tuple: tuple) -> tuple:\n\n    def recursive_filter(t: tuple) -> tuple:\n        filtered = []\n        for item in t:\n            if isinstance(item, int):\n                if item % 2 == 0:\n                    filtered.append(item)\n            elif isinstance(item, tuple):\n                nested_result = recursive_filter(item)\n                if nested_result:\n                    filtered.append(nested_result)\n        return tuple(filtered)\n    return recursive_filter(test_tuple)", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, Tuple]]) -> Tuple[Union[int, Tuple]]:\n\n    def filter_even(item):\n        if isinstance(item, int):\n            return item % 2 == 0\n        if isinstance(item, tuple):\n            filtered = tuple(filter(filter_even, item))\n            return filtered if any((isinstance(i, int) and i % 2 == 0 for i in filtered)) else None\n        return None\n    return tuple(filter(lambda x: filter_even(x) is not None, map(filter_even, test_tuple)))", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, Tuple]]) -> Tuple[Union[int, Tuple]]:\n\n    def helper(item):\n        if isinstance(item, int):\n            return item if item % 2 == 0 else None\n        elif isinstance(item, tuple):\n            filtered = tuple((helper(sub_item) for sub_item in item if helper(sub_item) is not None))\n            return filtered if any((isinstance(sub_item, int) and sub_item % 2 == 0 for sub_item in filtered)) else None\n    return tuple(filter(None, (helper(element) for element in test_tuple)))", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, Tuple]]) -> Tuple:\n\n    def is_even(item):\n        if isinstance(item, int):\n            return item % 2 == 0\n        elif isinstance(item, tuple):\n            return any((is_even(sub_item) for sub_item in item))\n\n    def filter_tuple(input_tuple):\n        if isinstance(input_tuple, tuple):\n            result = tuple((filter_tuple(sub_item) if isinstance(sub_item, tuple) else sub_item for sub_item in input_tuple if is_even(sub_item)))\n            return result if any((is_even(item) for item in result)) else ()\n        return input_tuple if is_even(input_tuple) else ()\n    return filter_tuple(test_tuple)", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def filter_tuple(t: Tuple) -> Tuple:\n        result = []\n        for item in t:\n            if isinstance(item, int):\n                if item % 2 == 0:\n                    result.append(item)\n            elif isinstance(item, tuple):\n                nested_result = filter_tuple(item)\n                if nested_result:\n                    result.append(nested_result)\n        return tuple(result)\n    return filter_tuple(test_tuple)", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, Tuple]]) -> Tuple[Union[int, Tuple]]:\n\n    def helper(item):\n        if isinstance(item, int):\n            return item if item % 2 == 0 else None\n        elif isinstance(item, tuple):\n            filtered = tuple(filter(None, map(helper, item)))\n            return filtered if any((isinstance(x, int) and x % 2 == 0 for x in filtered)) else None\n    return tuple(filter(None, map(helper, test_tuple)))", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, Tuple]]) -> Tuple[Union[int, Tuple]]:\n\n    def helper(value):\n        if isinstance(value, int):\n            return value if value % 2 == 0 else None\n        elif isinstance(value, tuple):\n            filtered_tuple = tuple((helper(v) for v in value if helper(v) is not None))\n            return filtered_tuple if any((isinstance(v, int) and v % 2 == 0 for v in filtered_tuple)) else None\n    result = tuple((v for v in test_tuple if helper(v) is not None))\n    return result", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, tuple]]) -> Tuple[Union[int, tuple]]:\n\n    def helper(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            filtered = tuple(filter(None, map(helper, element)))\n            return filtered if any((isinstance(i, int) and i % 2 == 0 for i in filtered)) else None\n    return tuple(filter(None, map(helper, test_tuple)))"], "result": {"repaired_passk": 0.6, "cross_model_passk": 0.30000000000000004, "original_passk": 0.7}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n\"\"\"\nWrite a Python function to find the surface area of a square pyramid with a given base edge length and slant height.\nassert surface_Area(3,4) == 33\n\"\"\"", "generated_programs": ["from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 4 * (0.5 * b * s)\n    return base_area + lateral_area", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Write a function to compute the polar representation (magnitude and angle) from rectangular coordinates (x, y)\n    and return a fixed complex number (-2+2.4492935982947064e-16j) as the second part of the tuple.\n    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return ((magnitude, angle), fixed_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return ((magnitude, angle), fixed_complex)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return ((magnitude, angle), fixed_complex)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return ((magnitude, angle), fixed_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return ((magnitude, angle), fixed_complex)", "from typing import Tuple\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude, angle = cmath.polar(complex(x, y))\n    return ((magnitude, angle), complex(-2, 2.4492935982947064e-16))", "from typing import Tuple\nfrom math import sqrt, atan2\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = sqrt(x ** 2 + y ** 2)\n    angle = atan2(y, x)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return ((magnitude, angle), fixed_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), complex(-2, 2.4492935982947064e-16))", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return ((magnitude, angle), fixed_complex)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    fixed_complex = complex(-2, 2.4492935982947064e-16)\n    return ((magnitude, angle), fixed_complex)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the difference between the first even and the first odd number in a given list.\n    If the list does not contain both an even and an odd number, return 0.\n    \n    assert diff_even_odd([1,3,5,7,4,1,6,8]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    return abs(even - odd) if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            return abs(first_even - first_odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((num for num in list1 if num % 2 == 0), None)\n    odd = next((num for num in list1 if num % 2 != 0), None)\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return abs(first_even - first_odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return abs(even - odd) if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return abs(first_even - first_odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if num % 2 == 0 and even_num is None:\n            even_num = num\n        elif num % 2 != 0 and odd_num is None:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            return abs(even_num - odd_num)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the k-th (1-indexed) smallest element from the given two sorted arrays.\n    If one or both arrays are empty, the function should handle these cases gracefully.\n    If k is larger than the combined length of both arrays, the function should return None.\n    \n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_helper(a, b, k):\n        if not a:\n            return b[k - 1]\n        if not b:\n            return a[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        idx_a = min(len(a), k // 2)\n        idx_b = k - idx_a\n        if a[idx_a - 1] < b[idx_b - 1]:\n            return kth_helper(a[idx_a:], b, k - idx_a)\n        else:\n            return kth_helper(a, b[idx_b:], k - idx_b)\n    combined_length = len(arr1) + len(arr2)\n    if k > combined_length:\n        return None\n    return kth_helper(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_smallest(a: List[int], b: List[int], k: int) -> int:\n        if not a:\n            return b[k - 1]\n        if not b:\n            return a[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        mid_a = len(a) // 2\n        mid_b = len(b) // 2\n        mid_a_val = a[mid_a]\n        mid_b_val = b[mid_b]\n        if mid_a + mid_b + 1 > k:\n            if mid_a_val > mid_b_val:\n                return kth_smallest(a[:mid_a], b, k)\n            else:\n                return kth_smallest(a, b[:mid_b], k)\n        elif mid_a_val > mid_b_val:\n            return kth_smallest(a, b[mid_b + 1:], k - mid_b - 1)\n        else:\n            return kth_smallest(a[mid_a + 1:], b, k - mid_a - 1)\n    total_length = len(arr1) + len(arr2)\n    if k > total_length or k < 1:\n        return None\n    return kth_smallest(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(arr1, arr2, k):\n        if not arr1:\n            return arr2[k - 1] if k <= len(arr2) else None\n        if not arr2:\n            return arr1[k - 1] if k <= len(arr1) else None\n        if k > len(arr1) + len(arr2):\n            return None\n        index1, index2 = (0, 0)\n        while k > 0:\n            if index1 == len(arr1):\n                return arr2[index2 + k - 1]\n            if index2 == len(arr2):\n                return arr1[index1 + k - 1]\n            if k == 1:\n                return min(arr1[index1], arr2[index2])\n            step = k // 2\n            new_index1 = min(index1 + step, len(arr1)) - 1\n            new_index2 = min(index2 + step, len(arr2)) - 1\n            if arr1[new_index1] < arr2[new_index2]:\n                k -= new_index1 - index1 + 1\n                index1 = new_index1 + 1\n            else:\n                k -= new_index2 - index2 + 1\n                index2 = new_index2 + 1\n        return None\n    return kth_element(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_from_sorted_arrays(A: List[int], B: List[int], k: int) -> int:\n        if len(A) > len(B):\n            A, B = (B, A)\n        if not A:\n            return B[k - 1] if k <= len(B) else None\n        if k == 1:\n            return min(A[0], B[0])\n        idx_A = min(len(A), k // 2)\n        idx_B = k - idx_A\n        if idx_B > len(B):\n            return None\n        if A[idx_A - 1] <= B[idx_B - 1]:\n            return kth_from_sorted_arrays(A[idx_A:], B, k - idx_A)\n        else:\n            return kth_from_sorted_arrays(A, B[idx_B:], k - idx_B)\n    if k > len(arr1) + len(arr2) or k <= 0:\n        return None\n    result = kth_from_sorted_arrays(arr1, arr2, k)\n    return result", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(arr1, arr2, k):\n        if not arr1:\n            return arr2[k - 1]\n        if not arr2:\n            return arr1[k - 1]\n        mid1 = len(arr1) // 2\n        mid2 = len(arr2) // 2\n        if mid1 + mid2 < k - 1:\n            if arr1[mid1] < arr2[mid2]:\n                return kth_element(arr1[mid1 + 1:], arr2, k - mid1 - 1)\n            else:\n                return kth_element(arr1, arr2[mid2 + 1:], k - mid2 - 1)\n        elif arr1[mid1] < arr2[mid2]:\n            return kth_element(arr1, arr2[:mid2], k)\n        else:\n            return kth_element(arr1[:mid1], arr2, k)\n    if k > len(arr1) + len(arr2):\n        return None\n    return kth_element(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(arr1, arr2, k):\n        if not arr1:\n            return arr2[k - 1] if k <= len(arr2) else None\n        if not arr2:\n            return arr1[k - 1] if k <= len(arr1) else None\n        if k > len(arr1) + len(arr2):\n            return None\n        i, j = (0, 0)\n        while k > 0:\n            if i == len(arr1):\n                return arr2[j + k - 1]\n            if j == len(arr2):\n                return arr1[i + k - 1]\n            if k == 1:\n                return min(arr1[i], arr2[j])\n            step = k // 2\n            step1 = min(len(arr1) - i, step)\n            step2 = min(len(arr2) - j, step)\n            if arr1[i + step1 - 1] < arr2[j + step2 - 1]:\n                i += step1\n                k -= step1\n            else:\n                j += step2\n                k -= step2\n    return kth_element(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(a: List[int], b: List[int], k: int) -> int:\n        if not a:\n            return b[k]\n        if not b:\n            return a[k]\n        if k == 0:\n            return min(a[0], b[0])\n        idx_a = min(len(a) - 1, k // 2)\n        idx_b = min(len(b) - 1, k // 2)\n        if a[idx_a] <= b[idx_b]:\n            return kth_element(a[idx_a + 1:], b, k - idx_a - 1)\n        else:\n            return kth_element(a, b[idx_b + 1:], k - idx_b - 1)\n    if k > len(arr1) + len(arr2) or k <= 0:\n        return None\n    return kth_element(arr1, arr2, k - 1)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2):\n        return None\n    merged = []\n    i, j = (0, 0)\n    while len(merged) < k and (i < len(arr1) or j < len(arr2)):\n        if i < len(arr1) and (j >= len(arr2) or arr1[i] <= arr2[j]):\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    return merged[-1] if len(merged) == k else None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_helper(a, b, k):\n        if not a:\n            return b[k - 1]\n        if not b:\n            return a[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        mid_a = len(a) // 2\n        mid_b = len(b) // 2\n        if mid_a + mid_b < k - 1:\n            if a[mid_a] < b[mid_b]:\n                return kth_helper(a[mid_a + 1:], b, k - mid_a - 1)\n            else:\n                return kth_helper(a, b[mid_b + 1:], k - mid_b - 1)\n        elif a[mid_a] < b[mid_b]:\n            return kth_helper(a, b[:mid_b], k)\n        else:\n            return kth_helper(a[:mid_a], b, k)\n    if k < 1 or k > len(arr1) + len(arr2):\n        return None\n    return kth_helper(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(a, b, k):\n        if not a:\n            return b[k - 1]\n        if not b:\n            return a[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        mid_a = len(a) // 2\n        mid_b = len(b) // 2\n        mid_a_value = a[mid_a]\n        mid_b_value = b[mid_b]\n        if mid_a + mid_b < k - 1:\n            if mid_a_value > mid_b_value:\n                return kth_element(a, b[mid_b + 1:], k - mid_b - 1)\n            else:\n                return kth_element(a[mid_a + 1:], b, k - mid_a - 1)\n        elif mid_a_value > mid_b_value:\n            return kth_element(a[:mid_a], b, k)\n        else:\n            return kth_element(a, b[:mid_b], k)\n    if k > len(arr1) + len(arr2):\n        return None\n    return kth_element(arr1, arr2, k)"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/607", "requirement": "from typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Write a function to search a string for a regex pattern. The function should return the matching substring, \n    a start index, and an end index. The end index is exclusive of the last character of the match.\n    \n    assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n    \"\"\"", "generated_programs": ["import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start, end = (match.start(), match.end())\n        return (match.group(), start, end)\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start, end = match.span()\n        return (match.group(), start, end)\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start, end = match.span()\n        return (text[start:end], start, end)\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start, end = (match.start(), match.end())\n        return (match.group(0), start, end)\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(0), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/610", "requirement": "from typing import List\n\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function which takes a list and an integer k, and returns a list with the same elements except for the element at index k removed. Index k is zero-based.\n    \n    assert remove_kth_element([1,1,2,3,4,4,5,1], 3) == [1, 1, 2, 4, 4, 5, 1]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return [element for index, element in enumerate(list1) if index != k]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/612", "requirement": "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a Python function which takes a list of lists and returns a list of two lists. \n    The first list contains the first elements of each sublist, and the second list contains the second elements of each sublist.\n    If a sublist has fewer than two elements, it contributes only the elements it has to the corresponding result list.\n    If a sublist has more than two elements, only the first two elements are considered.\n    \n    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) >= 1:\n            first_elements.append(sublist[0])\n        if len(sublist) >= 2:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) >= 1:\n            first_elements.append(sublist[0])\n        if len(sublist) >= 2:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) > 0:\n            first_elements.append(sublist[0])\n        if len(sublist) > 1:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) > 0:\n            first_elements.append(sublist[0])\n        if len(sublist) > 1:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    result = [[], []]\n    for sublst in lst:\n        if len(sublst) > 0:\n            result[0].append(sublst[0])\n        if len(sublst) > 1:\n            result[1].append(sublst[1])\n    return result", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    result = [[], []]\n    for sublist in lst:\n        if len(sublist) > 0:\n            result[0].append(sublist[0])\n        if len(sublist) > 1:\n            result[1].append(sublist[1])\n    return result", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) > 0:\n            first_elements.append(sublist[0])\n        if len(sublist) > 1:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    result = [[], []]\n    for sublist in lst:\n        if len(sublist) > 0:\n            result[0].append(sublist[0])\n        if len(sublist) > 1:\n            result[1].append(sublist[1])\n    return result", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    result = [[], []]\n    for sublist in lst:\n        if len(sublist) > 0:\n            result[0].append(sublist[0])\n        if len(sublist) > 1:\n            result[1].append(sublist[1])\n    return result", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    result = [[], []]\n    for sublist in lst:\n        if len(sublist) > 0:\n            result[0].append(sublist[0])\n        if len(sublist) > 1:\n            result[1].append(sublist[1])\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/615", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    \"\"\"\n    Write a function which takes a tuple of tuples and returns a list containing the average value for each corresponding element across all inner tuples.\n    \n    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum((inner_tuple[i] for inner_tuple in nums)) / len(nums) for i in range(len(nums[0]))]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(values) / len(values) for values in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(values) / len(values) for values in zip(*nums)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "Mbpp/622", "requirement": "def get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    \"\"\"Find the median of two sorted lists of the same size by merging them and selecting the middle elements.\n    \n    The function should merge the two input lists, sort the merged list, and then calculate the median as the average of the nth and (n-1)th elements in the sorted list.\n    \n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    median = (merged_list[n - 1] + merged_list[n]) / 2\n    return median", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    median = (merged_list[n - 1] + merged_list[n]) / 2\n    return median", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n    \"\"\"\n    Write a Python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius. The largest triangle in this context is an equilateral triangle with its base along the diameter of the semicircle.\n    \n    For a non-positive radius, the function should return None.\n    \n    assert triangle_area(-1) == None\n    \n    ### Test 1\n    Input: [5.0]\n    Expected Output: [10.825317547305483]\n    \n    ### Test 2\n    Input: [5.0]\n    Expected Output: [10.825317547305483]\n    \n    ### Test 3\n    Input: [0.0]\n    Expected Output: [None]\n    \"\"\"", "generated_programs": ["import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\nfrom typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = 2 * radius\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side = radius * 2\n    area = math.sqrt(3) / 4 * side ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    area = radius ** 2 * math.sqrt(3)\n    return area / 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n\"\"\"\nWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\nassert wind_chill(120,35)==40\n\"\"\"", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wind_chill_index)", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wind_chill_index)", "from math import pow\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * pow(v, 0.16) + 0.3965 * t * pow(v, 0.16)\n    return round(wind_chill_index)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.6, "original_passk": 0.4}}
{"task_id": "Mbpp/643", "requirement": "def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a string contains 'z' either as a standalone word or within a word but not at the start or end of that word.\n    \n    assert text_match_wordz_middle(\"pythonzabc.\") == True\n    \n    ### Test 1\n    Input: ['zpythonabc.']\n    Expected Output: [False]\n    \n    ### Test 2\n    Input: ['z']\n    Expected Output: [True]\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return re.search('\\\\b\\\\w+z\\\\w+\\\\b|\\\\bz\\\\b', text) is not None", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('(?<!\\\\w)z(?!\\\\w)|\\\\w+z\\\\w+', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    if re.search('\\\\Bz\\\\B', text):\n        return True\n    if re.search('\\\\bz\\\\b', text):\n        return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    if re.search('\\\\bz\\\\b', text):\n        return True\n    if re.search('\\\\Bz\\\\B', text):\n        return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w+z\\\\w+\\\\b', text) or re.search('\\\\bz\\\\b', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    if re.search('\\\\bz\\\\b', text):\n        return True\n    if re.search('\\\\Bz\\\\B', text):\n        return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\b[a-zA-Z]*\\\\Bz\\\\B[a-zA-Z]*\\\\b|\\\\bz\\\\b', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/722", "requirement": "from typing import Dict\nfrom typing import Tuple\n\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight greater than or equal to the minimum.\n    assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)},6.0,70)=={'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: details for name, details in students.items() if details[0] >= h and details[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: details for name, details in students.items() if details[0] >= h and details[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: info for name, info in students.items() if info[0] >= h and info[1] >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/734", "requirement": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of products of all possible contiguous subarrays (sublists) of a given list.\n    \n    A contiguous subarray is defined as a sequence of elements within the array that are contiguous (i.e., consecutive without any gaps).\n    \n    Parameters:\n    arr (List[int]): A list of integers.\n    \n    Returns:\n    int: The sum of products of all possible contiguous subarrays.\n    \n    Example:\n    assert sum_Of_Subarray_Prod([1,2,3]) == 20\n    \n    Input: [4, 5, 6]\n    Expected Output: 185\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for start in range(n):\n        product = 1\n        for end in range(start, n):\n            product *= arr[end]\n            result += product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= arr[j]\n            total_sum += current_product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for start in range(n):\n        product = 1\n        for end in range(start, n):\n            product *= arr[end]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    result = 0\n    n = len(arr)\n    for i in range(n):\n        subarray_prod = 1\n        for j in range(i, n):\n            subarray_prod *= arr[j]\n            result += subarray_prod\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        prod = 1\n        for j in range(i, n):\n            prod *= arr[j]\n            result += prod\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/739", "requirement": "def find_Index(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the index of the smallest triangular number that has at least n digits.\n    A triangular number or triangle number counts objects arranged in an equilateral triangle.\n    \n    assert find_Index(2) == 4\n    ### Test 1\n    Input: [3]\n    Expected Output: [14]\n    ### Test 2\n    Input: [0]\n    Expected Output: [1]\n    \"\"\"", "generated_programs": ["import math\n\ndef find_Index(n: int) -> int:\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if len(str(triangular_number)) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n\n    def triangular_number(index: int) -> int:\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        if len(str(triangular_number(index))) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    from math import sqrt, floor\n\n    def triangular_number(index):\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        if len(str(triangular_number(index))) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    import math\n\n    def triangular_number(index: int) -> int:\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        t_num = triangular_number(index)\n        if len(str(t_num)) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    import math\n\n    def triangular_number(index: int) -> int:\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        if math.floor(math.log10(triangular_number(index))) + 1 >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n\n    def triangular_number(index: int) -> int:\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        if len(str(triangular_number(index))) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    import math\n\n    def triangular_number(index):\n        return index * (index + 1) // 2\n    index = 1\n    while int(math.log10(triangular_number(index))) + 1 < n:\n        index += 1\n    return index", "def find_Index(n: int) -> int:\n    from math import sqrt\n\n    def triangular_number(index):\n        return index * (index + 1) // 2\n\n    def digit_count(number):\n        return len(str(number))\n    index = 1\n    while True:\n        t_num = triangular_number(index)\n        if digit_count(t_num) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n\n    def triangular_number(index: int) -> int:\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        tri_number = triangular_number(index)\n        if len(str(tri_number)) >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n\n    def triangular_number(k: int) -> int:\n        return k * (k + 1) // 2\n    index = 1\n    while True:\n        t_number = triangular_number(index)\n        if len(str(t_number)) >= n:\n            return index\n        index += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Write a function to find positive numbers within a given range from startnum to endnum \n    where every non-zero digit of the number divides the number evenly. \n    The function should exclude negative numbers and numbers containing the digit zero from consideration.\n    If negative numbers are provided as input, the function should raise a ValueError.\n    \n    assert divisible_by_digits(1,22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    \n    ### Test 1\n    Input: [-10, 10]\n    Expected Output: ['ValueError']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n\n    def is_divisible_by_digits(num: int) -> bool:\n        digits = [int(d) for d in str(num) if d != '0']\n        return all((num % d == 0 for d in digits))\n    return [i for i in range(startnum, endnum + 1) if is_divisible_by_digits(i)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers provided as input.')\n\n    def is_divisible_by_digits(num: int) -> bool:\n        for digit_str in str(num):\n            digit = int(digit_str)\n            if digit == 0 or num % digit != 0:\n                return False\n        return True\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        non_zero_digits = [int(d) for d in str(num)]\n        if all((num % digit == 0 for digit in non_zero_digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n\n    def is_divisible_by_digits(num: int) -> bool:\n        digits = [int(d) for d in str(num) if d != '0']\n        return all((num % digit == 0 for digit in digits))\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num > 0 and '0' not in str(num) and is_divisible_by_digits(num):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        if all((num % int(digit) == 0 for digit in str(num) if int(digit) != 0)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for number in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(number) if d != '0']\n        if '0' in str(number):\n            continue\n        if all((number % digit == 0 for digit in digits)):\n            result.append(number)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n\n    def is_valid(num: int) -> bool:\n        digits = [int(d) for d in str(num) if d != '0']\n        return all((num % digit == 0 for digit in digits))\n    return [num for num in range(startnum, endnum + 1) if num > 0 and '0' not in str(num) and is_valid(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = list(str(num))\n        if '0' not in digits and all((num % int(digit) == 0 for digit in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers provided as input.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        if '0' in str_num:\n            continue\n        if all((num % int(digit) == 0 for digit in str_num)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed as input.')\n\n    def is_divisible_by_digits(num: int) -> bool:\n        digits = [int(d) for d in str(num) if d != '0']\n        return all((num % d == 0 for d in digits))\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.4}}
{"task_id": "Mbpp/748", "requirement": "def capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to insert spaces before each uppercase letter in a given string that starts a new word, except when the uppercase letter is the very first character of the entire string. This means spaces are added between words starting with capital letters, treating consecutive uppercase letters as part of a single word unless they clearly denote the start of a new word. The function should handle an empty string by returning an empty string without errors.\n\n    Examples:\n    assert capital_words_spaces(\"Python\") == 'Python'\n    assert capital_words_spaces(\"thisIsATestString\") == 'this Is A Test String'\n    assert capital_words_spaces(\"thisIsAnExampleOfTheFunction\") == 'this Is An Example Of The Function'\n    assert capital_words_spaces(\"NASAHeadquarters\") == 'NASA Headquarters'\n    \"\"\"", "generated_programs": ["def capital_words_spaces(str1: str) -> str:\n    import re\n    if not str1:\n        return ''\n    result = re.sub('(?<!^)(?=[A-Z][a-z])', ' ', str1)\n    return result", "def capital_words_spaces(str1: str) -> str:\n    result = []\n    for i, char in enumerate(str1):\n        if char.isupper() and i > 0 and (not str1[i - 1].isupper()):\n            result.append(' ')\n        result.append(char)\n    return ''.join(result)", "def capital_words_spaces(str1: str) -> str:\n    import re\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "def capital_words_spaces(str1: str) -> str:\n    import re\n    return re.sub('(?<=[a-z])(?=[A-Z])', ' ', str1)", "def capital_words_spaces(str1: str) -> str:\n    import re\n    return re.sub('(?<=[a-z])(?=[A-Z])', ' ', str1)", "def capital_words_spaces(str1: str) -> str:\n    import re\n    return re.sub('(?<!^)(?=[A-Z][a-z])', ' ', str1)", "def capital_words_spaces(str1: str) -> str:\n    import re\n    return re.sub('(?<=[a-z])(?=[A-Z])', ' ', str1)", "def capital_words_spaces(str1: str) -> str:\n    import re\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "def capital_words_spaces(str1: str) -> str:\n    import re\n    if not str1:\n        return ''\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "def capital_words_spaces(str1: str) -> str:\n    import re\n    return re.sub('(?<!^)(?<![A-Z])(?=[A-Z])', ' ', str1)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/759", "requirement": "def is_decimal(num: str) -> bool:\n    \"\"\"\n    Write a function to check whether a given string is a decimal number with exactly two decimal places.\n    assert is_decimal('123.11') == True\n    \"\"\"", "generated_programs": ["import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "from typing import Union\n\ndef is_decimal(num: str) -> bool:\n    try:\n        parts = num.split('.')\n        return len(parts) == 2 and len(parts[1]) == 2 and all((part.isdigit() for part in parts))\n    except Exception:\n        return False", "def is_decimal(num: str) -> bool:\n    if '.' not in num:\n        return False\n    parts = num.split('.')\n    if len(parts) != 2:\n        return False\n    integer_part, decimal_part = parts\n    if not integer_part.isdigit():\n        return False\n    if len(decimal_part) != 2 or not decimal_part.isdigit():\n        return False\n    return True", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.match('^-?\\\\d+\\\\.\\\\d{2}$', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('-?\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List\n\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n\"\"\"\nWrite a python function to find the minimum difference between any two elements in a given array. \nassert find_min_diff((1,5,3,19,18,25),6) == 1\n\"\"\"", "generated_programs": ["from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, abs(arr[i + 1] - arr[i]))\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    if n <= 1:\n        return 0\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, arr[i + 1] - arr[i])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, arr[i + 1] - arr[i])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, arr[i + 1] - arr[i])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, arr[i + 1] - arr[i])\n    return min_diff"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number. A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers. The sequence of polite numbers starts with 3, 5, 6, 7, 9, 10, 11, etc. Note that powers of two are not polite numbers.\n    \n    assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x & x - 1 == 0 and x > 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n        current += 1\n    return polite_numbers[n - 1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x > 0 and x & x - 1 == 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n    return polite_numbers[n - 1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x & x - 1 == 0 and x > 0\n    polite_numbers = []\n    num = 1\n    while len(polite_numbers) < n:\n        num += 1\n        if not is_power_of_two(num):\n            polite_numbers.append(num)\n    return polite_numbers[-1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x & x - 1 == 0 and x > 0\n    polite_numbers = []\n    candidate = 1\n    while len(polite_numbers) < n:\n        candidate += 1\n        if not is_power_of_two(candidate):\n            polite_numbers.append(candidate)\n    return polite_numbers[n - 1]", "from math import log2, floor\n\ndef is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return log2(x) == floor(log2(x))\n    count = 0\n    number = 1\n    while count < n:\n        number += 1\n        if not is_power_of_two(number):\n            count += 1\n    return number", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x & x - 1 == 0 and x != 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n    return polite_numbers[n - 1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x & x - 1 == 0 and x > 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n        current += 1\n    return polite_numbers[n - 1]", "from typing import List\n\ndef is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x != 0 and x & x - 1 == 0\n    count = 0\n    num = 1\n    while count < n:\n        num += 1\n        if not is_power_of_two(num):\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x > 0 and x & x - 1 == 0\n    polite_numbers = []\n    current_number = 1\n    while len(polite_numbers) < n:\n        current_number += 1\n        if not is_power_of_two(current_number):\n            polite_numbers.append(current_number)\n    return polite_numbers[n - 1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x & x - 1 == 0 and x > 0\n    polite_numbers = []\n    num = 3\n    while len(polite_numbers) < n:\n        if not is_power_of_two(num):\n            polite_numbers.append(num)\n        num += 1\n    return polite_numbers[n - 1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/771", "requirement": "def check_expression(expression: str) -> bool:\n    \"\"\"Check if the given expression containing brackets is balanced.\n    \n    A string with balanced brackets means that each opening bracket has a corresponding closing bracket of the same type and brackets are properly nested.\n    \n    assert check_expression(\"{()}[{}]\") == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef check_expression(expression: str) -> bool:\n    bracket_pairs = {'(': ')', '{': '}', '[': ']'}\n    stack: List[str] = []\n    for char in expression:\n        if char in bracket_pairs:\n            stack.append(char)\n        elif char in bracket_pairs.values():\n            if not stack or bracket_pairs[stack.pop()] != char:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', ']': '[', '}': '{'}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    bracket_map = {')': '(', ']': '[', '}': '{'}\n    stack: List[str] = []\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map:\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if stack and stack[-1] == bracket_map[char]:\n                stack.pop()\n            else:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            stack.pop()\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack: List[str] = []\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if stack and stack[-1] == bracket_map[char]:\n                stack.pop()\n            else:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            stack.pop()\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    brackets = {'(': ')', '{': '}', '[': ']'}\n    for char in expression:\n        if char in brackets:\n            stack.append(char)\n        elif char in brackets.values():\n            if not stack or brackets[stack.pop()] != char:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    bracket_map = {'(': ')', '{': '}', '[': ']'}\n    stack: List[str] = []\n    for char in expression:\n        if char in bracket_map:\n            stack.append(char)\n        elif char in bracket_map.values():\n            if not stack or bracket_map[stack.pop()] != char:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    opening_brackets = set(bracket_map.values())\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in bracket_map:\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            stack.pop()\n    return not stack"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/780", "requirement": "def find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"Find all unique pairs of tuples from the given list and return a list of tuples where each tuple is the element-wise sum of the pairs.\n    \n    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    from itertools import combinations\n    result = [tuple(map(sum, zip(a, b))) for a, b in combinations(test_list, 2)]\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    n = len(test_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            result.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            pair_sum = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            result.append(pair_sum)\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    length = len(test_list)\n    for i in range(length):\n        for j in range(i + 1, length):\n            result.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return result", "from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [(a[0] + b[0], a[1] + b[1]) for a, b in combinations(test_list, 2)]", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    n = len(test_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            pair_sum = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            result.append(pair_sum)\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            result.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            result.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            pair_sum = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            result.append(pair_sum)\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    from itertools import combinations\n    result = []\n    for pair in combinations(test_list, 2):\n        result.append((pair[0][0] + pair[1][0], pair[0][1] + pair[1][1]))\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/782", "requirement": "def odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of the sums of all odd-length contiguous subarrays.\n    A subarray is considered odd-length if it contains an odd number of elements.\n    Iterate over all possible subarrays, check if their lengths are odd,\n    and if so, add their sums to the total sum.\n\n    assert odd_length_sum([1, 2, 4]) == 14\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n):\n            if (end - start + 1) % 2 == 1:\n                total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 != 0:\n                total_sum += sum(arr[i:j + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n):\n            if (end - start + 1) % 2 == 1:\n                total_sum += sum(arr[start:end + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 == 1:\n                total_sum += sum(arr[i:j + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 != 0:\n                total_sum += sum(arr[i:j + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 != 0:\n                total_sum += sum(arr[i:j + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 != 0:\n                total_sum += sum(arr[i:j + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        subarray_sum = 0\n        for end in range(start, n):\n            subarray_sum += arr[end]\n            if (end - start + 1) % 2 == 1:\n                total_sum += subarray_sum\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 != 0:\n                total_sum += sum(arr[i:j + 1])\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 != 0:\n                total_sum += sum(arr[i:j + 1])\n    return total_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even and odd number in a given list.\n    If the list does not contain both an even and an odd number, return 0.\n    \n    assert mul_even_odd([1,3,5,7,4,1,6,8]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = next((num for num in list1 if num % 2 == 0), None)\n    odd = next((num for num in list1 if num % 2 != 0), None)\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/790", "requirement": "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a Python function to check if the number at every even index is even in a given list.\n    \n    assert even_position([3, 2, 1]) == False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n\"\"\"\nWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\nassert text_starta_endb(\"aabbbb\")\n\"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.search('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a.*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.search('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = 'a.*b\\\\Z'\n    return re.search(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = 'a.*b$'\n    return re.search(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('a.*b$', text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/797", "requirement": "def sum_in_range(l: int, r: int) -> int:\n\"\"\"\nWrite a Python function to find the sum of all odd positive integers within the range [l, r].\nPositive integers start from 1. The function should ignore any negative numbers or zero in the range.\nassert sum_in_range(2,5) == 8\n\"\"\"", "generated_programs": ["def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(l, r + 1) if x > 0 and x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((num for num in range(max(1, l), r + 1) if num % 2 != 0))", "from typing import List\n\ndef sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(max(1, l), r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 == 1))", "def sum_in_range(l: int, r: int) -> int:\n    return sum([x for x in range(max(l, 1), max(r + 1, 1)) if x % 2 != 0])", "from typing import List\n\ndef sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(max(1, l), r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(max(1, l), r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(l, r + 1) if i > 0 and i % 2 != 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/4", "requirement": "def heap_queue_largest(nums: list, n: int) -> list:\n    \"\"\"\n    Write a function to find the n largest integers from a given list of numbers and return them in strictly descending order.\n\n    assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    \"\"\"", "generated_programs": ["import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(nlargest(n, nums), reverse=True)", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "from heapq import nlargest\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)"], "result": {"repaired_passk": 0.5, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/20", "requirement": "def is_woodall(num: int) -> bool:\n    \"\"\"Check if the given number is a Woodall number. A Woodall number is defined as a number of the form n * 2^n - 1, where n is a positive integer.\nassert is_woodall(383) == True\n\"\"\"", "generated_programs": ["from math import log2\n\ndef is_woodall(num: int) -> bool:\n    if num <= 0:\n        return False\n    n = log2((num + 1) / 2 ** int(log2(num + 1)))\n    return n.is_integer()", "from math import log2, floor\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = floor(log2(num + 1))\n    return num == n * 2 ** n - 1", "from typing import List\n\ndef is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall_candidate = n * 2 ** n - 1\n        if woodall_candidate == num:\n            return True\n        if woodall_candidate > num:\n            return False\n        n += 1", "from math import log2, isclose\n\ndef is_woodall(num: int) -> bool:\n    if num <= 0:\n        return False\n    n = log2(num + 1)\n    return n.is_integer() and isclose(n * 2 ** int(n) - 1, num)", "def is_woodall(num: int) -> bool:\n    from math import log2, floor\n    if num <= 0:\n        return False\n    n = floor(log2(num + 1))\n    return num == n * 2 ** n - 1", "from math import log2, floor\n\ndef is_woodall(num: int) -> bool:\n    if num <= 0:\n        return False\n    n = floor(log2(num + 1))\n    return n * 2 ** n - 1 == num", "from math import log2\n\ndef is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = int(log2(num + 1))\n    return num == n * 2 ** n - 1", "from typing import List\n\ndef is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall_number = n * 2 ** n - 1\n        if woodall_number == num:\n            return True\n        elif woodall_number > num:\n            return False\n        n += 1", "from math import log2, floor\n\ndef is_woodall(num: int) -> bool:\n    if num <= 0:\n        return False\n    n = floor(log2(num + 1))\n    return num == n * 2 ** n - 1", "from math import log2\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = log2(num + 1)\n    return n.is_integer() and int(n) * 2 ** int(n) - 1 == num"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.6}}
{"task_id": "Mbpp/58", "requirement": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"Check if the two given 32-bit signed integers have opposite signs using bitwise operations.\n    \n    The function should return True if x and y have opposite signs, otherwise False.\n    This is achieved by performing a bitwise XOR on x and y, then checking if the 32nd bit (sign bit) is set.\n    \n    assert opposite_Signs(1, -2) == True\n    \n    ### Test 1\n    Input: [0, 5]\n    Expected Output: [False]\n    \n    ### Test 2\n    Input: [100, -100]\n    Expected Output: [True]\n    \"\"\"", "generated_programs": ["def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/61", "requirement": "def count_Substrings(s: str) -> int:\n    \"\"\"Count the number of substrings where the sum of the digits equals the length of the substring.\n    \n    assert count_Substrings('112112') == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Substrings(s: str) -> int:\n\n    def digit_sum(substring: str) -> int:\n        return sum((int(char) for char in substring))\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if digit_sum(substring) == len(substring):\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j + 1]\n            digit_sum = sum((int(char) for char in substring))\n            if digit_sum == len(substring):\n                count += 1\n    return count", "import itertools\n\ndef count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for start in range(n):\n        for end in range(start + 1, n + 1):\n            substring = s[start:end]\n            sum_digits = sum((int(ch) for ch in substring))\n            if sum_digits == len(substring):\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            digit_sum = sum((int(ch) for ch in substring))\n            if digit_sum == len(substring):\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        substring_sum = 0\n        for j in range(i, n):\n            substring_sum += int(s[j])\n            if substring_sum == j - i + 1:\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for start in range(n):\n        digit_sum = 0\n        for end in range(start, n):\n            digit_sum += int(s[end])\n            if digit_sum == end - start + 1:\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n\n    def sum_of_digits(substr: str) -> int:\n        return sum((int(char) for char in substr))\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if sum_of_digits(substr) == len(substr):\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n\n    def digit_sum(sub: str) -> int:\n        return sum((int(c) for c in sub))\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            sub = s[i:j]\n            if digit_sum(sub) == len(sub):\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n\n    def sum_of_digits(substring: str) -> int:\n        return sum((int(char) for char in substring))\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if sum_of_digits(substring) == len(substring):\n                count += 1\n    return count", "from typing import List\n\ndef count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for start in range(n):\n        for end in range(start + 1, n + 1):\n            substring = s[start:end]\n            digit_sum = sum((int(ch) for ch in substring))\n            if digit_sum == len(substring):\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/84", "requirement": "def sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the Newman-Conway Sequence. \n    The function is defined for n >= 1. For n = 0, the function will raise an IndexError.\n    \n    assert sequence(10) == 6\n    \"\"\"", "generated_programs": ["def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('The Newman-Conway sequence is not defined for n = 0.')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('Newman-Conway sequence is undefined for n <= 0.')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('Input must be n >= 1')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be >= 1')\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    numbers = [0] * (n + 1)\n    numbers[1] = 1\n    numbers[2] = 1\n    for i in range(3, n + 1):\n        numbers[i] = numbers[numbers[i - 1]] + numbers[i - numbers[i - 1]]\n    return numbers[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be >= 1')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0, 1, 1]\n    for i in range(3, n + 1):\n        seq.append(seq[seq[i - 1]] + seq[i - seq[i - 1]])\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('The sequence is undefined for n < 1.')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "from functools import lru_cache\n\ndef sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('The Newman-Conway sequence is defined for n >= 1.')\n    if n == 1 or n == 2:\n        return 1\n    return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1))", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('Index must be 1 or greater.')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be >= 1')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0, 1, 1]\n    for i in range(3, n + 1):\n        seq.append(seq[seq[i - 1]] + seq[i - seq[i - 1]])\n    return seq[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('Index should be >= 1')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n\"\"\"\nWrite a Python function to find the number of divisors of a given integer. \nFor non-positive integers (zero and negative numbers), the function should return 0.\nassert divisor(15) == 4\n\"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))", "from typing import Optional\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    return sum((1 for i in range(1, n + 1) if n % i == 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements that appear in all sublists within the given nested list.\n    If the input is an empty list of lists, the function should raise an IndexError.\n    \n    assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not lst for lst in nestedlist)):\n        raise IndexError('Empty list or empty sublist encountered.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Input nested list is empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(sublist) == 0 for sublist in nestedlist)):\n        raise IndexError('The input is an empty list or contains empty sublists.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(lst) == 0 for lst in nestedlist)):\n        raise IndexError('The input list is empty or contains empty sublist.')\n    common_elements = set(nestedlist[0])\n    for lst in nestedlist[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise IndexError('The input is an empty list of lists.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Input is an empty list of lists.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or not all((isinstance(sublist, list) for sublist in nestedlist)):\n        raise IndexError('Input must be a non-empty nested list.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise IndexError('The input list cannot be empty or contain empty sublists.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise IndexError('Input nested list cannot be empty or contain empty sublists.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(sublist) == 0 for sublist in nestedlist)):\n        raise IndexError('Input nested list contains empty sublist or is completely empty.')\n    common_elements = set(nestedlist[0]).intersection(*nestedlist[1:])\n    return list(common_elements)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.30000000000000004, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to sum all amicable numbers up to, but not including, a specified number.\n\n    assert amicable_numbers_sum(999) == 504\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_divisors(a)\n        if b != a and b < limit and (sum_of_divisors(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def divisors_sum(n: int) -> int:\n        return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n\n    def find_amicable_pairs(limit: int) -> List[int]:\n        amicable_numbers = set()\n        for a in range(2, limit):\n            b = divisors_sum(a)\n            if b != a and b < limit and (divisors_sum(b) == a):\n                amicable_numbers.add(a)\n                amicable_numbers.add(b)\n        return list(amicable_numbers)\n    return sum(find_amicable_pairs(limit))", "from typing import List\n\ndef sum_of_divisors(n: int) -> int:\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\n\ndef is_amicable(a: int, b: int) -> bool:\n    return a != b and sum_of_divisors(a) == b and (sum_of_divisors(b) == a)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for num in range(2, limit):\n        partner = sum_of_divisors(num)\n        if partner < limit and is_amicable(num, partner):\n            amicable_sum += num\n    return amicable_sum", "from typing import List\n\ndef divisors_sum(n: int) -> int:\n    return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def is_amicable(a: int) -> bool:\n        b = divisors_sum(a)\n        return b != a and divisors_sum(b) == a\n    return sum(filter(is_amicable, range(1, limit)))", "from math import sqrt\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        total = 1\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_divisors(a)\n        if a != b and b < limit and (sum_of_divisors(b) == a):\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef sum_of_divisors(n: int) -> int:\n    return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for i in range(1, limit):\n        a = sum_of_divisors(i)\n        b = sum_of_divisors(a)\n        if i != a and b == i and (a < limit):\n            amicable_sum += i\n    return amicable_sum", "from typing import List\n\ndef divisors_sum(n: int) -> int:\n    return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = divisors_sum(a)\n        if b != a and divisors_sum(b) == a:\n            amicable_sum += a\n    return amicable_sum", "from typing import List\n\ndef divisors_sum(n: int) -> int:\n    return sum((i for i in range(1, n // 2 + 1) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def is_amicable(a: int) -> bool:\n        b = divisors_sum(a)\n        return b != a and divisors_sum(b) == a\n    return sum((a for a in range(2, limit) if is_amicable(a)))", "from typing import List\n\ndef divisor_sum(n: int) -> int:\n    return sum((i for i in range(1, n) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for num in range(2, limit):\n        pair = divisor_sum(num)\n        if pair != num and pair < limit and (divisor_sum(pair) == num):\n            amicable_sum += num\n    return amicable_sum", "from typing import List\n\ndef sum_of_divisors(n: int) -> int:\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def is_amicable(a: int) -> bool:\n        b = sum_of_divisors(a)\n        return b != a and sum_of_divisors(b) == a\n    return sum((a for a in range(2, limit) if is_amicable(a)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n\"\"\"\nCalculate the angle of the direction from complex number `a` to complex number `b`.\nassert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n\"\"\"", "generated_programs": ["import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    difference = b - a\n    return math.atan2(difference.imag, difference.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    direction = b - a\n    return math.atan2(direction.imag, direction.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    delta = b - a\n    return math.atan2(delta.imag, delta.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    delta = b - a\n    return math.atan2(delta.imag, delta.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    direction = b - a\n    return math.atan2(direction.imag, direction.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    delta = b - a\n    angle = math.atan2(delta.imag, delta.real)\n    return angle", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag - a.imag, b.real - a.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    diff = b - a\n    return math.atan2(diff.imag, diff.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag - a.imag, b.real - a.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    delta = b - a\n    return math.atan2(delta.imag, delta.real)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine if the given matrix is a magic square.\n    A magic square is a square matrix where the sums of every row, column,\n    and both main diagonals are equal. The function should return False for\n    non-square matrices or empty matrices.\n    \n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    target_sum = sum(my_matrix[0])\n    for i in range(n):\n        if sum(my_matrix[i]) != target_sum or sum((row[i] for row in my_matrix)) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or any((len(row) != len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    expected_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != expected_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != expected_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != expected_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != expected_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_sum or sum((my_matrix[j][i] for j in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum or sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if n == 0 or any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    size = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(size):\n        if sum((my_matrix[row][col] for row in range(size))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(size))) != magic_sum:\n        return False\n    if sum((my_matrix[i][size - i - 1] for i in range(size))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col_idx in range(n):\n        if sum((my_matrix[row_idx][col_idx] for row_idx in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != target_sum:\n        return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given number can be represented as the sum of powers of two, \n    including \\(2^0\\). The function should return True if the number can be expressed as such a sum, and False otherwise.\n    \n    assert is_Sum_Of_Powers_Of_Two(10) == True\n    \"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 not in (0, 1):\n            return False\n        n //= 2\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n >= 0 and bin(n).count('1') > 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n >= 0 and n == sum(((1 << i) * (n >> i & 1) for i in range(n.bit_length())))", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n < 0:\n        return False\n    while n > 0:\n        if n % 2 == 1:\n            n -= 1\n        n //= 2\n    return n == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n >= 0 and bin(n).count('1') >= 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 0 or n % 2 == 1:\n            n //= 2\n        else:\n            return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n >= 0 and bin(n).count('1') > 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n >= 0 and n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n > 0 and n & n - 1 == 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/160", "requirement": "def find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"Finds and returns a pair of integers (x, y) such that ax + by = n, or None if no such integers exist.\n    \n    The function iterates over possible values of x and checks if there exists a corresponding integer y that satisfies the equation.\n    assert find_solution(2, 3, 7) == (2, 1)\n    \"\"\"", "generated_programs": ["from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // abs(a) + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n) // abs(a) - 1, abs(n) // abs(a) + 2):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n + 1):\n        y = (n - a * x) / b\n        if y.is_integer():\n            return (x, int(y))\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n), abs(n) + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n // a) - 1, abs(n // a) + 2):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n), abs(n) + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(-abs(n), abs(n) + 1):\n        y, remainder = divmod(n - a * x, b)\n        if remainder == 0:\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.6}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n\"\"\"\nWrite a Python function that returns the given number without modifying it.\nThe term \"set all even bits\" in this context means to return the number as is, without changing any of its bits.\nassert even_bit_set_number(10) == 10\n\"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n,\n    where each element is a positive integer starting from 1 up to m, and each element (except the first) is at least\n    twice the previous element. The function should return the total number of such sequences.\n    \n    assert get_total_number_of_sequences(10, 4) == 4\n    \n    ### Test 1\n    Input: [7, 0]\n    Expected Output: [0]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(prev_value: int, length: int) -> int:\n        if length == n:\n            return 1\n        total = 0\n        for next_value in range(prev_value * 2, m + 1):\n            total += count_sequences(next_value, length + 1)\n        return total\n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(start_value, 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start, length):\n        if length == 0:\n            return 1\n        total = 0\n        for next_value in range(start * 2, m + 1):\n            total += count_sequences(next_value, length - 1)\n        return total\n    total_sequences = 0\n    for first_value in range(1, m + 1):\n        total_sequences += count_sequences(first_value, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(prev: int, length: int) -> int:\n        if length == 0:\n            return 1\n        count = 0\n        for next_elem in range(prev * 2, m + 1):\n            count += count_sequences(next_elem, length - 1)\n        return count\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, n - 1)\n    return total_count", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start: int, remaining: int) -> int:\n        if remaining == 0:\n            return 1\n        total = 0\n        for next_num in range(start * 2, m + 1):\n            total += count_sequences(next_num, remaining - 1)\n        return total\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for first_num in range(1, m + 1):\n        total_sequences += count_sequences(first_num, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        for i in range(start * 2, m + 1):\n            total += count_sequences(i, length - 1)\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += count_sequences(i, n)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def helper(prev, length):\n        if length == n:\n            return 1\n        total = 0\n        for i in range(prev * 2, m + 1):\n            total += helper(i, length + 1)\n        return total\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += helper(start, 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        total = 0\n        for next_num in range(current * 2, m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        return total\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start, length):\n        if length == 1:\n            return 1\n        count = 0\n        for next_value in range(2 * start, m + 1):\n            count += count_sequences(next_value, length - 1)\n        return count\n    total_sequences = 0\n    if n == 0:\n        return 0\n    for starting_value in range(1, m + 1):\n        total_sequences += count_sequences(starting_value, n)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start: int, length: int) -> int:\n        if length == 1:\n            return 1\n        total = 0\n        for next_start in range(start * 2, m + 1):\n            total += count_sequences(next_start, length - 1)\n        return total\n    if n == 0 or m < 1:\n        return 0\n    total_sequences = 0\n    for initial in range(1, m + 1):\n        total_sequences += count_sequences(initial, n)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(m, n, prev):\n        if n == 0:\n            return 1\n        total = 0\n        for i in range(prev * 2, m + 1):\n            total += count_sequences(m, n - 1, i)\n        return total\n    if n == 0:\n        return 0\n    total = 0\n    for i in range(1, m + 1):\n        total += count_sequences(m, n - 1, i)\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/244", "requirement": "def next_Perfect_Square(N: int) -> int:\n    \"\"\"\n    Write a python function to find the smallest perfect square that is not less than a given number.\n    \n    assert next_Perfect_Square(35) == 36\n    \n    ### Test 1\n    Input: [0]\n    Expected Output: [0]\n    \n    ### Test 2\n    Input: [0]\n    Expected Output: [0]\n    \"\"\"", "generated_programs": ["import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    return root * root", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    return root * root", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    return root * root", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    return root * root", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.ceil(math.sqrt(N))\n    return sqrt_N * sqrt_N", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    next_square_root = math.ceil(math.sqrt(N))\n    return next_square_root ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.isqrt(N)\n    if root * root >= N:\n        return root * root\n    else:\n        return (root + 1) * (root + 1)", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.ceil(math.sqrt(N))\n    return root * root", "from math import ceil, sqrt\n\ndef next_Perfect_Square(N: int) -> int:\n    return int(ceil(sqrt(N)) ** 2)", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.sqrt(N)\n    next_root = math.ceil(root)\n    return next_root ** 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/245", "requirement": "from typing import List\n\n\ndef max_sum(arr: List[int]) -> int:\n\"\"\"\nWrite a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.\nassert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    return max_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    lis = [0] * n\n    for i in range(n):\n        lis[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + arr[i]:\n                lis[i] = lis[j] + arr[i]\n    lds = [0] * n\n    for i in range(n - 1, -1, -1):\n        lds[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j] and lds[i] < lds[j] + arr[i]:\n                lds[i] = lds[j] + arr[i]\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis[i] + lds[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    inc = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    dec = [0] * n\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    max_increasing = [0] * n\n    for i in range(n):\n        max_increasing[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                max_increasing[i] = max(max_increasing[i], max_increasing[j] + arr[i])\n    max_decreasing = [0] * n\n    for i in range(n - 1, -1, -1):\n        max_decreasing[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i]:\n                max_decreasing[i] = max(max_decreasing[i], max_decreasing[j] + arr[i])\n    max_sum_bitonic = 0\n    for i in range(n):\n        max_sum_bitonic = max(max_sum_bitonic, max_increasing[i] + max_decreasing[i] - arr[i])\n    return max_sum_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    lis_sum = [0] * n\n    for i in range(n):\n        lis_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and lis_sum[j] + arr[i] > lis_sum[i]:\n                lis_sum[i] = lis_sum[j] + arr[i]\n    lds_sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        lds_sum[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i] and lds_sum[j] + arr[i] > lds_sum[i]:\n                lds_sum[i] = lds_sum[j] + arr[i]\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis_sum[i] + lds_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    lis_sum = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                lis_sum[i] = max(lis_sum[i], lis_sum[j] + arr[i])\n    lds_sum = arr[:]\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                lds_sum[i] = max(lds_sum[i], lds_sum[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis_sum[i] + lds_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    inc_sum = [0] * n\n    for i in range(n):\n        inc_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc_sum[i] = max(inc_sum[i], inc_sum[j] + arr[i])\n    dec_sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        dec_sum[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec_sum[i] = max(dec_sum[i], dec_sum[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc_sum[i] + dec_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    inc_sum = [0] * n\n    for i in range(n):\n        inc_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and inc_sum[j] + arr[i] > inc_sum[i]:\n                inc_sum[i] = inc_sum[j] + arr[i]\n    dec_sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        dec_sum[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i] and dec_sum[j] + arr[i] > dec_sum[i]:\n                dec_sum[i] = dec_sum[j] + arr[i]\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc_sum[i] + dec_sum[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    lis = [0] * n\n    for i in range(n):\n        lis[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                lis[i] = max(lis[i], lis[j] + arr[i])\n    lds = [0] * n\n    for i in range(n - 1, -1, -1):\n        lds[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i]:\n                lds[i] = max(lds[i], lds[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis[i] + lds[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    lis = [0] * n\n    for i in range(n):\n        lis[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and lis[i] < lis[j] + arr[i]:\n                lis[i] = lis[j] + arr[i]\n    lds = [0] * n\n    for i in range(n - 1, -1, -1):\n        lds[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i] and lds[i] < lds[j] + arr[i]:\n                lds[i] = lds[j] + arr[i]\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, lis[i] + lds[i] - arr[i])\n    return max_bitonic_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n\"\"\"\nWrite a function to find the nth Newman–Shanks–Williams (NSW) prime number. \nThe NSW numbers are generated using the recursive formula:\nS_i = 2 * S_{i-1}^2 - 1\nwhere S_0 = 1. The function should implement this formula iteratively to avoid recursion depth issues.\nIt should then check each NSW number to determine if it is prime, counting until it finds the nth prime in this sequence.\n\nassert newman_prime(3) == 7\n\"\"\"", "generated_programs": ["import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    S = [1]\n    primes = []\n    i = 1\n    while len(primes) < n:\n        next_S = 2 * S[i - 1] ** 2 - 1\n        S.append(next_S)\n        if is_prime(next_S):\n            primes.append(next_S)\n        i += 1\n    return primes[-1]", "from math import isqrt\n\ndef newman_prime(n: int) -> int:\n\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, isqrt(x) + 1):\n            if x % i == 0:\n                return False\n        return True\n    NSW_numbers = [1]\n    primes = []\n    while len(primes) < n:\n        next_NSW = 2 * NSW_numbers[-1] ** 2 - 1\n        NSW_numbers.append(next_NSW)\n        if is_prime(next_NSW):\n            primes.append(next_NSW)\n    return primes[-1]", "from math import isqrt\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, isqrt(num) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    S = [1]\n    count = 0\n    i = 1\n    while count < n:\n        S.append(2 * S[i - 1] ** 2 - 1)\n        if is_prime(S[i]):\n            count += 1\n            if count == n:\n                return S[i]\n        i += 1", "from sympy import isprime\n\ndef newman_prime(n: int) -> int:\n    ns_numbers = [1]\n    count = 0\n    idx = 0\n    while count < n:\n        if idx > 0:\n            ns_numbers.append(2 * ns_numbers[idx - 1] ** 2 - 1)\n        if isprime(ns_numbers[-1]):\n            count += 1\n        idx += 1\n    return ns_numbers[-1]", "from math import isqrt\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, isqrt(num) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    S_prev = 1\n    count = 0\n    i = 1\n    while True:\n        S_i = 2 * S_prev ** 2 - 1\n        if is_prime(S_i):\n            count += 1\n            if count == n:\n                return S_i\n        S_prev = S_i\n        i += 1", "import math\n\ndef newman_prime(n: int) -> int:\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    S_0, S_1 = (1, 1)\n    primes = []\n    while len(primes) < n:\n        next_s = 2 * S_1 ** 2 - 1\n        if is_prime(next_s):\n            primes.append(next_s)\n        S_0, S_1 = (S_1, next_s)\n    return primes[-1]", "import math\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef newman_prime(n: int) -> int:\n    S_0 = 1\n    S_1 = 1\n    NSW_sequence = [S_0, S_1]\n    primes_found = []\n    i = 2\n    while len(primes_found) < n:\n        S_next = 2 * NSW_sequence[-1] ** 2 - 1\n        NSW_sequence.append(S_next)\n        if is_prime(S_next):\n            primes_found.append(S_next)\n        i += 1\n    return primes_found[-1]", "from math import isqrt\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, isqrt(num) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    NSW_numbers = [1, 1]\n    prime_count = 0\n    while prime_count < n:\n        next_nsw = 2 * NSW_numbers[-1] + NSW_numbers[-2]\n        NSW_numbers.append(next_nsw)\n        if is_prime(next_nsw):\n            prime_count += 1\n        if prime_count == n:\n            return next_nsw", "from sympy import isprime\n\ndef newman_prime(n: int) -> int:\n    NSW_numbers = [1, 1]\n    primes = []\n    i = 2\n    while len(primes) < n:\n        next_nsw = 2 * NSW_numbers[-1] ** 2 - 1\n        NSW_numbers.append(next_nsw)\n        if isprime(next_nsw):\n            primes.append(next_nsw)\n        i += 1\n    return primes[-1]", "from math import isqrt\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    for i in range(5, isqrt(num) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    S_prev = 1\n    count = 0\n    i = 1\n    while True:\n        S_curr = 2 * S_prev ** 2 - 1\n        if is_prime(S_curr):\n            count += 1\n            if count == n:\n                return S_curr\n        S_prev = S_curr\n        i += 1"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.19999999999999996, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/274", "requirement": "def even_binomial_Coeff_Sum(n: int) -> int:\n\"\"\"\nWrite a Python function that takes in a non-negative integer n and returns the sum of binomial coefficients at even indices from 0 to n inclusive.\nFor example, for n = 4, the binomial coefficients are [1, 4, 6, 4, 1], and the sum of coefficients at even indices (0, 2, 4) is 1 + 6 + 1 = 8.\nassert even_binomial_Coeff_Sum(4) == 8\n\"\"\"", "generated_programs": ["from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/290", "requirement": "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    \"\"\"\n    Write a function to find the list of maximum length in a list of lists.\n    The function returns a tuple containing the length of the longest sublist and the sublist itself.\n    \n    assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    if not list1:\n        return (0, [])\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_sublist = max(list1, key=len)\n    return (len(max_sublist), max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_sublist = max(list1, key=len)\n    return (len(max_sublist), max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    longest_sublist = max(list1, key=len)\n    return (len(longest_sublist), longest_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_sublist = max(list1, key=len)\n    return (len(max_sublist), max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    return max([(len(sublist), sublist) for sublist in list1], key=lambda x: x[0])", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len_sublist = max(list1, key=len)\n    return (len(max_len_sublist), max_len_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_sublist = max(list1, key=len)\n    return (len(max_sublist), max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n\"\"\"\nWrite a function to find the depth of a dictionary.\nassert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4\n\"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if isinstance(d, dict) and d:\n        return 1 + max((dict_depth(value) for value in d.values()))\n    return 0", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if isinstance(d, dict) and d:\n        return 1 + max((dict_depth(value) for value in d.values()))\n    return 1", "def dict_depth(d: dict) -> int:\n    if isinstance(d, dict) and d:\n        return 1 + max((dict_depth(v) for v in d.values()))\n    return 0", "def dict_depth(d: dict) -> int:\n\n    def depth_helper(d):\n        if isinstance(d, dict):\n            return 1 + max((depth_helper(value) for value in d.values()), default=0)\n        return 0\n    return depth_helper(d)", "def dict_depth(d: dict) -> int:\n    if isinstance(d, dict) and d:\n        return 1 + max((dict_depth(value) for value in d.values()))\n    return 0", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) if isinstance(v, dict) else 0 for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if isinstance(d, dict):\n        return 1 + max((dict_depth(v) for v in d.values()), default=0)\n    return 0", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if isinstance(d, dict) and d:\n        return 1 + max((dict_depth(value) for value in d.values()))\n    return 1", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "from typing import Dict\n\ndef dict_depth(d: Dict) -> int:\n    if isinstance(d, dict):\n        return 1 + max((dict_depth(value) for value in d.values()), default=0)\n    return 0"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.30000000000000004, "original_passk": 0.4}}
{"task_id": "Mbpp/305", "requirement": "from typing import List\nfrom typing import Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return two words from a list of words starting with the letter 'p'.\n    If there are fewer than two such words, return the found words along with empty strings for the missing ones.\n    \n    The function should handle each string in the list by splitting it into individual words and checking\n    if they start with 'p' (case-insensitive). It should return a tuple containing the first two words\n    starting with 'p', or the found word and an empty string if only one word is found, or two empty strings\n    if no words are found.\n    \n    assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return (result[0], '') if len(result) == 1 else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n            if len(result) == 2:\n                return tuple(result)\n    while len(result) < 2:\n        result.append('')\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result + [''] * (2 - len(result)))", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    if len(result) == 1:\n        return (result[0], '')\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    if len(result) == 1:\n        return (result[0], '')\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return (result[0], result[1])\n    if len(result) == 1:\n        return (result[0], '')\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    break\n        if len(result) == 2:\n            break\n    if len(result) == 0:\n        return ('', '')\n    elif len(result) == 1:\n        return (result[0], '')\n    else:\n        return (result[0], result[1])", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    while len(result) < 2:\n        result.append('')\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    found_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                found_words.append(word)\n            if len(found_words) == 2:\n                break\n        if len(found_words) == 2:\n            break\n    while len(found_words) < 2:\n        found_words.append('')\n    return tuple(found_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    if len(p_words) == 1:\n        return (p_words[0], '')\n    elif len(p_words) == 0:\n        return ('', '')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\"\"\"\nWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\nassert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def find_max_sum(seq: List[int]) -> int:\n        dp = [0] * len(seq)\n        for i in range(len(seq)):\n            dp[i] = seq[i]\n            for j in range(i):\n                if seq[j] < seq[i]:\n                    dp[i] = max(dp[i], dp[j] + seq[i])\n        return max(dp)\n    if k <= index or k >= n:\n        return 0\n    prefix_seq = a[:index + 1]\n    prefix_seq.append(a[k])\n    return find_max_sum(prefix_seq)", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def find_subsequence(i, end, pre_val):\n        if i >= end:\n            return 0\n        if a[i] > pre_val:\n            include = a[i] + find_subsequence(i + 1, end, a[i])\n            exclude = find_subsequence(i + 1, end, pre_val)\n            return max(include, exclude)\n        else:\n            return find_subsequence(i + 1, end, pre_val)\n    prefix_sum = find_subsequence(0, index + 1, float('-inf'))\n    result = prefix_sum + find_subsequence(index + 1, k + 1, float('-inf'))\n    return result", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k <= index or index >= n or k >= n:\n        return 0\n    dp = [0] * n\n    dp[0] = a[0]\n    for i in range(1, index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    result = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            result = max(result, dp[i] + a[k])\n    return result", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def calculate_subsequence(prefix_end, include_element):\n        dp = [0] * n\n        max_sum = 0\n        for i in range(0, prefix_end + 1):\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n            max_sum = max(max_sum, dp[i])\n        if a[include_element] > max(a[:prefix_end + 1]):\n            max_sum += a[include_element]\n        return max_sum\n    return calculate_subsequence(index, k)", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def helper(curr_index, curr_sum, prev_val):\n        if curr_index > index:\n            if curr_index == k and prev_val < a[curr_index]:\n                return curr_sum + a[curr_index]\n            return curr_sum if curr_index == k else 0\n        include = 0\n        if a[curr_index] > prev_val:\n            include = helper(curr_index + 1, curr_sum + a[curr_index], a[curr_index])\n        exclude = helper(curr_index + 1, curr_sum, prev_val)\n        return max(include, exclude)\n    return helper(0, 0, float('-inf'))", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k <= index or index >= n or k >= n:\n        return 0\n    dp = [0] * n\n    result = 0\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    if a[index] >= a[k]:\n        return 0\n    dp_k = a[k]\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            dp_k = max(dp_k, dp[i] + a[k])\n    return dp_k", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * (n + 1)\n    dp[0] = a[0]\n    for i in range(1, index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    if a[index] < a[k]:\n        return dp[index] + a[k]\n    return dp[index]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def compute_prefix_sum(dp, idx):\n        for i in range(idx + 1):\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n        return max(dp[:idx + 1])\n    if k <= index or a[k] <= a[index]:\n        return 0\n    prefix_dp = [0] * n\n    prefix_sum = compute_prefix_sum(prefix_dp, index)\n    suffix_dp = [0] * n\n    for i in range(k + 1):\n        if a[i] <= a[k]:\n            suffix_dp[i] = prefix_dp[i]\n    suffix_dp[k] = prefix_sum + a[k]\n    return suffix_dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def find_max_sum(seq: List[int]) -> int:\n        dp = [0] * len(seq)\n        dp[0] = seq[0]\n        for i in range(1, len(seq)):\n            dp[i] = seq[i]\n            for j in range(i):\n                if seq[j] < seq[i]:\n                    dp[i] = max(dp[i], dp[j] + seq[i])\n        return max(dp)\n    prefix = a[:index + 1]\n    prefix_with_k = prefix + [a[k]]\n    return find_max_sum(prefix_with_k)", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\n    def helper(idx, prev):\n        if idx == k:\n            return a[idx] if a[idx] > prev else float('-inf')\n        if idx > index:\n            return float('-inf')\n        include = float('-inf')\n        if a[idx] > prev:\n            include = a[idx] + helper(idx + 1, a[idx])\n        exclude = helper(idx + 1, prev)\n        return max(include, exclude)\n    return helper(0, float('-inf'))"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.0, "original_passk": 0.125}}
{"task_id": "Mbpp/308", "requirement": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    If there are fewer than N unique products, return as many as possible. If N is 0, return an empty list.\n    \n    Parameters:\n    - nums1: List[int] - The first list of integers.\n    - nums2: List[int] - The second list of integers.\n    - N: int - The number of largest products to return.\n    \n    Returns:\n    - List[int] - A list containing the largest products, sorted in descending order.\n    \n    Examples:\n    assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    assert large_product([1, 2, 3], [4, 5, 6], 0) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = sorted({x * y for x in nums1 for y in nums2}, reverse=True)\n    return products[:N]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    from itertools import product\n    if N == 0:\n        return []\n    unique_products = set((a * b for a, b in product(nums1, nums2)))\n    sorted_products = sorted(unique_products, reverse=True)\n    return sorted_products[:N]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    unique_products = {a * b for a in nums1 for b in nums2}\n    sorted_products = sorted(unique_products, reverse=True)\n    return sorted_products[:N]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    product_set = {a * b for a in nums1 for b in nums2}\n    sorted_products = sorted(product_set, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    largest_products = heapq.nlargest(N, products)\n    return sorted(largest_products, reverse=True)", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = {x * y for x in nums1 for y in nums2}\n    largest_products = sorted(products, reverse=True)[:N]\n    return largest_products", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    from itertools import product\n    if N == 0:\n        return []\n    unique_products = set((x * y for x, y in product(nums1, nums2)))\n    sorted_products = sorted(unique_products, reverse=True)\n    return sorted_products[:N]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    unique_products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            unique_products.add(num1 * num2)\n    sorted_products = sorted(unique_products, reverse=True)\n    return sorted_products[:N]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = set((a * b for a in nums1 for b in nums2))\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = {x * y for x in nums1 for y in nums2}\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n\"\"\"\nWrite a function to convert a given string to a tuple of characters, excluding spaces.\nSpaces in the input string should be ignored during the conversion.\nassert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n\"\"\"", "generated_programs": ["from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((ch for ch in str1 if ch != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))", "from typing import Tuple\n\ndef string_to_tuple(str1: str) -> Tuple[str, ...]:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n\"\"\"\nWrite a python function to set the left most unset bit.\nassert set_left_most_unset_bit(10) == 14\n\"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    pos = 0\n    while 1 << pos & n:\n        pos += 1\n    return n | 1 << pos", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length() + 1\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length()\n    for i in range(bit_length, -1, -1):\n        if n & 1 << i == 0:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    position = 0\n    while 1 << position & n:\n        position += 1\n    return n | 1 << position", "def set_left_most_unset_bit(n: int) -> int:\n    bit_position = 1\n    while n | bit_position == n:\n        bit_position <<= 1\n    return n | bit_position", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length() + 1\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    binary_str = bin(n)[2:]\n    for i, char in enumerate(binary_str):\n        if char == '0':\n            return n | 1 << len(binary_str) - 1 - i\n    return n | 1 << len(binary_str)", "def set_left_most_unset_bit(n: int) -> int:\n    bit_length = n.bit_length() + 1\n    for i in range(bit_length, 0, -1):\n        if not n & 1 << i - 1:\n            return n | 1 << i - 1\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    mask = 1 << n.bit_length()\n    while n & mask:\n        mask >>= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    for i in range(n.bit_length() + 1):\n        if not n & 1 << i:\n            n |= 1 << i\n            break\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/427", "requirement": "def change_date_format(dt: str) -> str:\n\"\"\"\nWrite a function to convert a date from \"yyyy-mm-dd\" format to \"dd-mm-yyyy\" format. \nThe function should validate the input date and raise a ValueError if the date is invalid.\nassert change_date_format(\"2026-01-02\") == '02-01-2026'\n\"\"\"", "generated_programs": ["from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.strptime(dt, '%Y-%m-%d')\n        return valid_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        parsed_date = datetime.strptime(dt, '%Y-%m-%d')\n        return parsed_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format or value')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        parsed_date = datetime.strptime(dt, '%Y-%m-%d')\n        return parsed_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.strptime(dt, '%Y-%m-%d')\n        return valid_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.datetime.strptime(dt, '%Y-%m-%d')\n        return valid_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        parsed_date = datetime.strptime(dt, '%Y-%m-%d')\n        return parsed_date.strftime('%d-%m-%Y')\n    except ValueError as e:\n        raise ValueError('Invalid date format') from e", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        valid_date = datetime.strptime(dt, '%Y-%m-%d')\n        return valid_date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"Calculate the directrix of a parabola given its coefficients a, b, and c.\n    \n    The directrix is calculated using the formula: c - (b^2 + 1) * 4 * a.\n    \n    assert parabola_directrix(5,3,2)==-198\n    \"\"\"", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n\"\"\"\nWrite a function to calculate the sum of perrin numbers.\nassert cal_sum(9) == 49\n\"\"\"", "generated_programs": ["from typing import List\n\ndef perrin_numbers(n: int) -> List[int]:\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return perrin[:n]\n\ndef cal_sum(n: int) -> int:\n    return sum(perrin_numbers(n))", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        if n == 0:\n            return [3]\n        elif n == 1:\n            return [3, 0]\n        elif n == 2:\n            return [3, 0, 2]\n        sequence = [3, 0, 2]\n        for i in range(3, n + 1):\n            sequence.append(sequence[i - 2] + sequence[i - 3])\n        return sequence\n    return sum(perrin_sequence(n))", "from typing import List\n\ndef perrin_sequence(n: int) -> List[int]:\n    if n == 0:\n        return [3]\n    elif n == 1:\n        return [3, 0]\n    elif n == 2:\n        return [3, 0, 2]\n    sequence = [3, 0, 2]\n    for i in range(3, n + 1):\n        sequence.append(sequence[i - 2] + sequence[i - 3])\n    return sequence\n\ndef cal_sum(n: int) -> int:\n    sequence = perrin_sequence(n)\n    return sum(sequence)", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        if n == 0:\n            return [3]\n        if n == 1:\n            return [3, 0]\n        if n == 2:\n            return [3, 0, 2]\n        seq = [3, 0, 2]\n        for i in range(3, n + 1):\n            seq.append(seq[i - 2] + seq[i - 3])\n        return seq\n    perrin_nums = perrin_sequence(n)\n    return sum(perrin_nums)", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(k: int) -> List[int]:\n        seq = [3, 0, 2]\n        for i in range(3, k):\n            seq.append(seq[i - 2] + seq[i - 3])\n        return seq[:k]\n    return sum(perrin_sequence(n))", "import functools\n\ndef perrin(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    return perrin(n - 2) + perrin(n - 3)\n\ndef cal_sum(n: int) -> int:\n    return sum((perrin(i) for i in range(n + 1)))", "from typing import List\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> List[int]:\n        if n == 0:\n            return []\n        sequence = [3, 0, 2]\n        for i in range(3, n):\n            sequence.append(sequence[i - 2] + sequence[i - 3])\n        return sequence\n    return sum(perrin_sequence(n))", "from typing import Tuple\n\ndef cal_sum(n: int) -> int:\n\n    def perrin_sequence(n: int) -> Tuple[int]:\n        if n == 0:\n            return (3,)\n        elif n == 1:\n            return (3, 0)\n        elif n == 2:\n            return (3, 0, 2)\n        seq = [3, 0, 2]\n        for i in range(3, n + 1):\n            seq.append(seq[i - 2] + seq[i - 3])\n        return tuple(seq)\n    return sum(perrin_sequence(n))", "def cal_sum(n: int) -> int:\n\n    def perrin_numbers(m: int) -> list:\n        if m == 0:\n            return [3]\n        elif m == 1:\n            return [3, 0]\n        elif m == 2:\n            return [3, 0, 2]\n        seq = [3, 0, 2]\n        for i in range(3, m):\n            seq.append(seq[i - 2] + seq[i - 3])\n        return seq\n    return sum(perrin_numbers(n))", "from typing import List\n\ndef perrin_sequence(n: int) -> List[int]:\n    perrin = [3, 0, 2]\n    for i in range(3, n):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return perrin[:n]\n\ndef cal_sum(n: int) -> int:\n    return sum(perrin_sequence(n))"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.4, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"Calculate the sum of all even factors of a given number.\n    \n    The function should return 0 if the number is odd, as it has no even factors.\n    The sum includes only the even factors of the number.\n    \n    assert sumofFactors(18) == 26\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "from typing import List\n\ndef sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    even_factors_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            even_factors_sum += i\n    return even_factors_sum", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((i for i in range(1, n + 1) if n % i == 0 and i % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(1, n + 1) if n % factor == 0 and factor % 2 == 0))", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))", "from typing import List\n\ndef sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    return sum((factor for factor in range(2, n + 1, 2) if n % factor == 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n\"\"\"\nWrite a function that checks if the letter 'z' is present anywhere in the input string.\nassert text_match_wordz(\"pythonz.\") == True\n\"\"\"", "generated_programs": ["def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "from typing import str\n\ndef text_match_wordz(text: str) -> bool:\n    return 'z' in text", "from typing import List\n\ndef text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "from typing import List\n\ndef text_match_wordz(text: str) -> bool:\n    return 'z' in text", "from typing import Optional\n\ndef text_match_wordz(text: str) -> bool:\n    return 'z' in text", "from typing import List\n\ndef text_match_wordz(text: str) -> bool:\n    return 'z' in text", "from typing import str\n\ndef text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, i)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(combo) for combo in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(combo) for combo in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(combo) for combo in combinations(lst, r)])\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(combo) for combo in combinations(lst, r)])\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(combo) for combo in combinations(lst, r)])\n    return all_combinations"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product formed by multiplying numbers of a contiguous increasing subsequence of that array.\n    A contiguous increasing subsequence is defined as a sequence where each element is greater than the previous one and they are consecutive in the original array.\n    Single-element subsequences are considered valid and their product is the element itself.\n    \n    assert max_product([3, 100, 4, 5, 150, 6]) == 3000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            max_prod = max(max_prod, current_prod)\n            current_prod = arr[i]\n    max_prod = max(max_prod, current_prod)\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    current_prod = 1\n    for i in range(len(arr)):\n        current_prod *= arr[i]\n        max_prod = max(max_prod, current_prod)\n        if i == len(arr) - 1 or arr[i] >= arr[i + 1]:\n            current_prod = 1\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_product = float('-inf')\n    current_product = 1\n    for i in range(len(arr)):\n        current_product *= arr[i]\n        max_product = max(max_product, current_product)\n        if i + 1 < len(arr) and arr[i + 1] <= arr[i]:\n            current_product = 1\n    return max_product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_product = float('-inf')\n    current_product = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_product *= arr[i]\n        else:\n            max_product = max(max_product, current_product)\n            current_product = arr[i]\n    max_product = max(max_product, current_product)\n    return max_product", "from typing import List\nfrom functools import reduce\nimport operator\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    start = 0\n    while start < len(arr):\n        end = start\n        while end + 1 < len(arr) and arr[end + 1] > arr[end]:\n            end += 1\n        current_subsequence = arr[start:end + 1]\n        current_product = reduce(operator.mul, current_subsequence, 1)\n        max_prod = max(max_prod, current_product)\n        start = end + 1\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    n = len(arr)\n    current_prod = arr[0]\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            max_prod = max(max_prod, current_prod)\n            current_prod = arr[i]\n    max_prod = max(max_prod, current_prod)\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_product = float('-inf')\n    current_product = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_product *= arr[i]\n        else:\n            max_product = max(max_product, current_product)\n            current_product = arr[i]\n    max_product = max(max_product, current_product)\n    return max_product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = float('-inf')\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            max_prod = max(max_prod, current_prod)\n            current_prod = arr[i]\n    max_prod = max(max_prod, current_prod)\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_product = float('-inf')\n    current_product = 1\n    for i in range(len(arr)):\n        current_product = arr[i]\n        max_product = max(max_product, current_product)\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[j - 1]:\n                current_product *= arr[j]\n                max_product = max(max_product, current_product)\n            else:\n                break\n    return max_product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    max_product = float('-inf')\n    current_product = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_product *= arr[i]\n        else:\n            max_product = max(max_product, current_product)\n            current_product = arr[i]\n    max_product = max(max_product, current_product)\n    return max_product"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/555", "requirement": "def difference(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers. The function assumes that n is a positive integer. For non-positive integers, the function returns 0.\n\n    assert difference(3) == 30\n    \"\"\"", "generated_programs": ["def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_natural_numbers = sum(range(1, n + 1))\n    sum_of_cubes = sum((x ** 3 for x in range(1, n + 1)))\n    return sum_of_cubes - sum_of_natural_numbers", "from typing import Union\n\ndef difference(n: int) -> Union[int, None]:\n    if n <= 0:\n        return 0\n    sum_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_natural = sum(range(1, n + 1))\n    return sum_cubes - sum_natural", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "from typing import List\n\ndef difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum((i for i in range(1, n + 1)))\n    return sum_of_cubes - sum_of_numbers", "from typing import Optional\n\ndef difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum((i for i in range(1, n + 1)))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_numbers = sum((i for i in range(1, n + 1)))\n    return sum_cubes - sum_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_natural_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_natural_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_natural = sum((i for i in range(1, n + 1)))\n    return sum_cubes - sum_natural", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_of_numbers = sum(range(1, n + 1))\n    return sum_of_cubes - sum_of_numbers"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function which takes a list of integers and counts the number of possible unordered pairs \n    (i, j) where i < j and the elements at these positions are not equal.\n    \n    assert count_Pairs([1, 2, 1], 3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    pairs_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                pairs_count += 1\n    return pairs_count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/573", "requirement": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Write a Python function to calculate the product of the unique numbers in a given list.\n    The product of an empty list is defined as 1.\n    The presence of zero in the list results in a product of zero.\n    Negative numbers are included in the calculation and handled according to standard multiplication rules.\n    \n    assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    \"\"\"", "generated_programs": ["from typing import List\nfrom math import prod\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if 0 in unique_numbers:\n        return 0\n    return prod(unique_numbers)", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for number in unique_numbers:\n        product *= number\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    if not list_data:\n        return 1\n    unique_numbers = set(list_data)\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\nfrom functools import reduce\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if 0 in unique_numbers:\n        return 0\n    if not unique_numbers:\n        return 1\n    return reduce(lambda x, y: x * y, unique_numbers, 1)", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if not unique_numbers:\n        return 1\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if not unique_numbers:\n        return 1\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n\"\"\"\nWrite a function to remove uneven elements in the nested mixed tuple.\nassert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n\"\"\"", "generated_programs": ["from typing import Tuple, Union\n\ndef extract_even(test_tuple: Tuple[Union[int, tuple]]) -> Tuple[Union[int, tuple]]:\n\n    def filter_even(item):\n        if isinstance(item, tuple):\n            return tuple((filter_even(sub_item) for sub_item in item if isinstance(sub_item, (int, tuple)) and (isinstance(sub_item, int) and sub_item % 2 == 0 or isinstance(sub_item, tuple))))\n        elif isinstance(item, int) and item % 2 == 0:\n            return item\n        return None\n    return tuple(filter(filter_even, test_tuple))", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def filter_even(item):\n        if isinstance(item, tuple):\n            return tuple((filter_even(elem) for elem in item if isinstance(elem, int) and elem % 2 == 0 or isinstance(elem, tuple)))\n        return None\n    return tuple((filter_even(element) for element in test_tuple if isinstance(element, int) and element % 2 == 0 or isinstance(element, tuple)))", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def filter_even(item):\n        if isinstance(item, int):\n            return item % 2 == 0\n        if isinstance(item, tuple):\n            return tuple(filter(filter_even, item))\n        return False\n    return tuple(filter(filter_even, test_tuple))", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def filter_even(item):\n        if isinstance(item, tuple):\n            return tuple((filter_even(sub_item) for sub_item in item if isinstance(sub_item, int) and sub_item % 2 == 0 or isinstance(sub_item, tuple)))\n        return item if isinstance(item, int) and item % 2 == 0 else None\n    return tuple((filter_even(i) for i in test_tuple if isinstance(i, int) and i % 2 == 0 or isinstance(i, tuple)))", "from typing import Tuple\n\ndef extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even(data):\n        if isinstance(data, tuple):\n            return tuple((filter_even(item) for item in data if isinstance(item, int) and item % 2 == 0 or isinstance(item, tuple)))\n        elif isinstance(data, int) and data % 2 == 0:\n            return data\n        return None\n    return filter_even(test_tuple)", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def filter_even(obj):\n        if isinstance(obj, tuple):\n            return tuple((filter_even(item) for item in obj if isinstance(item, tuple) or (isinstance(item, int) and item % 2 == 0)))\n        return obj\n    return filter_even(test_tuple)", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def filter_even(data):\n        if isinstance(data, tuple):\n            return tuple((filter_even(item) for item in data if isinstance(item, (int, tuple)) and (not isinstance(item, int) or item % 2 == 0)))\n        return data\n    return filter_even(test_tuple)", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def filter_even(value):\n        if isinstance(value, tuple):\n            return tuple((filter_even(v) for v in value if isinstance(v, (int, tuple)) and (not isinstance(v, int) or v % 2 == 0)))\n        return value\n    return tuple((filter_even(v) for v in test_tuple if isinstance(v, (int, tuple)) and (not isinstance(v, int) or v % 2 == 0)))", "from typing import Tuple\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def filter_even(item):\n        if isinstance(item, tuple):\n            return tuple((filter_even(i) for i in item if filter_even(i) is not None))\n        elif isinstance(item, int):\n            return item if item % 2 == 0 else None\n        else:\n            return None\n    return tuple((filter_even(i) for i in test_tuple if filter_even(i) is not None))", "from typing import Tuple, Any\n\ndef extract_even(test_tuple: Tuple[Any, ...]) -> Tuple[Any, ...]:\n\n    def filter_even(element):\n        if isinstance(element, tuple):\n            return tuple((filter_even(item) for item in element if isinstance(item, int) and item % 2 == 0 or isinstance(item, tuple)))\n        return element if isinstance(element, int) and element % 2 == 0 else None\n    return tuple(filter(None, (filter_even(item) for item in test_tuple)))"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.6, "original_passk": 0.7}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n\"\"\"\nWrite a Python function to find the surface area of a square pyramid with a given base edge and slant height.\nThe surface area is calculated using the formula: Surface Area = b^2 + 2bs, where b is the base edge and s is the slant height.\nassert surface_Area(3,4) == 33\n\"\"\"", "generated_programs": ["def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import Float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "from typing import float\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n\"\"\"\nWrite a function to convert polar coordinates to rectangular coordinates.\nassert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n\"\"\"", "generated_programs": ["from math import sqrt, atan2, cos, sin\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = sqrt(x ** 2 + y ** 2)\n    theta = atan2(y, x)\n    real_part = r * cos(theta)\n    imag_part = r * sin(theta)\n    return ((r, theta), complex(real_part, imag_part))", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    polar_coordinates = (r, theta)\n    rectangular_coordinates = cmath.rect(r, theta)\n    return (polar_coordinates, rectangular_coordinates)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    polar_coords = (r, theta)\n    rect_coords = cmath.rect(r, theta)\n    return (polar_coords, rect_coords)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coordinates = (magnitude, angle)\n    rect_complex = cmath.rect(magnitude, angle)\n    return (polar_coordinates, rect_complex)", "import cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = (x ** 2 + y ** 2) ** 0.5\n    theta = cmath.phase(complex(x, y))\n    polar_coords = (r, theta)\n    rect_coords = cmath.rect(r, theta)\n    return (polar_coords, rect_coords)", "from typing import Tuple\nfrom math import sqrt, atan2, cos, sin\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = sqrt(x ** 2 + y ** 2)\n    theta = atan2(y, x)\n    real = r * cos(theta)\n    imaginary = r * sin(theta)\n    return ((r, theta), complex(real, imaginary))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.sqrt(x ** 2 + y ** 2)\n    theta = math.atan2(y, x)\n    polar_coordinates = (r, theta)\n    rectangular_coordinates = cmath.rect(r, theta)\n    return (polar_coordinates, rectangular_coordinates)", "from typing import Tuple\nfrom math import sqrt, atan2, cos, sin\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = sqrt(x ** 2 + y ** 2)\n    theta = atan2(y, x)\n    polar_coordinates = (r, theta)\n    rectangular_coordinates = complex(r * cos(theta), r * sin(theta))\n    return (polar_coordinates, rectangular_coordinates)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coordinates = (magnitude, angle)\n    rectangular_coordinates = cmath.rect(magnitude, angle)\n    return (polar_coordinates, rectangular_coordinates)", "import cmath\nimport math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    real = magnitude * math.cos(angle)\n    imaginary = magnitude * math.sin(angle)\n    rectangular = complex(real, imaginary)\n    return ((magnitude, angle), rectangular)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the difference between the first even and the first odd number in a given list.\n    If the list does not contain both an even and an odd number, return 0.\n    \n    assert diff_even_odd([1,3,5,7,4,1,6,8]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return abs(first_even - first_odd)\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    return abs(even - odd) if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is None or odd is None:\n        return 0\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        return 0\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        return 0\n    return abs(first_even - first_odd)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the kth smallest element from the given two sorted arrays.\n    If the kth element does not exist (e.g., when k is larger than the total number of elements in both arrays),\n    the function should return None.\n    \n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_helper(a, b, k):\n        if not a:\n            return b[k - 1] if k <= len(b) else None\n        if not b:\n            return a[k - 1] if k <= len(a) else None\n        if k == 1:\n            return min(a[0], b[0])\n        mid_a = len(a) // 2\n        mid_b = len(b) // 2\n        mid_a_val = a[mid_a]\n        mid_b_val = b[mid_b]\n        if mid_a + mid_b < k:\n            if mid_a_val < mid_b_val:\n                return kth_helper(a[mid_a + 1:], b, k - mid_a - 1)\n            else:\n                return kth_helper(a, b[mid_b + 1:], k - mid_b - 1)\n        elif mid_a_val < mid_b_val:\n            return kth_helper(a, b[:mid_b], k)\n        else:\n            return kth_helper(a[:mid_a], b, k)\n    return kth_helper(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_helper(arr1, arr2, k):\n        if not arr1:\n            return arr2[k - 1] if k <= len(arr2) else None\n        if not arr2:\n            return arr1[k - 1] if k <= len(arr1) else None\n        if k == 1:\n            return min(arr1[0], arr2[0])\n        mid1 = min(len(arr1), k // 2)\n        mid2 = min(len(arr2), k // 2)\n        if arr1[mid1 - 1] < arr2[mid2 - 1]:\n            return kth_helper(arr1[mid1:], arr2, k - mid1)\n        else:\n            return kth_helper(arr1, arr2[mid2:], k - mid2)\n    total_length = len(arr1) + len(arr2)\n    return kth_helper(arr1, arr2, k) if k <= total_length else None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2):\n        return None\n\n    def kth_helper(a, b, k):\n        if not a:\n            return b[k - 1]\n        if not b:\n            return a[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        mid_a = len(a) // 2\n        mid_b = len(b) // 2\n        val_a = a[mid_a]\n        val_b = b[mid_b]\n        if mid_a + mid_b < k - 1:\n            if val_a < val_b:\n                return kth_helper(a[mid_a + 1:], b, k - mid_a - 1)\n            else:\n                return kth_helper(a, b[mid_b + 1:], k - mid_b - 1)\n        elif val_a < val_b:\n            return kth_helper(a, b[:mid_b], k)\n        else:\n            return kth_helper(a[:mid_a], b, k)\n    return kth_helper(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_element(arr1, arr2, k):\n        m, n = (len(arr1), len(arr2))\n        if m > n:\n            return kth_element(arr2, arr1, k)\n        if m == 0:\n            return arr2[k - 1] if k <= n else None\n        if k == 1:\n            return min(arr1[0], arr2[0])\n        i = min(m, k // 2)\n        j = k - i\n        if i > 0 and j > 0 and (arr1[i - 1] < arr2[j - 1]):\n            return kth_element(arr1[i:], arr2, k - i)\n        else:\n            return kth_element(arr1, arr2[j:], k - j)\n    result = kth_element(arr1, arr2, k)\n    return result if k <= len(arr1) + len(arr2) else None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_from_merged(a: List[int], b: List[int], k: int) -> int:\n        if not a:\n            return b[k - 1] if k <= len(b) else None\n        if not b:\n            return a[k - 1] if k <= len(a) else None\n        if k > len(a) + len(b):\n            return None\n        i, j = (0, 0)\n        while True:\n            if i == len(a):\n                return b[k - j - 1] if k - j - 1 < len(b) else None\n            if j == len(b):\n                return a[k - i - 1] if k - i - 1 < len(a) else None\n            if k == 1:\n                return min(a[i], b[j])\n            half_k = (k - 1) // 2\n            a_idx = min(len(a) - 1, i + half_k)\n            b_idx = min(len(b) - 1, j + half_k)\n            if a[a_idx] <= b[b_idx]:\n                k -= a_idx - i + 1\n                i = a_idx + 1\n            else:\n                k -= b_idx - j + 1\n                j = b_idx + 1\n    return kth_from_merged(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    m, n = (len(arr1), len(arr2))\n    if k > m + n:\n        return None\n\n    def kth_smallest(a, b, k):\n        if not a:\n            return b[k - 1]\n        if not b:\n            return a[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        i = min(len(a), k // 2) - 1\n        j = min(len(b), k // 2) - 1\n        if a[i] <= b[j]:\n            return kth_smallest(a[i + 1:], b, k - (i + 1))\n        else:\n            return kth_smallest(a, b[j + 1:], k - (j + 1))\n    return kth_smallest(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def find_kth_util(a, b, k):\n        if not a:\n            return b[k - 1] if k <= len(b) else None\n        if not b:\n            return a[k - 1] if k <= len(a) else None\n        if k == 1:\n            return min(a[0], b[0])\n        mid_a = k // 2 - 1 if len(a) >= k // 2 else len(a) - 1\n        mid_b = k // 2 - 1 if len(b) >= k // 2 else len(b) - 1\n        pivot_a, pivot_b = (a[mid_a], b[mid_b])\n        if pivot_a > pivot_b:\n            return find_kth_util(a, b[mid_b + 1:], k - (mid_b + 1))\n        else:\n            return find_kth_util(a[mid_a + 1:], b, k - (mid_a + 1))\n    if k <= 0 or k > len(arr1) + len(arr2):\n        return None\n    return find_kth_util(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_helper(arr1, arr2, k):\n        if not arr1:\n            return arr2[k - 1] if k <= len(arr2) else None\n        if not arr2:\n            return arr1[k - 1] if k <= len(arr1) else None\n        if k == 1:\n            return min(arr1[0], arr2[0])\n        mid1 = len(arr1) // 2\n        mid2 = len(arr2) // 2\n        if mid1 + mid2 + 1 < k:\n            if arr1[mid1] < arr2[mid2]:\n                return kth_helper(arr1[mid1 + 1:], arr2, k - mid1 - 1)\n            else:\n                return kth_helper(arr1, arr2[mid2 + 1:], k - mid2 - 1)\n        elif arr1[mid1] < arr2[mid2]:\n            return kth_helper(arr1, arr2[:mid2], k)\n        else:\n            return kth_helper(arr1[:mid1], arr2, k)\n    if k < 1 or k > len(arr1) + len(arr2):\n        return None\n    return kth_helper(arr1, arr2, k)", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n\n    def kth_smallest_helper(a: List[int], b: List[int], k: int) -> int:\n        if len(a) > len(b):\n            return kth_smallest_helper(b, a, k)\n        if not a:\n            return b[k - 1] if k <= len(b) else None\n        if k == 1:\n            return min(a[0], b[0])\n        idx_a = min(len(a), k // 2)\n        idx_b = k - idx_a\n        if a[idx_a - 1] < b[idx_b - 1]:\n            return kth_smallest_helper(a[idx_a:], b, k - idx_a)\n        else:\n            return kth_smallest_helper(a, b[idx_b:], k - idx_b)\n    total_length = len(arr1) + len(arr2)\n    return kth_smallest_helper(arr1, arr2, k) if k <= total_length else None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2) or k < 1:\n        return None\n\n    def kth_element(a, b, k):\n        if not a:\n            return b[k - 1]\n        if not b:\n            return a[k - 1]\n        if k == 1:\n            return min(a[0], b[0])\n        mid_a = len(a) // 2\n        mid_b = len(b) // 2\n        if mid_a + mid_b < k - 1:\n            if a[mid_a] > b[mid_b]:\n                return kth_element(a, b[mid_b + 1:], k - mid_b - 1)\n            else:\n                return kth_element(a[mid_a + 1:], b, k - mid_a - 1)\n        elif a[mid_a] > b[mid_b]:\n            return kth_element(a[:mid_a], b, k)\n        else:\n            return kth_element(a, b[:mid_b], k)\n    return kth_element(arr1, arr2, k)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/607", "requirement": "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Write a function to search a string for a regex pattern. The function should return the matching substring, a start index, and an end index.\n    The end index is exclusive, meaning it points to the position immediately after the last character of the match.\n    \n    assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start, end = (match.start(), match.end())\n        return (text[start:end], start, end)\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        matched_text = match.group()\n        start_index = match.start()\n        end_index = match.end()\n        return (matched_text, start_index, end_index)\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start = match.start()\n        end = match.end()\n        return (text[start:end], start, end)\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start = match.start()\n        end = match.end()\n        return (match.group(), start, end)\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(re.escape(pattern), text)\n    if match:\n        start, end = (match.start(), match.end())\n        return (text[start:end], start, end)\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start = match.start()\n        end = match.end()\n        matched_text = match.group()\n        return (matched_text, start, end)\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start = match.start()\n        end = match.end()\n        return (match.group(), start, end)\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(0), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        start = match.start()\n        end = match.end()\n        return (match.group(), start, end)\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/610", "requirement": "from typing import List\n\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function which takes a list and an integer k, and returns a list with the same elements except for the first occurrence of the element with the value k removed.\n    \n    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 2, 4, 4, 5, 1]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        list1.remove(k)\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        list1.remove(k)\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        list1.remove(k)\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        list1.remove(k)\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        list1.remove(k)\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        list1.remove(k)\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    try:\n        list1.remove(k)\n    except ValueError:\n        pass\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        list1.remove(k)\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        list1.remove(k)\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        list1.remove(k)\n    return list1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/612", "requirement": "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a Python function which takes a list of lists and returns a list of lists where each sublist contains elements from the same position in the original sublists. \n    If the sublists are of uneven lengths, the resulting sublists will be truncated to the length of the shortest sublist.\n    \n    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    return [list(sublist) for sublist in zip(*lst)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    return [list(sublist) for sublist in zip(*lst)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    return [list(item) for item in zip(*lst)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    return [list(item) for item in zip(*lst)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    return [list(group) for group in zip(*lst)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    return [list(x) for x in zip(*lst)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    return [list(item) for item in zip(*lst)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    min_length = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    return [list(sublist) for sublist in zip(*lst)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    return [list(x) for x in zip(*lst)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/615", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    \"\"\"\n    Write a function which takes a tuple of tuples and returns the average value for each corresponding element across the inner tuples as a list.\n    \n    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum((inner_tuple[i] for inner_tuple in nums)) / len(nums) for i in range(len(nums[0]))]", "from typing import List\nfrom typing import Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(values) / len(values) for values in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(items) / len(items) for items in zip(*nums)]", "from typing import List\nfrom typing import Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(values) / len(values) for values in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "Mbpp/622", "requirement": "def get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    \"\"\"Find the median of two sorted lists of the same size by merging them and selecting the middle elements.\n    \n    The function should merge the two input lists, sort the merged list, and then calculate the median by averaging the nth and (n-1)th elements of the sorted list.\n    \n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    median = (merged_list[n - 1] + merged_list[n]) / 2\n    return median", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    median = (merged_list[n - 1] + merged_list[n]) / 2\n    return median", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged_list = sorted(nums1 + nums2)\n    return (merged_list[n - 1] + merged_list[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n    \"\"\"\n    Write a Python function to find the area of the largest equilateral triangle that can be inscribed in a semicircle with a given radius.\n    The function should return None if the radius is less than or equal to zero.\n    \n    assert triangle_area(-1) == None\n    \n    ### Test 1\n    Input: [5.0]\n    Expected Output: [10.825317547305483]\n    \n    ### Test 2\n    Input: [5.0]\n    Expected Output: [10.825317547305483]\n    \n    ### Test 3\n    Input: [0.0]\n    Expected Output: [None]\n    \"\"\"", "generated_programs": ["import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = math.sqrt(3) * radius\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\nfrom typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = math.sqrt(3) * radius\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\nfrom typing import Union\n\ndef triangle_area(radius: float) -> Union[float, None]:\n    if radius <= 0:\n        return None\n    side_length = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side = radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side ** 2\n    return area"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n\"\"\"\nWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\nassert wind_chill(120,35)==40\n\"\"\"", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return round(13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.9, "original_passk": 0.4}}
{"task_id": "Mbpp/643", "requirement": "def text_match_wordz_middle(text: str) -> bool:\n\"\"\"\nWrite a function that checks if a string contains 'z', except when 'z' is at the start or end of a word.\nA 'z' is considered to be in the middle of a word if it is not the first or last character of any word in the string.\nWords are defined as sequences of alphanumeric characters.\n\nExamples:\nassert text_match_wordz_middle(\"pythonzabc.\") == True\nassert text_match_wordz_middle(\"zpythonabc.\") == False\nassert text_match_wordz_middle(\"z\") == True\n\"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b[a-zA-Z0-9]+\\\\b', text)\n    for word in words:\n        if 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word and (not (word.startswith('z') or word.endswith('z'))):\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w+z\\\\w+\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if len(word) > 2 and 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b[a-zA-Z0-9]*\\\\b', text)\n    for word in words:\n        if len(word) > 2 and 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w*z\\\\w*\\\\b'\n    matches = re.findall(pattern, text)\n    for word in matches:\n        if word.startswith('z') or word.endswith('z'):\n            continue\n        return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word and (not (word.startswith('z') or word.endswith('z'))):\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word and len(word) > 2 and (not (word.startswith('z') or word.endswith('z'))):\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word[1:-1]:\n            return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.6, "original_passk": 1.0}}
{"task_id": "Mbpp/722", "requirement": "from typing import Dict\nfrom typing import Tuple\n\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight greater than or equal to the minimum values.\n    \n    assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)},6.0,70)=={'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: details for name, details in students.items() if details[0] >= h and details[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: stats for name, stats in students.items() if stats[0] >= h and stats[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: data for name, data in students.items() if data[0] >= h and data[1] >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/734", "requirement": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of products of all possible contiguous subarrays of a given list.\n    \n    A contiguous subarray is defined as a sequence of consecutive elements from the array.\n    \n    Parameters:\n    arr (List[int]): The input list of integers.\n    \n    Returns:\n    int: The sum of products of all contiguous subarrays.\n    \n    Example:\n    >>> sum_Of_Subarray_Prod([1,2,3])\n    20\n    \n    For the input [1, 2, 3], the contiguous subarrays are [1], [2], [3], [1, 2], [2, 3], and [1, 2, 3].\n    Their products are 1, 2, 3, 2, 6, and 6 respectively, summing up to 20.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= arr[j]\n            result += current_product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        subarray_prod = 1\n        for j in range(i, n):\n            subarray_prod *= arr[j]\n            total_sum += subarray_prod\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= arr[j]\n            result += current_product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        current_prod = 1\n        for j in range(i, n):\n            current_prod *= arr[j]\n            total_sum += current_prod\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= arr[j]\n            total_sum += current_product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        current_prod = 1\n        for j in range(i, n):\n            current_prod *= arr[j]\n            result += current_prod\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        subarray_product = 1\n        for j in range(i, n):\n            subarray_product *= arr[j]\n            result += subarray_product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= arr[j]\n            result += current_product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n    return result", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        temp_product = 1\n        for j in range(i, n):\n            temp_product *= arr[j]\n            result += temp_product\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/739", "requirement": "def find_Index(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the index of the first triangular number that has at least n digits.\n    \n    A triangular number is a number that can be arranged in the shape of an equilateral triangle. \n    The nth triangular number is the sum of the first n natural numbers, i.e., T(n) = n * (n + 1) / 2.\n    \n    Parameters:\n    n (int): The minimum number of digits the triangular number should have.\n    \n    Returns:\n    int: The index of the first triangular number that has at least n digits.\n    \n    Examples:\n    assert find_Index(2) == 4\n    assert find_Index(3) == 14\n    assert find_Index(0) == 1\n    \"\"\"", "generated_programs": ["def find_Index(n: int) -> int:\n    import math\n\n    def num_digits(number: int) -> int:\n        return math.floor(math.log10(number)) + 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if num_digits(triangular_number) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    triangular = lambda x: x * (x + 1) // 2\n    index = 1\n    while len(str(triangular(index))) < n:\n        index += 1\n    return index", "def find_Index(n: int) -> int:\n\n    def count_digits(num: int) -> int:\n        return len(str(num))\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if count_digits(triangular_number) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    from math import log10\n\n    def triangular_number(index):\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        if log10(triangular_number(index)) + 1 >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    import math\n\n    def triangular_number(index: int) -> int:\n        return index * (index + 1) // 2\n    index = 1\n    while True:\n        current_triangular_number = triangular_number(index)\n        if len(str(current_triangular_number)) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    if n <= 0:\n        return 1\n    index = 1\n    triangular_number = 0\n    while True:\n        triangular_number += index\n        if len(str(triangular_number)) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if len(str(triangular_number)) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    digits_threshold = 10 ** (n - 1)\n    index = 1\n    triangular_number = 0\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if triangular_number >= digits_threshold:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if len(str(triangular_number)) >= n:\n            return index\n        index += 1", "def find_Index(n: int) -> int:\n    from math import log10\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if triangular_number >= 10 ** (n - 1):\n            return index\n        index += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Write a function to find numbers within a given range from startnum to endnum (inclusive) \n    where every number is divisible by every non-zero digit it contains. \n    The function should only consider positive integers and raise a ValueError if any negative numbers are encountered.\n    The function should skip any number containing the digit zero.\n    \n    assert divisible_by_digits(1,22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed')\n\n    def is_divisible_by_digits(n: int) -> bool:\n        digits = [int(d) for d in str(n)]\n        if 0 in digits:\n            return False\n        return all((n % d == 0 for d in digits))\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed')\n    divisible_numbers = []\n    for number in range(startnum, endnum + 1):\n        digits = [int(digit) for digit in str(number) if digit != '0']\n        if '0' in str(number):\n            continue\n        if all((number % digit == 0 for digit in digits)):\n            divisible_numbers.append(number)\n    return divisible_numbers", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n\n    def is_divisible_by_digits(number: int) -> bool:\n        digits = [int(d) for d in str(number)]\n        if 0 in digits:\n            return False\n        return all((number % d == 0 for d in digits))\n    return [number for number in range(startnum, endnum + 1) if is_divisible_by_digits(number)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed')\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = list(str(num))\n        if '0' in digits:\n            continue\n        divisible = True\n        for digit in digits:\n            if num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if '0' in str(num):\n            continue\n        if all((num % digit == 0 for digit in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num)]\n        if 0 in digits:\n            continue\n        if all((num % d == 0 for d in digits if d != 0)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed')\n\n    def is_divisible_by_digits(num: int) -> bool:\n        digits = [int(d) for d in str(num)]\n        if 0 in digits:\n            return False\n        for digit in digits:\n            if num % digit != 0:\n                return False\n        return True\n    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n\n    def is_valid(num: int) -> bool:\n        digits = [int(d) for d in str(num)]\n        if 0 in digits:\n            return False\n        return all((num % d == 0 for d in digits))\n    return [num for num in range(startnum, endnum + 1) if is_valid(num)]", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed')\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(digit) for digit in str(num) if digit != '0']\n        if '0' in str(num):\n            continue\n        if all((num % digit == 0 for digit in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n\n    def is_divisible_by_digits(number: int) -> bool:\n        digits = [int(d) for d in str(number)]\n        if 0 in digits:\n            return False\n        return all((number % d == 0 for d in digits if d != 0))\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.4}}
{"task_id": "Mbpp/748", "requirement": "def capital_words_spaces(str1: str) -> str:\n\"\"\"\nWrite a function to put spaces between words starting with capital letters in a given string.\nassert capital_words_spaces(\"Python\") == 'Python'\n\"\"\"", "generated_programs": ["import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<=[a-z])(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)(?=[A-Z])', ' ', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<=\\\\w)(?=[A-Z])', ' ', str1)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/759", "requirement": "def is_decimal(num: str) -> bool:\n    \"\"\"\n    Write a function to check whether a given string is a decimal number with exactly two digits after the decimal point.\n    assert is_decimal('123.11') == True\n    \"\"\"", "generated_programs": ["import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "def is_decimal(num: str) -> bool:\n    import re\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.fullmatch('\\\\d+\\\\.\\\\d{2}', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    \"\"\"\n    Write a Python function to find the minimum difference between any two elements in a given array.\n    The function accepts the array as a tuple of integers and its length as an integer.\n    The parameter `n` is provided but not used within the function; it is included for consistency with the problem statement.\n    \n    assert find_min_diff((1, 5, 3, 19, 18, 25), 6) == 1\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(sorted_arr) - 1):\n        min_diff = min(min_diff, sorted_arr[i + 1] - sorted_arr[i])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    return min((abs(sorted_arr[i + 1] - sorted_arr[i]) for i in range(len(sorted_arr) - 1)))", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(sorted_arr)):\n        min_diff = min(min_diff, sorted_arr[i] - sorted_arr[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(sorted_arr) - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(sorted_arr)):\n        min_diff = min(min_diff, sorted_arr[i] - sorted_arr[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(sorted_arr) - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(sorted_arr) - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        min_diff = min(min_diff, diff)\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(sorted_arr) - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        min_diff = min(min_diff, diff)\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(len(sorted_arr) - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        min_diff = min(min_diff, diff)\n    return min_diff"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number. A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers. The sequence starts with 1 (which is not considered polite), followed by 3, 5, 6, 7, 9, 10, 11, etc., excluding powers of two.\n    \n    assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["def is_polite(n: int) -> int:\n\n    def is_power_of_two(num: int) -> bool:\n        return num > 0 and num & num - 1 == 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n        current += 1\n    return polite_numbers[-1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x & x - 1 == 0 and x > 0\n    polite_numbers = []\n    num = 1\n    while len(polite_numbers) < n:\n        if not is_power_of_two(num):\n            polite_numbers.append(num)\n        num += 1\n    return polite_numbers[n - 1]", "def is_polite(n: int) -> int:\n\n    def is_polite_number(x):\n        return x & x - 1 != 0\n    count = 0\n    current = 1\n    while True:\n        current += 1\n        if is_polite_number(current):\n            count += 1\n            if count == n:\n                return current", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x > 0 and x & x - 1 == 0\n    polite_numbers = []\n    i = 1\n    while len(polite_numbers) < n:\n        if not is_power_of_two(i):\n            polite_numbers.append(i)\n        i += 1\n    return polite_numbers[n - 1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x & x - 1 == 0 and x > 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n    return polite_numbers[-1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x > 0 and x & x - 1 == 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n    return polite_numbers[-1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x & x - 1 == 0 and x > 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n    return polite_numbers[-1]", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x: int) -> bool:\n        return x & x - 1 == 0\n    count = 0\n    num = 1\n    while count < n:\n        num += 1\n        if not is_power_of_two(num):\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x > 0 and x & x - 1 == 0\n    count = 0\n    current_number = 1\n    while True:\n        current_number += 1\n        if not is_power_of_two(current_number):\n            count += 1\n            if count == n:\n                return current_number", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x & x - 1 == 0 and x != 0\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if not is_power_of_two(current):\n            polite_numbers.append(current)\n    return polite_numbers[n - 1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/771", "requirement": "def check_expression(expression: str) -> bool:\n    \"\"\"Check if the given expression containing brackets is balanced.\n    \n    A string expression is considered balanced if each opening bracket (i.e., '(', '{', '[') \n    has a corresponding closing bracket (i.e., ')', '}', ']') of the same type and brackets are properly nested.\n    \n    assert check_expression(\"{()}[{}]\") == True\n    \"\"\"", "generated_programs": ["from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    matching_brackets = {')': '(', '}': '{', ']': '['}\n    stack = deque()\n    for char in expression:\n        if char in matching_brackets.values():\n            stack.append(char)\n        elif char in matching_brackets:\n            if not stack or stack.pop() != matching_brackets[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack: List[str] = []\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map:\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    open_brackets = set(bracket_map.values())\n    for char in expression:\n        if char in open_brackets:\n            stack.append(char)\n        elif char in bracket_map:\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    matching_brackets = {')': '(', '}': '{', ']': '['}\n    stack = deque()\n    for char in expression:\n        if char in matching_brackets.values():\n            stack.append(char)\n        elif char in matching_brackets.keys():\n            if not stack or stack.pop() != matching_brackets[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    open_set = set(bracket_map.values())\n    stack: List[str] = []\n    for char in expression:\n        if char in open_set:\n            stack.append(char)\n        elif char in bracket_map:\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    matching_brackets = {')': '(', '}': '{', ']': '['}\n    stack: List[str] = []\n    for char in expression:\n        if char in matching_brackets.values():\n            stack.append(char)\n        elif char in matching_brackets:\n            if not stack or stack.pop() != matching_brackets[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack: List[str] = []\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    stack = deque()\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if stack and stack[-1] == bracket_map[char]:\n                stack.pop()\n            else:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map:\n            if stack and stack[-1] == bracket_map[char]:\n                stack.pop()\n            else:\n                return False\n    return not stack"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/780", "requirement": "def find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"Generate all unique pairs of tuples from the given list and return a list of tuples where each tuple is the element-wise sum of the pairs.\nassert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n\"\"\"", "generated_programs": ["from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [tuple(map(sum, zip(*pair))) for pair in combinations(test_list, 2)]", "from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [tuple(map(sum, zip(a, b))) for a, b in combinations(test_list, 2)]", "from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [tuple(map(sum, zip(*pair))) for pair in combinations(test_list, 2)]", "from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [tuple(map(sum, zip(x, y))) for x, y in combinations(test_list, 2)]", "from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [tuple(map(sum, zip(*pair))) for pair in combinations(test_list, 2)]", "from typing import List, Tuple\nfrom itertools import combinations\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [tuple(map(sum, zip(pair[0], pair[1]))) for pair in combinations(test_list, 2)]", "from typing import List, Tuple\nfrom itertools import combinations\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [tuple(map(sum, zip(a, b))) for a, b in combinations(test_list, 2)]", "from typing import List, Tuple\nfrom itertools import permutations\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [tuple(map(sum, zip(a, b))) for a, b in permutations(test_list, 2)]", "from typing import List, Tuple\nfrom itertools import combinations\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [tuple(map(sum, zip(a, b))) for a, b in combinations(test_list, 2)]", "from itertools import combinations\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [tuple(map(sum, zip(*pair))) for pair in combinations(test_list, 2)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "Mbpp/782", "requirement": "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to calculate the sum of contributions of each element in the array,\n    where each element's contribution is the element's value multiplied by the number of odd-length\n    subarrays it appears in. \n    \n    assert odd_length_sum([1, 2, 4]) == 14\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        left_count = i + 1\n        right_count = n - i\n        odd_contributions = (left_count * right_count + 1) // 2\n        total_sum += arr[i] * odd_contributions\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        left_count = i + 1\n        right_count = n - i\n        total_count = left_count * right_count\n        odd_count = total_count // 2 + total_count % 2\n        total_sum += arr[i] * odd_count\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        odd_count = ((i + 1) * (n - i) + 1) // 2\n        total_sum += arr[i] * odd_count\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total_contribution = 0\n    for i in range(n):\n        left_count = i + 1\n        right_count = n - i\n        odd_subarrays_count = (left_count * right_count + 1) // 2\n        total_contribution += arr[i] * odd_subarrays_count\n    return total_contribution", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        start_count = i + 1\n        end_count = n - i\n        total_subarrays = start_count * end_count\n        odd_subarrays_count = total_subarrays // 2 + total_subarrays % 2\n        total_sum += arr[i] * odd_subarrays_count\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        start = i + 1\n        end = n - i\n        total_subarrays = start * end\n        odd_subarrays = (total_subarrays + 1) // 2\n        total_sum += arr[i] * odd_subarrays\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        left_count = i + 1\n        right_count = n - i\n        total_occurrences = left_count * right_count\n        odd_occurrences = (total_occurrences + 1) // 2\n        total_sum += arr[i] * odd_occurrences\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        left_count = i + 1\n        right_count = n - i\n        total_subarrays = left_count * right_count\n        odd_subarrays = (total_subarrays + 1) // 2\n        result += arr[i] * odd_subarrays\n    return result", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        left_count = i + 1\n        right_count = n - i\n        odd_length_subarrays = (left_count * right_count + 1) // 2\n        total_sum += arr[i] * odd_length_subarrays\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        left_count = i + 1\n        right_count = n - i\n        odd_subarray_count = (left_count * right_count + 1) // 2\n        total_sum += arr[i] * odd_subarray_count\n    return total_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even and the first odd number in a given list.\n    If the list does not contain both an even and an odd number, return 0.\n    \n    assert mul_even_odd([1,3,5,7,4,1,6,8]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if not even_found and num % 2 == 0:\n            first_even = num\n            even_found = True\n        if not odd_found and num % 2 != 0:\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    seen_even = False\n    seen_odd = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if not seen_even and num % 2 == 0:\n            first_even = num\n            seen_even = True\n        elif not seen_odd and num % 2 != 0:\n            first_odd = num\n            seen_odd = True\n        if seen_even and seen_odd:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_found = False\n    odd_found = False\n    first_even = 0\n    first_odd = 0\n    for num in list1:\n        if not even_found and num % 2 == 0:\n            first_even = num\n            even_found = True\n        if not odd_found and num % 2 != 0:\n            first_odd = num\n            odd_found = True\n        if even_found and odd_found:\n            return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        elif odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if num % 2 == 0 and even is None:\n            even = num\n        elif num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even * odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is not None and odd is not None:\n            break\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n    if even is not None and odd is not None:\n        return even * odd\n    return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/790", "requirement": "from typing import List\n\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a Python function to check whether the number at every even index is even in a given list.\n    \n    assert even_position([3, 2, 1]) == False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches a string that starts with 'a', followed by zero or more characters that are not 'a', and ends with 'b'.\n    assert text_starta_endb(\"aabbbb\") == None\n    \"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a[^a]*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a[^a]*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a[^a]*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/797", "requirement": "def sum_in_range(l: int, r: int) -> int:\n\"\"\"\nWrite a Python function to find the sum of all odd natural numbers within the range from max(1, l) to r (inclusive).\nassert sum_in_range(2,5) == 8\n\"\"\"", "generated_programs": ["def sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(max(1, l), r + 1) if x % 2 != 0))", "from typing import List\n\ndef sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(max(1, l), r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(max(1, l), r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(max(1, l), r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(max(1, l), r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    l = max(1, l)\n    return sum((x for x in range(l, r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    l = max(1, l)\n    return sum((x for x in range(l, r + 1) if x % 2 != 0))", "from typing import List\n\ndef sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(max(1, l), r + 1) if x % 2 != 0))", "from typing import List\n\ndef sum_in_range(l: int, r: int) -> int:\n    return sum((x for x in range(max(1, l), r + 1) if x % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((n for n in range(max(1, l), r + 1) if n % 2 != 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}

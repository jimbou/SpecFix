{"task_id": "Mbpp/6", "requirement": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the two numbers differ at exactly one bit position in their binary representation.\n    \n    The function should return:\n    - True if the binary representations of `a` and `b` differ at exactly one bit position, or if `a` and `b` are identical (no differing bits).\n    - False otherwise, including cases where the binary representations differ at more than one bit position.\n\n    The function uses the XOR operation (`a ^ b`) to determine the differing bits and checks if the result is a power of 2, which indicates a single differing bit position. For identical numbers (`a == b`), the XOR result is `0`, which is treated as satisfying the condition.\n\n    Example:\n    assert differ_At_One_Bit_Pos(13, 9) == True\n    \"\"\"", "generated_programs": ["def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return bin(xor_result).count('1') <= 1", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0 or xor_result == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return True\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return True\n    return xor_result & xor_result - 1 == 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/11", "requirement": "```python\ndef remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Write a Python function to remove the first and last occurrence of a given character from the string.\n    \n    - If the character appears only once in the string, remove that single occurrence.\n    - If the character does not exist in the string, return the original string unchanged.\n    - If the string is empty or the character is an empty string, return the original string unchanged.\n    - Ensure that overlapping indices are handled correctly, i.e., the first and last occurrence must be distinct for both to be removed.\n    \n    Examples:\n    assert remove_Occ(\"hello\", \"l\") == \"heo\"\n    assert remove_Occ(\"banana\", \"a\") == \"bnan\"\n    \"\"\"\n```", "generated_programs": ["def remove_Occ(s: str, ch: str) -> str:\n    if not s or not ch:\n        return s\n    first = s.find(ch)\n    last = s.rfind(ch)\n    if first == -1:\n        return s\n    if first == last:\n        return s[:first] + s[first + 1:]\n    return s[:first] + s[first + 1:last] + s[last + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or not ch or ch not in s:\n        return s\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or not ch:\n        return s\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == -1:\n        return s\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or not ch:\n        return s\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == -1:\n        return s\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or not ch:\n        return s\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or not ch:\n        return s\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == -1:\n        return s\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or not ch:\n        return s\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == -1:\n        return s\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or not ch:\n        return s\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == -1:\n        return s\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or not ch:\n        return s\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == -1:\n        return s\n    elif first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    else:\n        return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if not s or not ch:\n        return s\n    indices = [i for i, c in enumerate(s) if c == ch]\n    if not indices:\n        return s\n    first = indices[0]\n    last = indices[-1]\n    if first == last:\n        return s[:first] + s[first + 1:]\n    return s[:first] + s[first + 1:last] + s[last + 1:]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/16", "requirement": "```python\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if the input string consists of one or more sequences of \n    lowercase letters, where each sequence may optionally be joined by a single underscore. \n    The string must not start or end with an underscore, and consecutive underscores are not allowed.\n    Return False otherwise.\n\n    Examples:\n    - A single sequence of lowercase letters without underscores (e.g., \"abcdef\") is valid and should return True.\n    - Multiple sequences of lowercase letters joined by single underscores (e.g., \"abc_def_ghi\") are valid and should return True.\n    - Strings with leading or trailing underscores, consecutive underscores, or containing characters other than lowercase letters and underscores are invalid and should return False.\n\n    assert text_lowercase_underscore(\"aab_cbbbc\") == True\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^([a-z]+)(?:_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "code\nimport re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = re.compile('^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^([a-z]+(_[a-z]+)*)$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = re.compile('^([a-z]+)(_[a-z]+)*$')\n    return bool(pattern.match(text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "Mbpp/20", "requirement": "def is_woodall(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given number is a Woodall number or not.\n\n    A Woodall number is defined by the formula: W(n) = n * 2^n - 1, where n is a non-negative integer (n >= 0).\n    The function should determine if the input number matches any Woodall number generated by this formula.\n\n    Behavior:\n    1. The function accepts any integer input, including negative numbers, zero, and positive numbers.\n    2. The function returns `True` if the input number matches a Woodall number, and `False` otherwise.\n    3. For negative inputs, the function evaluates whether they match the formula for any valid non-negative n (e.g., -1 matches W(0) because W(0) = 0 * 2^0 - 1 = -1). \n       The function performs an exhaustive search over non-negative n, starting from n = 0, and stops when the generated Woodall number exceeds the input number.\n    4. The function does not raise exceptions for invalid inputs; it always returns a boolean value. Non-integer inputs are considered invalid and return `False`.\n\n    Examples:\n    assert is_woodall(383) == True\n    ### Test 1\n    Input: [-1]\n    Expected Output: [True]\n    ### Test 2\n    Input: [0]\n    Expected Output: [False]\n    \"\"\"", "generated_programs": ["import math\n\ndef is_woodall(num: int) -> bool:\n    if not isinstance(num, int):\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if not isinstance(num, int):\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if not isinstance(num, int):\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if not isinstance(num, int):\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        elif woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if not isinstance(num, int):\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if not isinstance(num, int):\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if not isinstance(num, int):\n        return False\n    n = 0\n    while True:\n        woodall_num = n * 2 ** n - 1\n        if woodall_num == num:\n            return True\n        if woodall_num > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if not isinstance(num, int):\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        elif woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if not isinstance(num, int):\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if not isinstance(num, int):\n        return False\n    n = 0\n    while True:\n        woodall_num = n * 2 ** n - 1\n        if woodall_num == num:\n            return True\n        elif woodall_num > num:\n            return False\n        n += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/58", "requirement": "```python\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given two integers have opposite signs or not.\n\n    Two integers are considered to have opposite signs if one is strictly positive and the other is strictly negative, \n    or if one is zero (treated as non-negative) and the other is strictly negative. \n    This determination is based on the binary representation of the integers, where the most significant bit (MSB) \n    indicates the sign: 0 for non-negative numbers (including zero) and 1 for negative numbers.\n\n    Examples:\n    - opposite_Signs(1, -2) -> True (1 is positive, -2 is negative)\n    - opposite_Signs(0, -5) -> True (0 is non-negative, -5 is negative)\n    - opposite_Signs(0, 5) -> False (both are non-negative)\n    - opposite_Signs(3, 7) -> False (both are positive)\n    - opposite_Signs(-3, -7) -> False (both are negative)\n\n    Note:\n    - Zero (0) is treated as non-negative (neutral) in this context.\n    - The function uses bitwise XOR (`^`) to determine opposite signs based on the MSB of the integers.\n\n    assert opposite_Signs(1, -2) == True\n    \"\"\"\n```", "generated_programs": ["def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0 or (x == 0 and y < 0) or (y == 0 and x < 0)", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0 or (x == 0 and y < 0) or (y == 0 and x < 0)", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0 or (x == 0 and y < 0) or (y == 0 and x < 0)", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0 or (x == 0 and y < 0) or (y == 0 and x < 0)", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0 or (x == 0 and y < 0) or (y == 0 and x < 0)", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0 or (x == 0 and y < 0) or (y == 0 and x < 0)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/67", "requirement": "```python\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Write a function to compute the nth Bell number, which represents the number of ways \n    to partition a set of n elements. The input `n` must be a non-negative integer.\n\n    - If `n` is negative, the function is expected to raise an `IndexError` due to invalid indexing.\n    - The function uses a dynamic programming approach to calculate the Bell number.\n    - The Bell number for a set of size `n` is defined as the number of distinct ways to partition \n      the set into non-empty subsets.\n\n    Example:\n    assert bell_number(2) == 2  # The second Bell number is 2, representing the partitions of a set of 2 elements.\n\n    Input constraints:\n    - `n` must be a non-negative integer (`n >= 0`).\n    - Behavior for negative inputs is undefined in terms of explicit error handling, but the function \n      will raise an `IndexError` due to invalid indexing.\n\n    Edge cases:\n    - For `n = 0`, the Bell number is 1 (the empty set has one partition: itself).\n    - For `n < 0`, the function will raise an `IndexError`.\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [-1]\n    Expected Output: ['IndexError']\n    \"\"\"\n```", "generated_programs": ["def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "code\n\ndef bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be a non-negative integer')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Invalid input: n must be a non-negative integer.')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be a non-negative integer')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Negative input is not allowed.')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/71", "requirement": "def comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to sort a list of elements in ascending order using the comb sort algorithm.\n    The function should repeatedly compare and swap elements that are a certain gap apart, \n    reducing the gap size over iterations until the list is sorted. The gap size is reduced \n    using a shrink factor of 1.3 (rounded down to the nearest integer), and the process continues \n    until no swaps are needed and the gap size is 1.\n\n    assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = max(1, int(gap / shrink))\n        sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = max(1, int(gap / shrink))\n        swapped = False\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                swapped = True\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = max(1, int(gap / shrink))\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                swapped = True\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/72", "requirement": "def dif_Square(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given integer `n` can be represented as the difference of two squares, where `n = a^2 - b^2` for integers `a` and `b`.\n\n    The function should return `True` if:\n    - `n` is an even number, or\n    - `n` is an odd number congruent to 1 modulo 4 (i.e., `n % 4 == 1`).\n\n    Otherwise, the function should return `False`.\n\n    Constraints:\n    - The input `n` is an integer and can be positive, negative, or zero.\n    - The output is a boolean value indicating whether `n` satisfies the above conditions.\n\n    Example:\n    assert dif_Square(5) == True\n    \"\"\"", "generated_programs": ["def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0:\n        return True\n    else:\n        return n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0 or n % 4 == 1:\n        return True\n    return False", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0:\n        return True\n    if n % 4 == 1:\n        return True\n    return False", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0:\n        return True\n    elif n % 4 == 1:\n        return True\n    else:\n        return False", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0:\n        return True\n    elif n % 4 == 1:\n        return True\n    else:\n        return False", "code\nimport math\n\ndef dif_Square(n: int) -> bool:\n    if n % 2 == 0:\n        return True\n    else:\n        return abs(n) % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0:\n        return True\n    elif n % 4 == 1:\n        return True\n    else:\n        return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n    \"\"\"\n    Write a Python function to determine whether a given integer is divisible by 11.\n    \n    The function should:\n    - Return True if the input integer `n` is divisible by 11, using the modulus operator (`%`).\n    - Handle both positive and negative integers, as divisibility by 11 applies equally to negative numbers.\n    - Not impose any restrictions on the range of input integers.\n    - Use the mathematical modulus operation (`n % 11 == 0`) to check divisibility, without relying on digit-based rules or transformations.\n\n    Example:\n    assert is_Diff(12345) == False\n    assert is_Diff(-11) == True\n    \"\"\"", "generated_programs": ["def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/84", "requirement": "```python\ndef sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the Newman-Conway sequence.\n\n    The Newman-Conway sequence is defined as follows:\n    - Base cases:\n        - sequence(1) = 1\n        - sequence(2) = 1\n    - Recursive formula for n > 2:\n        sequence(n) = sequence(sequence(n - 1)) + sequence(n - sequence(n - 1))\n\n    Constraints:\n    - The input `n` must be a positive integer (n > 0).\n    - If `n <= 0`, the function should raise an `IndexError`.\n\n    Implementation Details:\n    - Use an iterative approach to compute the sequence values.\n    - Precompute values up to `sequence(n)` using an auxiliary array for efficiency.\n\n    Example:\n    assert sequence(10) == 6\n    \"\"\"\n```", "generated_programs": ["def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/89", "requirement": "def closest_num(N: int) -> int:\n    \"\"\"\n    Write a function to find the closest smaller number than N by subtracting 1 from N. \n    The function should always decrement N by 1, regardless of whether N is positive, zero, or negative.\n    For example:\n    - If N = 11, the function returns 10.\n    - If N = 0, the function returns -1.\n    - If N = -5, the function returns -6.\n    \n    Input:\n    - N: An integer, which can be positive, zero, or negative.\n\n    Output:\n    - An integer that is exactly 1 less than the input N.\n\n    Example:\n    assert closest_num(11) == 10\n    \"\"\"", "generated_programs": ["def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "code\n\ndef closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/92", "requirement": "```python\ndef is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not.\n\n    A number is considered undulating if:\n    1. It has at least 3 digits.\n    2. The first two digits are distinct.\n    3. Starting from the third digit, the sequence alternates between the first and second digits based on their position:\n       - Digits at even indices (0-based) must match the first digit.\n       - Digits at odd indices (0-based) must match the second digit.\n\n    Edge cases:\n    - Numbers with fewer than 3 digits are not undulating.\n    - Numbers with repeated or non-alternating digit patterns are not undulating.\n\n    Example:\n    assert is_undulating(1212121) == True\n    \"\"\"\n```", "generated_programs": ["def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i in range(2, len(s)):\n        if i % 2 == 0:\n            if s[i] != first:\n                return False\n        elif s[i] != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i, char in enumerate(s):\n        if i % 2 == 0:\n            if char != s[0]:\n                return False\n        elif char != s[1]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i, char in enumerate(s):\n        if i % 2 == 0:\n            if char != first:\n                return False\n        elif char != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char != first:\n            return False\n        if i % 2 != 0 and char != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first = s[0]\n    second = s[1]\n    if first == second:\n        return False\n    for i, char in enumerate(s):\n        if i % 2 == 0:\n            if char != first:\n                return False\n        elif char != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i, char in enumerate(s):\n        if i % 2 == 0:\n            if char != first:\n                return False\n        elif char != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if i % 2 == 0:\n            if s[i] != s[0]:\n                return False\n        elif s[i] != s[1]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i in range(2, len(s)):\n        if i % 2 == 0:\n            if s[i] != first:\n                return False\n        elif s[i] != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i in range(2, len(s)):\n        if i % 2 == 0:\n            if s[i] != first:\n                return False\n        elif s[i] != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    digits = str(n)\n    if len(digits) < 3:\n        return False\n    first, second = (digits[0], digits[1])\n    if first == second:\n        return False\n    for i, digit in enumerate(digits[2:], start=2):\n        if i % 2 == 0 and digit != first or (i % 2 != 0 and digit != second):\n            return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.4}}
{"task_id": "Mbpp/95", "requirement": "```python\nfrom typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    \"\"\"\n    Write a Python function to find the length of the smallest list in a list of lists.\n    \n    Requirements:\n    1. The input `lst` must be a non-empty list of lists. If `lst` is empty, the function should raise a `ValueError`.\n    2. Empty lists within the input `lst` are valid and their length (`0`) should be considered when determining the smallest list.\n    3. The function should return an integer representing the length of the smallest list in `lst`.\n    \n    Example:\n    assert Find_Min_Length([[1], [1, 2]]) == 1\n    \"\"\"\n```", "generated_programs": ["from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('The input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must not be empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('The input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('The input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list cannot be empty')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('The input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('The input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/96", "requirement": "```python\ndef divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given integer `n`.\n    \n    - The function should return the count of all positive integers that divide `n` without a remainder.\n    - If `n` is less than or equal to `0`, the function should return `0`, as no positive divisors exist for such cases.\n    - The function does not raise exceptions for invalid inputs and assumes `n` is an integer.\n\n    Example:\n    assert divisor(15) == 4  # Positive divisors of 15 are: 1, 3, 5, 15\n    \"\"\"\n```", "generated_programs": ["def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/103", "requirement": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Compute the Eulerian number a(n, m) using the recursive definition.\n\n    The Eulerian number a(n, m) is defined as:\n    - a(n, m) = 0 if m < 0 or m >= n\n    - a(n, m) = 1 if n == 0 and m == 0\n    - a(n, m) = 0 if n == 0 and m != 0\n    - a(n, m) = 1 if m == 0 and n > 0\n    - a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m) otherwise\n\n    Constraints:\n    - n and m are non-negative integers.\n    - If m is greater than or equal to n, or if m is negative, the function should return 0.\n    - For n == 0, the function should return 1 only if m == 0; otherwise, it should return 0.\n\n    Examples:\n    - assert eulerian_num(3, 1) == 4\n    - Input: [5, 3], Expected Output: [26]\n    - Input: [0, 0], Expected Output: [0]\n    \"\"\"", "generated_programs": ["def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0 and n > 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0 and n > 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0 and n > 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0 and n > 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0 and n > 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0 and n > 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0 and n > 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0 and n > 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "Mbpp/109", "requirement": "def odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Write a Python function to count how many rotations of a binary string result in an odd decimal value. \n\n    The function performs the following steps:\n    1. Rotate the binary string `s` cyclically `n` times. Each rotation is computed modulo the length of the string, ensuring wraparound behavior.\n       - For a given rotation index `i`, the rotated string is defined as:\n         `rotated = s[-(i % len(s)):] + s[:-(i % len(s))]`.\n    2. Convert each rotated binary string to its decimal equivalent and check if it is odd using the modulus operator `% 2`.\n    3. Count all rotations (including repeated rotations due to `n` exceeding the string length) where the decimal value is odd.\n\n    Example:\n    - Input: odd_Equivalent(\"011001\", 6)\n    - Rotations: \"011001\", \"101100\", \"110110\", \"011011\", \"101101\", \"110110\".\n    - Odd decimal values: \"011001\" (25), \"011011\" (27), \"101101\" (45).\n    - Output: 3\n\n    Input and expected output examples:\n    ### Test 1\n    Input: ['101010', 1]\n    Expected Output: [0]\n    ### Test 2\n    Input: ['101010', 1]\n    Expected Output: [0]\n    ### Test 3\n    Input: ['1100', 8]\n    Expected Output: [4]\n    ### Test 4\n    Input: ['1', 6]\n    Expected Output: [6]\n    ### Test 5\n    Input: ['1100', 8]\n    Expected Output: [4]\n    \"\"\"", "generated_programs": ["def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation]\n        decimal = int(rotated, 2)\n        if decimal % 2 == 1:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation]\n        decimal = int(rotated, 2)\n        if decimal % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation]\n        decimal = int(rotated, 2)\n        if decimal % 2 == 1:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation]\n        decimal = int(rotated, 2)\n        if decimal % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation] if rotation != 0 else s\n        decimal = int(rotated, 2)\n        if decimal % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation]\n        decimal = int(rotated, 2)\n        if decimal % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation]\n        decimal = int(rotated, 2)\n        if decimal % 2 == 1:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation] if rotation != 0 else s\n        decimal = int(rotated, 2)\n        if decimal % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation]\n        decimal = int(rotated, 2)\n        if decimal % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation] if rotation != 0 else s\n        decimal = int(rotated, 2)\n        if decimal % 2 != 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/111", "requirement": "```python\nfrom typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements in given nested lists.\n\n    Requirements:\n    1. Input:\n       - `nestedlist` must be a list of lists, where each sublist contains integers.\n       - If `nestedlist` is empty (`[]`), the function should return an empty list (`[]`).\n       - If any sublist within `nestedlist` is empty (`[[]]` or contains empty sublists), the function should raise a `TypeError`.\n       - The function does not validate input types beyond the assumption that `nestedlist` is well-formed as `List[List[int]]`.\n\n    2. Output:\n       - The function returns a list of integers (`List[int]`) containing the elements that are common across all sublists in `nestedlist`.\n       - The order of elements in the output list is arbitrary, as the result is derived from a set operation.\n\n    Example:\n    assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    for sublist in nestedlist:\n        if not sublist:\n            raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    for sublist in nestedlist:\n        if not sublist:\n            raise TypeError('Sublist cannot be empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    for sublist in nestedlist:\n        if not sublist:\n            raise TypeError\n    common = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common.intersection_update(sublist)\n    return list(common)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    if any((not sublist for sublist in nestedlist)):\n        raise TypeError('Sublist cannot be empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    for sublist in nestedlist:\n        if not sublist:\n            raise TypeError('Sublist cannot be empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List, Set\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    for sublist in nestedlist:\n        if not sublist:\n            raise TypeError('Sublist is empty')\n    common_elements: Set[int] = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    for sublist in nestedlist:\n        if not sublist:\n            raise TypeError('Sublist cannot be empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    if any((not sublist for sublist in nestedlist)):\n        raise TypeError('Empty sublists are not allowed.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    for sublist in nestedlist:\n        if not sublist:\n            raise TypeError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    for sublist in nestedlist:\n        if not sublist:\n            raise TypeError('Sublist cannot be empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/113", "requirement": "```python\nfrom typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    \"\"\"\n    Write a function to check if a string represents an integer or not.\n\n    The function should return True if the input string can be successfully \n    converted to an integer using the `int()` function, and False otherwise.\n\n    Clarifications:\n    - Strings with surrounding whitespace (e.g., \" 123 \") are considered valid \n      if they can be parsed into an integer using `int()`.\n    - Signed integers (e.g., \"+123\", \"-123\") are considered valid.\n    - Strings with zero padding (e.g., \"00123\") are considered valid.\n    - Empty strings, strings containing non-numeric characters, or strings \n      that cannot be parsed into integers (e.g., \"python\") are considered invalid.\n    - The function should handle edge cases such as empty strings, whitespace-only \n      strings, and non-printable characters gracefully.\n\n    Example:\n    assert check_integer(\"python\") == False\n    \"\"\"\n```", "generated_programs": ["from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text.strip())\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text.strip())\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text.strip())\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text.strip())\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text.strip())\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text.strip())\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text.strip())\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        stripped_text = text.strip()\n        if not stripped_text:\n            return False\n        int(stripped_text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    if not text.strip():\n        return False\n    try:\n        int(text.strip())\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        stripped_text = text.strip()\n        if not stripped_text:\n            return False\n        int(stripped_text)\n        return True\n    except ValueError:\n        return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/118", "requirement": "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split strictly on the ASCII space character (' ').\n    The function should:\n    - Split the input string at each occurrence of the ASCII space character (' '), preserving consecutive spaces as empty strings in the output list.\n    - Return a list containing a single empty string ([\"\"]) if the input string is empty (\"\").\n    - Handle edge cases such as strings with only spaces by returning a list of empty strings corresponding to the number of spaces plus one.\n    - Do not split on other whitespace characters (e.g., tabs '\\t', newlines '\\n').\n\n    Example:\n    assert string_to_list(\"python programming\") == ['python', 'programming']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ') if string else ['']", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    if not string:\n        return ['']\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ') if string else ['']", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    if not string:\n        return ['']\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    if not string:\n        return ['']\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ') if string else ['']", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    if not string:\n        return ['']\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    if string == '':\n        return ['']\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    if string == '':\n        return ['']\n    return string.split(' ')"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/120", "requirement": "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n\n    Requirements:\n    1. The input `list1` must be a list of tuples, where each tuple contains exactly two numeric elements (integers).\n    2. If the input list is empty, the function must raise a `ValueError`.\n    3. If any tuple in the list does not contain exactly two elements or contains non-numeric elements, the function must raise a `ValueError`.\n    4. The function calculates the absolute product of the two numbers in each tuple and returns the maximum absolute product from the list.\n\n    Example:\n    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list is empty.')\n    max_product = 0\n    for pair in list1:\n        if len(pair) != 2 or not isinstance(pair[0], int) or (not isinstance(pair[1], int)):\n            raise ValueError('Invalid tuple in the list.')\n        product = abs(pair[0] * pair[1])\n        if product > max_product:\n            max_product = product\n    return max_product", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list is empty.')\n    max_product = 0\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2 or (not all((isinstance(x, int) for x in t))):\n            raise ValueError('Invalid tuple structure or non-numeric elements.')\n        product = abs(t[0] * t[1])\n        if product > max_product:\n            max_product = product\n    return max_product", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list is empty.')\n    max_product = 0\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2:\n            raise ValueError('Each element in the list must be a tuple of exactly two integers.')\n        if not all((isinstance(x, int) for x in t)):\n            raise ValueError('Each tuple must contain only integer elements.')\n        product = abs(t[0] * t[1])\n        if product > max_product:\n            max_product = product\n    return max_product", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list is empty')\n    max_product = 0\n    for tup in list1:\n        if not isinstance(tup, tuple) or len(tup) != 2:\n            raise ValueError('Each element in the list must be a tuple with exactly two elements')\n        if not all((isinstance(x, int) for x in tup)):\n            raise ValueError('Each tuple must contain only integer elements')\n        product = abs(tup[0] * tup[1])\n        if product > max_product:\n            max_product = product\n    return max_product", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list must not be empty.')\n    max_product = 0\n    for pair in list1:\n        if not isinstance(pair, tuple) or len(pair) != 2:\n            raise ValueError('Each element must be a tuple with exactly two elements.')\n        if not all((isinstance(x, int) for x in pair)):\n            raise ValueError('Each tuple must contain only numeric elements.')\n        current_product = abs(pair[0] * pair[1])\n        if current_product > max_product:\n            max_product = current_product\n    return max_product", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list cannot be empty.')\n    max_product = -1\n    for tup in list1:\n        if not isinstance(tup, tuple) or len(tup) != 2:\n            raise ValueError('Each element in the list must be a tuple of exactly two integers.')\n        if not all((isinstance(x, int) for x in tup)):\n            raise ValueError('Each tuple must contain only integer values.')\n        product = abs(tup[0] * tup[1])\n        if product > max_product:\n            max_product = product\n    return max_product", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list cannot be empty.')\n    max_prod = -1\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2:\n            raise ValueError('Each element in the list must be a tuple of exactly two elements.')\n        x, y = t\n        if not isinstance(x, int) or not isinstance(y, int):\n            raise ValueError('Each tuple must contain exactly two integer elements.')\n        current_prod = abs(x * y)\n        if current_prod > max_prod:\n            max_prod = current_prod\n    return max_prod", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list must not be empty.')\n    max_prod = float('-inf')\n    for tup in list1:\n        if not isinstance(tup, tuple) or len(tup) != 2:\n            raise ValueError('Each element in the list must be a tuple with exactly two integers.')\n        a, b = tup\n        if not isinstance(a, int) or not isinstance(b, int):\n            raise ValueError('Tuple elements must be integers.')\n        current_prod = abs(a * b)\n        if current_prod > max_prod:\n            max_prod = current_prod\n    return max_prod", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list cannot be empty.')\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2:\n            raise ValueError('Each element in the list must be a tuple containing exactly two elements.')\n        if not (isinstance(t[0], int) and isinstance(t[1], int)):\n            raise ValueError('Both elements in the tuple must be integers.')\n    max_product = 0\n    for t in list1:\n        product = abs(t[0] * t[1])\n        if product > max_product:\n            max_product = product\n    return max_product", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list cannot be empty.')\n    max_product = 0\n    for tup in list1:\n        if not isinstance(tup, tuple) or len(tup) != 2:\n            raise ValueError('Each element in the list must be a tuple with exactly two integers.')\n        if not isinstance(tup[0], int) or not isinstance(tup[1], int):\n            raise ValueError('Each tuple must contain exactly two integers.')\n        product = abs(tup[0] * tup[1])\n        if product > max_product:\n            max_product = product\n    return max_product"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "```python\ndef amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of all amicable numbers within the range [1, limit], inclusive.\n\n    Amicable numbers are defined as a pair of integers (a, b) such that:\n      - a is the sum of proper divisors of b (excluding b itself).\n      - b is the sum of proper divisors of a (excluding a itself).\n      - a != b.\n      - Both a and b must fall within the range [1, limit].\n\n    The function should:\n      - Identify all amicable pairs (a, b) where both numbers are within the range [1, limit].\n      - Add both numbers in each amicable pair to the total sum.\n      - Exclude numbers like 1 from the summation process, as they do not form valid pairs.\n\n    Input:\n      - limit: An integer specifying the upper bound of the range.\n\n    Output:\n      - Return the sum of all amicable numbers within the range [1, limit].\n\n    Examples:\n    assert amicable_numbers_sum(999) == 504\n    \"\"\"\n```", "generated_programs": ["def proper_divisors_sum(n: int) -> int:\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = proper_divisors_sum(a)\n        if b > a and proper_divisors_sum(b) == a and (b <= limit):\n            amicable_sum += a + b\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n):\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n):\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_pairs = set()\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b != a and b <= limit and (sum_of_proper_divisors(b) == a):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_proper_divisors(a)\n        if b > a and sum_proper_divisors(b) == a and (b <= limit):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if a != b and a == sum_of_proper_divisors(b) and (b <= limit):\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = math.isqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if a != b and sum_of_proper_divisors(b) == a and (b <= limit):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            if b <= limit:\n                amicable_pairs.add(a)\n                amicable_pairs.add(b)\n    return sum(amicable_pairs)", "code\nimport math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_pairs = set()\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > limit or b == a:\n            continue\n        if sum_of_proper_divisors(b) == a:\n            amicable_pairs.add(tuple(sorted((a, b))))\n    total_sum = 0\n    for pair in amicable_pairs:\n        total_sum += pair[0] + pair[1]\n    return total_sum", "def proper_divisors_sum(n: int) -> int:\n    if n < 2:\n        return 0\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_pairs = set()\n    for a in range(1, limit + 1):\n        b = proper_divisors_sum(a)\n        if b > limit or b == a:\n            continue\n        if proper_divisors_sum(b) == a:\n            if (a, b) not in amicable_pairs and (b, a) not in amicable_pairs:\n                amicable_pairs.add((a, b))\n    return sum((a + b for a, b in amicable_pairs))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.9}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Write a function to compute the angle of the complex number `b` relative to the positive real axis.\n    The function should ignore the argument `a` and calculate the angle using the imaginary and real parts of `b`.\n    Specifically, the angle is determined using `math.atan2(b.imag, b.real)`.\n\n    Example:\n    assert math.isclose(angle_complex(0, 1j), 1.5707963267948966, rel_tol=0.001)\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [(1+1j), (1-1j)]\n    Expected Output: [-0.7853981633974483]\n    ### Test 2\n    Input: [(1+1j), (1-1j)]\n    Expected Output: [-0.7853981633974483]\n    \"\"\"", "generated_programs": ["import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/126", "requirement": "def sum(a: int, b: int) -> int:\n\"\"\"\nWrite a python function to find the sum of common divisors of two given numbers.\nassert sum(10,15) == 6\n\"\"\"", "generated_programs": ["import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def common_divisors(x):\n        divisors = set()\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                divisors.add(i)\n                divisors.add(x // i)\n        return divisors\n    divisors_a = common_divisors(a)\n    divisors_b = common_divisors(b)\n    common = divisors_a.intersection(divisors_b)\n    return sum(common)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def common_divisors(n):\n        divisors = set()\n        for i in range(1, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    divisors_a = common_divisors(a)\n    divisors_b = common_divisors(b)\n    common = divisors_a.intersection(divisors_b)\n    return sum(common)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def find_common_divisors(x, y):\n        gcd_value = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd_value)) + 1):\n            if gcd_value % i == 0:\n                divisors.add(i)\n                divisors.add(gcd_value // i)\n        return divisors\n    common_divisors = find_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd_value = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd_value)) + 1):\n            if gcd_value % i == 0:\n                divisors.add(i)\n                divisors.add(gcd_value // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def gcd(x, y):\n        while y:\n            x, y = (y, x % y)\n        return x\n\n    def get_common_divisors(n):\n        divisors = set()\n        for i in range(1, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    gcd_val = gcd(a, b)\n    common_divisors = get_common_divisors(gcd_val)\n    return sum(common_divisors)", "from math import gcd\nfrom functools import reduce\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        common_divisors = set()\n        g = gcd(x, y)\n        for i in range(1, int(g ** 0.5) + 1):\n            if g % i == 0:\n                common_divisors.add(i)\n                common_divisors.add(g // i)\n        return common_divisors\n    common_divisors = get_common_divisors(a, b)\n    return reduce(lambda x, y: x + y, common_divisors, 0)", "import math\nfrom typing import List\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x: int, y: int) -> List[int]:\n        gcd_value = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd_value)) + 1):\n            if gcd_value % i == 0:\n                divisors.add(i)\n                divisors.add(gcd_value // i)\n        return sorted(divisors)\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)"], "result": {"repaired_passk": 0.6, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether a given matrix is a magic square.\n\n    A magic square is defined as a square matrix (i.e., the number of rows equals the number of columns) \n    where the sums of all rows, all columns, and the two diagonals are equal to the same value (the \"magic sum\").\n\n    The function should adhere to the following rules:\n    1. The input matrix must be a list of lists of integers.\n    2. If the input matrix is empty (`[]` or `[[]]`), return `False`.\n    3. If the input matrix is not square (i.e., the number of rows does not equal the number of columns, \n       or rows have inconsistent lengths), return `False`.\n    4. If the matrix is square, check whether it satisfies the magic square conditions:\n       - All rows must sum to the same value.\n       - All columns must sum to the same value.\n       - Both the primary diagonal (top-left to bottom-right) and the secondary diagonal (top-right to bottom-left) \n         must sum to the same value.\n    5. If all the above conditions are met, return `True`. Otherwise, return `False`.\n\n    Examples:\n    - `magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])` should return `True`.\n    - `magic_square_test([[]])` should return `False`.\n    - `magic_square_test([[1, 2], [3, 4, 5]])` should return `False` (not square).\n    - `magic_square_test([])` should return `False`.\n\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all(my_matrix):\n        return False\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = sum(my_matrix[0])\n    if any((sum(row) != magic_sum for row in my_matrix)):\n        return False\n    if any((sum((my_matrix[i][j] for i in range(n))) != magic_sum for j in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all(my_matrix):\n        return False\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_sum:\n            return False\n    diag1 = sum((my_matrix[i][i] for i in range(n)))\n    diag2 = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    return diag1 == magic_sum and diag2 == magic_sum", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or all((len(row) == 0 for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for i in range(n):\n        if sum((my_matrix[j][i] for j in range(n))) != target_sum:\n            return False\n    diagonal1 = sum((my_matrix[i][i] for i in range(n)))\n    diagonal2 = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    return diagonal1 == target_sum and diagonal2 == target_sum", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all(my_matrix):\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or any((not row for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_sum:\n            return False\n    primary_diag = sum((my_matrix[i][i] for i in range(n)))\n    secondary_diag = sum((my_matrix[i][n - i - 1] for i in range(n)))\n    if primary_diag != magic_sum or secondary_diag != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or all((not row for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    magic_sum = sum(my_matrix[0])\n    if not all((sum(row) == magic_sum for row in my_matrix)):\n        return False\n    if not all((sum((my_matrix[i][j] for i in range(n))) == magic_sum for j in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not my_matrix[0]:\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    primary_diag = sum((my_matrix[i][i] for i in range(n)))\n    if primary_diag != magic_sum:\n        return False\n    secondary_diag = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    if secondary_diag != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not any(my_matrix):\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    primary_diagonal = sum((my_matrix[i][i] for i in range(n)))\n    if primary_diagonal != magic_sum:\n        return False\n    secondary_diagonal = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    if secondary_diagonal != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not any(my_matrix):\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_sum:\n            return False\n    primary_diag = sum((my_matrix[i][i] for i in range(n)))\n    if primary_diag != magic_sum:\n        return False\n    secondary_diag = sum((my_matrix[i][n - i - 1] for i in range(n)))\n    if secondary_diag != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or all((len(row) == 0 for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_sum:\n            return False\n    primary_diagonal = sum((my_matrix[i][i] for i in range(n)))\n    if primary_diagonal != magic_sum:\n        return False\n    secondary_diagonal = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    if secondary_diagonal != magic_sum:\n        return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/130", "requirement": "```python\nfrom typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list of integers.\n    \n    Requirements:\n    1. The input list must contain only integers. If the list contains non-integer elements, the function behavior is undefined.\n    2. If the input list is empty, the function must raise a ValueError.\n    3. The function returns a single integer corresponding to the item with the highest frequency in the list.\n    4. In case of ties (multiple items with the same maximum frequency), the function returns the first item encountered with the maximum frequency, based on the order of appearance in the list.\n    \n    Example:\n    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2]) == 2\n    \"\"\"\n```", "generated_programs": ["from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty.')\n    count = Counter(nums)\n    max_freq = max(count.values())\n    for num in nums:\n        if count[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list is empty.')\n    freq = defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n    max_freq = max(freq.values())\n    for num in nums:\n        if freq[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list must not be empty.')\n    frequency = defaultdict(int)\n    for num in nums:\n        frequency[num] += 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list is empty.')\n    frequency = defaultdict(int)\n    for num in nums:\n        frequency[num] += 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty.')\n    frequency = defaultdict(int)\n    max_freq = 0\n    result = nums[0]\n    for num in nums:\n        frequency[num] += 1\n        if frequency[num] > max_freq:\n            max_freq = frequency[num]\n            result = num\n    return result", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty.')\n    frequency = defaultdict(int)\n    for num in nums:\n        frequency[num] += 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num\n    return -1", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty.')\n    freq = defaultdict(int)\n    max_freq = 0\n    result = nums[0]\n    for num in nums:\n        freq[num] += 1\n        if freq[num] > max_freq:\n            max_freq = freq[num]\n            result = num\n    return result", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty.')\n    frequency = defaultdict(int)\n    max_freq_item = None\n    max_freq = 0\n    for num in nums:\n        frequency[num] += 1\n        if frequency[num] > max_freq:\n            max_freq = frequency[num]\n            max_freq_item = num\n    return max_freq_item", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list is empty.')\n    frequency = {}\n    max_freq = 0\n    result = None\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n        if frequency[num] > max_freq:\n            max_freq = frequency[num]\n            result = num\n    return result", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty.')\n    frequency = {}\n    max_freq = 0\n    result = None\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n        if frequency[num] > max_freq:\n            max_freq = frequency[num]\n            result = num\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 1.0}}
{"task_id": "Mbpp/137", "requirement": "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to calculate the ratio of zeroes to non-zeroes in an array of integers.\n    \n    The function should behave as follows:\n    1. If the input list is empty, return `float('inf')`.\n    2. Count zeroes as elements that are exactly `0`.\n    3. Count non-zeroes as elements that are not `0`.\n    4. If there are no non-zero elements in the list, return `float('inf')`.\n    5. Otherwise, return the ratio of zeroes to non-zeroes as a float.\n\n    Example:\n    assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if not nums or non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if len(nums) == 0 or non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/138", "requirement": "```python\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given positive integer `n` can be represented \n    as a sum of multiple distinct non-zero powers of 2, excluding cases where `n` is itself a single power of 2.\n    \n    - The function should return `False` for `n <= 0` or if `n` is a single power of 2 (e.g., 1, 2, 4, 8, etc.).\n    - The function should return `True` if `n` can be expressed as a sum of two or more distinct non-zero powers of 2.\n    \n    Examples:\n    assert is_Sum_Of_Powers_Of_Two(10) == True  # 10 = 2 + 8\n    assert is_Sum_Of_Powers_Of_Two(1) == False  # 1 is a single power of 2\n    assert is_Sum_Of_Powers_Of_Two(2) == False  # 2 is a single power of 2\n    assert is_Sum_Of_Powers_Of_Two(0) == False  # 0 is not a positive integer\n    \"\"\"\n```", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/145", "requirement": "```python\nfrom typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the maximum absolute difference between any two elements in a given array.\n    \n    Preconditions:\n    - The input array `arr` must be a non-empty list of integers.\n    - The function will raise a `ValueError` if the input array is empty.\n    \n    Input Type:\n    - The input must be a list of integers (`List[int]`). Other iterable types, such as tuples, are not valid inputs.\n    \n    Expected Behavior:\n    - The function computes the maximum absolute difference by subtracting the smallest element in the array from the largest element.\n    - If the input array contains fewer than two elements, the function will still compute the difference between the single element and itself, resulting in `0`.\n    \n    Example:\n    assert max_Abs_Diff([2, 1, 5, 3]) == 4\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must be non-empty.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must be non-empty')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must not be empty.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must be non-empty')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must be non-empty.')\n    return abs(max(arr) - min(arr))", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must be non-empty.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must be non-empty')\n    return max(arr) - min(arr)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"\n    Write a function that returns a tuple of non-negative integers (x, y) that satisfy the equation ax + by = n, \n    or return None if no such solution exists. The function should find solutions by iterating over possible values \n    of x starting from 0 up to n // a (inclusive) and checking if a corresponding non-negative y exists. If multiple \n    solutions exist, return the lexicographically smallest solution (minimum x, break ties with y).\n\n    Constraints:\n    - x and y must be non-negative integers.\n    - If no solution exists, return None.\n    - The solution must satisfy the equation ax + by = n.\n    - If either a = 0 or b = 0, the function must immediately raise a ZeroDivisionError without attempting to compute solutions.\n    - The solution-finding loop runs only if both a and b are non-zero.\n\n    Example:\n    assert find_solution(2, 3, 7) == (2, 1)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a or b cannot be zero.')\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y == int(y) and y >= 0:\n            return (x, int(y))\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y >= 0 and y == int(y):\n            return (x, int(y))\n    return None", "code\nfrom typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a and b must be non-zero.')\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y >= 0 and y == int(y):\n            return (x, int(y))\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a and b must be non-zero.')\n    for x in range(n // a + 1):\n        remainder = n - a * x\n        if remainder >= 0 and remainder % b == 0:\n            y = remainder // b\n            return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a and b must be non-zero.')\n    for x in range(n // a + 1):\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('Neither a nor b can be zero.')\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a and b must be non-zero.')\n    for x in range(n // a + 1):\n        remainder = n - a * x\n        if remainder >= 0 and remainder % b == 0:\n            y = remainder // b\n            return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('Both a and b must be non-zero.')\n    for x in range(n // a + 1):\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    if a == 0 or b == 0:\n        raise ZeroDivisionError('a and b must be non-zero')\n    for x in range(n // a + 1):\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            if y >= 0:\n                return (x, y)\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "Mbpp/222", "requirement": "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    \"\"\"\n    Write a function to check if all the elements in a tuple have the exact same base data type. \n    The data type is determined using the `type()` function, which does not account for subclass relationships.\n    \n    The function outputs `True` if all elements in the tuple share the same base type, and `False` otherwise.\n    \n    Special cases and constraints:\n    1. Subclass relationships (e.g., `bool` is a subclass of `int`) are not considered; `bool` and `int` are treated as distinct.\n    2. The function handles empty tuples (`()`) explicitly, returning `True` as they contain no elements to compare.\n    3. Elements can be of any type supported by Python, including custom objects.\n    4. Mixed-type tuples (e.g., `(5, \"string\", 3.0)`) are valid input and should appropriately return `False`.\n    5. The result `False` signifies the presence of a type mismatch in elements or invalid input structure.\n\n    Example:\n    assert check_type((5, 6, 7, 3, 5, 6)) == True\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(item) == first_type for item in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for item in test_tuple:\n        if type(item) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(item) == first_type for item in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for item in test_tuple:\n        if type(item) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    base_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != base_type:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/223", "requirement": "```python\nfrom typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n    Write a function that takes in a sorted array, its length (n), and an element (x), \n    and returns whether the element is the majority element in the given sorted array. \n    The majority element is defined as the element that occurs strictly more than n/2 times.\n\n    Requirements:\n    1. The input array is guaranteed to be sorted in non-decreasing order.\n    2. The function must determine the count of the element x in the array and check if it exceeds n/2.\n    3. The sorted nature of the array is incidental and does not need to be leveraged for efficiency.\n    4. If the element x is not present in the array, the function should return False.\n    5. The function should return False if the count of x is less than or equal to n/2.\n\n    Examples:\n    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    assert is_majority([1, 2, 3, 4, 5], 5, 3) == False\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n / 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n / 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n / 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n / 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n / 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n / 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n / 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n // 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n    \"\"\"\n    Write a Python function to set all even bit positions of a given number `n` to 1.\n    The even bit positions to be set are restricted to the bit-length of `n`. \n    Specifically, only even bit positions from 0 up to (but not exceeding) `n.bit_length() - 1` are considered.\n    Higher bit positions beyond the bit-length of `n` remain unaffected.\n\n    Example:\n    assert even_bit_set_number(10) == 10\n    \"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length(), 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length(), 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length(), 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_length = n.bit_length()\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n.\n    Each sequence must satisfy the following conditions:\n    1. The first element of the sequence can be any positive integer between 1 and m (inclusive).\n    2. Each subsequent element in the sequence must satisfy:\n       - It is greater than or equal to twice the previous element.\n       - It is less than or equal to m.\n    The function returns the total number of such sequences.\n\n    Example:\n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"", "generated_programs": ["from functools import lru_cache\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 1:\n        return m\n    total = 0\n    for i in range(1, m // 2 ** (n - 1) + 1):\n        total += get_total_number_of_sequences(m, n - 1)\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = dp[i][j - 1] + dp[i - 1][j // 2]\n    return dp[n][m]", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum((dp[n][j] for j in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = sum((dp[i - 1][k] for k in range(2 * j, m + 1)))\n    return sum((dp[n][j] for j in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 1:\n        return m\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum((dp[n][j] for j in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = {}\n\n    def dfs(current: int, length: int) -> int:\n        if length == n:\n            return 1\n        if (current, length) in dp:\n            return dp[current, length]\n        total = 0\n        for next_num in range(2 * current, m + 1):\n            total += dfs(next_num, length + 1)\n        dp[current, length] = total\n        return total\n    result = 0\n    for first_num in range(1, m + 1):\n        result += dfs(first_num, 1)\n    return result", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 1:\n        return m\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 1:\n        return m\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                if k * 2 <= j:\n                    dp[i][j] += dp[i - 1][k]\n    total = 0\n    for i in range(1, m + 1):\n        total += dp[n][i]\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.7}}
{"task_id": "Mbpp/244", "requirement": "```python\ndef next_Perfect_Square(N: int) -> int:\n    \"\"\"\n    Write a Python function to find the next perfect square greater than a given number.\n\n    The function should:\n    1. Identify the square root of the given number `N`.\n    2. If the square root is not an integer, round it up to the nearest integer.\n    3. Return the square of the resulting integer to find the smallest perfect square \n       that is strictly greater than `N`.\n\n    Example:\n        assert next_Perfect_Square(35) == 36\n\n    Note: The function must ensure that if `N` is already a perfect square,\n          it finds the next perfect square greater than `N`.\n    \"\"\"\n```", "generated_programs": ["import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.sqrt(N)\n    next_root = math.floor(root) + 1\n    return next_root ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.sqrt(N)\n    if sqrt.is_integer():\n        return int((sqrt + 1) ** 2)\n    else:\n        return int(math.ceil(sqrt) ** 2)", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.sqrt(N)\n    next_int = math.ceil(sqrt) if sqrt != math.floor(sqrt) else math.floor(sqrt) + 1\n    return next_int ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.sqrt(N)\n    next_int = math.ceil(sqrt) if not sqrt.is_integer() else int(sqrt) + 1\n    return next_int ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.sqrt(N)\n    ceil_sqrt = math.ceil(sqrt_N)\n    if ceil_sqrt == sqrt_N:\n        ceil_sqrt += 1\n    return ceil_sqrt ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.sqrt(N)\n    next_int = math.ceil(sqrt) if not sqrt.is_integer() else int(sqrt) + 1\n    return next_int ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.sqrt(N)\n    if sqrt == int(sqrt):\n        return (int(sqrt) + 1) ** 2\n    else:\n        return math.ceil(sqrt) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.sqrt(N)\n    next_int = math.ceil(sqrt_N) if not sqrt_N.is_integer() else int(sqrt_N) + 1\n    return next_int ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.sqrt(N)\n    if sqrt == int(sqrt):\n        return (int(sqrt) + 1) ** 2\n    else:\n        return math.ceil(sqrt) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.sqrt(N)\n    if sqrt_N == int(sqrt_N):\n        return (int(sqrt_N) + 1) ** 2\n    else:\n        return math.ceil(sqrt_N) ** 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/247", "requirement": "```python\ndef lps(str1: str) -> int:\n    \"\"\"\n    Write a function to find the length of the longest palindromic subsequence in the given string.\n\n    Requirements:\n    - The input string `str1` must be non-empty. If an empty string is provided, the function must raise an IndexError.\n    - The input string may contain non-alphabetic characters, such as spaces, and these characters are considered valid and included in the calculation of the longest palindromic subsequence. No preprocessing is performed on the input string.\n\n    Example:\n    assert lps(\"TENS FOR TENS\") == 5\n    \"\"\"\n```", "generated_programs": ["def lps(str1: str) -> int:\n    if not str1:\n        raise IndexError('Input string must be non-empty.')\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    if not str1:\n        raise IndexError('Input string must be non-empty.')\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    if not str1:\n        raise IndexError('Input string must be non-empty.')\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    if not str1:\n        raise IndexError('Input string must be non-empty.')\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    if not str1:\n        raise IndexError('Input string must be non-empty.')\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    if not str1:\n        raise IndexError('Input string must be non-empty.')\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    if not str1:\n        raise IndexError('Input string must be non-empty.')\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    if not str1:\n        raise IndexError('Input string must be non-empty.')\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str1[i] == str1[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1] if length > 2 else 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    if not str1:\n        raise IndexError('Input string must be non-empty.')\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str1[i] == str1[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1] if length != 2 else 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    if not str1:\n        raise IndexError('Input string must be non-empty.')\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if str1[i] == str1[j]:\n                if cl == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    return dp[0][n - 1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/255", "requirement": "from typing import List, Tuple\n\ndef combinations_colors(l: List, n: int) -> List[Tuple]:\n    \"\"\"\n    Write a function that takes in a list and a positive integer n, and generates all combinations with replacement of the elements of the list. \n    The function returns a list containing tuples for each combination. \n    Combinations with replacement ensure that:\n    1. Order does not matter (e.g., ('Red', 'Green') and ('Green', 'Red') are considered the same).\n    2. Repetition of elements is allowed within combinations.\n    This behavior aligns with the use of `itertools.combinations_with_replacement`.\n\n    Example:\n    assert combinations_colors([\"Red\", \"Green\", \"Blue\"], 1) == [('Red',), ('Green',), ('Blue',)]\n    \"\"\"", "generated_programs": [], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/259", "requirement": "def maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    \"\"\"\n    Write a function to maximize the given two tuples element-wise. For each pair of tuples at the same index in the input tuples, \n    compare corresponding elements and construct a new tuple where each element is the maximum of the two compared values. \n    Return a tuple containing these new tuples.\n\n    Example:\n    assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple(((max(a, c), max(b, d)) for (a, b), (c, d) in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(x, y) for x, y in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(x, y) for x, y in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "code\nfrom typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(val1, val2) for val1, val2 in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(x, y) for x, y in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "```python\ndef newman_prime(n: int) -> int:\n    \"\"\"\n    Compute the nth term of the Newman-Shanks-Williams sequence.\n\n    The Newman-Shanks-Williams sequence is defined recursively as:\n    S(0) = 1\n    S(1) = 1\n    S(n) = 2 * S(n - 1) + S(n - 2) for n > 1\n\n    This function returns the value of the nth term in the sequence, where n is a non-negative integer.\n\n    Input constraints:\n    - If `n` is negative, the function must raise a `ValueError` with the message 'Input must be a non-negative integer.'\n    - If `n` is not an integer (e.g., a float), the function must raise a `TypeError`.\n\n    Example:\n    assert newman_prime(3) == 7\n    \"\"\"\n```", "generated_programs": ["def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    s0, s1 = (1, 1)\n    for _ in range(2, n + 1):\n        s0, s1 = (s1, 2 * s1 + s0)\n    return s1", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    s0, s1 = (1, 1)\n    for _ in range(2, n + 1):\n        s2 = 2 * s1 + s0\n        s0, s1 = (s1, s2)\n    return s1", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    s0, s1 = (1, 1)\n    for _ in range(2, n + 1):\n        s0, s1 = (s1, 2 * s1 + s0)\n    return s1", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    s0, s1 = (1, 1)\n    for _ in range(2, n + 1):\n        s2 = 2 * s1 + s0\n        s0, s1 = (s1, s2)\n    return s1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/264", "requirement": "```python\ndef dog_age(h_age: float) -> float:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years based on the following rules:\n    - For human ages less than or equal to 2 years, the dog's age is calculated as `h_age * 10.5`.\n    - For human ages greater than 2 years, the dog's age is calculated as `21 + (h_age - 2) * 4`.\n    - The function accepts any real number as input, including negative and zero values, and extrapolates the dog's age accordingly.\n    - Fractional human ages are supported, and the calculation interpolates dog years for such inputs.\n\n    Examples:\n    assert dog_age(12) == 61\n    assert dog_age(-3) == -31.5\n    \"\"\"\n```", "generated_programs": ["def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/265", "requirement": "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Write a function that takes in a list `S` and a positive integer `step` and splits the list into `step` sublists. \n    Each sublist contains elements from `S` distributed cyclically based on their index modulo `step`. \n    The function returns a list of these sublists.\n\n    Preconditions:\n    - `step` must be a positive integer greater than zero. If `step` is invalid (e.g., zero or negative), the function should raise a `ValueError`.\n\n    Example:\n    assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero.')\n    result = [[] for _ in range(step)]\n    for idx, item in enumerate(S):\n        result[idx % step].append(item)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero.')\n    result = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        result[i % step].append(item)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero')\n    result = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        result[i % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero')\n    sublists = [[] for _ in range(step)]\n    for idx, element in enumerate(S):\n        sublists[idx % step].append(element)\n    return sublists", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('Step must be a positive integer greater than zero.')\n    result = [[] for _ in range(step)]\n    for idx, element in enumerate(S):\n        result[idx % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero.')\n    result = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        result[i % step].append(item)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero.')\n    result = [[] for _ in range(step)]\n    for index, element in enumerate(S):\n        result[index % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero.')\n    result = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        result[i % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero')\n    result = [[] for _ in range(step)]\n    for index, element in enumerate(S):\n        result[index % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero')\n    sublists = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        sublists[i % step].append(element)\n    return sublists"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/271", "requirement": "def even_Power_Sum(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in an integer n and finds the sum of the fifth powers \n    of the first n even natural numbers (i.e., 2, 4, 6, ..., 2n).\n    assert even_Power_Sum(2) == 1056\n    \"\"\"", "generated_programs": ["def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/279", "requirement": "def is_num_decagonal(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the nth decagonal number using the formula: n * (4 * n - 3).\n    A decagonal number is a figurate number that represents a decagon. The nth decagonal number is derived from the formula.\n    Example:\n    assert is_num_decagonal(3) == 27\n    \"\"\"", "generated_programs": ["def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/286", "requirement": "```python\nfrom typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the largest sum of a contiguous subarray in the modified \n    array, which is conceptually formed by repeating the given array `k` times. \n\n    Details:\n    - The function should compute the maximum sum of a contiguous subarray that \n      may span one or more repetitions of the original array `a`. \n    - The explicit formation of the repeated array is not required; the function \n      can use optimized techniques to simulate the effect of repetition without \n      creating the full repeated array in memory.\n    - Cross-boundary subarrays (i.e., subarrays spanning multiple repetitions \n      of the original array) must be considered.\n\n    Input:\n    - `a`: A list of integers representing the original array.\n    - `n`: The length of the array `a`. This parameter is provided for clarity \n      and consistency, but does not need to be computed by the function.\n    - `k`: The number of times the array `a` is conceptually repeated.\n\n    Output:\n    - Returns an integer representing the largest sum of a contiguous subarray \n      within the conceptually repeated array.\n\n    Example:\n    >>> assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    if not a or k == 0:\n        return 0\n    total_sum = sum(a)\n    single_max = kadane(a)\n    if k == 1:\n        return single_max\n    modified_arr = a + a\n    modified_max = kadane(modified_arr)\n    if modified_max > single_max and modified_max > total_sum * k:\n        return modified_max\n    else:\n        return max(single_max, total_sum * k)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    max_kadane = float('-inf')\n    current = 0\n    for num in a:\n        current = max(num, current + num)\n        max_kadane = max(max_kadane, current)\n    if k == 1:\n        return max_kadane\n    total_sum = sum(a)\n    max_prefix = float('-inf')\n    current_prefix = 0\n    for i in range(n):\n        current_prefix += a[i]\n        max_prefix = max(max_prefix, current_prefix)\n    max_suffix = float('-inf')\n    current_suffix = 0\n    for i in range(n - 1, -1, -1):\n        current_suffix += a[i]\n        max_suffix = max(max_suffix, current_suffix)\n    if total_sum > 0:\n        return max(max_kadane, max_prefix + max_suffix + total_sum * (k - 2))\n    else:\n        return max(max_kadane, max_prefix + max_suffix)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    if k == 1:\n        return kadane(a)\n    total_sum = sum(a)\n    max_prefix = max_suffix = current_prefix = current_suffix = 0\n    for i in range(n):\n        current_prefix += a[i]\n        max_prefix = max(max_prefix, current_prefix)\n    for i in range(n - 1, -1, -1):\n        current_suffix += a[i]\n        max_suffix = max(max_suffix, current_suffix)\n    if total_sum > 0:\n        return max(max_prefix + max_suffix + total_sum * (k - 2), kadane(a), max_prefix + max_suffix)\n    else:\n        return max(kadane(a), max_prefix + max_suffix)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    max_prefix = max_suffix = max_current_prefix = max_current_suffix = 0\n    for i in range(n):\n        max_current_prefix += a[i]\n        max_prefix = max(max_prefix, max_current_prefix)\n    for i in range(n - 1, -1, -1):\n        max_current_suffix += a[i]\n        max_suffix = max(max_suffix, max_current_suffix)\n    if total_sum > 0:\n        return max(max_prefix + max_suffix + total_sum * (k - 2), kadane(a))\n    else:\n        return max(max_prefix + max_suffix, kadane(a))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    total_sum = sum(a)\n    max_single = kadane(a)\n    if k == 1:\n        return max_single\n    max_prefix = max_suffix = -float('inf')\n    current_prefix = current_suffix = 0\n    for i in range(n):\n        current_prefix += a[i]\n        max_prefix = max(max_prefix, current_prefix)\n    for i in range(n - 1, -1, -1):\n        current_suffix += a[i]\n        max_suffix = max(max_suffix, current_suffix)\n    if total_sum > 0:\n        return max(max_single, max_prefix + max_suffix + total_sum * (k - 2))\n    else:\n        return max(max_single, max_prefix + max_suffix)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in arr:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    total_sum = sum(a)\n    max_kadane = kadane(a)\n    if k == 1:\n        return max_kadane\n    max_prefix = float('-inf')\n    current_prefix = 0\n    for num in a:\n        current_prefix += num\n        max_prefix = max(max_prefix, current_prefix)\n    max_suffix = float('-inf')\n    current_suffix = 0\n    for num in reversed(a):\n        current_suffix += num\n        max_suffix = max(max_suffix, current_suffix)\n    if total_sum > 0:\n        return max(max_kadane, max_prefix + max_suffix + total_sum * (k - 2))\n    else:\n        return max(max_kadane, max_prefix + max_suffix)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    if k == 1:\n        current_max = a[0]\n        global_max = a[0]\n        for num in a[1:]:\n            current_max = max(num, current_max + num)\n            global_max = max(global_max, current_max)\n        return global_max\n    total_sum = sum(a)\n    kadane_result = max_sub_array_sum_repeated(a, n, 1)\n    prefix_sum = 0\n    suffix_sum = 0\n    current_prefix = 0\n    current_suffix = 0\n    for i in range(n):\n        current_prefix += a[i]\n        prefix_sum = max(prefix_sum, current_prefix)\n    for i in range(n - 1, -1, -1):\n        current_suffix += a[i]\n        suffix_sum = max(suffix_sum, current_suffix)\n    if total_sum > 0:\n        return max(kadane_result, suffix_sum + prefix_sum + total_sum * (k - 2))\n    else:\n        return max(kadane_result, suffix_sum + prefix_sum)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr):\n        max_sum, current_sum = (arr[0], arr[0])\n        for num in arr[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    total_sum = sum(a)\n    if k == 1:\n        return max_sub_array_sum(a)\n    max_prefix_sum = -float('inf')\n    max_suffix_sum = -float('inf')\n    current_prefix_sum = 0\n    current_suffix_sum = 0\n    for i in range(n):\n        current_prefix_sum += a[i]\n        max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n    for i in range(n - 1, -1, -1):\n        current_suffix_sum += a[i]\n        max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n    if total_sum > 0:\n        return max(max_suffix_sum + max_prefix_sum + total_sum * (k - 2), max_sub_array_sum(a))\n    else:\n        return max(max_suffix_sum + max_prefix_sum, max_sub_array_sum(a))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr):\n        max_sum = current_sum = arr[0]\n        for num in arr[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    total_sum = sum(a)\n    single_max = max_sub_array_sum(a)\n    if k == 1:\n        return single_max\n    prefix_max = [0] * n\n    prefix_max[0] = a[0]\n    current = a[0]\n    for i in range(1, n):\n        current += a[i]\n        prefix_max[i] = max(prefix_max[i - 1], current)\n    suffix_max = [0] * n\n    suffix_max[-1] = a[-1]\n    current = a[-1]\n    for i in range(n - 2, -1, -1):\n        current += a[i]\n        suffix_max[i] = max(suffix_max[i + 1], current)\n    if k == 2:\n        return max(single_max, prefix_max[-1] + suffix_max[0])\n    cross_max = prefix_max[-1] + suffix_max[0] + max(0, (k - 2) * total_sum)\n    return max(single_max, cross_max)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    total_sum = sum(a)\n    max_kadane = kadane(a)\n    if k == 1:\n        return max_kadane\n    max_prefix_sum = get_max_prefix_sum(a)\n    max_suffix_sum = get_max_suffix_sum(a)\n    if total_sum > 0:\n        return max(max_kadane, max_suffix_sum + max_prefix_sum + total_sum * (k - 2))\n    else:\n        return max(max_kadane, max_prefix_sum + max_suffix_sum)\n\ndef kadane(arr: List[int]) -> int:\n    max_current = max_global = arr[0]\n    for i in range(1, len(arr)):\n        max_current = max(arr[i], max_current + arr[i])\n        max_global = max(max_global, max_current)\n    return max_global\n\ndef get_max_prefix_sum(arr: List[int]) -> int:\n    max_prefix = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum += num\n        max_prefix = max(max_prefix, current_sum)\n    return max_prefix\n\ndef get_max_suffix_sum(arr: List[int]) -> int:\n    max_suffix = float('-inf')\n    current_sum = 0\n    for num in reversed(arr):\n        current_sum += num\n        max_suffix = max(max_suffix, current_sum)\n    return max_suffix"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.6, "original_passk": 0.7}}
{"task_id": "Mbpp/294", "requirement": "```python\ndef max_val(listval: list) -> int:\n    \"\"\"\n    Write a function to find the maximum numeric value in a given heterogeneous list.\n    The input list may contain elements of mixed types, including integers, floats, strings, or other objects.\n    The function should:\n    1. Filter the list to include only numeric values (integers and floats).\n    2. Compute and return the maximum value from the filtered numeric elements.\n    \n    Constraints:\n    - Only integers and floats are considered for the maximum value calculation.\n    - If the list contains no numeric values, the function will raise a ValueError.\n\n    Example:\n    assert max_val(['Python', 3, 2, 4, 5, 'version']) == 5\n    \"\"\"\n```", "generated_programs": ["def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numeric_values:\n        raise ValueError('No numeric values found in the list.')\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numeric_values:\n        raise ValueError('No numeric values found in the list.')\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numeric_values:\n        raise ValueError('No numeric values found in the list')\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numeric_values:\n        raise ValueError('No numeric values found in the list.')\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numeric_values:\n        raise ValueError('No numeric values found in the list')\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numeric_values:\n        raise ValueError('No numeric values found in the list')\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numeric_values:\n        raise ValueError('No numeric values found in the list')\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numeric_values:\n        raise ValueError('No numeric values found in the list')\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_vals = [x for x in listval if isinstance(x, (int, float))]\n    if not numeric_vals:\n        raise ValueError('No numeric values found in the list')\n    return max(numeric_vals)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numeric_values:\n        raise ValueError('No numeric values found in the list')\n    return max(numeric_values)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/300", "requirement": "def count_binary_seq(n: int) -> int:\n    \"\"\"\n    Write a function to find the count of all binary sequences of length 2n such that the sum of the first n bits is equal to the sum of the last n bits.\n    The function calculates this count by summing the square of combinations for choosing k bits out of n, for all k from 0 to n.\n    assert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(0, n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/301", "requirement": "```python\ndef dict_depth(d: dict) -> int:\n    \"\"\"\n    Write a function to find the depth of a dictionary.\n\n    Depth is defined as the maximum number of levels of nested dictionaries, including the outermost dictionary itself.\n    - The outermost dictionary always contributes a depth of 1, even if it is empty.\n    - If a value of a key in the dictionary is another dictionary, depth increases by 1 recursively for each nested level.\n    - Non-dictionary values do not contribute to depth but do not prevent further exploration of nested dictionaries.\n    - If the input is not a dictionary (e.g., a list, integer, or other data type), the function should return 0 without raising an error.\n    - The function does not handle lists or other non-dictionary structures containing dictionaries; such inputs are treated as invalid and return 0.\n    - The function uses the `max` function with a `default=0` parameter to handle cases where no nested dictionaries are found, ensuring that the depth of an empty dictionary is correctly returned as 1.\n\n    Example:\n    assert dict_depth({'a': 1, 'b': {'c': {'d': {}}}}) == 4\n    \"\"\"\n    pass\n```", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            max_depth = max(max_depth, 1 + dict_depth(value))\n    return max_depth", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            current_depth = dict_depth(value) + 1\n            if current_depth > max_depth:\n                max_depth = current_depth\n    return max_depth", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            current_depth = dict_depth(value) + 1\n            if current_depth > max_depth:\n                max_depth = current_depth\n    return max_depth"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/305", "requirement": "```python\nfrom typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    \"\"\"\n    Write a function that takes a list of strings, where each string may contain multiple words separated by spaces, \n    and returns a tuple containing up to two words that start with the letter 'p' (case-insensitive). \n\n    Requirements:\n    1. The input is a list of strings, where each string may contain multiple words.\n    2. The function should split each string into individual words and check if they start with 'p' or 'P'.\n    3. The function should return a tuple containing the first two words (in the order they appear) that start with 'p' or 'P'.\n    4. If fewer than two such words are found, the function should return a tuple containing all the found words (which may have fewer than two elements).\n    5. If no words starting with 'p' or 'P' are found, the function should return an empty tuple.\n    6. The function should handle an empty input list or strings with no valid 'p'-starting words gracefully, returning an empty tuple in such cases.\n\n    Examples:\n    assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')\n    assert start_withp([\"pencil pen pool apple Python\"]) == ('pencil', 'pen')\n    assert start_withp([\"parking\"]) == ('parking',)\n    assert start_withp([]) == ()\n    assert start_withp([\"Java JavaScript\"]) == ()\n    \"\"\"\n```", "generated_programs": ["from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    result = []\n    for string in words:\n        for word in string.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    p_words = []\n    for s in words:\n        for word in s.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    p_words = []\n    for string in words:\n        for word in string.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n            if len(p_words) == 2:\n                return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    p_words = []\n    for word in words:\n        for w in word.split():\n            if w.lower().startswith('p'):\n                p_words.append(w)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    p_words = []\n    for s in words:\n        for word in s.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    p_words = []\n    for string in words:\n        for word in string.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    p_words = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, ...]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum of an increasing subsequence from the prefix of the array up to the ith index (`index`), \n    and then include the value of the kth element (`a[k]`) in the sum, where `k > index`. \n\n    The subsequence must satisfy the following conditions:\n    1. The subsequence is formed using elements from the prefix of the array up to `index` (inclusive).\n    2. The subsequence must be strictly increasing during its construction, meaning each element added to the subsequence must be greater than the previous element.\n    3. All elements in the subsequence must be strictly less than the value of the kth element (`a[k]`).\n    4. The kth element (`a[k]`) is added to the maximum sum of the valid subsequence after its construction.\n\n    Edge case handling:\n    - If the array `a` is empty or if `index >= n` or `k >= n` or `k <= index`, the function should raise an `IndexError`.\n    - If no valid subsequence can be formed (i.e., no elements in the prefix satisfy the conditions), the function should return the value of `a[k]` as the result.\n\n    The function returns the maximum sum of the valid subsequence plus the value of the kth element.\n\n    Example:\n    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    \"\"\"", "generated_programs": ["code\nfrom typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise IndexError('Invalid index or array length')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        if a[i] >= a[k]:\n            continue\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i] and dp[j] + a[i] > dp[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = max(dp)\n    if max_sum == 0:\n        return a[k]\n    else:\n        return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise IndexError\n    prefix = a[:index + 1]\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = prefix[i]\n        for j in range(i):\n            if prefix[j] < prefix[i] and prefix[i] < a[k]:\n                dp[i] = max(dp[i], dp[j] + prefix[i])\n    max_sum = max([x for x in dp if x < a[k]], default=0)\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise IndexError\n    last_element = a[k]\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        if a[i] >= last_element:\n            continue\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i] and a[i] < last_element:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = max(dp) if any(dp) else 0\n    return max_sum + last_element", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise IndexError('Invalid indices provided.')\n    prefix = a[:index + 1]\n    target = a[k]\n    dp = [x if x < target else 0 for x in prefix]\n    for i in range(len(prefix)):\n        if prefix[i] >= target:\n            continue\n        for j in range(i):\n            if prefix[j] < prefix[i] and dp[j] != 0:\n                dp[i] = max(dp[i], dp[j] + prefix[i])\n    max_sum = max(dp) if max(dp) > 0 else 0\n    return max_sum + target", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise IndexError\n    prefix = a[:index + 1]\n    target = a[k]\n    dp = [0] * len(prefix)\n    for i in range(len(prefix)):\n        if prefix[i] < target:\n            dp[i] = prefix[i]\n            for j in range(i):\n                if prefix[j] < prefix[i] and prefix[i] < target:\n                    dp[i] = max(dp[i], dp[j] + prefix[i])\n    max_sum = max(dp, default=0)\n    return max_sum + target", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise IndexError('Invalid index or array size.')\n    dp = [0] * (index + 1)\n    max_sum = 0\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i] and a[i] < a[k]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n        max_sum = max(max_sum, dp[i])\n    if max_sum == 0:\n        return a[k]\n    else:\n        return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise IndexError('Invalid indices or empty array')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i] and a[j] < a[k]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = max(dp) if dp else 0\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise IndexError\n    if index < 0:\n        return a[k]\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i] and a[i] < a[k]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = max([val for val in dp if val < a[k]], default=0)\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise IndexError\n    prefix = a[:index + 1]\n    target = a[k]\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        if prefix[i] < target:\n            dp[i] = prefix[i]\n            for j in range(i):\n                if prefix[j] < prefix[i] and dp[j] + prefix[i] > dp[i]:\n                    dp[i] = dp[j] + prefix[i]\n    max_sum = max(dp) if any((v > 0 for v in dp)) else 0\n    return max_sum + target", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if not a or index >= n or k >= n or (k <= index):\n        raise IndexError('Invalid index or array size')\n    if index < 0 or k < 0:\n        raise IndexError('Invalid index')\n    dp = [0] * (index + 1)\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] >= a[k]:\n            dp[i] = 0\n            continue\n        current_max = 0\n        for j in range(i):\n            if a[j] < a[i] and dp[j] > current_max:\n                current_max = dp[j]\n        dp[i] = current_max + a[i]\n        if dp[i] > max_sum:\n            max_sum = dp[i]\n    return max_sum + a[k] if max_sum != 0 else a[k]"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.6, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/308", "requirement": "```python\nfrom typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest products from two given lists, \n    where each product is obtained by multiplying one factor from each list. \n\n    The results must be returned as a list sorted in descending order. \n    Duplicates in the result must be included if they correspond to distinct combinations \n    of factors from the two lists. For example, if two distinct pairs of numbers produce \n    the same product, both occurrences must be included in the output.\n\n    The function must compute the top `N` largest products, sorted in descending order, \n    after considering all possible products. If `N` exceeds the total number of possible \n    products, the function must return all products (including duplicates from distinct \n    combinations), sorted in descending order. If `N = 0`, the function must return an \n    empty list.\n\n    Efficiency considerations are optional; the function may use optimized approaches \n    (e.g., heap-based methods) or exhaustive computation as long as the output satisfies \n    the requirements.\n\n    Edge cases:\n    - If `N = 0`, return an empty list.\n    - If `N` exceeds the total number of possible products, return all products, sorted \n      in descending order.\n\n    Example:\n    assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    \"\"\"\n```", "generated_programs": ["from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, num1 * num2)\n            if len(products) > N:\n                heapq.heappop(products)\n    return sorted(products, reverse=True)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    products.sort(reverse=True)\n    return products[:N] if N <= len(products) else products", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    heapq.heapify(products)\n    result = []\n    for _ in range(min(N, len(products))):\n        result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, num1 * num2)\n            if len(products) > N:\n                heapq.heappop(products)\n    return sorted(products, reverse=True)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    heapq.heapify(products)\n    result = []\n    for _ in range(min(N, len(products))):\n        result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, -(num1 * num2))\n    result = []\n    for _ in range(min(N, len(products))):\n        result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    heapq.heapify(products)\n    result = []\n    for _ in range(min(N, len(products))):\n        result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, -(num1 * num2))\n    result = []\n    for _ in range(min(N, len(products))):\n        result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-num1 * num2)\n    heapq.heapify(products)\n    result = []\n    for _ in range(min(N, len(products))):\n        result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    heapq.heapify(products)\n    result = []\n    for _ in range(min(N, len(products))):\n        result.append(-heapq.heappop(products))\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/310", "requirement": "```python\ndef string_to_tuple(str1: str) -> tuple:\n    \"\"\"\n    Write a function to convert a given string to a tuple of characters, excluding spaces (' ').\n    The function should iterate through each character in the input string and include only non-space characters in the resulting tuple.\n\n    Example:\n    assert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n    \"\"\"\n```", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "```python\ndef set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the left-most unset bit in the binary representation of a given integer `n`.\n\n    - The function operates within the binary representation of `n` as determined by its `bit_length()`.\n    - An \"unset bit\" is defined as a bit position where the value is `0` in the binary representation of `n`.\n    - The \"left-most unset bit\" is the highest positional bit (most significant bit) that is unset within the binary representation of `n`.\n\n    Behavior:\n    1. If `n` is `-1` (all bits are set in a signed integer), the function returns `n` unchanged.\n    2. If `n` is `0` (all bits are unset), the function sets the least significant bit (position 0) and returns `1`.\n    3. For positive integers, the function identifies the left-most unset bit within the binary representation of `n` and sets it.\n    4. The function does not consider bits beyond the current `bit_length()` of `n` and does not assume an infinite bit domain.\n\n    Examples:\n    - assert set_left_most_unset_bit(10) == 14\n    - assert set_left_most_unset_bit(0) == 1\n    - assert set_left_most_unset_bit(-1) == -1\n    \"\"\"\n```", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = 1 << bit_length - 1\n    while mask:\n        if not n & mask:\n            return n | mask\n        mask >>= 1\n    return n | 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = 1 << bit_length - 1\n    while mask:\n        if not n & mask:\n            return n | mask\n        mask >>= 1\n    return n | 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = 1 << bit_length - 1\n    while mask:\n        if not n & mask:\n            return n | mask\n        mask >>= 1\n    return n | 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = 1 << bit_length - 1\n    while mask > 0:\n        if n & mask == 0:\n            return n | mask\n        mask >>= 1\n    return n | 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = 1 << bit_length - 1\n    while mask > 0:\n        if not n & mask:\n            return n | mask\n        mask >>= 1\n    return n | 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = 1 << bit_length - 1\n    while mask and n & mask:\n        mask >>= 1\n    if not mask:\n        return n\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = 1 << bit_length - 1\n    while mask > 0:\n        if n & mask == 0:\n            return n | mask\n        mask >>= 1\n    return n | 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = 1 << bit_length - 1\n    while mask > 0:\n        if n & mask == 0:\n            return n | mask\n        mask >>= 1\n    return n | 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/388", "requirement": "def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the highest power of 2 that is less than or equal to a given positive integer `n`.\n\n    Constraints:\n    - The input `n` must be a positive integer (`n > 0`).\n    - If `n` is zero or negative, the function must raise a `ValueError`.\n\n    Examples:\n    assert highest_Power_of_2(10) == 8\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [-5]\n    Expected Output: ['ValueError']\n    ### Test 2\n    Input: [0]\n    Expected Output: ['ValueError']\n    ### Test 3\n    Input: [0]\n    Expected Output: ['ValueError']\n    \"\"\"", "generated_programs": ["import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    return 2 ** int(math.log2(n))", "import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    return 2 ** (n.bit_length() - 1)", "import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    return 2 ** (n.bit_length() - 1)", "import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    return 2 ** int(math.log2(n))", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError\n    power = 0\n    while 1 << power + 1 <= n:\n        power += 1\n    return 1 << power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError\n    power = 0\n    while 1 << power <= n:\n        power += 1\n    return 1 << power - 1", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/389", "requirement": "```python\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th Lucas number.\n\n    The Lucas sequence is defined as:\n    - L(0) = 2\n    - L(1) = 1\n    - L(n) = L(n-1) + L(n-2) for n > 1\n\n    Requirements:\n    1. **Valid input range:**\n       - The input `n` must be an integer.\n       - If `n` is non-negative, the function computes the Lucas number at position `n` in the sequence.\n       - If `n` is negative, the function returns `1` as a special case.\n\n    2. **Behavior for invalid inputs:**\n       - If the input is not an integer, the function should raise a `TypeError`.\n\n    3. **Implementation approach:**\n       - The function should use an iterative approach to compute the Lucas sequence for better performance.\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [-1]\n    Expected Output: [1]\n\n    ### Test 2\n    Input: [9]\n    Expected Output: [76]\n\n    assert find_lucas(9) == 76\n    \"\"\"\n```", "generated_programs": ["def find_lucas(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return 1\n    a, b = (2, 1)\n    for _ in range(n):\n        a, b = (b, a + b)\n    return a", "def find_lucas(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    prev, curr = (2, 1)\n    for _ in range(2, n + 1):\n        prev, curr = (curr, prev + curr)\n    return curr", "def find_lucas(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/392", "requirement": "def get_max_sum(n: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Requirements:\n    1. The function is defined for non-negative integers only (n >= 0). Negative input values are considered invalid and will result in undefined behavior.\n    2. The base case is explicitly defined as: if n == 0, the function must return 0.\n    3. For positive integers (n > 0), the function recursively computes the maximum sum using the given equation.\n    4. The function does not handle negative inputs explicitly; passing negative values may lead to a RecursionError due to unbounded recursion.\n\n    Example:\n    assert get_max_sum(60) == 106\n    \"\"\"", "generated_programs": ["def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    f_n2 = get_max_sum(n // 2)\n    f_n3 = get_max_sum(n // 3)\n    f_n4 = get_max_sum(n // 4)\n    f_n5 = get_max_sum(n // 5)\n    return max(f_n2 + f_n3 + f_n4 + f_n5, n)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/410", "requirement": "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    \"\"\"\n    Write a function to find the minimum integer value in a given heterogeneous list.\n    \n    The function should:\n    - Only consider integers in the list when determining the minimum value.\n    - Raise a ValueError if the list is empty or if it contains no integers.\n    \n    Examples:\n    assert min_val(['Python', 3, 2, 4, 5, 'version']) == 2\n    \n    Edge cases:\n    - Input: [] (an empty list)\n      Expected Output: ValueError\n    - Input: ['Python', 'version'] (a list with no integers)\n      Expected Output: ValueError\n    \"\"\"", "generated_programs": ["from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    int_values = [x for x in listval if isinstance(x, int)]\n    if not int_values:\n        raise ValueError('The list is empty or contains no integers.')\n    return min(int_values)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('The list is empty or contains no integers.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('The list is empty or contains no integers.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('List is empty or contains no integers.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list or the list is empty.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('The list is either empty or contains no integers.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list or the list is empty.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('The list is empty or contains no integers.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list or the list is empty.')\n    return min(integers)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/415", "requirement": "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Write a Python function to find a pair of integers from a given array that produces the numerically largest product. \n    The function should adhere to the following rules:\n    \n    1. If the input array has fewer than two elements, return the default value `(0, 0)`.\n    2. Negative numbers are valid candidates for the pair, and the function should consider their product when determining the numerically largest product.\n    3. The order of the pair in the output should match the order in which the integers appear in the input array.\n    4. The function should iterate through all possible pairs without sorting the input array.\n    5. The input array may include zeros, duplicate values, and both positive and negative integers.\n    6. If there are multiple pairs with the same maximum product, return the first pair encountered during iteration.\n    7. The function maximizes the numeric product, not the absolute product.\n\n    Example:\n    assert max_Product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = -float('inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_product = None\n    result_pair = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            if max_product is None or product > max_product:\n                max_product = product\n                result_pair = (arr[i], arr[j])\n    return result_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (0, 0)\n    max_product = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_product = arr[i] * arr[j]\n            if current_product > max_product:\n                max_product = current_product\n                max_pair = (arr[i], arr[j])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_product = -float('inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (arr[0], arr[1])\n    max_product = arr[0] * arr[1]\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_product = arr[i] * arr[j]\n            if current_product > max_product:\n                max_product = current_product\n                max_pair = (arr[i], arr[j])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (arr[0], arr[1])\n    max_product = arr[0] * arr[1]\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_product = arr[i] * arr[j]\n            if current_product > max_product:\n                max_product = current_product\n                max_pair = (arr[i], arr[j])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (arr[0], arr[1])\n    max_product = arr[0] * arr[1]\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_product = arr[i] * arr[j]\n            if current_product > max_product:\n                max_product = current_product\n                max_pair = (arr[i], arr[j])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (arr[0], arr[1])\n    max_product = arr[0] * arr[1]\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_product = arr[i] * arr[j]\n            if current_product > max_product:\n                max_product = current_product\n                max_pair = (arr[i], arr[j])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (arr[0], arr[1])\n    max_product = arr[0] * arr[1]\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_product = arr[i] * arr[j]\n            if current_product > max_product:\n                max_product = current_product\n                max_pair = (arr[i], arr[j])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = float('-inf')\n    result_pair = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result_pair = (arr[i], arr[j])\n    return result_pair"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/418", "requirement": "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    \"\"\"\n    Write a Python function to find the sublist within a list of lists that has the maximum length.\n    \n    - The input `lst` is expected to be a list of lists of strings (`List[List[str]]`).\n    - If the input list `lst` is empty, the function should raise a `ValueError`.\n    - The function should return the sublist with the maximum length if the input list is non-empty.\n    \n    Example:\n    assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list cannot be empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('The input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list cannot be empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list cannot be empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('The input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('The input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('The input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list cannot be empty')\n    max_sublist = max(lst, key=len)\n    return max_sublist"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/427", "requirement": "```python\ndef change_date_format(dt: str) -> str:\n    \"\"\"\n    Write a function to convert a date string from yyyy-mm-dd format to dd-mm-yyyy format.\n    \n    Requirements:\n    1. The input `dt` is assumed to be a string strictly adhering to the `yyyy-mm-dd` format with hyphen (`-`) delimiters.\n       - The function does not validate the input for correctness, structure, or adherence to calendar dates.\n       - Inputs that do not conform to the `yyyy-mm-dd` format (e.g., `2023/06/15`) will not be processed correctly and may produce unexpected outputs.\n    \n    2. The function performs string manipulation only:\n       - It splits the input string by `-` characters, reverses the order of the resulting segments, and rejoins them using `-` as the delimiter.\n       - The function does not validate the output or ensure it conforms to a valid date format.\n    \n    3. Invalid or non-existent dates (e.g., `1900-02-29`) are treated as plain strings and processed without raising errors.\n    \n    Examples:\n    assert change_date_format(\"2026-01-02\") == '02-01-2026'\n    assert change_date_format(\"1900-02-29\") == '29-02-1900'\n    assert change_date_format(\"2023/06/15\") == '2023/06/15'\n    \"\"\"\n    return '-'.join(dt.split('-')[::-1])\n```", "generated_programs": ["def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "```python\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find the directrix of a parabola using the formula:\n    directrix = -((b ** 2 + 1) // (4 * a))\n    \n    The function takes three integer parameters:\n    - a: The coefficient of the quadratic term in the parabola equation.\n    - b: The coefficient of the linear term in the parabola equation.\n    - c: The constant term in the parabola equation (included in the signature but not used in the calculation).\n\n    Notes:\n    - The formula explicitly applies negation to the result of the division operation, not just the numerator.\n    - Ensure `a` is non-zero to avoid division by zero errors. If `a == 0`, the function must raise a `ValueError` with the message: \"Coefficient 'a' must be non-zero to avoid division by zero.\"\n    - The parameter `c` is included for consistency with the general form of a parabola equation but does not influence the calculation.\n    - The expected output for the given example is based on the formula provided.\n\n    Example:\n    assert parabola_directrix(5, 3, 2) == -198\n    \"\"\"\n```", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero to avoid division by zero.\")\n    return -((b ** 2 + 1) // (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero to avoid division by zero.\")\n    return -((b ** 2 + 1) // (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero to avoid division by zero.\")\n    return -((b ** 2 + 1) // (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero to avoid division by zero.\")\n    return -((b ** 2 + 1) // (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero to avoid division by zero.\")\n    return -((b ** 2 + 1) // (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero to avoid division by zero.\")\n    directrix = -((b ** 2 + 1) // (4 * a))\n    return directrix", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero to avoid division by zero.\")\n    return -((b ** 2 + 1) // (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero to avoid division by zero.\")\n    directrix = -((b ** 2 + 1) // (4 * a))\n    return directrix", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero to avoid division by zero.\")\n    directrix = -((b ** 2 + 1) // (4 * a))\n    return directrix", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero to avoid division by zero.\")\n    directrix = -((b ** 2 + 1) // (4 * a))\n    return directrix"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/435", "requirement": "def last_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the last digit of a given number. \n    The input `n` can be positive or negative. The \"last digit\" is defined as the absolute value of the rightmost digit of the number, ignoring the sign. \n    The function should always return a non-negative single-digit integer between 0 and 9.\n\n    Examples:\n    assert last_Digit(123) == 3\n    assert last_Digit(-456) == 6\n    \"\"\"", "generated_programs": ["def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/448", "requirement": "```python\ndef cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of Perrin numbers up to the nth index.\n\n    The Perrin sequence is defined as:\n    P(0) = 3, P(1) = 0, P(2) = 2, and for n >= 3, P(n) = P(n-2) + P(n-3).\n\n    The function should:\n    - Return the sum of all Perrin numbers from index 0 to n (inclusive), explicitly including the value at index n, when n >= 0.\n    - For example, if n = 1, the sum is P(0) + P(1), and if n = 3, the sum is P(0) + P(1) + P(2) + P(3).\n    - Return 0 for negative values of n, as the sum of an empty sequence is 0.\n\n    Examples:\n    assert cal_sum(9) == 49\n    assert cal_sum(-1) == 0\n    assert cal_sum(1) == 3\n    assert cal_sum(0) == 3\n    \"\"\"\n```", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    p = [3, 0, 2]\n    if n < 3:\n        return sum(p[:n + 1])\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    p = [3, 0, 2]\n    if n < 3:\n        return sum(p[:n + 1])\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    p = [3, 0, 2]\n    if n < 3:\n        return sum(p[:n + 1])\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    p = [3, 0, 2]\n    if n < 3:\n        return sum(p[:n + 1])\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    perrin = [3, 0, 2]\n    if n < 3:\n        return sum(perrin[:n + 1])\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    a, b, c = (3, 0, 2)\n    if n == 0:\n        return a\n    elif n == 1:\n        return a + b\n    elif n == 2:\n        return a + b + c\n    total = a + b + c\n    for _ in range(3, n + 1):\n        d = b + a\n        total += d\n        a, b, c = (b, c, d)\n    return total", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [0] * (n + 1)\n    p[0], p[1], p[2] = (3, 0, 2)\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    p = [0] * (n + 1)\n    p[0] = 3\n    if n >= 1:\n        p[1] = 0\n    if n >= 2:\n        p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/450", "requirement": "def extract_string(str1: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract strings from a given list of string values where the length of each string matches the specified size.\n    assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/451", "requirement": "def remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all types of whitespace characters from the given string.\n    Whitespace characters include spaces (' '), tabs ('\\t'), newlines ('\\n'), carriage returns ('\\r'), and other characters defined as whitespace by Python's `str.split()` method.\n\n    Examples:\n    - Input: ' Google    Flutter '\n      Output: 'GoogleFlutter'\n    - Input: 'A\\tB\\nC'\n      Output: 'ABC'\n    - Input: 'Special\\tCharacters\\nInWhitespace'\n      Output: 'SpecialCharactersInWhitespace'\n\n    assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'\n    \"\"\"", "generated_programs": ["def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if the input text contains at least one distinct word with the lowercase letter 'z'.\n    \n    A \"word\" is defined as a sequence of alphanumeric characters (letters and digits) bounded by non-alphanumeric characters or text boundaries (e.g., spaces, punctuation, or line breaks). \n    The function should:\n    - Match whole words containing one or more occurrences of the lowercase letter 'z'.\n    - Respect case sensitivity, meaning only lowercase 'z' is considered a match.\n    - Ignore surrounding punctuation or spaces when identifying valid words.\n    - Return True if at least one valid word containing 'z' is found; otherwise, return False.\n\n    Example:\n    assert text_match_wordz(\"pythonz.\") == True\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    return any(('z' in word for word in words))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    return any(('z' in word for word in words))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    return any(('z' in word for word in words))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    return any(('z' in word for word in words))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    return any(('z' in word for word in words))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word:\n            return True\n    return False", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    return any(('z' in word for word in words))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word:\n            return True\n    return False", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word:\n            return True\n    return False", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word:\n            return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/457", "requirement": "```python\nfrom typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a Python function that takes a list of sublists (`lst`) as input and returns the sublist with the minimum length. \n    If multiple sublists have the same minimum length, return the first occurrence among those sublists.\n    \n    Edge cases:\n    - If `lst` is an empty list, the function should return an empty list (`[]`).\n    - Sublists can contain elements of any type (`Any`), and the comparison is solely based on length.\n\n    Example:\n    assert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]\n    assert Find_Min([]) == []\n    \"\"\"\n```", "generated_programs": ["from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    return min(lst, key=len)", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    return min(lst, key=len)", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_len = len(lst[0])\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    for sublist in lst:\n        if len(sublist) == min_length:\n            return sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_len = min((len(sublist) for sublist in lst))\n    for sublist in lst:\n        if len(sublist) == min_len:\n            return sublist\n    return []", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_len = min((len(sublist) for sublist in lst))\n    for sublist in lst:\n        if len(sublist) == min_len:\n            return sublist\n    return []", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_len = len(lst[0])\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_length = len(lst[0])\n    min_sublist = lst[0]\n    for sublist in lst[1:]:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_length = len(lst[0])\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_len = len(lst[0])\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_sublist = sublist\n    return min_sublist"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/460", "requirement": "```python\nfrom typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a Python function to get the first element of each sublist. \n    The function assumes that all sublists in the input are non-empty. \n    If an empty sublist is encountered, the function will raise an IndexError \n    as a consequence of attempting to access the first element of an empty list. \n    The function does not explicitly validate the input for empty sublists; \n    it relies on Python's natural error mechanism to handle such cases.\n\n    Example:\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \"\"\"\n```", "generated_programs": ["from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/462", "requirement": "def combinations_list(lst: List[str]) -> List[List[str]]:\n    \"\"\"\n    Write a function to find all possible subsets (combinations) of the elements of a given list.\n    The function should generate subsets incrementally by appending elements in the order they appear in the input list.\n    The subsets must be ordered as follows:\n    - Start with the empty subset.\n    - For each element in the input list, generate new subsets by prepending the element to all previously generated subsets, maintaining the order of elements as they appear in the input list.\n    - Continue this process until all elements have been processed.\n\n    Input:\n    - A list of strings `lst` (e.g., ['orange', 'red', 'green', 'blue']).\n\n    Output:\n    - A list of lists, where each inner list represents a subset of the input list, ordered as described above.\n\n    Example:\n    assert combinations_list(['orange', 'red', 'green', 'blue']) == [\n        [], \n        ['orange'], \n        ['red'], \n        ['red', 'orange'], \n        ['green'], \n        ['green', 'orange'], \n        ['green', 'red'], \n        ['green', 'red', 'orange'], \n        ['blue'], \n        ['blue', 'orange'], \n        ['blue', 'red'], \n        ['blue', 'red', 'orange'], \n        ['blue', 'green'], \n        ['blue', 'green', 'orange'], \n        ['blue', 'green', 'red'], \n        ['blue', 'green', 'red', 'orange']\n    ]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = [[]]\n    for i in range(len(lst)):\n        for j in range(len(result)):\n            result.append([lst[i]] + result[j])\n    return result", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = [[]]\n    for element in lst:\n        new_subsets = []\n        for subset in result:\n            new_subsets.append([element] + subset)\n        result.extend(new_subsets)\n    return result", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = [[]]\n    for i in range(len(lst)):\n        current_element = lst[i]\n        temp = [subset + [current_element] for subset in result]\n        result.extend(temp)\n    return result", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    subsets = [[]]\n    for element in lst:\n        new_subsets = []\n        for subset in subsets:\n            new_subsets.append([element] + subset)\n        subsets += new_subsets\n    return subsets", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = [[]]\n    for i in range(len(lst)):\n        current = []\n        for subset in result:\n            current.append([lst[i]] + subset)\n        result.extend(current)\n    return result", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = [[]]\n    for element in lst:\n        new_subsets = []\n        for subset in result:\n            new_subsets.append([element] + subset)\n        result += new_subsets\n    return result", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = [[]]\n    for element in lst:\n        new_subsets = []\n        for subset in result:\n            new_subsets.append([element] + subset)\n        result.extend(new_subsets)\n    return result", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    subsets = [[]]\n    for item in lst:\n        new_subsets = [subset + [item] for subset in subsets]\n        subsets += new_subsets\n    return subsets", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = [[]]\n    for element in lst:\n        new_subsets = []\n        for subset in result:\n            new_subsets.append([element] + subset)\n        result.extend(new_subsets)\n    return result", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = [[]]\n    for element in lst:\n        current_length = len(result)\n        for i in range(current_length):\n            new_subset = [element] + result[i]\n            result.append(new_subset)\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.8, "original_passk": 0.0}}
{"task_id": "Mbpp/463", "requirement": "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product subarray of the given array.\n\n    The function should adhere to the following specifications:\n    1. A subarray is defined as a contiguous portion of the array, and the function should return the maximum product of any such subarray.\n    2. Zeros in the array should be treated as valid subarray elements. If a zero is encountered, it can either terminate a subarray or be considered as a subarray itself with a product of zero. The function should handle zeros without resetting the accumulation process entirely.\n    3. For single-element arrays, the output should simply be the value of the single element, as the single element itself constitutes the only valid subarray.\n    4. For arrays containing only negative numbers or zeros, the function should still compute the maximum product subarray by considering the properties of negative numbers (e.g., the product of two negative numbers is positive) and zeros.\n    5. The initial value of the maximum product (`max_product`) should be set to the first element of the array (`arr[0]`), ensuring consistent behavior for arrays of all sizes and compositions.\n\n    Example:\n    assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "code\nfrom typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "code\nfrom typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "Mbpp/465", "requirement": "```python\ndef drop_empty(dict1: dict) -> dict:\n    \"\"\"\n    Write a function to drop items from a given dictionary where the value is strictly `None`.\n    Only keys with values equal to `None` should be removed. All other values, including falsy values \n    such as empty strings (`''`), `0`, `False`, or empty lists (`[]`), should be retained.\n\n    Examples:\n    assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None}) == {'c1': 'Red', 'c2': 'Green'}\n    assert drop_empty({'c1': '', 'c2': None, 'c3': 'Blue'}) == {'c1': '', 'c3': 'Blue'}\n    \"\"\"\n```", "generated_programs": ["def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/468", "requirement": "```python\nfrom typing import List\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product formed by multiplying numbers of a strictly increasing subsequence of the array.\n\n    - A \"strictly increasing subsequence\" is defined as any subset of the array (not necessarily contiguous) where the numbers are in strictly increasing order, and the relative order of elements in the original array is preserved.\n    - Single elements are considered valid strictly increasing subsequences.\n    - The function should maximize the product of the selected numbers in the subsequence, prioritizing the overall maximum product regardless of the subsequence length.\n    - If the array is empty, the function should return 0.\n    - If no strictly increasing subsequence exists, the function should return the maximum product of a single element in the array (or 0 if the array is empty).\n\n    Example:\n    assert max_product([3, 100, 4, 5, 150, 6]) == 3000\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [num for num in arr]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [num for num in arr]\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp, default=0)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [num for num in arr]\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp) if max(dp) > 0 else 0", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [arr[i] for i in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [num for num in arr]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp, default=0)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [num for num in arr]\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp) if max(dp) > 0 else 0", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    max_prod = [arr[i] for i in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                if max_prod[j] * arr[i] > max_prod[i]:\n                    max_prod[i] = max_prod[j] * arr[i]\n    return max(max_prod) if max(max_prod) > 0 else max(arr)", "from typing import List\nimport heapq\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = float('-inf')\n    heap = []\n    for num in arr:\n        current_max = num\n        for prev in heap:\n            if prev[1] < num:\n                current_max = max(current_max, num * prev[1])\n        heapq.heappush(heap, (-current_max, num))\n        if -heap[0][0] > max_prod:\n            max_prod = -heap[0][0]\n    return max(max_prod, max(arr)) if max_prod != float('-inf') else 0", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    product = [arr[i] for i in range(n)]\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                if dp[i] < dp[j] + 1:\n                    dp[i] = dp[j] + 1\n                    product[i] = product[j] * arr[i]\n                elif dp[i] == dp[j] + 1:\n                    product[i] = max(product[i], product[j] * arr[i])\n    if not any((dp[i] > 1 for i in range(n))):\n        return max(arr)\n    return max(product)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    prod = [num for num in arr]\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                if dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prod[i] = prod[j] * arr[i]\n                elif dp[j] + 1 == dp[i]:\n                    prod[i] = max(prod[i], prod[j] * arr[i])\n    if not any((dp[i] > 1 for i in range(n))):\n        return max(arr) if arr else 0\n    return max(prod)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/472", "requirement": "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given list contains consecutive numbers or not.\n\n    The function should adhere to the following rules:\n    1. The input list must contain only integers. If the list contains non-integer elements, the function should raise a `TypeError`.\n    2. An empty list (`[]`) is considered invalid input, and the function should raise a `ValueError`.\n    3. A list is considered to contain consecutive numbers if:\n       - The numbers can be arranged in a strictly sequential order without any gaps.\n       - The list does not contain duplicate values.\n       - The range of numbers in the list matches the range from the minimum value to the maximum value in the list.\n\n    Examples:\n    - `check_Consecutive([1, 2, 3, 4, 5])` should return `True` because the list contains consecutive numbers.\n    - `check_Consecutive([1, 2, 2, 3])` should return `False` because the list contains duplicate values.\n    - `check_Consecutive([])` should raise a `ValueError` because an empty list is invalid input.\n    - `check_Consecutive([1, 3, 4])` should return `False` because the numbers are not consecutive.\n\n    assert check_Consecutive([1, 2, 3, 4, 5]) == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    if not all((isinstance(x, int) for x in l)):\n        raise TypeError('List contains non-integer elements.')\n    if len(l) != len(set(l)):\n        return False\n    min_val, max_val = (min(l), max(l))\n    return max_val - min_val == len(l) - 1", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Input list cannot be empty.')\n    if not all((isinstance(x, int) for x in l)):\n        raise TypeError('Input list must contain only integers.')\n    sorted_l = sorted(l)\n    if len(sorted_l) != len(set(sorted_l)):\n        return False\n    return sorted_l[-1] - sorted_l[0] + 1 == len(sorted_l)", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    if not all((isinstance(x, int) for x in l)):\n        raise TypeError('List contains non-integer elements.')\n    unique_sorted = sorted(set(l))\n    if len(unique_sorted) != len(l):\n        return False\n    return unique_sorted == list(range(min(unique_sorted), max(unique_sorted) + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('The list is empty.')\n    if not all((isinstance(x, int) for x in l)):\n        raise TypeError('The list contains non-integer elements.')\n    if len(l) != len(set(l)):\n        return False\n    min_val = min(l)\n    max_val = max(l)\n    return max_val - min_val == len(l) - 1", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    if not all((isinstance(x, int) for x in l)):\n        raise TypeError('List contains non-integer elements.')\n    if len(set(l)) != len(l):\n        return False\n    min_val = min(l)\n    max_val = max(l)\n    return max_val - min_val == len(l) - 1", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    if not all((isinstance(x, int) for x in l)):\n        raise TypeError('List must contain only integers.')\n    if len(l) != len(set(l)):\n        return False\n    min_val = min(l)\n    max_val = max(l)\n    return max_val - min_val == len(l) - 1", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if len(l) == 0:\n        raise ValueError('Empty list is invalid input.')\n    if not all((isinstance(x, int) for x in l)):\n        raise TypeError('List must contain only integers.')\n    if len(set(l)) != len(l):\n        return False\n    sorted_l = sorted(l)\n    return sorted_l[-1] - sorted_l[0] == len(sorted_l) - 1", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    if not all((isinstance(x, int) for x in l)):\n        raise TypeError('List must contain only integers.')\n    unique_sorted = sorted(set(l))\n    if len(unique_sorted) != len(l):\n        return False\n    return unique_sorted[-1] - unique_sorted[0] == len(unique_sorted) - 1", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not all((isinstance(x, int) for x in l)):\n        raise TypeError('The list contains non-integer elements.')\n    if not l:\n        raise ValueError('The list is empty.')\n    if len(l) != len(set(l)):\n        return False\n    min_val = min(l)\n    max_val = max(l)\n    expected_range = set(range(min_val, max_val + 1))\n    actual_set = set(l)\n    return expected_range == actual_set", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not isinstance(l, list):\n        raise TypeError('Input must be a list.')\n    if not l:\n        raise ValueError('List cannot be empty.')\n    if not all((isinstance(x, int) for x in l)):\n        raise TypeError('List must contain only integers.')\n    unique_sorted = sorted(set(l))\n    if len(unique_sorted) != len(l):\n        return False\n    return unique_sorted == list(range(unique_sorted[0], unique_sorted[-1] + 1))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/473", "requirement": "```python\nfrom typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    \"\"\"\n    Write a function to find the intersection of tuples from two lists of tuples, \n    treating tuples as equivalent if their elements match irrespective of order. \n    The function should normalize each tuple by sorting its elements, ensuring that \n    tuples like (4, 5) and (5, 4) are treated as identical. The output should be a \n    set of tuples, preserving the tuple structure and order of elements within each \n    tuple as determined by the normalization process.\n\n    Additional clarifications:\n    1. Input tuples are assumed to have consistent sizes, and the function will \n       normalize each tuple by sorting its elements.\n    2. Duplicate tuples in the input lists are treated as a single instance for \n       the purpose of intersection.\n    3. The output is a set of tuples, where each tuple is normalized (sorted) \n       and represents a unique intersection of the input lists.\n\n    Example:\n    assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , \n                              [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}\n    \"\"\"\n```", "generated_programs": ["from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1 & set2", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1 & set2", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1 & set2", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_set1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_set2 = {tuple(sorted(t)) for t in test_list2}\n    return normalized_set1.intersection(normalized_set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_set1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_set2 = {tuple(sorted(t)) for t in test_list2}\n    return normalized_set1.intersection(normalized_set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalize = lambda tuples: {tuple(sorted(t)) for t in tuples}\n    set1 = normalize(test_list1)\n    set2 = normalize(test_list2)\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n\n    def normalize(tuples_list):\n        return {tuple(sorted(t)) for t in tuples_list}\n    set1 = normalize(test_list1)\n    set2 = normalize(test_list2)\n    return set1.intersection(set2)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/476", "requirement": "```python\nfrom typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of the largest and smallest values in a given list of integers.\n\n    Requirements:\n    1. The input `nums` must be a list of integers.\n    2. If the input list `nums` is empty, the function should raise a `ValueError`.\n    3. The function will return the sum of the largest and smallest integers in the list.\n\n    Example:\n    assert big_sum([1, 2, 3]) == 4\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty')\n    return min(nums) + max(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list cannot be empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list cannot be empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The list cannot be empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list cannot be empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list cannot be empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list cannot be empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list cannot be empty.')\n    return min(nums) + max(nums)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/478", "requirement": "```python\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove individual lowercase alphabetic characters from a given string.\n    The function should:\n    1. Remove only lowercase alphabetic characters (e.g., 'a' to 'z').\n    2. Retain all other characters, including uppercase alphabetic characters, digits, punctuation, and spaces.\n    3. Preserve the original order of characters in the input string.\n\n    Example:\n    assert remove_lowercase(\"PYTHon\") == 'PYTH'\n    \"\"\"\n```", "generated_programs": ["def remove_lowercase(str1: str) -> str:\n    return ''.join((char for char in str1 if not char.islower()))", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join((char for char in str1 if not char.islower()))", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/479", "requirement": "def first_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the first digit of a given positive integer.\n    \n    Preconditions:\n    - The input `n` must be a positive integer (n > 0).\n    - Negative integers or non-integer inputs are considered invalid and should not be passed to the function.\n    \n    Behavior:\n    - The function extracts the first digit of the input number by converting it to a string, taking the first character, and converting it back to an integer.\n    - If a negative integer is passed, the function behavior is undefined and may raise a runtime error (e.g., ValueError).\n    \n    Example:\n    assert first_Digit(123) == 1\n    \"\"\"", "generated_programs": ["def first_Digit(n: int) -> int:\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    return int(str(n)[0])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/559", "requirement": "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Write a function to find the sum of the largest contiguous sublist in the given list.\n    \n    Requirements:\n    1. The input list `a` must be non-empty, and the parameter `size` must match the length of the list (`len(a)`).\n       - If `size` does not match `len(a)`, or if the list is empty, the function will raise an `IndexError`.\n    2. The function assumes valid input and does not handle edge cases such as empty lists or mismatched `size` values.\n    3. The function calculates the sum of the largest contiguous sublist using the given list and size, following the reference implementation.\n    \n    Example:\n    assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if len(a) != size or size == 0:\n        raise IndexError\n    max_sum = a[0]\n    current_sum = a[0]\n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if len(a) != size or size == 0:\n        raise IndexError\n    max_sum = a[0]\n    current_sum = a[0]\n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "code\nfrom typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size != len(a) or not a:\n        raise IndexError('Invalid input: size does not match list length or list is empty.')\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if len(a) != size or not a:\n        raise IndexError\n    max_end_here = a[0]\n    max_so_far = a[0]\n    for i in range(1, size):\n        max_end_here = max(a[i], max_end_here + a[i])\n        max_so_far = max(max_so_far, max_end_here)\n    return max_so_far", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if len(a) != size or not a:\n        raise IndexError('Invalid input: size does not match list length or list is empty.')\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size != len(a):\n        raise IndexError('Invalid input: list is empty or size does not match list length.')\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size != len(a) or not a:\n        raise IndexError\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size != len(a) or not a:\n        raise IndexError\n    max_so_far = float('-inf')\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here += a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if len(a) != size or not a:\n        raise IndexError\n    max_so_far = float('-inf')\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here += a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size != len(a) or not a:\n        raise IndexError\n    max_so_far = float('-inf')\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here += a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/564", "requirement": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function that takes a list of integers `arr` and an integer `n` (the length of the list) and returns the count of all possible unordered pairs of elements where both elements are unequal. \n\n    The function should:\n    - Consider \"unordered pairs\" as pairs `(a, b)` where the order does not matter (i.e., `(a, b)` is the same as `(b, a)`).\n    - Account for the frequency of individual numbers in the list when calculating the count of pairs.\n    - Exclude pairs where both elements are equal (e.g., `(1, 1)`).\n    - Handle lists with duplicate elements correctly by subtracting pairs formed by equal elements from the total possible pairs.\n    - Return `0` if the list has fewer than two elements, as no pairs can be formed.\n\n    Input assumptions:\n    - `arr` is a valid list of integers.\n    - `n` is the length of the list `arr` and is always non-negative.\n    - The list `arr` may contain duplicates.\n\n    Example:\n    assert count_Pairs([1, 2, 1], 3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\nfrom collections import Counter\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    counter = Counter(arr)\n    total_pairs = n * (n - 1) // 2\n    same_pairs = sum((v * (v - 1) // 2 for v in counter.values()))\n    return total_pairs - same_pairs", "from typing import List\nfrom collections import Counter\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    freq = Counter(arr)\n    total = 0\n    for key in freq:\n        total += freq[key] * (n - freq[key])\n    return total // 2", "from typing import List\nfrom collections import Counter\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    total_pairs = n * (n - 1) // 2\n    freq = Counter(arr)\n    same_pairs = sum((v * (v - 1) // 2 for v in freq.values()))\n    return total_pairs - same_pairs", "from typing import List\nfrom collections import Counter\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    freq = Counter(arr)\n    total = n * (n - 1) // 2\n    same = sum((v * (v - 1) // 2 for v in freq.values()))\n    return total - same", "from typing import List\nfrom collections import Counter\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    total_pairs = n * (n - 1) // 2\n    count = Counter(arr)\n    same_pairs = sum((v * (v - 1) // 2 for v in count.values()))\n    return total_pairs - same_pairs", "from typing import List\nfrom collections import Counter\nfrom math import comb\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    total_pairs = comb(n, 2)\n    freq = Counter(arr)\n    same_pairs = sum((comb(cnt, 2) for cnt in freq.values() if cnt >= 2))\n    return total_pairs - same_pairs", "from typing import List\nfrom collections import Counter\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    freq = Counter(arr)\n    total_pairs = n * (n - 1) // 2\n    same_pairs = 0\n    for count in freq.values():\n        if count >= 2:\n            same_pairs += count * (count - 1) // 2\n    return total_pairs - same_pairs", "from typing import List\nfrom collections import Counter\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    total_pairs = n * (n - 1) // 2\n    counter = Counter(arr)\n    same_pairs = 0\n    for v in counter.values():\n        if v >= 2:\n            same_pairs += v * (v - 1) // 2\n    return total_pairs - same_pairs", "from typing import List\nfrom collections import defaultdict\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    freq = defaultdict(int)\n    for num in arr:\n        freq[num] += 1\n    total_pairs = n * (n - 1) // 2\n    same_pairs = 0\n    for count in freq.values():\n        if count >= 2:\n            same_pairs += count * (count - 1) // 2\n    return total_pairs - same_pairs", "from typing import List\nfrom collections import Counter\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    if n < 2:\n        return 0\n    count = 0\n    freq = Counter(arr)\n    total_pairs = n * (n - 1) // 2\n    pairs_with_same_elements = 0\n    for key in freq:\n        if freq[key] >= 2:\n            pairs_with_same_elements += freq[key] * (freq[key] - 1) // 2\n    return total_pairs - pairs_with_same_elements"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n\"\"\"\nWrite a function to remove uneven elements in the nested mixed tuple.\nassert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n\"\"\"", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for element in test_tuple:\n        if isinstance(element, tuple):\n            result.append(extract_even(element))\n        elif isinstance(element, int) and element % 2 == 0:\n            result.append(element)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for element in test_tuple:\n        if isinstance(element, tuple):\n            result.append(extract_even(element))\n        elif isinstance(element, int) and element % 2 == 0:\n            result.append(element)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def _extract_even(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                processed_item = _extract_even(item)\n                if processed_item:\n                    result.append(processed_item)\n            elif isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n        return tuple(result)\n    return _extract_even(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def is_even(n):\n        return isinstance(n, int) and n % 2 == 0\n\n    def process_tuple(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                processed_item = process_tuple(item)\n                if processed_item:\n                    result.append(processed_item)\n            elif is_even(item):\n                result.append(item)\n        return tuple(result)\n    return process_tuple(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def even_filter(item):\n        if isinstance(item, tuple):\n            return tuple((even_filter(x) for x in item if even_filter(x) is not None))\n        elif isinstance(item, int):\n            return item if item % 2 == 0 else None\n        else:\n            return item\n    filtered = tuple((even_filter(item) for item in test_tuple if even_filter(item) is not None))\n    return filtered", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            return tuple((process_element(e) for e in element if isinstance(e, (int, tuple)) and (isinstance(e, tuple) or e % 2 == 0)))\n        elif isinstance(element, int) and element % 2 == 0:\n            return element\n        else:\n            return None\n    return tuple((e for e in process_element(test_tuple) if e is not None))"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n    \"\"\"\n    Write a Python function to find the surface area of a square pyramid given the base edge length (`b`) and the slant height (`s`).\n    The surface area is calculated using the formula:\n        surface area = base area + lateral area\n        base area = b^2\n        lateral area = 2 * b * s\n    Here, `s` explicitly represents the slant height (the distance from the apex to the midpoint of one base edge along the triangular face).\n    Example:\n        assert surface_Area(3, 4) == 33\n    \"\"\"", "generated_programs": ["def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "from typing import Union\n\ndef surface_Area(b: Union[float, int], s: Union[float, int]) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area"], "result": {"repaired_passk": 0.8, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/589", "requirement": "from typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function to find all perfect squares between two given numbers `a` and `b`, inclusive of the boundaries.\n\n    Requirements:\n    1. The function should return a list of integers representing the perfect squares between `a` and `b` (inclusive).\n    2. If `a` or `b` is negative, or if `a > b`, the function must raise a `ValueError`.\n    3. The inputs `a` and `b` must be integers. If non-integer inputs are provided, the function behavior is undefined.\n    4. The function assumes valid input types but explicitly handles invalid ranges as described above.\n\n    Example:\n    assert perfect_squares(1, 30) == [1, 4, 9, 16, 25]\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if a < 0 or b < 0 or a > b:\n        raise ValueError\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if a < 0 or b < 0 or a > b:\n        raise ValueError\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if a < 0 or b < 0 or a > b:\n        raise ValueError('Invalid range')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if a < 0 or b < 0 or a > b:\n        raise ValueError('Invalid range provided.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if a < 0 or b < 0 or a > b:\n        raise ValueError\n    start = math.ceil(math.sqrt(a)) if a > 0 else 0\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if a < 0 or b < 0 or a > b:\n        raise ValueError('Invalid range: a and b must be non-negative and a <= b.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if a < 0 or b < 0 or a > b:\n        raise ValueError('Invalid range')\n    start = math.ceil(math.sqrt(a)) if math.sqrt(a) != int(math.sqrt(a)) else int(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if a < 0 or b < 0 or a > b:\n        raise ValueError('Invalid range: a and b must be non-negative and a must be less than or equal to b.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if a < 0 or b < 0 or a > b:\n        raise ValueError(\"Invalid range: 'a' and 'b' must be non-negative with 'a' <= 'b'.\")\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if a < 0 or b < 0 or a > b:\n        raise ValueError('Invalid range. Both a and b must be non-negative, and a must be less than or equal to b.')\n    start = math.ceil(math.sqrt(a)) if a > 0 else 0\n    end = math.floor(math.sqrt(b))\n    squares = [i * i for i in range(start, end + 1)]\n    return squares"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Write a function to convert Cartesian coordinates (x, y) into polar coordinates and a transformed rectangular complex coordinate.\n\n    The function performs the following steps:\n    1. Calculate the polar coordinates:\n       - Magnitude = sqrt(x^2 + y^2)\n       - Angle = atan2(y, x)\n       These values are returned as a tuple (magnitude, angle).\n\n    2. Convert the polar coordinates into a rectangular complex coordinate using the `cmath.rect` function.\n\n    3. Transform the rectangular complex coordinate by negating its real part while retaining its imaginary part. \n       This transformation is applied to the rectangular complex coordinate to produce the final rectangular complex output.\n\n    4. Return a tuple containing:\n       - The polar coordinates as (magnitude, angle)\n       - The transformed rectangular complex coordinate\n\n    Example:\n    assert polar_rect(3, 4) == ((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar = (magnitude, angle)\n    rect = cmath.rect(magnitude, angle)\n    transformed_rect = complex(-rect.real, rect.imag)\n    return (polar, transformed_rect)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = cmath.rect(magnitude, angle)\n    transformed_rect_complex = complex(-rect_complex.real, rect_complex.imag)\n    return ((magnitude, angle), transformed_rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    polar = (magnitude, angle)\n    rect = cmath.rect(magnitude, angle)\n    transformed_rect = complex(-rect.real, rect.imag)\n    return (polar, transformed_rect)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    polar = (magnitude, angle)\n    rect_complex = cmath.rect(magnitude, angle)\n    transformed_complex = complex(-rect_complex.real, rect_complex.imag)\n    return (polar, transformed_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    polar_coords = (magnitude, angle)\n    rect_complex = cmath.rect(magnitude, angle)\n    transformed_rect = complex(-rect_complex.real, rect_complex.imag)\n    return (polar_coords, transformed_rect)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    polar = (magnitude, angle)\n    rectangular = cmath.rect(magnitude, angle)\n    transformed_rectangular = complex(-rectangular.real, rectangular.imag)\n    return (polar, transformed_rectangular)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    rect_complex = cmath.rect(magnitude, angle)\n    transformed_rect_complex = complex(-rect_complex.real, rect_complex.imag)\n    return ((magnitude, angle), transformed_rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    polar = (magnitude, angle)\n    rect_complex = cmath.rect(magnitude, angle)\n    transformed_rect_complex = complex(-rect_complex.real, rect_complex.imag)\n    return (polar, transformed_rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    polar_coords = (magnitude, angle)\n    rect_complex = cmath.rect(magnitude, angle)\n    transformed_rect = complex(-rect_complex.real, rect_complex.imag)\n    return (polar_coords, transformed_rect)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    polar_coords = (magnitude, angle)\n    rect_complex = cmath.rect(magnitude, angle)\n    transformed_rect = complex(-rect_complex.real, rect_complex.imag)\n    return (polar_coords, transformed_rect)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/592", "requirement": "def sum_Of_product(n: int) -> int:\n\"\"\"\nWrite a python function to find the sum of the product of consecutive binomial co-efficients.\nassert sum_Of_product(3) == 15\n\"\"\"", "generated_programs": ["from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, k) * comb(n, k + 1) for k in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(i + 1, i) * comb(n, i + 1) for i in range(n)))", "import math\n\ndef sum_Of_product(n: int) -> int:\n    return sum((math.comb(n, k) * math.comb(n, k + 1) for k in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    total = 0\n    for k in range(1, n + 1):\n        total += comb(n, k) * comb(n, k - 1)\n    return total", "import math\n\ndef sum_Of_product(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += math.comb(n, k) * math.comb(n, k + 1)\n    return total", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    total = 0\n    for i in range(1, n + 1):\n        total += comb(n, i) * comb(n, i - 1)\n    return total"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the absolute difference between the first even number and the first odd number in a given list.\n\n    - The function searches for the first even number and the first odd number independently across the entire list, without requiring sequential discovery.\n    - If the list does not contain at least one even number and one odd number, the function will raise a `StopIteration` exception.\n    - If the list is empty, the function will raise a `StopIteration` exception.\n    - The input list is not guaranteed to contain both even and odd numbers, and the function will raise `StopIteration` if either is missing.\n\n    Example:\n    assert diff_even_odd([1,3,5,7,4,1,6,8]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is None or odd is None:\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is None or odd is None:\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is None or odd is None:\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            return abs(even_num - odd_num)\n    raise StopIteration", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is None or odd is None:\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is None or odd is None:\n        raise StopIteration('List does not contain both even and odd numbers.')\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is None or odd is None or (not list1):\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    if not list1:\n        raise StopIteration('List is empty')\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is None or odd is None:\n        raise StopIteration('List does not contain both even and odd numbers')\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None or (not list1):\n        raise StopIteration\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    if not list1:\n        raise StopIteration('The list is empty.')\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    if even_num is None or odd_num is None:\n        raise StopIteration('The list does not contain both even and odd numbers.')\n    return abs(even_num - odd_num)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/599", "requirement": "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n    Write a function to find the sum and average of the first n natural numbers.\n\n    - The input `number` represents the count of the first natural numbers to consider.\n    - If `number > 0`, the function computes the sum of the first `number` natural numbers (1 through `number`) and their average.\n    - If `number = 0`, the function explicitly raises a `ZeroDivisionError` with the message 'Cannot compute average for an empty set.' This behavior is mandatory and ensures that the average cannot be computed for an empty set.\n    - If `number < 0`, the function returns `(0, -0.0)` to indicate that the sum and average over an empty range are `0` and `-0.0`, respectively. This behavior is explicitly defined and does not raise an exception.\n    - The function assumes that the input `number` is always an integer and does not validate the input type.\n\n    Example:\n    assert sum_average(10) == (55, 5.5)\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number > 0:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty set.')\n    else:\n        return (0, -0.0)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number > 0:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty set.')\n    else:\n        return (0, -0.0)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number > 0:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty set.')\n    else:\n        return (0, -0.0)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number > 0:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty set.')\n    else:\n        return (0, -0.0)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number > 0:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty set.')\n    else:\n        return (0, -0.0)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number > 0:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty set.')\n    else:\n        return (0, -0.0)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number > 0:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty set.')\n    else:\n        return (0, -0.0)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number > 0:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty set.')\n    else:\n        return (0, -0.0)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number > 0:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty set.')\n    else:\n        return (0, -0.0)", "code\nfrom typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number > 0:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty set.')\n    else:\n        return (0, -0.0)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/602", "requirement": "```python\ndef first_repeated_char(str1: str) -> str:\n    \"\"\"\n    Write a Python function to find the first repeated character in a given string.\n    \n    The function should analyze the input string `str1` and determine the first character \n    that appears more than once when traversing the string from left to right. If a repeated \n    character is found, the function should return it. The function must be case-sensitive, \n    meaning that 'a' and 'A' are treated as different characters. If no repeated character \n    is found, the function should return an empty string (`\"\"`).\n    \n    The function is expected to handle all valid string inputs, including:\n      - Strings with alphabetic characters, digits, whitespaces, and special characters.\n      - Edge cases such as an empty string, which should return an empty string (`\"\"`).\n\n    Examples:\n    assert first_repeated_char(\"abcabc\") == \"a\"  # 'a' is the first repeated character\n    \"\"\"\n```", "generated_programs": ["def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = {}\n    for char in str1:\n        if char in seen:\n            return char\n        seen[char] = True\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/603", "requirement": "```python\nfrom typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    \"\"\"\n    Write a function to generate all ludic numbers smaller than or equal to a given integer `n`.\n    \n    Ludic numbers are a sequence of integers derived through an iterative filtering process:\n    1. Start with a list of integers from 1 to `n`.\n    2. Begin with the first number in the list (the number 1) and repeatedly apply the following steps:\n       - Select the current number from the list and add it to the list of ludic numbers.\n       - Remove all remaining numbers in the list that are divisible by the current number.\n    3. Continue the filtering process with the next number in the updated list, repeating until no further filtering can be applied (i.e., the list is empty).\n    \n    The function should return the list of ludic numbers up to `n`.\n\n    Constraints:\n    - If `n < 1`, return an empty list.\n    - The input `n` is guaranteed to be a non-negative integer.\n    \n    Example:\n    assert get_ludic(10) == [1, 2, 3, 5, 7]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    numbers = list(range(1, n + 1))\n    ludic = []\n    while numbers:\n        current = numbers[0]\n        ludic.append(current)\n        numbers = [x for x in numbers if x % current != 0]\n    return ludic", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = []\n    numbers = list(range(1, n + 1))\n    while numbers:\n        current = numbers[0]\n        ludic_numbers.append(current)\n        numbers = [num for num in numbers if num % current != 0]\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    numbers = list(range(1, n + 1))\n    ludic_numbers = []\n    while numbers:\n        current = numbers[0]\n        ludic_numbers.append(current)\n        numbers = [x for x in numbers if x % current != 0]\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    numbers = list(range(1, n + 1))\n    ludic = []\n    while numbers:\n        current = numbers[0]\n        ludic.append(current)\n        numbers = [x for x in numbers if x % current != 0]\n    return ludic", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    numbers = list(range(1, n + 1))\n    ludic = []\n    while numbers:\n        current = numbers[0]\n        ludic.append(current)\n        numbers = [x for x in numbers if x % current != 0]\n    return ludic", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    numbers = list(range(1, n + 1))\n    ludic = []\n    while numbers:\n        current = numbers[0]\n        ludic.append(current)\n        numbers = [num for num in numbers if num % current != 0]\n    return ludic", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic = []\n    numbers = list(range(1, n + 1))\n    while numbers:\n        ludic.append(numbers[0])\n        current = numbers[0]\n        numbers = [num for num in numbers if num % current != 0]\n    return sorted(ludic)", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = []\n    numbers = list(range(1, n + 1))\n    while numbers:\n        current = numbers[0]\n        ludic_numbers.append(current)\n        numbers = [num for num in numbers if num % current != 0]\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    numbers = list(range(1, n + 1))\n    ludic_numbers = []\n    while numbers:\n        current = numbers[0]\n        ludic_numbers.append(current)\n        numbers = [num for num in numbers if num % current != 0]\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = []\n    numbers = list(range(1, n + 1))\n    while numbers:\n        current = numbers[0]\n        ludic_numbers.append(current)\n        numbers = [num for num in numbers if num % current != 0]\n    return ludic_numbers"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.9}}
{"task_id": "Mbpp/604", "requirement": "```python\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words in a given string. Words are defined as sequences of non-space characters \n    separated by one or more spaces. The function should normalize spacing by collapsing multiple consecutive spaces \n    into a single space and removing any leading or trailing spaces in the input. The output should contain words \n    in reverse order, separated by a single space.\n\n    Edge-case behavior:\n    - For an empty string input, the output should also be an empty string.\n    - For input strings containing only spaces, the output should be an empty string.\n    - For input strings with multiple consecutive spaces between words, the output should have single spaces between words.\n    - Leading and trailing spaces in the input should be ignored in the output.\n\n    Example:\n    assert reverse_words(\"python program\") == \"program python\"\n    \"\"\"\n```", "generated_programs": ["def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    return ' '.join(reversed(words))", "def reverse_words(s: str) -> str:\n    words = s.strip().split()\n    return ' '.join(words[::-1])", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = [word for word in s.split() if word]\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/608", "requirement": "```python\ndef bell_Number(n: int) -> int:\n    \"\"\"\n    Write a Python function to compute the nth Bell number, which represents the number of ways to partition a set of n elements.\n    \n    Constraints:\n    - The input `n` must be a non-negative integer (n >= 0).\n    - If `n` is negative or not an integer, the function should raise a `ValueError` with an appropriate error message.\n    \n    Computation:\n    - The Bell numbers are computed using Bell's triangle:\n        - Start with `bell[0][0] = 1`.\n        - For each row `i` (1 to n), set `bell[i][0] = bell[i-1][i-1]`.\n        - For each column `j` (1 to i), compute `bell[i][j] = bell[i-1][j-1] + bell[i][j-1]`.\n    - The nth Bell number is the first element of the nth row, i.e., `bell[n][0]`.\n\n    Examples:\n    - assert bell_Number(2) == 2\n    - For `n = 0`, the output is `1` (base case).\n    - For invalid inputs (e.g., `n < 0` or non-integer types), the function raises a `ValueError`.\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [-1]\n    Expected Output: ['ValueError']\n    ### Test 2\n    Input: [-1]\n    Expected Output: ['ValueError']\n    \"\"\"\n```", "generated_programs": ["def bell_Number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    bell = [[1]]\n    for i in range(1, n + 1):\n        bell.append([bell[i - 1][i - 1]])\n        for j in range(1, i + 1):\n            bell[i].append(bell[i - 1][j - 1] + bell[i][j - 1])\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[1]]\n    for i in range(1, n + 1):\n        bell.append([bell[i - 1][i - 1]])\n        for j in range(1, i + 1):\n            bell[i].append(bell[i - 1][j - 1] + bell[i][j - 1])\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    import sys\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/610", "requirement": "```python\nfrom typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function that takes a list of integers `list1` and an integer `k`, and returns a new list with the same elements, \n    but with the k'th element removed. The parameter `k` is interpreted using 1-based indexing, meaning `k=1` refers to the first element, \n    `k=2` refers to the second element, and so on. \n\n    Constraints:\n    - `k` must be a positive integer within the range `1 <= k <= len(list1)`. \n    - If `k` is out of bounds (e.g., `k <= 0` or `k > len(list1)`), the behavior is undefined.\n\n    Example:\n    assert remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k - 1] + list1[k:]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/611", "requirement": "```python\nfrom typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n    Write a function which, given a matrix represented as a list of lists, returns the maximum value \n    from the N'th column. The function assumes the input matrix is well-formed, meaning all rows \n    must have at least N+1 elements. If any row does not have enough elements to access the N'th \n    column, or if the matrix is empty, the function will raise an IndexError.\n\n    Parameters:\n    - test_list: A list of lists of integers representing the matrix.\n    - N: An integer representing the column index (0-based) to find the maximum value from.\n\n    Returns:\n    - The maximum value from the N'th column.\n\n    Behavior:\n    - If the matrix is empty (`test_list = []`), an IndexError is raised.\n    - If any row in the matrix does not have at least N+1 elements, an IndexError is raised.\n    - The function does not skip rows with insufficient columns; it strictly enforces well-formedness.\n\n    Example:\n    assert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [[[3, 2, 1], [], [6, 5, 4]], 0]\n    Expected Output: ['IndexError']\n    ### Test 2\n    Input: [[[], [], [1, 2, 3]], 2]\n    Expected Output: ['IndexError']\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    if not test_list:\n        raise IndexError\n    for row in test_list:\n        if len(row) <= N:\n            raise IndexError\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    if not test_list:\n        raise IndexError\n    for row in test_list:\n        if len(row) < N + 1:\n            raise IndexError\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    if not test_list:\n        raise IndexError\n    for row in test_list:\n        if len(row) <= N:\n            raise IndexError\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    if not test_list:\n        raise IndexError\n    for row in test_list:\n        if len(row) < N + 1:\n            raise IndexError\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    if not test_list:\n        raise IndexError\n    for row in test_list:\n        if len(row) <= N:\n            raise IndexError\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    if not test_list:\n        raise IndexError\n    for row in test_list:\n        if len(row) <= N:\n            raise IndexError\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    if not test_list:\n        raise IndexError\n    for row in test_list:\n        if len(row) <= N:\n            raise IndexError\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    if not test_list:\n        raise IndexError\n    for row in test_list:\n        if len(row) <= N:\n            raise IndexError\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    if not test_list:\n        raise IndexError('Matrix is empty')\n    for row in test_list:\n        if len(row) <= N:\n            raise IndexError('Row does not have enough elements')\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    if not test_list:\n        raise IndexError('Matrix is empty')\n    max_val = None\n    for row in test_list:\n        if len(row) <= N:\n            raise IndexError('Row does not have enough elements')\n        if max_val is None or row[N] > max_val:\n            max_val = row[N]\n    return max_val"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/615", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n\"\"\"\nWrite a function which takes a tuple of tuples and returns the average value for each tuple as a list.\nassert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]\n\"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(t) / len(t) for t in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(t) / len(t) for t in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(x) / len(x) for x in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(t) / len(t) for t in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(t) / len(t) for t in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(tup) / len(tup) for tup in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(t) / len(t) for t in zip(*nums)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/620", "requirement": "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    \"\"\"\n    Write a function to find the size of the largest subset of a list of numbers such that for every pair of numbers in the subset, one number is divisible by the other. \n    The function should:\n    1. Consider only positive integers for divisibility checks. Negative numbers in the input list should be treated as their absolute values.\n    2. Preserve duplicates in the input list. Each instance of a duplicate number should be treated as a distinct element when calculating the subset size.\n    3. Perform the transformation of negative numbers to their absolute values before any other processing, including subset calculations.\n    4. Return 0 for an empty list.\n    5. Assume the input list contains only integers and does not require validation for invalid inputs.\n\n    Examples:\n    assert largest_subset([1, 3, 6, 13, 17, 18]) == 4\n    assert largest_subset([-2, -4, 8, 16]) == 3\n    assert largest_subset([]) == 0\n    assert largest_subset([5, 5, 5, 5]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = [abs(x) for x in a]\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = [abs(x) for x in a]\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = [abs(x) for x in a]\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = [abs(x) for x in a]\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = [abs(x) for x in a]\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = [abs(x) for x in a]\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = [abs(x) for x in a]\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = [abs(x) for x in a]\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = [abs(x) for x in a]\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = [abs(x) for x in a]\n    a.sort()\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp, default=0)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/622", "requirement": "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    \"\"\"\n    Write a function to find the median of two sorted lists of the same size. \n\n    Requirements:\n    1. Both input lists (`nums1` and `nums2`) must be non-empty and sorted in ascending order.\n    2. The value of `n` must match the actual size of both input lists. If `n` does not match the size of either list, or if the lists are empty, the function should raise a `ValueError`.\n    3. The function calculates the median by merging the two sorted lists into one sorted list and finding the average of the two middle elements of the merged list.\n    4. The function returns the median as a floating-point number.\n\n    Edge Case Handling:\n    - If either list is empty or `n` is zero, the function raises a `ValueError`.\n    - If the sizes of the two lists do not match or differ from `n`, the function raises a `ValueError`.\n\n    Example:\n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if not nums1 or not nums2 or n == 0 or (len(nums1) != n) or (len(nums2) != n):\n        raise ValueError('Invalid input: lists must be non-empty and of size n.')\n    merged = sorted(nums1 + nums2)\n    mid = merged[n - 1] + merged[n]\n    return mid / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if not nums1 or not nums2 or len(nums1) != n or (len(nums2) != n):\n        raise ValueError('Invalid input: lists must be non-empty and of size n.')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if not nums1 or not nums2 or n == 0:\n        raise ValueError('Input lists must be non-empty and n must be greater than zero.')\n    if len(nums1) != n or len(nums2) != n:\n        raise ValueError('The size of both lists must match the value of n.')\n    merged = sorted(nums1 + nums2)\n    mid = n * 2 // 2\n    return (merged[mid - 1] + merged[mid]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if not nums1 or not nums2 or n == 0:\n        raise ValueError('Input lists must be non-empty and n must be greater than zero.')\n    if len(nums1) != n or len(nums2) != n:\n        raise ValueError('The size of both lists must match the value of n.')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return float(merged[mid])", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if not nums1 or not nums2 or n == 0:\n        raise ValueError('Lists must be non-empty and n must be greater than zero.')\n    if len(nums1) != n or len(nums2) != n:\n        raise ValueError('The sizes of the lists must match the value of n.')\n    merged = sorted(nums1 + nums2)\n    mid = n\n    return (merged[mid - 1] + merged[mid]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if not nums1 or not nums2 or n == 0:\n        raise ValueError('Input lists must be non-empty and n must be greater than zero.')\n    if len(nums1) != n or len(nums2) != n:\n        raise ValueError('The size of the input lists must match the value of n.')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return float(merged[mid])", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if len(nums1) == 0 or len(nums2) == 0 or n == 0:\n        raise ValueError('Lists must be non-empty and n must be non-zero')\n    if len(nums1) != n or len(nums2) != n:\n        raise ValueError('Size of lists must match n')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return float(merged[mid])", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if not nums1 or not nums2 or n == 0:\n        raise ValueError('Lists must be non-empty and n must be greater than zero.')\n    if len(nums1) != n or len(nums2) != n:\n        raise ValueError('Size of both lists must match n.')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if not nums1 or not nums2 or n == 0:\n        raise ValueError('Input lists must be non-empty and n must be greater than zero.')\n    if len(nums1) != n or len(nums2) != n:\n        raise ValueError('The size of the input lists must match the value of n.')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2.0\n    else:\n        return float(merged[mid])", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if not nums1 or not nums2 or n == 0:\n        raise ValueError('Input lists must be non-empty and n must be greater than zero.')\n    if len(nums1) != n or len(nums2) != n:\n        raise ValueError('The size of input lists must match n.')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2.0\n    else:\n        return float(merged[mid])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> Optional[float]:\n    \"\"\"\n    Write a Python function to compute the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\n    Clarifications:\n    1. The \"largest triangle\" refers to a right triangle whose hypotenuse coincides with the diameter of the semicircle. The area of such a triangle is calculated as (radius * radius), where the base and height are both equal to the radius of the semicircle.\n    2. If the radius is non-positive (radius <= 0), the function should return None, as a semicircle with a non-positive radius cannot inscribe a meaningful triangle.\n    3. The output type is either a float (for valid radius > 0) or None (for invalid radius <= 0).\n\n    Examples:\n    assert triangle_area(1) == 1\n    assert triangle_area(0) == None\n    assert triangle_area(-1) == None\n    \"\"\"", "generated_programs": ["from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/631", "requirement": "```python\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace whitespaces (' ') with underscores ('_') and underscores ('_') with whitespaces (' ') \n    in a given string. Each character in the string should be processed independently in a single pass, without \n    iterative or sequential transformations. The function should handle all input cases, including strings with \n    pre-existing underscores, multiple consecutive whitespaces, or a mix of both.\n\n    Example:\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    \"\"\"\n```", "generated_programs": ["def replace_spaces(text: str) -> str:\n    return text.translate(str.maketrans({' ': '_', '_': ' '}))", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '\\x00').replace('_', ' ').replace('\\x00', '_')", "def replace_spaces(text: str) -> str:\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in text])", "def replace_spaces(text: str) -> str:\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in text])", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '\\x00').replace('_', ' ').replace('\\x00', '_')", "def replace_spaces(text: str) -> str:\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in text])", "def replace_spaces(text: str) -> str:\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in text])", "def replace_spaces(text: str) -> str:\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in text])", "def replace_spaces(text: str) -> str:\n    return text.replace(' ', '\\x00').replace('_', ' ').replace('\\x00', '_')", "def replace_spaces(text: str) -> str:\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in text])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/638", "requirement": "```python\ndef wind_chill(v: float, t: float) -> int:\n    \"\"\"\n    Write a function to calculate the wind chill index rounded using standard mathematical rounding \n    (rounding up for .5 and above, down otherwise) given the wind velocity in km/h and a temperature in Celsius.\n\n    The function must validate inputs:\n    - Wind velocity `v` must be non-negative (v >= 0). If `v` is negative, raise a `ValueError`.\n    - Temperature `t` is assumed to be a valid float without additional constraints.\n\n    The formula for calculating the wind chill index is:\n    wind_chill = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n\n    Example:\n    assert wind_chill(120, 35) == 40\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [-1, 20]\n    Expected Output: ['ValueError']\n    ### Test 2\n    Input: [0, 10]\n    Expected Output: [19]\n    \"\"\"\n```", "generated_programs": ["def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wc)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wc)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wc)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return int(round(wc))", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return int(round(wci, 0))", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wc)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wind_chill_value = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return int(round(wind_chill_value))", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return int(wc + 0.5) if wc > 0 else int(wc - 0.5)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.floor(wind_chill_index + 0.5)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/643", "requirement": "```python\ndef text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if the input string contains the character 'z' \n    such that 'z' is surrounded by other characters within a word. A word is \n    defined as a sequence of non-whitespace characters. The function should \n    return True if 'z' is found in the middle of a word (not at the start or \n    end of the word), and False otherwise.\n\n    Notes:\n    - The function should handle input strings with multiple words separated \n      by spaces.\n    - Words are sequences of characters separated by whitespace.\n    - The implementation should use regular expressions to identify 'z' \n      surrounded by other characters within a word.\n\n    Example:\n    assert text_match_wordz_middle(\"pythonzabc.\") == True\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = re.compile('\\\\Bz\\\\B')\n    return bool(pattern.search(text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = re.compile('\\\\Bz\\\\B')\n    return bool(pattern.search(text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = re.compile('\\\\Bz\\\\B')\n    return bool(pattern.search(text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/644", "requirement": "```python\nfrom typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function to reverse the elements of an array up to a given position `k`.\n    \n    The function performs the following:\n    1. Reverses the elements of the array from the start up to (and including) the element at index `k-1`.\n    2. Appends the remaining elements of the array (from index `k` onward) unchanged.\n    \n    Special cases:\n    - If `k <= 0`, the function returns the original array unchanged.\n    - If `k > len(input)`, the function treats `k` as equal to `len(input)` and reverses the entire array.\n    - If the input array is empty, the function returns an empty list regardless of the value of `k`.\n\n    Example:\n    assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k > len(input):\n        k = len(input)\n    if k <= 0:\n        return input\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k <= 0:\n        return input\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k > len(input):\n        k = len(input)\n    if k <= 0:\n        return input.copy()\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k <= 0:\n        return input\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k <= 0:\n        return input.copy()\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input or k <= 0:\n        return input[:]\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k <= 0:\n        return input\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k <= 0:\n        return input.copy()\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k > len(input):\n        k = len(input)\n    if k <= 0:\n        return input\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k <= 0:\n        return input.copy()\n    if k > len(input):\n        k = len(input)\n    reversed_part = input[:k][::-1]\n    remaining_part = input[k:]\n    return reversed_part + remaining_part"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/722", "requirement": "def filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    The input is given as:\n    - a dictionary where the key is a student name (string) and the value is a tuple of two floats representing (student_height, student_weight),\n    - a minimal height (float),\n    - a minimal weight (float).\n\n    Write a function to filter and return a dictionary of students whose height is greater than or equal to the minimal height and whose weight is greater than or equal to the minimal weight.\n\n    Example:\n    assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70) == {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/734", "requirement": "def sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to calculate the sum of the products of all contiguous subarrays \n    (sublists formed by consecutive elements) of a given list. For each subarray, compute the \n    product of its elements and add it to the total sum.\n\n    Example:\n    assert sum_Of_Subarray_Prod([1,2,3]) == 20\n    \"\"\"", "generated_programs": ["code\nfrom typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        prod = 1\n        for j in range(i, n):\n            prod *= arr[j]\n            total += prod\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= arr[j]\n            total_sum += current_product\n    return total_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/735", "requirement": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Toggle all bits of the integer `n` except for the most significant bit and the least significant bit.\n    If `n` has fewer than 3 bits, return `n` unchanged.\n    The function should ensure that the result has the same number of bits as `n`.\n    \n    Example:\n    assert toggle_middle_bits(9) == 15\n    \"\"\"", "generated_programs": ["def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 1\n    mask &= ~1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 1\n    mask &= ~1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 1\n    mask &= ~1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 1\n    mask &= ~1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 1\n    mask &= ~1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 1\n    mask &= ~1\n    return n ^ mask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/740", "requirement": "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    \"\"\"\n    Write a function to convert the given tuple to a key-value dictionary using adjacent elements. \n    The function should pair elements at even indices as keys with elements at the subsequent odd indices as values. \n    If the tuple length is odd, the last unpaired element should be ignored. \n    If the tuple is empty or contains only a single element, the function should return an empty dictionary without raising an error.\n    \n    Example:\n    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    length = len(test_tup)\n    for i in range(0, length - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result_dict = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result_dict[test_tup[i]] = test_tup[i + 1]\n    return result_dict", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result_dict = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result_dict[test_tup[i]] = test_tup[i + 1]\n    return result_dict", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        key = test_tup[i]\n        value = test_tup[i + 1]\n        result[key] = value\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/743", "requirement": "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    \"\"\"\n    Write a function to rotate a given list by a specified number of items to the right direction. \n    The rotation wraps around the list, meaning elements shifted beyond the end of the list reappear at the beginning.\n    \n    Requirements:\n    1. If the input list is empty (`[]`), the function should raise a `ZeroDivisionError` as the operation `m % len(l)` is undefined.\n    2. If `m` is greater than the length of the list, the rotation should wrap around using modular arithmetic (`m = m % len(l)`).\n    3. The input `m` is assumed to be a non-negative integer. Negative values for `m` or non-integer inputs are not valid and are outside the scope of this function.\n    4. If `m` is zero, the function should return the list unchanged.\n    5. The function should handle edge cases gracefully, adhering to the behavior demonstrated in the provided example.\n\n    Example:\n    assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    m = m % len(l)\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    n = len(l)\n    m = m % n\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    if m == 0:\n        return l.copy()\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    n = len(l)\n    m = m % n\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "code\nfrom typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot perform modular arithmetic on an empty list.')\n    if m == 0:\n        return l.copy()\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m] if m != 0 else l", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    if m == 0:\n        return l.copy()\n    m = m % len(l)\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    n = len(l)\n    m = m % n\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Cannot rotate an empty list.')\n    n = len(l)\n    m = m % n\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/745", "requirement": "def divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Write a function to find numbers within a given range from startnum to endnum (inclusive) \n    where every number is divisible by each of its non-zero digits. A number is considered \n    valid if for every digit in the number, the digit is not zero and the number is divisible \n    by that digit without a remainder.\n\n    assert divisible_by_digits(1,22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if all((digit != '0' and num % int(digit) == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((digit != 0 and num % digit == 0 for digit in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        valid = True\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        valid = True\n        for digit in str(num):\n            if digit == '0':\n                valid = False\n                break\n            if num % int(digit) != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        valid = True\n        for digit in str(num):\n            if digit == '0':\n                valid = False\n                break\n            if num % int(digit) != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        is_valid = True\n        for digit in str(num):\n            if digit == '0':\n                is_valid = False\n                break\n            if num % int(digit) != 0:\n                is_valid = False\n                break\n        if is_valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        valid = True\n        for digit in str(num):\n            if digit == '0':\n                valid = False\n                break\n            if num % int(digit) != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        valid = True\n        for digit in str(num):\n            if digit == '0':\n                valid = False\n                break\n            if num % int(digit) != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        valid = True\n        for digit in str(num):\n            if digit == '0':\n                valid = False\n                break\n            if num % int(digit) != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        valid = True\n        for digit_str in str(num):\n            if digit_str == '0':\n                valid = False\n                break\n            digit = int(digit_str)\n            if num % digit != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.9, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/748", "requirement": "```python\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to insert spaces between words in a given string, where each word starts with an uppercase letter.\n    The function should treat every transition into an uppercase letter (except at the start of the string) as the beginning of a new word, regardless of the preceding character type (e.g., lowercase, uppercase, digits, symbols, or whitespace).\n    The output must preserve the exact ordering of characters in the input string, inserting spaces only at the identified transitions.\n\n    Edge cases:\n    - Strings with all uppercase letters (e.g., \"TEST\") should remain unchanged.\n    - Strings with no uppercase letters (e.g., \"test\") should remain unchanged.\n    - Mixed-case strings with symbols or numbers (e.g., \"example123Test\") should handle transitions into uppercase letters as word boundaries.\n\n    Example:\n    assert capital_words_spaces(\"Python\") == 'Python'\n    assert capital_words_spaces(\"PythonRocksIsFun\") == 'Python Rocks Is Fun'\n    assert capital_words_spaces(\"ThisIsATest\") == 'This Is A Test'\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "def capital_words_spaces(str1: str) -> str:\n    result = []\n    for i, char in enumerate(str1):\n        if i != 0 and char.isupper():\n            result.append(' ')\n        result.append(char)\n    return ''.join(result)", "def capital_words_spaces(str1: str) -> str:\n    result = []\n    for i, char in enumerate(str1):\n        if char.isupper() and i != 0:\n            result.append(' ')\n        result.append(char)\n    return ''.join(result)", "def capital_words_spaces(str1: str) -> str:\n    result = ''\n    for i, char in enumerate(str1):\n        if i != 0 and char.isupper():\n            result += ' ' + char\n        else:\n            result += char\n    return result", "def capital_words_spaces(str1: str) -> str:\n    result = []\n    for i, char in enumerate(str1):\n        if char.isupper() and i != 0:\n            result.append(' ')\n        result.append(char)\n    return ''.join(result)", "def capital_words_spaces(str1: str) -> str:\n    result = []\n    for i, char in enumerate(str1):\n        if char.isupper() and i != 0:\n            result.append(' ')\n        result.append(char)\n    return ''.join(result)", "def capital_words_spaces(str1: str) -> str:\n    result = []\n    for i, char in enumerate(str1):\n        if char.isupper() and i != 0:\n            result.append(' ')\n        result.append(char)\n    return ''.join(result)", "def capital_words_spaces(str1: str) -> str:\n    result = ''\n    for i, char in enumerate(str1):\n        if i != 0 and char.isupper():\n            result += ' ' + char\n        else:\n            result += char\n    return result", "def capital_words_spaces(str1: str) -> str:\n    result = str1[0] if str1 else ''\n    for i in range(1, len(str1)):\n        if str1[i].isupper():\n            result += ' ' + str1[i]\n        else:\n            result += str1[i]\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/752", "requirement": "```python\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Jacobsthal number. The Jacobsthal sequence is defined as:\n    - jacobsthal_num(0) = 0\n    - jacobsthal_num(1) = 1\n    - jacobsthal_num(n) = jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2) for n > 1\n\n    The function assumes that the input `n` is a non-negative integer. \n    If `n` is negative, the behavior is undefined and may result in a RecursionError.\n\n    Example sequence: 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    Example:\n    assert jacobsthal_num(5) == 11\n    \"\"\"\n```", "generated_programs": ["def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    prev, curr = (0, 1)\n    for _ in range(2, n + 1):\n        prev, curr = (curr, curr + 2 * prev)\n    return curr", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            a, b = (b, b + 2 * a)\n        return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            a, b = (b, b + 2 * a)\n        return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            a, b = (b, b + 2 * a)\n        return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        prev, curr = (0, 1)\n        for _ in range(2, n + 1):\n            next_val = curr + 2 * prev\n            prev, curr = (curr, next_val)\n        return curr", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + 2 * dp[i - 2]\n        return dp[n]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 0.4}}
{"task_id": "Mbpp/754", "requirement": "```python\nfrom typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists at the same index. \n    The function should find such common elements and return them as a list. \n\n    The comparison is restricted to indices that are valid in all three lists, meaning the range of indices \n    considered is determined by the shortest list. If the lists have differing lengths, the function will \n    only compare elements up to the length of the shortest list. No error will be raised for differing lengths.\n\n    Examples:\n    assert extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]\n    assert extract_index_list([1, 2, 3], [1, 2], [1, 2, 3]) == [1, 2]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_len = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_len = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_len = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_len) if l1[i] == l2[i] and l1[i] == l3[i]]", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/757", "requirement": "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n    Write a function to count the pairs of reverse strings in the given string list. \n    A reverse string pair consists of two distinct strings where one is the reverse of the other. \n    Palindromic strings (strings that reverse to themselves) are explicitly excluded from being considered as valid reverse pairs.\n\n    Each reverse pair should be counted only once, irrespective of duplicates. This means that if a reverse pair is found, it should contribute only one to the count, even if either string in the pair appears multiple times in the list. Once a reverse pair is identified, both strings in the pair are globally excluded from further consideration, ensuring that neither string can participate in forming additional reverse pairs. Unmatched duplicates should remain in the list for further processing.\n\n    The function should handle edge cases gracefully, such as lists containing only palindromic strings or repeated strings, without raising runtime errors.\n\n    Example:\n    assert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]) == 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    used = set()\n    for i in range(len(test_list)):\n        if test_list[i] in used:\n            continue\n        reversed_str = test_list[i][::-1]\n        if reversed_str != test_list[i] and reversed_str in test_list:\n            count += 1\n            used.add(test_list[i])\n            used.add(reversed_str)\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    used = set()\n    for i in range(len(test_list)):\n        if test_list[i] in used:\n            continue\n        reversed_str = test_list[i][::-1]\n        if reversed_str != test_list[i] and reversed_str in test_list:\n            count += 1\n            used.add(test_list[i])\n            used.add(reversed_str)\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    used = set()\n    count = 0\n    for i, s in enumerate(test_list):\n        if s in used:\n            continue\n        reversed_s = s[::-1]\n        if reversed_s in test_list and reversed_s != s and (reversed_s not in used):\n            used.add(s)\n            used.add(reversed_s)\n            count += 1\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    used = set()\n    for i in range(len(test_list)):\n        if test_list[i] in used:\n            continue\n        reversed_str = test_list[i][::-1]\n        if reversed_str in test_list and reversed_str != test_list[i]:\n            count += 1\n            used.add(reversed_str)\n            used.add(test_list[i])\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    used = set()\n    count = 0\n    for i in range(len(test_list)):\n        if test_list[i] not in used:\n            reversed_str = test_list[i][::-1]\n            if reversed_str != test_list[i] and reversed_str in test_list:\n                if reversed_str not in used:\n                    count += 1\n                    used.add(test_list[i])\n                    used.add(reversed_str)\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    used_indices = set()\n    count = 0\n    for i in range(len(test_list)):\n        if i in used_indices:\n            continue\n        for j in range(i + 1, len(test_list)):\n            if j in used_indices:\n                continue\n            if test_list[i] == test_list[j][::-1] and test_list[i] != test_list[j]:\n                count += 1\n                used_indices.add(i)\n                used_indices.add(j)\n                break\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    used_indices = set()\n    count = 0\n    for i in range(len(test_list)):\n        if i in used_indices:\n            continue\n        for j in range(i + 1, len(test_list)):\n            if j in used_indices:\n                continue\n            if test_list[i] == test_list[j][::-1] and test_list[i] != test_list[j]:\n                count += 1\n                used_indices.add(i)\n                used_indices.add(j)\n                break\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    used_indices = set()\n    for i in range(len(test_list)):\n        if i in used_indices:\n            continue\n        for j in range(i + 1, len(test_list)):\n            if j in used_indices:\n                continue\n            if test_list[i] == test_list[j][::-1] and test_list[i] != test_list[j]:\n                count += 1\n                used_indices.add(i)\n                used_indices.add(j)\n                break\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    used_indices = set()\n    for i in range(len(test_list)):\n        if i in used_indices:\n            continue\n        for j in range(i + 1, len(test_list)):\n            if j in used_indices:\n                continue\n            if test_list[i] == test_list[j][::-1] and test_list[i] != test_list[i][::-1]:\n                count += 1\n                used_indices.add(i)\n                used_indices.add(j)\n                break\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    used_indices = set()\n    count = 0\n    for i in range(len(test_list)):\n        if i in used_indices:\n            continue\n        for j in range(i + 1, len(test_list)):\n            if j in used_indices:\n                continue\n            if test_list[i] == test_list[j][::-1] and test_list[i] != test_list[i][::-1]:\n                used_indices.add(i)\n                used_indices.add(j)\n                count += 1\n                break\n    return count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/759", "requirement": "```python\ndef is_decimal(num: str) -> bool:\n    \"\"\"\n    Write a function to check whether a given string is a strictly positive decimal number \n    with exactly two digits after the decimal point. The input must adhere to the following rules:\n    - The number must not include a positive ('+') or negative ('-') sign.\n    - The number must not have leading zeros unless it is '0.xx'.\n    - The number must not have trailing zeros after the decimal point unless required to meet the precision of 2.\n    - The format must strictly match the pattern: one or more digits, followed by a dot ('.'), followed by exactly two digits.\n\n    Examples:\n    assert is_decimal('123.11') == True\n    assert is_decimal('-123.45') == False\n    assert is_decimal('+123.45') == False\n    assert is_decimal('123.0') == False\n    assert is_decimal('0.12') == True\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^(?!0\\\\d)\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^(?!0\\\\d+\\\\.\\\\d{2}$)\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^(([1-9]\\\\d*)|0)\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^(?!0\\\\d)(\\\\d+)\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num)) and (not num.startswith(('+', '-')))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^(?!0\\\\d)(\\\\d+)\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num)) and (not ('+' in num or '-' in num)) and (len(num.split('.')[1]) == 2)", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^(\\\\d+)\\\\.\\\\d{2}$'\n    if not re.match(pattern, num):\n        return False\n    integer_part = num.split('.')[0]\n    if integer_part != '0' and integer_part.startswith('0'):\n        return False\n    return True", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    if not pattern.match(num):\n        return False\n    if num[0] == '0' and len(num.split('.')[0]) > 1:\n        return False\n    return True", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^(\\\\d+)\\\\.(\\\\d{2})$')\n    match = pattern.match(num)\n    if not match:\n        return False\n    integer_part, fractional_part = match.groups()\n    if integer_part.startswith('0') and len(integer_part) > 1:\n        return False\n    return True", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    if not pattern.match(num):\n        return False\n    parts = num.split('.')\n    if len(parts[0]) > 1 and parts[0][0] == '0':\n        return False\n    return True", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    if not re.match(pattern, num):\n        return False\n    if num.count('.') != 1:\n        return False\n    integer_part, decimal_part = num.split('.')\n    if len(decimal_part) != 2:\n        return False\n    if integer_part.startswith('0') and len(integer_part) > 1:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    \"\"\"\n    Write a Python function to find the minimum difference between any two elements in a given array. \n\n    Requirements:\n    1. The input `arr` can be either a list or a tuple of integers. The function will internally convert tuples to lists for processing.\n    2. The parameter `n` is ignored and has no effect on the function's behavior. The function will always consider all elements in `arr`.\n    3. The function assumes that `arr` is a non-empty collection of integers with at least two elements. Behavior for empty arrays or arrays with fewer than two elements is undefined.\n    4. The function calculates the minimum absolute difference between any two elements in the array by:\n       - Sorting the array.\n       - Iterating through adjacent elements in the sorted array to find the smallest difference.\n    5. The function does not handle invalid input types (e.g., non-integer elements in `arr`).\n\n    Example:\n    assert find_min_diff((1, 5, 3, 19, 18, 25), 6) == 1\n    \"\"\"", "generated_programs": ["from typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    arr = list(arr)\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    arr_list = list(arr)\n    arr_list.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr_list)):\n        min_diff = min(min_diff, abs(arr_list[i] - arr_list[i - 1]))\n    return min_diff", "from typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    arr_list = list(arr)\n    arr_list.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr_list)):\n        min_diff = min(min_diff, abs(arr_list[i] - arr_list[i - 1]))\n    return min_diff", "from typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    arr_list = list(arr)\n    arr_list.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr_list)):\n        min_diff = min(min_diff, abs(arr_list[i] - arr_list[i - 1]))\n    return min_diff", "from typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    arr_list = list(arr)\n    arr_list.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr_list)):\n        diff = abs(arr_list[i] - arr_list[i - 1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        current_diff = abs(arr[i] - arr[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n    return min_diff", "code\nfrom typing import List, Union\n\ndef find_min_diff(arr: Union[List[int], tuple], n: int) -> int:\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(arr_sorted)):\n        diff = abs(arr_sorted[i] - arr_sorted[i - 1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/769", "requirement": "def Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Write a Python function to compute the symmetric difference between two lists.\n    The symmetric difference includes elements that are in either of the lists but not in both.\n    The result combines elements unique to the first list and elements unique to the second list.\n    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return sorted(list(symmetric_diff))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "code\nfrom typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/771", "requirement": "```python\ndef check_expression(expression: str) -> bool:\n    \"\"\"\n    Write a function to check if the given expression is balanced or not. \n    The function should determine if the expression contains properly balanced \n    pairs of parentheses-like symbols: '()', '{}', and '[]'. \n\n    Rules:\n    1. Only the characters '(', ')', '{', '}', '[', and ']' are considered for balancing.\n       Any other characters in the input string are ignored.\n    2. A pair is considered balanced if:\n       - Every opening symbol ('(', '{', '[') has a corresponding closing symbol \n         (')', '}', ']') in the correct order.\n       - No unmatched opening or closing symbols remain after processing the expression.\n    3. The function should return True if the expression is balanced according to the above rules, \n       and False otherwise.\n\n    Example:\n    assert check_expression(\"{()}[{}]\") == True\n    \"\"\"\n```", "generated_programs": ["def check_expression(expression: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or mapping[char] != stack.pop():\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    brackets = {'(': ')', '{': '}', '[': ']'}\n    for char in expression:\n        if char in brackets:\n            stack.append(char)\n        elif char in brackets.values():\n            if not stack or brackets[stack.pop()] != char:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in pairs.values():\n            stack.append(char)\n        elif char in pairs.keys():\n            if not stack or stack[-1] != pairs[char]:\n                return False\n            stack.pop()\n    return not stack"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/777", "requirement": "from typing import List\n\n\ndef find_sum(arr: List[int]) -> int:\n\"\"\"\nWrite a python function to find the sum of non-repeated elements in a given list.\nassert find_sum([1,2,3,1,1,4,5,6]) == 21\n\"\"\"", "generated_programs": ["from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = list(set(arr))\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = list(set(arr))\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = list(set(arr))\n    return sum(unique_elements)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/780", "requirement": "def find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to find all unique combinations of sums between pairs of tuples in the given tuple list.\n    For each pair of tuples (a, b) where a comes before b in the list, calculate a new tuple by summing the \n    corresponding elements of a and b. Return a list of these resulting tuples.\n\n    Example:\n    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            combinations.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            combinations.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            a, b = (test_list[i], test_list[j])\n            combinations.append((a[0] + b[0], a[1] + b[1]))\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            result.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            a = test_list[i]\n            b = test_list[j]\n            combinations.append((a[0] + b[0], a[1] + b[1]))\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            a = test_list[i]\n            b = test_list[j]\n            sum_tuple = (a[0] + b[0], a[1] + b[1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            a = test_list[i]\n            b = test_list[j]\n            sum_tuple = (a[0] + b[0], a[1] + b[1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            a = test_list[i]\n            b = test_list[j]\n            new_tuple = (a[0] + b[0], a[1] + b[1])\n            combinations.append(new_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    n = len(test_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            a = test_list[i]\n            b = test_list[j]\n            combined = (a[0] + b[0], a[1] + b[1])\n            combinations.append(combined)\n    return combinations"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/781", "requirement": "```python\ndef count_divisors(n: int) -> bool:\n    \"\"\"\n    Write a Python function to determine whether the count of divisors of a given integer `n` is even.\n\n    - The function should accept any integer input, including negative numbers and zero.\n    - For negative numbers, the function should compute the divisors of their positive counterpart by taking the absolute value of `n`.\n    - Divisors are defined as all positive integers `i` such that `n % i == 0`. Both `i` and its paired quotient `n // i` are counted as separate divisors unless `i * i == n` (i.e., when `i` is the square root of `n`), in which case it is counted only once.\n    - For zero, the function should return `True`, treating zero as having an even count of divisors (special case logic).\n    - The function should return `True` if the count of divisors is even, and `False` otherwise.\n    - The function assumes valid integer input and does not handle non-integer or invalid types.\n\n    Example:\n    assert count_divisors(10)  # 10 has 4 divisors (1, 2, 5, 10), which is even, so the result is True.\n    \"\"\"\n```", "generated_programs": ["import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "def count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    divisors_count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                divisors_count += 1\n            else:\n                divisors_count += 2\n    return divisors_count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return len(divisors) % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    divisor_count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                divisor_count += 1\n            else:\n                divisor_count += 2\n    return divisor_count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "def count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    sqrt_n = math.isqrt(n)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/784", "requirement": "```python\nfrom typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even and the first odd number in a given list.\n    \n    Requirements:\n    1. The function assumes the presence of at least one even and one odd number in `list1`.\n    2. If either an even or odd number is absent in the list, the function will raise a `StopIteration` exception.\n    3. The caller is responsible for handling cases where the input list lacks an even or odd number.\n    4. The function does not handle empty lists or lists with all even or all odd numbers internally.\n    \n    Example:\n    assert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return even * odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return even * odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_num = next((x for x in list1 if x % 2 == 0), None)\n    odd_num = next((x for x in list1 if x % 2 != 0), None)\n    if even_num is None or odd_num is None:\n        raise StopIteration\n    return even_num * odd_num", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/787", "requirement": "def text_match_three(text: str) -> re.Match:\n\"\"\"\nWrite a function that matches a string that has an a followed by three 'b'.\nassert not text_match_three(\"ac\")\n\"\"\"", "generated_programs": ["import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('ab{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('ab{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('ab{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'abbb'\n    return re.search(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'abbb'\n    return re.search(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = 'ab{3}'\n    return re.search(pattern, text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    pattern = re.compile('ab{3}')\n    return pattern.search(text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "```python\nimport re\n\ndef text_starta_endb(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches an entire string that starts with a single 'a', \n    is followed by zero or more characters that are NOT 'a', and ends with exactly one 'b'.\n    \n    - The match must encompass the entire string (use `re.fullmatch`).\n    - The string must start with exactly one 'a'.\n    - After the initial 'a', the string can contain any sequence of characters except 'a'.\n    - The string must end with exactly one 'b', with no additional characters after it.\n    - If the string does not meet these criteria, the function should return None.\n\n    Examples:\n    assert text_starta_endb(\"aabbbb\") is None\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = re.compile('^a[^a]*b$')\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = re.compile('^a[^a]*b$')\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = re.compile('^a[^a]*b$')\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.fullmatch(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/800", "requirement": "```python\ndef remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all space characters (' ') from a string.\n    The function should not remove other types of whitespace characters, such as tabs ('\\\\t') or newlines ('\\\\n').\n    \n    Example:\n    assert remove_all_spaces('python  program') == 'pythonprogram'\n    \n    Additional clarification:\n    - Input strings may contain a mix of spaces and other whitespace characters (e.g., tabs, newlines).\n    - Only space characters (' ') should be removed, while other whitespace characters should remain unchanged.\n    - For example, remove_all_spaces('\\\\t\\\\nno_spaces_hardcase\\\\t\\\\n') should return '\\\\t\\\\nno_spaces_hardcase\\\\t\\\\n'.\n    \"\"\"\n```", "generated_programs": ["def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return ''.join([char for char in text if char != ' '])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/801", "requirement": "```python\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a Python function to determine how many of the three given integers are equal.\n\n    The function should return:\n    - 3 if all three numbers are equal.\n    - 2 if exactly two numbers are equal.\n    - 0 if no numbers are equal.\n\n    Examples:\n    assert test_three_equal(1, 1, 1) == 3\n    assert test_three_equal(1, 2, 3) == 0\n    assert test_three_equal(1, 1, 2) == 2\n    \"\"\"\n```", "generated_programs": ["def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/6", "requirement": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the two numbers differ at exactly one bit position in their binary representation.\n    Two numbers are considered to differ at one bit position if the XOR of the two numbers results in a binary number that is a power of two or zero. \n    This means the XOR result must have at most one bit set to `1`.\n\n    Special cases:\n    - If the two numbers are identical (e.g., `a == b`), the XOR result is `0`, which is treated as valid and returns `True`.\n\n    Examples:\n    - differ_At_One_Bit_Pos(13, 9) == True\n    - differ_At_One_Bit_Pos(27, 27) == True\n    \"\"\"", "generated_programs": ["def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/11", "requirement": "```python\ndef remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Write a Python function to remove the first and last occurrence of a given character from the string.\n    \n    - The function should remove the first occurrence of the character `ch` from the string `s` if it exists.\n    - After removing the first occurrence, the function should remove the last occurrence of the character `ch` from the original positions in the string, provided the last occurrence is distinct from the first occurrence (i.e., `last_occurrence > first_occurrence`).\n    - If the character `ch` does not exist in the string `s`, the function should return the original string unchanged.\n    - If the first and last occurrences of the character `ch` are the same (e.g., the character appears only once), the function should remove it only once.\n    \n    Edge cases:\n    - If the character `ch` is not present in the string `s`, the function should return the original string unchanged.\n    - If the character `ch` appears only once in the string `s`, the function should remove it once.\n    - If the character `ch` appears multiple times, the function should remove the first and last occurrences as described.\n\n    Example:\n    assert remove_Occ(\"hello\", \"l\") == \"heo\"\n    \"\"\"\n```", "generated_programs": ["def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if last_index == first_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    else:\n        return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/16", "requirement": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if the input string matches the following criteria:\n    - The string consists of one or more sequences of lowercase letters.\n    - These sequences may optionally be joined by one or more underscores.\n    - Underscores must be correctly formatted, meaning they must separate sequences of lowercase letters (e.g., \"abc_def\" or \"abc_def_ghi\").\n    - Strings without underscores are valid if they consist entirely of lowercase letters (e.g., \"abcdef\").\n    - Strings containing invalid characters, uppercase letters, or incorrectly formatted substrings (e.g., \"abc_\", \"_abc\", \"ABC\") must return False.\n\n    Example:\n    assert text_lowercase_underscore(\"aab_cbbbc\") == True\n    \"\"\"", "generated_programs": ["import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = re.compile('^([a-z]+(_[a-z]+)*)$')\n    return bool(pattern.match(text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^([a-z]+)(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/20", "requirement": "def is_woodall(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given number is a Woodall number or not.\n\n    A Woodall number is defined as a number that can be expressed in the form:\n        W(n) = n * 2^n - 1\n    where `n` is a non-negative integer.\n\n    The function should:\n    1. Accept an integer input `num`.\n    2. Return `True` if `num` matches the formula for any non-negative integer `n`.\n    3. Return `False` if `num` does not match the formula for any non-negative integer `n`.\n    4. Handle edge cases such as negative numbers and zero:\n       - Negative numbers should categorically return `False` because Woodall numbers are defined only for non-negative integers `n`.\n       - Zero should return `False` as it does not satisfy the formula for any non-negative integer `n`.\n\n    Examples:\n    assert is_woodall(383) == True\n    ### Test 1\n    Input: [-1]\n    Expected Output: [False]\n    ### Test 2\n    Input: [0]\n    Expected Output: [False]\n    \"\"\"", "generated_programs": ["def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    max_n = math.floor(math.log2(num + 1)) if num > 0 else 0\n    for n in range(max_n + 1):\n        if n * 2 ** n - 1 == num:\n            return True\n    return False", "def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * (1 << n) - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        elif woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/58", "requirement": "```python\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given two integers have opposite signs.\n    Two integers are considered to have opposite signs if one is negative and the other is non-negative (including zero).\n    This function uses the XOR operation to determine if the sign bits of the two integers differ.\n\n    Examples:\n    assert opposite_Signs(1, -2) == True\n    assert opposite_Signs(0, -5) == True\n    \"\"\"\n```", "generated_programs": ["def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return (x < 0) != (y < 0)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/67", "requirement": "```python\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Write a function to compute the Bell number for a given non-negative integer `n`.\n    The Bell number represents the number of ways to partition a set of `n` elements.\n\n    Preconditions:\n    - The input `n` must be a non-negative integer (`n >= 0`).\n    - If `n` is negative, the function must explicitly raise an `IndexError` with the message \n      `'Input must be a non-negative integer.'`.\n\n    Implementation details:\n    - Use dynamic programming to compute Bell numbers based on their recurrence relation:\n      Bell(n, 0) = Bell(n-1, n-1)\n      Bell(n, k) = Bell(n-1, k-1) + Bell(n, k-1) for k > 0\n    - The function returns the Bell number for the given input `n`.\n\n    Example:\n    assert bell_number(2) == 2\n    \"\"\"\n```", "generated_programs": ["def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[1]]\n    for i in range(1, n + 1):\n        bell.append([bell[i - 1][-1]])\n        for j in range(1, i + 1):\n            bell[i].append(bell[i - 1][j - 1] + bell[i][j - 1])\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/71", "requirement": "def comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of integers in ascending order using the comb sort algorithm.\n    The function modifies the input list by repeatedly comparing and swapping elements \n    based on a shrinking gap size until the list is sorted. The gap size is reduced \n    using the formula gap = gap * 10 // 13, with a minimum gap of 1. The process continues \n    until no swaps are needed and the gap size is 1.\n\n    Example:\n    assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = max(1, int(gap / shrink))\n        if gap == 1:\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = max(1, int(gap / shrink))\n        if gap == 1:\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                if gap == 1:\n                    sorted = False\n    return nums"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/72", "requirement": "def dif_Square(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given number can be represented as the difference of two squares.\n\n    A number `n` can be represented as the difference of two squares (i.e., `a^2 - b^2` for integers `a` and `b`) if and only if:\n    - `n` is even, or\n    - `n % 4 == 1`.\n\n    This is based on the mathematical property that:\n    - Even numbers can always be expressed as the difference of two squares.\n    - Odd numbers that are congruent to 1 modulo 4 can also be expressed as the difference of two squares.\n\n    The function should return `True` if the given number satisfies these conditions, and `False` otherwise.\n\n    Examples:\n    - `assert dif_Square(5) == True` (5 is odd and satisfies `5 % 4 == 1`).\n    - `assert dif_Square(10) == True` (10 is even).\n\n    Constraints:\n    - The input `n` is a non-negative integer (i.e., `n >= 0`).\n    \"\"\"", "generated_programs": ["def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0:\n        return True\n    return n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0:\n        return True\n    if n % 4 == 1:\n        return True\n    return False", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0 or n % 4 == 1:\n        return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n    \"\"\"\n    Write a Python function to determine whether a given integer `n` is divisible by 11.\n    \n    The function should:\n    1. Accept a single integer input `n`.\n    2. Return `True` if `n` is divisible by 11, and `False` otherwise.\n    3. Handle negative integers by treating them the same as positive integers for divisibility checks.\n    4. Assume the input is always a valid integer. Non-integer inputs or other invalid types are not considered.\n    \n    Examples:\n    - For `n = 12345`, the function should return `False` because 12345 is not divisible by 11.\n    - For `n = -11`, the function should return `True` because -11 is divisible by 11.\n    \n    Edge cases:\n    - Negative numbers are valid inputs and should be checked for divisibility by 11.\n    - Zero (`n = 0`) is divisible by 11 and should return `True`.\n    \n    assert is_Diff(12345) == False\n    \"\"\"", "generated_programs": ["def is_Diff(n: int) -> bool:\n    return abs(n) % 11 == 0", "def is_Diff(n: int) -> bool:\n    return abs(n) % 11 == 0", "def is_Diff(n: int) -> bool:\n    return abs(n) % 11 == 0", "def is_Diff(n: int) -> bool:\n    return abs(n) % 11 == 0", "def is_Diff(n: int) -> bool:\n    return abs(n) % 11 == 0", "def is_Diff(n: int) -> bool:\n    return abs(n) % 11 == 0", "def is_Diff(n: int) -> bool:\n    return abs(n) % 11 == 0", "def is_Diff(n: int) -> bool:\n    return abs(n) % 11 == 0", "def is_Diff(n: int) -> bool:\n    return abs(n) % 11 == 0", "def is_Diff(n: int) -> bool:\n    return abs(n) % 11 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/84", "requirement": "```python\ndef sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the Newman-Conway sequence.\n\n    The Newman-Conway sequence is defined as follows:\n    - sequence(1) = 1\n    - sequence(2) = 1\n    - For n > 2: sequence(n) = sequence(sequence(n - 1)) + sequence(n - sequence(n - 1))\n\n    Constraints:\n    - The input `n` must be a positive integer (n >= 1).\n    - If `n` is less than 1, the function must raise a `ValueError` with an appropriate message.\n\n    Implementation:\n    - Use an iterative approach to compute the sequence efficiently for large values of `n`.\n    - Precompute the sequence values in a list up to the nth number.\n\n    Examples:\n    - assert sequence(10) == 6\n    - Input: [0]\n      Expected Output: ['ValueError']\n    - Input: [0]\n      Expected Output: ['ValueError']\n    - Input: [0]\n      Expected Output: ['ValueError']\n    \"\"\"\n```", "generated_programs": ["def sequence(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise ValueError('The input `n` must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/89", "requirement": "def closest_num(N: int) -> int:\n    \"\"\"\n    Write a function to find the closest smaller number than N. \n    The closest smaller number is defined as the result of subtracting 1 from the input N, regardless of whether N is positive, zero, or negative.\n    The input N is guaranteed to be an integer.\n\n    Examples:\n    assert closest_num(11) == 10\n    assert closest_num(0) == -1\n    assert closest_num(-5) == -6\n    \"\"\"", "generated_programs": ["def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/92", "requirement": "```python\ndef is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not.\n\n    A number is considered undulating if:\n    1. It alternates between exactly two distinct digits for its entire length.\n    2. The alternating digits are derived from the first two digits of the number.\n    3. The number has a minimum length of 3 digits.\n\n    Additional constraints:\n    - If the number has fewer than 3 digits, it cannot form an undulating pattern and should return False.\n    - If the first two digits of the number are the same, it cannot alternate and should return False.\n\n    Examples:\n    assert is_undulating(1212121) == True\n    assert is_undulating(12) == False\n    \"\"\"\n```", "generated_programs": ["def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i - 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != s[i % 2]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first = s[0]\n    second = s[1]\n    if first == second:\n        return False\n    for i in range(2, len(s)):\n        expected = first if i % 2 == 0 else second\n        if s[i] != expected:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or s[0] == s[1]:\n        return False\n    first, second = (s[0], s[1])\n    for i in range(2, len(s)):\n        if i % 2 == 0:\n            if s[i] != first:\n                return False\n        elif s[i] != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first = s[0]\n    second = s[1]\n    if first == second:\n        return False\n    for i in range(len(s)):\n        if i % 2 == 0:\n            if s[i] != first:\n                return False\n        elif s[i] != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first = s[0]\n    second = s[1]\n    if first == second:\n        return False\n    for i in range(2, len(s)):\n        expected_digit = first if i % 2 == 0 else second\n        if s[i] != expected_digit:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i in range(2, len(s)):\n        expected_digit = first if i % 2 == 0 else second\n        if s[i] != expected_digit:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if i % 2 == 0:\n            if s[i] != s[0]:\n                return False\n        elif s[i] != s[1]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i in range(2, len(s)):\n        expected_digit = first if i % 2 == 0 else second\n        if s[i] != expected_digit:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first = s[0]\n    second = s[1]\n    if first == second:\n        return False\n    for i in range(len(s)):\n        if i % 2 == 0 and s[i] != first:\n            return False\n        if i % 2 != 0 and s[i] != second:\n            return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.4}}
{"task_id": "Mbpp/95", "requirement": "```python\nfrom typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    \"\"\"\n    Write a Python function to find the length of the smallest list in a list of lists.\n\n    Requirements:\n    1. The input `lst` must be a non-empty list of lists. If `lst` is empty, the function must raise a `ValueError`.\n    2. If `lst` contains only empty sublists (e.g., `[[]]`), the function must raise a `ValueError`.\n    3. The function must compute the length of the smallest non-empty sublist in `lst`.\n    4. If `lst` contains valid sublists, the function must return the length of the smallest sublist.\n\n    Example:\n    assert Find_Min_Length([[1], [1, 2]]) == 1\n    \"\"\"\n```", "generated_programs": ["from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list is empty.')\n    if all((len(sublist) == 0 for sublist in lst)):\n        raise ValueError('All sublists are empty.')\n    return min((len(sublist) for sublist in lst if sublist))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must be non-empty.')\n    if all((len(sublist) == 0 for sublist in lst)):\n        raise ValueError('Input list contains only empty sublists.')\n    return min((len(sublist) for sublist in lst if sublist))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst or all((not sublist for sublist in lst)):\n        raise ValueError('Input list must be a non-empty list of non-empty sublists.')\n    return min((len(sublist) for sublist in lst if sublist))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list is empty.')\n    if all((len(sublist) == 0 for sublist in lst)):\n        raise ValueError('All sublists are empty.')\n    return min((len(sublist) for sublist in lst if sublist))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('The input list is empty.')\n    if all((len(sublist) == 0 for sublist in lst)):\n        raise ValueError('All sublists are empty.')\n    return min((len(sublist) for sublist in lst if sublist))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must be non-empty.')\n    if all((len(sublist) == 0 for sublist in lst)):\n        raise ValueError('Input list must contain at least one non-empty sublist.')\n    return min((len(sublist) for sublist in lst if sublist))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list is empty.')\n    if all((len(sublist) == 0 for sublist in lst)):\n        raise ValueError('All sublists are empty.')\n    min_length = min((len(sublist) for sublist in lst if sublist))\n    return min_length", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list cannot be empty.')\n    if all((len(sublist) == 0 for sublist in lst)):\n        raise ValueError('Input list contains only empty sublists.')\n    return min((len(sublist) for sublist in lst if sublist))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('The input list must be non-empty.')\n    if all((len(sublist) == 0 for sublist in lst)):\n        raise ValueError('The input list contains only empty sublists.')\n    return min((len(sublist) for sublist in lst if sublist))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must not be empty.')\n    if all((len(sublist) == 0 for sublist in lst)):\n        raise ValueError('Input list must contain at least one non-empty sublist.')\n    return min((len(sublist) for sublist in lst if sublist))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/96", "requirement": "```python\ndef divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given integer.\n    \n    Requirements:\n    - The input `n` can be any integer, including positive integers, negative integers, and zero.\n    - For positive integers, the function returns the count of positive divisors of `n`.\n    - For zero, the function returns `0` as zero has no positive divisors.\n    - For negative integers, the function returns `0` as negative numbers are not considered to have positive divisors.\n    \n    Examples:\n    assert divisor(15) == 4  # Positive integer case: divisors are [1, 3, 5, 15]\n    assert divisor(-15) == 0  # Negative integer case: no positive divisors\n    assert divisor(0) == 0  # Zero case: no positive divisors\n    \"\"\"\n```", "generated_programs": ["def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/103", "requirement": "```python\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Compute the Eulerian number a(n, m) using the recurrence relation and base cases.\n\n    The Eulerian number a(n, m) is defined as follows:\n    - If `m < 0` or `m >= n`, the result is 0 (invalid cases).\n    - If `n == 0` or `m == 0`, the base case results in 1.\n    - For other cases, the recurrence relation is:\n      a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m)\n\n    Constraints:\n    - Inputs must satisfy `n >= 0` and `0 <= m < n` for valid computation.\n    - The function handles invalid cases (`m < 0` or `m >= n`) by returning 0.\n\n    Examples:\n    - assert eulerian_num(3, 1) == 4\n    - Input: [5, 3], Expected Output: [26]\n    - Input: [0, 0], Expected Output: [0]\n    \"\"\"\n```", "generated_programs": ["def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if j == 0:\n                dp[i][j] = 1\n            elif i == 0 or j >= i:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    return dp[n][m]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "Mbpp/109", "requirement": "```python\ndef odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Write a Python function to calculate the number of rotations of a binary string `s` that result in an odd integer value, \n    when the binary string is rotated `n` times. \n\n    The rotation process is defined as follows:\n    - For each rotation index `i` (from 0 to `n-1`), the binary string `s` is rotated cyclically using modular arithmetic. \n      Specifically, the rotation is performed as:\n        rotated = s[-(i % len(s)):] + s[:-(i % len(s))]\n      where `len(s)` is the length of the binary string.\n    - The rotated binary string is converted to an integer using base-2 conversion, and its oddness is determined by checking \n      if the integer is not divisible by 2.\n\n    The function returns the count of rotations (out of `n` total rotations) that result in an odd integer value.\n\n    Additional clarifications:\n    - If `n` exceeds the length of the binary string (`len(s)`), rotations are computed cyclically using modular arithmetic, \n      ensuring redundancy is handled correctly.\n    - If `n = 0`, the function returns `0` since no rotations are performed.\n    - The binary string `s` is guaranteed to be non-empty and consists only of characters '0' and '1'.\n\n    Example:\n    assert odd_Equivalent(\"011001\", 6) == 3\n\n    Input and expected output examples:\n    ### Test 1\n    Input: ['101010', 1]\n    Expected Output: [0]\n    ### Test 2\n    Input: ['101010', 1]\n    Expected Output: [0]\n    ### Test 3\n    Input: ['1100', 8]\n    Expected Output: [4]\n    ### Test 4\n    Input: ['1', 6]\n    Expected Output: [6]\n    ### Test 5\n    Input: ['1100', 8]\n    Expected Output: [4]\n    \"\"\"\n```", "generated_programs": ["def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = s[-(i % length):] + s[:-(i % length)]\n        num = int(rotation, 2)\n        if num % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotated = s[-(i % length):] + s[:-(i % length)]\n        if int(rotated, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    for i in range(n):\n        rotation_index = i % len(s)\n        rotated = s[-rotation_index:] + s[:-rotation_index]\n        num = int(rotated, 2)\n        if num % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    if n == 0:\n        return 0\n    for i in range(n):\n        rotation_index = i % length\n        rotated = s[-rotation_index:] + s[:-rotation_index]\n        if int(rotated, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation] if rotation != 0 else s\n        num = int(rotated, 2)\n        if num % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    if n == 0:\n        return 0\n    count = 0\n    length = len(s)\n    for i in range(n):\n        shift = i % length\n        rotated = s[-shift:] + s[:-shift]\n        if int(rotated, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    if n == 0:\n        return 0\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation_index = i % length\n        rotated = s[-rotation_index:] + s[:-rotation_index]\n        if int(rotated, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation] if rotation != 0 else s\n        num = int(rotated, 2)\n        if num % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    if n == 0:\n        return 0\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation]\n        num = int(rotated, 2)\n        if num % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    if n == 0:\n        return 0\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated = s[-rotation:] + s[:-rotation] if rotation != 0 else s\n        num = int(rotated, 2)\n        if num % 2 != 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/111", "requirement": "```python\nfrom typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements in given nested lists.\n    \n    Requirements:\n    1. The function should find the intersection of elements across all sublists in the input `nestedlist`.\n    2. All sublists in `nestedlist` must be non-empty. If any sublist is empty or if `nestedlist` itself is empty, the function should raise a `TypeError`.\n    3. The function assumes that all elements in the sublists are integers.\n    4. The output should be a list of integers representing the common elements across all sublists, with no specific order guaranteed.\n    \n    Edge cases:\n    - Input `[[]]` or `[]` should raise a `TypeError`.\n    - If all sublists are non-empty but no common elements exist, the function should return an empty list (`[]`).\n\n    Example:\n    assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input nested list or any sublist cannot be empty.')\n    common = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common.intersection_update(sublist)\n    return list(common)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input nested list or any sublist is empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input must be a non-empty list of non-empty sublists.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise TypeError('Input nested list is empty.')\n    for sublist in nestedlist:\n        if not sublist:\n            raise TypeError('One of the sublists is empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input list or any sublist cannot be empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input nested list or any of its sublists cannot be empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('All sublists must be non-empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input list or any sublist cannot be empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((len(sublist) == 0 for sublist in nestedlist)):\n        raise TypeError('Input nested list or any sublist is empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or any((not sublist for sublist in nestedlist)):\n        raise TypeError('Input nested list or any of its sublists cannot be empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/113", "requirement": "def check_integer(text: str) -> Optional[bool]:\n\"\"\"\nWrite a function to check if a string represents an integer or not.\nassert check_integer(\"python\")==False\n\"\"\"", "generated_programs": ["from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    if not text.strip():\n        return None\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/118", "requirement": "```python\nfrom typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split strictly on the space character (' ').\n    The function should:\n    1. Split the input string only on explicit space characters (' '), not on other whitespace characters like tabs or newlines.\n    2. Preserve empty elements in the output list that result from consecutive spaces in the input string.\n    3. For an empty input string, return a list containing a single empty string (['']).\n    4. Handle edge cases such as strings with leading spaces, trailing spaces, or multiple consecutive spaces by preserving empty elements in the output list.\n\n    Example:\n    assert string_to_list(\"python programming\") == ['python', 'programming']\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    if not string:\n        return ['']\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ') if string else ['']", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    if not string:\n        return ['']\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ') if string else ['']", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ') if string else ['']", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ') if string else ['']", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    if not string:\n        return ['']\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ') if string else ['']", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    if not string:\n        return ['']\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ') if string != '' else ['']"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/120", "requirement": "```python\nfrom typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n    \n    Requirements:\n    1. The input `list1` must be a list of tuples, where each tuple contains exactly two numeric elements (integers).\n    2. If the input list is empty (`[]`), the function will raise a `ValueError` because the `max()` function cannot operate on an empty sequence.\n    3. If any tuple in the list does not contain exactly two elements, or contains non-numeric types, the function will raise a `ValueError` or `TypeError` due to tuple unpacking failure.\n    4. The function does not handle invalid inputs explicitly; it assumes the caller provides valid input and relies on Python's built-in error handling for edge cases.\n\n    Example:\n    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    \"\"\"\n    return max((abs(a * b) for a, b in list1))\n```", "generated_programs": ["from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list cannot be empty.')\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list cannot be empty.')\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list cannot be empty.')\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list cannot be empty.')\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list cannot be empty.')\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list cannot be empty.')\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('The input list is empty.')\n    return max((abs(a * b) for a, b in list1))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "```python\ndef amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of all amicable numbers within the range [2, limit].\n    \n    Amicable numbers are defined as pairs of integers (a, b) where:\n      - a != b\n      - sum_of_divisors(a) = b\n      - sum_of_divisors(b) = a\n    \n    The function should:\n      1. Consider only pairs where both numbers a and b lie within the range [2, limit].\n      2. Include both numbers of each valid amicable pair in the sum.\n    \n    Example:\n      - For limit = 999, the only amicable pair within the range is (220, 284).\n        Their sum is 220 + 284 = 504.\n    \n    Test cases:\n      assert amicable_numbers_sum(999) == 504\n      assert amicable_numbers_sum(284) == 504\n      assert amicable_numbers_sum(220) == 0\n    \"\"\"\n```", "generated_programs": ["def sum_of_divisors(n: int) -> int:\n    return sum((i for i in range(1, n) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a and (b <= limit):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def sum_of_divisors(n: int) -> int:\n    return sum((i for i in range(1, n) if n % i == 0))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a and (b <= limit):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a and (b <= limit):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def sum_of_divisors(n: int) -> int:\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def sum_of_divisors(n: int) -> int:\n    if n < 2:\n        return 0\n    total = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            if i == n // i:\n                total += i\n            else:\n                total += i + n // i\n        i += 1\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a:\n            if b <= limit:\n                amicable_sum += a + b\n    return amicable_sum", "import math\n\ndef sum_of_divisors(n: int) -> int:\n    if n < 2:\n        return 0\n    total = 1\n    sqrt_n = math.isqrt(n)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        if a in amicable_pairs:\n            continue\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a and (b <= limit):\n            amicable_sum += a + b\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            pair = tuple(sorted((a, b)))\n            amicable_pairs.add(pair)\n    return sum((sum(pair) for pair in amicable_pairs))", "def sum_of_divisors(n: int) -> int:\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    if limit < 2:\n        return 0\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            pair = tuple(sorted((a, b)))\n            amicable_pairs.add(pair)\n    return sum((sum(pair) for pair in amicable_pairs))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Calculate the polar angle (in radians) of the complex number `b` relative to the positive x-axis.\n    \n    The function computes the angle using the `math.atan2` function, which takes the imaginary part (`b.imag`) \n    and the real part (`b.real`) of the complex number `b` as inputs. The first argument `a` is ignored \n    and does not affect the computation.\n\n    Example:\n    - For `angle_complex(0, 1j)`, the angle of `b=1j` is calculated as `math.atan2(1, 0)`, which equals /2 \n      or approximately 1.5707963267948966.\n\n    Assertions:\n    assert math.isclose(angle_complex(0, 1j), 1.5707963267948966, rel_tol=0.001)\n\n    Input:\n    - `a`: A complex number (ignored in the computation).\n    - `b`: A complex number whose polar angle is to be calculated.\n\n    Output:\n    - Returns the polar angle of `b` in radians as a float.\n    \"\"\"", "generated_programs": ["import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/126", "requirement": "def sum(a: int, b: int) -> int:\n\"\"\"\nWrite a python function to find the sum of common divisors of two given numbers.\nassert sum(10,15) == 6\n\"\"\"", "generated_programs": ["import math\n\ndef sum(a: int, b: int) -> int:\n    gcd = math.gcd(a, b)\n    divisors = set()\n    for i in range(1, int(math.sqrt(gcd)) + 1):\n        if gcd % i == 0:\n            divisors.add(i)\n            divisors.add(gcd // i)\n    return sum(divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return divisors\n    return sum(common_divisors(a, b))", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def common_divisors(x):\n        divisors = set()\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                divisors.add(i)\n                divisors.add(x // i)\n        return divisors\n    divisors_a = common_divisors(a)\n    divisors_b = common_divisors(b)\n    common = divisors_a.intersection(divisors_b)\n    return sum(common)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def common_divisors(x, y):\n        gcd_value = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd_value)) + 1):\n            if gcd_value % i == 0:\n                divisors.add(i)\n                divisors.add(gcd_value // i)\n        return divisors\n    divisors = common_divisors(a, b)\n    return sum(divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return divisors\n    common_divs = get_common_divisors(a, b)\n    return sum(common_divs)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return sorted(divisors)\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\nfrom typing import List\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x: int, y: int) -> List[int]:\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return sorted(divisors)\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\nfrom typing import List\n\ndef get_common_divisors(a: int, b: int) -> List[int]:\n    gcd_value = math.gcd(a, b)\n    divisors = set()\n    for i in range(1, int(math.sqrt(gcd_value)) + 1):\n        if gcd_value % i == 0:\n            divisors.add(i)\n            divisors.add(gcd_value // i)\n    return sorted(divisors)\n\ndef sum(a: int, b: int) -> int:\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\nfrom typing import List\n\ndef find_divisors(n: int) -> List[int]:\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef sum(a: int, b: int) -> int:\n    a_divisors = find_divisors(a)\n    b_divisors = find_divisors(b)\n    common_divisors = set(a_divisors).intersection(b_divisors)\n    return sum(common_divisors)"], "result": {"repaired_passk": 0.6, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether the given matrix is a magic square.\n\n    A magic square is defined as a square matrix (n x n) where:\n    - The sum of each row, each column, and both main diagonals is the same.\n    - The matrix must be non-empty and all rows must have the same length as the number of rows (i.e., it must be square).\n\n    The function should return:\n    - False if the input matrix is empty, not square, or contains rows of inconsistent lengths.\n    - True if the matrix satisfies the magic square properties.\n\n    Examples:\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    assert magic_square_test([[]]) == False\n    assert magic_square_test([]) == False\n    \"\"\"", "generated_programs": ["code\nfrom typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix:\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    target = sum(my_matrix[0])\n    for i in range(1, n):\n        if sum(my_matrix[i]) != target:\n            return False\n    for j in range(n):\n        if sum((my_matrix[i][j] for i in range(n))) != target:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or any((len(row) != len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all(my_matrix):\n        return False\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target:\n            return False\n    diagonal1 = sum((my_matrix[i][i] for i in range(n)))\n    diagonal2 = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    return diagonal1 == target and diagonal2 == target", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix:\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((row for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all(my_matrix):\n        return False\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix:\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all(my_matrix):\n        return False\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all(my_matrix):\n        return False\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    diagonal1 = sum((my_matrix[i][i] for i in range(n)))\n    diagonal2 = sum((my_matrix[i][n - i - 1] for i in range(n)))\n    if diagonal1 != target_sum or diagonal2 != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all(my_matrix):\n        return False\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target_sum:\n        return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/130", "requirement": "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list of integers.\n\n    Requirements:\n    1. The input list `nums` must be a non-empty list of integers. If the list is empty, the function should raise a `ValueError`.\n    2. If two or more items have the same maximum frequency, the function will return the first item (in the order of appearance in the list) among those with the highest frequency.\n    3. The function guarantees that the output will always be an integer.\n\n    Example:\n    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2]) == 2\n    \"\"\"", "generated_programs": ["from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty.')\n    frequency = defaultdict(int)\n    for num in nums:\n        frequency[num] += 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num\n    return -1", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list must be non-empty.')\n    frequency = {}\n    for num in nums:\n        frequency[num] = frequency.get(num, 0) + 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list must be non-empty.')\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list must be non-empty.')\n    freq = defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n    max_freq = max(freq.values())\n    for num in nums:\n        if freq[num] == max_freq:\n            return num", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list must be non-empty.')\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list must be non-empty.')\n    freq = defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n    max_freq = max(freq.values())\n    for num in nums:\n        if freq[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list must be non-empty.')\n    frequency = defaultdict(int)\n    for num in nums:\n        frequency[num] += 1\n    max_freq = -1\n    result = None\n    for num in nums:\n        if frequency[num] > max_freq:\n            max_freq = frequency[num]\n            result = num\n    return result", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list must be non-empty.')\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list must be non-empty.')\n    frequency = {}\n    max_freq = 0\n    result = None\n    for num in nums:\n        frequency[num] = frequency.get(num, 0) + 1\n        if frequency[num] > max_freq:\n            max_freq = frequency[num]\n            result = num\n    return result", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list must be non-empty.')\n    frequency = {}\n    max_freq = 0\n    result = None\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n        if frequency[num] > max_freq:\n            max_freq = frequency[num]\n            result = num\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "Mbpp/137", "requirement": "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to calculate the ratio of zeroes to non-zeroes in an array of integers.\n    \n    The function should adhere to the following rules:\n    1. If the array contains no non-zero elements (i.e., all elements are zero or the array is empty), return `float('inf')` to represent an infinite ratio.\n    2. The ratio is defined as the count of zeroes divided by the count of non-zero elements.\n    3. The function should not raise exceptions for empty arrays; instead, it should handle them gracefully as described above.\n    \n    Example:\n    assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "import math\nfrom typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return float('inf')\n    return zero_count / non_zero_count", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "code\nfrom typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "Mbpp/138", "requirement": "```python\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given positive integer `n` can be represented \n    as a sum of multiple distinct non-zero powers of 2. \n\n    - A \"non-zero power of 2\" refers to values of the form \\(2^k\\) where \\(k > 0\\), such as 2, 4, 8, etc.\n    - The function should return `True` if `n` can be expressed as a sum of two or more distinct non-zero powers of 2.\n    - The function should return `False` for numbers that are exact powers of 2 (e.g., \\(2^1 = 2\\), \\(2^3 = 8\\)), \n      for `n = 0`, and for `n = 1`.\n\n    Examples:\n    - `assert is_Sum_Of_Powers_Of_Two(10) == True` because \\(10 = 2^1 + 2^3\\).\n    - `assert is_Sum_Of_Powers_Of_Two(1) == False` because \\(1 = 2^0\\), which is not a sum of multiple powers of 2.\n    - `assert is_Sum_Of_Powers_Of_Two(2) == False` because \\(2 = 2^1\\), which is a single power of 2.\n    - `assert is_Sum_Of_Powers_Of_Two(0) == False` because `0` cannot be expressed as a sum of powers of 2.\n    \"\"\"\n```", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n < 2:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 1 or n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n < 2:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/145", "requirement": "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the maximum absolute difference between any two elements in a given array.\n    \n    Preconditions:\n    - The input array `arr` must contain at least one element.\n    - If the input array is empty (`[]`), the function will raise a `ValueError`.\n    \n    Functionality:\n    - For a valid input array, the function computes the maximum (`max(arr)`) and minimum (`min(arr)`) values in the array, and returns their difference.\n    \n    Example:\n    assert max_Abs_Diff((2,1,5,3)) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must contain at least one element.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must contain at least one element.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must contain at least one element.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must contain at least one element.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('The input array must contain at least one element.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('The input array must contain at least one element.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('The input array must contain at least one element.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('The input array must contain at least one element.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must contain at least one element.')\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array must contain at least one element.')\n    return max(arr) - min(arr)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"\n    Write a function that returns integers x and y as a tuple (x, y) that satisfy the equation ax + by = n, \n    subject to the following constraints:\n    - Both x and y must be non-negative integers (x >= 0 and y >= 0).\n    - If multiple solutions exist, return the solution with the smallest non-negative x.\n    - If no solution exists, return None.\n\n    Examples:\n    assert find_solution(2, 3, 7) == (2, 1)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y >= 0 and y == int(y):\n            return (x, int(y))\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/222", "requirement": "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    \"\"\"\n    Write a function to check if all the elements in a tuple have the exact same data type.\n    \n    - The function should return True if all elements in the tuple have the same data type as determined by Python's `type()` function.\n    - For an empty tuple, the function should return True, as there are no conflicting types.\n    - For a tuple with one element, the function should also return True, since a single type is consistent.\n    - The function must strictly compare types without considering subclass relationships or type compatibility.\n    - The input to the function is guaranteed to be a tuple (no validation for incorrect input types is required).\n\nExample:\nassert check_type((5, 6, 7, 3, 5, 6)) == True\nassert check_type((5, 3.0)) == False\nassert check_type((5,)) == True\nassert check_type(()) == True\n\"\"\"", "generated_programs": ["from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(item) == first_type for item in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(element) == first_type for element in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(item) == first_type for item in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(element) == first_type for element in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(item) == first_type for item in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for item in test_tuple:\n        if type(item) != first_type:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/223", "requirement": "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n    Write a function that takes in a sorted array `arr` of integers, its length `n`, and an integer `x`, and returns whether `x` is the majority element in the array. \n\n    The majority element is defined as the element that occurs strictly more than `n // 2` times in the array. The function should perform a global count of occurrences of `x` in the array and check if this count exceeds `n // 2`.\n\n    Key details:\n    1. The array `arr` is sorted, but the function does not require leveraging the sorted property for optimized counting (e.g., binary search). A direct count of occurrences (`arr.count(x)`) is sufficient.\n    2. If `x` is not present in the array, the function should return `False`.\n    3. The function should return `False` if the count of `x` is exactly `n // 2` or less.\n    4. Edge cases, such as when `n` is 0 or `x` is not in the array, are handled by the global count logic.\n\n    Example:\n    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    count = arr.count(x)\n    return count > n // 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n    \"\"\"\n    Write a Python function that sets all even-indexed bits (starting from index 0) in the binary representation of a given positive integer `n` to `1`. \n    The function should only modify bits within the range of the number's binary length (i.e., up to `n.bit_length()`), preserving the original value of other bits.\n    \n    Constraints:\n    - The input `n` is a positive integer.\n    - Negative numbers or non-standard integer representations are not considered.\n    - The output is an integer, where the even-indexed bits in the binary representation of `n` are set to `1`.\n\n    Example:\n    assert even_bit_set_number(10) == 10\n    \"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length(), 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length(), 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = sum((1 << i for i in range(0, bit_length, 2)))\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length(), 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    for i in range(0, n.bit_length(), 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_length = n.bit_length()\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 0\n    bit_length = n.bit_length()\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n\"\"\"\nWrite a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nassert get_total_number_of_sequences(10, 4) == 4\n\"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def backtrack(index, last):\n        if index == n:\n            return 1\n        total = 0\n        for i in range(2 * last, m + 1):\n            total += backtrack(index + 1, i)\n        return total\n    return backtrack(0, 0)", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def helper(last, length):\n        if length == n:\n            return 1\n        total = 0\n        for i in range(2 * last, m + 1):\n            total += helper(i, length + 1)\n        return total\n    return sum((helper(i, 1) for i in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def dfs(start: int, length: int) -> int:\n        if length == n:\n            return 1\n        total = 0\n        for num in range(2 * start, m + 1):\n            total += dfs(num, length + 1)\n        return total\n    return sum((dfs(i, 1) for i in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    from functools import lru_cache\n\n    def dp(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for next_element in range(2 * last_element, m + 1):\n            total += dp(current_length + 1, next_element)\n        return total\n    return sum((dp(1, i) for i in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    from functools import lru_cache\n\n    def dp(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += dp(current_length + 1, i)\n        return total\n    result = 0\n    for i in range(1, m + 1):\n        result += dp(1, i)\n    return result", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def helper(current_seq: List[int]) -> int:\n        if len(current_seq) == n:\n            return 1\n        last_element = current_seq[-1] if current_seq else 0\n        total = 0\n        for next_element in range(2 * last_element, m + 1):\n            if next_element > m:\n                break\n            current_seq.append(next_element)\n            total += helper(current_seq)\n            current_seq.pop()\n        return total\n    return helper([])", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for length in range(2, n + 1):\n        for val in range(1, m + 1):\n            dp[length][val] = 0\n            for prev_val in range(1, val // 2 + 1):\n                dp[length][val] += dp[length - 1][prev_val]\n    return sum(dp[n][1:])", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum(dp[n][1:m + 1])", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.7}}
{"task_id": "Mbpp/244", "requirement": "def next_Perfect_Square(N: int) -> int:\n\"\"\"\nWrite a python function to find the next perfect square greater than a given number.\nassert next_Perfect_Square(35) == 36\n\"\"\"", "generated_programs": ["import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    next_sqrt = sqrt + 1\n    return next_sqrt * next_sqrt", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.isqrt(N)\n    next_square = (sqrt_N + 1) ** 2\n    return next_square", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    next_sq = sqrt + 1\n    return next_sq * next_sq", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt = math.isqrt(N)\n    return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.isqrt(N)\n    if root * root == N:\n        return (root + 1) ** 2\n    else:\n        return (root + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt = math.isqrt(N)\n    next_square = (sqrt + 1) ** 2\n    return next_square", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) * (sqrt + 1)\n    else:\n        return (sqrt + 1) * (sqrt + 1)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/247", "requirement": "```python\ndef lps(str1: str) -> int:\n    \"\"\"\n    Write a function to find the length of the longest palindromic subsequence in the given string.\n\n    Requirements:\n    - The input `str1` must be a non-empty string. If an empty string is provided, the function will raise an `IndexError`.\n    - All characters in the input string, including spaces and non-alphabetic characters, are treated as valid and considered part of the subsequence.\n    - The function calculates the length of the longest palindromic subsequence using dynamic programming.\n    - Single-character subsequences are considered palindromic.\n    - For substrings of length 2, if the characters match, their contribution to the subsequence length is `2`.\n    - For longer substrings, the function dynamically calculates the contribution of matched pairs based on previously computed results.\n    - If characters do not match, the function selects the maximum subsequence length possible by ignoring one character from either end.\n    - The function returns the integer length of the longest palindromic subsequence.\n\n    Example:\n    assert lps(\"TENS FOR TENS\") == 5\n    \"\"\"\n```", "generated_programs": ["def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/255", "requirement": "from typing import List, Tuple\n\ndef combinations_colors(l: List, n: int) -> List[Tuple]:\n    \"\"\"\n    Write a function that takes in a list of elements and an integer n, and generates all combinations of length n \n    where repetition of elements is allowed, but the order of elements in the combinations does not matter. \n    This corresponds to combinations *with replacement* in mathematical combinatorics. \n    The function returns a list of tuples, where each tuple represents a unique combination.\n\n    Example:\n    assert combinations_colors([\"Red\", \"Green\", \"Blue\"], 1) == [('Red',), ('Green',), ('Blue',)]\n    assert combinations_colors([\"Red\", \"Green\", \"Blue\"], 2) == [('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), \n                                                                ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Blue')]\n    \"\"\"", "generated_programs": [], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/259", "requirement": "def maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    \"\"\"\n    Write a function to maximize the given two tuples element-wise. \n    For each pair of tuples at the same position in test_tup1 and test_tup2, \n    create a new tuple where each element is the maximum of the corresponding elements \n    from the two input tuples. Return a tuple containing these new tuples.\n\n    Example:\n    assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(x, y) for x, y in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(x, y) for x, y in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "```python\ndef newman_prime(n: int) -> int:\n    \"\"\"\n    Compute the nth term of the NewmanShanksWilliams sequence (S(n)), defined by the recurrence relation:\n    S(0) = 1, S(1) = 1, and S(n) = 2 * S(n-1) + S(n-2) for n > 1.\n\n    Constraints:\n    - The input `n` must be a non-negative integer (n >= 0).\n    - If `n` is negative, the function raises a `ValueError`.\n    - If `n` is not an integer (e.g., a float or non-numeric type), the function raises a `TypeError`.\n\n    Note:\n    - This function computes the sequence term directly and does not filter for prime values.\n\n    Example:\n    assert newman_prime(3) == 7\n    \"\"\"\n```", "generated_programs": ["def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    s0, s1 = (1, 1)\n    for _ in range(2, n + 1):\n        s2 = 2 * s1 + s0\n        s0, s1 = (s1, s2)\n    return s1", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    s0, s1 = (1, 1)\n    for _ in range(2, n + 1):\n        s2 = 2 * s1 + s0\n        s0, s1 = (s1, s2)\n    return s1", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    s0, s1 = (1, 1)\n    for _ in range(2, n + 1):\n        s_next = 2 * s1 + s0\n        s0, s1 = (s1, s_next)\n    return s1", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('n must be an integer')\n    if n < 0:\n        raise ValueError('n must be a non-negative integer')\n    if n == 0 or n == 1:\n        return 1\n    s0, s1 = (1, 1)\n    for _ in range(2, n + 1):\n        s0, s1 = (s1, 2 * s1 + s0)\n    return s1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/264", "requirement": "```python\ndef dog_age(h_age: float) -> float:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years based on the following rules:\n    - For human age (h_age) <= 2, the dog's age is calculated as h_age * 10.5.\n    - For human age (h_age) > 2, the dog's age is calculated as 21 + (h_age - 2) * 4.\n    - The function accepts any float value for h_age, including negative, zero, and fractional values.\n    - Negative and zero values for h_age are treated as valid inputs, and the formula is applied directly without special handling.\n    \n    Examples:\n    - dog_age(12) == 61\n    - dog_age(-3) == -31.5\n    - dog_age(0) == 0.0\n    - dog_age(1.5) == 15.75\n    \n    assert dog_age(12) == 61\n    \"\"\"\n```", "generated_programs": ["def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/265", "requirement": "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Write a function that takes in a list `S` and a positive integer `step` and splits the list into `step` sublists. \n    Each sublist is formed by distributing elements of `S` in a round-robin manner based on their positions in the input list. \n    Specifically, the element at index `i` in `S` is added to the sublist at index `i % step`.\n\n    Preconditions:\n    - `step` must be a positive integer greater than zero.\n    - If `step` is zero or negative, the function should raise a `ValueError`.\n\n    The function returns a list of `step` sublists, where each sublist contains elements distributed cyclically from the input list.\n\n    Example:\n    assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('Step must be a positive integer greater than zero.')\n    result = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        result[i % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero')\n    sublists = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        sublists[i % step].append(element)\n    return sublists", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero.')\n    result = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        result[i % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero')\n    result = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        result[i % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('Step must be a positive integer greater than zero.')\n    result = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        result[i % step].append(item)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('Step must be a positive integer greater than zero.')\n    sublists = [[] for _ in range(step)]\n    for index, element in enumerate(S):\n        sublists[index % step].append(element)\n    return sublists", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('Step must be a positive integer greater than zero.')\n    result = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        result[i % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero')\n    result = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        result[i % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('Step must be a positive integer greater than zero.')\n    sublists = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        sublists[i % step].append(item)\n    return sublists", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer greater than zero.')\n    sublists = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        sublists[i % step].append(element)\n    return sublists"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/271", "requirement": "def even_Power_Sum(n: int) -> int:\n    \"\"\"\n    Write a Python function that takes an integer n and calculates the sum of the fifth powers \n    of the first n even natural numbers. The first n even natural numbers are defined as \n    2, 4, 6, ..., up to 2 * n.\n    Example:\n    assert even_Power_Sum(2) == 1056\n    \"\"\"", "generated_programs": ["def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/279", "requirement": "def is_num_decagonal(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the nth decagonal number using the formula: n * (4 * n - 3).\n    A decagonal number is a figurate number that represents a decagon. The nth decagonal number is derived from the formula.\n    Example:\n    assert is_num_decagonal(3) == 27\n    \"\"\"", "generated_programs": ["def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/286", "requirement": "from typing import List\n\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\"\"\"\nWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\nassert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    total_sum = sum(a)\n    max_ending_here = max_so_far = a[0]\n    for i in range(1, n * k):\n        current_element = a[i % n]\n        max_ending_here = max(current_element, max_ending_here + current_element)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    total_sum = sum(a)\n    if total_sum > 0:\n        return max_sub_array_sum(a) + (k - 1) * total_sum\n    else:\n        return max_sub_array_sum(a * min(k, 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr: List[int]) -> int:\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    total_sum = sum(a)\n    if k == 1:\n        return max_sub_array_sum(a)\n    elif total_sum > 0:\n        return max_sub_array_sum(a * 2) + total_sum * (k - 2)\n    else:\n        return max_sub_array_sum(a * 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return kadane(a * 2) if kadane(a * 2) > kadane(a) else kadane(a)\n    else:\n        return kadane(a * 2) + total_sum * (k - 2)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr: List[int]) -> int:\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    else:\n        max_kadane = kadane(a)\n        if total_sum > 0:\n            return max(max_kadane, total_sum * (k - 1) + kadane(a + a))\n        else:\n            return max(max_kadane, kadane(a + a))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    if k == 1:\n        return max_sub_array_sum(a)\n    total_sum = sum(a)\n    if total_sum <= 0:\n        return max_sub_array_sum(a * k)\n    else:\n        single_max = max_sub_array_sum(a)\n        return max(single_max, total_sum * (k - 1) + max_sub_array_sum(a), total_sum * (k - 2) + max_sub_array_sum(a + a))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    total_sum = sum(a)\n    if k == 1:\n        max_ending_here = max_so_far = a[0]\n        for i in range(1, n):\n            max_ending_here = max(a[i], max_ending_here + a[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    else:\n        max_ending_here = max_so_far = a[0]\n        for i in range(1, n * 2):\n            max_ending_here = max(a[i % n], max_ending_here + a[i % n])\n            max_so_far = max(max_so_far, max_ending_here)\n        if total_sum > 0:\n            return max_so_far + total_sum * (k - 2)\n        else:\n            return max_so_far", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    total_sum = sum(a)\n    max_prefix_sum = max_suffix_sum = current_prefix_sum = current_suffix_sum = 0\n    for num in a:\n        current_prefix_sum += num\n        max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n    for num in reversed(a):\n        current_suffix_sum += num\n        max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n    if total_sum > 0:\n        single_max = max_sub_array_sum(a)\n        return max(max_prefix_sum + max_suffix_sum + total_sum * (k - 2), single_max)\n    else:\n        return max_sub_array_sum(a * k)\n\ndef max_sub_array_sum(arr: List[int]) -> int:\n    max_current = max_global = arr[0]\n    for i in range(1, len(arr)):\n        max_current = max(arr[i], max_current + arr[i])\n        max_global = max(max_global, max_current)\n    return max_global", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    total_sum = sum(a)\n    if k == 1:\n        return kadane(a)\n    max_single = kadane(a)\n    if total_sum <= 0:\n        return max_single\n    else:\n        prefix_sum = suffix_sum = 0\n        max_prefix = max_suffix = float('-inf')\n        current_sum = 0\n        for num in a:\n            current_sum += num\n            if current_sum > max_prefix:\n                max_prefix = current_sum\n        current_sum = 0\n        for num in reversed(a):\n            current_sum += num\n            if current_sum > max_suffix:\n                max_suffix = current_sum\n        return max(max_single, max_prefix + max_suffix + total_sum * (k - 2))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    total_sum = sum(a)\n    max_prefix_sum = float('-inf')\n    max_suffix_sum = float('-inf')\n    current_prefix_sum = 0\n    current_suffix_sum = 0\n    max_sub_array_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum += num\n        if current_sum > max_sub_array_sum:\n            max_sub_array_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    if k == 1:\n        return max_sub_array_sum\n    for i in range(n):\n        current_prefix_sum += a[i]\n        if current_prefix_sum > max_prefix_sum:\n            max_prefix_sum = current_prefix_sum\n    for i in range(n - 1, -1, -1):\n        current_suffix_sum += a[i]\n        if current_suffix_sum > max_suffix_sum:\n            max_suffix_sum = current_suffix_sum\n    if total_sum > 0:\n        return max(max_sub_array_sum, max_prefix_sum + max_suffix_sum + total_sum * (k - 2))\n    else:\n        return max(max_sub_array_sum, max_prefix_sum + max_suffix_sum)"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.9, "original_passk": 0.7}}
{"task_id": "Mbpp/294", "requirement": "def max_val(listval: list) -> int:\n    \"\"\"\n    Write a function to find the maximum numeric value in a given heterogeneous list.\n    The list may contain elements of mixed types, including integers, floating-point numbers, and non-numeric values.\n    The function should consider only numeric values (integers and floating-point numbers) when determining the maximum value.\n    The list must contain at least one numeric value for the function to work correctly.\n    assert max_val(['Python', 3, 2, 4, 5, 'version']) == 5\n    \"\"\"", "generated_programs": ["def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    return max((item for item in listval if isinstance(item, (int, float))))", "def max_val(listval: list) -> int:\n    return max((item for item in listval if isinstance(item, (int, float))))", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [item for item in listval if isinstance(item, (int, float))]\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    return max(numeric_values)", "def max_val(listval: list) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    return max(numeric_values)", "from typing import List, Union\n\ndef max_val(listval: List[Union[int, float, str]]) -> int:\n    numeric_values = [x for x in listval if isinstance(x, (int, float))]\n    return max(numeric_values)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/300", "requirement": "def count_binary_seq(n: int) -> int:\n    \"\"\"\n    Write a function to find the count of all binary sequences of length 2n such that \n    the sum of the first n bits is equal to the sum of the last n bits. The function \n    calculates this count by summing the square of combinations of n bits taken k at \n    a time for all k from 0 to n.\n\n    Example:\n    assert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "from math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "from math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "from math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom functools import lru_cache\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return comb(n - 1, k) + comb(n - 1, k - 1)\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/301", "requirement": "```python\ndef dict_depth(d: dict) -> int:\n    \"\"\"\n    Write a function to find the depth of a dictionary. The depth is defined as the maximum level of nested dictionaries \n    starting from an empty dictionary at the base level (which has a depth of `1`). \n\n    - The input must be a dictionary. If the input is not a dictionary, the function should return a depth of `1`.\n    - If the dictionary is empty, it contributes a depth of `1`.\n    - If a dictionary contains nested dictionaries, the function should compute the depth recursively, considering the \n      maximum depth contributed by nested dictionaries.\n    - Non-dictionary values within the dictionary do not contribute to depth calculation and are ignored when determining depth.\n    - If the dictionary contains no nested dictionaries (i.e., all values are non-dictionary types), the depth is `1`.\n\n    Example:\n    assert dict_depth({'a':1, 'b': {'c': {'d': {}}}}) == 4\n    \"\"\"\n```", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 1\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 1\n    if not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 1\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 1\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 1\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 1\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 1\n    if not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 1\n    if not d:\n        return 1\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            current_depth = dict_depth(value) + 1\n            if current_depth > max_depth:\n                max_depth = current_depth\n    return max_depth", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 1\n    if not d:\n        return 1\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            current_depth = dict_depth(value) + 1\n            if current_depth > max_depth:\n                max_depth = current_depth\n    return max_depth", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 1\n    if not d:\n        return 1\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            current_depth = dict_depth(value) + 1\n            if current_depth > max_depth:\n                max_depth = current_depth\n    return max_depth"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/305", "requirement": "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return a tuple containing up to two words from a list of strings, \n    where each string is treated as a sentence containing words separated by spaces. \n    The function should identify words that start with the letter 'p' or 'P' (case-insensitive).\n\n    - Input: A list of strings, where each string may contain multiple words separated by spaces.\n    - Output: A tuple containing the first two words (in order of appearance) that start with 'p' or 'P'. \n      If fewer than two such words are found, the tuple will contain only the found words (e.g., one word or an empty tuple).\n    - Edge cases:\n      - If the input list is empty or contains no words starting with 'p' or 'P', return an empty tuple `()`.\n      - The function assumes all elements in the input list are strings; non-string inputs are not handled.\n\n    Example:\n    assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    return tuple(p_words)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/306", "requirement": "```python\nfrom typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum of an increasing subsequence that:\n    1. Includes elements from the start of the list up to the `index` position (inclusive).\n    2. Must include the `kth` element, where `k > index`.\n\n    The subsequence must satisfy the following conditions:\n    - The elements in the subsequence up to `index` must form a valid increasing sequence.\n    - The `kth` element must be added to the subsequence, and it must maintain the increasing order \n      (i.e., all elements in the subsequence before `k` must be less than `a[k]`).\n    - If no valid increasing subsequence exists up to `index` that can connect to `a[k]`, the result is simply `a[k]`.\n\n    Input validation:\n    - The list `a` must have at least `n` elements, where `n > 0`.\n    - `index` and `k` must be valid indices within the range `[0, n-1]`.\n    - `k` must be strictly greater than `index`.\n    - If any of these conditions are violated, the function raises an `IndexError`.\n\n    Edge cases:\n    - If `index == 0`, the subsequence can only include `a[0]` and `a[k]` if `a[0] < a[k]`.\n    - If no valid increasing subsequence exists before `k`, the output is `a[k]`.\n\n    Example:\n    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n <= 0 or index < 0 or k < 0 or (index >= n) or (k >= n) or (k <= index):\n        raise IndexError('Invalid indices or list length.')\n    max_sum = a[k]\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            current_sum = a[i]\n            for j in range(i + 1, index + 1):\n                if a[j] > a[i] and a[j] < a[k]:\n                    current_sum += a[j]\n            if current_sum + a[k] > max_sum:\n                max_sum = current_sum + a[k]\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n <= 0 or index < 0 or k < 0 or (index >= n) or (k >= n) or (k <= index):\n        raise IndexError('Invalid input parameters')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            dp[i] = a[i]\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[j] < a[i] and a[i] < a[k]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = max(dp) + a[k] if any(dp) else a[k]\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n <= 0 or index < 0 or k < 0 or (index >= n) or (k >= n) or (k <= index):\n        raise IndexError('Invalid indices.')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = a[k]\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i] + a[k])\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n <= 0 or index < 0 or k < 0 or (index >= n) or (k >= n) or (k <= index):\n        raise IndexError\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i] and dp[j] + a[i] > dp[i]:\n                    dp[i] = dp[j] + a[i]\n    max_sum = max(dp) if dp else 0\n    if max_sum > 0:\n        return max_sum + a[k]\n    else:\n        return a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n <= 0 or index < 0 or k < 0 or (index >= n) or (k >= n) or (k <= index):\n        raise IndexError('Invalid indices or list length')\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = -float('inf')\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    if max_sum != -float('inf'):\n        return max_sum + a[k]\n    else:\n        return a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n <= 0 or len(a) < n or index < 0 or (index >= n) or (k < 0) or (k >= n) or (k <= index):\n        raise IndexError('Invalid input parameters')\n    dp = [0] * n\n    dp[index] = a[index]\n    for i in range(index):\n        if a[i] < a[index]:\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = -float('inf')\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    if max_sum != -float('inf'):\n        return max_sum + a[k]\n    else:\n        return a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n <= 0 or index < 0 or k < 0 or (index >= n) or (k >= n) or (k <= index):\n        raise IndexError('Invalid indices or conditions.')\n    if index == 0:\n        return a[0] + a[k] if a[0] < a[k] else a[k]\n    dp = [a[i] for i in range(index + 1)]\n    for i in range(index + 1):\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = a[k]\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i] + a[k])\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n <= 0 or index < 0 or k >= n or (k <= index):\n        raise IndexError('Invalid input indices or list size.')\n\n    def find_max_sum(a: List[int], end: int, last_val: int) -> int:\n        dp = [0] * (end + 1)\n        for i in range(end + 1):\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i] and dp[j] + a[i] > dp[i]:\n                    dp[i] = dp[j] + a[i]\n            if a[i] > last_val:\n                max_sum = 0\n                for j in range(i + 1):\n                    if a[j] < last_val:\n                        max_sum = max(max_sum, dp[j])\n                if max_sum > 0:\n                    return max_sum + a[k]\n        return a[k]\n    return find_max_sum(a, index, a[k])", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n <= 0 or index >= n or k >= n or (k <= index):\n        raise IndexError('Invalid indices or length.')\n    if index == 0:\n        return a[k] if a[0] < a[k] else a[k]\n    dp = [0] * (index + 1)\n    dp[0] = a[0]\n    for i in range(1, index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i] and dp[j] + a[i] > dp[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = float('-inf')\n    for i in range(index + 1):\n        if dp[i] != 0 and a[i] < a[k]:\n            max_sum = max(max_sum, dp[i] + a[k])\n    return max(max_sum, a[k]) if max_sum != float('-inf') else a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if n <= 0 or index < 0 or k < 0 or (index >= n) or (k >= n) or (k <= index):\n        raise IndexError('Invalid indices or list size.')\n    if index == 0:\n        if a[0] < a[k]:\n            return a[0] + a[k]\n        else:\n            return a[k]\n    dp = [0] * (index + 1)\n    dp[0] = a[0]\n    for i in range(1, index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = -1\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k] if max_sum != -1 else a[k]"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.7, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/308", "requirement": "```python\nfrom typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest distinct products \n    obtained from all possible pairings (Cartesian product) of elements from two given lists, \n    where each product is calculated by multiplying one element from `nums1` and one \n    element from `nums2`. \n    \n    The function should:\n    1. Compute products for all pair combinations, considering all elements in both lists.\n    2. Select the top `N` largest distinct products, sorted in descending order.\n    3. Ensure the output list does not contain duplicate products, even if certain products \n       are derived from different pair combinations of elements.\n\n    Additional constraints:\n    - Both `nums1` and `nums2` should contain at least one element.\n    - `N` must be less than or equal to the number of distinct products obtainable \n      from all pairs.\n\n    Example assertion:\n    assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]\n    \"\"\"\n```", "generated_programs": ["from typing import List\nimport itertools\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for a, b in itertools.product(nums1, nums2):\n        products.add(a * b)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport itertools\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for a, b in itertools.product(nums1, nums2):\n        products.add(a * b)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport itertools\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for a, b in itertools.product(nums1, nums2):\n        products.add(a * b)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    distinct_products = sorted(products, reverse=True)\n    return distinct_products[:N]", "from typing import List\nimport itertools\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for n1, n2 in itertools.product(nums1, nums2):\n        products.add(n1 * n2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    largest_products = heapq.nlargest(N, products)\n    return sorted(largest_products, reverse=True)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/310", "requirement": "```python\ndef string_to_tuple(str1: str) -> tuple:\n    \"\"\"\n    Write a function to convert a given string to a tuple of characters, excluding spaces (' ').\n    The function should iterate through the input string and include only non-space characters in the resulting tuple.\n\n    Example:\n    assert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n\n    Edge cases:\n    - For an empty string (\"\"), the function should return an empty tuple ().\n    - For a string consisting only of spaces (\"     \"), the function should return an empty tuple ().\n    \"\"\"\n```", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the left-most unset bit in the binary representation of an integer `n`.\n    \n    The \"left-most unset bit\" refers to the most significant unset bit in the binary representation of `n`, starting from the highest bit index and moving toward the least significant bit. The function modifies `n` by setting this bit to 1 and returns the updated value.\n\n    Special cases:\n    - If `n` is -1 (all bits are set in two's complement representation), the function returns `n` unchanged.\n    - If `n` is 0, the function sets the most significant unset bit (the highest bit index) to 1 and returns the result.\n    - Negative numbers are handled in their two's complement binary representation.\n\n    Example:\n    assert set_left_most_unset_bit(10) == 14\n    \"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    mask = 1\n    while mask & n:\n        mask <<= 1\n        if mask == 0:\n            return n | 1 << n.bit_length()\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    mask = 1\n    while mask <= abs(n):\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    mask = 1\n    while mask <= abs(n):\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    mask = 1 << n.bit_length() - 1\n    while mask > 0:\n        if not n & mask:\n            return n | mask\n        mask >>= 1\n    return n | 1 << n.bit_length()", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    bit_length = n.bit_length()\n    for i in range(bit_length - 1, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n | 1 << bit_length", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    bit_length = n.bit_length()\n    for i in range(bit_length, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n | 1 << bit_length", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    bit_length = n.bit_length()\n    mask = 1 << bit_length\n    while mask > 0:\n        if n & mask == 0:\n            return n | mask\n        mask >>= 1\n    return n | 1 << bit_length", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    mask = 1 << n.bit_length() - 1\n    while mask > 0:\n        if n & mask == 0:\n            return n | mask\n        mask >>= 1\n    return n | 1 << n.bit_length()", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return n\n    bit_length = n.bit_length()\n    mask = 1 << bit_length\n    while mask > 0:\n        if n & mask == 0:\n            return n | mask\n        mask = mask >> 1\n    return n | 1 << bit_length"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/388", "requirement": "def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the highest power of 2 that is less than or equal to n.\n    \n    Constraints:\n    - The input `n` must be a positive integer (`n > 0`).\n    - If `n` is zero or negative, the function must raise a `ValueError`.\n    \n    Examples:\n    - assert highest_Power_of_2(10) == 8\n    \n    Edge case handling:\n    - For `n = 0`, the function must raise a `ValueError`.\n    - For `n < 0`, the function must raise a `ValueError`.\n    \"\"\"", "generated_programs": ["import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    return 2 ** math.floor(math.log2(n))", "import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    return 2 ** math.floor(math.log2(n))", "import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    return 2 ** math.floor(math.log2(n))", "import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    return 2 ** (n.bit_length() - 1)", "import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    return 2 ** (int(math.log2(n)) if n > 0 else 0)", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    power = 0\n    while 1 << power + 1 <= n:\n        power += 1\n    return 1 << power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/389", "requirement": "def find_lucas(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th Lucas number. The Lucas sequence is defined as:\n    - L(0) = 2\n    - L(1) = 1\n    - L(n) = L(n-1) + L(n-2) for n > 1\n\n    For negative inputs (n < 0), the function should return the Lucas number corresponding to the absolute value of n, effectively treating negative indices as their positive counterparts.\n\n    Examples:\n    - find_lucas(9) should return 76.\n    - find_lucas(-1) should return 1 (same as find_lucas(1)).\n    - find_lucas(0) should return 2.\n\n    assert find_lucas(9) == 76\n    \"\"\"", "generated_programs": ["def find_lucas(n: int) -> int:\n    n = abs(n)\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    n = abs(n)\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    n = abs(n)\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    n = abs(n)\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    n = abs(n)\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    n = abs(n)\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    n = abs(n)\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    n = abs(n)\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    n = abs(n)\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    n = abs(n)\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/392", "requirement": "```python\ndef get_max_sum(n: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum possible by using the given equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Requirements:\n    1. The function must handle non-negative integer inputs (`n >= 0`) only. Negative inputs (`n < 0`) are considered invalid and will result in undefined behavior (e.g., RecursionError).\n    2. The base case for recursion is defined as `f(0) = 0`. For any positive integer `n`, the function recursively evaluates the maximum result of the given equation until the base case is reached.\n    3. The function does not handle non-integer inputs. It is assumed that `n` is always an integer.\n    4. The function does not include explicit error handling for invalid inputs (e.g., `n < 0` or non-integer values). Invalid inputs may lead to recursion failure or undefined behavior.\n    \n    Example:\n    assert get_max_sum(60) == 106\n    \"\"\"\n```", "generated_programs": ["def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    recursive_sum = get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)\n    return max(recursive_sum, n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "from functools import lru_cache\n\ndef get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/410", "requirement": "```python\nfrom typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    \"\"\"\n    Write a function to find the minimum value among integers in a given heterogeneous list.\n    \n    The function filters the input list to retain only integers and computes the minimum value \n    among them. If the list is empty or contains no integers, the function raises a ValueError.\n\n    Constraints:\n    1. The input list can contain elements of any data type, but only integers are considered \n       for the computation.\n    2. If the list is empty or contains no integers, the function raises a ValueError.\n\n    Example:\n    assert min_val(['Python', 3, 2, 4, 5, 'version']) == 2\n    \"\"\"\n```", "generated_programs": ["from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    int_list = [x for x in listval if isinstance(x, int)]\n    if not int_list:\n        raise ValueError('No integers found in the list.')\n    return min(int_list)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('The list contains no integers.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('List is empty or contains no integers')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if type(x) == int]\n    if not integers:\n        raise ValueError('No integers found in the list')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list')\n    return min(integers)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/415", "requirement": "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Write a Python function to find a pair of integers from a given array that produces the highest product.\n    \n    Requirements:\n    1. The input array `arr` must be a list of integers.\n    2. If the input array has fewer than two elements, the function should return the default value `(0, 0)`.\n    3. The function should consider all integers in the array, including negative numbers, as valid candidates for forming pairs.\n    4. The output pair should be returned in the order in which the integers are encountered during traversal, without sorting or reordering based on magnitude.\n    5. If multiple pairs produce the same highest product, the function should return the first pair encountered during traversal.\n    6. The function does not impose constraints on computational efficiency; a nested traversal approach is acceptable.\n\n    Example:\n    assert max_Product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = float('-inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = float('-inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            curr_prod = arr[i] * arr[j]\n            if curr_prod > max_prod:\n                max_prod = curr_prod\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_product = float('-inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_product = arr[i] * arr[j]\n            if current_product > max_product:\n                max_product = current_product\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = float('-inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = float('-inf')\n    result_pair = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result_pair = (arr[i], arr[j])\n    return result_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_product = float('-inf')\n    pair = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_product = arr[i] * arr[j]\n            if current_product > max_product:\n                max_product = current_product\n                pair = (arr[i], arr[j])\n    return pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = float('-inf')\n    result = (0, 0)\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = float('-inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = -float('inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = float('-inf')\n    result_pair = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result_pair = (arr[i], arr[j])\n    return result_pair"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/418", "requirement": "```python\nfrom typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    \"\"\"\n    Write a Python function to find the sublist with the maximum length in a list of lists.\n    \n    Requirements:\n    - The input `lst` must be a list of lists, where each sublist contains strings.\n    - The function returns the sublist with the maximum length (i.e., the sublist containing the most elements).\n    - If the input list is empty, the function raises a `ValueError`.\n    - The function does not handle invalid inputs (e.g., non-list structures or lists containing non-list elements) and assumes the input adheres to the specified type.\n\n    Example:\n    assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']\n    \"\"\"\n    return max(lst, key=len)\n```", "generated_programs": ["from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list must not be empty')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list cannot be empty')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('The input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list cannot be empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('The input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty')\n    return max(lst, key=len)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/427", "requirement": "def change_date_format(dt: str) -> str:\n\"\"\"\nWrite a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\nassert change_date_format(\"2026-01-02\") == '02-01-2026'\n\"\"\"", "generated_programs": ["def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    return '-'.join(dt.split('-')[::-1])", "def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    return f'{parts[2]}-{parts[1]}-{parts[0]}'", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    date_obj = datetime.strptime(dt, '%Y-%m-%d')\n    return date_obj.strftime('%d-%m-%Y')", "def change_date_format(dt: str) -> str:\n    year, month, day = dt.split('-')\n    return f'{day}-{month}-{year}'", "def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    return f'{parts[2]}-{parts[1]}-{parts[0]}'", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    date_obj = datetime.strptime(dt, '%Y-%m-%d')\n    return date_obj.strftime('%d-%m-%Y')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    date_obj = datetime.strptime(dt, '%Y-%m-%d')\n    return date_obj.strftime('%d-%m-%Y')", "from typing import Union\n\ndef change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    return f'{parts[2]}-{parts[1]}-{parts[0]}'", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    date_obj = datetime.strptime(dt, '%Y-%m-%d')\n    return date_obj.strftime('%d-%m-%Y')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "```python\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find the directrix of a parabola given its coefficients in the standard form of a quadratic equation y = ax + bx + c.\n    \n    The directrix of a parabola is calculated using the formula:\n    directrix = (c - b / (4a)) - 1 / (4a)\n    \n    The function should return the directrix as an integer by truncating the result of the calculation to an integer.\n    \n    Example:\n    assert parabola_directrix(5, 3, 2) == -198\n    \"\"\"\n```", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return int(c - b ** 2 / (4 * a) - 1 / (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return int(directrix)", "import math\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return math.floor(directrix)", "import math\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return math.trunc(directrix)", "import math\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return math.floor(directrix) if directrix >= 0 else math.ceil(directrix)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/435", "requirement": "```python\ndef last_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the last digit of a given number.\n    The \"last digit\" is defined as the digit in the ones place of the number, ignoring the sign for negative numbers.\n    The function should handle both positive and negative integers by taking the absolute value of the input before extracting the last digit.\n    \n    Examples:\n    assert last_Digit(123) == 3\n    assert last_Digit(-456) == 6\n    \"\"\"\n```", "generated_programs": ["def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "code\n\ndef last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/448", "requirement": "```python\ndef cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of Perrin numbers up to and including the nth index.\n    \n    The Perrin sequence is defined as:\n    - P(0) = 3, P(1) = 0, P(2) = 2 (base cases).\n    - P(n) = P(n-2) + P(n-3) for n >= 3.\n    \n    The function should:\n    - Compute the sum of all Perrin numbers from P(0) to P(n) (inclusive).\n    - Handle non-negative integer inputs for `n`. If `n` is negative, return 0 as the sum.\n    \n    Examples:\n    - If n = 0, the sum is P(0) = 3.\n    - If n = 9, the sum is P(0) + P(1) + ... + P(9) = 49.\n    \n    Edge cases:\n    - For n = -1 or other negative values, the function should return 0.\n    - For n = 0, the function should return the sum of only P(0).\n    \n    assert cal_sum(9) == 49\n    \"\"\"\n```", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    perrin = [3, 0, 2]\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    perrin = [3, 0, 2]\n    if n < 3:\n        return sum(perrin[:n + 1])\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    p = [0] * (n + 1)\n    p[0], p[1], p[2] = (3, 0, 2)\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    p = [0] * (n + 1)\n    p[0] = 3\n    p[1] = 0\n    p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    p = [0] * (n + 1)\n    p[0] = 3\n    p[1] = 0\n    p[2] = 2\n    total = p[0] + p[1] + p[2]\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n        total += p[i]\n    return total", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    p = [0] * (n + 1)\n    p[0], p[1], p[2] = (3, 0, 2)\n    total = p[0] + p[1] + p[2]\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n        total += p[i]\n    return total", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    p = [0] * (n + 1)\n    p[0] = 3\n    p[1] = 0\n    p[2] = 2\n    total = p[0] + p[1] + p[2]\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n        total += p[i]\n    return total", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    perrin = [0] * (n + 1)\n    perrin[0] = 3\n    perrin[1] = 0\n    perrin[2] = 2\n    total = perrin[0] + perrin[1] + perrin[2]\n    for i in range(3, n + 1):\n        perrin[i] = perrin[i - 2] + perrin[i - 3]\n        total += perrin[i]\n    return total"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/450", "requirement": "def extract_string(str1: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract strings from a given list of string values where the length of each string matches the specified size.\n    assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "code\nfrom typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/451", "requirement": "```python\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all types of whitespace characters from the given string.\n    This includes spaces, tabs, newlines, and any other characters classified as whitespace.\n\n    assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'\n    \"\"\"\n```", "generated_programs": ["def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "import re\n\ndef remove_whitespaces(text1: str) -> str:\n    return re.sub('\\\\s+', '', text1)", "import re\n\ndef remove_whitespaces(text1: str) -> str:\n    return re.sub('\\\\s+', '', text1)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "```python\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if the input string contains at least one complete word \n    that includes the character 'z' anywhere within the word. A word is defined as a \n    sequence of alphanumeric characters bounded by word boundaries (e.g., spaces, \n    punctuation, or start/end of the string). The function should return True if such \n    a word exists, and False otherwise.\n\n    Examples:\n    - text_match_wordz(\"pythonz.\") == True\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    return any(('z' in word for word in words))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    return any(('z' in word for word in words))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word:\n            return True\n    return False", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    return any(('z' in word.lower() for word in words))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    return any(('z' in word for word in words))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word:\n            return True\n    return False", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word.lower():\n            return True\n    return False", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word:\n            return True\n    return False", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word:\n            return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/457", "requirement": "```python\nfrom typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a Python function to find the sublist having the minimum length in a given list of sublists.\n\n    Requirements:\n    1. The input `lst` must be a list of sublists, where each sublist can contain elements of any type.\n    2. If the `lst` is empty, the function should return an empty list (`[]`) without raising an error.\n    3. If there are multiple sublists with the same minimum length, the function should return the first sublist with the minimum length based on its order in the input list.\n    4. The function assumes the input is valid (i.e., all elements in `lst` are sublists) and does not perform input validation.\n\n    Example:\n    assert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]\n    \"\"\"\n```", "generated_programs": ["from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    return min(lst, key=len)", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    return min(lst, key=len)", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < len(min_sublist):\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < len(min_sublist):\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_list = lst[0]\n    for sublist in lst:\n        if len(sublist) < len(min_list):\n            min_list = sublist\n    return min_list", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < len(min_sublist):\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < len(min_sublist):\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < len(min_sublist):\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_len = len(lst[0])\n    min_list = lst[0]\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_list = sublist\n    return min_list", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_len = len(lst[0])\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_sublist = sublist\n    return min_sublist"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/460", "requirement": "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a Python function to get the first element of each sublist.\n    \n    Requirements:\n    - The input `lst` is a list of sublists.\n    - Each sublist in `lst` is expected to be non-empty.\n    - If an empty sublist is encountered, the function will raise an `IndexError` as per Python's default behavior.\n    - The function does not perform explicit error handling for empty sublists and assumes well-formed input.\n\n    Example:\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/462", "requirement": "```python\nfrom typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    \"\"\"\n    Write a function to find all possible subsets (combinations) of the elements of a given list.\n    \n    Requirements:\n    1. The input list `lst` consists of strings (`List[str]`).\n    2. The function should generate all subsets of the input list, including:\n       - The empty subset `[]`.\n       - Subsets of varying sizes, from 1 element up to the size of the input list.\n    3. Subsets must preserve the order of elements as they appear in the input list.\n    4. The output should not include permutations (different orderings of the same elements) or duplicate subsets.\n    5. The output must be a list of lists (`List[List[str]]`), where each inner list represents a subset.\n\n    Example:\n    assert combinations_list(['orange', 'red', 'green', 'blue']) == [\n        [], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], \n        ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], \n        ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], \n        ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']\n    ]\n    \"\"\"\n```", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for subset in combinations(lst, r):\n            result.append(list(subset))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    all_subsets = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            all_subsets.append(list(reversed(combo)))\n    return all_subsets", "from typing import List\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = [[]]\n    for item in lst:\n        new_subsets = []\n        for subset in result:\n            new_subsets.append(subset + [item])\n        result.extend(new_subsets)\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for subset in combinations(lst, r):\n            result.append(list(subset))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            all_combinations.append(list(combo))\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            all_combinations.append(list(combo))\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[str]) -> List[List[str]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            all_combinations.append(list(combo))\n    return all_combinations"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/463", "requirement": "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product subarray of the given array.\n\n    The function should:\n    1. Treat zeros as valid subarray components, contributing a product of 0 and resetting the subarray product computation when encountered.\n    2. Initialize `max_product`, `current_max`, and `current_min` using the first element of the array to ensure compatibility with edge cases, such as single-element arrays.\n    3. Consider all subarrays, including single elements, as valid for comparison, regardless of whether they contain zeros, negative numbers, or positive numbers.\n\n    Example:\n    assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112\n    Input: [[0]]\n    Expected Output: [0]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = current_max = current_min = arr[0]\n    for num in arr[1:]:\n        if num == 0:\n            current_max, current_min = (1, 1)\n            max_product = max(max_product, 0)\n            continue\n        temp = current_max\n        current_max = max(num, current_max * num, current_min * num)\n        current_min = min(num, temp * num, current_min * num)\n        max_product = max(max_product, current_max)\n    return max_product", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = current_max = current_min = arr[0]\n    for num in arr[1:]:\n        if num == 0:\n            current_max, current_min = (1, 1)\n            max_product = max(max_product, 0)\n            continue\n        temp = current_max\n        current_max = max(num, current_max * num, current_min * num)\n        current_min = min(num, temp * num, current_min * num)\n        max_product = max(max_product, current_max)\n    return max_product", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = current_max = current_min = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] == 0:\n            current_max = current_min = 0\n        else:\n            temp = current_max\n            current_max = max(arr[i], max(current_max * arr[i], current_min * arr[i]))\n            current_min = min(arr[i], min(temp * arr[i], current_min * arr[i]))\n        max_product = max(max_product, current_max)\n    return max_product", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = current_max = current_min = arr[0]\n    for num in arr[1:]:\n        if num == 0:\n            current_max, current_min = (1, 1)\n            max_product = max(max_product, 0)\n            continue\n        temp = current_max\n        current_max = max(num, num * current_max, num * current_min)\n        current_min = min(num, num * temp, num * current_min)\n        max_product = max(max_product, current_max)\n    return max_product", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    current_max = arr[0]\n    current_min = arr[0]\n    for num in arr[1:]:\n        if num == 0:\n            current_max = 1\n            current_min = 1\n            max_product = max(max_product, 0)\n            continue\n        temp = current_max\n        current_max = max(num, current_max * num, current_min * num)\n        current_min = min(num, temp * num, current_min * num)\n        max_product = max(max_product, current_max)\n    return max_product", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    current_max = arr[0]\n    current_min = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] == 0:\n            current_max = 0\n            current_min = 0\n        else:\n            temp = current_max\n            current_max = max(arr[i], arr[i] * current_max, arr[i] * current_min)\n            current_min = min(arr[i], arr[i] * temp, arr[i] * current_min)\n        max_product = max(max_product, current_max)\n    return max_product", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    current_max = arr[0]\n    current_min = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] == 0:\n            current_max = 1\n            current_min = 1\n            max_product = max(max_product, 0)\n            continue\n        temp = current_max\n        current_max = max(arr[i], current_max * arr[i], current_min * arr[i])\n        current_min = min(arr[i], temp * arr[i], current_min * arr[i])\n        max_product = max(max_product, current_max)\n    return max_product", "code\nfrom typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    current_max = arr[0]\n    current_min = arr[0]\n    for num in arr[1:]:\n        if num == 0:\n            current_max = 1\n            current_min = 1\n            max_product = max(max_product, 0)\n            continue\n        temp = current_max\n        current_max = max(num, current_max * num, current_min * num)\n        current_min = min(num, temp * num, current_min * num)\n        max_product = max(max_product, current_max)\n    return max_product", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    current_max = arr[0]\n    current_min = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] == 0:\n            current_max = 1\n            current_min = 1\n            max_product = max(max_product, 0)\n            continue\n        temp = current_max\n        current_max = max(arr[i], current_max * arr[i], current_min * arr[i])\n        current_min = min(arr[i], temp * arr[i], current_min * arr[i])\n        max_product = max(max_product, current_max)\n    return max_product", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    current_max = arr[0]\n    current_min = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] == 0:\n            current_max = 1\n            current_min = 1\n            max_product = max(max_product, 0)\n            continue\n        temp = current_max\n        current_max = max(arr[i], arr[i] * current_max, arr[i] * current_min)\n        current_min = min(arr[i], arr[i] * temp, arr[i] * current_min)\n        max_product = max(max_product, current_max)\n    return max_product"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/465", "requirement": "```python\ndef drop_empty(dict1: dict) -> dict:\n    \"\"\"\n    Write a function to drop items from a given dictionary where the value is strictly `None`.\n\n    An item is considered \"empty\" if its value is `None`. Values that are falsy in Python \n    but not `None` (e.g., `\"\"`, `0`, `False`) should not be removed.\n\n    Examples:\n    assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None}) == {'c1': 'Red', 'c2': 'Green'}\n\n    ### Test 1\n    Input: [{'c1': '', 'c2': None, 'c3': 'Blue'}]\n    Expected Output: [{'c1': '', 'c3': 'Blue'}]\n\n    ### Test 2\n    Input: [{'c1': '', 'c2': None, 'c3': 'Blue'}]\n    Expected Output: [{'c1': '', 'c3': 'Blue'}]\n    \"\"\"\n```", "generated_programs": ["def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product formed by multiplying numbers of a strictly increasing subsequence of the given array.\n    \n    Requirements:\n    1. The subsequence must be strictly increasing, meaning each subsequent number in the subsequence must be greater than the previous one. Repeated values are not allowed in the subsequence.\n    2. Only one subsequence is considered for maximizing the product, and overlapping subsequences are not allowed.\n    3. If the array is empty, the function should return 0.\n    4. The function should handle arrays containing negative or zero values appropriately, as these values may affect the product calculation.\n    \n    Example:\n    assert max_product([3, 100, 4, 5, 150, 6]) == 3000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [num for num in arr]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [num for num in arr]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [num for num in arr]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n        dp[i] = max(dp[i], arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [arr[i] for i in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    max_prod = [num for num in arr]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                max_prod[i] = max(max_prod[i], max_prod[j] * arr[i])\n    return max(max_prod)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    product = [1] * n\n    for i in range(n):\n        product[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                if product[j] * arr[i] > product[i]:\n                    product[i] = product[j] * arr[i]\n                    dp[i] = dp[j] + 1\n    return max(product)", "from typing import List\nimport itertools\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = float('-inf')\n    for r in range(1, len(arr) + 1):\n        for seq in itertools.combinations(arr, r):\n            if list(seq) == sorted(seq) and len(seq) == len(set(seq)):\n                current_prod = 1\n                for num in seq:\n                    current_prod *= num\n                if current_prod > max_prod:\n                    max_prod = current_prod\n    return max_prod if max_prod != float('-inf') else 0", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    product = [1] * n\n    for i in range(n):\n        product[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                if dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    product[i] = product[j] * arr[i]\n                elif dp[j] + 1 == dp[i]:\n                    product[i] = max(product[i], product[j] * arr[i])\n    return max(product) if max(product) != 1 else 0", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/472", "requirement": "```python\nfrom typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given list contains consecutive numbers or not.\n    \n    The function should adhere to the following rules:\n    1. A list is considered to contain consecutive numbers if, when sorted, it matches a range of integers \n       starting from the minimum value in the list to the maximum value in the list (inclusive), with no gaps.\n    2. The input list must contain only integers. Non-integer values or special values (e.g., None) are invalid.\n    3. The function should raise a ValueError for invalid inputs, including:\n       - An empty list.\n       - Lists containing non-integer values.\n    4. Duplicate values in the list are allowed, but they must form a valid consecutive sequence when sorted.\n    5. For valid input, the function returns:\n       - True if the list contains consecutive numbers.\n       - False otherwise.\n\n    Example:\n    assert check_Consecutive([1, 2, 3, 4, 5]) == True\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Input list cannot be empty.')\n    if not all((isinstance(x, int) for x in l)):\n        raise ValueError('Input list must contain only integers.')\n    sorted_l = sorted(l)\n    return sorted_l == list(range(sorted_l[0], sorted_l[-1] + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid.')\n    if not all((isinstance(x, int) for x in l)):\n        raise ValueError('List contains non-integer values.')\n    sorted_list = sorted(l)\n    return sorted_list == list(range(sorted_list[0], sorted_list[-1] + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('The list cannot be empty.')\n    if not all((isinstance(x, int) for x in l)):\n        raise ValueError('The list must contain only integers.')\n    sorted_list = sorted(l)\n    return sorted_list == list(range(sorted_list[0], sorted_list[-1] + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('The list is empty.')\n    if not all((isinstance(x, int) for x in l)):\n        raise ValueError('The list contains non-integer values.')\n    sorted_list = sorted(l)\n    return sorted_list == list(range(sorted_list[0], sorted_list[-1] + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Input list cannot be empty.')\n    if not all((isinstance(i, int) for i in l)):\n        raise ValueError('Input list must contain only integers.')\n    sorted_l = sorted(l)\n    min_val, max_val = (sorted_l[0], sorted_l[-1])\n    return sorted_l == list(range(min_val, max_val + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('The list must not be empty.')\n    if not all((isinstance(x, int) for x in l)):\n        raise ValueError('The list must contain only integers.')\n    sorted_l = sorted(l)\n    min_val = sorted_l[0]\n    max_val = sorted_l[-1]\n    expected_range = list(range(min_val, max_val + 1))\n    return sorted_l == expected_range", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('List cannot be empty.')\n    if not all((isinstance(item, int) for item in l)):\n        raise ValueError('List must contain only integers.')\n    sorted_list = sorted(l)\n    min_val, max_val = (sorted_list[0], sorted_list[-1])\n    return sorted_list == list(range(min_val, max_val + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Input list cannot be empty.')\n    if not all((isinstance(x, int) for x in l)):\n        raise ValueError('Input list must contain only integers.')\n    sorted_l = sorted(l)\n    min_val = sorted_l[0]\n    max_val = sorted_l[-1]\n    expected_range = range(min_val, max_val + 1)\n    return sorted_l == list(expected_range)", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Input list cannot be empty.')\n    if not all((isinstance(i, int) for i in l)):\n        raise ValueError('Input list must contain only integers.')\n    sorted_list = sorted(l)\n    min_val = sorted_list[0]\n    max_val = sorted_list[-1]\n    expected_range = range(min_val, max_val + 1)\n    sorted_range = list(expected_range)\n    return sorted_list == sorted_range", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Input list cannot be empty.')\n    if not all((isinstance(x, int) for x in l)):\n        raise ValueError('Input list must contain only integers.')\n    sorted_l = sorted(l)\n    min_val = sorted_l[0]\n    max_val = sorted_l[-1]\n    expected_range = range(min_val, max_val + 1)\n    actual_sequence = sorted_l\n    return list(expected_range) == actual_sequence"], "result": {"repaired_passk": 0.8, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/473", "requirement": "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    \"\"\"\n    Write a function to find the intersection of tuples from two lists, where tuples are compared after normalizing their sub-elements by sorting. \n    The normalization ensures that tuples with the same elements, irrespective of their order, are treated as equivalent. \n    The intersection is calculated at the tuple level, preserving the identity of tuples as ordered sequences post-normalization. \n    Tuples with varying lengths are supported, and normalization applies to all tuples in the input lists.\n\n    Example:\n    assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)], [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}\n    \"\"\"", "generated_programs": ["from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_list1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_list2 = {tuple(sorted(t)) for t in test_list2}\n    intersection = normalized_list1 & normalized_list2\n    return intersection", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_set1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_set2 = {tuple(sorted(t)) for t in test_list2}\n    intersection = normalized_set1 & normalized_set2\n    return intersection", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_list1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_list2 = {tuple(sorted(t)) for t in test_list2}\n    intersection = normalized_list1 & normalized_list2\n    return intersection", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_list1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_list2 = {tuple(sorted(t)) for t in test_list2}\n    return normalized_list1.intersection(normalized_list2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_list1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_list2 = {tuple(sorted(t)) for t in test_list2}\n    return {tuple(t) for t in normalized_list1.intersection(normalized_list2)}", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_set1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_set2 = {tuple(sorted(t)) for t in test_list2}\n    intersection_set = normalized_set1 & normalized_set2\n    return intersection_set", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_set1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_set2 = {tuple(sorted(t)) for t in test_list2}\n    intersection = normalized_set1.intersection(normalized_set2)\n    return {tuple(sorted(t)) for t in intersection}", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalize = lambda t: tuple(sorted(t))\n    set1 = set(map(normalize, test_list1))\n    set2 = set(map(normalize, test_list2))\n    return set((tuple(sorted(t)) for t in set1.intersection(set2)))", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_list1 = [tuple(sorted(t)) for t in test_list1]\n    normalized_list2 = [tuple(sorted(t)) for t in test_list2]\n    set1 = set(normalized_list1)\n    set2 = set(normalized_list2)\n    intersection = set1.intersection(set2)\n    return intersection"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/476", "requirement": "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of the largest and smallest value in a given array.\n    The input array `nums` must be non-empty and contain valid integers. If the input array is empty, the function should raise a `ValueError`.\n    Example:\n    assert big_sum([1, 2, 3]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array must be non-empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array must not be empty')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array must be non-empty')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array must be non-empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array must be non-empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array must be non-empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input array must be non-empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array must be non-empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array must be non-empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array must be non-empty')\n    return max(nums) + min(nums)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/478", "requirement": "```python\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove all individual lowercase alphabetic characters \n    from a given string while preserving uppercase alphabetic characters and \n    non-alphabetic characters exactly as they appear.\n\n    The function should:\n    1. Remove each lowercase alphabetic character (e.g., 'a', 'b', 'c', etc.) \n       from the input string.\n    2. Preserve all uppercase alphabetic characters (e.g., 'A', 'B', 'C', etc.).\n    3. Preserve all non-alphabetic characters (e.g., digits, punctuation, spaces) \n       without modification.\n\n    Examples:\n    assert remove_lowercase(\"PYTHon\") == \"PYTH\"\n    assert remove_lowercase(\"123PYthON\") == \"123PYON\"\n    \"\"\"\n```", "generated_programs": ["def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join((char for char in str1 if not char.islower()))", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not (char.isalpha() and char.islower())])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/479", "requirement": "def first_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the first digit of a given number.\n    \n    Constraints:\n    1. The input `n` must be a non-negative integer (0 or greater).\n    2. If `n` is negative, the function must raise a `ValueError`.\n    3. The \"first digit\" refers to the leftmost digit in the string representation of the number.\n\n    Example:\n    assert first_Digit(123) == 1\n    \"\"\"", "generated_programs": ["def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return int(str(n)[0])", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('The input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/559", "requirement": "```python\nfrom typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Write a function to find the sum of the largest contiguous sublist in the given list.\n\n    Requirements:\n    1. The input list `a` must not be empty, and `size` must be greater than 0. If either condition is violated, the function will raise an `IndexError`.\n    2. The parameter `size` must be equal to the length of the input list `a`. If `size != len(a)`, the behavior is undefined.\n    3. If the input list contains only negative values, the function will return the least negative single element as the sum of the largest contiguous sublist.\n    4. The function uses Kadane's algorithm to compute the sum of the largest contiguous sublist.\n\n    Example:\n    assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size <= 0 or size != len(a):\n        raise IndexError('Invalid input conditions')\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size <= 0:\n        raise IndexError\n    if size != len(a):\n        return -1\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size <= 0:\n        raise IndexError('Input list must not be empty and size must be greater than 0.')\n    if size != len(a):\n        raise IndexError('Size must be equal to the length of the input list.')\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size <= 0:\n        raise IndexError('Invalid input parameters')\n    if size != len(a):\n        raise IndexError('Size must be equal to the length of the list')\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size <= 0:\n        raise IndexError('Invalid input: list is empty or size is non-positive')\n    if size != len(a):\n        raise IndexError('Size does not match the length of the list')\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        max_global = max(max_global, max_current)\n    return max_global", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size <= 0:\n        raise IndexError('Input list must not be empty and size must be greater than 0.')\n    if size != len(a):\n        raise ValueError('Size must be equal to the length of the input list.')\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        max_global = max(max_global, max_current)\n    return max_global", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size <= 0:\n        raise IndexError('The input list must not be empty, and size must be greater than 0.')\n    if size != len(a):\n        raise ValueError('The size must be equal to the length of the input list.')\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size <= 0:\n        raise IndexError('Invalid input: list is empty or size is not greater than 0.')\n    if size != len(a):\n        raise IndexError('Size does not match the length of the list.')\n    max_sum = a[0]\n    current_sum = a[0]\n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "code\nfrom typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size <= 0:\n        raise IndexError('Invalid input: list is empty or size is non-positive.')\n    if size != len(a):\n        raise ValueError('Size must be equal to the length of the input list.')\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if not a or size <= 0:\n        raise IndexError('Input list must not be empty and size must be greater than 0.')\n    if size != len(a):\n        raise IndexError('Size must be equal to the length of the input list.')\n    max_so_far = a[0]\n    max_ending_here = a[0]\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/564", "requirement": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function that takes a list of integers `arr` and an integer `n` representing the length of the list. \n    The function counts the number of possible unordered pairs of elements in the list where the two elements are unequal. \n\n    - An unordered pair is defined as a combination of two elements from the list, regardless of their order.\n    - The function considers all possible pairs formed by the elements in the list, including contributions from duplicate values.\n    - Pairs formed by identical elements (e.g., [1, 1]) are excluded from the count.\n\n    Example:\n    assert count_Pairs([1, 2, 1], 3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for a, b in combinations(arr, 2) if a != b))", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for a, b in combinations(arr, 2) if a != b))", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for a, b in combinations(arr, 2) if a != b))", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return len([pair for pair in combinations(arr, 2) if pair[0] != pair[1]])", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    unique_pairs = list(combinations(arr, 2))\n    count = sum((1 for a, b in unique_pairs if a != b))\n    return count", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    pairs = list(combinations(arr, 2))\n    count = 0\n    for pair in pairs:\n        if pair[0] != pair[1]:\n            count += 1\n    return count", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    pairs = list(combinations(arr, 2))\n    count = 0\n    for pair in pairs:\n        if pair[0] != pair[1]:\n            count += 1\n    return count", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    pairs = combinations(arr, 2)\n    count = 0\n    for pair in pairs:\n        if pair[0] != pair[1]:\n            count += 1\n    return count", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    unique_pairs = list(combinations(arr, 2))\n    count = 0\n    for pair in unique_pairs:\n        if pair[0] != pair[1]:\n            count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    from collections import Counter\n    cnt = Counter(arr)\n    total_pairs = n * (n - 1) // 2\n    same_pairs = sum((v * (v - 1) // 2 for v in cnt.values()))\n    return total_pairs - same_pairs"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/580", "requirement": "```python\ndef extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Write a function to remove odd integer elements from a nested mixed tuple while preserving the original tuple structure.\n\n    Rules:\n    - An \"odd integer\" is defined as an integer `item` where `item % 2 != 0`.\n    - Non-integer elements (e.g., strings, floats) are preserved without modification.\n    - Nested tuples are recursively traversed, and odd integers are removed at all levels of nesting.\n    - Tuples that become empty after filtering are retained as empty tuples in the output, at all levels of nesting.\n    - The function ensures that the nesting structure of the input tuple is preserved in the output, even if subtuples become empty.\n    - The input and output must strictly conform to tuple types, and the function should handle only tuple inputs.\n\n    Example:\n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"\n```", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n\n    def traverse(t):\n        if isinstance(t, tuple):\n            return tuple((traverse(item) for item in t if not (isinstance(item, int) and item % 2 != 0)))\n        return t\n    return traverse(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 != 0:\n            continue\n        else:\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int):\n            if item % 2 == 0:\n                result.append(item)\n        else:\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 != 0:\n            continue\n        else:\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n        elif not isinstance(item, int):\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n        elif not isinstance(item, int):\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            new_tuple = extract_even(item)\n            result.append(new_tuple)\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n        elif not isinstance(item, int):\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_elements(element):\n        if isinstance(element, int) and element % 2 != 0:\n            return None\n        if isinstance(element, tuple):\n            return tuple(filter(lambda x: x is not None, (filter_elements(item) for item in element)))\n        return element\n    return tuple(filter(lambda x: x is not None, (filter_elements(item) for item in test_tuple)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even(item):\n        if isinstance(item, tuple):\n            return tuple((filter_even(sub_item) for sub_item in item))\n        elif isinstance(item, int):\n            return item if item % 2 == 0 else None\n        else:\n            return item\n    filtered = filter_even(test_tuple)\n    return tuple((item for item in filtered if item is not None))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even(item):\n        if isinstance(item, tuple):\n            return tuple((filter_even(x) for x in item))\n        elif isinstance(item, int) and item % 2 != 0:\n            return None\n        else:\n            return item\n    filtered = filter_even(test_tuple)\n    if isinstance(filtered, tuple):\n        return tuple((x for x in filtered if x is not None))\n    else:\n        return filtered if filtered is not None else ()"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n\"\"\"\nWrite a python function to find the surface area of a square pyramid with a given base edge and height.\nassert surface_Area(3,4) == 33\n\"\"\"", "generated_programs": ["import math\n\ndef surface_Area(b: float, s: float) -> float:\n    slant_height = math.sqrt(s ** 2 + (b / 2) ** 2)\n    base_area = b ** 2\n    lateral_area = 2 * b * slant_height\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    slant_height = math.sqrt(s ** 2 + (b / 2) ** 2)\n    base_area = b ** 2\n    lateral_area = 2 * b * slant_height\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    slant_height = math.sqrt((b / 2) ** 2 + s ** 2)\n    base_area = b ** 2\n    lateral_area = 2 * b * slant_height\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    slant_height = math.sqrt((b / 2) ** 2 + s ** 2)\n    base_area = b ** 2\n    lateral_area = 2 * b * slant_height\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    slant_height = math.sqrt((b / 2) ** 2 + s ** 2)\n    lateral_area = 2 * b * slant_height\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    slant_height = math.sqrt(s ** 2 + (b / 2) ** 2)\n    base_area = b ** 2\n    lateral_area = 2 * b * slant_height\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    slant_height = math.sqrt((b / 2) ** 2 + s ** 2)\n    lateral_area = 2 * b * slant_height\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    slant_height = math.sqrt((b / 2) ** 2 + s ** 2)\n    base_area = b ** 2\n    lateral_area = 2 * b * slant_height\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    slant_height = math.sqrt((b / 2) ** 2 + s ** 2)\n    lateral_area = 2 * b * slant_height\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    slant_height = math.sqrt((b / 2) ** 2 + s ** 2)\n    base_area = b ** 2\n    lateral_area = 4 * (0.5 * b * slant_height)\n    return base_area + lateral_area"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/589", "requirement": "from typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function to find all perfect squares inclusively between two given integers `a` and `b`.\n    \n    Requirements:\n    1. The function should return a list of integers representing the perfect squares between `a` and `b`, inclusive of both bounds.\n    2. If `a` or `b` is negative, the function should raise a `ValueError` since perfect squares are non-negative.\n    3. If `a > b`, the function should return an empty list, as the range is invalid.\n    4. The function should only accept integer inputs for `a` and `b`. If non-integer types are provided, a `TypeError` should be raised.\n    \n    Example:\n    assert perfect_squares(1, 30) == [1, 4, 9, 16, 25]\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        return []\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Both inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Both inputs must be non-negative.')\n    if a > b:\n        return []\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        return []\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        return []\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Both inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Both inputs must be non-negative.')\n    if a > b:\n        return []\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative integers.')\n    if a > b:\n        return []\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        return []\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        return []\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        return []\n    start = math.ceil(math.sqrt(a)) if a > 0 else 0\n    end = math.floor(math.sqrt(b))\n    squares = [i * i for i in range(start, end + 1)]\n    return squares", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Bounds must be non-negative.')\n    if a > b:\n        return []\n    start = math.ceil(math.sqrt(a)) if a > 0 else 0\n    end = math.floor(math.sqrt(b))\n    squares = [i * i for i in range(start, end + 1)]\n    return squares"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Write a function to convert Cartesian coordinates (x, y) to polar coordinates and return a tuple containing:\n    1. The polar coordinates as a tuple (magnitude, angle), where:\n       - magnitude is the distance from the origin to the point (x, y), calculated as sqrt(x^2 + y^2).\n       - angle is the angle in radians between the positive x-axis and the line connecting the origin to the point (x, y), calculated using atan2(y, x).\n    2. A fixed complex number (-2+2.4492935982947064e-16j), which is included as an example-specific value unrelated to the input (x, y).\n\n    Example:\n    assert polar_rect(3, 4) == ((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), complex(-2, 2.4492935982947064e-16))", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    fixed_complex = -2 + 2.4492935982947064e-16j\n    return ((magnitude, angle), fixed_complex)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/592", "requirement": "def sum_Of_product(n: int) -> int:\n\"\"\"\nWrite a python function to find the sum of the product of consecutive binomial co-efficients.\nassert sum_Of_product(3) == 15\n\"\"\"", "generated_programs": ["from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, k) * comb(n, k + 1) for k in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(i, 2) * comb(n, i) for i in range(2, n + 1)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(i, 2) * comb(i + 1, 2) for i in range(1, n + 1)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, k) * comb(n, k + 1) for k in range(n)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "```python\nfrom typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to compute the absolute difference between the first even number \n    and the first odd number in a given list of integers. The function assumes that the \n    input list contains at least one even number and one odd number. If the input list \n    does not meet this condition, a StopIteration exception will be raised.\n\n    Preconditions:\n    - The input list must be non-empty.\n    - The input list must contain at least one even number and one odd number.\n\n    The difference is calculated as abs(first_even - first_odd), where:\n    - first_even is the first even number in the list.\n    - first_odd is the first odd number in the list.\n\n    Example:\n    assert diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 3\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration('The list must contain at least one even and one odd number.')\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration('List does not contain both even and odd numbers.')\n    return abs(first_even - first_odd)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/599", "requirement": "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n    Write a function to find the sum and average of the first n natural numbers.\n\n    Requirements:\n    1. The input `number` must be an integer.\n    2. The term \"natural numbers\" refers to positive integers starting from 1.\n    3. If `number` is zero, the function should raise a `ZeroDivisionError` as division by zero is not defined.\n    4. If `number` is negative, the function should compute the sum and average using an empty range, resulting in a sum of 0 and an average of -0.0.\n    5. The sum is calculated using `sum(range(1, number + 1))`, and the average is computed as `total_sum / number`.\n\n    Examples:\n    - assert sum_average(10) == (55, 5.5)\n    - Input: [0], Expected Output: ['ZeroDivisionError']\n    - Input: [-5], Expected Output: [(0, -0.0)]\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number == 0:\n        raise ZeroDivisionError\n    if number < 0:\n        return (0, -0.0)\n    total_sum = sum(range(1, number + 1))\n    average = total_sum / number\n    return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number == 0:\n        raise ZeroDivisionError\n    if number < 0:\n        return (0, -0.0)\n    total_sum = sum(range(1, number + 1))\n    average = total_sum / number\n    return (total_sum, average)", "code\nfrom typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number == 0:\n        raise ZeroDivisionError\n    elif number < 0:\n        return (0, -0.0)\n    total_sum = sum(range(1, number + 1))\n    average = total_sum / number\n    return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number == 0:\n        raise ZeroDivisionError\n    if number < 0:\n        return (0, -0.0)\n    total_sum = sum(range(1, number + 1))\n    average = total_sum / number\n    return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number == 0:\n        raise ZeroDivisionError\n    if number < 0:\n        return (0, -0.0)\n    total_sum = sum(range(1, number + 1))\n    average = total_sum / number\n    return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number == 0:\n        raise ZeroDivisionError('Cannot divide by zero')\n    elif number < 0:\n        return (0, -0.0)\n    else:\n        total_sum = sum(range(1, number + 1))\n        average = total_sum / number\n        return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number == 0:\n        raise ZeroDivisionError\n    elif number < 0:\n        return (0, -0.0)\n    total_sum = sum(range(1, number + 1))\n    average = total_sum / number\n    return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number == 0:\n        raise ZeroDivisionError\n    elif number < 0:\n        return (0, -0.0)\n    else:\n        total_sum = sum(range(1, number + 1))\n        average = total_sum / number\n        return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number == 0:\n        raise ZeroDivisionError('division by zero')\n    if number < 0:\n        return (0, -0.0)\n    total_sum = sum(range(1, number + 1))\n    average = total_sum / number\n    return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number == 0:\n        raise ZeroDivisionError('division by zero is not defined')\n    if number < 0:\n        return (0, -0.0)\n    total_sum = sum(range(1, number + 1))\n    average = total_sum / number\n    return (total_sum, average)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/602", "requirement": "```python\ndef first_repeated_char(str1: str) -> str:\n    \"\"\"\n    Write a Python function to find the first repeated character in the given string `str1`.\n    \n    - The function processes the string from left to right.\n    - It identifies the first character in the traversal that appears more than once.\n    - The input string `str1` can contain any character, including letters, numbers, special symbols, and non-ASCII characters.\n    - If there is no repeated character in the string, the function should return an empty string ('').\n    - The function must handle edge cases gracefully, such as an empty input string or a string with all unique characters.\n    \n    Example:\n    assert first_repeated_char(\"abcabc\") == \"a\"\n\n    Edge cases:\n    assert first_repeated_char(\"\") == \"\"\n    assert first_repeated_char(\"abcdef\") == \"\"\n    assert first_repeated_char(\"112233\") == \"1\"\n    assert first_repeated_char(\"a!@#a\") == \"a\"\n    \"\"\"\n```", "generated_programs": ["def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    char_set = set()\n    for char in str1:\n        if char in char_set:\n            return char\n        char_set.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    char_set = set()\n    for char in str1:\n        if char in char_set:\n            return char\n        char_set.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/603", "requirement": "from typing import List\n\n\ndef get_ludic(n: int) -> List[int]:\n\"\"\"\nWrite a function to get all lucid numbers smaller than or equal to a given integer.\nassert get_ludic(10) == [1, 2, 3, 5, 7]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic = [1]\n    candidates = list(range(2, n + 1))\n    while candidates:\n        next_ludic = candidates[0]\n        ludic.append(next_ludic)\n        candidates = [x for i, x in enumerate(candidates) if (i + 1) % next_ludic != 0]\n    return ludic", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic = [1]\n    candidates = list(range(2, n + 1))\n    while candidates:\n        next_ludic = candidates[0]\n        ludic.append(next_ludic)\n        candidates = [x for i, x in enumerate(candidates) if (i + 1) % next_ludic != 0]\n    return ludic", "def get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = [1]\n    candidates = list(range(2, n + 1))\n    while candidates:\n        current_ludic = candidates[0]\n        ludic_numbers.append(current_ludic)\n        candidates = [candidate for i, candidate in enumerate(candidates, 1) if i % current_ludic != 0]\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic = [1]\n    candidates = list(range(2, n + 1))\n    while candidates:\n        next_ludic = candidates[0]\n        ludic.append(next_ludic)\n        candidates = [x for i, x in enumerate(candidates) if (i + 1) % next_ludic != 0]\n    return ludic", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = [1]\n    candidates = list(range(2, n + 1))\n    while candidates:\n        next_ludic = candidates[0]\n        ludic_numbers.append(next_ludic)\n        candidates = [x for i, x in enumerate(candidates) if (i + 1) % next_ludic != 0]\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = [1]\n    current_list = list(range(2, n + 1))\n    while current_list:\n        next_ludic = current_list[0]\n        ludic_numbers.append(next_ludic)\n        current_list = [x for i, x in enumerate(current_list) if (i + 1) % next_ludic != 0]\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = [1]\n    candidates = list(range(2, n + 1))\n    while candidates:\n        next_ludic = candidates[0]\n        ludic_numbers.append(next_ludic)\n        candidates = [candidate for idx, candidate in enumerate(candidates) if (idx + 1) % next_ludic != 0]\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic = [True] * (n + 1)\n    result = []\n    for i in range(1, n + 1):\n        if ludic[i]:\n            result.append(i)\n            count = 0\n            for j in range(i + 1, n + 1):\n                if ludic[j]:\n                    count += 1\n                    if count % i == 0:\n                        ludic[j] = False\n    return result", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = [1]\n    if n == 1:\n        return ludic_numbers\n    candidates = list(range(2, n + 1))\n    while candidates:\n        next_ludic = candidates[0]\n        ludic_numbers.append(next_ludic)\n        candidates = [x for i, x in enumerate(candidates) if (i + 1) % next_ludic != 0]\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = [1]\n    if n == 1:\n        return ludic_numbers\n    current_list = list(range(2, n + 1))\n    while current_list:\n        next_ludic = current_list[0]\n        ludic_numbers.append(next_ludic)\n        current_list = [x for i, x in enumerate(current_list) if (i + 1) % next_ludic != 0]\n    return ludic_numbers"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.8, "original_passk": 0.9}}
{"task_id": "Mbpp/604", "requirement": "```python\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse the order of words in a given string. Words are defined as sequences of non-space characters separated by spaces. \n    The function should normalize spacing in the output such that:\n    - Words in the reversed string are separated by exactly one space.\n    - Leading and trailing spaces in the input string are removed in the output.\n    - Consecutive spaces between words in the input are treated as a single separator.\n\n    Example:\n    assert reverse_words(\"python program\") == \"program python\"\n    assert reverse_words(\"multiple    spaces between words\") == \"words between spaces multiple\"\n    \"\"\"\n```", "generated_programs": ["def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.strip().split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/608", "requirement": "def bell_Number(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the nth Bell number using Bell's triangle.\n\n    Constraints:\n    - The input `n` must be a non-negative integer.\n    - If `n` is negative, the function should raise an `IndexError`.\n\n    Behavior:\n    - The function computes the nth Bell number using Bell's triangle, a triangular array where each element is derived from the previous row.\n    - The Bell number is defined combinatorially and represents the number of ways to partition a set of `n` elements.\n\n    Examples:\n    - assert bell_Number(2) == 2\n    - For invalid input such as `bell_Number(-1)`, the function should raise an `IndexError`.\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [-1]\n    Expected Output: ['IndexError']\n    ### Test 2\n    Input: [-1]\n    Expected Output: ['IndexError']\n    \"\"\"", "generated_programs": ["def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError\n    bell = [[1]]\n    for i in range(1, n + 1):\n        row = [bell[i - 1][0]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell[i - 1][j - 1])\n        bell.append(row)\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be a non-negative integer')\n    if n == 0:\n        return 1\n    bell = [[1]]\n    for i in range(1, n + 1):\n        row = [bell[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell[i - 1][j - 1])\n        bell.append(row)\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[1]]\n    for i in range(1, n + 1):\n        row = [bell[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell[i - 1][j - 1])\n        bell.append(row)\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('The input must be a non-negative integer.')\n    bell = [[1]]\n    for i in range(1, n + 1):\n        next_row = [bell[i - 1][-1]]\n        for j in range(1, i + 1):\n            next_row.append(next_row[j - 1] + bell[i - 1][j - 1])\n        bell.append(next_row)\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(row)\n    return bell_triangle[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError(\"The input 'n' must be a non-negative integer.\")\n    if n == 0:\n        return 1\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(row)\n    return bell_triangle[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[1]]\n    for i in range(1, n + 1):\n        bell.append([bell[i - 1][-1]])\n        for j in range(1, i + 1):\n            bell[i].append(bell[i][j - 1] + bell[i - 1][j - 1])\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(row)\n    return bell_triangle[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('The input must be a non-negative integer.')\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/610", "requirement": "```python\nfrom typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function which takes a list of integers `list1` and an integer `k`, and returns a new list with the same elements, but the k'th element removed.\n\n    Requirements:\n    1. The index `k` is **1-based**. The first element of the list corresponds to `k=1`, the second element to `k=2`, and so on.\n    2. If `k` is less than 1 or greater than the length of the list, the function should raise an `IndexError`.\n    3. Negative values for `k` are not valid and should raise a `ValueError`.\n    4. If `list1` is empty, the function should raise an `IndexError` regardless of the value of `k`.\n\n    Example:\n    assert remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1:\n        raise ValueError('k cannot be negative or zero.')\n    if not list1:\n        raise IndexError('List is empty.')\n    if k > len(list1):\n        raise IndexError('k is out of range.')\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if not list1:\n        raise IndexError('List is empty')\n    if k < 1:\n        raise ValueError('k must be a positive integer')\n    if k > len(list1):\n        raise IndexError('k is out of range')\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if not list1:\n        raise IndexError('List is empty')\n    if k < 1:\n        raise ValueError('k must be a positive integer')\n    if k > len(list1):\n        raise IndexError('k is out of range')\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if not list1:\n        raise IndexError('List is empty')\n    if k < 1:\n        raise ValueError('k must be greater than 0')\n    if k > len(list1):\n        raise IndexError('k is out of range')\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if not list1:\n        raise IndexError('List is empty')\n    if k < 1:\n        raise ValueError('k must be a positive integer')\n    if k > len(list1):\n        raise IndexError('k is out of range')\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if not list1:\n        raise IndexError('List is empty.')\n    if k < 1:\n        raise ValueError('k must be a positive integer.')\n    if k > len(list1):\n        raise IndexError('k is out of range.')\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if not list1:\n        raise IndexError('The list is empty.')\n    if k < 1:\n        raise ValueError('k must be a positive integer.')\n    if k > len(list1):\n        raise IndexError('k is out of range.')\n    return [x for i, x in enumerate(list1, 1) if i != k]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if not list1:\n        raise IndexError('List is empty')\n    if k < 1:\n        raise ValueError('k must be a positive integer')\n    if k > len(list1):\n        raise IndexError('k is out of range')\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if not list1:\n        raise IndexError('List is empty')\n    if k < 1:\n        raise ValueError('k must be a positive integer')\n    if k > len(list1):\n        raise IndexError('k is greater than the length of the list')\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if not list1:\n        raise IndexError('The list is empty.')\n    if k < 1:\n        raise ValueError('k must be a positive integer.')\n    if k > len(list1):\n        raise IndexError('k is out of range.')\n    return [x for i, x in enumerate(list1, 1) if i != k]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/611", "requirement": "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n    Write a function which, given a matrix represented as a list of lists, returns the maximum value from the N'th column.\n    \n    Requirements:\n    1. The input matrix is assumed to be well-formed, meaning all rows must have at least `N + 1` columns.\n    2. If any row does not have an `N`'th column, the function will raise an `IndexError`.\n    3. Sparse rows (e.g., empty rows or rows with fewer than `N + 1` columns) are not allowed and will result in an error.\n    4. The function does not preemptively validate the matrix structure or the value of `N`. It relies on Python's built-in indexing behavior, which will raise an `IndexError` if `N` is out of range for any row.\n\n    Example:\n    assert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "code\nfrom typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/615", "requirement": "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    \"\"\"\n    Write a function which takes a tuple of tuples of floats and returns a list of average values for each inner tuple.\n    \n    Requirements:\n    1. Each inner tuple must contain only numeric values of type `float`.\n    2. The function calculates the average of all elements in each inner tuple by summing the elements and dividing by the number of elements in the tuple.\n    3. The input `nums` must be a tuple containing one or more inner tuples. Empty inner tuples are not allowed and will result in undefined behavior.\n    4. The output is a list of floating-point numbers representing the averages, with no rounding applied.\n    5. The function assumes all inner tuples are of valid structure and does not perform input validation for non-numeric values or irregular structures.\n\n    Example:\n    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(t) / len(t) for t in nums]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(inner) / len(inner) for inner in nums]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(t) / len(t) for t in nums]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(t) / len(t) for t in nums]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(inner) / len(inner) for inner in nums]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(inner) / len(inner) for inner in nums]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(t) / len(t) for t in nums]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(t) / len(t) for t in nums]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(inner) / len(inner) for inner in nums]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(inner) / len(inner) for inner in nums]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/620", "requirement": "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    \"\"\"\n    Write a function to find the size of the largest subset of a list of numbers such that every pair in the subset satisfies the following conditions:\n    - **Unidirectional divisibility**: For any pair `(x, y)` in the subset, either `x % y == 0` or `y % x == 0` must hold.\n    - Negative numbers are treated the same as positive numbers, and divisibility is evaluated based on their actual values.\n    - The input list is sorted in ascending order before processing to ensure consistent evaluation of divisibility.\n\n    Edge cases:\n    - If the input list `a` is empty (`[]`), the function should return `0`.\n\n    Example:\n    assert largest_subset([1, 3, 6, 13, 17, 18]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted(map(abs, a))\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted(map(abs, a))\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted(map(abs, a))\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted(a, key=abs)\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted(a)\n    dp = [1] * len(a)\n    max_size = 1\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_size = max(max_size, dp[i])\n    return max_size", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/622", "requirement": "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    \"\"\"\n    Write a function to find the median of two sorted lists of the same size. The function must adhere to the following requirements:\n    \n    1. **Input Validation**:\n        - Both `nums1` and `nums2` must be non-empty lists of integers, and their sizes must match the provided parameter `n`.\n        - If either list is empty, or if their sizes do not match `n`, the function must raise an `IndexError`.\n        - The parameter `n` must be a positive integer. If `n <= 0`, the function must raise an `IndexError`.\n\n    2. **Preconditions**:\n        - Both input lists `nums1` and `nums2` are guaranteed to be sorted in non-decreasing order. The function does not need to handle unsorted inputs.\n\n    3. **Behavior**:\n        - The function must merge the two lists completely into a single sorted list and calculate the median of the merged list.\n        - The median is defined as the average of the two middle elements in the merged list when the total number of elements is even.\n\n    4. **Non-mutative Processing**:\n        - The input lists `nums1` and `nums2` must remain unchanged after processing.\n\n    5. **Edge Cases**:\n        - If `n=0`, the function must raise an `IndexError`.\n        - Repeated values in the input lists are allowed and must be handled correctly during merging and median calculation.\n\n    Example:\n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or len(nums1) != n or len(nums2) != n:\n        raise IndexError('Invalid input lists or size n.')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or len(nums1) != n or len(nums2) != n or (not nums1) or (not nums2):\n        raise IndexError('Invalid input: lists must be non-empty and of size n, and n must be positive.')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2.0\n    else:\n        return float(merged[mid])", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0:\n        raise IndexError\n    if not nums1 or not nums2 or len(nums1) != n or (len(nums2) != n):\n        raise IndexError\n    merged = []\n    i, j = (0, 0)\n    while i < n and j < n:\n        if nums1[i] <= nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    merged.extend(nums1[i:])\n    merged.extend(nums2[j:])\n    mid = 2 * n // 2\n    median = (merged[mid - 1] + merged[mid]) / 2\n    return median", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or len(nums1) != n or len(nums2) != n:\n        raise IndexError('Invalid input: list sizes must match n and n must be positive.')\n    merged = []\n    i, j = (0, 0)\n    while i < n and j < n:\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    merged.extend(nums1[i:])\n    merged.extend(nums2[j:])\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or len(nums1) != n or len(nums2) != n:\n        raise IndexError('Invalid input parameters')\n    merged = []\n    i, j = (0, 0)\n    while i < n and j < n:\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    while i < n:\n        merged.append(nums1[i])\n        i += 1\n    while j < n:\n        merged.append(nums2[j])\n        j += 1\n    mid = (merged[n - 1] + merged[n]) / 2\n    return mid", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or len(nums1) != n or len(nums2) != n:\n        raise IndexError('Invalid input: lists must be non-empty and of size n.')\n    merged = []\n    i, j = (0, 0)\n    while i < n and j < n:\n        if nums1[i] <= nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    merged.extend(nums1[i:])\n    merged.extend(nums2[j:])\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or len(nums1) != n or len(nums2) != n:\n        raise IndexError('Invalid input: list sizes must match n and n must be positive.')\n    merged = []\n    i = j = 0\n    while i < n and j < n:\n        if nums1[i] <= nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    while i < n:\n        merged.append(nums1[i])\n        i += 1\n    while j < n:\n        merged.append(nums2[j])\n        j += 1\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "code\nfrom typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or len(nums1) != n or len(nums2) != n:\n        raise IndexError('Invalid input sizes.')\n    merged = []\n    i, j = (0, 0)\n    while i < n and j < n:\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    while i < n:\n        merged.append(nums1[i])\n        i += 1\n    while j < n:\n        merged.append(nums2[j])\n        j += 1\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return float(merged[mid])", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or len(nums1) != n or len(nums2) != n:\n        raise IndexError('Invalid input parameters')\n    merged = []\n    i, j = (0, 0)\n    while i < n and j < n:\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    while i < n:\n        merged.append(nums1[i])\n        i += 1\n    while j < n:\n        merged.append(nums2[j])\n        j += 1\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0:\n        raise IndexError('n must be a positive integer')\n    if not nums1 or not nums2 or len(nums1) != n or (len(nums2) != n):\n        raise IndexError('Lists must be non-empty and of size n')\n    merged = []\n    i, j = (0, 0)\n    while i < n and j < n:\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    while i < n:\n        merged.append(nums1[i])\n        i += 1\n    while j < n:\n        merged.append(nums2[j])\n        j += 1\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "```python\ndef triangle_area(radius: float) -> Optional[float]:\n    \"\"\"\n    Write a Python function to calculate the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\n    Clarifications:\n    1. The \"largest triangle inscribed in a semicircle\" is defined as a right triangle where:\n       - The two legs are equal to the radius of the semicircle.\n       - The hypotenuse is the diameter of the semicircle.\n       - The area is calculated using the formula: (base * height) / 2, which simplifies to radius * radius for this specific triangle.\n\n    2. Edge case handling:\n       - If the radius is less than or equal to 0, the function must return `None` to indicate invalid input.\n       - Negative radius values are considered invalid and must return `None`.\n       - A radius of 0 is also considered invalid and must return `None`.\n\n    3. Expected output:\n       - For valid positive radius values, the function returns the area of the triangle as a float.\n       - For invalid radius values (negative or zero), the function returns `None`.\n\n    4. Return type:\n       - The function returns either a float (for valid inputs) or `None` (for invalid inputs).\n\n    Examples:\n    assert triangle_area(1) == 1.0\n    assert triangle_area(-1) == None\n    assert triangle_area(0) == None\n    \"\"\"\n    if radius <= 0:\n        return None\n    return radius * radius\n```", "generated_programs": ["from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/631", "requirement": "```python\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace spaces (' ') with underscores ('_') and underscores ('_') with spaces (' ') \n    in a given string. The function should process each character independently and simultaneously, without \n    intermediate cascading effects. All other characters should remain unchanged. The function should handle \n    edge cases such as empty strings and strings without spaces or underscores by returning the original string.\n\n    Examples:\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    assert replace_spaces(' __ ') == '_  _'\n    assert replace_spaces('Underscore_Test') == 'Underscore Test'\n    \"\"\"\n```", "generated_programs": ["def replace_spaces(text: str) -> str:\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in text])", "def replace_spaces(text: str) -> str:\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in text])", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/638", "requirement": "```python\ndef wind_chill(v: float, t: float) -> int:\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the nearest integer using standard rounding rules \n    (rounds up if the decimal part is  0.5, otherwise rounds down). The calculation uses wind velocity in km/h \n    and temperature in Celsius without any unit conversion. The formula for the wind chill index is:\n    \n        wind_chill = 13.12 + 0.6215 * t - 11.37 * v**0.16 + 0.3965 * t * v**0.16\n\n    Preconditions:\n    - Wind velocity (v) must be non-negative. If v < 0, the function should raise a ValueError.\n    - Temperature (t) can be any valid float value.\n\n    Examples:\n    - assert wind_chill(120, 35) == 40\n    - For input [-1, 20], the function should raise a ValueError.\n    - For input [0, 10], the function should return 19.\n    \"\"\"\n```", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wc)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wind_chill_index)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wc)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wc)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wind_chill_index)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wind_chill_index)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wind_chill_index)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wind_chill_index)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return int(wc + 0.5) if wc > 0 else int(wc - 0.5)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wc = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return int(wc + 0.5) if wc >= 0 else int(wc - 0.5)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/643", "requirement": "def text_match_wordz_middle(text: str) -> bool:\n\"\"\"\nWrite a function that checks if a strings contains 'z', except at the start and end of the word.\nassert text_match_wordz_middle(\"pythonzabc.\")==True\n\"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w+z\\\\w+\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\b[a-zA-Z]*z[a-zA-Z]+\\\\b', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\b[a-zA-Z]*z[a-zA-Z]+\\\\b', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\b[a-zA-Z]*z[a-zA-Z]+\\\\b', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w*z\\\\w*\\\\b'\n    matches = re.findall(pattern, text)\n    for match in matches:\n        if 'z' in match[1:-1]:\n            return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 1.0}}
{"task_id": "Mbpp/644", "requirement": "```python\nfrom typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function to reverse the elements of an array up to a given position `k`.\n    \n    The function should behave as follows:\n    1. If `k` is negative or zero, treat it as an empty reversal and return the original array unchanged.\n    2. If `k` exceeds the length of the array, adjust `k` to be equal to the length of the array.\n    3. The reversal includes all elements from the start of the array up to (and including) the element at index `k-1`.\n    4. The input array is assumed to consist of integers. If the array is empty, return an empty array.\n    \n    Example:\n    assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k <= 0:\n        return input.copy()\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if k <= 0:\n        return input\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if k <= 0 or not input:\n        return input\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input or k <= 0:\n        return input.copy()\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if k <= 0:\n        return input.copy()\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input or k <= 0:\n        return input[:]\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k <= 0:\n        return input.copy()\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if k <= 0:\n        return input.copy()\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if k <= 0 or not input:\n        return input\n    n = len(input)\n    if k > n:\n        k = n\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k <= 0:\n        return input.copy()\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/722", "requirement": "def filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    The input is given as:\n    - a dictionary where each key is a student name (string) and each value is a tuple of two floats representing the student's height and weight respectively,\n    - a minimal height (float),\n    - a minimal weight (float).\n\n    Write a function to filter and return a dictionary of students whose height is greater than or equal to the minimal height and whose weight is greater than or equal to the minimal weight.\n\n    Example:\n    assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70) == {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/734", "requirement": "def sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to calculate the sum of the products of all contiguous subarrays \n    (sublists formed by consecutive elements) of a given list. \n\n    For each subarray, compute the product of its elements and add this product to the total sum.\n\n    Example:\n    assert sum_Of_Subarray_Prod([1,2,3]) == 20\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        prod = 1\n        for j in range(i, n):\n            prod *= arr[j]\n            total += prod\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        current_prod = 1\n        for j in range(i, n):\n            current_prod *= arr[j]\n            total_sum += current_prod\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/735", "requirement": "def toggle_middle_bits(n: int) -> int:\n\"\"\"\nWrite a python function to toggle bits of the number except the first and the last bit. \nassert toggle_middle_bits(9) == 15\n\"\"\"", "generated_programs": ["def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    length = n.bit_length()\n    mask = (1 << length - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    num_bits = n.bit_length()\n    if num_bits <= 2:\n        return n\n    mask = (1 << num_bits - 1) - 1\n    mask &= ~1\n    return n ^ mask", "code\n\ndef toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    length = n.bit_length()\n    mask = (1 << length - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = (1 << bit_length - 1) - 1\n    mask &= ~1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    bits = n.bit_length()\n    if bits == 1:\n        return n\n    mask = (1 << bits - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 0\n    num_bits = n.bit_length()\n    if num_bits <= 2:\n        return n\n    mask = (1 << num_bits - 1) - 1\n    mask = mask ^ 1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    if bit_length <= 2:\n        return n\n    mask = (1 << bit_length - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    num_bits = n.bit_length()\n    if num_bits <= 2:\n        return n\n    mask = (1 << num_bits - 1) - 1\n    mask &= ~1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 1\n    num_bits = n.bit_length()\n    if num_bits <= 2:\n        return n\n    mask = (1 << num_bits - 1) - 1\n    mask -= 1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    binary = bin(n)[2:]\n    if len(binary) <= 2:\n        return n\n    middle = binary[1:-1]\n    toggled = ''.join(['1' if bit == '0' else '0' for bit in middle])\n    result = binary[0] + toggled + binary[-1]\n    return int(result, 2)"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/740", "requirement": "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    \"\"\"\n    Write a function to convert the given tuple into a key-value dictionary by pairing adjacent elements. \n    The function should iterate over the tuple in steps of 2, treating the element at each even index as the key \n    and the element at the next index as the value. \n\n    - If the tuple has an odd length, the last element is ignored as it does not have a matching pair.\n    - If the tuple has fewer than 2 elements (e.g., an empty tuple or a single-element tuple), the function should return an empty dictionary.\n    - The input is assumed to be a tuple, and no explicit error handling for invalid inputs is required.\n\n    Example:\n    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    return {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        key = test_tup[i]\n        value = test_tup[i + 1]\n        result[key] = value\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result_dict = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result_dict[test_tup[i]] = test_tup[i + 1]\n    return result_dict", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        key = test_tup[i]\n        value = test_tup[i + 1]\n        result[key] = value\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        key = test_tup[i]\n        value = test_tup[i + 1]\n        result[key] = value\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/743", "requirement": "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    \"\"\"\n    Write a function to rotate a given list by a specified number of items to the right direction.\n\n    - If the input list `l` is empty, the function should raise a `ZeroDivisionError`.\n    - The rotation should wrap around cyclically, meaning if `m` exceeds or matches the length of the list, the effective rotation count should be computed using modulo arithmetic (`m % len(l)`).\n    - The function assumes `m` is a non-negative integer.\n\n    Example:\n    assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    effective_rotation = m % len(l)\n    return l[-effective_rotation:] + l[:-effective_rotation]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('The input list is empty.')\n    n = len(l)\n    effective_rotation = m % n\n    return l[-effective_rotation:] + l[:-effective_rotation]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError\n    n = len(l)\n    effective_rotation = m % n\n    return l[-effective_rotation:] + l[:-effective_rotation]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('The input list is empty.')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('The input list is empty.')\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        raise ZeroDivisionError('Input list cannot be empty')\n    n = len(l)\n    effective_rotation = m % n\n    return l[-effective_rotation:] + l[:-effective_rotation]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\"\"\"\nWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. \nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if all((digit != '0' and num % int(digit) == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        divisible = True\n        for digit in str(num):\n            if digit == '0':\n                continue\n            if num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        valid = True\n        for digit in str(num):\n            if digit == '0':\n                valid = False\n                break\n            if num % int(digit) != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num)]\n        valid = True\n        for d in digits:\n            if d == 0:\n                valid = False\n                break\n            if num % d != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        temp = num\n        divisible = True\n        while temp > 0:\n            digit = temp % 10\n            if digit == 0:\n                temp //= 10\n                continue\n            if num % digit != 0:\n                divisible = False\n                break\n            temp //= 10\n        if divisible:\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.4, "cross_model_passk": 0.30000000000000004, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/748", "requirement": "```python\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to insert spaces between words in a given string, where each word starts with a capital letter.\n    \n    The function should:\n    1. Add a space before every uppercase letter that is preceded by a lowercase letter or another uppercase letter, except at the start of the string.\n    2. Leave single-word strings (e.g., \"Python\") unchanged.\n    3. Retain existing spaces or delimiters in the input string without modification.\n\n    Examples:\n    assert capital_words_spaces(\"Python\") == 'Python'\n    assert capital_words_spaces(\"ThisIsATest\") == 'This Is A Test'\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z][a-z]*)', ' \\\\1', str1)", "def capital_words_spaces(str1: str) -> str:\n    result = []\n    for i, char in enumerate(str1):\n        if i != 0 and char.isupper():\n            if str1[i - 1] != ' ':\n                result.append(' ')\n        result.append(char)\n    return ''.join(result)", "def capital_words_spaces(str1: str) -> str:\n    result = ''\n    for i, char in enumerate(str1):\n        if i != 0 and char.isupper() and (str1[i - 1].islower() or str1[i - 1].isupper()):\n            result += ' ' + char\n        else:\n            result += char\n    return result", "def capital_words_spaces(str1: str) -> str:\n    result = []\n    for i, char in enumerate(str1):\n        if i != 0 and char.isupper():\n            prev_char = str1[i - 1]\n            if prev_char.islower() or prev_char.isupper():\n                result.append(' ')\n        result.append(char)\n    return ''.join(result)", "def capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return str1\n    result = str1[0]\n    for char in str1[1:]:\n        if char.isupper() and (str1[str1.index(char) - 1].islower() or str1[str1.index(char) - 1].isupper()):\n            result += ' '\n        result += char\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/752", "requirement": "```python\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Jacobsthal number. The Jacobsthal sequence is defined as:\n    J(n) = J(n-1) + 2 * J(n-2) for n > 1,\n    with base cases:\n    J(0) = 0\n    J(1) = 1.\n\n    Constraints:\n    - The input `n` must be a non-negative integer (n >= 0).\n    - Negative input values are not valid and should raise a ValueError.\n\n    Examples:\n    assert jacobsthal_num(5) == 11\n    \"\"\"\n```", "generated_programs": ["def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = (0, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, b + 2 * a)\n    return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            a, b = (b, b + 2 * a)\n        return b", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    j_prev_prev, j_prev = (0, 1)\n    for _ in range(2, n + 1):\n        j_current = j_prev + 2 * j_prev_prev\n        j_prev_prev, j_prev = (j_prev, j_current)\n    return j_prev", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    j_prev_prev = 0\n    j_prev = 1\n    for _ in range(2, n + 1):\n        j_current = j_prev + 2 * j_prev_prev\n        j_prev_prev = j_prev\n        j_prev = j_current\n    return j_prev", "def jacobsthal_num(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    jacobsthal = [0] * (n + 1)\n    jacobsthal[0] = 0\n    jacobsthal[1] = 1\n    for i in range(2, n + 1):\n        jacobsthal[i] = jacobsthal[i - 1] + 2 * jacobsthal[i - 2]\n    return jacobsthal[n]"], "result": {"repaired_passk": 0.5, "cross_model_passk": 1.0, "original_passk": 0.4}}
{"task_id": "Mbpp/754", "requirement": "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists at the same index. \n    The function should find and return a list of such common elements. \n\n    The comparison is performed only up to the length of the shortest list among l1, l2, and l3. \n    If the lists have differing lengths, the function dynamically adjusts to the shortest list to avoid out-of-bounds errors.\n\n    Preconditions:\n    - The input lists l1, l2, and l3 can have differing lengths.\n    - The function does not raise errors for unequal-length lists; instead, it truncates comparisons to the shortest list.\n\n    Example:\n    assert extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/757", "requirement": "```python\nfrom typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n    Write a function to count pairs of reverse strings in the given string list.\n    A reverse pair consists of two distinct strings where one string equals the reverse of the other.\n    Each reverse pair is counted exactly once, regardless of duplicates or order in the list.\n    Duplicate entries in the input list do not increment the count multiple times, and only unique reverse pairs are considered.\n    Strings that are palindromes (identical to their reverse) are ignored entirely and do not contribute to the count.\n\n    Example:\n    assert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]) == 2\n    \"\"\"\n```", "generated_programs": ["from typing import List, Set\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    unique_strings = set(test_list)\n    pairs = set()\n    for s in unique_strings:\n        reversed_s = s[::-1]\n        if reversed_s in unique_strings and reversed_s != s:\n            pair = tuple(sorted((s, reversed_s)))\n            pairs.add(pair)\n    return len(pairs)", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    unique_strings = set(test_list)\n    counted = set()\n    count = 0\n    for s in unique_strings:\n        reversed_s = s[::-1]\n        if reversed_s != s and reversed_s in unique_strings and (reversed_s not in counted):\n            count += 1\n            counted.add(s)\n            counted.add(reversed_s)\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    unique_strings = set(test_list)\n    reverse_pairs = set()\n    for s in unique_strings:\n        reversed_s = s[::-1]\n        if reversed_s != s and reversed_s in unique_strings:\n            pair = tuple(sorted((s, reversed_s)))\n            reverse_pairs.add(pair)\n    return len(reverse_pairs)", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    unique_strings = set(test_list)\n    reverse_pairs = set()\n    for s in unique_strings:\n        reversed_s = s[::-1]\n        if reversed_s != s and reversed_s in unique_strings:\n            pair = tuple(sorted((s, reversed_s)))\n            reverse_pairs.add(pair)\n    return len(reverse_pairs)", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    unique_strings = set(test_list)\n    reverse_pairs = set()\n    for s in unique_strings:\n        reversed_s = s[::-1]\n        if reversed_s in unique_strings and reversed_s != s:\n            pair = tuple(sorted((s, reversed_s)))\n            reverse_pairs.add(pair)\n    return len(reverse_pairs)", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    unique_strings = set(test_list)\n    reverse_pairs = set()\n    for s in unique_strings:\n        reversed_s = s[::-1]\n        if reversed_s != s and reversed_s in unique_strings:\n            pair = tuple(sorted([s, reversed_s]))\n            reverse_pairs.add(pair)\n    return len(reverse_pairs)", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    unique_strings = set(test_list)\n    reverse_pairs = set()\n    for s in unique_strings:\n        reversed_s = s[::-1]\n        if reversed_s in unique_strings and reversed_s != s and (frozenset({s, reversed_s}) not in reverse_pairs):\n            reverse_pairs.add(frozenset({s, reversed_s}))\n    return len(reverse_pairs)", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    unique_strings = set(test_list)\n    count = 0\n    used_pairs = set()\n    for s in unique_strings:\n        reversed_s = s[::-1]\n        if reversed_s != s and reversed_s in unique_strings:\n            pair = tuple(sorted((s, reversed_s)))\n            if pair not in used_pairs:\n                used_pairs.add(pair)\n                count += 1\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    unique_strings = set(test_list)\n    pairs = set()\n    for s in unique_strings:\n        reversed_s = s[::-1]\n        if reversed_s in unique_strings and reversed_s != s:\n            pair = frozenset([s, reversed_s]) if s < reversed_s else frozenset([reversed_s, s])\n            pairs.add(pair)\n    return len(pairs)", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    unique_strings = set(test_list)\n    counted_pairs = set()\n    count = 0\n    for s in unique_strings:\n        reversed_s = s[::-1]\n        if reversed_s != s and reversed_s in unique_strings and (s not in counted_pairs) and (reversed_s not in counted_pairs):\n            count += 1\n            counted_pairs.add(s)\n            counted_pairs.add(reversed_s)\n    return count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/759", "requirement": "```python\ndef is_decimal(num: str) -> bool:\n    \"\"\"\n    Write a function to check whether a given string is a valid decimal number with exactly two digits after the decimal point.\n    \n    The function should return True if the input string meets the following criteria:\n    1. The string represents a non-negative decimal number (no '+' or '-' signs are allowed).\n    2. The string must have an integer part followed by a mandatory '.' and exactly two digits in the fractional part.\n    3. Leading zeros in the integer part are allowed (e.g., '001.11' is valid).\n    4. Trailing decimals without integer parts (e.g., '.11') are not valid.\n    5. Strings without fractional parts (e.g., '123' or '123.') are not valid.\n    6. Strings with more than two digits in the fractional part (e.g., '123.456') are not valid.\n    7. Strings containing non-numeric characters (e.g., '123.a1') or empty strings are not valid.\n\n    Example:\n    assert is_decimal('123.11') == True\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List\n\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n\"\"\"\nWrite a python function to find the minimum difference between any two elements in a given array. \nassert find_min_diff((1,5,3,19,18,25),6) == 1\n\"\"\"", "generated_programs": ["from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr_sorted[i] - arr_sorted[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr_sorted[i] - arr_sorted[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = abs(arr[i] - arr[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    return list(set1.difference(set2))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/771", "requirement": "```python\ndef check_expression(expression: str) -> bool:\n    \"\"\"\n    Write a function to check if the given expression is balanced or not. \n    The function should only check the balance of bracket pairs `{}`, `[]`, and `()` \n    and ignore all other symbols in the expression. An expression is considered \n    balanced if:\n    1. Every opening bracket has a corresponding closing bracket of the same type.\n    2. Brackets are properly nested and closed in the correct order.\n    3. Non-bracket characters are ignored and do not affect the balance-checking process.\n\n    Example:\n    assert check_expression(\"{()}[{}]\") == True\n    \"\"\"\n```", "generated_programs": ["def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', ']': '[', '}': '{'}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or bracket_pairs[char] != stack.pop():\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', ']': '[', '}': '{'}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', ']': '[', '}': '{'}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {'{': '}', '[': ']', '(': ')'}\n    for char in expression:\n        if char in bracket_pairs:\n            stack.append(char)\n        elif char in bracket_pairs.values():\n            if not stack or bracket_pairs[stack.pop()] != char:\n                return False\n    return not stack"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/777", "requirement": "```python\nfrom typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of all unique elements in a given list.\n    The function should treat \"unique elements\" as distinct values in the list, disregarding their frequency.\n    For example, if the input list contains repeated elements, the duplicates are ignored, and only the distinct values are summed.\n    \n    Example:\n    assert find_sum([1, 2, 3, 1, 1, 4, 5, 6]) == 21\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/780", "requirement": "def find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to find all unique combinations of sums for pairs of tuples in the given tuple list. \n    Each combination is formed by summing the corresponding elements of two distinct tuples from the list.\n    The result should include all possible pairwise combinations of sums, excluding self-pairs.\n    \n    Example:\n    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = set()\n    for i in range(len(test_list)):\n        for j in range(len(test_list)):\n            if i != j:\n                sum_pair = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n                combinations.add(sum_pair)\n    return sorted(combinations)", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    n = len(test_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum1 = test_list[i][0] + test_list[j][0]\n            sum2 = test_list[i][1] + test_list[j][1]\n            combinations.append((sum1, sum2))\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = set()\n    for i in range(len(test_list)):\n        for j in range(len(test_list)):\n            if i != j:\n                sum_pair = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n                combinations.add(sum_pair)\n    return sorted(combinations)", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    n = len(test_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return list(set(combinations))", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_pair = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_pair)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_pair = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            if sum_pair not in combinations:\n                combinations.append(sum_pair)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum1 = test_list[i][0] + test_list[j][0]\n            sum2 = test_list[i][1] + test_list[j][1]\n            result.append((sum1, sum2))\n    return result", "code\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(len(test_list)):\n            if i != j:\n                sum_pair = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n                if sum_pair not in combinations:\n                    combinations.append(sum_pair)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_pair = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_pair)\n    unique_combinations = list(set(combinations))\n    unique_combinations.sort()\n    return unique_combinations"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/781", "requirement": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the count of divisors of an integer `n` is even.\n\n    Requirements:\n    1. The input `n` can be any integer, including negative integers and zero.\n    2. The function should calculate the divisors of `n` by iterating through all integers from `1` to `|n|` (absolute value of `n`), inclusive.\n    3. A divisor is defined as an integer `i` such that `n % i == 0`.\n    4. The function should return `True` if the total count of divisors is even, and `False` otherwise.\n    5. For edge cases:\n        - If `n` is zero, treat it as having divisors that satisfy the definition above.\n        - If `n` is negative, calculate divisors using the absolute value of `n`.\n\n    Examples:\n    ### Test 1\n    Input: [-1]\n    Expected Output: [True]\n    \"\"\"", "generated_programs": ["def count_divisors(n: int) -> bool:\n    n = abs(n)\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "def count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    absolute_n = abs(n)\n    divisors = [i for i in range(1, absolute_n + 1) if absolute_n % i == 0]\n    return len(divisors) % 2 == 0", "def count_divisors(n: int) -> bool:\n    divisors = 0\n    absolute_n = abs(n)\n    for i in range(1, absolute_n + 1):\n        if absolute_n % i == 0:\n            divisors += 1\n    return divisors % 2 == 0", "def count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n_abs = abs(n)\n    divisors = [i for i in range(1, n_abs + 1) if n_abs % i == 0]\n    return len(divisors) % 2 == 0", "def count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "def count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n_abs = abs(n)\n    count = 0\n    for i in range(1, n_abs + 1):\n        if n_abs % i == 0:\n            count += 1\n    return count % 2 == 0", "def count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n_abs = abs(n)\n    divisors = [i for i in range(1, n_abs + 1) if n_abs % i == 0]\n    return len(divisors) % 2 == 0", "def count_divisors(n: int) -> bool:\n    if n == 0:\n        divisors = [i for i in range(1, 101) if 0 % i == 0]\n    else:\n        abs_n = abs(n)\n        divisors = [i for i in range(1, abs_n + 1) if abs_n % i == 0]\n    return len(divisors) % 2 == 0", "def count_divisors(n: int) -> bool:\n    if n == 0:\n        divisors = [i for i in range(1, 101) if 0 % i == 0]\n        return len(divisors) % 2 == 0\n    n_abs = abs(n)\n    divisors = [i for i in range(1, n_abs + 1) if n_abs % i == 0]\n    return len(divisors) % 2 == 0", "def count_divisors(n: int) -> bool:\n    if n == 0:\n        divisors = [i for i in range(1, 101) if 0 % i == 0]\n        return len(divisors) % 2 == 0\n    n_abs = abs(n)\n    divisors = [i for i in range(1, n_abs + 1) if n_abs % i == 0]\n    return len(divisors) % 2 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even number and the first odd number in a given list.\n    \n    Requirements:\n    - The input list must contain at least one even number and one odd number.\n    - If the input list does not contain both an even and an odd number, the function will raise a `StopIteration` exception.\n    - The function assumes the input list is non-empty and does not handle cases where the list is empty.\n    - The function always returns an integer if valid inputs exist.\n    \n    Example:\n    assert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return even * odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return even * odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return even * odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    if even_num is None or odd_num is None:\n        raise StopIteration\n    return even_num * odd_num", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    if even_num is None or odd_num is None:\n        raise StopIteration\n    return even_num * odd_num", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    if even_num is None or odd_num is None:\n        raise StopIteration('The list must contain at least one even and one odd number.')\n    return even_num * odd_num"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/787", "requirement": "```python\ndef text_match_three(text: str) -> re.Match:\n    \"\"\"\n    Write a function that identifies whether the input string contains, at any position, the exact pattern of an 'a' \n    immediately followed by three consecutive 'b' characters ('abbb'). The function should return a match object if the \n    pattern exists anywhere within the string and None if no match is found. Use `re.search` for matching.\n\n    Example:\n    assert not text_match_three(\"ac\")  # The string \"ac\" does not contain the required pattern \"abbb\".\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "```python\nimport re\n\ndef text_starta_endb(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches an entire string that starts with the character 'a', \n    is followed by zero or more characters of any kind, and ends with the character 'b'. \n    The match must span the entire string, meaning no characters can exist before 'a' \n    or after 'b'. If the string matches the pattern, return a re.Match object; otherwise, \n    return None.\n\n    Examples:\n    - text_starta_endb(\"aabbbb\") -> Returns a re.Match object as the string starts with 'a', \n      has characters in between, and ends with 'b'.\n    - text_starta_endb(\"ab\") -> Returns a re.Match object as the string starts with 'a' and \n      ends with 'b' with no characters in between.\n    - text_starta_endb(\"axb\") -> Returns a re.Match object as the string starts with 'a', \n      has one character in between, and ends with 'b'.\n    - text_starta_endb(\"a\") -> Returns None as the string does not end with 'b'.\n    - text_starta_endb(\"b\") -> Returns None as the string does not start with 'a'.\n    - text_starta_endb(\"aabbbbc\") -> Returns None as the string has trailing characters \n      after 'b'.\n\n    Note:\n    - The function uses `re.fullmatch` to ensure the entire string matches the pattern.\n    - If no match is found, the function returns None.\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a.*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = re.compile('^a.*b$')\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = re.compile('^a.*b$')\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a.*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.fullmatch('a.*b', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = re.compile('^a.*b$')\n    return pattern.fullmatch(text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.fullmatch(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = re.compile('^a.*b$')\n    return re.fullmatch(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/800", "requirement": "```python\ndef remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all occurrences of the literal space character (' ') \n    from a string. The function should not modify other types of whitespace characters \n    (e.g., tabs, newlines, carriage returns, or Unicode whitespace characters) or \n    any other characters in the input string.\n\n    Edge cases:\n    - If the input string contains tabs, newlines, or other whitespace characters, \n      these should remain untouched.\n    - The function should preserve the structure of the input string, removing only \n      literal spaces without collapsing or transforming other formatted whitespace.\n\n    Example:\n    assert remove_all_spaces('python  program') == 'pythonprogram'\n    assert remove_all_spaces('\\t\\nno_spaces_hardcase\\t\\n') == '\\t\\nno_spaces_hardcase\\t\\n'\n    \"\"\"\n```", "generated_programs": ["def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "code\n\ndef remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/801", "requirement": "def test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a Python function that determines the count of integers that are equal to each other among three given integers.\n\n    The function should return:\n    - `3` if all three integers are equal.\n    - `2` if exactly two integers are equal.\n    - `0` if all three integers are distinct.\n\n    Examples:\n    assert test_three_equal(1, 1, 1) == 3\n    assert test_three_equal(1, 2, 3) == 0\n    assert test_three_equal(1, 1, 2) == 2\n    \"\"\"", "generated_programs": ["def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "from typing import List\n\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0", "from typing import List\n\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/6", "requirement": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Write a Python function to determine whether two integers differ at exactly one bit position in their binary representation.\n    \n    The function should return True if the XOR of the two numbers results in a value that is a power of two or zero. This ensures that:\n    - If the two numbers differ at exactly one bit position, the XOR result will have a single \"1\" in its binary representation (a power of two).\n    - If the two numbers are identical, the XOR result will be zero, which is treated as satisfying the condition.\n\n    Preconditions:\n    - Both inputs are non-negative integers.\n\n    Examples:\n    assert differ_At_One_Bit_Pos(13, 9) == True  # 13 (1101) and 9 (1001) differ at one bit position.\n    assert differ_At_One_Bit_Pos(27, 27) == True  # Identical numbers are treated as differing at zero bits, satisfying the condition.\n    \"\"\"", "generated_programs": ["def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result == 0 or xor_result & xor_result - 1 == 0", "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result & xor_result - 1 == 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "Mbpp/11", "requirement": "def remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Write a Python function to remove the first and last occurrence of a given character from the string.\n\n    - The \"first occurrence\" refers to the first position of the character in the original input string.\n    - The \"last occurrence\" refers to the last position of the character in the original input string, regardless of any modifications made during the removal of the first occurrence.\n    - If the character appears only once in the string, the function removes that single occurrence.\n    - If the first and last occurrences overlap (i.e., the character appears only once), the function ensures no redundant operations occur.\n    - If the character does not appear in the string, the function returns the original string unchanged.\n\n    Examples:\n    assert remove_Occ(\"hello\", \"l\") == \"heo\"\n    assert remove_Occ(\"banana\", \"a\") == \"bnan\"\n    \"\"\"", "generated_programs": ["def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == -1:\n        return s\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    if ch not in s:\n        return s\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == -1:\n        return s\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == -1:\n        return s\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "code\n\ndef remove_Occ(s: str, ch: str) -> str:\n    if ch not in s:\n        return s\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "def remove_Occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/16", "requirement": "```python\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if the input string meets the following criteria:\n    1. The string consists of one or more sequences of lowercase letters.\n    2. Each sequence of lowercase letters may be joined by a single underscore ('_').\n    3. Underscores must not appear consecutively, at the beginning, or at the end of the string.\n    4. The string must not contain any characters other than lowercase letters and underscores.\n\n    Examples:\n    - \"abcdef\" is valid because it is a single sequence of lowercase letters.\n    - \"abc_def\" is valid because it consists of two sequences of lowercase letters joined by a single underscore.\n    - \"abc_def_ghi\" is valid because it consists of three sequences of lowercase letters joined by single underscores.\n    - \"abc__def\" is invalid because it contains consecutive underscores.\n    - \"_abc\" and \"abc_\" are invalid because they contain leading or trailing underscores.\n    - \"abc123_def\" is invalid because it contains characters other than lowercase letters and underscores.\n\n    assert text_lowercase_underscore(\"aab_cbbbc\") == (True)\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^([a-z]+(_[a-z]+)*)$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = re.compile('^([a-z]+(_[a-z]+)*)$')\n    return bool(pattern.match(text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = re.compile('^([a-z]+(_[a-z]+)*)$')\n    return bool(pattern.match(text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = re.compile('^[a-z]+(?:_[a-z]+)*$')\n    return bool(pattern.match(text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^([a-z]+(_[a-z]+)*)$'\n    return bool(re.match(pattern, text))", "import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/20", "requirement": "```python\ndef is_woodall(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given number is a Woodall number or not.\n\n    A Woodall number is defined as W(n) = n * 2^n - 1, where n is a non-negative integer.\n    The function should determine if the input `num` matches any Woodall number for n >= 0.\n\n    Requirements:\n    1. The input `num` can be any integer, including negative numbers and zero.\n    2. If `num` is a valid Woodall number, the function should return `True`.\n    3. If `num` is not a valid Woodall number, the function should return `False`.\n    4. The function should handle edge cases gracefully:\n       - For `num = 0`, the function should return `False`.\n       - For negative values of `num`, the function should return `False`.\n    5. The function should use an iterative approach to compute Woodall numbers starting from n = 0,\n       and terminate when the computed Woodall number exceeds the input `num`.\n\n    Examples:\n    assert is_woodall(383) == True\n    assert is_woodall(-1) == False\n    assert is_woodall(0) == False\n    \"\"\"\n```", "generated_programs": ["def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 0\n    while True:\n        woodall = n * (1 << n) - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num <= 0:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num <= 0:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        elif woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 0:\n        return False\n    n = 0\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        elif woodall > num:\n            return False\n        n += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/58", "requirement": "```python\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given two integers have opposite signs or not.\n    Two integers are considered to have opposite signs if one is positive and the other is negative.\n    Special case: Zero (0) is treated as having the same sign as positive integers when compared to negative integers.\n    The function should use bitwise operations to determine opposite signs.\n    \n    Examples:\n    assert opposite_Signs(1, -2) == True\n    assert opposite_Signs(0, -5) == True\n    \"\"\"\n```", "generated_programs": ["def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/67", "requirement": "```python\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Write a function to compute the nth Bell number, which represents the number of ways to partition a set of n elements.\n\n    The function should:\n    - Use the Bell Triangle method to calculate the nth Bell number.\n    - Assume the input `n` is a non-negative integer.\n    - For invalid inputs such as negative integers, the function must raise an IndexError.\n    - The Bell Triangle should be initialized such that the first element is `1` (i.e., the topmost row starts with `[1]`).\n    - For `n=0`, the function should return `1` as the 0th Bell number.\n\n    Examples:\n    assert bell_number(2) == 2\n    \"\"\"\n```", "generated_programs": ["def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[1]]\n    for i in range(1, n + 1):\n        row = [bell[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell[i - 1][j - 1])\n        bell.append(row)\n    return bell[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    triangle = [[1]]\n    for i in range(1, n + 1):\n        row = [triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + triangle[i - 1][j - 1])\n        triangle.append(row)\n    return triangle[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(row)\n    return bell_triangle[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be a non-negative integer')\n    if n == 0:\n        return 1\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(row)\n    return bell_triangle[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be a non-negative integer')\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(row)\n    return bell_triangle[n][0] if bell_triangle else 1", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(row)\n    return bell_triangle[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(row)\n    return bell_triangle[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        current_row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            current_row.append(current_row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(current_row)\n    return bell_triangle[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        current_row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            current_row.append(current_row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(current_row)\n    return bell_triangle[n][0]", "def bell_number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell_triangle = [[1]]\n    for i in range(1, n + 1):\n        new_row = [bell_triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            new_row.append(new_row[j - 1] + bell_triangle[i - 1][j - 1])\n        bell_triangle.append(new_row)\n    return bell_triangle[-1][0]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/71", "requirement": "def comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to sort a list of elements in ascending order using the comb sort algorithm.\n    The function should repeatedly compare and swap elements that are a certain gap apart, reducing the gap size over iterations until the list is sorted.\n    The gap size is reduced using a shrink factor of 1.3 (rounded down), and the process continues until no swaps are needed and the gap size is 1.\n    assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = max(1, int(gap / shrink))\n        swapped = False\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                swapped = True\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    swapped = True\n    shrink = 1.3\n    while gap > 1 or swapped:\n        gap = max(1, int(gap / shrink))\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                swapped = True\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = max(1, int(gap / shrink))\n        sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n        if gap == 1 and sorted:\n            break\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n    return nums", "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = (nums[i + gap], nums[i])\n                sorted = False\n            i += 1\n    return nums"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/72", "requirement": "```python\ndef dif_Square(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given number can be represented as the difference of two squares or not.\n\n    A number can be represented as the difference of two squares if it satisfies one of the following conditions:\n    1. The number is even (n % 2 == 0).\n    2. The number is congruent to 1 modulo 4 (n % 4 == 1).\n\n    Examples:\n    - dif_Square(5) == True because 5 is congruent to 1 modulo 4 (5 % 4 == 1).\n    - dif_Square(10) == True because 10 is even (10 % 2 == 0).\n\n    Constraints:\n    - The input `n` is an integer and can be positive, negative, or zero.\n\n    assert dif_Square(5) == True\n    \"\"\"\n```", "generated_programs": ["def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 4 == 0 or n % 2 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or abs(n) % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        n = -n\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    return n % 2 == 0 or n % 4 == 1", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0:\n        return True\n    if n % 4 == 1:\n        return True\n    return False", "def dif_Square(n: int) -> bool:\n    if n % 2 == 0 or n % 4 == 1:\n        return True\n    return False", "def dif_Square(n: int) -> bool:\n    if n < 0:\n        n = -n\n    return n % 2 == 0 or n % 4 == 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.8}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n    \"\"\"\n    Write a Python function to determine whether a given integer is divisible by 11.\n    The function should return True if the input integer `n` is divisible by 11, and False otherwise.\n    \n    Requirements:\n    1. The function must use modular arithmetic (`n % 11 == 0`) to check divisibility.\n    2. The input `n` will always be an integer. No error handling for invalid input types is required.\n    3. Negative integers are valid inputs and should be handled correctly according to modular arithmetic rules.\n    4. The function must return a boolean value (`True` or `False`).\n    \n    Example:\n    assert is_Diff(12345) == False\n    \"\"\"", "generated_programs": ["def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0", "def is_Diff(n: int) -> bool:\n    return n % 11 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/84", "requirement": "```python\ndef sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the Newman-Conway sequence.\n\n    The Newman-Conway sequence is defined as follows:\n    - sequence(1) = 1\n    - sequence(2) = 1\n    - For n > 2: sequence(n) = sequence(sequence(n - 1)) + sequence(n - sequence(n - 1))\n\n    Constraints:\n    - The input `n` must be an integer greater than or equal to 1.\n    - If `n <= 0`, the function must raise an `IndexError`.\n\n    Examples:\n    - assert sequence(10) == 6\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [0]\n    Expected Output: ['IndexError']\n    ### Test 2\n    Input: [0]\n    Expected Output: ['IndexError']\n    ### Test 3\n    Input: [0]\n    Expected Output: ['IndexError']\n    \"\"\"\n```", "generated_programs": ["def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    memo = [0] * (n + 1)\n    memo[1], memo[2] = (1, 1)\n    for i in range(3, n + 1):\n        memo[i] = memo[memo[i - 1]] + memo[i - memo[i - 1]]\n    return memo[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    memo = [0] * (n + 1)\n    memo[1] = 1\n    memo[2] = 1\n    for i in range(3, n + 1):\n        memo[i] = memo[memo[i - 1]] + memo[i - memo[i - 1]]\n    return memo[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n <= 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/89", "requirement": "def closest_num(N: int) -> int:\n    \"\"\"\n    Write a function to find the closest smaller number than N.\n    The function should return N - 1 for all integer inputs, including positive, zero, and negative values.\n    Edge cases:\n    - If N is 0, the function should return -1.\n    - If N is negative, the function should return N - 1, which is a smaller negative number.\n\n    Example:\n    assert closest_num(11) == 10\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [0]\n    Expected Output: [-1]\n    \"\"\"", "generated_programs": ["def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    return N - 1", "def closest_num(N: int) -> int:\n    if N == 0:\n        return -1\n    return N - 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/92", "requirement": "def is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not.\n\n    A number is considered undulating if it meets the following criteria:\n    1. The number must have at least 3 digits.\n    2. The digits must alternate strictly between two distinct values.\n       - The first digit and the second digit must be different.\n       - All digits at even positions (0-based index) must match the first digit.\n       - All digits at odd positions (0-based index) must match the second digit.\n\n    Edge cases:\n    - Numbers with fewer than 3 digits are not undulating.\n    - Numbers where the first two digits are the same are not undulating.\n    - Any deviation from the strict alternation pattern results in the number being classified as not undulating.\n\n    Example:\n    assert is_undulating(1212121) == True\n    \"\"\"", "generated_programs": ["def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or s[0] == s[1]:\n        return False\n    for i in range(2, len(s)):\n        if i % 2 == 0 and s[i] != s[0] or (i % 2 != 0 and s[i] != s[1]):\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first, second = (s[0], s[1])\n    if first == second:\n        return False\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char != first:\n            return False\n        if i % 2 != 0 and char != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(len(s)):\n        if i % 2 == 0 and s[i] != s[0]:\n            return False\n        if i % 2 != 0 and s[i] != s[1]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first = s[0]\n    second = s[1]\n    if first == second:\n        return False\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char != first:\n            return False\n        if i % 2 != 0 and char != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(len(s)):\n        if i % 2 == 0:\n            if s[i] != s[0]:\n                return False\n        elif s[i] != s[1]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    digits = str(n)\n    if len(digits) < 3:\n        return False\n    first = digits[0]\n    second = digits[1]\n    if first == second:\n        return False\n    for i, digit in enumerate(digits):\n        if i % 2 == 0:\n            if digit != first:\n                return False\n        elif digit != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first = s[0]\n    second = s[1]\n    if first == second:\n        return False\n    for i in range(len(s)):\n        if i % 2 == 0:\n            if s[i] != first:\n                return False\n        elif s[i] != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3 or s[0] == s[1]:\n        return False\n    first = s[0]\n    second = s[1]\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char != first:\n            return False\n        if i % 2 != 0 and char != second:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    if s[0] == s[1]:\n        return False\n    for i in range(len(s)):\n        if i % 2 == 0:\n            if s[i] != s[0]:\n                return False\n        elif s[i] != s[1]:\n            return False\n    return True", "def is_undulating(n: int) -> bool:\n    s = str(n)\n    if len(s) < 3:\n        return False\n    first = s[0]\n    second = s[1]\n    if first == second:\n        return False\n    for i in range(len(s)):\n        if i % 2 == 0:\n            if s[i] != first:\n                return False\n        elif s[i] != second:\n            return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.4}}
{"task_id": "Mbpp/95", "requirement": "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    \"\"\"\n    Write a Python function to find the length of the smallest list in a list of lists.\n\n    Requirements:\n    1. The input `lst` must be a non-empty list of lists. If the input list is empty (`[]`), the function must raise a `ValueError`.\n    2. Empty sublists (`[]`) within the input list are valid and their length is considered as `0`.\n    3. If all sublists are empty (e.g., `[[], []]`), the function should return `0` as the smallest length.\n    4. The function must not return a default value for invalid inputs; it must raise a `ValueError` for cases where the input list itself is empty.\n\n    Example:\n    assert Find_Min_Length([[1], [1, 2]]) == 1\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must not be empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must not be empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list cannot be empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list cannot be empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must not be empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must not be empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must not be empty.')\n    return min((len(sublist) for sublist in lst))", "from typing import List, Any\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n    if not lst:\n        raise ValueError('Input list must be non-empty.')\n    return min((len(sublist) for sublist in lst))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given integer `n`.\n    \n    Requirements:\n    1. The function accepts any integer `n` (positive, negative, or zero) as valid input.\n    2. Divisors are restricted to positive integers in the range `1` to `abs(n)`.\n    3. For negative inputs, the function calculates divisors based on the absolute value of `n`.\n    4. If `n` is zero, the function returns `0` since zero has no positive divisors.\n    5. The function returns the count of positive divisors of `n`.\n\n    Example:\n    assert divisor(15) == 4\n    \"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if n == 0:\n        return 0\n    n = abs(n)\n    return len([i for i in range(1, n + 1) if n % i == 0])", "def divisor(n: int) -> int:\n    if n == 0:\n        return 0\n    n = abs(n)\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n == 0:\n        return 0\n    n = abs(n)\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n == 0:\n        return 0\n    n = abs(n)\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n == 0:\n        return 0\n    n = abs(n)\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n == 0:\n        return 0\n    n = abs(n)\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n == 0:\n        return 0\n    n_abs = abs(n)\n    count = 0\n    for i in range(1, n_abs + 1):\n        if n_abs % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n == 0:\n        return 0\n    n = abs(n)\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n == 0:\n        return 0\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n == 0:\n        return 0\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/103", "requirement": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Write a function to compute the Eulerian number a(n, m) using the standard recurrence relation:\n        a(n, m) = (n - m) * a(n-1, m-1) + (m + 1) * a(n-1, m)\n    The function should handle edge cases and base cases as follows:\n    - If m < 0 or m >= n, return 0 (invalid range for m).\n    - If n == 0 or m == 0, return 1 (base cases of the recurrence relation).\n\n    The function returns a single integer representing the Eulerian number a(n, m).\n\n    Examples:\n    - assert eulerian_num(3, 1) == 4\n    - Input: [5, 3], Expected Output: [26]\n    - Input: [0, 0], Expected Output: [0]\n    \"\"\"", "generated_programs": ["def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)", "def eulerian_num(n: int, m: int) -> int:\n    if m < 0 or m >= n:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "Mbpp/109", "requirement": "def odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Write a Python function to count the number of rotations of a binary string `s` up to `n` times, where the decimal value of the rotated binary string is odd.\n\n    The rotation is performed as a **right cyclic rotation**. Specifically:\n    - For each rotation `i` (from 0 to `n-1`), the binary string `s` is rotated such that the last `(i % len(s))` characters of the string move to the front, and the remaining characters shift to the right.\n    - If `i % len(s) == 0`, the rotation results in the original string `s`.\n    - The number of rotations performed is exactly `n`, even if `n > len(s)`. Rotations wrap cyclically using the modulo operation (`i % len(s)`), meaning duplicate rotations are included in the count.\n\n    The function checks whether the decimal value of each rotated binary string is odd and counts the total number of such rotations.\n\n    Examples:\n    - odd_Equivalent(\"011001\", 6) == 3\n    - odd_Equivalent(\"101010\", 1) == 0\n    - odd_Equivalent(\"1100\", 8) == 4\n    - odd_Equivalent(\"1\", 6) == 6\n\n    Input:\n    - `s`: A binary string consisting of '0' and '1'.\n    - `n`: An integer representing the number of rotations to perform.\n\n    Output:\n    - Returns an integer representing the count of rotations where the decimal value of the rotated binary string is odd.\n    \"\"\"", "generated_programs": ["def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated_s = s[-rotation:] + s[:-rotation]\n        if int(rotated_s, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        shift = i % length\n        rotated = s[-shift:] + s[:-shift] if shift != 0 else s\n        if int(rotated, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated_s = s[-rotation:] + s[:-rotation]\n        if int(rotated_s, 2) % 2 == 1:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    l = len(s)\n    for i in range(n):\n        shift = i % l\n        rotated = s[-shift:] + s[:-shift] if shift != 0 else s\n        if int(rotated, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated_s = s[-rotation:] + s[:-rotation]\n        if int(rotated_s, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated_s = s[-rotation:] + s[:-rotation]\n        if int(rotated_s, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated_s = s[-rotation:] + s[:-rotation]\n        if int(rotated_s, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    len_s = len(s)\n    for i in range(n):\n        rotated = s[-(i % len_s):] + s[:-(i % len_s)]\n        if int(rotated, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    length = len(s)\n    for i in range(n):\n        rotation = i % length\n        rotated_s = s[-rotation:] + s[:-rotation]\n        if int(rotated_s, 2) % 2 != 0:\n            count += 1\n    return count", "def odd_Equivalent(s: str, n: int) -> int:\n    count = 0\n    len_s = len(s)\n    for i in range(n):\n        rotation = i % len_s\n        rotated_s = s[-rotation:] + s[:-rotation]\n        if int(rotated_s, 2) % 2 != 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n\"\"\"\nWrite a function to find the common elements in given nested lists.\nassert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]))==set([18, 12])\n\"\"\"", "generated_programs": ["from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    return list(reduce(lambda a, b: set(a) & set(b), nestedlist))", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    return list(reduce(lambda a, b: set(a) & set(b), nestedlist))", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\nfrom functools import reduce\nfrom collections import Counter\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    common_elements = reduce(lambda x, y: set(x) & set(y), nestedlist)\n    return list(common_elements)", "code\nfrom typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    common = set(nestedlist[0])\n    for lst in nestedlist[1:]:\n        common.intersection_update(lst)\n    return list(common)", "from typing import List\nfrom functools import reduce\nfrom collections import Counter\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        return []\n    counter = Counter()\n    for lst in nestedlist:\n        counter.update(set(lst))\n    common_elements = [elem for elem, cnt in counter.items() if cnt == len(nestedlist)]\n    return sorted(common_elements)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "Mbpp/113", "requirement": "```python\nfrom typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    \"\"\"\n    Write a function to check if a string represents a valid integer or not.\n\n    A string is considered to represent a valid integer if:\n    1. It can be successfully converted to an integer using the `int()` function.\n    2. Leading and trailing whitespace in the string is ignored during conversion.\n    3. The string represents a valid decimal integer, including:\n       - Positive integers (e.g., \"123\", \"+123\").\n       - Negative integers (e.g., \"-123\").\n       - Integers with leading zeros (e.g., \"00123\").\n    4. Strings that cannot be interpreted as integers by `int()` (e.g., \"python\", \"3.14\", \"12a\", \"\", \"+\", \"-\") are considered invalid and should return `False`.\n\n    Examples:\n    - assert check_integer(\"python\") == False\n    - Input: [' 123 ']\n      Expected Output: [True]\n    \"\"\"\n```", "generated_programs": ["from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    text = text.strip()\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        stripped_text = text.strip()\n        if not stripped_text:\n            return False\n        int(stripped_text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        stripped_text = text.strip()\n        if not stripped_text:\n            return False\n        int(stripped_text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        stripped_text = text.strip()\n        if not stripped_text:\n            return False\n        int(stripped_text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        stripped_text = text.strip()\n        if not stripped_text:\n            return False\n        int(stripped_text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        stripped_text = text.strip()\n        if not stripped_text:\n            return False\n        int(stripped_text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        stripped_text = text.strip()\n        if not stripped_text:\n            return False\n        int(stripped_text)\n        return True\n    except ValueError:\n        return False", "code\nfrom typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    try:\n        stripped_text = text.strip()\n        if not stripped_text:\n            return False\n        int(stripped_text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    stripped_text = text.strip()\n    if not stripped_text:\n        return False\n    try:\n        int(stripped_text)\n        return True\n    except ValueError:\n        return False", "from typing import Optional\n\ndef check_integer(text: str) -> Optional[bool]:\n    text = text.strip()\n    if not text:\n        return False\n    if text[0] in '+-':\n        if len(text) == 1:\n            return False\n        text = text[1:]\n    return text.isdigit()"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/118", "requirement": "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string into a list of strings by splitting strictly on the literal space character (' ').\n    The function should retain all resulting substrings, including empty strings caused by consecutive spaces, leading spaces, or trailing spaces in the input.\n    assert string_to_list(\"python programming\") == ['python', 'programming']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')", "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    return string.split(' ')"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/120", "requirement": "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n\n    Requirements:\n    1. The input list must contain at least one tuple with exactly two integers. If the list is empty or contains any tuple that does not have exactly two integers, the function must raise a `ValueError`.\n    2. For each valid tuple `(a, b)` in the list, calculate the absolute product `abs(a * b)`.\n    3. Return the maximum absolute product among all valid tuples in the list.\n\n    Examples:\n    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [[]]\n    Expected Output: ['ValueError']\n    ### Test 2\n    Input: [[()]]\n    Expected Output: ['ValueError']\n    ### Test 3\n    Input: [[]]\n    Expected Output: ['ValueError']\n    ### Test 4\n    Input: [[()]]\n    Expected Output: ['ValueError']\n    \"\"\"", "generated_programs": ["code\nfrom typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1 or any((not isinstance(t, tuple) or len(t) != 2 for t in list1)):\n        raise ValueError\n    max_product = max((abs(a * b) for a, b in list1))\n    return max_product", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2 or (not all((isinstance(x, int) for x in t))):\n            raise ValueError\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError\n    for pair in list1:\n        if not isinstance(pair, tuple) or len(pair) != 2 or (not all((isinstance(x, int) for x in pair))):\n            raise ValueError\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2 or (not all((isinstance(x, int) for x in t))):\n            raise ValueError\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('List is empty')\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2 or (not all((isinstance(x, int) for x in t))):\n            raise ValueError('List contains invalid tuples')\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('The input list must contain at least one tuple.')\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2 or (not all((isinstance(x, int) for x in t))):\n            raise ValueError('Each tuple in the list must contain exactly two integers.')\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('The list is empty.')\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2 or (not all((isinstance(x, int) for x in t))):\n            raise ValueError('The list contains an invalid tuple.')\n    return max((abs(a * b) for a, b in list1))", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('The list must contain at least one tuple.')\n    for tup in list1:\n        if not isinstance(tup, tuple) or len(tup) != 2 or (not all((isinstance(x, int) for x in tup))):\n            raise ValueError('Each element in the list must be a tuple with exactly two integers.')\n    max_product = max((abs(a * b) for a, b in list1))\n    return max_product", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('List must contain at least one tuple.')\n    max_product = None\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2 or (not all((isinstance(x, int) for x in t))):\n            raise ValueError('Each tuple in the list must contain exactly two integers.')\n        product = abs(t[0] * t[1])\n        if max_product is None or product > max_product:\n            max_product = product\n    return max_product", "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError('Input list is empty.')\n    max_product = None\n    for t in list1:\n        if not isinstance(t, tuple) or len(t) != 2 or (not all((isinstance(i, int) for i in t))):\n            raise ValueError('List contains invalid tuples.')\n        current_product = abs(t[0] * t[1])\n        if max_product is None or current_product > max_product:\n            max_product = current_product\n    if max_product is None:\n        raise ValueError('No valid tuples found.')\n    return max_product"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "```python\ndef amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of all amicable numbers within the range [2, limit], inclusive.\n\n    Amicable numbers are defined as pairs of numbers (a, b) such that:\n    - a != b\n    - sum_of_divisors(a) = b\n    - sum_of_divisors(b) = a\n    - Both a and b lie within the range [2, limit].\n\n    The function should:\n    - Include both members of each amicable pair in the sum. For example, if (220, 284) is an amicable pair, their sum (220 + 284) contributes to the result.\n    - Return 0 for inputs less than 2, as no amicable numbers exist in such ranges.\n\n    Input:\n    - limit: An integer specifying the upper bound of the range to search for amicable numbers. Must be >= 2.\n\n    Output:\n    - An integer representing the sum of all amicable numbers within the specified range.\n\n    Examples:\n    assert amicable_numbers_sum(999) == 504\n    \"\"\"\n```", "generated_programs": ["def sum_of_divisors(n: int) -> int:\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    if limit < 2:\n        return 0\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n    if limit < 2:\n        return 0\n\n    def sum_of_divisors(n: int) -> int:\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a and (b <= limit):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def sum_of_divisors(n: int) -> int:\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    if limit < 2:\n        return 0\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def sum_of_divisors(n: int) -> int:\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    if limit < 2:\n        return 0\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum(amicable_pairs)", "def amicable_numbers_sum(limit: int) -> int:\n    if limit < 2:\n        return 0\n\n    def sum_of_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    checked = set()\n    for a in range(2, limit + 1):\n        if a in checked:\n            continue\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_sum += a + b\n            checked.add(a)\n            checked.add(b)\n    return amicable_sum", "import math\n\ndef sum_of_divisors(n: int) -> int:\n    if n == 1:\n        return 0\n    total = 1\n    sqrt_n = math.isqrt(n)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    if limit < 2:\n        return 0\n    amicable_sum = 0\n    visited = set()\n    for a in range(2, limit + 1):\n        if a in visited:\n            continue\n        b = sum_of_divisors(a)\n        if b != a and b <= limit and (sum_of_divisors(b) == a):\n            amicable_sum += a + b\n            visited.add(b)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    if limit < 2:\n        return 0\n    amicable_sum = 0\n    seen = set()\n    for a in range(2, limit + 1):\n        if a in seen:\n            continue\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a and (b <= limit):\n            amicable_sum += a + b\n            seen.add(a)\n            seen.add(b)\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n    if limit < 2:\n        return 0\n\n    def sum_of_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    seen = set()\n    for a in range(2, limit + 1):\n        if a in seen:\n            continue\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a and (b <= limit):\n            amicable_sum += a + b\n            seen.add(a)\n            seen.add(b)\n    return amicable_sum", "def sum_of_divisors(n):\n    divisors = {1}\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit: int) -> int:\n    if limit < 2:\n        return 0\n    amicable_sum = 0\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        if a in amicable_pairs:\n            continue\n        b = sum_of_divisors(a)\n        if b != a and b >= 2 and (b <= limit) and (sum_of_divisors(b) == a):\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n            amicable_sum += a + b\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n    if limit < 2:\n        return 0\n\n    def sum_of_divisors(n: int) -> int:\n        divisors = [1]\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    amicable_pairs = set()\n    for a in range(2, limit + 1):\n        if a in amicable_pairs:\n            continue\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a and (b <= limit):\n            amicable_sum += a + b\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return amicable_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/124", "requirement": "```python\ndef angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Write a function to calculate the angle of the complex number `b` relative to the origin on the complex plane.\n    The function should ignore the input `a` and only compute the angle of `b` using `math.atan2(b.imag, b.real)`.\n    \n    Examples:\n    assert math.isclose(angle_complex(0, 1j), 1.5707963267948966, rel_tol=0.001)\n    \n    Input and expected output examples:\n    ### Test 1\n    Input: [(1+1j), (1-1j)]\n    Expected Output: [-0.7853981633974483]\n    ### Test 2\n    Input: [(1+1j), (1-1j)]\n    Expected Output: [-0.7853981633974483]\n    \"\"\"\n```", "generated_programs": ["import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/126", "requirement": "def sum(a: int, b: int) -> int:\n\"\"\"\nWrite a python function to find the sum of common divisors of two given numbers.\nassert sum(10,15) == 6\n\"\"\"", "generated_programs": ["import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd_value = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd_value)) + 1):\n            if gcd_value % i == 0:\n                divisors.add(i)\n                divisors.add(gcd_value // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def common_divisors(x, y):\n        gcd_val = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd_val)) + 1):\n            if gcd_val % i == 0:\n                divisors.add(i)\n                divisors.add(gcd_val // i)\n        return sorted(divisors)\n    return sum(common_divisors(a, b))", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def common_divisors(x):\n        divisors = set()\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                divisors.add(i)\n                divisors.add(x // i)\n        return divisors\n    divisors_a = common_divisors(a)\n    divisors_b = common_divisors(b)\n    common = divisors_a.intersection(divisors_b)\n    return sum(common)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        gcd_value = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd_value)) + 1):\n            if gcd_value % i == 0:\n                divisors.add(i)\n                divisors.add(gcd_value // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "from math import gcd\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x, y):\n        common_div = gcd(x, y)\n        divisors = set()\n        for i in range(1, int(common_div ** 0.5) + 1):\n            if common_div % i == 0:\n                divisors.add(i)\n                divisors.add(common_div // i)\n        return divisors\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)", "import math\nfrom typing import List\n\ndef sum(a: int, b: int) -> int:\n\n    def get_common_divisors(x: int, y: int) -> List[int]:\n        gcd = math.gcd(x, y)\n        divisors = set()\n        for i in range(1, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                divisors.add(i)\n                divisors.add(gcd // i)\n        return sorted(divisors)\n    common_divisors = get_common_divisors(a, b)\n    return sum(common_divisors)"], "result": {"repaired_passk": 0.6, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether the given matrix is a magic square.\n\n    A matrix is considered a magic square if it satisfies the following conditions:\n    1. The matrix must be non-empty and square-shaped (i.e., the number of rows equals the number of columns, and all rows have the same length).\n    2. The sum of the elements in each row, each column, and both main diagonals must be equal to the same value, referred to as the \"magic sum.\"\n\n    If the matrix is empty, non-square, or does not meet the magic square criteria, the function should return False.\n\n    Examples:\n    - assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    - assert magic_square_test([[]]) == False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_sum:\n            return False\n    diag1 = sum((my_matrix[i][i] for i in range(n)))\n    diag2 = sum((my_matrix[i][n - i - 1] for i in range(n)))\n    if diag1 != magic_sum or diag2 != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    diagonal1 = sum((my_matrix[i][i] for i in range(n)))\n    diagonal2 = sum((my_matrix[i][n - i - 1] for i in range(n)))\n    if diagonal1 != magic_sum or diagonal2 != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix:\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for i in range(n):\n        if sum([my_matrix[j][i] for j in range(n)]) != magic_sum:\n            return False\n    if sum([my_matrix[i][i] for i in range(n)]) != magic_sum:\n        return False\n    if sum([my_matrix[i][n - 1 - i] for i in range(n)]) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not my_matrix[0]:\n        return False\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix[1:]:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_sum:\n            return False\n    diagonal1 = sum((my_matrix[i][i] for i in range(n)))\n    diagonal2 = sum((my_matrix[i][n - i - 1] for i in range(n)))\n    if diagonal1 != magic_sum or diagonal2 != magic_sum:\n        return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/130", "requirement": "```python\nfrom typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list.\n\n    Requirements:\n    1. The function must return the item with the highest frequency in the list.\n    2. If multiple items have the same maximum frequency, the function must return the first one encountered in the list.\n    3. If the input list is empty, the function must raise a ValueError.\n    4. The input list is assumed to contain integers only.\n\n    Example:\n    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2]) == 2\n    \"\"\"\n```", "generated_programs": ["from typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list is empty')\n    counter = Counter(nums)\n    max_freq = max(counter.values())\n    for num in nums:\n        if counter[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list is empty')\n    freq = defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n    max_freq = max(freq.values())\n    for num in nums:\n        if freq[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty')\n    frequency = defaultdict(int)\n    for num in nums:\n        frequency[num] += 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list is empty.')\n    freq = defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n    max_freq = max(freq.values())\n    for num in nums:\n        if freq[num] == max_freq:\n            return num", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list cannot be empty')\n    frequency = defaultdict(int)\n    max_freq = 0\n    max_num = None\n    for num in nums:\n        frequency[num] += 1\n        if frequency[num] > max_freq:\n            max_freq = frequency[num]\n            max_num = num\n    return max_num", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list is empty.')\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list is empty')\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list is empty.')\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    max_freq = max(frequency.values())\n    for num in nums:\n        if frequency[num] == max_freq:\n            return num", "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input list is empty.')\n    frequency = {}\n    max_freq = 0\n    max_item = None\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n        if frequency[num] > max_freq:\n            max_freq = frequency[num]\n            max_item = num\n    return max_item", "from typing import List\nfrom collections import defaultdict\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input list is empty')\n    frequency = defaultdict(int)\n    for num in nums:\n        frequency[num] += 1\n    max_freq_item = nums[0]\n    max_freq = frequency[max_freq_item]\n    for num in nums[1:]:\n        if frequency[num] > max_freq:\n            max_freq_item = num\n            max_freq = frequency[num]\n    return max_freq_item"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "Mbpp/137", "requirement": "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of zeroes to non-zeroes in an array of integers.\n\n    - If the input list contains only zeroes (i.e., no non-zero integers), return `float('inf')` to represent an undefined ratio.\n    - If the input list is empty, return `float('inf')` to align with the behavior for all-zeroes lists.\n    - Only literal `0` values are considered as zeroes. Non-zero integers are all other values in the list.\n    - The function assumes the input is a list of integers and does not handle mixed types or non-integer values.\n    - The ratio is calculated as the count of zeroes divided by the count of non-zero integers. If the count of non-zero integers is zero, the function avoids division by zero and returns `float('inf')`.\n    - The expected output precision is tested using `math.isclose()` with `rel_tol=0.001`.\n\n    Example:\n    assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return float('inf')\n    return zero_count / non_zero_count", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums or all((num == 0 for num in nums)):\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "from typing import List\nimport math\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zero_count = nums.count(0)\n    non_zero_count = len(nums) - zero_count\n    if non_zero_count == 0:\n        return float('inf')\n    return zero_count / non_zero_count", "from typing import List\n\ndef zero_count(nums: List[int]) -> float:\n    if not nums:\n        return float('inf')\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to determine whether the given positive integer `n` \n    can be represented as the sum of two or more distinct powers of 2. A power \n    of 2 is defined as \\(2^m\\) where \\(m \\geq 0\\). The function should return:\n    \n    - `True` if `n` can be expressed as the sum of two or more distinct powers of 2.\n    - `False` if `n` is a single power of 2 (e.g., \\(2^m\\)) or if `n` is not positive.\n\n    Special cases:\n    - For \\(n = 0\\), return `False` (not positive).\n    - For \\(n = 1\\), return `False` (a single power of 2, \\(2^0\\)).\n    - For \\(n = 2\\), return `False` (a single power of 2, \\(2^1\\)).\n    - For \\(n = 10\\), return `True` (e.g., \\(10 = 2^3 + 2^1\\)).\n\n    Example:\n    assert is_Sum_Of_Powers_Of_Two(10) == True\n    \"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    binary_str = bin(n)[2:]\n    return binary_str.count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if bin(n).count('1') == 1:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    binary_representation = bin(n)\n    return binary_representation.count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    if n & n - 1 == 0:\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/145", "requirement": "```python\nfrom typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the maximum difference between the largest and smallest elements in a given array.\n\n    Requirements:\n    1. The input must be a list of integers (`List[int]`). Tuples or other iterable types are not valid inputs.\n    2. If the input array is empty, the function must raise a `ValueError`.\n    3. For arrays with a single element, the function should return `0` since the largest and smallest elements are the same.\n    4. For arrays with identical values, the function should return `0` as the difference between the largest and smallest elements is `0`.\n    5. The \"maximum difference\" is defined as the difference between the largest (`max(arr)`) and smallest (`min(arr)`) elements in the array.\n\n    Example:\n    assert max_Abs_Diff([2, 1, 5, 3]) == 4\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    if len(arr) == 1:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    if len(arr) == 1:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    if len(arr) == 1:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    if len(arr) == 1:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    if len(arr) == 1:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    if len(arr) == 1:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    if len(arr) == 1:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    if len(arr) == 1:\n        return 0\n    return max(arr) - min(arr)", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    if len(arr) == 1:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val - min_val", "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    if not isinstance(arr, list):\n        raise ValueError('Input must be a list of integers.')\n    if not arr:\n        raise ValueError('Input array cannot be empty.')\n    if len(arr) == 1:\n        return 0\n    return max(arr) - min(arr)"], "result": {"repaired_passk": 0.4, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"\n    Write a function that returns a tuple of integers (x, y) that satisfy the equation ax + by = n, \n    subject to the following constraints:\n    - Both x and y must be non-negative integers (x >= 0, y >= 0).\n    - If there exist solutions where both x and y are non-negative integers, the function must return one such solution. \n      The specific solution returned does not need to be unique, but it must satisfy the non-negativity constraint.\n    - If no solution exists where both x and y are non-negative integers, the function must return None.\n    - The function does not prioritize solutions based on additional criteria (e.g., smallest values of x or y) \n      beyond the non-negativity constraint.\n\n    Additional clarifications:\n    - The inputs `a`, `b`, and `n` must be integers, and `a` and `b` must be positive (a > 0, b > 0). \n      If either `a` or `b` is zero or negative, the behavior of the function is undefined.\n    - The function assumes valid input and does not perform explicit validation of input ranges.\n    - The function uses a nested loop structure to find solutions, which inherently prioritizes smaller values of `x` \n      due to the order of iteration. This prioritization is incidental and not explicitly required.\n\n    Example:\n    assert find_solution(2, 3, 7) == (2, 1)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return (x, y)\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/222", "requirement": "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    \"\"\"\n    Write a function to check if all elements in the tuple have strictly the same data type.\n    The function should return True if all elements in the tuple are of the same strict type \n    (e.g., all elements are integers, or all are strings) and False otherwise.\n\n    Additional constraints:\n    - Mixed types like int and float are considered different and should result in False.\n    - Empty tuples are considered to have the same type and should return True.\n    - The function does not handle nested tuples or other complex compound types; assume all elements are primitives (e.g., int, str, float).\n\n    Example:\n    assert check_type((5, 6, 7, 3, 5, 6)) == True\n    \"\"\"", "generated_programs": ["code\nfrom typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(element) == first_type for element in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(element) == first_type for element in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((isinstance(element, first_type) for element in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(element) == first_type for element in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(element) == first_type for element in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((isinstance(element, first_type) for element in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    return all((type(element) == first_type for element in test_tuple))", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for item in test_tuple:\n        if type(item) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for item in test_tuple:\n        if type(item) != first_type:\n            return False\n    return True", "from typing import Tuple\n\ndef check_type(test_tuple: Tuple) -> bool:\n    if not test_tuple:\n        return True\n    first_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/223", "requirement": "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n    Write a function that takes in a sorted array `arr` of integers, its length `n`, and an integer `x`. \n    The function returns whether `x` is the majority element in the given sorted array. \n    A majority element is defined as an element that occurs more than `n // 2` times in the array.\n\n    The function should:\n    1. Calculate the majority index as `n // 2`.\n    2. Check if the element at the majority index (`arr[majority_index]`) is equal to `x`. If not, return `False`.\n    3. If the element at the majority index is equal to `x`, count the total occurrences of `x` in the array using `arr.count(x)`.\n    4. Return `True` if the count of `x` is greater than `n // 2`, otherwise return `False`.\n\n    Note:\n    - The input array `arr` is guaranteed to be sorted in non-decreasing order.\n    - If `x` is not present at the majority index, the function should not count occurrences of `x` and should immediately return `False`.\n\n    Example:\n    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    majority_index = n // 2\n    if arr[majority_index] != x:\n        return False\n    return arr.count(x) > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    majority_index = n // 2\n    if arr[majority_index] != x:\n        return False\n    return arr.count(x) > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    majority_index = n // 2\n    if arr[majority_index] != x:\n        return False\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    majority_index = n // 2\n    if arr[majority_index] != x:\n        return False\n    return arr.count(x) > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    majority_index = n // 2\n    if arr[majority_index] != x:\n        return False\n    return arr.count(x) > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    majority_index = n // 2\n    if arr[majority_index] != x:\n        return False\n    return arr.count(x) > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    majority_index = n // 2\n    if arr[majority_index] != x:\n        return False\n    count = arr.count(x)\n    return count > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    majority_index = n // 2\n    if arr[majority_index] != x:\n        return False\n    return arr.count(x) > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    majority_index = n // 2\n    if arr[majority_index] != x:\n        return False\n    return arr.count(x) > n // 2", "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    majority_index = n // 2\n    if arr[majority_index] != x:\n        return False\n    count = arr.count(x)\n    return count > n // 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.5}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n    \"\"\"\n    Write a Python function to ensure that all bits located at even indices (starting from index 0) in the binary representation of a given integer `n` are set to `1`. \n    The function should only modify bits within the actual bit-length of `n` and preserve all other bits as they are.\n\n    - \"Even indices\" refer to positions 0, 2, 4, ..., up to `(bit_length - 2)` of the binary representation of `n`.\n    - Bits beyond the bit-length of `n` (implicit trailing zeros) are not considered for modification.\n    - If all even-index bits are already set to `1`, the input value remains unchanged.\n\n    Example:\n    assert even_bit_set_number(10) == 10\n    \"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_len = n.bit_length()\n    mask = 0\n    for i in range(0, bit_len, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    bit_length = n.bit_length()\n    mask = 0\n    for i in range(0, bit_length, 2):\n        mask |= 1 << i\n    return n | mask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n.\n    Each sequence must satisfy the following conditions:\n    - The first element of the sequence can be any positive integer between 1 and m (inclusive).\n    - Each subsequent element in the sequence must be a positive integer that is:\n        - Greater than or equal to twice the previous element.\n        - Less than or equal to m.\n    The function should return the total number of such sequences.\n\n    Example:\n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n    from functools import lru_cache\n\n    def dp(current, length):\n        if length == n:\n            return 1\n        count = 0\n        for next_num in range(2 * current, m + 1):\n            count += dp(next_num, length + 1)\n        return count\n    total = 0\n    for first_num in range(1, m + 1):\n        total += dp(first_num, 1)\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    from functools import lru_cache\n\n    def dfs(current_length, last_element):\n        if current_length == n:\n            return 1\n        count = 0\n        for next_element in range(2 * last_element, m + 1):\n            count += dfs(current_length + 1, next_element)\n        return count\n    total = 0\n    for first_element in range(1, m + 1):\n        total += dfs(1, first_element)\n    return total", "import sys\nsys.setrecursionlimit(1000000)\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def dfs(current_length, last_element):\n        if current_length == n:\n            return 1\n        count = 0\n        for i in range(2 * last_element, m + 1):\n            count += dfs(current_length + 1, i)\n        return count\n    total = 0\n    for first_element in range(1, m + 1):\n        total += dfs(1, first_element)\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum((dp[n][j] for j in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum((dp[n][j] for j in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    from functools import lru_cache\n\n    def dp(current_pos, last_num):\n        if current_pos == n:\n            return 1\n        count = 0\n        for num in range(2 * last_num, m + 1):\n            count += dp(current_pos + 1, num)\n        return count\n    if n == 0:\n        return 0\n    total = 0\n    for first_num in range(1, m + 1):\n        total += dp(1, first_num)\n    return total", "code\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 1:\n        return m\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = sum((dp[i - 1][k] for k in range(2 * j, m + 1)))\n    return sum((dp[n][j] for j in range(1, m + 1)))", "import sys\nsys.setrecursionlimit(1000000)\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    def helper(pos, prev):\n        if pos == n:\n            return 1\n        if dp[pos][prev] != -1:\n            return dp[pos][prev]\n        count = 0\n        for i in range(2 * prev, m + 1):\n            count += helper(pos + 1, i)\n        dp[pos][prev] = count\n        return count\n    total = 0\n    for i in range(1, m + 1):\n        total += helper(1, i)\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 1:\n        return m\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 1:\n        return m\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            if 2 * j <= m:\n                dp[i][j] = dp[i - 1][j * 2]\n            if j + 1 <= m:\n                dp[i][j] += dp[i][j + 1]\n    total = 0\n    for i in range(1, m + 1):\n        total += dp[n][i]\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.7}}
{"task_id": "Mbpp/244", "requirement": "def next_Perfect_Square(N: int) -> int:\n    \"\"\"\n    Write a Python function to find the smallest perfect square greater than a given number `N`.\n    \n    Clarifications:\n    1. \"Next perfect square\":\n       - A perfect square is an integer that can be expressed as the square of another integer.\n       - The function must return the smallest perfect square strictly greater than `N`.\n       - If `N` is itself a perfect square, the function must move to the next larger perfect square.\n\n    2. Square root calculation:\n       - Use the integer square root (`math.isqrt`) of `N` to determine the largest integer `r` such that `r^2 <= N`.\n       - The next perfect square is calculated by taking the square of `r + 1`.\n\n    3. Input constraints:\n       - `N` must be a non-negative integer. If `N` is negative, raise a `ValueError`.\n       - For `N = 0`, the next perfect square is `1`.\n\n    Example:\n    assert next_Perfect_Square(35) == 36\n    \"\"\"", "generated_programs": ["import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        raise ValueError\n    r = math.isqrt(N)\n    return (r + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        raise ValueError('N must be a non-negative integer')\n    r = math.isqrt(N)\n    return (r + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        raise ValueError('N must be a non-negative integer')\n    r = math.isqrt(N)\n    return (r + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        raise ValueError('N must be a non-negative integer')\n    r = math.isqrt(N)\n    return (r + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        raise ValueError('N must be a non-negative integer')\n    r = math.isqrt(N)\n    if r * r == N:\n        r += 1\n    else:\n        r += 1\n    return r * r", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        raise ValueError('N must be a non-negative integer.')\n    r = math.isqrt(N)\n    if r * r == N:\n        r += 1\n    else:\n        r += 1\n    return r * r", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        raise ValueError('N must be a non-negative integer.')\n    r = math.isqrt(N)\n    if r * r == N:\n        r += 1\n    else:\n        r += 1\n    return r * r", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        raise ValueError('N must be a non-negative integer')\n    r = math.isqrt(N)\n    if r * r == N:\n        r += 1\n    else:\n        r += 1\n    return r * r", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        raise ValueError('N must be a non-negative integer')\n    r = math.isqrt(N)\n    if r * r == N:\n        r += 1\n    else:\n        r += 1\n    return r * r", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        raise ValueError('N must be a non-negative integer')\n    r = math.isqrt(N)\n    if r * r == N:\n        r += 1\n    else:\n        r += 0\n    return (r + 1) ** 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/247", "requirement": "def lps(str1: str) -> int:\n    \"\"\"\n    Write a function to find the length of the longest palindromic subsequence in the given string.\n\n    Requirements:\n    1. The input string `str1` must be a non-empty string. If the input string is empty, the function will raise an `IndexError`.\n    2. The function assumes the input string contains valid characters and does not impose restrictions on the type of characters (e.g., alphanumeric, spaces, etc.).\n    3. The function calculates the length of the longest palindromic subsequence using dynamic programming, as demonstrated in the reference implementation.\n    4. Edge cases such as single-character strings or strings with spaces are handled correctly, as shown in the example assertion.\n\n    Example:\n    assert lps(\"TENS FOR TENS\") == 5\n    \"\"\"", "generated_programs": ["def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    if n == 0:\n        raise IndexError('Input string must be non-empty.')\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str1[i] == str1[j]:\n                if length == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    return dp[0][n - 1]", "def lps(str1: str) -> int:\n    n = len(str1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if str1[i] == str1[j] and cl == 2:\n                dp[i][j] = 2\n            elif str1[i] == str1[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    return dp[0][n - 1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/255", "requirement": "from typing import List, Tuple\n\ndef combinations_colors(l: List, n: int) -> List[Tuple]:\n    \"\"\"\n    Write a function that takes in a list and a length `n`, and generates all unique combinations of the elements of the list with repetition allowed, where the order of elements in the combinations does not matter. The function returns a list containing tuples for each combination.\n\n    The combinations are generated such that each tuple represents a combination of `n` elements from the input list, allowing repeated elements, but ensuring that the order of elements in the tuple does not create duplicate combinations. This behavior aligns with the mathematical definition of combinations with repetition.\n\n    Example:\n    assert combinations_colors([\"Red\", \"Green\", \"Blue\"], 1) == [('Red',), ('Green',), ('Blue',)]\n    assert combinations_colors([\"Red\", \"Green\", \"Blue\"], 2) == [('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Blue')]\n    \"\"\"", "generated_programs": [], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/259", "requirement": "def maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    \"\"\"\n    Write a function to maximize the given two tuples element-wise. For each pair of tuples at the same position in \n    test_tup1 and test_tup2, create a new tuple where each element is the maximum of the corresponding elements \n    from the two input tuples. Return a tuple containing these new tuples.\n\n    Example:\n    assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple(((max(a[0], b[0]), max(a[1], b[1])) for a, b in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(x, y) for x, y in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple(((max(a1, a2), max(b1, b2)) for (a1, b1), (a2, b2) in zip(test_tup1, test_tup2)))", "from typing import Tuple\n\ndef maximize_elements(test_tup1: Tuple[Tuple[int, int], ...], test_tup2: Tuple[Tuple[int, int], ...]) -> Tuple[Tuple[int, int], ...]:\n    return tuple((tuple((max(a, b) for a, b in zip(t1, t2))) for t1, t2 in zip(test_tup1, test_tup2)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "```python\ndef newman_prime(n: int) -> int:\n    \"\"\"\n    Compute the nth NewmanShanksWilliams (NSW) number using the iterative approach.\n\n    The function calculates the NSW number sequence using the following formula:\n        NSW(0) = 1\n        NSW(1) = 1\n        NSW(n) = 2 * NSW(n - 1) + NSW(n - 2) for n > 1\n\n    Requirements:\n    - The input `n` must be a non-negative integer.\n    - If `n` is negative, the function should raise a ValueError with the message: 'Input must be a non-negative integer.'\n    - If `n` is not an integer (e.g., a float or string), the function should raise a TypeError.\n\n    Implementation Details:\n    - The function must use an iterative approach to compute the NSW number sequence.\n    - Recursive implementations are not permitted due to potential performance and stack limit issues.\n\n    Note:\n    - This function computes the general NSW number sequence, not specifically NSW primes.\n    - The function does not handle primality checks or filtering NSW primes; this logic is expected to be implemented separately.\n\n    Example:\n    assert newman_prime(3) == 7\n    \"\"\"\n```", "generated_programs": ["def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be a non-negative integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, 2 * b + a)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    a, b = (1, 1)\n    for _ in range(2, n + 1):\n        c = 2 * b + a\n        a, b = (b, c)\n    return b", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    prev2, prev1 = (1, 1)\n    for _ in range(2, n + 1):\n        current = 2 * prev1 + prev2\n        prev2, prev1 = (prev1, current)\n    return prev1", "def newman_prime(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0 or n == 1:\n        return 1\n    nsw_prev_prev = 1\n    nsw_prev = 1\n    for _ in range(2, n + 1):\n        nsw_current = 2 * nsw_prev + nsw_prev_prev\n        nsw_prev_prev = nsw_prev\n        nsw_prev = nsw_current\n    return nsw_prev"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/264", "requirement": "def dog_age(h_age: float) -> float:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years based on the given human age `h_age`.\n    The function uses the following formula:\n    - If `h_age <= 2`, the dog's age is calculated as `h_age * 10.5`.\n    - If `h_age > 2`, the dog's age is calculated as `21 + (h_age - 2) * 4`.\n\n    The input `h_age` can be any real number, including negative values, zero, or fractional numbers.\n    The function does not impose any constraints or validation on the input domain.\n\n    Example:\n    assert dog_age(12) == 61\n    \"\"\"", "generated_programs": ["def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "code\n\ndef dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4", "def dog_age(h_age: float) -> float:\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.8}}
{"task_id": "Mbpp/265", "requirement": "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Write a function that takes in a list `S` and a positive integer `step` and splits the list into `step` sublists. \n    The elements of the input list are distributed cyclically across the sublists based on their index modulo `step`. \n    For example, the first sublist contains elements at indexes congruent to `0 % step`, the second sublist contains elements at indexes congruent to `1 % step`, and so on.\n\n    Constraints:\n    - `step` must be a positive integer. If `step <= 0`, the function should raise a `ValueError`.\n    - If the input list `S` is empty, the function should return a list of `step` empty sublists.\n\n    Example:\n    assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('Step must be a positive integer.')\n    result = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        result[i % step].append(item)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer')\n    result = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        result[i % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer')\n    result = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        result[i % step].append(item)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('Step must be a positive integer.')\n    result = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        result[i % step].append(element)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer')\n    result = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        result[i % step].append(item)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer')\n    sublists = [[] for _ in range(step)]\n    for index, element in enumerate(S):\n        sublists[index % step].append(element)\n    return sublists", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer')\n    result = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        result[i % step].append(item)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer')\n    sublists = [[] for _ in range(step)]\n    for i, element in enumerate(S):\n        sublists[i % step].append(element)\n    return sublists", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer')\n    result = [[] for _ in range(step)]\n    for index, item in enumerate(S):\n        result[index % step].append(item)\n    return result", "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError('step must be a positive integer')\n    sublists = [[] for _ in range(step)]\n    for index, element in enumerate(S):\n        sublists[index % step].append(element)\n    return sublists"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/271", "requirement": "def even_Power_Sum(n: int) -> int:\n    \"\"\"\n    Write a Python function that takes an integer n and calculates the sum of the fifth powers of the first n even natural numbers.\n    For example, the first n even natural numbers are generated as 2, 4, 6, ..., up to 2 * n.\n    The function should return the sum of (2 ** 5, 4 ** 5, ..., (2 * n) ** 5).\n    assert even_Power_Sum(2) == 1056\n    \"\"\"", "generated_programs": ["def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))", "def even_Power_Sum(n: int) -> int:\n    return sum(((2 * i) ** 5 for i in range(1, n + 1)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/279", "requirement": "def is_num_decagonal(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the nth decagonal number using the formula: n * (4 * n - 3).\n    A decagonal number is a figurate number that represents a decagon. The nth decagonal number is derived from the formula.\n    Example:\n    assert is_num_decagonal(3) == 27\n    \"\"\"", "generated_programs": ["def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)", "def is_num_decagonal(n: int) -> int:\n    return n * (4 * n - 3)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/286", "requirement": "from typing import List\n\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the largest sum of a contiguous subarray in the modified array \n    which is conceptually formed by repeating the given array `k` times.\n    \n    Requirements:\n    1. Input:\n        - `a`: A list of integers representing the original array.\n        - `n`: An integer representing the size of the original array `a`.\n        - `k`: An integer representing the number of times `a` is repeated.\n    2. Output:\n        - Returns an integer representing the largest sum of a contiguous subarray \n          in the conceptual repeated array.\n    3. Behavior:\n        - The function should NOT explicitly construct the modified array \n          for large `k` to avoid memory issues.\n        - For `k > 2`, calculations must optimize by considering overlaps between \n          prefix and suffix segments of the repeated array. Specifically:\n          - The maximum sum of a contiguous subarray may include elements \n            from the suffix of one repetition and the prefix of the next repetition.\n        - The function must efficiently handle negative and mixed numbers in `a`.\n    4. Example:\n        - For the input `max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3)`, the output is `30`.\n        - In this specific example:\n          - The optimal subarray sum involves parts of repeated segments and does \n            not require constructing the entire repeated array explicitly.\n\n    Notes:\n    - Ensure correctness by adhering to the example provided and optimizing for large `k`.\n    - The concept of prefix and suffix overlap for calculations must be explicitly handled when `k > 1`.\n    - Keep computations efficient to ensure scalability for cases of high `k`.\n\n    assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    if k == 1:\n        return max_sub_array_sum(a)\n    total_sum = sum(a)\n    max_suffix = suffix = 0\n    max_prefix = prefix = 0\n    for num in a:\n        prefix += num\n        max_prefix = max(max_prefix, prefix)\n    for num in reversed(a):\n        suffix += num\n        max_suffix = max(max_suffix, suffix)\n    if total_sum <= 0:\n        return max(max_sub_array_sum(a), max_prefix + max_suffix)\n    else:\n        return max(max_sub_array_sum(a), max_prefix + max_suffix + (k - 2) * total_sum)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in arr:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    total_sum = sum(a)\n    max_prefix_sum = max_suffix_sum = prefix_sum = suffix_sum = 0\n    for i in range(n):\n        prefix_sum += a[i]\n        max_prefix_sum = max(max_prefix_sum, prefix_sum)\n    for i in range(n - 1, -1, -1):\n        suffix_sum += a[i]\n        max_suffix_sum = max(max_suffix_sum, suffix_sum)\n    if k == 1:\n        return kadane(a)\n    elif total_sum <= 0:\n        return max(kadane(a), max_prefix_sum + max_suffix_sum)\n    else:\n        return max(kadane(a), max_prefix_sum + max_suffix_sum + (k - 2) * total_sum)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_sum = arr[0]\n        current_sum = arr[0]\n        for num in arr[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    if k == 1:\n        return kadane(a)\n    total_sum = sum(a)\n    max_prefix = 0\n    current_prefix = 0\n    for num in a:\n        current_prefix += num\n        max_prefix = max(max_prefix, current_prefix)\n    max_suffix = 0\n    current_suffix = 0\n    for num in reversed(a):\n        current_suffix += num\n        max_suffix = max(max_suffix, current_suffix)\n    if total_sum > 0:\n        return max(kadane(a), max_suffix + max_prefix + total_sum * (k - 2))\n    else:\n        return max(kadane(a), max_suffix + max_prefix)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    total_sum = sum(a)\n    max_prefix = max_suffix = a[0]\n    current_prefix = current_suffix = a[0]\n    for i in range(1, n):\n        current_prefix += a[i]\n        max_prefix = max(max_prefix, current_prefix)\n        current_suffix += a[n - i - 1]\n        max_suffix = max(max_suffix, current_suffix)\n    if k == 1:\n        return kadane(a)\n    elif k == 2:\n        return max(kadane(a), max_prefix + max_suffix)\n    else:\n        return max(kadane(a), max_prefix + max_suffix + max(0, total_sum * (k - 2)))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr):\n        max_sum = current_sum = arr[0]\n        for num in arr[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    total_sum = sum(a)\n    if k == 1:\n        return max_sub_array_sum(a)\n    max_prefix_sum = max_suffix_sum = 0\n    prefix_sum = suffix_sum = 0\n    for i in range(n):\n        prefix_sum += a[i]\n        max_prefix_sum = max(max_prefix_sum, prefix_sum)\n    for i in range(n - 1, -1, -1):\n        suffix_sum += a[i]\n        max_suffix_sum = max(max_suffix_sum, suffix_sum)\n    if total_sum > 0:\n        return max(max_suffix_sum + max_prefix_sum + total_sum * (k - 2), max_sub_array_sum(a))\n    else:\n        return max(max_suffix_sum + max_prefix_sum, max_sub_array_sum(a))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    total_sum = sum(a)\n    max_prefix_sum = max_suffix_sum = float('-inf')\n    current_prefix = current_suffix = 0\n    for i in range(n):\n        current_prefix += a[i]\n        max_prefix_sum = max(max_prefix_sum, current_prefix)\n    for i in range(n - 1, -1, -1):\n        current_suffix += a[i]\n        max_suffix_sum = max(max_suffix_sum, current_suffix)\n    max_single = kadane(a)\n    if k == 1:\n        return max_single\n    if total_sum <= 0:\n        return max(max_single, max_prefix_sum + max_suffix_sum)\n    else:\n        return max(max_single, max_prefix_sum + max_suffix_sum + (k - 2) * total_sum)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    if k == 1:\n        return kadane(a)\n    total_sum = sum(a)\n    if k == 2:\n        repeated = a + a\n        return kadane(repeated)\n    max_prefix = max_suffix = -float('inf')\n    current_prefix = current_suffix = 0\n    for i in range(n):\n        current_prefix += a[i]\n        max_prefix = max(max_prefix, current_prefix)\n    for i in range(n - 1, -1, -1):\n        current_suffix += a[i]\n        max_suffix = max(max_suffix, current_suffix)\n    if total_sum > 0:\n        return max(max_prefix + max_suffix + (k - 2) * total_sum, kadane(a))\n    else:\n        return max(max_prefix + max_suffix, kadane(a))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    total_sum = sum(a)\n    max_kadane = kadane(a)\n    if k == 1:\n        return max_kadane\n    max_prefix, max_suffix = (-float('inf'), -float('inf'))\n    current_prefix, current_suffix = (0, 0)\n    for i in range(n):\n        current_prefix += a[i]\n        max_prefix = max(max_prefix, current_prefix)\n    for i in range(n - 1, -1, -1):\n        current_suffix += a[i]\n        max_suffix = max(max_suffix, current_suffix)\n    if total_sum > 0:\n        return max(max_kadane, max_prefix + max_suffix + total_sum * (k - 2))\n    else:\n        return max(max_kadane, max_prefix + max_suffix)", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n\n    def max_sub_array_sum(arr: List[int]) -> int:\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            max_global = max(max_global, max_current)\n        return max_global\n    if k == 1:\n        return max_sub_array_sum(a)\n    total_sum = sum(a)\n    prefix_sum = suffix_sum = max_prefix_sum = max_suffix_sum = 0\n    for i in range(n):\n        prefix_sum += a[i]\n        max_prefix_sum = max(max_prefix_sum, prefix_sum)\n    for i in range(n - 1, -1, -1):\n        suffix_sum += a[i]\n        max_suffix_sum = max(max_suffix_sum, suffix_sum)\n    if total_sum > 0:\n        return max(max_suffix_sum + max_prefix_sum + total_sum * (k - 2), max_sub_array_sum(a))\n    else:\n        return max(max_suffix_sum + max_prefix_sum, max_sub_array_sum(a))", "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    if k == 0:\n        return 0\n\n    def kadane(arr):\n        max_current = max_global = arr[0]\n        for i in range(1, len(arr)):\n            max_current = max(arr[i], max_current + arr[i])\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    total_sum = sum(a)\n    max_single = kadane(a)\n    if k == 1:\n        return max_single\n    prefix_sum = []\n    suffix_sum = []\n    current_prefix = 0\n    current_suffix = 0\n    max_prefix = 0\n    max_suffix = 0\n    for num in a:\n        current_prefix += num\n        if current_prefix > max_prefix:\n            max_prefix = current_prefix\n        prefix_sum.append(current_prefix)\n    for num in reversed(a):\n        current_suffix += num\n        if current_suffix > max_suffix:\n            max_suffix = current_suffix\n        suffix_sum.append(current_suffix)\n    suffix_sum = suffix_sum[::-1]\n    if k == 2:\n        return max(max_single, max_suffix + max_prefix)\n    if total_sum > 0:\n        return max(max_suffix + max_prefix + total_sum * (k - 2), max_single)\n    else:\n        return max(max_suffix + max_prefix, max_single)"], "result": {"repaired_passk": 0.6, "cross_model_passk": 0.30000000000000004, "original_passk": 0.7}}
{"task_id": "Mbpp/294", "requirement": "def max_val(listval: list) -> int:\n    \"\"\"\n    Write a function to find the maximum numerical value in a given heterogeneous list.\n    \n    The function should:\n    - Filter out non-numerical elements (e.g., strings, None, etc.) from the input list.\n    - Consider both integers and floating-point numbers as valid numerical inputs for comparison.\n    - Return the maximum value among the numerical elements in the list.\n    - Raise a ValueError if the list is empty or contains no numerical elements.\n\n    Example:\n    assert max_val(['Python', 3, 2, 4, 5, 'version']) == 5\n    \"\"\"", "generated_programs": ["def max_val(listval: list) -> int:\n    numerical_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numerical_values:\n        raise ValueError('The list is empty or contains no numerical elements.')\n    return max(numerical_values)", "def max_val(listval: list) -> int:\n    numericals = [x for x in listval if isinstance(x, (int, float))]\n    if not numericals:\n        raise ValueError('List is empty or contains no numerical elements.')\n    return max(numericals)", "def max_val(listval: list) -> int:\n    numerical_values = [x for x in listval if type(x) in (int, float)]\n    if not numerical_values:\n        raise ValueError('The list is empty or contains no numerical elements.')\n    return max(numerical_values)", "def max_val(listval: list) -> int:\n    numerical_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numerical_values:\n        raise ValueError('The list is empty or contains no numerical elements.')\n    return max(numerical_values)", "def max_val(listval: list) -> int:\n    numerical_elements = [x for x in listval if isinstance(x, (int, float))]\n    if not numerical_elements:\n        raise ValueError('The list is empty or contains no numerical elements.')\n    return max(numerical_elements)", "def max_val(listval: list) -> int:\n    numerical_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numerical_values:\n        raise ValueError('The list is empty or contains no numerical elements.')\n    return max(numerical_values)", "def max_val(listval: list) -> int:\n    numerical_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numerical_values:\n        raise ValueError('The list is empty or contains no numerical elements.')\n    return max(numerical_values)", "def max_val(listval: list) -> int:\n    numerical_values = [x for x in listval if isinstance(x, (int, float))]\n    if not numerical_values:\n        raise ValueError('List is empty or contains no numerical elements.')\n    return max(numerical_values)", "def max_val(listval: list) -> int:\n    numerical_elements = [x for x in listval if isinstance(x, (int, float))]\n    if not numerical_elements:\n        raise ValueError('The list is empty or contains no numerical elements.')\n    return max(numerical_elements)", "def max_val(listval: list) -> int:\n    numerical_elements = [x for x in listval if isinstance(x, (int, float))]\n    if not numerical_elements:\n        raise ValueError('The list is empty or contains no numerical elements.')\n    return max(numerical_elements)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/300", "requirement": "def count_binary_seq(n: int) -> int:\n    \"\"\"\n    Write a function to find the count of all binary sequences of length 2n such that the sum of the first n bits is equal to the sum of the last n bits.\n    The function calculates this count by summing the square of combinations for choosing k bits out of n, for all k from 0 to n.\n    assert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    count = 0\n    for k in range(n + 1):\n        count += comb(n, k) ** 2\n    return count", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    return sum((comb(n, k) ** 2 for k in range(n + 1)))", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\n\ndef count_binary_seq(n: int) -> int:\n    from math import comb\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\n\ndef count_binary_seq(n: int) -> int:\n    from math import comb\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total", "import math\nfrom math import comb\n\ndef count_binary_seq(n: int) -> int:\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/301", "requirement": "```python\ndef dict_depth(d: dict) -> int:\n    \"\"\"\n    Write a function `dict_depth` to find the depth of a dictionary. \n    The depth of a dictionary is defined as the maximum nesting level of dictionaries within the given input dictionary. \n\n    Rules:\n    1. The input is guaranteed to be a dictionary. Non-dictionary inputs do not need to be handled and are out of scope.\n    2. Depth starts at 1 for any dictionary, including an empty dictionary (`{}`).\n    3. Non-dictionary values within the dictionary do not affect the depth calculation and do not recurse further.\n    4. If a dictionary contains another dictionary, the depth is the maximum depth of the nested dictionaries plus 1.\n\n    Example:\n    assert dict_depth({'a': 1, 'b': {'c': {'d': {}}}}) == 4\n    \"\"\"\n```", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values() if isinstance(value, dict)), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(value) for value in d.values())) if any((isinstance(value, dict) for value in d.values())) else 1", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values())) if any((isinstance(v, dict) for v in d.values())) else 1", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            max_depth = max(max_depth, 1 + dict_depth(value))\n    return max_depth", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            current_depth = dict_depth(value) + 1\n            if current_depth > max_depth:\n                max_depth = current_depth\n    return max_depth", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            current_depth = dict_depth(value) + 1\n            if current_depth > max_depth:\n                max_depth = current_depth\n    return max_depth"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.0}}
{"task_id": "Mbpp/305", "requirement": "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return up to two words from a list of phrases where each word starts with the letter 'p' (case-insensitive). \n\n    - **Input**: \n      A list of phrases (strings). Each phrase may contain multiple words separated by whitespace.\n    \n    - **Processing**:\n      1. Split each phrase into individual words using whitespace as the delimiter.\n      2. Check each word to see if it starts with the letter 'p' or 'P' (case-insensitive).\n      3. Accumulate up to two such words in the order they appear.\n\n    - **Output**:\n      A tuple containing up to two words that start with the letter 'p' (case-insensitive). \n      - If two such words are found, return them as a two-element tuple.\n      - If only one such word is found, return it as a single-element tuple.\n      - If no such words are found, return an empty tuple.\n\n    - **Edge Cases**:\n      - If fewer than two words starting with 'p' are found, return as many as possible.\n      - Ensure consistent output format as a tuple, even in edge cases.\n\n    Example:\n    >>> assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    return tuple(result)\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                result.append(word)\n                if len(result) == 2:\n                    break\n        if len(result) == 2:\n            break\n    return tuple(result)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    return tuple(p_words)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/306", "requirement": "```python\nfrom typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum of a non-contiguous increasing subsequence \n    from the prefix of the array up to the given `index` (inclusive), such that the \n    subsequence also includes the `kth` element, where `k > index`.\n\n    The function should:\n    1. Use a dynamic programming (DP) approach to compute the maximum sum of all valid \n       non-contiguous increasing subsequences ending at each position up to `index`. \n       A subsequence is valid if it adheres to the increasing order rule \n       (`a[j] < a[i]` for all elements in the subsequence).\n    2. From the computed DP values, select the maximum sum of a subsequence where the \n       last element of the subsequence satisfies the condition `a[last] < a[k]`.\n    3. Add the value of the `kth` element (`a[k]`) to the selected subsequence's sum \n       to produce the final result.\n\n    Additional details:\n    - The `kth` element must always be included in the final sum, and it must follow \n      the increasing order rule (`a[last] < a[k]`).\n    - If no valid subsequence exists (i.e., no element in the prefix satisfies the \n      condition `a[i] < a[k]`), the result should be the value of the `kth` element alone.\n\n    Constraints:\n    - The subsequence is non-contiguous but must follow the increasing order rule \n      (`a[j] < a[i]` for all elements in the subsequence).\n    - The `kth` element is always included in the final sum.\n\n    Example:\n    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [a[i] for i in range(index + 1)]\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i] and dp[j] + a[i] > dp[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k] and dp[i] > max_sum:\n            max_sum = dp[i]\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [a[i] for i in range(index + 1)]\n    for i in range(index + 1):\n        for j in range(i):\n            if a[j] < a[i]:\n                if dp[j] + a[i] > dp[i]:\n                    dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            if dp[i] > max_sum:\n                max_sum = dp[i]\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if k <= index or k >= n:\n        return a[k]\n    dp = [0] * (index + 1)\n    result = a[k]\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n        if a[i] < a[k]:\n            result = max(result, dp[i] + a[k])\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/308", "requirement": "```python\nfrom typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest unique products \n    from two given lists, selecting one factor from each list. \n    \n    Requirements:\n    - \"Largest products\" refers to the distinct largest values (no duplicates allowed),\n      resulting from multiplying any element from nums1 with any element from nums2.\n    - The function must return exactly N products in descending order.\n    - If the number of unique products is less than N, return all the unique \n      products sorted in descending order.\n    - Assume nums1 and nums2 contain at least one element each.\n    - Inputs are guaranteed to be non-empty lists of integers.\n    \n    Example:\n    assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    \"\"\"\n```", "generated_programs": ["from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for n1 in nums1:\n        for n2 in nums2:\n            products.add(n1 * n2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:min(N, len(sorted_products))]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:min(N, len(sorted_products))]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    unique_products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            unique_products.add(product)\n    sorted_products = sorted(unique_products, reverse=True)\n    return sorted_products[:N]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/310", "requirement": "```python\ndef string_to_tuple(str1: str) -> tuple:\n    \"\"\"\n    Write a function to convert a given string to a tuple of characters, excluding any whitespace characters.\n    The function should iterate through the input string and include only non-whitespace characters in the resulting tuple.\n    Example:\n    assert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n    \"\"\"\n```", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if not char.isspace()))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if not char.isspace()))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if not char.isspace()))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if not char.isspace()))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if not char.isspace()))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if not char.isspace()))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if not char.isspace()))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if not char.isspace()))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if not char.isspace()))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if not char.isspace()))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the left-most unset bit in the binary representation of an integer `n`.\n\n    The \"left-most unset bit\" is defined as the most significant bit (highest position) in the binary representation of `n` that is currently unset (0). The binary representation is determined dynamically based on the number's value, without assuming a fixed-width constraint.\n\n    Behavior:\n    - For positive integers, the function identifies the most significant unset bit and sets it to 1.\n    - For `n == 0`, the function sets the first bit (producing `1` as the output).\n    - For `n == -1`, the function returns `-1` immediately, as all bits are considered set in the signed two's complement representation.\n    - Negative numbers other than `-1` are not explicitly handled, and the behavior for such inputs is undefined.\n\n    Example:\n    assert set_left_most_unset_bit(10) == 14\n    \"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        mask <<= 1\n    return n | mask >> 1", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    if n == -1:\n        return -1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == -1:\n        return -1\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/388", "requirement": "```python\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the highest power of 2 that is less than or equal to n.\n    \n    Requirements:\n    - The input `n` must be a positive integer (n > 0).\n    - If `n` is less than or equal to 0, the function must raise a `ValueError`.\n    - For valid inputs, the function returns the largest power of 2 that is less than or equal to `n`.\n\n    Example:\n    assert highest_Power_of_2(10) == 8\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [-5]\n    Expected Output: ['ValueError']\n    ### Test 2\n    Input: [0]\n    Expected Output: ['ValueError']\n    ### Test 3\n    Input: [10]\n    Expected Output: [8]\n    \"\"\"\n```", "generated_programs": ["import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    return 2 ** int(math.log2(n))", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "import math\n\ndef highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    power = math.floor(math.log2(n))\n    return 2 ** power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power", "def highest_Power_of_2(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/389", "requirement": "def find_lucas(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th Lucas number. The Lucas sequence is defined as:\n    - L(0) = 2\n    - L(1) = 1\n    - L(n) = L(n-1) + L(n-2) for n > 1\n\n    Requirements:\n    1. The function must handle edge cases explicitly:\n       - For n=0, return 2.\n       - For n=1, return 1.\n       - For n < 0 (negative values), return 1 as a default fallback value.\n    2. The function must compute the Lucas number iteratively, starting from the base cases (L(0) and L(1)).\n    3. The function must not use recursion to avoid issues with recursion depth for large n.\n\n    Example:\n    assert find_lucas(9) == 76\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [-1]\n    Expected Output: [1]\n    \"\"\"", "generated_programs": ["def find_lucas(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if n < 0:\n        return 1\n    elif n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b", "def find_lucas(n: int) -> int:\n    if n < 0:\n        return 1\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    a, b = (2, 1)\n    for _ in range(2, n + 1):\n        a, b = (b, a + b)\n    return b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/392", "requirement": "```python\ndef get_max_sum(n: int) -> int:\n    \"\"\"\n    Write a function to find the maximum sum possible by using the given equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Revised Requirements:\n    1. The input `n` must be a non-negative integer (`n >= 0`). The function assumes valid input and does not validate or guard against invalid inputs such as `n < 0` or non-integer values. Invalid inputs may result in undefined behavior, such as a `RecursionError`.\n    2. The function uses recursion to compute the maximum of two quantities:\n       - (a) The sum of reduced values of `n` (`f(n/2) + f(n/3) + f(n/4) + f(n/5)`).\n       - (b) The value of `n` itself.\n    3. The recursion terminates when `n == 0`, where the function returns 0 as the base case.\n    4. The function does not explicitly handle cases where `n < 0` or non-integer inputs. Such cases are considered invalid and result in undefined behavior.\n    5. Example assertion: assert get_max_sum(60) == 106.\n    \"\"\"\n```", "generated_programs": ["def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    sum_reduced = get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)\n    return max(sum_reduced, n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    sum_reduced = get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)\n    return max(sum_reduced, n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    sum_reduced = get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)\n    return max(sum_reduced, n)", "def get_max_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    sum_of_reduced = get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)\n    return max(sum_of_reduced, n)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/410", "requirement": "```python\nfrom typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    \"\"\"\n    Write a function to find the minimum integer value in a given heterogeneous list.\n    \n    The function must adhere to the following rules:\n    1. The input list can contain elements of mixed types, but only integers are considered for finding the minimum value.\n    2. If the list does not contain any integers, the function must raise a ValueError.\n    3. If the list is empty, the function must raise a ValueError.\n    4. Non-integer elements in the list are ignored during the computation of the minimum value.\n    \n    Example:\n    assert min_val(['Python', 3, 2, 4, 5, 'version']) == 2\n    \n    Input and expected output examples:\n    ### Test 1\n    Input: [[]]\n    Expected Output: ['ValueError']\n    ### Test 2\n    Input: [[]]\n    Expected Output: ['ValueError']\n    \"\"\"\n```", "generated_programs": ["from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    if not listval:\n        raise ValueError('List is empty')\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    if not listval:\n        raise ValueError('List is empty')\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers in the list')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    if not listval:\n        raise ValueError('The list is empty')\n    integers = [x for x in listval if type(x) == int]\n    if not integers:\n        raise ValueError('The list does not contain any integers')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    if not listval:\n        raise ValueError('Empty list')\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers in the list')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    if not listval:\n        raise ValueError('List is empty')\n    int_values = [x for x in listval if isinstance(x, int)]\n    if not int_values:\n        raise ValueError('No integers found in the list')\n    return min(int_values)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    if not listval:\n        raise ValueError('List is empty')\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    if not listval:\n        raise ValueError('List is empty')\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    if not listval:\n        raise ValueError('List is empty')\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('List contains no integers')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    if not listval:\n        raise ValueError('List is empty.')\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('No integers found in the list.')\n    return min(integers)", "from typing import List, Union, Any\n\ndef min_val(listval: List[Union[int, Any]]) -> int:\n    if not listval:\n        raise ValueError('List is empty or does not contain any integers.')\n    integers = [x for x in listval if isinstance(x, int)]\n    if not integers:\n        raise ValueError('List is empty or does not contain any integers.')\n    return min(integers)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/415", "requirement": "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Write a Python function to find a pair of integers with the highest product from a given array of integers.\n\n    Requirements:\n    1. If the array contains fewer than two elements, return the default pair `(0, 0)`.\n    2. Consider all pairs of integers in the array, including pairs involving negative numbers and zero.\n    3. If multiple pairs produce the same maximum product, return the first pair encountered during iteration.\n    4. The resulting pair should be returned in the order they appear in the array, without sorting or reordering.\n    5. The function should handle arrays with negative numbers and zero, treating them equally based on their product value.\n\n    Examples:\n    assert max_Product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)\n    assert max_Product([5]) == (0, 0)\n    assert max_Product([0, -1, 5, -3, -4, 2]) == (-3, -4)\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = float('-inf')\n    pair = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                pair = (arr[i], arr[j])\n    return pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_p = float('-inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] * arr[j] > max_p:\n                max_p = arr[i] * arr[j]\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (0, 0)\n    max_product = -float('inf')\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_product = arr[i] * arr[j]\n            if current_product > max_product:\n                max_product = current_product\n                max_pair = (arr[i], arr[j])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = -float('inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_p = float('-inf')\n    pair = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_p = arr[i] * arr[j]\n            if current_p > max_p:\n                max_p = current_p\n                pair = (arr[i], arr[j])\n    return pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (arr[0], arr[1])\n    max_product = arr[0] * arr[1]\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_product = arr[i] * arr[j]\n            if current_product > max_product:\n                max_product = current_product\n                max_pair = (arr[i], arr[j])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_prod = float('-inf')\n    result = (0, 0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                result = (arr[i], arr[j])\n    return result", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (arr[0], arr[1])\n    max_prod = arr[0] * arr[1]\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                max_pair = (arr[i], arr[j])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (arr[0], arr[1])\n    max_prod = arr[0] * arr[1]\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                max_pair = (arr[i], arr[j])\n    return max_pair", "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    if len(arr) < 2:\n        return (0, 0)\n    max_pair = (arr[0], arr[1])\n    max_prod = arr[0] * arr[1]\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            current_prod = arr[i] * arr[j]\n            if current_prod > max_prod:\n                max_prod = current_prod\n                max_pair = (arr[i], arr[j])\n    return max_pair"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/418", "requirement": "```python\nfrom typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    \"\"\"\n    Write a Python function to find the sublist with the maximum length in a list of lists of strings.\n    \n    The function takes a list of lists of strings as input and returns the sublist with the maximum length.\n    If the input list is empty, the function should raise a ValueError.\n    \n    Constraints:\n    - The input is always a list of lists of strings (`List[List[str]]`).\n    - The function assumes that all sublists are valid and does not handle invalid input types.\n    - If there are multiple sublists with the same maximum length, the function returns the first one encountered.\n    \n    Example:\n    assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list cannot be empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('The input list is empty.')\n    return max(lst, key=len)", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty.')\n    return max(lst, key=lambda x: len(x))", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('The input list is empty.')\n    return max(lst, key=lambda x: len(x))", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list cannot be empty.')\n    max_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) > len(max_sublist):\n            max_sublist = sublist\n    return max_sublist", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty.')\n    max_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) > len(max_sublist):\n            max_sublist = sublist\n    return max_sublist", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list cannot be empty.')\n    max_len = max((len(sublist) for sublist in lst))\n    for sublist in lst:\n        if len(sublist) == max_len:\n            return sublist", "from typing import List\n\ndef Find_Max(lst: List[List[str]]) -> List[str]:\n    if not lst:\n        raise ValueError('Input list is empty')\n    max_len = -1\n    result = []\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            result = sublist\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/427", "requirement": "```python\ndef change_date_format(dt: str) -> str:\n    \"\"\"\n    Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n    \n    The function assumes the input is a string and processes it as text without validating \n    the input format or checking for calendar-valid dates. It splits the input string by \n    the \"-\" delimiter and reverses the order of the resulting components. If the input \n    does not contain the expected \"-\" delimiter or does not conform to the \"yyyy-mm-dd\" \n    structure, the function will still process the input as-is, treating it as a generic \n    string and applying the same logic.\n\n    The function does not handle invalid dates (e.g., \"1900-02-29\") or non-standard \n    delimiters (e.g., \"yyyy/mm/dd\") beyond treating them as plain text. The output will \n    reflect the reversed order of the components based on the \"-\" delimiter, or the \n    input will remain unchanged if the delimiter is absent.\n\n    Examples:\n    assert change_date_format(\"2026-01-02\") == '02-01-2026'\n    assert change_date_format(\"1900-02-29\") == '29-02-1900'\n    assert change_date_format(\"2023/06/15\") == '2023/06/15'\n    \"\"\"\n```", "generated_programs": ["def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    if len(parts) == 3:\n        return f'{parts[2]}-{parts[1]}-{parts[0]}'\n    return dt", "def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    if len(parts) == 3:\n        return f'{parts[2]}-{parts[1]}-{parts[0]}'\n    return dt", "def change_date_format(dt: str) -> str:\n    if '-' in dt:\n        parts = dt.split('-')\n        if len(parts) == 3:\n            return f'{parts[2]}-{parts[1]}-{parts[0]}'\n    return dt", "def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    if len(parts) == 3:\n        return f'{parts[2]}-{parts[1]}-{parts[0]}'\n    return dt", "def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    if len(parts) == 3:\n        return f'{parts[2]}-{parts[1]}-{parts[0]}'\n    return dt", "def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    if len(parts) == 3:\n        return f'{parts[2]}-{parts[1]}-{parts[0]}'\n    return dt", "def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    if len(parts) == 3:\n        return f'{parts[2]}-{parts[1]}-{parts[0]}'\n    return dt", "def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    if len(parts) == 3:\n        return f'{parts[2]}-{parts[1]}-{parts[0]}'\n    return dt", "def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    if len(parts) == 3:\n        return f'{parts[2]}-{parts[1]}-{parts[0]}'\n    return dt", "def change_date_format(dt: str) -> str:\n    parts = dt.split('-')\n    if len(parts) == 3:\n        return f'{parts[2]}-{parts[1]}-{parts[0]}'\n    return dt"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "```python\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to compute the directrix of a parabola given its coefficients `a`, `b`, and `c` \n    from the standard quadratic equation `y = ax^2 + bx + c`. \n\n    The directrix is calculated using the formula:\n        directrix = (c - b ** 2 / (4 * a)) - 1 / (4 * a)\n    where intermediate results involve floating-point division. The final result is truncated \n    to an integer using `int()`.\n\n    Example:\n    assert parabola_directrix(5, 3, 2) == -198\n    \"\"\"\n```", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return int(c - b ** 2 / (4 * a) - 1 / (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return int(c - b ** 2 / (4 * a) - 1 / (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return int(c - b ** 2 / (4 * a) - 1 / (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return int(c - b ** 2 / (4 * a) - 1 / (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return int(c - b ** 2 / (4 * a) - 1 / (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return int(c - b ** 2 / (4 * a) - 1 / (4 * a))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return int(directrix)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    directrix = c - b ** 2 / (4 * a) - 1 / (4 * a)\n    return int(directrix)"], "result": {"repaired_passk": 0.09999999999999998, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/435", "requirement": "```python\ndef last_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the last digit of a given number.\n    \n    The function should:\n    1. Extract the last decimal digit of the absolute value of the input number `n`.\n       - If `n` is negative, the sign should be ignored, and the function should treat `n` as positive.\n    2. Return the last digit as an integer.\n    3. Handle special cases like `n = 0` by returning `0` as the last digit.\n    \n    Input constraints:\n    - The input `n` can be any integer, including negative numbers and zero.\n    \n    Output:\n    - The output will always be a single integer representing the last decimal digit of the absolute value of `n`.\n\n    Example:\n    assert last_Digit(123) == 3\n    \"\"\"\n```", "generated_programs": ["def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10", "def last_Digit(n: int) -> int:\n    return abs(n) % 10"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/448", "requirement": "```python\ndef cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of Perrin numbers from P(0) to P(n), \n    inclusive of both endpoints.\n\n    The Perrin sequence is defined as:\n    - P(0) = 3\n    - P(1) = 0\n    - P(2) = 2\n    - For n >= 3, P(n) = P(n-2) + P(n-3)\n\n    The function should:\n    - Compute the Perrin sequence iteratively for all indices from 0 to n (inclusive).\n    - Return the sum of all computed values in the sequence from P(0) to P(n), inclusive.\n\n    Clarifications:\n    - The sequence is generated only up to index `n`, and the sum is calculated \n      over all values in the sequence from P(0) to P(n), inclusive.\n    - No additional values beyond index `n` are generated or included in the sum.\n\n    Preconditions:\n    - `n` must be an integer.\n    - If `n` is negative, the function should return 0 (as no terms are computed).\n    - For `n == 0`, the function should return P(0) = 3.\n\n    Examples:\n    - assert cal_sum(9) == 49\n    - Input: [-1] -> Expected Output: [0]\n    - Input: [1] -> Expected Output: [3]\n    - Input: [0] -> Expected Output: [3]\n    \"\"\"\n```", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    p = [0] * (n + 1)\n    p[0] = 3\n    if n >= 1:\n        p[1] = 0\n    if n >= 2:\n        p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    perrin = [3, 0, 2]\n    if n < 3:\n        return sum(perrin[:n + 1])\n    for i in range(3, n + 1):\n        perrin.append(perrin[i - 2] + perrin[i - 3])\n    return sum(perrin)", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    p = [0] * (n + 1)\n    p[0] = 3\n    if n >= 1:\n        p[1] = 0\n    if n >= 2:\n        p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    p = [0] * (n + 1)\n    p[0] = 3\n    if n >= 1:\n        p[1] = 0\n    if n >= 2:\n        p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    p = [0] * (n + 1)\n    p[0] = 3\n    if n >= 1:\n        p[1] = 0\n    if n >= 2:\n        p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 3\n    perrin = [0] * (n + 1)\n    perrin[0] = 3\n    if n >= 1:\n        perrin[1] = 0\n    if n >= 2:\n        perrin[2] = 2\n    for i in range(3, n + 1):\n        perrin[i] = perrin[i - 2] + perrin[i - 3]\n    return sum(perrin[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    p = [0] * (n + 1)\n    p[0] = 3\n    if n >= 1:\n        p[1] = 0\n    if n >= 2:\n        p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 3\n    p = [0] * (n + 1)\n    p[0] = 3\n    if n >= 1:\n        p[1] = 0\n    if n >= 2:\n        p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [0] * (n + 1)\n    p[0] = 3\n    p[1] = 0\n    p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/450", "requirement": "def extract_string(str1: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract strings from a given list of string values where the length of each string matches the specified size.\n    assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]", "from typing import List\n\ndef extract_string(str1: List[str], l: int) -> List[str]:\n    return [s for s in str1 if len(s) == l]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/451", "requirement": "```python\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all types of whitespace characters from the given string.\n\n    Whitespace characters include spaces (' '), tabs ('\\t'), newlines ('\\n'), and any other characters \n    classified as whitespace by Python's `str.split()` method. The function should remove all occurrences \n    of these characters, including leading, trailing, and intermediate whitespaces, and return a single \n    contiguous string of non-whitespace characters.\n\n    Example:\n    assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'\n    \"\"\"\n```", "generated_programs": ["def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())", "def remove_whitespaces(text1: str) -> str:\n    return ''.join(text1.split())"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "```python\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if the input text contains at least one word \n    where the letter 'z' appears anywhere within the word. A \"word\" is defined \n    as a sequence of alphanumeric characters (including underscores) surrounded \n    by word boundaries. The function should return True if such a word exists, \n    and False otherwise.\n\n    Examples:\n    assert text_match_wordz(\"pythonz.\") == True\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/457", "requirement": "```python\nfrom typing import List, Any\n\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a Python function to find the sublist with the minimum length from a list of sublists.\n    \n    Requirements:\n    - **Input**: The function takes a list of sublists containing elements of type `Any`. \n      If the input list is empty (`[]`), the function should return an empty list (`[]`) as the output.\n    - **Processing**: The sublist with the smallest length should be identified. \n      In case multiple sublists have the same minimum length, return the first sublist encountered with that length.\n    - **Output**: The function returns a single sublist with the minimum length based on the above rules.\n      The output will always be a sublist from the input or an empty list.\n\n    Preconditions:\n    - The input must be a list of sublists (i.e., the function assumes all elements in the input are lists).\n    - Sublists can be empty (e.g., `[[]]` is valid input).\n    \n    Example:\n    assert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]\n    \"\"\"\n```", "generated_programs": ["from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    return min(lst, key=len)", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    return min(lst, key=len)", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_len = min((len(sublist) for sublist in lst))\n    for sublist in lst:\n        if len(sublist) == min_len:\n            return sublist\n    return []", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < len(min_sublist):\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    for sublist in lst:\n        if len(sublist) == min_length:\n            return sublist\n    return []", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_length = len(lst[0])\n    min_list = lst[0]\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_list = sublist\n    return min_list", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < len(min_sublist):\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_len = len(lst[0])\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_len = len(lst[0])\n    min_sublist = lst[0]\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_sublist = sublist\n    return min_sublist", "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    if not lst:\n        return []\n    min_sublist = lst[0]\n    min_length = len(min_sublist)\n    for sublist in lst:\n        current_length = len(sublist)\n        if current_length < min_length:\n            min_sublist = sublist\n            min_length = current_length\n    return min_sublist"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/460", "requirement": "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a Python function to get the first element of each sublist.\n    \n    Requirements:\n    - The input `lst` is a list of sublists.\n    - Each sublist is expected to be non-empty.\n    - If any sublist is empty, the function will raise an `IndexError`.\n    - The function does not handle or filter out empty sublists; it assumes the input meets the precondition that all sublists are non-empty.\n    \n    Example:\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]", "from typing import List, Any\n\ndef Extract(lst: List[List[Any]]) -> List[Any]:\n    return [sublist[0] for sublist in lst]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/462", "requirement": "```python\nfrom typing import List\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    \"\"\"\n    Write a function to find all possible combinations (subsets) of the elements of a given list, \n    ensuring the following rules:\n    \n    1. The combinations must respect the order of elements as they appear in the input list. \n       For example, if the input list is ['orange', 'red'], the combination ['orange', 'red'] is valid, \n       but ['red', 'orange'] is not.\n    \n    2. Each combination must be unique, and no permutations of the same elements in different orders \n       should be included. For example, ['orange', 'red'] is valid, but ['red', 'orange'] is excluded.\n    \n    3. The combinations must be generated in lexicographical order based on the sequence of the input list. \n       The output starts with an empty list (`[]`) and progressively includes elements while maintaining \n       the order of the input list.\n    \n    4. The output must include all subsets of the input list, starting with the empty subset and ending \n       with the subset containing all elements of the input list, while adhering to the above rules.\n    \n    Example:\n    assert combinations_list(['orange', 'red', 'green', 'blue']) == [\n        [], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], \n        ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], \n        ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], \n        ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']\n    ]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\n    def backtrack(start, path):\n        result.append(path)\n        for i in range(start, len(lst)):\n            backtrack(i + 1, path + [lst[i]])\n    result = []\n    backtrack(0, [])\n    return result", "from typing import List\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\n    def backtrack(index, path):\n        result.append(path)\n        for i in range(index, len(lst)):\n            backtrack(i + 1, path + [lst[i]])\n    result = []\n    backtrack(0, [])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    n = len(lst)\n    for r in range(n + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from itertools import combinations\nfrom typing import List\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for subset in combinations(lst, r):\n            result.append(list(subset)[::-1])\n    return result", "from typing import List\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\n    def backtrack(start, path):\n        result.append(path)\n        for i in range(start, len(lst)):\n            backtrack(i + 1, path + [lst[i]])\n    result = []\n    backtrack(0, [])\n    return sorted(result, key=lambda x: [lst.index(e) if e in lst else -1 for e in x])", "from typing import List\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\n    def backtrack(start, path):\n        if start > len(lst):\n            return\n        result.append(path.copy())\n        for i in range(start, len(lst)):\n            path.append(lst[i])\n            backtrack(i + 1, path)\n            path.pop()\n    result = []\n    backtrack(0, [])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    n = len(lst)\n    for r in range(n + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    n = len(lst)\n    for r in range(n + 1):\n        for combo in combinations(lst, r):\n            all_combinations.append(list(combo))\n    return sorted(all_combinations, key=lambda x: [lst.index(i) for i in x])", "from typing import List\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = [[]]\n    for i in range(len(lst)):\n        current_length = len(result)\n        for j in range(current_length):\n            new_combination = result[j] + [lst[i]]\n            result.append(new_combination)\n    return sorted(result, key=lambda x: [lst.index(element) for element in x])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/463", "requirement": "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product subarray of the given array.\n\n    A \"maximum product subarray\" is defined as the contiguous sequence of elements within the array that produces the largest possible product when multiplied together. The function should account for the following cases:\n    - Zeros in the array reset the product calculation but are valid subarray elements.\n    - Negative numbers are allowed and should be handled to maximize the product.\n    - For arrays containing only zeros or negatives, the maximum product may be zero or the largest negative number.\n    - For arrays with a single element, the maximum product is the value of that element.\n    - The input array is guaranteed to be non-empty.\n\n    Example:\n    assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = min_prod = result = arr[0]\n    for num in arr[1:]:\n        if num < 0:\n            max_prod, min_prod = (min_prod, max_prod)\n        max_prod = max(num, max_prod * num)\n        min_prod = min(num, min_prod * num)\n        result = max(result, max_prod)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = min_prod = result = arr[0]\n    for num in arr[1:]:\n        if num < 0:\n            max_prod, min_prod = (min_prod, max_prod)\n        max_prod = max(num, max_prod * num)\n        min_prod = min(num, min_prod * num)\n        result = max(result, max_prod)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = min_prod = result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_prod, min_prod = (min_prod, max_prod)\n        max_prod = max(arr[i], max_prod * arr[i])\n        min_prod = min(arr[i], min_prod * arr[i])\n        result = max(result, max_prod)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = min_prod = result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_prod, min_prod = (min_prod, max_prod)\n        max_prod = max(arr[i], max_prod * arr[i])\n        min_prod = min(arr[i], min_prod * arr[i])\n        result = max(result, max_prod)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    min_prod = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_prod, min_prod = (min_prod, max_prod)\n        max_prod = max(arr[i], max_prod * arr[i])\n        min_prod = min(arr[i], min_prod * arr[i])\n        result = max(result, max_prod)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    min_prod = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_prod, min_prod = (min_prod, max_prod)\n        max_prod = max(arr[i], max_prod * arr[i])\n        min_prod = min(arr[i], min_prod * arr[i])\n        result = max(result, max_prod)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    min_prod = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_prod, min_prod = (min_prod, max_prod)\n        max_prod = max(arr[i], max_prod * arr[i])\n        min_prod = min(arr[i], min_prod * arr[i])\n        result = max(result, max_prod)\n    return result", "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    min_prod = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_prod, min_prod = (min_prod, max_prod)\n        max_prod = max(arr[i], max_prod * arr[i])\n        min_prod = min(arr[i], min_prod * arr[i])\n        result = max(result, max_prod)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/465", "requirement": "def drop_empty(dict1: dict) -> dict:\n    \"\"\"\n    Write a function to drop items from a given dictionary where the value is explicitly `None`.\n\n    Items with values other than `None`, including falsy values such as `\"\"`, `0`, `False`, `[]`, `{}`, etc., should not be removed.\n\n    Examples:\n    assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None}) == {'c1': 'Red', 'c2': 'Green'}\n    assert drop_empty({'c1': '', 'c2': None, 'c3': 'Blue'}) == {'c1': '', 'c3': 'Blue'}\n    \"\"\"", "generated_programs": ["def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {key: value for key, value in dict1.items() if value is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}", "def drop_empty(dict1: dict) -> dict:\n    return {k: v for k, v in dict1.items() if v is not None}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n\"\"\"\nWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nassert max_product([3, 100, 4, 5, 150, 6]) == 3000\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [num for num in arr]\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp) if dp else 0", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    max_prod = 1\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n        max_prod = max(max_prod, dp[i])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/472", "requirement": "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given list contains consecutive numbers or not.\n    Consecutive numbers are defined as a sequence of unique integers that, when sorted, form a contiguous range without gaps.\n    The function should raise a ValueError for empty lists, as they are considered invalid input.\n    \n    Examples:\n    assert check_Consecutive([1, 2, 3, 4, 5]) == True\n    assert check_Consecutive([1, 3, 2, 5, 4]) == True\n    assert check_Consecutive([1, 2, 4, 5]) == False\n    assert check_Consecutive([]) == ValueError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input')\n    unique = sorted(set(l))\n    return unique == list(range(unique[0], unique[-1] + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    unique_sorted = sorted(set(l))\n    return unique_sorted == list(range(unique_sorted[0], unique_sorted[-1] + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    unique_list = sorted(set(l))\n    return unique_list == list(range(unique_list[0], unique_list[-1] + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    unique_sorted = sorted(set(l))\n    return unique_sorted == list(range(unique_sorted[0], unique_sorted[-1] + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    unique_elements = set(l)\n    if len(unique_elements) != len(l):\n        return False\n    sorted_list = sorted(unique_elements)\n    return sorted_list[-1] - sorted_list[0] == len(sorted_list) - 1", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    unique_elements = sorted(set(l))\n    if len(unique_elements) != len(l):\n        return False\n    for i in range(1, len(unique_elements)):\n        if unique_elements[i] != unique_elements[i - 1] + 1:\n            return False\n    return True", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is not allowed.')\n    unique_elements = set(l)\n    if len(unique_elements) != len(l):\n        return False\n    sorted_list = sorted(unique_elements)\n    return sorted_list == list(range(sorted_list[0], sorted_list[-1] + 1))", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input')\n    sorted_l = sorted(l)\n    unique_l = list(set(sorted_l))\n    if len(unique_l) != len(sorted_l):\n        return False\n    for i in range(1, len(unique_l)):\n        if unique_l[i] != unique_l[i - 1] + 1:\n            return False\n    return True", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    unique_sorted = sorted(set(l))\n    if len(unique_sorted) != len(l):\n        return False\n    for i in range(1, len(unique_sorted)):\n        if unique_sorted[i] != unique_sorted[i - 1] + 1:\n            return False\n    return True", "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if not l:\n        raise ValueError('Empty list is invalid input.')\n    unique_nums = sorted(set(l))\n    if len(unique_nums) != len(l):\n        return False\n    for i in range(1, len(unique_nums)):\n        if unique_nums[i] != unique_nums[i - 1] + 1:\n            return False\n    return True"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.6, "original_passk": 1.0}}
{"task_id": "Mbpp/473", "requirement": "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    \"\"\"\n    Write a function to find the intersection of tuples from two lists, where tuples are compared based on their elements irrespective of order. \n    For comparison, each tuple should be normalized by sorting its elements. The output should be a set of tuples, with each tuple in sorted order.\n\n    Example:\n    assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}\n    \"\"\"", "generated_programs": ["from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n\n    def normalize(tuples: List[Tuple]) -> Set[Tuple]:\n        return {tuple(sorted(t)) for t in tuples}\n    set1 = normalize(test_list1)\n    set2 = normalize(test_list2)\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n\n    def normalize(t: Tuple) -> Tuple:\n        return tuple(sorted(t))\n    set1 = {normalize(t) for t in test_list1}\n    set2 = {normalize(t) for t in test_list2}\n    return set1.intersection(set2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    normalized_list1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_list2 = {tuple(sorted(t)) for t in test_list2}\n    return normalized_list1.intersection(normalized_list2)", "from typing import List, Set, Tuple\n\ndef tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Set[Tuple]:\n    set1 = {tuple(sorted(t)) for t in test_list1}\n    set2 = {tuple(sorted(t)) for t in test_list2}\n    return set1.intersection(set2)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/476", "requirement": "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of the largest and smallest values in a given array of integers.\n    \n    Requirements:\n    - The input array must contain only integers.\n    - If the input array is empty (`[]`), the function should raise a `ValueError`.\n    - If the input array contains one element, the largest and smallest values are the same, and their sum should be twice that value.\n    - The function should not handle non-numeric values; such inputs are considered invalid and may raise a `TypeError`.\n\n    Example:\n    assert big_sum([1, 2, 3]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array is empty')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array cannot be empty')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array cannot be empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array cannot be empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array cannot be empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array cannot be empty')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array cannot be empty')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('The input array is empty.')\n    return max(nums) + min(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array cannot be empty.')\n    return min(nums) + max(nums)", "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    if not nums:\n        raise ValueError('Input array cannot be empty.')\n    return max(nums) + min(nums)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/478", "requirement": "```python\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove all lowercase characters from a given string.\n    \n    The function should:\n    - Preserve all non-lowercase characters (including uppercase letters, digits, and special characters) exactly as they are.\n    - Treat lowercase characters individually, removing each lowercase letter one at a time.\n    - Ensure that the order of the remaining characters in the string is maintained.\n\n    Examples:\n    assert remove_lowercase(\"PYTHon\") == \"PYTH\"\n    assert remove_lowercase(\"123PYthON\") == \"123PYON\"\n    \"\"\"\n```", "generated_programs": ["def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join((char for char in str1 if not char.islower()))", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])", "def remove_lowercase(str1: str) -> str:\n    return ''.join([char for char in str1 if not char.islower()])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/479", "requirement": "def first_Digit(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the first digit of a given number. \n    The function should only accept non-negative integers as input. If the input is negative, the function must raise a ValueError.\n    \n    Input:\n    - n: A non-negative integer.\n\n    Output:\n    - Returns the first digit of the input number as an integer.\n\n    Constraints:\n    - The input must be a non-negative integer. Negative integers are considered invalid and will result in a ValueError.\n    - The function does not handle non-integer inputs.\n\n    Examples:\n    assert first_Digit(123) == 1\n    \"\"\"", "generated_programs": ["def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n", "def first_Digit(n: int) -> int:\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    while n >= 10:\n        n = n // 10\n    return n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/559", "requirement": "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Write a function to find the sum of the contiguous sublist with the highest sum in the given list.\n\n    Requirements:\n    1. The \"largest contiguous sublist\" is defined as the sublist with the maximum sum of its elements.\n       - If all elements are negative, the sublist with the least negative sum is considered.\n    2. The input list `a` must contain integers, and its length must match the value of `size`.\n       - If `size` does not match the length of `a`, the function should raise a `ValueError`.\n    3. If the input list `a` is empty (`a=[]`) or `size=0`, the function should raise an `IndexError`.\n    4. The function assumes `size` is non-negative and `a` contains at least one integer when valid.\n\n    Example:\n    assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size != len(a):\n        raise ValueError('Size does not match the length of the list.')\n    if size == 0:\n        raise IndexError('The list is empty or size is zero.')\n    max_sum = a[0]\n    current_sum = a[0]\n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size != len(a):\n        raise ValueError('Size does not match the length of the list.')\n    if not a or size == 0:\n        raise IndexError('The list is empty or size is zero.')\n    max_sum = a[0]\n    current_sum = a[0]\n    for num in a[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size != len(a):\n        raise ValueError('Size does not match the length of the list.')\n    if not a or size == 0:\n        raise IndexError('List is empty or size is zero.')\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if len(a) != size:\n        raise ValueError('The size does not match the length of the list.')\n    if size == 0 or not a:\n        raise IndexError('The list is empty or size is zero.')\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size != len(a):\n        raise ValueError('Size does not match the length of the list.')\n    if not a or size == 0:\n        raise IndexError('The list is empty or size is zero.')\n    max_sum = a[0]\n    current_sum = a[0]\n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size != len(a):\n        raise ValueError('Size does not match the length of the list.')\n    if size == 0 or not a:\n        raise IndexError('List is empty or size is zero.')\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size != len(a):\n        raise ValueError('Size does not match the length of the list.')\n    if not a or size == 0:\n        raise IndexError('List is empty or size is zero.')\n    max_sum = a[0]\n    current_sum = a[0]\n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if len(a) != size:\n        raise ValueError('Size does not match the length of the list.')\n    if size == 0 or not a:\n        raise IndexError('The list is empty or size is zero.')\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if len(a) != size:\n        raise ValueError('Size does not match the length of the list.')\n    if size == 0 or not a:\n        raise IndexError('The list is empty or size is zero.')\n    max_sum = a[0]\n    current_sum = a[0]\n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if len(a) != size:\n        raise ValueError('Size does not match the length of the list.')\n    if not a or size == 0:\n        raise IndexError('The list is empty or size is zero.')\n    max_current = max_global = a[0]\n    for i in range(1, size):\n        max_current = max(a[i], max_current + a[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/564", "requirement": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function that takes a list of integers `arr` and an integer `n` representing the length of the list. \n    The function counts the number of possible unordered pairs (i, j) where:\n    - i and j are indices in the list such that i < j.\n    - The elements at these indices are unequal.\n\n    The function should:\n    - Consider all possible pairs of indices in the list.\n    - Exclude pairs where both elements are equal, even if duplicates exist in the list.\n\n    Examples:\n    assert count_Pairs([1, 2, 1], 3) == 2\n    assert count_Pairs([1, 1, 2, 2], 4) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/580", "requirement": "```python\ndef extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Write a function to filter a nested mixed tuple, retaining only even integers and preserving the original structure of the tuple.\n    \n    Rules:\n    1. If an element is an integer, include it in the output only if it is even.\n    2. If an element is a tuple, recursively filter its contents:\n       - Retain only even integers within the tuple.\n       - Preserve the structure of the tuple, including empty tuples if no even integers are found.\n    3. Non-integer, non-tuple elements are ignored and excluded from the output.\n    4. The depth of nesting is unconstrained, and the function should handle arbitrarily nested tuples.\n\n    Example:\n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"\n```", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for element in test_tuple:\n        if isinstance(element, int):\n            if element % 2 == 0:\n                result.append(element)\n        elif isinstance(element, tuple):\n            filtered_tuple = extract_even(element)\n            result.append(filtered_tuple)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for element in test_tuple:\n        if isinstance(element, int) and element % 2 == 0:\n            result.append(element)\n        elif isinstance(element, tuple):\n            filtered_tuple = extract_even(element)\n            if filtered_tuple:\n                result.append(filtered_tuple)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for element in test_tuple:\n        if isinstance(element, int):\n            if element % 2 == 0:\n                result.append(element)\n        elif isinstance(element, tuple):\n            filtered_tuple = extract_even(element)\n            if filtered_tuple:\n                result.append(filtered_tuple)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for element in test_tuple:\n        if isinstance(element, int):\n            if element % 2 == 0:\n                result.append(element)\n        elif isinstance(element, tuple):\n            filtered_tuple = extract_even(element)\n            result.append(filtered_tuple)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, int):\n            if item % 2 == 0:\n                result.append(item)\n        elif isinstance(item, tuple):\n            filtered_tuple = extract_even(item)\n            if filtered_tuple:\n                result.append(filtered_tuple)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_element(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            filtered = tuple(filter(None, map(filter_element, element)))\n            return filtered if filtered else ()\n        else:\n            return None\n    result = tuple(filter(None, map(filter_element, test_tuple)))\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_element(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            filtered = tuple(filter(None, (filter_element(item) for item in element)))\n            return filtered if filtered else ()\n        else:\n            return None\n    return tuple(filter(None, (filter_element(item) for item in test_tuple)))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_element(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            return tuple((item for item in map(filter_element, element) if item is not None))\n        else:\n            return None\n    filtered_tuple = tuple((item for item in map(filter_element, test_tuple) if item is not None))\n    return filtered_tuple", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_element(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            filtered = tuple(filter(lambda x: x is not None, map(filter_element, element)))\n            return filtered if filtered else None\n        else:\n            return None\n    result = tuple(filter(lambda x: x is not None, map(filter_element, test_tuple)))\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def filter_even(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            filtered = tuple(filter(lambda x: x is not None, map(filter_even, element)))\n            return filtered if filtered else ()\n        else:\n            return None\n    result = tuple(filter(lambda x: x is not None, map(filter_even, test_tuple)))\n    return result"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n    \"\"\"\n    Write a Python function to find the surface area of a square pyramid given the base edge length (`b`) and the vertical height (`s`).\n    \n    The surface area is calculated as the sum of:\n    1. The base area, which is a square with side length `b` (computed as `b ** 2`).\n    2. The lateral surface area, which is simplified as `2 * b * s`, where `s` is the vertical height (perpendicular distance from the apex to the center of the base).\n\n    Note: This implementation uses a simplified formula for the lateral surface area and does not involve slant height or trigonometric calculations.\n\n    Example:\n    assert surface_Area(3, 4) == 33\n    \"\"\"", "generated_programs": ["def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/589", "requirement": "from typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function to find perfect squares between two given numbers, inclusive of the boundaries.\n    \n    The function should:\n    1. Return a list of perfect squares between `a` and `b`, including `a` and `b` if they are perfect squares.\n    2. Handle invalid inputs as follows:\n       - If `a` or `b` is negative, raise a `ValueError` since square roots of negative numbers are undefined in real numbers.\n       - If `a > b`, raise a `ValueError` since the range is invalid.\n    3. Use integer inputs only. Non-integer inputs will raise a `TypeError`.\n\n    Mathematical calculations:\n    - Use `math.ceil(math.sqrt(a))` to determine the starting point of the range.\n    - Use `math.floor(math.sqrt(b))` to determine the endpoint of the range.\n    - Iterate through the inclusive range of integers and compute their squares.\n\n    Example:\n    assert perfect_squares(1, 30) == [1, 4, 9, 16, 25]\n    \"\"\"", "generated_programs": ["import math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs cannot be negative.')\n    if a > b:\n        raise ValueError('Invalid range: a cannot be greater than b.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "import math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        raise ValueError('First input must be less than or equal to the second input.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "import math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative')\n    if a > b:\n        raise ValueError('Invalid range: a must be less than or equal to b')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    result = [i ** 2 for i in range(start, end + 1)]\n    return result", "import math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        raise ValueError('a must be less than or equal to b.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    result = []\n    for i in range(start, end + 1):\n        result.append(i * i)\n    return result", "import math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Both inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        raise ValueError('First input must be less than or equal to the second input.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "import math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        raise ValueError('Invalid range: a must be less than or equal to b.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "from typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        raise ValueError('The first input must be less than or equal to the second input.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i ** 2 for i in range(start, end + 1)]", "import math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        raise ValueError('The first input must be less than or equal to the second input.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    squares = [i * i for i in range(start, end + 1)]\n    return squares", "code\nimport math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        raise ValueError('Start of range must be less than or equal to end of range.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "import math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError('Inputs must be integers.')\n    if a < 0 or b < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if a > b:\n        raise ValueError('The first input must be less than or equal to the second input.')\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)] if start <= end else []"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Write a function to convert rectangular coordinates (x, y) to polar coordinates and perform a secondary computation.\n\n    The function performs the following steps:\n    1. Converts the input rectangular coordinates (x, y) into polar coordinates:\n       - `magnitude` is calculated as the Euclidean distance: sqrt(x**2 + y**2).\n       - `angle` is calculated as the counterclockwise angle from the positive x-axis using atan2(y, x).\n       The polar coordinates are returned as a tuple: (magnitude, angle).\n\n    2. Computes a secondary rectangular representation using a shifted polar angle:\n       - The angle is incremented by  (180 rotation).\n       - Using the original magnitude and the shifted angle, a complex number is computed via cmath.rect.\n       This complex number represents the rectangular coordinates derived from the shifted polar angle.\n\n    The function returns:\n    - A tuple containing the polar coordinates (magnitude, angle).\n    - A complex number representing the rectangular coordinates computed from the shifted polar angle.\n\n    Example:\n    assert polar_rect(3, 4) == ((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    shifted_angle = angle + math.pi\n    complex_num = cmath.rect(magnitude, shifted_angle)\n    return ((magnitude, angle), complex_num)", "import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    shifted_angle = angle + math.pi\n    complex_num = cmath.rect(magnitude, shifted_angle)\n    return ((magnitude, angle), complex_num)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    shifted_angle = angle + math.pi\n    shifted_complex = math.rect(magnitude, shifted_angle)\n    return ((magnitude, angle), shifted_complex)", "import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    shifted_angle = angle + math.pi\n    complex_num = cmath.rect(magnitude, shifted_angle)\n    return ((magnitude, angle), complex_num)", "import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    shifted_angle = angle + math.pi\n    shifted_complex = cmath.rect(magnitude, shifted_angle)\n    return ((magnitude, angle), shifted_complex)", "import cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = cmath.sqrt(x ** 2 + y ** 2).real\n    angle = cmath.atan2(y, x)\n    shifted_angle = angle + cmath.pi\n    complex_num = cmath.rect(magnitude, shifted_angle)\n    return ((magnitude, angle), complex_num)", "import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    shifted_angle = angle + math.pi\n    complex_num = cmath.rect(magnitude, shifted_angle)\n    return ((magnitude, angle), complex_num)", "import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    shifted_angle = angle + math.pi\n    complex_num = cmath.rect(magnitude, shifted_angle)\n    return ((magnitude, angle), complex_num)", "import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    shifted_angle = angle + math.pi\n    complex_rect = cmath.rect(magnitude, shifted_angle)\n    return ((magnitude, angle), complex_rect)", "import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    shifted_angle = angle + math.pi\n    shifted_complex = cmath.rect(magnitude, shifted_angle)\n    return ((magnitude, angle), shifted_complex)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/592", "requirement": "def sum_Of_product(n: int) -> int:\n\"\"\"\nWrite a python function to find the sum of the product of consecutive binomial co-efficients.\nassert sum_Of_product(3) == 15\n\"\"\"", "generated_programs": ["from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(n, i) * comb(n, i + 1) for i in range(n)))", "import math\n\ndef sum_Of_product(n: int) -> int:\n    return sum((math.comb(n, k) * math.comb(n, k + 1) for k in range(n)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    return sum((comb(i, j) * comb(i, j + 1) for i in range(1, n + 1) for j in range(i)))", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    total = 0\n    for i in range(1, n + 1):\n        total += comb(n, i) * comb(n, i + 1)\n    return total", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    total = 0\n    for i in range(1, n + 1):\n        total += comb(n, i) * comb(n, i + 1)\n    return total", "from math import comb\n\ndef sum_Of_product(n: int) -> int:\n    total = 0\n    for i in range(1, n + 1):\n        total += comb(n, i) * comb(n, i + 1)\n    return total"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the absolute difference between the first even number and the first odd number in a given list.\n    \n    - The function assumes that the input list contains at least one even number and one odd number.\n    - If the list does not contain an even number or an odd number, the function will raise a `StopIteration` exception.\n    - The function will return an integer representing the absolute difference between the first even and first odd numbers.\n\n    Example:\n    assert diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return abs(first_even - first_odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0), None)\n    odd = next((x for x in list1 if x % 2 != 0), None)\n    if even is None or odd is None:\n        raise StopIteration('List does not contain both even and odd numbers.')\n    return abs(even - odd)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_num = next((x for x in list1 if x % 2 == 0), None)\n    odd_num = next((x for x in list1 if x % 2 != 0), None)\n    if even_num is None or odd_num is None:\n        raise StopIteration('The list does not contain both even and odd numbers.')\n    return abs(even_num - odd_num)", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration('The list does not contain at least one even and one odd number.')\n    return abs(first_even - first_odd)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/599", "requirement": "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n    Write a function to find the sum and average of the first `n` natural numbers.\n\n    - The term \"first `n` natural numbers\" refers to the sequence of positive integers starting from 1 up to `n` (inclusive).\n    - The input `number` must be a non-negative integer. If `number` is negative, the function should return `(0, -0.0)` as the sum and average over an empty range.\n    - If `number` is 0, the function should raise a `ZeroDivisionError` because the average cannot be computed for an empty range.\n    - For positive integers, the function computes the sum of the first `n` natural numbers and their average.\n\n    Example:\n    assert sum_average(10) == (55, 5.5)\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [0]\n    Expected Output: ['ZeroDivisionError']\n    ### Test 2\n    Input: [-5]\n    Expected Output: [(0, -0.0)]\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number < 0:\n        return (0, -0.0)\n    elif number == 0:\n        raise ZeroDivisionError\n    else:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number < 0:\n        return (0, -0.0)\n    elif number == 0:\n        raise ZeroDivisionError\n    else:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number < 0:\n        return (0, -0.0)\n    elif number == 0:\n        raise ZeroDivisionError\n    else:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number < 0:\n        return (0, -0.0)\n    elif number == 0:\n        raise ZeroDivisionError\n    else:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number < 0:\n        return (0, -0.0)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty range.')\n    else:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number < 0:\n        return (0, -0.0)\n    if number == 0:\n        raise ZeroDivisionError\n    total_sum = number * (number + 1) // 2\n    average = total_sum / number\n    return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number < 0:\n        return (0, -0.0)\n    if number == 0:\n        raise ZeroDivisionError\n    total_sum = number * (number + 1) // 2\n    average = total_sum / number\n    return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number < 0:\n        return (0, -0.0)\n    if number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty range.')\n    total_sum = number * (number + 1) // 2\n    average = total_sum / number\n    return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number < 0:\n        return (0, -0.0)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty range.')\n    else:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)", "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    if number < 0:\n        return (0, -0.0)\n    elif number == 0:\n        raise ZeroDivisionError('Cannot compute average for an empty range.')\n    else:\n        total_sum = number * (number + 1) // 2\n        average = total_sum / number\n        return (total_sum, average)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/602", "requirement": "```python\ndef first_repeated_char(str1: str) -> str:\n    \"\"\"\n    Write a Python function to find the first repeated character in a given string.\n\n    The function should:\n    - Traverse the string from left to right to identify the first character that is repeated.\n    - Return the first repeated character as a string if found.\n    - Return an empty string (\"\") if no repeated character exists.\n    - Handle case-sensitive comparisons (e.g., 'A' and 'a' are considered different characters).\n    - For edge cases:\n      - Return an empty string (\"\") for an empty input string or a string with only one character.\n\n    Example/Assertion:\n    assert first_repeated_char(\"abcabc\") == \"a\"\n    \"\"\"\n```", "generated_programs": ["def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''", "def first_repeated_char(str1: str) -> str:\n    if not str1 or len(str1) == 1:\n        return ''\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return ''"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/603", "requirement": "def get_ludic(n: int) -> List[int]:\n    \"\"\"\n    Write a function to get all ludic numbers smaller than or equal to a given integer `n`.\n\n    Ludic numbers are determined using the following iterative process:\n    1. Start with a list of integers from 1 to `n` (inclusive).\n    2. Begin with the second element in the list (index 1, using 0-based indexing for implementation).\n    3. For each element at position `index` in the list (0-based indexing), let `step` be the value of the element at that position.\n       Remove every `step`-th element from the list, starting from the position `index + step`. Specifically, remove elements at positions \n       `index + step`, `index + 2*step`, and so on, until the end of the list. After each removal, the list is updated immediately.\n    4. Continue this process for each remaining element in the list, moving to the next position, until no more elements can be removed.\n\n    The function returns the remaining numbers in the list after applying the above process.\n\n    Example:\n    assert get_ludic(10) == [1, 2, 3, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_list = list(range(1, n + 1))\n    index = 1\n    while index < len(ludic_list):\n        step = ludic_list[index]\n        i = index + step\n        while i < len(ludic_list):\n            ludic_list.pop(i)\n            i += step - 1\n        index += 1\n    return ludic_list", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_list = list(range(1, n + 1))\n    index = 1\n    while index < len(ludic_list):\n        step = ludic_list[index]\n        i = index + step\n        while i < len(ludic_list):\n            ludic_list.pop(i)\n            i += step - 1\n        index += 1\n    return ludic_list", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_list = list(range(1, n + 1))\n    index = 1\n    while index < len(ludic_list):\n        step = ludic_list[index]\n        current = index + step\n        while current < len(ludic_list):\n            ludic_list.pop(current)\n            current += step - 1\n        index += 1\n    return ludic_list", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = list(range(1, n + 1))\n    index = 1\n    while index < len(ludic_numbers):\n        step = ludic_numbers[index]\n        i = index + step\n        while i < len(ludic_numbers):\n            ludic_numbers.pop(i)\n            i += step - 1\n        index += 1\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_list = list(range(1, n + 1))\n    index = 1\n    while index < len(ludic_list):\n        step = ludic_list[index]\n        i = index + step\n        while i < len(ludic_list):\n            ludic_list.pop(i)\n            i += step - 1\n        index += 1\n    return ludic_list", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = list(range(1, n + 1))\n    index = 1\n    while index < len(ludic_numbers):\n        step = ludic_numbers[index]\n        i = index + step\n        while i < len(ludic_numbers):\n            ludic_numbers.pop(i)\n            i += step - 1\n        index += 1\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = list(range(1, n + 1))\n    index = 1\n    while index < len(ludic_numbers):\n        step = ludic_numbers[index]\n        i = index + step\n        while i < len(ludic_numbers):\n            ludic_numbers.pop(i)\n            i += step - 1\n        index += 1\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = list(range(1, n + 1))\n    index = 1\n    while index < len(ludic_numbers):\n        step = ludic_numbers[index]\n        i = index + step\n        while i < len(ludic_numbers):\n            ludic_numbers.pop(i)\n            i += step - 1\n        index += 1\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_numbers = list(range(1, n + 1))\n    index = 1\n    while index < len(ludic_numbers):\n        step = ludic_numbers[index]\n        i = index + step\n        while i < len(ludic_numbers):\n            ludic_numbers.pop(i)\n            i += step - 1\n        index += 1\n    return ludic_numbers", "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    ludic_list = list(range(1, n + 1))\n    index = 1\n    while index < len(ludic_list):\n        step = ludic_list[index]\n        del_indices = []\n        i = index + step\n        while i < len(ludic_list):\n            del_indices.append(i)\n            i += step\n        for i in reversed(del_indices):\n            ludic_list.pop(i)\n        index += 1\n    return ludic_list"], "result": {"repaired_passk": 0.8, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/604", "requirement": "```python\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse the order of words in a given string. Words are defined as sequences of non-space characters separated by spaces. \n    The function should:\n    1. Normalize whitespace by collapsing consecutive spaces into a single space and removing leading or trailing spaces.\n    2. Reverse the order of the words in the input string.\n    3. Return the reversed words as a single space-separated string.\n\n    Example:\n    assert reverse_words(\"python program\") == \"program python\"\n    \"\"\"\n```", "generated_programs": ["def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.strip().split()))", "def reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))", "def reverse_words(s: str) -> str:\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "def reverse_words(s: str) -> str:\n    words = s.strip().split()\n    words.reverse()\n    return ' '.join(words)", "def reverse_words(s: str) -> str:\n    words = s.strip().split()\n    words.reverse()\n    return ' '.join(words)", "def reverse_words(s: str) -> str:\n    words = s.strip().split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "def reverse_words(s: str) -> str:\n    normalized = ' '.join(s.split())\n    reversed_words = ' '.join(normalized.split(' ')[::-1])\n    return reversed_words"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/608", "requirement": "def bell_Number(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the nth Bell number.\n\n    Requirements:\n    - The input `n` must be a non-negative integer.\n    - If `n` is negative, the function should raise an `IndexError`.\n    - The function calculates the nth Bell number using the Bell triangle approach.\n    - Example:\n        assert bell_Number(2) == 2\n    \"\"\"", "generated_programs": ["def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input `n` must be a non-negative integer.')\n    bell = [[1]]\n    for i in range(1, n + 1):\n        bell.append([bell[i - 1][-1]])\n        for j in range(1, i + 1):\n            bell[i].append(bell[i][j - 1] + bell[i - 1][j - 1])\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('The input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    bell = [[1]]\n    for i in range(1, n + 1):\n        row = [bell[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + bell[i - 1][j - 1])\n        bell.append(row)\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be a non-negative integer')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "from typing import List\n\ndef bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    if n == 0:\n        return 1\n    triangle: List[List[int]] = [[1]]\n    for i in range(1, n + 1):\n        row = [triangle[i - 1][-1]]\n        for j in range(1, i + 1):\n            row.append(row[j - 1] + triangle[i - 1][j - 1])\n        triangle.append(row)\n    return triangle[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('Input must be a non-negative integer.')\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be a non-negative integer.')\n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "def bell_Number(n: int) -> int:\n    if n < 0:\n        raise IndexError('n must be a non-negative integer')\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/610", "requirement": "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function that takes a list of integers and an integer `k`, and returns a new list with the same elements, except the k'th element is removed. \n\n    Requirements:\n    1. Indexing for `k` is **1-based**. The first element corresponds to `k=1`, the second element to `k=2`, and so on.\n    2. If `k` is less than 1 or greater than the length of the list, the function should return the original list unchanged.\n    3. The function should not modify the input list; it should return a new list.\n\n    Example:\n    assert remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1[:]\n    return list1[:k - 1] + list1[k:]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/611", "requirement": "from typing import List\n\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n\"\"\"\nWrite a function which given a matrix represented as a list of lists returns the max of the n'th column.\nassert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))", "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    return max((row[N] for row in test_list))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/615", "requirement": "```python\nfrom typing import List\nfrom typing import Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    \"\"\"\n    Write a function which takes a tuple of tuples, where all inner tuples are guaranteed to have the same length, \n    and returns a list containing the average of elements at each corresponding position across all inner tuples.\n\n    For example:\n    - If the input is ((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)), \n      the function calculates averages for each position:\n      - Position 1: (10 + 30 + 81 + 1) / 4 = 30.5\n      - Position 2: (10 + 45 + 80 + 2) / 4 = 34.25\n      - Position 3: (10 + 56 + 39 + 3) / 4 = 27.0\n      - Position 4: (12 + 45 + 32 + 4) / 4 = 23.25\n    - The output is [30.5, 34.25, 27.0, 23.25].\n\n    The function assumes that all inner tuples have equal lengths. If the input does not meet this condition, \n    the behavior is undefined.\n\n    Example:\n    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]\n    \"\"\"\n```", "generated_programs": ["from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(nums) for column in zip(*nums)]", "code\nfrom typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(nums) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(x) / len(nums) for x in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum((inner[i] for inner in nums)) / len(nums) for i in range(len(nums[0]))]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(nums) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(nums) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(nums) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    num_tuples = len(nums)\n    num_elements = len(nums[0]) if num_tuples > 0 else 0\n    averages = [0.0] * num_elements\n    for tup in nums:\n        for i in range(num_elements):\n            averages[i] += tup[i]\n    return [avg / num_tuples for avg in averages]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    num_tuples = len(nums)\n    if num_tuples == 0:\n        return []\n    tuple_length = len(nums[0])\n    averages = [0.0] * tuple_length\n    for inner_tuple in nums:\n        for i, num in enumerate(inner_tuple):\n            averages[i] += num\n    averages = [total / num_tuples for total in averages]\n    return averages"], "result": {"repaired_passk": 0.6, "cross_model_passk": 0.6, "original_passk": 1.0}}
{"task_id": "Mbpp/620", "requirement": "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    \"\"\"\n    Write a function to find the size of the largest subset of a list of numbers such that for every pair of numbers in the subset, the larger number is divisible by the smaller number. \n\n    - The function considers divisibility in one direction only: `a[i] % a[j] == 0`, where `a[i]` is the larger number and `a[j]` is the smaller number.\n    - Negative numbers are valid inputs and are treated the same as positive numbers for divisibility checks.\n    - If the input list is empty, the function returns `0`.\n\n    Example:\n    assert largest_subset([1, 3, 6, 13, 17, 18]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted(map(abs, a))\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    n = len(a)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a_sorted = sorted([abs(x) for x in a])\n    dp = [1] * len(a_sorted)\n    for i in range(1, len(a_sorted)):\n        for j in range(i):\n            if a_sorted[i] % a_sorted[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted([abs(x) for x in a])\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "from typing import List\n\ndef largest_subset(a: List[int]) -> int:\n    if not a:\n        return 0\n    a = sorted(map(abs, a))\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] % a[j] == 0 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/622", "requirement": "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    \"\"\"\n    Write a function to find the median of two sorted lists of the same size. \n    The function must merge the two sorted input lists into one sorted list and calculate the median by accessing the middle elements. \n    Preconditions:\n    - Both input lists (`nums1` and `nums2`) must be sorted in non-decreasing order.\n    - Both input lists must have exactly `n` elements, where `n > 0`.\n    - If `n <= 0` or the input lists are empty, the function must raise an `IndexError`.\n    - Negative values are allowed in the input lists.\n\n    Example:\n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or not nums1 or (not nums2):\n        raise IndexError\n    merged = sorted(nums1 + nums2)\n    mid = n\n    return (merged[mid - 1] + merged[mid]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or not nums1 or (not nums2):\n        raise IndexError('Invalid input lists or size.')\n    merged = sorted(nums1 + nums2)\n    mid = n\n    return (merged[mid - 1] + merged[mid]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or not nums1 or (not nums2):\n        raise IndexError('Input lists must not be empty and n must be greater than 0.')\n    merged = sorted(nums1 + nums2)\n    mid = n\n    return (merged[mid - 1] + merged[mid]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or not nums1 or (not nums2):\n        raise IndexError\n    merged = sorted(nums1 + nums2)\n    mid = n\n    if 2 * n % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or not nums1 or (not nums2):\n        raise IndexError\n    merged = sorted(nums1 + nums2)\n    mid = (len(merged) - 1) // 2\n    if len(merged) % 2 == 1:\n        return float(merged[mid])\n    else:\n        return (merged[mid] + merged[mid + 1]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or not nums1 or (not nums2):\n        raise IndexError('Input lists must have at least one element and n must be greater than 0.')\n    merged = sorted(nums1 + nums2)\n    mid = n\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or not nums1 or (not nums2):\n        raise IndexError('Input lists must be non-empty and n must be greater than 0.')\n    merged = sorted(nums1 + nums2)\n    mid = n\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or not nums1 or (not nums2):\n        raise IndexError('Invalid input lists or size')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2.0\n    else:\n        return float(merged[mid])", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or not nums1 or (not nums2):\n        raise IndexError('Input lists must have exactly `n` elements where `n > 0`.')\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2.0\n    else:\n        return float(merged[mid])", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    if n <= 0 or not nums1 or (not nums2):\n        raise IndexError('Input lists must be non-empty and n must be positive.')\n    merged = sorted(nums1 + nums2)\n    if len(merged) != 2 * n:\n        raise IndexError('Input lists must have exactly n elements.')\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return float(merged[mid])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> Optional[float]:\n    \"\"\"\n    Write a Python function to calculate the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n    \n    The largest triangle inscribed in a semicircle is a right triangle where:\n    - The base of the triangle is equal to the diameter of the semicircle (2 * radius).\n    - The height of the triangle is equal to the radius of the semicircle.\n    - The area of the triangle is calculated using the formula: (1/2) * base * height = radius * radius.\n\n    Input:\n    - `radius` (float): The radius of the semicircle. Must be a non-negative number.\n\n    Output:\n    - Returns the area of the triangle as a float if `radius > 0`.\n    - Returns `None` if `radius <= 0`, including cases where the radius is negative or zero.\n\n    Examples:\n    assert triangle_area(-1) == None\n    assert triangle_area(0) == None\n    assert triangle_area(1) == 1\n    \"\"\"", "generated_programs": ["from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius > 0:\n        return radius * radius\n    else:\n        return None", "code\nfrom typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius", "from typing import Optional\n\ndef triangle_area(radius: float) -> Optional[float]:\n    if radius <= 0:\n        return None\n    return radius * radius"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/631", "requirement": "```python\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function that replaces spaces (' ') with underscores ('_') and underscores ('_') with spaces (' ') \n    simultaneously in a given string. The function should process each character individually, ensuring that:\n    - Spaces (' ') are replaced with underscores ('_').\n    - Underscores ('_') are replaced with spaces (' ').\n    - All other characters remain unchanged.\n    \n    The replacement must occur in a single traversal of the input string, without cascading substitutions or \n    intermediate processing. The function should handle strings containing any combination of spaces, underscores, \n    and other characters, including edge cases such as empty strings or strings with consecutive spaces/underscores.\n\n    Example:\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    assert replace_spaces(' __ ') == '_  _'\n    assert replace_spaces('Underscore_Test') == 'Underscore Test'\n    \"\"\"\n```", "generated_programs": ["def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "def replace_spaces(text: str) -> str:\n    result = []\n    for char in text:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/638", "requirement": "```python\ndef wind_chill(v: float, t: float) -> int:\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the nearest integer using standard mathematical rounding \n    (e.g., round() in Python). The wind velocity is provided in km/h, and the temperature is in Celsius. \n\n    Constraints:\n    - Wind velocity (v) must be non-negative (v >= 0). If v < 0, raise a ValueError.\n    - The formula assumes wind velocity is directly in km/h without requiring unit conversion.\n\n    Formula:\n    Wind chill index = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n\n    Examples:\n    - assert wind_chill(120, 35) == 40\n    - Input: [-1, 20] -> Expected Output: ['ValueError']\n    - Input: [0, 10] -> Expected Output: [19]\n    \"\"\"\n```", "generated_programs": ["def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)", "def wind_chill(v: float, t: float) -> int:\n    if v < 0:\n        raise ValueError('Wind velocity must be non-negative.')\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/643", "requirement": "def text_match_wordz_middle(text: str) -> bool:\n\"\"\"\nWrite a function that checks if a strings contains 'z', except at the start and end of the word.\nassert text_match_wordz_middle(\"pythonzabc.\")==True\n\"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w+z\\\\w+\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w+z\\\\w+\\\\b', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w+z\\\\w+\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b\\\\w+z\\\\w+\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\b[a-zA-Z]*z[a-zA-Z]*\\\\b'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = re.compile('\\\\b[a-zA-Z]*z[a-zA-Z]+\\\\b')\n    return bool(pattern.search(text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "Mbpp/644", "requirement": "```python\nfrom typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function to reverse the elements of an array up to a given position `k`.\n    \n    The function should:\n    1. Reverse the elements of the array from the start up to, but not including, the position `k`.\n    2. Concatenate the reversed portion with the remaining elements of the array starting from position `k`.\n    3. Handle edge cases as follows:\n       - If `k` is negative, treat it as `0` (no reversal occurs).\n       - If `k` exceeds the length of the array, treat it as the array's length (reverse the entire array).\n       - If `k` is `0`, return the array unchanged (no reversal occurs).\n       - If the input array is empty, return an empty array.\n    \n    Example:\n    assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k < 0:\n        k = 0\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k <= 0:\n        return input\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k < 0:\n        k = 0\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k < 0:\n        k = 0\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k < 0:\n        k = 0\n    if k > len(input):\n        k = len(input)\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k < 0:\n        k = 0\n    if k > len(input):\n        k = len(input)\n    if k == 0:\n        return input\n    return input[:k][::-1] + input[k:]", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k < 0:\n        k = 0\n    elif k > len(input):\n        k = len(input)\n    if k == 0:\n        return input.copy()\n    reversed_part = input[:k][::-1]\n    remaining_part = input[k:]\n    return reversed_part + remaining_part", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k < 0:\n        k = 0\n    if k > len(input):\n        k = len(input)\n    reversed_part = input[:k][::-1]\n    remaining_part = input[k:]\n    return reversed_part + remaining_part", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k < 0:\n        k = 0\n    if k > len(input):\n        k = len(input)\n    if k == 0:\n        return input.copy()\n    reversed_part = input[:k][::-1]\n    remaining_part = input[k:]\n    return reversed_part + remaining_part", "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    if not input:\n        return []\n    if k < 0:\n        k = 0\n    elif k > len(input):\n        k = len(input)\n    if k == 0:\n        return input\n    reversed_part = input[:k][::-1]\n    remaining_part = input[k:]\n    return reversed_part + remaining_part"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/722", "requirement": "def filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    The input is given as:\n    - a dictionary where each key is a student name (string) and each value is a tuple of two floats representing the student's height and weight respectively,\n    - a minimal height (float),\n    - a minimal weight (float).\n\n    Write a function to filter students such that only those with height greater than or equal to the minimal height and weight greater than or equal to the minimal weight are included in the output.\n\n    Example:\n    assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70) == {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/734", "requirement": "def sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to calculate the sum of the products of all contiguous subarrays \n    (sublists formed by consecutive elements) of a given list. \n\n    For each subarray, compute the product of its elements and add it to the total sum.\n\n    Example:\n    assert sum_Of_Subarray_Prod([1,2,3]) == 20\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    for i in range(len(arr)):\n        product = 1\n        for j in range(i, len(arr)):\n            product *= arr[j]\n            total += product\n    return total", "code\nfrom typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/735", "requirement": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Write a Python function to toggle all bits of the number except the first (most significant) and the last (least significant) bit. \n    If the number has fewer than 3 bits, return the number unchanged. The toggling should respect the bit-length of the input number, ensuring the result fits within the same number of bits.\n\n    Example:\n    assert toggle_middle_bits(9) == 15\n    \"\"\"", "generated_programs": ["def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n < 4:\n        return n\n    bit_length = n.bit_length()\n    mask = (1 << bit_length - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n < 3:\n        return n\n    bit_length = n.bit_length()\n    mask = (1 << bit_length - 1) - 1\n    mask &= ~1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n < 2:\n        return n\n    bit_length = n.bit_length()\n    if bit_length < 3:\n        return n\n    mask = (1 << bit_length - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    mask = (1 << n.bit_length() - 1) - 1\n    mask &= ~1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n == 0:\n        return 0\n    num_bits = n.bit_length()\n    if num_bits < 3:\n        return n\n    mask = (1 << num_bits - 1) - 2\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n < 2:\n        return n\n    num_bits = n.bit_length()\n    if num_bits < 3:\n        return n\n    mask = (1 << num_bits - 1) - 1\n    mask &= ~1\n    return n ^ mask", "def toggle_middle_bits(n: int) -> int:\n    if n.bit_length() < 3:\n        return n\n    first_bit = n >> n.bit_length() - 1\n    last_bit = n & 1\n    mask = (1 << n.bit_length() - 1) - 1\n    middle_bits = (n & mask) >> 1\n    toggled_middle = middle_bits ^ (1 << n.bit_length() - 2) - 1\n    result = first_bit << n.bit_length() - 1 | toggled_middle << 1 | last_bit\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/740", "requirement": "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    \"\"\"\n    Write a function to convert the given tuple to a key-value dictionary using adjacent elements. \n    The function should adhere to the following rules:\n    1. If the tuple contains an odd number of elements, the last unpaired element should be ignored.\n    2. If the tuple is empty, the function should return an empty dictionary `{}`.\n    3. For single-element tuples or tuples with no adjacent pairs, the function should return an empty dictionary `{}`.\n    4. The function should not raise exceptions for valid inputs, including odd-length tuples or empty tuples.\n\n    Example:\n    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result", "from typing import Dict, Tuple, Any\n\ndef tuple_to_dict(test_tup: Tuple[Any, ...]) -> Dict[Any, Any]:\n    if not test_tup or len(test_tup) == 1:\n        return {}\n    result = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/743", "requirement": "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    \"\"\"\n    Write a function to rotate a given list by a specified number of items to the right direction.\n\n    Requirements:\n    1. If the input list `l` is empty, the function should return an empty list (`[]`) without raising an error.\n    2. The rotation count `m` should be normalized using modulo operation (`m % len(l)`) to ensure it aligns with the valid range of the list length. This normalization is applied only when the list is non-empty.\n    3. If `m == 0`, the function should return the original list without modification.\n    4. The function should handle edge cases gracefully:\n       - For an empty list input, return `[]`.\n       - For negative or excessively large values of `m`, apply modulo normalization to determine the effective rotation count.\n    5. The input list `l` is not guaranteed to have a non-zero length, and the function must handle this case explicitly.\n\n    Example:\n    assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    m = m % len(l)\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n\n    return l[-m:] + l[:-m]", "code\nfrom typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    normalized_m = m % len(l)\n    if normalized_m == 0:\n        return l.copy()\n    return l[-normalized_m:] + l[:-normalized_m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    m = m % len(l)\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]", "from typing import List\n\ndef rotate_right(l: List[int], m: int) -> List[int]:\n    if not l:\n        return []\n    n = len(l)\n    m = m % n\n    if m == 0:\n        return l.copy()\n    return l[-m:] + l[:-m]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n\"\"\"\nWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. \nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if all((digit != '0' and num % int(digit) == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if all((digit != '0' and num % int(digit) == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % digit == 0 for digit in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(digit) for digit in str(num) if int(digit) != 0]\n        if all([num % digit == 0 for digit in digits]):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        divisible = True\n        for digit in str(num):\n            if digit == '0':\n                divisible = False\n                break\n            if num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num)]\n        divisible = True\n        for d in digits:\n            if d == 0:\n                divisible = False\n                break\n            if num % d != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        is_divisible = True\n        for digit in str(num):\n            if digit == '0':\n                is_divisible = False\n                break\n            if num % int(digit) != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.4, "cross_model_passk": 0.5, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/748", "requirement": "```python\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to insert spaces before each capital letter in a given string, \n    except for the first character of the string. Each capital letter after the \n    first character is treated as the start of a new word, regardless of whether \n    it follows a lowercase or another uppercase letter. \n\n    Examples:\n    - Single capitalized words remain unchanged (e.g., \"Python\"  \"Python\").\n    - Spaces are inserted between consecutive capital letters (e.g., \"TESTCases\"  \"T E S T Cases\").\n    - Compound words with mixed casing are split into separate words (e.g., \"ThisIsATest\"  \"This Is A Test\").\n\n    The function uses regular expressions to achieve this behavior.\n\n    assert capital_words_spaces(\"Python\") == 'Python'\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/752", "requirement": "def jacobsthal_num(n: int) -> int:\n\"\"\"\nWrite a function to find the nth jacobsthal number.  0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\nassert jacobsthal_num(5) == 11\n\"\"\"", "generated_programs": ["def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n - 1) + 2 * jacobsthal_num(n - 2)", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            c = a + 2 * b\n            a, b = (b, c)\n        return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            c = a + 2 * b\n            a, b = (b, c)\n        return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            c = a + 2 * b\n            a, b = (b, c)\n        return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = (0, 1)\n        for _ in range(2, n + 1):\n            c = a + 2 * b\n            a, b = (b, c)\n        return b", "def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j = [0] * (n + 1)\n        j[0] = 0\n        j[1] = 1\n        for i in range(2, n + 1):\n            j[i] = j[i - 1] + 2 * j[i - 2]\n        return j[n]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.6, "original_passk": 0.4}}
{"task_id": "Mbpp/754", "requirement": "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. \n    The function should find and return a list of elements from l1 that are common across the corresponding indices \n    of the three lists. \n\n    The comparison is restricted to indices that exist in all three lists, meaning the function will only consider \n    indices up to the length of the shortest list among l1, l2, and l3. If the lists have mismatched lengths, \n    indices beyond the shortest list are ignored.\n\n    The function must handle lists of varying lengths gracefully without errors, and it should not assume that \n    the input lists are of equal length.\n\n    Example:\n    assert extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_len = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "from typing import List\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/757", "requirement": "```python\nfrom typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n    Write a function to count pairs of reverse strings in the given string list. A pair is considered a reverse pair \n    if one string in the list is the reverse of another string, regardless of the order in which they appear in the list. \n    Each instance of a reverse pair contributes to the count; duplicates are counted individually. Specifically, if a \n    string and its reverse appear multiple times in the list, each occurrence of the reverse pairing is counted separately. \n    Note that pairs are counted between strings only, and a string does not form a pair with itself.\n\n    Input sample: [\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]\n    Output: 2\n    Explanation:\n    - \"best\" and \"tseb\" form a reverse pair.\n    - \"julia\" and \"ailuj\" form a reverse pair.\n    - Total reverse pairs = 2.\n\n    assert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]) == 2\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j][::-1]:\n                count += 1\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j][::-1]:\n                count += 1\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j][::-1]:\n                count += 1\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j][::-1]:\n                count += 1\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    n = len(test_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if test_list[i] == test_list[j][::-1]:\n                count += 1\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    seen = {}\n    for s in test_list:\n        reversed_s = s[::-1]\n        if reversed_s in seen:\n            count += seen[reversed_s]\n        seen[s] = seen.get(s, 0) + 1\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j][::-1]:\n                count += 1\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j][::-1]:\n                count += 1\n    return count", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(len(test_list)):\n            if i != j and test_list[i] == test_list[j][::-1]:\n                count += 1\n    return count // 2", "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j][::-1]:\n                count += 1\n    return count"], "result": {"repaired_passk": 0.19999999999999996, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/759", "requirement": "```python\ndef is_decimal(num: str) -> bool:\n    \"\"\"\n    Write a function to check whether a given string is a valid decimal number with exactly two digits after the decimal point.\n\n    A valid decimal number must meet the following criteria:\n    1. It must consist only of digits before the decimal point, with no leading \"+\" or \"-\" signs, and no leading zeros unless the number is \"0\".\n       - Leading zeros are invalid for numbers other than \"0\" (e.g., \"003.10\" and \"012.34\" are invalid).\n       - A single \"0\" before the decimal point is valid (e.g., \"0.99\" is valid).\n    2. It must have exactly one decimal point.\n    3. It must have exactly two digits after the decimal point.\n    4. Strings without a decimal point (e.g., \"123\") are invalid.\n\n    Example:\n    assert is_decimal('123.11') == True\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^(0|[1-9]\\\\d*)\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^(0|[1-9]\\\\d*)\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^(0|[1-9]\\\\d*)\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^(0|[1-9]\\\\d*)\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^(0|[1-9]\\\\d*)\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^(?!0\\\\d)(\\\\d+)\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num)) or num == '0.00'", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^(0|[1-9]\\\\d*)\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^(0|[1-9]\\\\d*)\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^0\\\\.\\\\d{2}$|^[1-9]\\\\d*\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^(\\\\d+\\\\.\\\\d{2})$')\n    if not pattern.match(num):\n        return False\n    integer_part = num.split('.')[0]\n    if integer_part != '0' and integer_part.startswith('0'):\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    \"\"\"\n    Write a Python function to find the minimum absolute difference between any two elements in a given array. \n    The input array can be either a list or a tuple of integers. If the input is a tuple, it should be converted to a list before processing.\n    The function must sort the array before calculating differences to ensure consecutive elements are directly comparable.\n    The function should raise a ValueError if the input array contains fewer than two elements, as the minimum difference cannot be computed in such cases.\n    The parameter `n` represents the expected length of the input array but is not used in the computation. It is included for validation purposes and should match the actual length of the array; otherwise, the behavior is undefined.\n    Differences between elements must be calculated using absolute values to ensure non-negative results.\n    \n    Example:\n    assert find_min_diff((1, 5, 3, 19, 18, 25), 6) == 1\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    if len(arr) < 2:\n        raise ValueError('Input array must contain at least two elements.')\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    if len(arr) < 2:\n        raise ValueError('Input array must contain at least two elements.')\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    if len(arr) < 2:\n        raise ValueError('Input array must contain at least two elements.')\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    if len(arr) < 2:\n        raise ValueError('Input array must contain at least two elements.')\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        current_diff = abs(arr[i] - arr[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n    return min_diff", "from typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    if len(arr) < 2:\n        raise ValueError('Input array must contain at least two elements.')\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        current_diff = abs(arr[i] - arr[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n    return min_diff", "from typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    if isinstance(arr, tuple):\n        arr = list(arr)\n    if len(arr) < 2:\n        raise ValueError('Input array must contain at least two elements.')\n    if len(arr) != n:\n        raise ValueError('Length of array does not match the expected length.')\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    if len(arr) < 2:\n        raise ValueError('Input array must contain at least two elements.')\n    if len(arr) != n:\n        raise ValueError('Length of input array does not match expected length.')\n    arr_list = list(arr)\n    arr_list.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr_list)):\n        current_diff = abs(arr_list[i] - arr_list[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n    return min_diff", "from typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    if not isinstance(arr, (list, tuple)):\n        raise TypeError('Input must be a list or tuple')\n    if len(arr) < 2:\n        raise ValueError('Array must contain at least two elements')\n    if len(arr) != n:\n        raise ValueError('Length of array does not match the expected value')\n    arr_list = list(arr) if isinstance(arr, tuple) else arr\n    arr_list.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr_list)):\n        current_diff = abs(arr_list[i] - arr_list[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n    return min_diff", "code\nfrom typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    if not isinstance(arr, (list, tuple)):\n        raise TypeError('Input must be a list or tuple of integers.')\n    if len(arr) < 2:\n        raise ValueError('Input array must contain at least two elements.')\n    if len(arr) != n:\n        raise ValueError(\"The length of the input array does not match the expected length 'n'.\")\n    arr_list = list(arr) if isinstance(arr, tuple) else arr\n    arr_list.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr_list)):\n        current_diff = abs(arr_list[i] - arr_list[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n    return min_diff", "from typing import List, Tuple\n\ndef find_min_diff(arr: List[int] | Tuple[int], n: int) -> int:\n    if not isinstance(arr, (list, tuple)):\n        raise TypeError('Input must be a list or tuple')\n    if len(arr) < 2:\n        raise ValueError('Input array must contain at least two elements')\n    if len(arr) != n:\n        raise ValueError('Input array length does not match the expected length')\n    arr_list = list(arr) if isinstance(arr, tuple) else arr\n    arr_list.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr_list)):\n        current_diff = abs(arr_list[i] - arr_list[i - 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n    return min_diff"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/769", "requirement": "def Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Write a Python function to compute the symmetric difference between two lists.\n    The symmetric difference includes elements that are in either of the lists but not in both.\n    Specifically, the result should include elements that are unique to the first list (present in the first list but not in the second) \n    and elements that are unique to the second list (present in the second list but not in the first). \n    The result should combine these unique elements into a single list.\n\n    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return list(set(li1) ^ set(li2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    return list(set1.symmetric_difference(set2))", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    symmetric_diff = set1.symmetric_difference(set2)\n    return list(symmetric_diff)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/771", "requirement": "```python\ndef check_expression(expression: str) -> bool:\n    \"\"\"\n    Write a function to check if the given expression is balanced or not, \n    considering only the brackets `{}`, `()`, and `[]`. Non-bracket characters \n    in the input are ignored and do not affect the balance of the expression.\n\n    A balanced expression is defined as:\n    - Every opening bracket has a corresponding and correctly ordered closing bracket.\n    - Brackets are properly nested (e.g., \"{[()]}\" is balanced, but \"{[(])}\" is not).\n    - Non-bracket characters are ignored and do not contribute to imbalance.\n\n    Edge cases:\n    - An empty string is considered balanced and should return True.\n    - Strings containing only non-bracket characters (e.g., \"abc123\") are considered balanced and should return True.\n\n    Examples:\n    assert check_expression(\"{()}[{}]\") == True\n    ### Test 1\n    Input: ['<<<>>>']\n    Expected Output: [True]\n    \"\"\"\n```", "generated_programs": ["def check_expression(expression: str) -> bool:\n    stack = []\n    brackets = {'}': '{', ')': '(', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {'{': '}', '(': ')', '[': ']'}\n    for char in expression:\n        if char in bracket_pairs:\n            stack.append(char)\n        elif char in bracket_pairs.values():\n            if not stack or bracket_pairs[stack.pop()] != char:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {'{': '}', '[': ']', '(': ')'}\n    for char in expression:\n        if char in bracket_pairs:\n            stack.append(char)\n        elif char in bracket_pairs.values():\n            if not stack or bracket_pairs[stack.pop()] != char:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    stack = deque()\n    bracket_pairs = {'{': '}', '(': ')', '[': ']'}\n    for char in expression:\n        if char in bracket_pairs:\n            stack.append(char)\n        elif char in bracket_pairs.values():\n            if not stack or bracket_pairs[stack.pop()] != char:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack[-1] != brackets[char]:\n                return False\n            stack.pop()\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {'{': '}', '[': ']', '(': ')'}\n    for char in expression:\n        if char in bracket_pairs:\n            stack.append(char)\n        elif char in bracket_pairs.values():\n            if not stack or bracket_pairs[stack.pop()] != char:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', ']': '[', '}': '{'}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/777", "requirement": "```python\nfrom typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of all distinct elements in a given list.\n    Distinct elements are the unique values present in the list, regardless of their frequency of occurrence.\n    For example, in the list [1, 2, 3, 1, 1, 4, 5, 6], the distinct elements are [1, 2, 3, 4, 5, 6].\n    The function should return the sum of these distinct elements.\n    \n    assert find_sum([1, 2, 3, 1, 1, 4, 5, 6]) == 21\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    return sum(set(arr))", "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    unique_elements = set(arr)\n    return sum(unique_elements)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/780", "requirement": "def find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to find all unique combinations of sums between pairs of tuples in the given list. \n    For each pair of tuples (a, b) where a comes before b in the list, calculate a new tuple by summing \n    the corresponding elements of a and b. Return a list of these resulting tuples.\n\n    Example:\n    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            a, b = test_list[i]\n            c, d = test_list[j]\n            result.append((a + c, b + d))\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            a, b = test_list[i]\n            c, d = test_list[j]\n            combinations.append((a + c, b + d))\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            a = test_list[i]\n            b = test_list[j]\n            sum_tuple = (a[0] + b[0], a[1] + b[1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    n = len(test_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            a, b = (test_list[i], test_list[j])\n            summed_tuple = (a[0] + b[0], a[1] + b[1])\n            result.append(summed_tuple)\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/781", "requirement": "```python\ndef count_divisors(n: int) -> bool:\n    \"\"\"\n    Write a Python function to determine whether the count of divisors of a given integer `n` is even.\n\n    - The function should consider all integers, including negative and zero, as valid inputs.\n    - Divisors are defined as distinct positive integers that divide `n` without a remainder.\n    - For negative values of `n`, the function should calculate divisors as if `n` were positive.\n    - For `n = 0`, the function should return `True` since `0` has an infinite number of divisors, which is considered even for this purpose.\n    - For perfect squares, divisors should not be double-counted (e.g., if `i` is a divisor and `n // i` is the same as `i`, it should only be counted once).\n    - The function should return `True` if the count of divisors is even, and `False` otherwise.\n\n    Example:\n    assert count_divisors(10)\n    \"\"\"\n```", "generated_programs": ["import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    sqrt_n = math.isqrt(n)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    divisors_count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                divisors_count += 1\n            else:\n                divisors_count += 2\n    return divisors_count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "import math\n\ndef count_divisors(n: int) -> bool:\n    n = abs(n)\n    if n == 0:\n        return True\n    count = 0\n    sqrt_n = math.isqrt(n)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even number and the first odd number in a given list.\n    \n    - The function assumes that the input list contains at least one even number and one odd number.\n    - If the list does not contain both an even number and an odd number, a `StopIteration` exception will be raised.\n    - The function does not handle exceptional cases such as lists with only even numbers, only odd numbers, or empty lists.\n    \n    Example:\n    assert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = next((x for x in list1 if x % 2 == 0))\n    odd = next((x for x in list1 if x % 2 != 0))\n    return even * odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0), None)\n    first_odd = next((x for x in list1 if x % 2 != 0), None)\n    if first_even is None or first_odd is None:\n        raise StopIteration\n    return first_even * first_odd", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = next((x for x in list1 if x % 2 == 0))\n    first_odd = next((x for x in list1 if x % 2 != 0))\n    return first_even * first_odd"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/787", "requirement": "def text_match_three(text: str) -> re.Match:\n\"\"\"\nWrite a function that matches a string that has an a followed by three 'b'.\nassert not text_match_three(\"ac\")\n\"\"\"", "generated_programs": ["import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('a[b]{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.search('ab{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('abbb', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('ab{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('ab{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('ab{3}', text)", "import re\n\ndef text_match_three(text: str) -> re.Match:\n    return re.match('abbb', text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n\"\"\"\nWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\nassert text_starta_endb(\"aabbbb\")\n\"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/800", "requirement": "def remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all spaces (' ') from a string while preserving all other types of whitespace characters \n    (e.g., tabs '\\t', newlines '\\n') and the original order of characters.\n\n    The function should:\n    - Remove only spaces (' ') from the input string.\n    - Leave all other whitespace characters (e.g., tabs, newlines) intact.\n\n    Example:\n    assert remove_all_spaces('python  program') == 'pythonprogram'\n\n    Input and expected output examples:\n    ### Test 1\n    Input: ['\\t\\nno_spaces_hardcase\\t\\n']\n    Expected Output: ['\\t\\nno_spaces_hardcase\\t\\n']\n    \"\"\"", "generated_programs": ["def remove_all_spaces(text: str) -> str:\n    return text.replace(' ', '')", "def remove_all_spaces(text: str) -> str:\n    return ''.join((char for char in text if char != ' '))", "def remove_all_spaces(text: str) -> str:\n    return ''.join((char for char in text if char != ' '))", "code\n\ndef remove_all_spaces(text: str) -> str:\n    return ''.join([char for char in text if char != ' '])", "def remove_all_spaces(text: str) -> str:\n    return ''.join((char for char in text if char != ' '))", "def remove_all_spaces(text: str) -> str:\n    return ''.join([char for char in text if char != ' '])", "def remove_all_spaces(text: str) -> str:\n    return ''.join((char for char in text if char != ' '))", "def remove_all_spaces(text: str) -> str:\n    return ''.join([char for char in text if char != ' '])", "def remove_all_spaces(text: str) -> str:\n    return ''.join([char for char in text if char != ' '])", "def remove_all_spaces(text: str) -> str:\n    return ''.join([char for char in text if char != ' '])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/801", "requirement": "```python\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a Python function to determine how many of the three given integers are part of equality groups.\n\n    The function should return:\n    - `3` if all three integers are equal.\n    - `2` if exactly two integers are equal.\n    - `0` if no integers are equal.\n\n    Examples:\n    - If the input is (1, 1, 1), the function returns 3 because all three integers are equal.\n    - If the input is (1, 2, 3), the function returns 0 because no integers are equal.\n\n    Constraints:\n    - The input integers can be any valid integers, including negative numbers and zero.\n\n    assert test_three_equal(1, 1, 1) == 3\n    \"\"\"\n```", "generated_programs": ["def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or x == z or y == z:\n        return 2\n    else:\n        return 0", "def test_three_equal(x: int, y: int, z: int) -> int:\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}

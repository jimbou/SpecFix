{"task_id": "Mbpp/4", "requirement": "def heap_queue_largest(nums: list, n: int) -> list:\n    \"\"\"\n    Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n    Note: The result from heapq.nlargest is already in descending order, so no additional sorting is required.\n\n    assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    \"\"\"", "generated_programs": ["import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/20", "requirement": "def is_woodall(num: int) -> bool:\n    \"\"\"Check if the given number is a Woodall number. A Woodall number is defined as a number of the form n * 2^n - 1 for some integer n.\n    \n    assert is_woodall(383) == True\n    \"\"\"", "generated_programs": ["def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "def is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * (1 << n) - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * (1 << n) - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/58", "requirement": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"Check if the two given 32-bit integers have opposite signs using bitwise operations.\n    \n    The function uses the XOR operation between the two numbers and checks if the 32nd bit (most significant bit for a 32-bit signed integer) is set,\n    indicating that the numbers have opposite signs.\n    \n    assert opposite_Signs(1, -2) == True\n    \"\"\"", "generated_programs": ["def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/61", "requirement": "def count_Substrings(s: str) -> int:\n    \"\"\"Count the number of substrings where the sum of the digits equals the length of the substring.\n    \n    assert count_Substrings('112112') == 6\n    \"\"\"", "generated_programs": ["def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            substring_length = j - i + 1\n            if current_sum == substring_length:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        sum_digits = 0\n        for j in range(i, len(s)):\n            sum_digits += int(s[j])\n            length = j - i + 1\n            if sum_digits == length:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/84", "requirement": "def sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the Newman-Conway sequence.\n    The function is defined for positive integers starting from 1.\n    If n is 0, the function should raise an IndexError as per the reference implementation.\n    \n    assert sequence(10) == 6\n    \"\"\"", "generated_programs": ["def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n should be a positive integer starting from 1')\n    if n <= 2:\n        return 1\n    seq = [0, 1, 1]\n    for i in range(3, n + 1):\n        seq.append(seq[seq[i - 1]] + seq[i - seq[i - 1]])\n    return seq[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be a positive integer')\n    if n < 3:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n should be a positive integer')\n    if n <= 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n should be a positive integer starting from 1')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n should be a positive integer starting from 1.')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the number of positive divisors of a given integer.\n    For non-positive integers, the function should return 0 as they do not have positive divisors.\n    \n    assert divisor(15) == 4\n    \"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "code\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements in given nested lists. \n    If the nested list is empty or contains only empty sublists, the function should return an empty list.\n    \n    assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    \"\"\"", "generated_programs": ["from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((len(sub) == 0 for sub in nestedlist)):\n        return []\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((not sublist for sublist in nestedlist)):\n        return []\n    common_set = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_set.intersection_update(set(sublist))\n    return list(common_set)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common.intersection_update(sublist)\n    return list(common)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist or all((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to sum all amicable numbers up to and including a specified number.\n\n    An amicable pair consists of two different numbers where each number is the sum of the proper divisors of the other.\n    The function should return the sum of all such numbers up to and including the given limit.\n\n    assert amicable_numbers_sum(999) == 504\n    \"\"\"", "generated_programs": ["def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n):\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if a != b and sum_of_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n):\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n):\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n):\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_numbers = set()\n    for a in range(2, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if a != b and sum_of_proper_divisors(b) == a and (b <= limit):\n            amicable_numbers.add(a)\n            amicable_numbers.add(b)\n    return sum(amicable_numbers)", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if a != b and sum_of_proper_divisors(b) == a and (a < b):\n            amicable_sum += a + b\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = math.isqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_proper_divisors(a)\n        if b > a and sum_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "import math\n\ndef proper_divisor_sum(n: int) -> int:\n    if n < 2:\n        return 0\n    total = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                total += i\n            else:\n                total += i + n // i\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = proper_divisor_sum(a)\n        if b != a and proper_divisor_sum(b) == a:\n            if a < b:\n                amicable_sum += a + b\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        i = 2\n        while i * i <= n:\n            if n % i == 0:\n                if i == n // i:\n                    total += i\n                else:\n                    total += i + n // i\n            i += 1\n        return total\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if a != b and sum_of_proper_divisors(b) == a:\n            if a < b:\n                amicable_sum += a + b\n    return amicable_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n    \"\"\"\n    Write a function to get the angle of the complex number b relative to a.\n    This is calculated as the phase of the difference between b and a.\n    \n    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n    \"\"\"", "generated_programs": ["import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine if the given matrix is a magic square.\n    A magic square is defined as a square grid filled with distinct positive integers in the range 1 to n^2 such that \n    the sum of the numbers in any horizontal, vertical, or main diagonal line is always the same number, known as the magic constant.\n    \n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    unique_numbers = set()\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n        unique_numbers.update(row)\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    if unique_numbers != set(range(1, n ** 2 + 1)):\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    unique_numbers = set()\n    for row in my_matrix:\n        unique_numbers.update(row)\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    if unique_numbers != set(range(1, n ** 2 + 1)):\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_sum = n * (n ** 2 + 1) // 2\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_sum:\n            return False\n    for j in range(n):\n        if sum((my_matrix[i][j] for i in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    unique_numbers = set()\n    for row in my_matrix:\n        for num in row:\n            if num < 1 or num > n ** 2 or num in unique_numbers:\n                return False\n            unique_numbers.add(num)\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    distinct_numbers = set()\n    for row in my_matrix:\n        for num in row:\n            if num < 1 or num > n ** 2 or num in distinct_numbers:\n                return False\n            distinct_numbers.add(num)\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    unique_numbers = set()\n    for row in my_matrix:\n        if len(set(row)) != n:\n            return False\n        unique_numbers.update(row)\n    if unique_numbers != set(range(1, n ** 2 + 1)):\n        return False\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_constant:\n            return False\n    for j in range(n):\n        if sum((my_matrix[i][j] for i in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    unique_numbers = set()\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n        unique_numbers.update(row)\n    if unique_numbers != set(range(1, n ** 2 + 1)):\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    elements = set()\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n        elements.update(row)\n    if elements != set(range(1, n ** 2 + 1)):\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    magic_constant = n * (n ** 2 + 1) // 2\n    unique_numbers = set()\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n        unique_numbers.update(row)\n    if unique_numbers != set(range(1, n ** 2 + 1)):\n        return False\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_constant:\n            return False\n    for j in range(n):\n        if sum((my_matrix[i][j] for i in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if n == 0 or len(my_matrix[0]) != n:\n        return False\n    magic_constant = n * (n ** 2 + 1) // 2\n    unique_numbers = set()\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n        unique_numbers.update(row)\n    if unique_numbers != set(range(1, n ** 2 + 1)):\n        return False\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_constant:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_constant:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_constant:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    expected_sum = n * (n ** 2 + 1) // 2\n    unique_numbers = set()\n    for row in my_matrix:\n        for num in row:\n            if num < 1 or num > n ** 2:\n                return False\n            unique_numbers.add(num)\n    if len(unique_numbers) != n ** 2:\n        return False\n    for row in my_matrix:\n        if sum(row) != expected_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != expected_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != expected_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != expected_sum:\n        return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n\"\"\"\nWrite a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\nassert is_Sum_Of_Powers_Of_Two(10) == True\n\"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n != 0 and n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') == 1 or bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n < 1:\n        return False\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 1 and n >> 1 > 0:\n            return False\n        n = n >> 1\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 != 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\"\"\"\nWrite a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\nassert find_solution(2, 3, 7) == (2, 1)\n\"\"\"", "generated_programs": ["from math import gcd\nfrom typing import Tuple, Union\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    d = gcd(a, b)\n    if n % d != 0:\n        return None\n    a, b, n = (a // d, b // d, n // d)\n    for x in range(n // a + 1):\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            return (x, y)\n    return None", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    gcd_ab = math.gcd(a, b)\n    if n % gcd_ab != 0:\n        return None\n    a_div, b_div, n_div = (a // gcd_ab, b // gcd_ab, n // gcd_ab)\n    for x in range(n_div // a_div + 1):\n        remainder = n_div - a_div * x\n        if remainder % b_div == 0:\n            y = remainder // b_div\n            return (x, y)\n    return None", "from typing import Tuple, Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        else:\n            g, x, y = extended_gcd(b, a % b)\n            return (g, y, x - a // b * y)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x *= n // g\n    y *= n // g\n    return (x, y)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        else:\n            g, x, y = extended_gcd(b, a % b)\n            return (g, y, x - a // b * y)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x *= n // g\n    y *= n // g\n    return (x, y)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(aa, bb):\n        if bb == 0:\n            return (aa, 1, 0)\n        else:\n            g, x, y = extended_gcd(bb, aa % bb)\n            return (g, y, x - aa // bb * y)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x *= n // g\n    y *= n // g\n    return (x, y)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    gcd_ab = math.gcd(a, b)\n    if n % gcd_ab != 0:\n        return None\n    a_div = a // gcd_ab\n    b_div = b // gcd_ab\n    n_div = n // gcd_ab\n    for x in range(n_div // a_div + 1):\n        if (n_div - a_div * x) % b_div == 0:\n            y = (n_div - a_div * x) // b_div\n            return (x, y)\n    return None", "from typing import Tuple, Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        else:\n            gcd, x1, y1 = extended_gcd(b, a % b)\n            x = y1\n            y = x1 - a // b * y1\n            return (gcd, x, y)\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return None\n    x *= n // gcd\n    y *= n // gcd\n    return (x, y)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        else:\n            g, x, y = extended_gcd(b, a % b)\n            return (g, y, x - a // b * y)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x0 = x * (n // g)\n    y0 = y * (n // g)\n    return (x0, y0)", "from typing import Tuple, Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if a == 0:\n            return (b, 0, 1)\n        else:\n            gcd, x1, y1 = extended_gcd(b % a, a)\n            x = y1 - b // a * x1\n            y = x1\n            return (gcd, x, y)\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return None\n    x0 = x * (n // gcd)\n    y0 = y * (n // gcd)\n    return (x0, y0)", "from typing import Tuple\nfrom typing import Union\nfrom math import gcd\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n        if a == 0:\n            return (b, 0, 1)\n        else:\n            g, x, y = extended_gcd(b % a, a)\n            return (g, y - b // a * x, x)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x0 = x * (n // g)\n    y0 = y * (n // g)\n    return (x0, y0)"], "result": {"repaired_passk": 0.19999999999999996, "cross_model_passk": 0.30000000000000004, "original_passk": 0.0}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n\"\"\"\nWrite a Python function to set all even bits in a 32-bit integer representation of a given number.\nassert even_bit_set_number(10) == 10\n\"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    mask = 2863311530\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 2863311530\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 2863311530\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 2863311530\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 2863311530\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    even_mask = 2863311530\n    return n | even_mask", "def even_bit_set_number(n: int) -> int:\n    mask = 1431655765\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 2863311530\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    mask = 2863311530\n    return n | mask", "def even_bit_set_number(n: int) -> int:\n    even_bits = 2863311531\n    return n | even_bits"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n\"\"\"\nWrite a function that takes in positive integers m and n and finds the number of possible sequences of length n, \nwhere each element is a positive integer starting from any number between 1 and m, inclusive. Each subsequent element \nin the sequence must be greater than or equal to twice the previous element but less than or equal to m.\n\nFor example, for m=10 and n=4, the valid sequences include [1, 2, 4, 8], [1, 2, 4, 9], etc., as long as they meet the criteria.\n\nassert get_total_number_of_sequences(10, 4) == 4\n\"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def backtrack(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += backtrack(current_length + 1, i)\n        return total\n    count = 0\n    for i in range(1, m + 1):\n        count += backtrack(1, i)\n    return count", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def count_sequences(start, length):\n        if length == 1:\n            return 1\n        total = 0\n        for next_num in range(2 * start, m + 1):\n            total += count_sequences(next_num, length - 1)\n        return total\n    result = 0\n    for first_num in range(1, m + 1):\n        result += count_sequences(first_num, n)\n    return result", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def helper(current_length, last_value):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_value, m + 1):\n            total += helper(current_length + 1, i)\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += helper(1, i)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    from functools import lru_cache\n\n    def dp(current_length: int, last_element: int) -> int:\n        if current_length == n:\n            return 1\n        total = 0\n        for next_element in range(2 * last_element, m + 1):\n            total += dp(current_length + 1, next_element)\n        return total\n    result = 0\n    for first_element in range(1, m + 1):\n        result += dp(1, first_element)\n    return result", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def dfs(current_length: int, last_number: int) -> int:\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_number, m + 1):\n            total += dfs(current_length + 1, i)\n        return total\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for first_num in range(1, m + 1):\n        total_sequences += dfs(1, first_num)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                if 2 * k <= j:\n                    dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            k = j // 2\n            for l in range(1, k + 1):\n                dp[i][j] += dp[i - 1][l]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            k = 1\n            while k <= j // 2:\n                dp[i][j] += dp[i - 1][k]\n                k += 1\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/244", "requirement": "def next_Perfect_Square(N: int) -> int:\n\"\"\"\nWrite a python function to find the next perfect square greater than a given number.\nassert next_Perfect_Square(35) == 36\n\"\"\"", "generated_programs": ["import math\n\ndef next_Perfect_Square(N: int) -> int:\n    i = math.isqrt(N) + 1\n    return i * i", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    next_sqrt = sqrt + 1\n    return next_sqrt * next_sqrt", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    next_square = (math.isqrt(N) + 1) ** 2\n    return next_square", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.isqrt(N)\n    next_square = (sqrt_N + 1) ** 2\n    return next_square", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    next_square = (sqrt + 1) ** 2\n    return next_square", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) * (sqrt + 1)\n    else:\n        return (sqrt + 1) * (sqrt + 1)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/245", "requirement": "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, \n    where a sequence is bitonic if it is first increasing and then decreasing. A single element is considered a \n    valid bitonic subsequence. The function should return 0 for an empty list.\n    \n    Parameters:\n    arr (List[int]): The input list of integers.\n    \n    Returns:\n    int: The maximum sum of a bitonic subsequence.\n    \n    Examples:\n    assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n    assert max_sum([]) == 0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    return max_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_val = 0\n    for i in range(n):\n        max_sum_val = max(max_sum_val, inc[i] + dec[i] - arr[i])\n    return max_sum_val", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_bitonic = 0\n    for i in range(n):\n        max_sum_bitonic = max(max_sum_bitonic, inc[i] + dec[i] - arr[i])\n    return max_sum_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_bitonic = 0\n    for i in range(n):\n        max_sum_bitonic = max(max_sum_bitonic, inc[i] + dec[i] - arr[i])\n    return max_sum_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic = 0\n    for i in range(n):\n        max_bitonic = max(max_bitonic, inc[i] + dec[i] - arr[i])\n    return max_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic = 0\n    for i in range(n):\n        max_bitonic = max(max_bitonic, inc[i] + dec[i] - arr[i])\n    return max_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic = 0\n    for i in range(n):\n        max_bitonic = max(max_bitonic, inc[i] + dec[i] - arr[i])\n    return max_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_bitonic = 0\n    for i in range(n):\n        max_sum_bitonic = max(max_sum_bitonic, inc[i] + dec[i] - arr[i])\n    return max_sum_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    return max_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth Newman–Shanks–Williams (NSW) prime number.\n    The NSW numbers are generated using the recurrence relation S_0 = 1, S_1 = 1, and S_{n+1} = 2*S_n + S_{n-1}.\n    The function should return the nth prime number found in the NSW sequence.\n    \n    assert newman_prime(3) == 7\n    \"\"\"", "generated_programs": ["import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    s = [1, 1]\n    prime_count = 0\n    while True:\n        next_s = 2 * s[-1] + s[-2]\n        s.append(next_s)\n        if is_prime(next_s):\n            prime_count += 1\n            if prime_count == n:\n                return next_s", "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n == 1:\n        return 1\n    S = [1, 1]\n    count = 0\n    while True:\n        next_S = 2 * S[-1] + S[-2]\n        S.append(next_S)\n        if is_prime(next_S):\n            count += 1\n            if count == n:\n                return next_S", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n == 0:\n        return 1\n    s0, s1 = (1, 1)\n    count = 0\n    while True:\n        if is_prime(s1):\n            count += 1\n            if count == n:\n                return s1\n        s0, s1 = (s1, 2 * s1 + s0)", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n == 0:\n        return 1\n    S = [1, 1]\n    prime_count = 0\n    while True:\n        next_S = 2 * S[-1] + S[-2]\n        S.append(next_S)\n        if is_prime(next_S):\n            prime_count += 1\n            if prime_count == n:\n                return next_S", "def is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        return 0\n    s0, s1 = (1, 1)\n    count = 0\n    while True:\n        if is_prime(s0):\n            count += 1\n            if count == n:\n                return s0\n        s0, s1 = (s1, 2 * s1 + s0)", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    s = [1, 1]\n    count = 0\n    while True:\n        next_s = 2 * s[-1] + s[-2]\n        s.append(next_s)\n        if is_prime(s[-1]):\n            count += 1\n            if count == n:\n                return s[-1]", "def is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    s0, s1 = (1, 1)\n    count = 0\n    while True:\n        if is_prime(s1):\n            count += 1\n            if count == n:\n                return s1\n        s0, s1 = (s1, 2 * s1 + s0)", "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        return 0\n    S_0, S_1 = (1, 1)\n    primes_found = 0\n    while True:\n        if is_prime(S_1):\n            primes_found += 1\n            if primes_found == n:\n                return S_1\n        S_next = 2 * S_1 + S_0\n        S_0, S_1 = (S_1, S_next)", "import sympy\n\ndef newman_prime(n: int) -> int:\n\n    def nsw_number(k: int) -> int:\n        if k == 0 or k == 1:\n            return 1\n        S = [0] * (k + 1)\n        S[0] = S[1] = 1\n        for i in range(2, k + 1):\n            S[i] = 2 * S[i - 1] + S[i - 2]\n        return S[k]\n    count = 0\n    i = 0\n    while True:\n        num = nsw_number(i)\n        if sympy.isprime(num):\n            count += 1\n            if count == n:\n                return num\n        i += 1", "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be at least 1')\n    s0 = 1\n    s1 = 1\n    primes_found = 0\n    current_n = 1\n    while primes_found < n:\n        s_next = 2 * s1 + s0\n        s0 = s1\n        s1 = s_next\n        if is_prime(s_next):\n            primes_found += 1\n    return s1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/274", "requirement": "def even_binomial_Coeff_Sum(n: int) -> int:\n\"\"\"\nWrite a Python function that takes in a non-negative integer n and returns the sum of binomial coefficients at even indices. \nThe binomial coefficient C(n, k) is defined as the number of ways to choose k elements from a set of n elements.\nFor example, the binomial coefficients for n=4 are C(4,0), C(4,1), C(4,2), C(4,3), C(4,4).\nThe function should sum the coefficients at even indices: C(n,0), C(n,2), C(n,4), ...\nassert even_binomial_Coeff_Sum(4) == 8\n\"\"\"", "generated_programs": ["from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "import math\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((math.comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "import math\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((math.comb(n, k) for k in range(0, n + 1, 2)))", "import math\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    total = 0\n    for k in range(0, n + 1, 2):\n        total += math.comb(n, k)\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/290", "requirement": "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    \"\"\"\n    Write a function to find the list of maximum length in a list of lists.\n    The function should return a tuple containing the length of the longest list and the list itself.\n    If there are multiple lists with the same maximum length, return any one of them.\n    \n    assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=lambda x: len(x))\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(lst) for lst in list1))\n    max_list = next((lst for lst in list1 if len(lst) == max_len))\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(l) for l in list1))\n    for l in list1:\n        if len(l) == max_len:\n            return (max_len, l)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(lst) for lst in list1))\n    max_list = next((lst for lst in list1 if len(lst) == max_len))\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(lst) for lst in list1))\n    max_list = next((lst for lst in list1 if len(lst) == max_len))\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(lst) for lst in list1))\n    max_list = next((lst for lst in list1 if len(lst) == max_len))\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_list = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_list)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n    \"\"\"Calculate the maximum depth of nested dictionaries.\n    \n    The depth is determined by the number of levels in the longest path from the root dictionary to a leaf node, where a leaf node is defined as either an empty dictionary or a value that is not a dictionary.\n    \n    assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4\n    \"\"\"", "generated_programs": ["code\n\ndef dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "code\n\ndef dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()), default=0)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/305", "requirement": "from typing import List\nfrom typing import Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return the first two words from a list of strings that start with the letter 'p', \n    considering both uppercase and lowercase 'p'. If fewer than two such words are found, return empty strings \n    for the missing words.\n    \n    The function searches for words starting with 'p' across all strings in the list, not limited to words within \n    the same string.\n    \n    assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    p_words.extend([''] * (2 - len(p_words)))\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word in words:\n        for w in word.split():\n            if w.lower().startswith('p'):\n                p_words.append(w)\n                if len(p_words) >= 2:\n                    return tuple(p_words[:2])\n    return ('', '') if len(p_words) < 2 else tuple(p_words[:2])", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word_seq in words:\n        for word in word_seq.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) >= 2:\n                    return tuple(p_words[:2])\n    return ('', '') if len(p_words) < 2 else tuple(p_words[:2])", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    return tuple(p_words) if len(p_words) == 2 else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for string in words:\n        for word in string.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return (p_words[0] if p_words else '', p_words[1] if len(p_words) > 1 else '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word in words:\n        for subword in word.split():\n            if subword.lower().startswith('p'):\n                p_words.append(subword)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    return tuple(p_words) if len(p_words) >= 2 else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return (p_words[0] if len(p_words) > 0 else '', p_words[1] if len(p_words) > 1 else '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word in words:\n        for w in word.split():\n            if w.lower().startswith('p'):\n                p_words.append(w)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    return (p_words[0] if len(p_words) > 0 else '', p_words[1] if len(p_words) > 1 else '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    while len(p_words) < 2:\n        p_words.append('')\n    return tuple(p_words[:2])", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word in words:\n        for w in word.split():\n            if w.lower().startswith('p'):\n                p_words.append(w)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    if len(p_words) == 0:\n        return ('', '')\n    elif len(p_words) == 1:\n        return (p_words[0], '')\n    else:\n        return (p_words[0], p_words[1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\"\"\"\nWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\nassert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    if k <= index:\n        return dp[index]\n    return dp[index] + a[k] if a[k] > a[index] else 0", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = dp[index]\n    if k < n and a[k] > a[index]:\n        max_sum += a[k]\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i] and dp[j] + a[i] > dp[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = dp[index]\n    for i in range(index + 1, k):\n        if a[i] > a[index]:\n            max_sum += a[i]\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i] and dp[j] + a[i] > dp[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            if dp[i] + a[k] > max_sum:\n                max_sum = dp[i] + a[k]\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            dp[i] = a[i]\n        else:\n            dp[i] = 0\n        for j in range(i):\n            if a[j] < a[i] and a[i] < a[k]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = max(dp[:index + 1])\n    if max_sum > 0:\n        return max_sum + a[k]\n    else:\n        return a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = dp[index]\n    if a[k] > a[index]:\n        dp_k = a[k]\n        for i in range(index + 1):\n            if a[i] < a[k]:\n                dp_k = max(dp_k, dp[i] + a[k])\n        max_sum = dp_k\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    dp[0] = a[0]\n    for i in range(1, index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = dp[index]\n    for i in range(index + 1, k + 1):\n        if a[i] > a[index]:\n            max_sum = max(max_sum, dp[index] + a[i])\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    if a[k] > a[index]:\n        max_sum = dp[index]\n        for i in range(index + 1, k):\n            if a[i] > a[index]:\n                max_sum = max(max_sum, dp[index] + a[i])\n        return max_sum + a[k]\n    else:\n        return dp[index]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    if a[k] <= a[index]:\n        return dp[index]\n    max_sum = dp[index]\n    for i in range(index + 1, k):\n        if a[i] >= a[index] and a[i] <= a[k]:\n            max_sum = max(max_sum, dp[index] + a[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = dp[index]\n    if k > index and k < n:\n        for i in range(index + 1, k + 1):\n            dp[i] = a[i]\n            for j in range(i):\n                if a[i] > a[j]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n            if i == k:\n                max_sum += dp[i] - a[i] if dp[i] > a[i] else 0\n    return max_sum"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.09999999999999998, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/308", "requirement": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    If N is zero, the function should return an empty list. If N exceeds the total number of possible products, the function should return all possible products sorted in descending order.\n    \n    assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]\n    \"\"\"", "generated_programs": ["from typing import List\nimport itertools\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = [x * y for x, y in itertools.product(nums1, nums2)]\n    products.sort(reverse=True)\n    return products[:N] if N <= len(products) else products", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    products.sort(reverse=True)\n    return products[:min(N, len(products))]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    products.sort(reverse=True)\n    if N > len(products):\n        return products\n    return products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, -(num1 * num2))\n    result = []\n    for _ in range(min(N, len(products))):\n        result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-num1 * num2)\n    heapq.heapify(products)\n    result = []\n    while len(result) < N and products:\n        result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    heapq.heapify(products)\n    result = []\n    for _ in range(min(N, len(products))):\n        result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-num1 * num2)\n    if N > len(products):\n        N = len(products)\n    heapq.heapify(products)\n    largest = []\n    for _ in range(N):\n        largest.append(-heapq.heappop(products))\n    return largest", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, -(num1 * num2))\n    if N >= len(products):\n        result = sorted([-x for x in products], reverse=True)\n    else:\n        result = []\n        for _ in range(N):\n            result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    if N > len(products):\n        N = len(products)\n    heapq.heapify(products)\n    result = []\n    for _ in range(N):\n        result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    if N >= len(products):\n        heapq.heapify(products)\n        result = []\n        while products:\n            result.append(-heapq.heappop(products))\n        return result\n    else:\n        largest = heapq.nsmallest(N, products)\n        return sorted([-x for x in largest], reverse=True)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n\"\"\"\nWrite a function to convert a given string to a tuple of characters, excluding spaces.\nSpaces in the input string should not be included in the resulting tuple.\nassert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n\"\"\"", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Write a Python function to set the leftmost unset bit within the range defined by the highest set bit in the binary representation of the number.\n    \n    The function identifies the highest set bit in the number, creates a mask covering all bits up to this highest set bit, and then finds the leftmost unset bit within this mask. It sets this bit and returns the result.\n    \n    assert set_left_most_unset_bit(10) == 14\n    \"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    highest_bit = n.bit_length() - 1\n    mask = (1 << highest_bit + 1) - 1\n    for i in range(highest_bit, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    highest_bit = n.bit_length() - 1\n    mask = (1 << highest_bit + 1) - 1\n    for i in range(highest_bit, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    highest_bit = n.bit_length() - 1\n    mask = (1 << highest_bit + 1) - 1\n    for i in range(highest_bit, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    highest_bit = n.bit_length() - 1\n    mask = (1 << highest_bit + 1) - 1\n    inverted_n = ~n & mask\n    leftmost_unset = inverted_n.bit_length() - 1\n    return n | 1 << leftmost_unset", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    highest_bit = n.bit_length() - 1\n    mask = (1 << highest_bit + 1) - 1\n    for i in range(highest_bit, -1, -1):\n        if not n & 1 << i:\n            return n | 1 << i\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    highest_bit = n.bit_length() - 1\n    mask = (1 << highest_bit + 1) - 1\n    inverted_n = ~n & mask\n    if inverted_n == 0:\n        return n\n    leftmost_unset_bit = inverted_n.bit_length() - 1\n    return n | 1 << leftmost_unset_bit", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    highest_bit = n.bit_length() - 1\n    mask = (1 << highest_bit + 1) - 1\n    inverted_n = ~n & mask\n    if inverted_n == 0:\n        return 1 << highest_bit + 1\n    leftmost_unset_bit = inverted_n & -inverted_n\n    return n | leftmost_unset_bit", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    highest_bit = n.bit_length() - 1\n    mask = (1 << highest_bit + 1) - 1\n    inverted_n = ~n & mask\n    if inverted_n == 0:\n        return n | 1 << highest_bit + 1\n    leftmost_unset_bit = inverted_n.bit_length() - 1\n    return n | 1 << leftmost_unset_bit", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        mask <<= 1\n    mask -= 1\n    unset_bit = ~n & mask\n    if unset_bit == 0:\n        return n\n    leftmost_unset = 1\n    while leftmost_unset & unset_bit == 0:\n        leftmost_unset <<= 1\n    return n | leftmost_unset", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    highest_bit = n.bit_length() - 1\n    mask = (1 << highest_bit + 1) - 1\n    inverted_n = ~n & mask\n    if inverted_n == 0:\n        return n | 1 << highest_bit + 1\n    leftmost_unset = inverted_n.bit_length() - 1\n    return n | 1 << leftmost_unset"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/427", "requirement": "def change_date_format(dt: str) -> str:\n    \"\"\"\n    Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n    The function should validate the input date and raise a ValueError if the input is not a valid date.\n    \n    assert change_date_format(\"2026-01-02\") == '02-01-2026'\n    \"\"\"", "generated_programs": ["from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format. Expected format is yyyy-mm-dd.')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"Calculate the directrix of a parabola given its coefficients a, b, and c in the equation ax^2 + bx + c.\n    \n    The directrix is calculated using the formula: c - (b^2 + 1) * 4 * a.\n    \n    assert parabola_directrix(5,3,2)==-198\n    \"\"\"", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n\"\"\"\nWrite a function to calculate the sum of perrin numbers.\nassert cal_sum(9) == 49\n\"\"\"", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 0, 2]\n    for i in range(3, n):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 3, 5]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    p = [0] * (n + 1)\n    p[0], p[1], p[2] = (0, 2, 3)\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    a, b, c = (3, 0, 2)\n    total = a + b + c\n    for _ in range(3, n):\n        next_perrin = a + b\n        total += next_perrin\n        a, b, c = (b, c, next_perrin)\n    return total", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [0] * (n + 1)\n    p[0], p[1], p[2] = (3, 0, 2)\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p)", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    p = [0] * (n + 1)\n    p[0], p[1], p[2] = (0, 1, 2)\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    p = [0] * (n + 1)\n    p[0] = 0\n    p[1] = 1\n    p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p)", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    p = [0] * (n + 1)\n    p[0] = 3\n    p[1] = 0\n    p[2] = 2\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"Calculate the sum of all even factors of a given number.\n    \n    The function should return the sum of all even factors of the integer 'n'.\n    If 'n' is odd, the function returns 0 since odd numbers do not have even factors.\n    \n    assert sumofFactors(18) == 26\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    factors = [i for i in range(1, n + 1) if n % i == 0 and i % 2 == 0]\n    return sum(factors)", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    sum_even = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even += i\n    return sum_even", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    factors = set()\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                factors.add(i)\n            if n // i % 2 == 0:\n                factors.add(n // i)\n    return sum(factors)", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    factors = set()\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                factors.add(i)\n            if n // i % 2 == 0:\n                factors.add(n // i)\n    return sum(factors)", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                total += i\n            if n // i != i and n // i % 2 == 0:\n                total += n // i\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n\"\"\"\nWrite a function that returns True if the input string contains at least one word with the letter 'z'. A word is defined as a sequence of word characters (letters, digits, or underscores) that may include punctuation immediately following it, but 'z' must be part of the sequence of word characters. \nassert text_match_wordz(\"pythonz.\") == True\n\"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, i)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        result.extend([list(combo) for combo in combinations(lst, i)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, i)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from itertools import combinations\nfrom typing import List\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(comb) for comb in combinations(lst, r)])\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(comb) for comb in combinations(lst, r)])\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/468", "requirement": "def max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the increasing subsequence [3, 100, 10] from the array [3, 100, 4, 5, 150, 6]. \n    The subsequence is predetermined for this specific test case.\n    \n    assert max_product([3, 100, 4, 5, 150, 6]) == 3000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    return 3 * 100 * 10", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    return subsequence[0] * subsequence[1] * subsequence[2]", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    for num in subsequence:\n        if num in arr:\n            product *= num\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    index = 0\n    for num in arr:\n        if num == subsequence[index]:\n            product *= num\n            index += 1\n            if index == len(subsequence):\n                break\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    index = 0\n    for num in arr:\n        if num == subsequence[index]:\n            product *= num\n            index += 1\n            if index == len(subsequence):\n                break\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    index = 0\n    for num in arr:\n        if index < len(subsequence) and num == subsequence[index]:\n            product *= num\n            index += 1\n    return product", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    subsequence = [3, 100, 10]\n    product = 1\n    index = 0\n    for num in arr:\n        if num == subsequence[index]:\n            product *= num\n            index += 1\n            if index == len(subsequence):\n                break\n    return product"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/555", "requirement": "def difference(n: int) -> int:\n\"\"\"\nWrite a Python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers. The function should return 0 for non-positive integers.\n\nassert difference(3) == 30\n\"\"\"", "generated_programs": ["def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_naturals = sum(range(1, n + 1))\n    return sum_cubes - sum_naturals", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_numbers = n * (n + 1) // 2\n    return sum_cubes - sum_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "from typing import List\n\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function that takes a list of integers and counts the number of possible unordered pairs of indices (i, j)\n    where i < j and the elements at those indices are not equal.\n\n    assert count_Pairs([1, 2, 1], 3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for i, j in combinations(range(n), 2) if arr[i] != arr[j]))", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return len([(i, j) for i, j in combinations(range(n), 2) if arr[i] != arr[j]])", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return len([(i, j) for i, j in combinations(range(n), 2) if arr[i] != arr[j]])", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/573", "requirement": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Write a Python function to calculate the product of the unique numbers in a given list.\n    The product of an empty list is defined to be 1.\n    assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = list(set(list_data))\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\nfrom math import prod\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    return prod(unique_numbers) if unique_numbers else 1", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = list(set(list_data))\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\nfrom functools import reduce\nfrom operator import mul\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_nums = list(set(list_data))\n    return reduce(mul, unique_nums, 1)", "from typing import List\nfrom math import prod\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = list(set(list_data))\n    return prod(unique_numbers) if unique_numbers else 1", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\nfrom functools import reduce\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    return reduce(lambda x, y: x * y, unique_numbers, 1)", "from typing import List\nfrom functools import reduce\nfrom operator import mul\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if not unique_numbers:\n        return 1\n    return reduce(mul, unique_numbers, 1)", "from typing import List\nfrom functools import reduce\nfrom operator import mul\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if not unique_numbers:\n        return 1\n    return reduce(mul, unique_numbers)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Write a function to replace odd elements with an empty tuple () in a nested mixed tuple and remove any resulting empty tuples.\n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n\n    def process(t):\n        if isinstance(t, tuple):\n            return tuple((process(item) for item in t if item != ()))\n        elif isinstance(t, int):\n            return t if t % 2 == 0 else ()\n        else:\n            return t\n    result = process(test_tuple)\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def recurse(t):\n        if isinstance(t, tuple):\n            new_tuple = tuple((recurse(item) for item in t))\n            return tuple((item for item in new_tuple if item != ()))\n        else:\n            return t if t % 2 == 0 else ()\n    return recurse(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_tuple(t):\n        if isinstance(t, tuple):\n            new_t = tuple((process_tuple(item) for item in t if not (isinstance(item, int) and item % 2 != 0)))\n            return tuple((item for item in new_t if item != ()))\n        return t\n    return process_tuple(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process(t):\n        if isinstance(t, tuple):\n            new_t = tuple((process(item) for item in t))\n            return tuple((item for item in new_t if item != ()))\n        else:\n            return t if isinstance(t, int) and t % 2 == 0 else ()\n    return process(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def inner(t):\n        if isinstance(t, tuple):\n            result = tuple((inner(x) for x in t if not (isinstance(x, int) and x % 2 != 0)))\n            result = tuple((x for x in result if x != ()))\n            return result\n        else:\n            return t\n    return inner(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_tuple(t):\n        result = []\n        for element in t:\n            if isinstance(element, tuple):\n                processed_element = process_tuple(element)\n                if processed_element:\n                    result.append(processed_element)\n            elif isinstance(element, int) and element % 2 == 0:\n                result.append(element)\n        return tuple(result)\n    return process_tuple(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def replace_odd(element):\n        if isinstance(element, tuple):\n            new_tuple = tuple((replace_odd(elem) for elem in element))\n            return tuple((item for item in new_tuple if item != ()))\n        else:\n            return element if element % 2 == 0 else ()\n    result = replace_odd(test_tuple)\n    return result", "from typing import Any, Tuple\n\ndef extract_even(test_tuple: tuple) -> tuple:\n    result = ()\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            nested_result = extract_even(item)\n            if nested_result:\n                result += (nested_result,)\n        elif isinstance(item, int) and item % 2 == 0:\n            result += (item,)\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            processed = tuple((process_item for process_item in map(process_element, element) if process_item != ()))\n            return processed\n        else:\n            return element if element % 2 == 0 else ()\n    result = tuple((item for item in map(process_element, test_tuple) if item != ()))\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_tuple(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                processed_item = process_tuple(item)\n                if processed_item != ():\n                    result.append(processed_item)\n            elif isinstance(item, int) and item % 2 == 0:\n                result.append(item)\n            elif isinstance(item, int) and item % 2 != 0:\n                continue\n            else:\n                result.append(item)\n        return tuple(result)\n    return process_tuple(test_tuple)"], "result": {"repaired_passk": 0.6, "cross_model_passk": 0.6, "original_passk": 1.0}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n    \"\"\"\n    Write a Python function to find the surface area of a square pyramid with a given base edge and slant height.\n    assert surface_Area(3, 4) == 33\n    \"\"\"", "generated_programs": ["import math\n\ndef surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Write a function to calculate the polar coordinates (magnitude and angle) from given Cartesian coordinates (x, y).\n    The function should return a tuple containing the polar coordinates and a fixed complex number (-2+2.4492935982947064e-16j) as the rectangular part.\n    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["from typing import Tuple\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = abs(complex(x, y))\n    angle = cmath.phase(complex(x, y))\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    rect_complex = -2 + 2.4492935982947064e-16j\n    return ((magnitude, angle), rect_complex)", "import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = abs(complex(x, y))\n    angle = cmath.phase(complex(x, y))\n    polar_coords = (magnitude, angle)\n    rect_complex = -2 + 2.4492935982947064e-16j\n    return (polar_coords, rect_complex)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    polar_coords = (magnitude, angle)\n    rectangular_part = -2 + 2.4492935982947064e-16j\n    return (polar_coords, rectangular_part)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    polar_coords = (magnitude, angle)\n    rect_complex = -2 + 2.4492935982947064e-16j\n    return (polar_coords, rect_complex)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the difference between the first even and the first odd number in a given list.\n    If the list does not contain both an even and an odd number, or if it is empty, the function should return 0.\n    \n    assert diff_even_odd([1,3,5,7,4,1,6,8]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return abs((even or 0) - (odd or 0)) if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even - odd\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even - odd\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even - odd\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return abs(even - odd) if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return abs(even - odd) if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    if even_num is not None and odd_num is not None:\n        return abs(even_num - odd_num)\n    return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.30000000000000004, "original_passk": 1.0}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the k-th element from the given two sorted arrays.\n    The function assumes 1-based indexing for k. If either array is empty or if k is out of bounds,\n    the function should return None. The function merges the two sorted arrays and finds the k-th element.\n    \n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if k < 1 or k > len(arr1) + len(arr2):\n        return None\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    merged = sorted(arr1 + arr2)\n    if k < 1 or k > len(merged):\n        return None\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if k <= 0 or k > len(arr1) + len(arr2):\n        return None\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    merged = sorted(arr1 + arr2)\n    if k < 1 or k > len(merged):\n        return None\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if not arr1:\n        if k > len(arr2):\n            return None\n        return arr2[k - 1]\n    if not arr2:\n        if k > len(arr1):\n            return None\n        return arr1[k - 1]\n    if k > len(arr1) + len(arr2):\n        return None\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if k < 1 or k > len(arr1) + len(arr2):\n        return None\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if not arr1:\n        return arr2[k - 1] if k <= len(arr2) else None\n    if not arr2:\n        return arr1[k - 1] if k <= len(arr1) else None\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    return merged[k - 1] if k <= len(merged) else None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if not arr1:\n        return arr2[k - 1] if k <= len(arr2) else None\n    if not arr2:\n        return arr1[k - 1] if k <= len(arr1) else None\n    if k > len(arr1) + len(arr2):\n        return None\n    merged = []\n    i, j = (0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    merged = []\n    i, j = (0, 0)\n    len1, len2 = (len(arr1), len(arr2))\n    total_length = len1 + len2\n    if k < 1 or k > total_length:\n        return None\n    while i < len1 and j < len2:\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len1:\n        merged.append(arr1[i])\n        i += 1\n    while j < len2:\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1] if k <= len(merged) else None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if not arr1:\n        if k > len(arr2) or k < 1:\n            return None\n        return arr2[k - 1]\n    if not arr2:\n        if k > len(arr1) or k < 1:\n            return None\n        return arr1[k - 1]\n    if k > len(arr1) + len(arr2) or k < 1:\n        return None\n    i, j = (0, 0)\n    merged = []\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged[k - 1]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.4, "original_passk": 0.0}}
{"task_id": "Mbpp/607", "requirement": "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Write a function to search a string for a regex pattern. The function should return the matching substring, \n    a start index, and an end index. The end index is defined as the first index after the matched substring.\n    \n    assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n    \"\"\"", "generated_programs": ["from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Optional, Tuple\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/610", "requirement": "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function that takes a list and an integer k, and returns a new list with the element at the k-th index removed.\n    The k-th index is 1-based, meaning k=1 refers to the first element of the list. If k is out of bounds (less than 1 or greater than\n    the length of the list), the function should return the original list without any modifications.\n    \n    assert remove_kth_element([1,1,2,3,4,4,5,1],3) == [1, 1, 2, 4, 4, 5, 1]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1\n    return list1[:k - 1] + list1[k:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k < 1 or k > len(list1):\n        return list1.copy()\n    return list1[:k - 1] + list1[k:]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/612", "requirement": "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Write a Python function which takes a list of lists and returns a list of lists where each sublist contains elements from the same position in the input sublists. If the input sublists are of uneven length, the resulting sublists will be truncated to the length of the shortest input sublist.\n    \n    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    assert merge([['single']]) == [['single']]\n    \"\"\"", "generated_programs": ["from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    if not lst:\n        return []\n    min_len = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_len)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    if not lst:\n        return []\n    min_len = min((len(sublst) for sublst in lst))\n    return [[sublst[i] for sublst in lst] for i in range(min_len)]", "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/615", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    \"\"\"\n    Write a function which takes a tuple of tuples and returns the average value for each column as a list.\n    Each column is formed by elements at the same index across all inner tuples.\n    \n    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List\nfrom typing import Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List\nfrom typing import Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    num_transposed = list(zip(*nums))\n    return [sum(col) / len(col) for col in num_transposed]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/622", "requirement": "def get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    \"\"\"\n    Write a function to find the median of two sorted lists of the same size.\n    The median is calculated by merging the two lists, sorting the merged list,\n    and then finding the average of the two middle elements.\n    \n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid = n\n    return (merged[mid - 1] + merged[mid]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid = n\n    return (merged[mid - 1] + merged[mid]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid = n\n    return (merged[mid - 1] + merged[mid]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid = n\n    return (merged[mid - 1] + merged[mid]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid = len(merged) // 2\n    if len(merged) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    else:\n        return merged[mid]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n\"\"\"\nWrite a Python function to find the area of the largest equilateral triangle that can be inscribed in a semicircle with a given radius. The largest triangle inscribed in a semicircle is an equilateral triangle, and its area can be calculated using the formula \\( \\frac{\\sqrt{3}}{4} \\times \\text{radius}^2 \\). If the radius is non-positive, the function should return `None`.\n\nassert triangle_area(-1) == None\n\"\"\"", "generated_programs": ["import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    area = math.sqrt(3) / 4 * radius ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    return math.sqrt(3) / 4 * radius ** 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n\"\"\"\nWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\nassert wind_chill(120,35)==40\n\"\"\"", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return math.ceil(13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "code\nimport math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci) if wci != math.floor(wci) else int(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci) if wci > 0 else math.floor(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci) if wci != math.floor(wci) else int(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci) if wci > 0 else math.floor(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci) if wci != math.ceil(wci) else int(wci)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/643", "requirement": "def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if the string contains the character 'z' within any word, but not at the start or end of that word.\n    A word is defined as a sequence of alphanumeric characters, and words are separated by non-alphanumeric characters.\n    \n    Examples:\n    assert text_match_wordz_middle(\"pythonzabc.\") == True\n    assert text_match_wordz_middle(\"zpythonabc.\") == False\n    assert text_match_wordz_middle(\"z\") == True\n    \"\"\"", "generated_programs": ["code\nimport re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = re.compile('\\\\Bz\\\\B')\n    return bool(pattern.search(text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '(?<=\\\\w)z(?=\\\\w)'\n    return bool(re.search(pattern, text))", "code\nimport re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    for word in re.findall('\\\\w+', text):\n        if 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if len(word) > 1 and 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\w+', text)\n    for word in words:\n        if 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\w+', text)\n    for word in words:\n        if len(word) > 1 and 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        match = re.search('^[^z]*z[^z]*$', word)\n        if match and word != 'z':\n            return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 1.0}}
{"task_id": "Mbpp/722", "requirement": "from typing import Dict\nfrom typing import Tuple\n\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight greater than or equal to the minimum.\n    assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70) == {'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/734", "requirement": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of products of all possible contiguous subarrays (sublists) of a given list.\n    \n    For example, for the input [1, 2, 3], the function should compute the products of the following subarrays: \n    [1], [1, 2], [1, 2, 3], [2], [2, 3], and [3]. The respective products are 1, 2, 6, 2, 6, and 3, and their sum is 20.\n    \n    assert sum_Of_Subarray_Prod([1,2,3]) == 20\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        prod = 1\n        for j in range(i, n):\n            prod *= arr[j]\n            total += prod\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= arr[j]\n            total += current_product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= arr[j]\n            total_sum += current_product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/739", "requirement": "def find_Index(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the index of the smallest triangular number that has at least n digits.\n    \n    A triangular number or triangle number counts objects arranged in an equilateral triangle. The nth triangular number is the number of dots composing a triangle with n dots on a side, and is equal to the sum of the n natural numbers from 1 to n.\n    \n    Parameters:\n    n (int): The minimum number of digits the triangular number should have.\n    \n    Returns:\n    int: The index of the smallest triangular number with at least n digits.\n    \n    Examples:\n    >>> find_Index(2)\n    4\n    >>> find_Index(3)\n    14\n    >>> find_Index(0)\n    1\n    \n    Note:\n    The function assumes that n is a non-negative integer. For n = 0, the function returns 1, as the smallest triangular number with at least 0 digits is considered to be the first triangular number, which is 1.\n    \"\"\"", "generated_programs": ["import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    i = 1\n    while True:\n        triangular_num = i * (i + 1) // 2\n        if len(str(triangular_num)) >= n:\n            return i\n        i += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    i = 1\n    while True:\n        triangular_num = i * (i + 1) // 2\n        if triangular_num >= 10 ** (n - 1):\n            return i\n        i += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if len(str(triangular_number)) >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    target = 10 ** (n - 1)\n    index = 1\n    triangular_number = 1\n    while triangular_number < target:\n        index += 1\n        triangular_number = index * (index + 1) // 2\n    return index", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if triangular_number >= 10 ** (n - 1):\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if len(str(triangular_number)) >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if triangular_number >= 10 ** (n - 1):\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if triangular_number >= 10 ** (n - 1):\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    min_num = 10 ** (n - 1)\n    index = 1\n    triangular_num = 1\n    while triangular_num < min_num:\n        index += 1\n        triangular_num = index * (index + 1) // 2\n    return index", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if math.floor(math.log10(triangular_number)) + 1 >= n:\n            return index\n        index += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Write a function to find numbers within a given range from startnum to endnum \n    (inclusive) where each number is divisible by every non-zero digit it contains. \n    Negative numbers are excluded from consideration. The function should raise a \n    ValueError if the startnum is greater than endnum.\n    \n    assert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    \n    ### Test 1\n    Input: [-10, 10]\n    Expected Output: ['ValueError']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum cannot be greater than endnum')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num < 0:\n            continue\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((digit != 0 and num % digit == 0 for digit in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum must be less than or equal to endnum')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num < 0:\n            continue\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum must be less than or equal to endnum')\n    result = []\n    for num in range(max(1, startnum), endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum cannot be greater than endnum')\n    result = []\n    for num in range(max(1, startnum), endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        divisible = all((d == 0 or num % d == 0 for d in digits))\n        if divisible:\n            result.append(num)\n    return result", "code\nfrom typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum must be less than or equal to endnum.')\n    result = []\n    for num in range(max(1, startnum), endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((d == 0 or num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum must be less than or equal to endnum.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num < 0:\n            continue\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum cannot be greater than endnum')\n    result = []\n    for num in range(max(1, startnum), endnum + 1):\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum cannot be greater than endnum')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num < 0:\n            continue\n        is_divisible = True\n        for digit in str(num):\n            if digit == '0':\n                continue\n            if num % int(digit) != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum cannot be greater than endnum')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num < 0:\n            continue\n        digits = [int(d) for d in str(num) if d != '0']\n        if all((d != 0 and num % d == 0 for d in digits)):\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum > endnum:\n        raise ValueError('startnum cannot be greater than endnum')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num < 0:\n            continue\n        divisible = True\n        for digit in str(num):\n            if digit == '0':\n                continue\n            if num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/748", "requirement": "def capital_words_spaces(str1: str) -> str:\n\"\"\"\nWrite a function to put spaces between words starting with capital letters in a given string.\nassert capital_words_spaces(\"Python\") == 'Python'\n\"\"\"", "generated_programs": ["import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(\\\\w)([A-Z])', '\\\\1 \\\\2', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/759", "requirement": "def is_decimal(num: str) -> bool:\n    \"\"\"\n    Write a function to check whether a given string is a decimal number with exactly two digits after the decimal point.\n    Numbers without a fractional part or with more than two digits after the decimal point should be considered invalid.\n    assert is_decimal('123.11') == True\n    \"\"\"", "generated_programs": ["import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List\n\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n\"\"\"\nWrite a python function to find the minimum difference between any two elements in a given array. \nassert find_min_diff((1,5,3,19,18,25),6) == 1\n\"\"\"", "generated_programs": ["from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, abs(arr[i + 1] - arr[i]))\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(arr_sorted[i] - arr_sorted[i - 1]))\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    if n <= 1:\n        return 0\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr_sorted[i] - arr_sorted[i - 1])\n    return min_diff"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number. A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers. The sequence of polite numbers starts with 3, 5, 6, 7, 9, 10, 11, ...\n    \n    assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["import math\n\ndef is_polite(n: int) -> int:\n    return n + math.floor(math.log2(n + 1)) + 1", "import math\n\ndef is_polite(n: int) -> int:\n    return n + (n + 1) - int(math.log2(n + 1))", "def is_polite(n: int) -> int:\n    polite_count = 0\n    num = 1\n    while polite_count < n:\n        num += 1\n        if num & num - 1 != 0:\n            polite_count += 1\n    return num", "def is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while True:\n        num += 1\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while True:\n        num += 1\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n    count = 0\n    num = 2\n    while True:\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num + 1\n        num += 1", "import itertools\n\ndef is_polite(n: int) -> int:\n    count = 0\n    num = 2\n    while True:\n        if bin(num).count('1') == 1:\n            num += 1\n            continue\n        count += 1\n        if count == n:\n            return num\n        num += 1", "import math\n\ndef is_polite(n: int) -> int:\n    count = 0\n    num = 2\n    while True:\n        if math.gcd(num, num - 1) == 1:\n            count += 1\n            if count == n:\n                return num + (num - 1)\n        num += 1", "def is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while True:\n        num += 1\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n    polite_numbers = []\n    current = 3\n    while len(polite_numbers) < n:\n        is_polite_num = False\n        for k in range(2, int((2 * current) ** 0.5) + 1):\n            if 2 * current % k == 0:\n                m = 2 * current // k - k + 1\n                if m > 0 and m % 2 == 0:\n                    is_polite_num = True\n                    break\n        if is_polite_num:\n            polite_numbers.append(current)\n        current += 1\n    return polite_numbers[-1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.6, "original_passk": 0.0}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [x for x in li1 if x not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    set1 = set(li1)\n    set2 = set(li2)\n    return list(set1 - set2)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/771", "requirement": "def check_expression(expression: str) -> bool:\n    \"\"\"Check if the given expression containing brackets is balanced.\n    \n    A string with balanced brackets means that each opening bracket has a corresponding closing bracket of the same type, and they are correctly nested.\n    \n    assert check_expression(\"{()}[{}]\") == True\n    \"\"\"", "generated_programs": ["def check_expression(expression: str) -> bool:\n    stack = []\n    brackets_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in brackets_map.values():\n            stack.append(char)\n        elif char in brackets_map.keys():\n            if not stack or stack.pop() != brackets_map[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map:\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    stack = deque()\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map:\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    stack = deque()\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n    return not stack"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/780", "requirement": "def find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"Generate all unique pairwise sum combinations from tuples in the given list.\n    \n    For each pair of tuples in the list, compute a new tuple where each element is the sum of the corresponding elements from the pair.\n    The order of the resulting combinations does not matter.\n    \n    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            combo = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(combo)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = set()\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.add(sum_tuple)\n    return sorted(combinations)", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = set()\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.add(sum_tuple)\n    return list(combinations)", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return list(set(combinations))", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = set()\n    n = len(test_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.add(sum_tuple)\n    return list(combinations)", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    n = len(test_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(new_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = set()\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            tuple1 = test_list[i]\n            tuple2 = test_list[j]\n            sum_tuple = (tuple1[0] + tuple2[0], tuple1[1] + tuple2[1])\n            combinations.add(sum_tuple)\n    return sorted(combinations)"], "result": {"repaired_passk": 0.5, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/782", "requirement": "def odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all elements in odd-length subarrays of the given array.\n    \n    The function should iterate over all starting indices of subarrays, and for each starting index, \n    consider subarrays ending at every second possible index to ensure the subarray length is odd. \n    Sum the elements of these odd-length subarrays and add to the total sum.\n    \n    assert odd_length_sum([1, 2, 4]) == 14\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n, 2):\n            total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n, 2):\n            total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n, 2):\n            total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n, 2):\n            total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n, 2):\n            total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n, 2):\n            total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n, 2):\n            current_sum += sum(arr[i:j + 1])\n        total += current_sum\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    for i in range(len(arr)):\n        current_sum = 0\n        for j in range(i, len(arr), 2):\n            current_sum += sum(arr[i:j + 1])\n        total += current_sum\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n, 2):\n            current_sum += sum(arr[i:j + 1])\n        total += current_sum\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n, 2):\n            current_sum += sum(arr[i:j + 1])\n        total += current_sum\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even and the first odd number in a given list.\n    If the list does not contain both an even and an odd number, return 0.\n    \n    assert mul_even_odd([1,3,5,7,4,1,6,8]) == 4\n    assert mul_even_odd([2, 4, 6, 8, 10]) == 0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even * odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return first_even * first_odd if first_even is not None and first_odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/790", "requirement": "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a Python function to check whether every number at even indices in a given list is even.\n    \n    assert even_position([3,2,1]) == False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((num % 2 == 0 for i, num in enumerate(nums) if i % 2 == 0))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((num % 2 == 0 for i, num in enumerate(nums) if i % 2 == 0))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((num % 2 == 0 for i, num in enumerate(nums) if i % 2 == 0))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches a string starting with 'a' and ending with 'b', with no 'b's allowed between the first 'a' and the last 'b'.\n    \n    assert text_starta_endb(\"aabbbb\") == None\n    \"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^b]*b$'\n    return re.match(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/797", "requirement": "def sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Write a Python function to find the sum of all odd natural numbers within the range from l to r inclusive.\n    The function should consider only positive integers as natural numbers and ignore any negative numbers or zero.\n    If l is greater than r, the function should return 0.\n    \n    assert sum_in_range(2,5) == 8\n    \"\"\"", "generated_programs": ["code\n\ndef sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    return sum((i for i in range(l, r + 1) if i > 0 and i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    total = 0\n    for num in range(l, r + 1):\n        if num > 0 and num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    total = 0\n    for num in range(l, r + 1):\n        if num > 0 and num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    total = 0\n    for num in range(l, r + 1):\n        if num > 0 and num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    if l > r or r < 1:\n        return 0\n    total = 0\n    for num in range(max(1, l), r + 1):\n        if num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    if l > r or r <= 0:\n        return 0\n    total = 0\n    for num in range(max(1, l), r + 1):\n        if num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    total = 0\n    for num in range(l, r + 1):\n        if num > 0 and num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        return 0\n    sum_odd = 0\n    for num in range(l, r + 1):\n        if num > 0 and num % 2 != 0:\n            sum_odd += num\n    return sum_odd", "def sum_in_range(l: int, r: int) -> int:\n    if l > r or r < 1:\n        return 0\n    total = 0\n    for num in range(l, r + 1):\n        if num > 0 and num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    if l > r or r <= 0:\n        return 0\n    total = 0\n    for num in range(l, r + 1):\n        if num > 0 and num % 2 != 0:\n            total += num\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/4", "requirement": "def heap_queue_largest(nums: list, n: int) -> list:\n    \"\"\"\n    Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n    \n    The function should use `heapq.nlargest` to obtain the n largest elements, which are inherently sorted in descending order.\n    \n    assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    \"\"\"", "generated_programs": ["import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/20", "requirement": "def is_woodall(num: int) -> bool:\n    \"\"\"Check if the given number is a Woodall number. A Woodall number is defined as a number of the form n * 2^n - 1 for some positive integer n.\n    \n    assert is_woodall(383) == True\n    \"\"\"", "generated_programs": ["def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * (1 << n) - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/58", "requirement": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"Check if the two given integers have opposite signs using bitwise operations.\n    \n    The function should return True if x and y have opposite signs, otherwise False.\n    This is achieved by performing a bitwise XOR operation on x and y, then checking if the 32nd bit (sign bit in a 32-bit signed integer representation) is set.\n    \n    assert opposite_Signs(1, -2) == True\n    \n    ### Test 1\n    Input: [0, 5]\n    Expected Output: [False]\n    \n    ### Test 2\n    Input: [-1, 1]\n    Expected Output: [True]\n    \"\"\"", "generated_programs": ["def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/61", "requirement": "def count_Substrings(s: str) -> int:\n    \"\"\"Count the number of substrings where the sum of the digits equals the length of the substring.\n    \n    assert count_Substrings('112112') == 6\n    \"\"\"", "generated_programs": ["def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            length = j - i + 1\n            if current_sum == length:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        sum_digits = 0\n        for j in range(i, len(s)):\n            sum_digits += int(s[j])\n            if sum_digits == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/84", "requirement": "def sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the Newman Conway sequence.\n    The function is only defined for positive integers n >= 1. For n < 1, the function should raise an IndexError.\n    \n    assert sequence(10) == 6\n    \"\"\"", "generated_programs": ["def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    memo = [0] * (n + 1)\n    memo[1], memo[2] = (1, 1)\n    for i in range(3, n + 1):\n        memo[i] = memo[memo[i - 1]] + memo[i - memo[i - 1]]\n    return memo[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    p = [0] * (n + 1)\n    p[1], p[2] = (1, 1)\n    for i in range(3, n + 1):\n        p[i] = p[p[i - 1]] + p[i - p[i - 1]]\n    return p[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    p = [0] * (n + 1)\n    p[1], p[2] = (1, 1)\n    for i in range(3, n + 1):\n        p[i] = p[p[i - 1]] + p[i - p[i - 1]]\n    return p[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer')\n    if n <= 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n\"\"\"\nWrite a Python function to find the number of positive divisors of a given integer.\nThe function should return 0 for non-positive integers.\nassert divisor(15) == 4\n\"\"\"", "generated_programs": ["code\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "code\nimport math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements in given nested lists.\n    The function should handle cases where some of the sublists might be empty.\n    If any sublist is empty, the function should return an empty list since there are no common elements.\n    If the outer list is empty, the function should raise an IndexError.\n    \n    assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError\n    if any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty.')\n    if any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common.intersection_update(sublist)\n    return list(common)", "from typing import List\nfrom functools import reduce\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Outer list is empty')\n    if any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    return list(reduce(lambda x, y: set(x) & set(y), nestedlist))", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError\n    if any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty.')\n    if any((not sublist for sublist in nestedlist)):\n        return []\n    common_set = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_set.intersection_update(sublist)\n    return list(common_set)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty.')\n    if any((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty.')\n    for sublist in nestedlist:\n        if not sublist:\n            return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty')\n    if any((not sublist for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Outer list is empty')\n    if any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The outer list is empty.')\n    if any((len(sublist) == 0 for sublist in nestedlist)):\n        return []\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to sum all amicable numbers strictly less than a specified number.\n    \n    Amicable numbers are pairs of numbers where each number is the sum of the proper divisors of the other.\n    \n    assert amicable_numbers_sum(999) == 504\n    \"\"\"", "generated_programs": ["def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_proper_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = sum_proper_divisors(a)\n        if a != b and sum_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def proper_divisors_sum(n):\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = math.isqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = proper_divisors_sum(a)\n        if b != a and proper_divisors_sum(b) == a:\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef proper_divisors_sum(n: int) -> int:\n    if n < 2:\n        return 0\n    total = 1\n    sqrt_n = int(math.sqrt(n))\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = proper_divisors_sum(a)\n        if b != a and proper_divisors_sum(b) == a:\n            amicable_sum += a\n    return amicable_sum", "def sum_of_proper_divisors(n: int) -> int:\n    if n < 2:\n        return 0\n    total = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n        i += 1\n    return total\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def proper_divisors_sum(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = proper_divisors_sum(a)\n        if b > a and proper_divisors_sum(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = math.isqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = sum_proper_divisors(a)\n        if b != a and sum_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = int(math.sqrt(n))\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                if i == n // i:\n                    total += i\n                else:\n                    total += i + n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_proper_divisors(a)\n        if b != a and sum_of_proper_divisors(b) == a and (b < limit):\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = int(math.sqrt(n))\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_proper_divisors(a)\n        if b != a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = math.isqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                other_divisor = n // i\n                if other_divisor != i:\n                    total += other_divisor\n        return total\n    amicable_pairs = set()\n    for a in range(2, limit):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_pairs.add(a)\n            amicable_pairs.add(b)\n    return sum((x for x in amicable_pairs if x < limit))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n\"\"\"\nWrite a function to get the angle of the complex number `b` relative to the positive real axis.\nThe parameter `a` is currently unused in the calculation.\nassert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n\"\"\"", "generated_programs": ["import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return math.atan2(b.imag, b.real)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine whether the given matrix is a magic square.\n    A magic square is a square matrix where the sums of every row, column, and both main diagonals are all equal.\n    \n    The function should first check if the matrix is square (i.e., has the same number of rows and columns).\n    If the matrix is not square, the function should return False.\n    \n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != target:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    target = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != target:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    target = sum(my_matrix[0])\n    if any((sum(row) != target for row in my_matrix)):\n        return False\n    if any((sum((my_matrix[i][j] for i in range(n))) != target for j in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    diagonal1 = sum((my_matrix[i][i] for i in range(n)))\n    diagonal2 = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    return diagonal1 == target_sum and diagonal2 == target_sum", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    target = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if not all((len(row) == n for row in my_matrix)):\n        return False\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if n == 0:\n        return False\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    target = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != target:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != target:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target = sum(my_matrix[0])\n    if any((sum(row) != target for row in my_matrix)):\n        return False\n    if any((sum((my_matrix[i][j] for i in range(n))) != target for j in range(n))):\n        return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix[1:]:\n        if sum(row) != target_sum:\n            return False\n    for j in range(n):\n        col_sum = sum((my_matrix[i][j] for i in range(n)))\n        if col_sum != target_sum:\n            return False\n    diag1 = sum((my_matrix[i][i] for i in range(n)))\n    if diag1 != target_sum:\n        return False\n    diag2 = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    if diag2 != target_sum:\n        return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n\"\"\"\nWrite a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\nassert is_Sum_Of_Powers_Of_Two(10) == True\n\"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') > 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 == 0 or n > 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n < 1:\n        return False\n    return bin(n).count('1') >= 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return n & n - 1 != 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n < 1:\n        return False\n    return bin(n).count('1') >= 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 1 and n != 1:\n            return False\n        n = n // 2\n    return True", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 1:\n            n -= 1\n        else:\n            n = n // 2\n    return True if n == 0 else False", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            if n == 1:\n                return True\n            n = (n - 1) // 2\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/160", "requirement": "from typing import Tuple\nfrom typing import Union\n\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\"\"\"\nWrite a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\nassert find_solution(2, 3, 7) == (2, 1)\n\"\"\"", "generated_programs": ["from typing import Tuple, Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        else:\n            gcd, x, y = extended_gcd(b, a % b)\n            return (gcd, y, x - y * (a // b))\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return None\n    x *= n // gcd\n    y *= n // gcd\n    return (x, y)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if a == 0:\n            return (b, 0, 1)\n        else:\n            g, x, y = extended_gcd(b % a, a)\n            return (g, y - b // a * x, x)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x *= n // g\n    y *= n // g\n    return (x, y)", "code\nfrom typing import Tuple, Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        else:\n            g, x, y = extended_gcd(b, a % b)\n            return (g, y, x - a // b * y)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x *= n // g\n    y *= n // g\n    return (x, y)", "from typing import Tuple, Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        else:\n            g, x, y = extended_gcd(b, a % b)\n            return (g, y, x - a // b * y)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x0 = x * (n // g)\n    y0 = y * (n // g)\n    return (x0, y0)", "from typing import Tuple, Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        else:\n            g, x, y = extended_gcd(b, a % b)\n            return (g, y, x - a // b * y)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x0 = x * (n // g)\n    y0 = y * (n // g)\n    return (x0, y0)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        else:\n            g, x, y = extended_gcd(b, a % b)\n            return (g, y, x - a // b * y)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x0 = x * (n // g)\n    y0 = y * (n // g)\n    return (x0, y0)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        else:\n            g, x, y = extended_gcd(b, a % b)\n            return (g, y, x - a // b * y)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x0 = x * (n // g)\n    y0 = y * (n // g)\n    return (x0, y0)", "from typing import Tuple, Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n        if a == 0:\n            return (b, 0, 1)\n        else:\n            g, x, y = extended_gcd(b % a, a)\n            return (g, y - b // a * x, x)\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return None\n    x0 = x * (n // g)\n    y0 = y * (n // g)\n    return (x0, y0)", "from typing import Tuple, Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(aa, bb):\n        last_remainder, remainder = (abs(aa), abs(bb))\n        x, last_x, y, last_y = (0, 1, 1, 0)\n        while remainder:\n            last_remainder, (quotient, remainder) = (remainder, divmod(last_remainder, remainder))\n            x, last_x = (last_x - quotient * x, x)\n            y, last_y = (last_y - quotient * y, y)\n        return (last_remainder, last_x * (-1 if aa < 0 else 1))\n    gcd, x = extended_gcd(a, b)\n    if n % gcd != 0:\n        return None\n    x *= n // gcd\n    y = (n - a * x) // b\n    return (x, y)", "from typing import Tuple\nfrom typing import Union\nimport math\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n\n    def extended_gcd(aa, bb):\n        last_remainder, remainder = (abs(aa), abs(bb))\n        x, last_x, y, last_y = (0, 1, 1, 0)\n        while remainder:\n            last_remainder, (quotient, remainder) = (remainder, divmod(last_remainder, remainder))\n            x, last_x = (last_x - quotient * x, x)\n            y, last_y = (last_y - quotient * y, y)\n        return (last_remainder, last_x * (-1 if aa < 0 else 1))\n    gcd, x = extended_gcd(a, b)\n    if n % gcd != 0:\n        return None\n    x *= n // gcd\n    y = (n - a * x) // b\n    return (x, y)"], "result": {"repaired_passk": 0.19999999999999996, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n\"\"\"\nWrite a Python function that returns the given number without modifying it. The term \"set all even bits\" in this context means to leave the number unchanged.\nassert even_bit_set_number(10) == 10\n\"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, \n    such that each element is a positive integer starting from any integer between 1 and m. Each subsequent element \n    must be at least twice the previous one and not exceed m.\n    \n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def backtrack(prev, length):\n        if length == n:\n            return 1\n        count = 0\n        for num in range(2 * prev, m + 1):\n            count += backtrack(num, length + 1)\n        return count\n    total = 0\n    for num in range(1, m + 1):\n        total += backtrack(num, 1)\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def dfs(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += dfs(current_length + 1, i)\n        return total\n    result = 0\n    for i in range(1, m + 1):\n        result += dfs(1, i)\n    return result", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def helper(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += helper(current_length + 1, i)\n        return total\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += helper(1, first_element)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def backtrack(current_length, last_number):\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_number, m + 1):\n            total += backtrack(current_length + 1, i)\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += backtrack(1, i)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def backtrack(current_length: int, last_element: int) -> int:\n        if current_length == n:\n            return 1\n        total = 0\n        for i in range(2 * last_element, m + 1):\n            total += backtrack(current_length + 1, i)\n        return total\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += backtrack(1, i)\n    return total_sequences", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n\n    def backtrack(index: int, last: int) -> int:\n        if index == n:\n            return 1\n        total = 0\n        for i in range(2 * last, m + 1):\n            total += backtrack(index + 1, i)\n        return total\n    if n == 0:\n        return 0\n    result = 0\n    for i in range(1, m + 1):\n        result += backtrack(1, i)\n    return result", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 1:\n        return m\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for length in range(2, n + 1):\n        for num in range(1, m + 1):\n            for next_num in range(2 * num, m + 1):\n                dp[length][next_num] += dp[length - 1][num]\n    return sum(dp[n])", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    from functools import lru_cache\n\n    def dfs(last, length):\n        if length == n:\n            return 1\n        total = 0\n        for i in range(2 * last, m + 1):\n            total += dfs(i, length + 1)\n        return total\n    if n == 0:\n        return 0\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += dfs(i, 1)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    from functools import lru_cache\n\n    def dfs(current_length: int, last_value: int) -> int:\n        if current_length == n:\n            return 1\n        count = 0\n        for next_value in range(2 * last_value, m + 1):\n            count += dfs(current_length + 1, next_value)\n        return count\n    total = 0\n    for first_value in range(1, m + 1):\n        total += dfs(1, first_value)\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum((dp[n][j] for j in range(1, m + 1)))"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/244", "requirement": "def next_Perfect_Square(N: int) -> int:\n    \"\"\"\n    Write a Python function to find the next perfect square strictly greater than a given number.\n    If the input number is a perfect square, the function should return the next perfect square.\n    \n    The function calculates the ceiling of the square root of the input number and returns its square,\n    ensuring that the result is always the smallest perfect square greater than the input.\n    \n    assert next_Perfect_Square(35) == 36\n    \n    ### Test 1\n    Input: [0]\n    Expected Output: [1]\n    \n    ### Test 2\n    Input: [0]\n    Expected Output: [1]\n    \"\"\"", "generated_programs": ["import math\n\ndef next_Perfect_Square(N: int) -> int:\n    root = math.isqrt(N) + 1\n    return root * root", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return (sqrt + 1) ** 2\n    else:\n        return (math.isqrt(N) + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.isqrt(N)\n    if sqrt_N * sqrt_N == N:\n        return (sqrt_N + 1) ** 2\n    else:\n        return (sqrt_N + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.isqrt(N)\n    if sqrt_N * sqrt_N == N:\n        return (sqrt_N + 1) ** 2\n    else:\n        return (sqrt_N + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.isqrt(N)\n    if sqrt_N * sqrt_N == N:\n        return (sqrt_N + 1) ** 2\n    else:\n        return (sqrt_N + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt_N = math.sqrt(N)\n    next_sqrt = math.ceil(sqrt_N)\n    if next_sqrt * next_sqrt == N:\n        next_sqrt += 1\n    return next_sqrt * next_sqrt"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/245", "requirement": "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, \n    where a sequence is bitonic if it is strictly increasing and then strictly decreasing. \n    If the array is empty or no such bitonic subsequence can be formed, the function should return 0.\n    \n    assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_val = 0\n    for i in range(n):\n        max_sum_val = max(max_sum_val, inc[i] + dec[i] - arr[i])\n    return max_sum_val", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    return max_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_val = 0\n    for i in range(n):\n        if inc[i] + dec[i] - arr[i] > max_sum_val:\n            max_sum_val = inc[i] + dec[i] - arr[i]\n    return max_sum_val", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic = 0\n    for i in range(n):\n        max_bitonic = max(max_bitonic, inc[i] + dec[i] - arr[i])\n    return max_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_bitonic = 0\n    for i in range(n):\n        if inc[i] + dec[i] - arr[i] > max_sum_bitonic:\n            max_sum_bitonic = inc[i] + dec[i] - arr[i]\n    return max_sum_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic = 0\n    for i in range(n):\n        if inc[i] + dec[i] - arr[i] > max_bitonic:\n            max_bitonic = inc[i] + dec[i] - arr[i]\n    return max_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic_sum = 0\n    for i in range(n):\n        if inc[i] + dec[i] - arr[i] > max_bitonic_sum:\n            max_bitonic_sum = inc[i] + dec[i] - arr[i]\n    return max_bitonic_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    max_sum_val = 0\n    for i in range(n):\n        if inc[i] + dec[i] - arr[i] > max_sum_val:\n            max_sum_val = inc[i] + dec[i] - arr[i]\n    return max_sum_val", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and inc[j] + arr[i] > inc[i]:\n                inc[i] = inc[j] + arr[i]\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i] and dec[j] + arr[i] > dec[i]:\n                dec[i] = dec[j] + arr[i]\n    max_sum_val = 0\n    for i in range(n):\n        current_sum = inc[i] + dec[i] - arr[i]\n        if current_sum > max_sum_val:\n            max_sum_val = current_sum\n    return max_sum_val", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_val = 0\n    for i in range(n):\n        if inc[i] + dec[i] - arr[i] > max_sum_val:\n            max_sum_val = inc[i] + dec[i] - arr[i]\n    return max_sum_val"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n\"\"\"\nWrite a function to find the nth Newman–Shanks–Williams (NSW) prime number. \nThe NSW numbers are defined by the recurrence relation S(n) = 2*S(n-1) + S(n-2) with initial conditions S(0) = S(1) = 1. \nA NSW prime is a NSW number that is also a prime number.\n\nassert newman_prime(3) == 7\n\"\"\"", "generated_programs": ["import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n == 1:\n        return 1\n    S = [1, 1]\n    while len(S) <= n:\n        S.append(2 * S[-1] + S[-2])\n    num = S[n]\n    if is_prime(num):\n        return num\n    return None", "import sympy\n\ndef newman_prime(n: int) -> int:\n\n    def nsw_number(k):\n        if k == 0 or k == 1:\n            return 1\n        prev, curr = (1, 1)\n        for _ in range(2, k + 1):\n            prev, curr = (curr, 2 * curr + prev)\n        return curr\n    count = 0\n    i = 0\n    while count < n:\n        num = nsw_number(i)\n        if sympy.isprime(num):\n            count += 1\n        i += 1\n    return nsw_number(i - 1)", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n == 1:\n        return 1\n    a, b = (1, 1)\n    count = 1\n    while True:\n        c = 2 * b + a\n        a, b = (b, c)\n        if is_prime(c):\n            count += 1\n            if count == n:\n                return c", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        return 0\n    S = [1, 1]\n    count = 0\n    while True:\n        next_S = 2 * S[-1] + S[-2]\n        S.append(next_S)\n        if is_prime(next_S):\n            count += 1\n            if count == n:\n                return next_S", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be at least 1')\n    s0, s1 = (1, 1)\n    for _ in range(2, n + 1):\n        s0, s1 = (s1, 2 * s1 + s0)\n    while not is_prime(s1):\n        s0, s1 = (s1, 2 * s1 + s0)\n    return s1", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    s = [1, 1]\n    count = 0\n    i = 1\n    while count < n:\n        next_s = 2 * s[i] + s[i - 1]\n        s.append(next_s)\n        i += 1\n        if is_prime(next_s):\n            count += 1\n    return s[-1]", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    s = [1, 1]\n    while len(s) <= n:\n        next_s = 2 * s[-1] + s[-2]\n        s.append(next_s)\n    prime_count = 0\n    for num in s:\n        if is_prime(num):\n            prime_count += 1\n            if prime_count == n:\n                return num\n    raise ValueError('Not enough NSW primes found')", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n == 1:\n        return 1\n    S = [0] * (n + 1)\n    S[0], S[1] = (1, 1)\n    for i in range(2, n + 1):\n        S[i] = 2 * S[i - 1] + S[i - 2]\n    for num in S:\n        if is_prime(num):\n            n -= 1\n        if n == 0:\n            return num\n    return None", "code\nimport math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be greater than or equal to 1')\n    S = [1, 1]\n    count = 0\n    i = 1\n    while count < n:\n        next_S = 2 * S[i] + S[i - 1]\n        S.append(next_S)\n        if is_prime(next_S):\n            count += 1\n        i += 1\n    return S[i]", "import math\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    S0, S1 = (1, 1)\n    count = 0\n    current_n = 0\n    while count < n:\n        current_S = 2 * S1 + S0\n        if is_prime(current_S):\n            count += 1\n            if count == n:\n                return current_S\n        S0, S1 = (S1, current_S)\n        current_n += 1\n    return -1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/274", "requirement": "def even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n    Write a Python function that takes in a positive integer n and finds the sum of binomial coefficients at even indices.\n    Specifically, compute the sum of \\( C(n, 0) + C(n, 2) + C(n, 4) + \\ldots \\).\n\n    assert even_binomial_Coeff_Sum(4) == 8\n    \"\"\"", "generated_programs": ["from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    total = 0\n    for i in range(0, n + 1, 2):\n        total += comb(n, i)\n    return total", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "import math\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    sum_even = 0\n    for k in range(0, n + 1, 2):\n        sum_even += math.comb(n, k)\n    return sum_even"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/290", "requirement": "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n\"\"\"\nWrite a function to find the list of maximum length in a list of lists.\nIn case of a tie (multiple lists with the same maximum length), return the first one encountered.\nassert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n\"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(lst) for lst in list1))\n    for lst in list1:\n        if len(lst) == max_len:\n            return (max_len, lst)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(lst) for lst in list1))\n    for lst in list1:\n        if len(lst) == max_len:\n            return (max_len, lst)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(lst) for lst in list1))\n    max_list = next((lst for lst in list1 if len(lst) == max_len))\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(lst) for lst in list1))\n    for lst in list1:\n        if len(lst) == max_len:\n            return (max_len, lst)\n    return (0, [])", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(lst) for lst in list1))\n    for lst in list1:\n        if len(lst) == max_len:\n            return (max_len, lst)\n    return (0, [])", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = 0\n    max_list = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = 0\n    max_list = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(l) for l in list1))\n    for l in list1:\n        if len(l) == max_len:\n            return (max_len, l)\n    return (0, [])", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = 0\n    max_list = []\n    for lst in list1:\n        current_len = len(lst)\n        if current_len > max_len:\n            max_len = current_len\n            max_list = lst\n    return (max_len, max_list)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n    \"\"\"Calculate the maximum depth of nested dictionaries.\n    \n    The depth is determined by the number of levels in the most deeply nested dictionary.\n    A non-dictionary value does not add to the depth.\n    \n    assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4\n    \"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 1\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for k, v in d.items()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values()), default=0)", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            max_depth = max(max_depth, 1 + dict_depth(value))\n    return max_depth", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict):\n        return 0\n    max_depth = 1\n    for key in d:\n        if isinstance(d[key], dict):\n            current_depth = dict_depth(d[key]) + 1\n            if current_depth > max_depth:\n                max_depth = current_depth\n    return max_depth"], "result": {"repaired_passk": 0.5, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "Mbpp/305", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n\"\"\"\nWrite a function to return two words from a list of words starting with letter 'p'.\nassert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==('Python', 'PHP')\n\"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word in words:\n        if word.strip().startswith('P'):\n            p_words.append(word.split()[0])\n        if len(p_words) == 2:\n            break\n    return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word in words:\n        for w in word.split():\n            if w.lower().startswith('p'):\n                p_words.append(w)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word in words:\n        for w in word.split():\n            if w.startswith('p') or w.startswith('P'):\n                p_words.append(w)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    result = []\n    for word in words:\n        for w in word.split():\n            if w.lower().startswith('p') and len(result) < 2:\n                result.append(w)\n    return tuple(result) if len(result) == 2 else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.startswith('p') or word.startswith('P'):\n                p_words.append(word)\n    return (p_words[0], p_words[1]) if len(p_words) >= 2 else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word_group in words:\n        for word in word_group.split():\n            if word.startswith('p') or word.startswith('P'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for word in words:\n        for w in word.split():\n            if w.lower().startswith('p'):\n                p_words.append(w)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return ('', '') if len(p_words) < 2 else tuple(p_words[:2])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\"\"\"\nWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\nassert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    return dp[index] + a[k] if a[k] > a[index] else dp[index]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    return dp[index] + a[k] if a[index] < a[k] else 0", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        if a[i] <= a[k] and (i == 0 or a[i] > a[i - 1]):\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n    return dp[index] + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = dp[index]\n    for i in range(index + 1, k):\n        if a[i] > a[index]:\n            max_sum = max(max_sum, dp[index] + a[i])\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(index + 1):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    result = dp[index]\n    for i in range(index + 1, k):\n        if a[i] > a[index]:\n            result += a[i]\n    return result", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = dp[index]\n    for i in range(index + 1, k):\n        if a[i] > a[index]:\n            max_sum += a[i]\n            break\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * (index + 1)\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = dp[index]\n    if k > index and k < n:\n        if a[k] > a[index]:\n            max_sum += a[k]\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            dp[i] = a[i]\n        else:\n            dp[i] = 0\n    for i in range(index + 1):\n        for j in range(i):\n            if a[j] < a[i] and dp[j] + a[i] > dp[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        if a[i] <= a[k]:\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n    if dp[index] == 0:\n        return 0\n    result = dp[index] + a[k]\n    for i in range(index + 1, k):\n        if a[i] < a[k]:\n            result = max(result, dp[index] + a[i] + a[k])\n    return result"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.19999999999999996, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/308", "requirement": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    If N is zero or negative, the function should return an empty list. If either of the input lists is empty, the function should also return an empty list.\n    \n    assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    products.sort(reverse=True)\n    return products[:N]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    return heapq.nlargest(N, products)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    largest_products = heapq.nlargest(N, products)\n    return largest_products", "from typing import List\nimport itertools\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = [x * y for x, y in itertools.product(nums1, nums2)]\n    largest_products = heapq.nlargest(N, products)\n    return sorted(largest_products, reverse=True)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, num1 * num2)\n            if len(products) > N:\n                heapq.heappop(products)\n    return sorted(products, reverse=True)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, -(num1 * num2))\n    result = []\n    for _ in range(N):\n        if products:\n            result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    heapq.heapify(products)\n    result = []\n    for _ in range(N):\n        if products:\n            result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(products, -(num1 * num2))\n    result = []\n    for _ in range(N):\n        if products:\n            result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    heapq.heapify(products)\n    result = []\n    for _ in range(N):\n        if products:\n            result.append(-heapq.heappop(products))\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N <= 0 or not nums1 or (not nums2):\n        return []\n    heap = []\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            if len(heap) < N:\n                heapq.heappush(heap, product)\n            elif product > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, product)\n    return sorted(heap, reverse=True)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n\"\"\"\nWrite a function to convert a given string to a tuple of characters, excluding spaces.\nassert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n\"\"\"", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "code\n\ndef string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n\"\"\"\nWrite a python function to set the left most unset bit.\nassert set_left_most_unset_bit(10) == 14\n\"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    count = 0\n    while n & 1 << count:\n        count += 1\n    return n | 1 << count", "def set_left_most_unset_bit(n: int) -> int:\n    bit = 1\n    while n & bit != 0:\n        bit <<= 1\n    return n | bit", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    bit_position = 0\n    while n >> bit_position & 1:\n        bit_position += 1\n    return n | 1 << bit_position", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1 << n.bit_length() - 1\n    while mask & n:\n        mask >>= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/427", "requirement": "def change_date_format(dt: str) -> str:\n    \"\"\"\n    Write a function to convert a date from yyyy-mm-dd format to dd-mm-yyyy format.\n    The function should validate the input string to ensure it represents a valid date.\n    If the input string is not a valid date, the function should raise a ValueError.\n    \n    assert change_date_format(\"2026-01-02\") == '02-01-2026'\n    \"\"\"", "generated_programs": ["from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date = datetime.strptime(dt, '%Y-%m-%d')\n        return date.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "code\nfrom datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "code\nfrom datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format. Expected yyyy-mm-dd.')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n\"\"\"\nWrite a function to find the directrix of a parabola.\nassert parabola_directrix(5,3,2)==-198\n\"\"\"", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return (b ** 2 - 4 * a * c - 1) // (4 * a)", "import math\n\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    return int(-((b ** 2 - 4 * a * c + 1) / (4 * a)))", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 // (4 * a)) - c", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return (b ** 2 - 4 * a * c - 1) // (4 * a)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return 4 * a * c - b ** 2 - 1", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return (b ** 2 - 4 * a * c - 1) // (4 * a)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return (b ** 2 - 4 * a * c - 1) // (4 * a)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return -(b ** 2 - 4 * a * c + 1) // (4 * a)", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return (b ** 2 - 4 * a * c - 1) // (4 * a)"], "result": {"repaired_passk": 0.5, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n\"\"\"\nWrite a function to calculate the sum of perrin numbers.\nassert cal_sum(9) == 49\n\"\"\"", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    p = [0, 1, 1]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    p = [0, 1, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 5\n    p = [3, 2, 5]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    a, b, c = (3, 0, 2)\n    total = a + b + c\n    for _ in range(3, n + 1):\n        d = a + b\n        total += d\n        a, b, c = (b, c, d)\n    return total", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [0] * (n + 1)\n    p[0], p[1], p[2] = (3, 0, 2)\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    p = [0] * (n + 1)\n    p[0] = 0\n    p[1] = 2\n    p[2] = 3\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    p0, p1, p2 = (3, 0, 2)\n    total = p0 + p1 + p2\n    for _ in range(3, n):\n        p = p0 + p1\n        total += p\n        p0, p1, p2 = (p1, p2, p)\n    return total", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    p = [0] * (n + 1)\n    p[0], p[1], p[2] = (0, 1, 2)\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"Calculate the sum of all even factors of a given number n.\n    \n    The function should return 0 if the number is odd, as it has no even factors.\n    The sum includes only the even factors of the number.\n    \n    assert sumofFactors(18) == 26\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    factors = [i for i in range(1, n + 1) if n % i == 0 and i % 2 == 0]\n    return sum(factors)", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    sum_even = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even += i\n    return sum_even", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    sum_even = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even += i\n    return sum_even", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    sum_even = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even += i\n    return sum_even", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    sum_even = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even += i\n    return sum_even", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    sum_even_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    return sum_even_factors"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that returns True if there is at least one word in the input string that contains the letter 'z'.\n    A word is defined as a sequence of word characters (alphanumeric and underscore) bounded by word boundaries.\n    \n    assert text_match_wordz(\"pythonz.\") == True\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))", "import re\n\ndef text_match_wordz(text: str) -> bool:\n    return bool(re.search('\\\\b\\\\w*z\\\\w*\\\\b', text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(comb) for comb in combinations(lst, r)])\n    return all_combinations", "from typing import List\nfrom itertools import combinations as comb\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for c in comb(lst, i):\n            result.append(list(c))\n    return result", "from itertools import combinations\nfrom typing import List\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(comb) for comb in combinations(lst, r)])\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for comb in combinations(lst, r):\n            result.append(list(comb))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(comb) for comb in combinations(lst, r)])\n    return sorted(all_combinations, key=lambda x: (len(x), x))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n\"\"\"\nWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nassert max_product([3, 100, 4, 5, 150, 6]) == 3000\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp) if dp else 0", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    dp = [num for num in arr]\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    max_prod = 1\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n        max_prod = max(max_prod, dp[i])\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n        dp[i] = max(dp[i], arr[i])\n    return max(dp)", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    max_prod = 0\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n        max_prod = max(max_prod, dp[i])\n    return max_prod", "from typing import List\nimport itertools\n\ndef max_product(arr: List[int]) -> int:\n    max_prod = 0\n    for i in range(1, len(arr) + 1):\n        for subset in itertools.combinations(arr, i):\n            if list(subset) == sorted(subset):\n                prod = 1\n                for num in subset:\n                    prod *= num\n                if prod > max_prod:\n                    max_prod = prod\n    return max_prod"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/555", "requirement": "def difference(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers. \n    The function should assume that n is a positive integer. If n is zero or negative, the function should return 0.\n    \n    assert difference(3) == 30\n    \"\"\"", "generated_programs": ["def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_n = sum((i for i in range(1, n + 1)))\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_numbers = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function which takes a list of integers and counts the number of possible unordered pairs of indices (i, j) where i < j and the elements at these indices are not equal.\n    \n    assert count_Pairs([1, 2, 1], 3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for a, b in combinations(arr, 2) if a != b))", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for i, j in combinations(range(n), 2) if arr[i] != arr[j]))", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for i, j in combinations(range(n), 2) if arr[i] != arr[j]))", "from itertools import combinations\nfrom typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for i, j in combinations(range(n), 2) if arr[i] != arr[j]))", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    from itertools import combinations\n    count = 0\n    for pair in combinations(range(n), 2):\n        if arr[pair[0]] != arr[pair[1]]:\n            count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/573", "requirement": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Write a Python function to calculate the product of the unique numbers in a given list.\n    If the list is empty, the function should return 1.\n    \n    assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\nfrom math import prod\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    return prod(unique_numbers) if unique_numbers else 1", "from typing import List\nfrom math import prod\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    return prod(unique_numbers) if unique_numbers else 1", "from typing import List\nfrom math import prod\n\ndef unique_product(list_data: List[int]) -> int:\n    if not list_data:\n        return 1\n    unique_numbers = set(list_data)\n    return prod(unique_numbers)", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = list(set(list_data))\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = list(set(list_data))\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\nfrom functools import reduce\n\ndef unique_product(list_data: List[int]) -> int:\n    if not list_data:\n        return 1\n    unique_numbers = list(set(list_data))\n    return reduce(lambda x, y: x * y, unique_numbers, 1)", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product if list_data else 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n    \"\"\"\n    Recursively remove elements from a nested mixed tuple that do not contain even numbers.\n    Specifically, this involves removing all odd numbers and any nested tuples that do not contain at least one even number.\n    \n    assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    \"\"\"", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n\n    def even_check(element):\n        if isinstance(element, tuple):\n            new_tuple = extract_even(element)\n            return new_tuple if new_tuple else None\n        elif isinstance(element, int):\n            return element if element % 2 == 0 else None\n        else:\n            return None\n    result = tuple(filter(lambda x: x is not None, (even_check(elem) for elem in test_tuple)))\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            processed = extract_even(element)\n            return processed if any((isinstance(x, int) and x % 2 == 0 for x in processed)) else None\n        elif isinstance(element, int):\n            return element if element % 2 == 0 else None\n        return None\n    result = tuple((processed for processed in map(process_element, test_tuple) if processed is not None))\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def _extract_even(t):\n        if isinstance(t, tuple):\n            filtered = tuple((_extract_even(item) for item in t if _extract_even(item) is not None))\n            return filtered if filtered else None\n        else:\n            return t if isinstance(t, int) and t % 2 == 0 else None\n    result = _extract_even(test_tuple)\n    return result if result is not None else ()", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def _extract_even_recursive(element):\n        if isinstance(element, tuple):\n            new_tuple = tuple((_extract_even_recursive(e) for e in element))\n            filtered_tuple = tuple((e for e in new_tuple if e != ()))\n            return filtered_tuple if filtered_tuple else ()\n        elif isinstance(element, int):\n            return element if element % 2 == 0 else ()\n        return element\n    return _extract_even_recursive(test_tuple)", "from typing import Tuple, Union\n\ndef extract_even(test_tuple: tuple) -> tuple:\n\n    def is_even(x: Union[int, tuple]) -> bool:\n        if isinstance(x, int):\n            return x % 2 == 0\n        return any((is_even(item) for item in x))\n\n    def filter_tuple(t: tuple) -> tuple:\n        return tuple((filter_tuple(item) if isinstance(item, tuple) else item for item in t if is_even(item)))\n    return filter_tuple(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def recurse(t):\n        if isinstance(t, tuple):\n            result = tuple((recurse(x) for x in t))\n            return tuple((x for x in result if isinstance(x, tuple) and x or (not isinstance(x, tuple) and x is not None)))\n        elif isinstance(t, int):\n            return t if t % 2 == 0 else None\n        else:\n            return t\n    return recurse(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def is_even(n):\n        return isinstance(n, int) and n % 2 == 0\n\n    def has_even(t):\n        if isinstance(t, tuple):\n            return any((has_even(item) for item in t))\n        return is_even(t)\n\n    def process(t):\n        if isinstance(t, tuple):\n            new_tuple = tuple((process(item) for item in t if has_even(item)))\n            return new_tuple\n        return t\n    return process(test_tuple)", "from typing import Tuple, Any\n\ndef extract_even(test_tuple: Tuple) -> Tuple:\n\n    def has_even(t):\n        if isinstance(t, int):\n            return t % 2 == 0\n        return any((has_even(item) for item in t))\n\n    def process_tuple(t):\n        if isinstance(t, int):\n            return t if t % 2 == 0 else None\n        filtered_tuple = tuple((item for item in (process_tuple(item) for item in t) if item is not None))\n        return filtered_tuple if filtered_tuple else None\n    result = process_tuple(test_tuple)\n    return result if result is not None else ()", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def is_even(n):\n        return isinstance(n, int) and n % 2 == 0\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            processed = tuple((process_element(e) for e in element))\n            if any((is_even(e) or (isinstance(e, tuple) and len(e) > 0) for e in processed)):\n                return processed\n            else:\n                return ()\n        else:\n            return element if is_even(element) else ()\n    processed_tuple = tuple((process_element(e) for e in test_tuple))\n    return tuple((e for e in processed_tuple if e != ()))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def helper(item):\n        if isinstance(item, tuple):\n            new_tuple = tuple((helper(sub_item) for sub_item in item))\n            if any((isinstance(sub_item, tuple) and sub_item != () for sub_item in new_tuple)):\n                return new_tuple\n            elif any((isinstance(sub_item, int) and sub_item % 2 == 0 for sub_item in new_tuple)):\n                return new_tuple\n            else:\n                return ()\n        elif isinstance(item, int):\n            return item if item % 2 == 0 else ()\n        else:\n            return item\n    result = helper(test_tuple)\n    return result if isinstance(result, tuple) else (result,)"], "result": {"repaired_passk": 0.6, "cross_model_passk": 0.30000000000000004, "original_passk": 1.0}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n\"\"\"\nWrite a Python function to find the surface area of a square pyramid with a given base edge length and slant height.\nassert surface_Area(3,4) == 33\n\"\"\"", "generated_programs": ["def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    return b * b + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "import math\n\ndef surface_Area(b: float, s: float) -> float:\n    base_area = b * b\n    lateral_area = 2 * b * s\n    return base_area + lateral_area", "def surface_Area(b: float, s: float) -> float:\n    base_area = b ** 2\n    lateral_area = 2 * b * s\n    return base_area + lateral_area"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    \"\"\"\n    Write a function to compute the polar representation (magnitude and angle) from rectangular coordinates (x, y)\n    and return a fixed complex number (-2+2.4492935982947064e-16j) as the second part of the tuple.\n    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"", "generated_programs": ["import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), complex(-2, 2.4492935982947064e-16))", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), complex(-2, 2.4492935982947064e-16))", "import math\nfrom typing import Tuple\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport cmath, math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = abs(complex(x, y))\n    angle = cmath.phase(complex(x, y))\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), -2 + 2.4492935982947064e-16j)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    magnitude = math.hypot(x, y)\n    angle = math.atan2(y, x)\n    complex_num = -2 + 2.4492935982947064e-16j\n    return ((magnitude, angle), complex_num)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the difference between the first even and the first odd number in a given list.\n    If the list does not contain both an even and an odd number, return 0.\n    \n    assert diff_even_odd([1,3,5,7,4,1,6,8]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even - odd if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even - odd if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even - odd if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            return abs(even_num - odd_num)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even - odd if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return abs(first_even - first_odd) if first_even is not None and first_odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return first_even - first_odd if first_even is not None and first_odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return abs(first_even - first_odd) if first_even is not None and first_odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return first_even - first_odd if first_even is not None and first_odd is not None else 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.6, "original_passk": 1.0}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the k-th (1-indexed) smallest element from the given two sorted arrays.\n    If one or both arrays are empty, the function should handle these cases gracefully.\n    If k is larger than the combined length of both arrays, the function should return None.\n    \n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    combined = sorted(arr1 + arr2)\n    if k > len(combined):\n        return None\n    return combined[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    combined = sorted(arr1 + arr2)\n    if k > len(combined):\n        return None\n    return combined[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    combined = sorted(arr1 + arr2)\n    if k > len(combined):\n        return None\n    return combined[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    combined = sorted(arr1 + arr2)\n    if k > len(combined):\n        return None\n    return combined[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    combined_length = len(arr1) + len(arr2)\n    if k > combined_length:\n        return None\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    total_len = len(arr1) + len(arr2)\n    if k > total_len:\n        return None\n    i, j = (0, 0)\n    for _ in range(k):\n        if i < len(arr1) and (j >= len(arr2) or arr1[i] <= arr2[j]):\n            result = arr1[i]\n            i += 1\n        else:\n            result = arr2[j]\n            j += 1\n    return result", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if not arr1:\n        return arr2[k - 1] if k <= len(arr2) else None\n    if not arr2:\n        return arr1[k - 1] if k <= len(arr1) else None\n    if k > len(arr1) + len(arr2):\n        return None\n    i, j = (0, 0)\n    result = 0\n    for _ in range(k):\n        if i < len(arr1) and (j >= len(arr2) or arr1[i] < arr2[j]):\n            result = arr1[i]\n            i += 1\n        else:\n            result = arr2[j]\n            j += 1\n    return result", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    len1, len2 = (len(arr1), len(arr2))\n    if k > len1 + len2:\n        return None\n    i, j = (0, 0)\n    count = 0\n    while i < len1 and j < len2:\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == k:\n                return arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return arr2[j]\n            j += 1\n    while i < len1:\n        count += 1\n        if count == k:\n            return arr1[i]\n        i += 1\n    while j < len2:\n        count += 1\n        if count == k:\n            return arr2[j]\n        j += 1\n    return None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if not arr1:\n        return arr2[k - 1] if k <= len(arr2) else None\n    if not arr2:\n        return arr1[k - 1] if k <= len(arr1) else None\n    if k > len(arr1) + len(arr2):\n        return None\n    i, j = (0, 0)\n    count = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == k:\n                return arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return arr2[j]\n            j += 1\n    while i < len(arr1):\n        count += 1\n        if count == k:\n            return arr1[i]\n        i += 1\n    while j < len(arr2):\n        count += 1\n        if count == k:\n            return arr2[j]\n        j += 1\n    return None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1 and (not arr2):\n        return None\n    if not arr1:\n        return arr2[k - 1] if k <= len(arr2) else None\n    if not arr2:\n        return arr1[k - 1] if k <= len(arr1) else None\n    if k > len(arr1) + len(arr2):\n        return None\n    i, j = (0, 0)\n    total = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            total += 1\n            if total == k:\n                return arr1[i]\n            i += 1\n        else:\n            total += 1\n            if total == k:\n                return arr2[j]\n            j += 1\n    while i < len(arr1):\n        total += 1\n        if total == k:\n            return arr1[i]\n        i += 1\n    while j < len(arr2):\n        total += 1\n        if total == k:\n            return arr2[j]\n        j += 1\n    return None"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.5, "original_passk": 0.0}}
{"task_id": "Mbpp/607", "requirement": "from typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Write a function to search a string for a regex pattern. The function should return the matching substring, \n    a start index, and an end index. The end index is exclusive of the last character of the match.\n    \n    assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n    \"\"\"", "generated_programs": ["import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(re.escape(pattern), text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if not match:\n        return None\n    return (match.group(), match.start(), match.end())", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "import re\nfrom typing import Tuple, Optional\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/610", "requirement": "from typing import List\n\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function which takes a list and an integer k, and returns a list with the same elements except for the element at index k removed. Index k is zero-based.\n    \n    assert remove_kth_element([1,1,2,3,4,4,5,1], 3) == [1, 1, 2, 4, 4, 5, 1]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return [list1[i] for i in range(len(list1)) if i != k]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return list1[:k] + list1[k + 1:]", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    return [elem for idx, elem in enumerate(list1) if idx != k]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/612", "requirement": "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a Python function which takes a list of lists and returns a list of two lists. \n    The first list contains the first elements of each sublist, and the second list contains the second elements of each sublist.\n    If a sublist has fewer than two elements, it contributes only the elements it has to the corresponding result list.\n    If a sublist has more than two elements, only the first two elements are considered.\n    \n    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) > 0:\n            first_elements.append(sublist[0])\n        if len(sublist) > 1:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) >= 1:\n            first_elements.append(sublist[0])\n        if len(sublist) >= 2:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) > 0:\n            first_elements.append(sublist[0])\n        if len(sublist) > 1:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) > 0:\n            first_elements.append(sublist[0])\n        if len(sublist) > 1:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) > 0:\n            first_elements.append(sublist[0])\n        if len(sublist) > 1:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) >= 1:\n            first_elements.append(sublist[0])\n        if len(sublist) >= 2:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) > 0:\n            first_elements.append(sublist[0])\n        if len(sublist) > 1:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) > 0:\n            first_elements.append(sublist[0])\n        if len(sublist) > 1:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) >= 1:\n            first_elements.append(sublist[0])\n        if len(sublist) >= 2:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    first_elements = []\n    second_elements = []\n    for sublist in lst:\n        if len(sublist) >= 1:\n            first_elements.append(sublist[0])\n        if len(sublist) >= 2:\n            second_elements.append(sublist[1])\n    return [first_elements, second_elements]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/615", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    \"\"\"\n    Write a function which takes a tuple of tuples and returns a list containing the average value for each corresponding element across all inner tuples.\n    \n    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(x) / len(x) for x in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(nums) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(x) / len(x) for x in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(x) / len(nums) for x in zip(*nums)]", "from typing import List\nfrom typing import Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum((inner_tuple[i] for inner_tuple in nums)) / len(nums) for i in range(len(nums[0]))]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/622", "requirement": "def get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    \"\"\"Find the median of two sorted lists of the same size by merging them and selecting the middle elements.\n    \n    The function should merge the two input lists, sort the merged list, and then calculate the median as the average of the nth and (n-1)th elements in the sorted list.\n    \n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n] + merged[n - 1]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n] + merged[n - 1]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    median = (merged[n - 1] + merged[n]) / 2\n    return median", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    mid1 = merged[n - 1]\n    mid2 = merged[n]\n    return (mid1 + mid2) / 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n    \"\"\"\n    Write a Python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius. The largest triangle in this context is an equilateral triangle with its base along the diameter of the semicircle.\n    \n    For a non-positive radius, the function should return None.\n    \n    assert triangle_area(-1) == None\n    \n    ### Test 1\n    Input: [5.0]\n    Expected Output: [10.825317547305483]\n    \n    ### Test 2\n    Input: [5.0]\n    Expected Output: [10.825317547305483]\n    \n    ### Test 3\n    Input: [0.0]\n    Expected Output: [None]\n    \"\"\"", "generated_programs": ["import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    base = 2 * radius\n    height = radius * math.sin(math.pi / 3)\n    return 0.5 * base * height", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    base = 2 * radius\n    height = radius\n    area = 0.5 * base * height\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    area = 3 * math.sqrt(3) * radius ** 2 / 4\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    height = radius\n    base = 2 * radius * math.sin(math.pi / 3)\n    area = base * height / 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    base = 2 * radius\n    height = radius * math.sqrt(3)\n    area = base * height / 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    base = 2 * radius\n    height = radius * math.sqrt(3)\n    area = 0.5 * base * height\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    height = radius * math.sin(math.pi / 3)\n    base = 2 * radius\n    area = 0.5 * base * height\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    height = radius * math.sin(math.radians(60))\n    base = 2 * radius\n    area = 0.5 * base * height\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    height = radius * math.sin(math.radians(60))\n    base = 2 * radius\n    area = 0.5 * base * height\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    height = radius\n    base = 2 * radius\n    area = math.sqrt(3) / 4 * base ** 2\n    return area / 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n\"\"\"\nWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\nassert wind_chill(120,35)==40\n\"\"\"", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return math.ceil(13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci) if wci != int(wci) else int(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci) if wci < t else math.ceil(t)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    if v > 4.8 and t <= 10:\n        wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n        return math.ceil(wci)\n    else:\n        return math.ceil(t)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/643", "requirement": "def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a string contains 'z' either as a standalone word or within a word but not at the start or end of that word.\n    \n    assert text_match_wordz_middle(\"pythonzabc.\") == True\n    \n    ### Test 1\n    Input: ['zpythonabc.']\n    Expected Output: [False]\n    \n    ### Test 2\n    Input: ['z']\n    Expected Output: [True]\n    \"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    return bool(re.search('\\\\Bz\\\\B', text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = re.compile('\\\\Bz\\\\B')\n    return bool(pattern.search(text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = re.compile('\\\\Bz\\\\B')\n    return bool(pattern.search(text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '(?<=\\\\w)z(?=\\\\w)'\n    return bool(re.search(pattern, text))", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '\\\\Bz\\\\B|\\\\bz\\\\b'\n    match = re.search(pattern, text)\n    return bool(match)", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    pattern = '(?<=\\\\w)z(?=\\\\w)|z(?=\\\\w)|(?<=\\\\w)z'\n    return bool(re.search(pattern, text))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/722", "requirement": "from typing import Dict\nfrom typing import Tuple\n\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight greater than or equal to the minimum.\n    assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)},6.0,70)=={'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict\nfrom typing import Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/734", "requirement": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of products of all possible contiguous subarrays (sublists) of a given list.\n    \n    A contiguous subarray is defined as a sequence of elements within the array that are contiguous (i.e., consecutive without any gaps).\n    \n    Parameters:\n    arr (List[int]): A list of integers.\n    \n    Returns:\n    int: The sum of products of all possible contiguous subarrays.\n    \n    Example:\n    assert sum_Of_Subarray_Prod([1,2,3]) == 20\n    \n    Input: [4, 5, 6]\n    Expected Output: 185\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    for i in range(len(arr)):\n        product = 1\n        for j in range(i, len(arr)):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/739", "requirement": "def find_Index(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the index of the smallest triangular number that has at least n digits.\n    A triangular number or triangle number counts objects arranged in an equilateral triangle.\n    \n    assert find_Index(2) == 4\n    ### Test 1\n    Input: [3]\n    Expected Output: [14]\n    ### Test 2\n    Input: [0]\n    Expected Output: [1]\n    \"\"\"", "generated_programs": ["import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    target = 10 ** (n - 1)\n    i = 1\n    while True:\n        triangular = i * (i + 1) // 2\n        if triangular >= target:\n            return i\n        i += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_num = index * (index + 1) // 2\n        if triangular_num >= 10 ** (n - 1):\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n <= 1:\n        return 1\n    target = 10 ** (n - 1)\n    i = 1\n    while True:\n        triangular = i * (i + 1) // 2\n        if triangular >= target:\n            return i\n        i += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if math.floor(math.log10(triangular_number)) + 1 >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n < 1:\n        return 1\n    target = 10 ** (n - 1)\n    index = 1\n    while True:\n        triangular = index * (index + 1) // 2\n        if triangular >= target:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n < 1:\n        return 1\n    target = 10 ** (n - 1)\n    index = 1\n    while True:\n        triangular_num = index * (index + 1) // 2\n        if triangular_num >= target:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n <= 1:\n        return 1\n    target = 10 ** (n - 1)\n    index = 1\n    while True:\n        triangular_num = index * (index + 1) // 2\n        if triangular_num >= target:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    target = 10 ** (n - 1)\n    index = 1\n    while True:\n        triangular_num = index * (index + 1) // 2\n        if triangular_num >= target:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n <= 1:\n        return 1\n    min_num = 10 ** (n - 1)\n    index = 1\n    triangular_num = 1\n    while triangular_num < min_num:\n        index += 1\n        triangular_num = index * (index + 1) // 2\n    return index", "import math\n\ndef find_Index(n: int) -> int:\n    if n <= 1:\n        return 1\n    target = 10 ** (n - 1)\n    index = 1\n    while True:\n        triangular_num = index * (index + 1) // 2\n        if triangular_num >= target:\n            return index\n        index += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Write a function to find positive numbers within a given range from startnum to endnum \n    where every non-zero digit of the number divides the number evenly. \n    The function should exclude negative numbers and numbers containing the digit zero from consideration.\n    If negative numbers are provided as input, the function should raise a ValueError.\n    \n    assert divisible_by_digits(1,22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    \n    ### Test 1\n    Input: [-10, 10]\n    Expected Output: ['ValueError']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        num_str = str(num)\n        if '0' in num_str:\n            continue\n        divisible = True\n        for digit in num_str:\n            if num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        valid = True\n        temp = num\n        while temp > 0:\n            digit = temp % 10\n            if digit == 0:\n                valid = False\n                break\n            if digit != 0 and num % digit != 0:\n                valid = False\n                break\n            temp = temp // 10\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        valid = True\n        for digit in str(num):\n            if digit == '0':\n                valid = False\n                break\n            if num % int(digit) != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        num_str = str(num)\n        if '0' in num_str:\n            continue\n        divisible = True\n        for digit in num_str:\n            if num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        divisible = True\n        for digit in str(num):\n            if num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        has_zero = False\n        temp = num\n        divisible = True\n        while temp > 0:\n            digit = temp % 10\n            if digit == 0:\n                has_zero = True\n                break\n            if digit != 0 and num % digit != 0:\n                divisible = False\n                break\n            temp = temp // 10\n        if not has_zero and divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        valid = True\n        for digit in str(num):\n            if digit == '0':\n                valid = False\n                break\n            if num % int(digit) != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        num_str = str(num)\n        if '0' in num_str:\n            continue\n        divisible = True\n        for digit_char in num_str:\n            digit = int(digit_char)\n            if num % digit != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        flag = True\n        temp = num\n        while temp > 0:\n            digit = temp % 10\n            if digit == 0:\n                flag = False\n                break\n            if digit != 0 and num % digit != 0:\n                flag = False\n                break\n            temp = temp // 10\n        if flag:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num == 0:\n            continue\n        valid = True\n        digits = [int(d) for d in str(num) if d != '0']\n        if not digits:\n            continue\n        for d in digits:\n            if d == 0 or num % d != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/748", "requirement": "def capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to insert spaces before each uppercase letter in a given string that starts a new word, except when the uppercase letter is the very first character of the entire string. This means spaces are added between words starting with capital letters, treating consecutive uppercase letters as part of a single word unless they clearly denote the start of a new word. The function should handle an empty string by returning an empty string without errors.\n\n    Examples:\n    assert capital_words_spaces(\"Python\") == 'Python'\n    assert capital_words_spaces(\"thisIsATestString\") == 'this Is A Test String'\n    assert capital_words_spaces(\"thisIsAnExampleOfTheFunction\") == 'this Is An Example Of The Function'\n    assert capital_words_spaces(\"NASAHeadquarters\") == 'NASA Headquarters'\n    \"\"\"", "generated_programs": ["import re\n\ndef capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return ''\n    return re.sub('([A-Z])', ' \\\\1', str1).lstrip()", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return ''\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return ''\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return str1\n    pattern = re.compile('(?<!^)([A-Z])')\n    return pattern.sub(' \\\\1', str1)", "def capital_words_spaces(str1: str) -> str:\n    result = ''\n    for i, char in enumerate(str1):\n        if char.isupper() and i != 0:\n            result += ' '\n        result += char\n    return result", "def capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return ''\n    result = str1[0]\n    for char in str1[1:]:\n        if char.isupper():\n            result += ' ' + char\n        else:\n            result += char\n    return result", "def capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return str1\n    result = str1[0]\n    for char in str1[1:]:\n        if char.isupper():\n            result += ' ' + char\n        else:\n            result += char\n    return result", "def capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return ''\n    result = str1[0]\n    for i in range(1, len(str1)):\n        if str1[i].isupper() and (not str1[i - 1].isspace()):\n            result += ' ' + str1[i]\n        else:\n            result += str1[i]\n    return result", "def capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return ''\n    result = str1[0]\n    for i in range(1, len(str1)):\n        if str1[i].isupper() and (not str1[i - 1].isspace()):\n            result += ' '\n        result += str1[i]\n    return result", "def capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return ''\n    result = ''\n    for i, char in enumerate(str1):\n        if char.isupper() and i != 0:\n            prev_char = str1[i - 1]\n            if not (prev_char.isupper() and (i + 1 < len(str1) and str1[i + 1].islower())):\n                result += ' '\n        result += char\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/759", "requirement": "def is_decimal(num: str) -> bool:\n    \"\"\"\n    Write a function to check whether a given string is a decimal number with exactly two decimal places.\n    assert is_decimal('123.11') == True\n    \"\"\"", "generated_programs": ["import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.match('^\\\\d+\\\\.\\\\d{2}$', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import List\n\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n\"\"\"\nWrite a python function to find the minimum difference between any two elements in a given array. \nassert find_min_diff((1,5,3,19,18,25),6) == 1\n\"\"\"", "generated_programs": ["from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr_sorted[i] - arr_sorted[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr_sorted[i] - arr_sorted[i - 1])\n    return min_diff", "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr_sorted[i] - arr_sorted[i - 1])\n    return min_diff"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.30000000000000004, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number. A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers. The sequence of polite numbers starts with 3, 5, 6, 7, 9, 10, 11, etc. Note that powers of two are not polite numbers.\n    \n    assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["def is_polite(n: int) -> int:\n    count = 0\n    num = 2\n    while count < n:\n        num += 1\n        if not num & num - 1 == 0:\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while True:\n        num += 1\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n    count = 0\n    num = 3\n    while True:\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num\n        num += 1", "import math\n\ndef is_polite(n: int) -> int:\n    count = 0\n    num = 2\n    while True:\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num\n        num += 1", "def is_polite(n: int) -> int:\n    count = 0\n    num = 2\n    while True:\n        num += 1\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n    count = 0\n    num = 2\n    while True:\n        num += 1\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n    polite_numbers = []\n    current = 2\n    while len(polite_numbers) < n:\n        current += 1\n        if current & current - 1 != 0:\n            polite_numbers.append(current)\n    return polite_numbers[-1]", "def is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while True:\n        num += 1\n        if num & num - 1 == 0:\n            continue\n        count += 1\n        if count == n:\n            return num", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x != 0 and x & x - 1 == 0\n    count = 0\n    num = 2\n    while True:\n        num += 1\n        if not is_power_of_two(num):\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n\n    def is_power_of_two(x):\n        return x != 0 and x & x - 1 == 0\n    count = 0\n    num = 2\n    while True:\n        if not is_power_of_two(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/771", "requirement": "def check_expression(expression: str) -> bool:\n    \"\"\"Check if the given expression containing brackets is balanced.\n    \n    A string with balanced brackets means that each opening bracket has a corresponding closing bracket of the same type and brackets are properly nested.\n    \n    assert check_expression(\"{()}[{}]\") == True\n    \"\"\"", "generated_programs": ["def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', ']': '[', '}': '{'}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or bracket_pairs[char] != stack.pop():\n                return False\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    stack = deque()\n    brackets = {'}': '{', ')': '(', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    brackets = {'(': ')', '{': '}', '[': ']'}\n    for char in expression:\n        if char in brackets:\n            stack.append(char)\n        elif char in brackets.values():\n            if not stack or brackets[stack.pop()] != char:\n                return False\n    return not stack", "def check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    stack = deque()\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    stack = deque()\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        elif char in mapping.values():\n            stack.append(char)\n    return not stack"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/780", "requirement": "def find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"Find all unique pairs of tuples from the given list and return a list of tuples where each tuple is the element-wise sum of the pairs.\n    \n    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            result.append(sum_tuple)\n    return result", "code\nfrom typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return sorted(combinations)", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return sorted(combinations)", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return sorted(combinations)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/782", "requirement": "def odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of the sums of all odd-length contiguous subarrays.\n    A subarray is considered odd-length if it contains an odd number of elements.\n    Iterate over all possible subarrays, check if their lengths are odd,\n    and if so, add their sums to the total sum.\n\n    assert odd_length_sum([1, 2, 4]) == 14\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n, 2):\n            total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n, 2):\n            total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 != 0:\n                total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr) + 1):\n            subarray = arr[i:j]\n            if len(subarray) % 2 != 0:\n                total += sum(subarray)\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += arr[j]\n            if (j - i + 1) % 2 == 1:\n                total += current_sum\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += arr[j]\n            if (j - i + 1) % 2 != 0:\n                total += current_sum\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += arr[j]\n            if (j - i + 1) % 2 == 1:\n                total += current_sum\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += arr[j]\n            if (j - i + 1) % 2 == 1:\n                total += current_sum\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += arr[j]\n            if (j - i + 1) % 2 == 1:\n                total_sum += current_sum\n    return total_sum", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += arr[j]\n            if (j - i + 1) % 2 == 1:\n                total += current_sum\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even and odd number in a given list.\n    If the list does not contain both an even and an odd number, return 0.\n    \n    assert mul_even_odd([1,3,5,7,4,1,6,8]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is not None and odd is not None:\n            break\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return even * odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    return even_num * odd_num if even_num is not None and odd_num is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    if even_num is not None and odd_num is not None:\n        return even_num * odd_num\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/790", "requirement": "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a Python function to check if the number at every even index is even in a given list.\n    \n    assert even_position([3, 2, 1]) == False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        if i % 2 == 0:\n            if nums[i] % 2 != 0:\n                return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n\"\"\"\nWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\nassert text_starta_endb(\"aabbbb\")\n\"\"\"", "generated_programs": ["import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a.*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = re.compile('^a.*b$')\n    return pattern.match(text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a.*b$'\n    return re.match(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/797", "requirement": "def sum_in_range(l: int, r: int) -> int:\n\"\"\"\nWrite a Python function to find the sum of all odd positive integers within the range [l, r].\nPositive integers start from 1. The function should ignore any negative numbers or zero in the range.\nassert sum_in_range(2,5) == 8\n\"\"\"", "generated_programs": ["def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(l, r + 1) if i > 0 and i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    return sum((i for i in range(max(1, l), r + 1) if i % 2 != 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/4", "requirement": "def heap_queue_largest(nums: list, n: int) -> list:\n    \"\"\"\n    Write a function to find the n largest integers from a given list of numbers and return them in strictly descending order.\n\n    assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    \"\"\"", "generated_programs": ["import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return heapq.nlargest(n, nums)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    if n <= 0:\n        return []\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    if not nums or n <= 0:\n        return []\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "import heapq\n\ndef heap_queue_largest(nums: list, n: int) -> list:\n    if not nums or n <= 0:\n        return []\n    largest = heapq.nlargest(n, nums)\n    return sorted(largest, reverse=True)"], "result": {"repaired_passk": 0.5, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/20", "requirement": "def is_woodall(num: int) -> bool:\n    \"\"\"Check if the given number is a Woodall number. A Woodall number is defined as a number of the form n * 2^n - 1, where n is a positive integer.\nassert is_woodall(383) == True\n\"\"\"", "generated_programs": ["def is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    if num < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1", "import math\n\ndef is_woodall(num: int) -> bool:\n    n = 1\n    while True:\n        woodall = n * 2 ** n - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/58", "requirement": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"Check if the two given 32-bit signed integers have opposite signs using bitwise operations.\n    \n    The function should return True if x and y have opposite signs, otherwise False.\n    This is achieved by performing a bitwise XOR on x and y, then checking if the 32nd bit (sign bit) is set.\n    \n    assert opposite_Signs(1, -2) == True\n    \n    ### Test 1\n    Input: [0, 5]\n    Expected Output: [False]\n    \n    ### Test 2\n    Input: [100, -100]\n    Expected Output: [True]\n    \"\"\"", "generated_programs": ["def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0", "def opposite_Signs(x: int, y: int) -> bool:\n    return x ^ y < 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/61", "requirement": "def count_Substrings(s: str) -> int:\n    \"\"\"Count the number of substrings where the sum of the digits equals the length of the substring.\n    \n    assert count_Substrings('112112') == 6\n    \"\"\"", "generated_programs": ["def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        total = 0\n        for j in range(i, len(s)):\n            total += int(s[j])\n            if total == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "code\n\ndef count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        current_sum = 0\n        for j in range(i, len(s)):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count", "def count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/84", "requirement": "def sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the Newman-Conway Sequence. \n    The function is defined for n >= 1. For n = 0, the function will raise an IndexError.\n    \n    assert sequence(10) == 6\n    \"\"\"", "generated_programs": ["def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = (1, 1)\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be at least 1')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be >= 1')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be >= 1')\n    if n == 1 or n == 2:\n        return 1\n    memo = [0] * (n + 1)\n    memo[1] = 1\n    memo[2] = 1\n    for i in range(3, n + 1):\n        memo[i] = memo[memo[i - 1]] + memo[i - memo[i - 1]]\n    return memo[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be >= 1')\n    if n in (1, 2):\n        return 1\n    memo = [0] * (n + 1)\n    memo[1], memo[2] = (1, 1)\n    for i in range(3, n + 1):\n        memo[i] = memo[memo[i - 1]] + memo[i - memo[i - 1]]\n    return memo[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be greater than or equal to 1')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be greater than or equal to 1')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = (1, 1)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be greater than or equal to 1')\n    if n == 1 or n == 2:\n        return 1\n    a = [0] * (n + 1)\n    a[1], a[2] = (1, 1)\n    for i in range(3, n + 1):\n        a[i] = a[a[i - 1]] + a[i - a[i - 1]]\n    return a[n]", "def sequence(n: int) -> int:\n    if n < 1:\n        raise IndexError('n must be greater than or equal to 1')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]", "def sequence(n: int) -> int:\n    if n == 0:\n        raise IndexError('n must be >= 1')\n    if n == 1 or n == 2:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    return dp[n]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n\"\"\"\nWrite a Python function to find the number of divisors of a given integer. \nFor non-positive integers (zero and negative numbers), the function should return 0.\nassert divisor(15) == 4\n\"\"\"", "generated_programs": ["def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "def divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "import math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/111", "requirement": "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the common elements that appear in all sublists within the given nested list.\n    If the input is an empty list of lists, the function should raise an IndexError.\n    \n    assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Input list is empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Input list is empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Input list is empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Input list is empty')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(set(sublist))\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('The input list is empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Input list of lists cannot be empty.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Input is an empty list of lists.')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)", "from typing import List\n\ndef common_in_nested_lists(nestedlist: List[List[int]]) -> List[int]:\n    if not nestedlist:\n        raise IndexError('Input is an empty list of lists')\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/123", "requirement": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to sum all amicable numbers up to, but not including, a specified number.\n\n    assert amicable_numbers_sum(999) == 504\n    \"\"\"", "generated_programs": ["def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        return sum((i for i in range(1, n) if n % i == 0))\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = int(math.sqrt(n))\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sum(divisors)\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n):\n        if n < 2:\n            return 0\n        total = 1\n        i = 2\n        while i * i <= n:\n            if n % i == 0:\n                if i == n // i:\n                    total += i\n                else:\n                    total += i + n // i\n            i += 1\n        return total\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = sum_of_proper_divisors(a)\n        if b != a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = int(math.sqrt(n))\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = sum_of_divisors(a)\n        if b != a and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "def amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        i = 2\n        while i * i <= n:\n            if n % i == 0:\n                if i == n // i:\n                    total += i\n                else:\n                    total += i + n // i\n            i += 1\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = math.isqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_proper_divisors(a)\n        if b != a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef get_proper_divisors(n: int) -> list:\n    divisors = {1}\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef sum_of_proper_divisors(n: int) -> int:\n    return sum(get_proper_divisors(n))\n\ndef amicable_numbers_sum(limit: int) -> int:\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = sum_of_proper_divisors(a)\n        if a != b and sum_of_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = math.isqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = sum_of_proper_divisors(a)\n        if b != a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "import math\n\ndef amicable_numbers_sum(limit: int) -> int:\n\n    def sum_of_proper_divisors(n: int) -> int:\n        if n < 2:\n            return 0\n        total = 1\n        sqrt_n = math.isqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_proper_divisors(a)\n        if b > a and sum_of_proper_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "Mbpp/124", "requirement": "def angle_complex(a: complex, b: complex) -> float:\n\"\"\"\nCalculate the angle of the direction from complex number `a` to complex number `b`.\nassert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n\"\"\"", "generated_programs": ["import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    delta = b - a\n    return cmath.phase(delta)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    diff = b - a\n    return cmath.phase(diff)", "import math\nimport cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    diff = b - a\n    return cmath.phase(diff)", "import math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    diff = b - a\n    return math.atan2(diff.imag, diff.real)", "import cmath\nimport math\n\ndef angle_complex(a: complex, b: complex) -> float:\n    delta = b - a\n    return cmath.phase(delta)", "import cmath\n\ndef angle_complex(a: complex, b: complex) -> float:\n    return cmath.phase(b - a)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/129", "requirement": "from typing import List\n\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to determine if the given matrix is a magic square.\n    A magic square is a square matrix where the sums of every row, column,\n    and both main diagonals are equal. The function should return False for\n    non-square matrices or empty matrices.\n    \n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    target = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target:\n        return False\n    return True", "code\nfrom typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix:\n        return False\n    n = len(my_matrix)\n    if any((len(row) != n for row in my_matrix)):\n        return False\n    target = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != target:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((row[col] for row in my_matrix)) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - i - 1] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    target = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    diagonal1 = sum((my_matrix[i][i] for i in range(n)))\n    diagonal2 = sum((my_matrix[i][n - i - 1] for i in range(n)))\n    return diagonal1 == magic_sum and diagonal2 == magic_sum", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    diag1 = sum((my_matrix[i][i] for i in range(n)))\n    diag2 = sum((my_matrix[i][n - i - 1] for i in range(n)))\n    return diag1 == target_sum and diag2 == target_sum", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or not all((len(row) == len(my_matrix) for row in my_matrix)):\n        return False\n    n = len(my_matrix)\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != target_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != target_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(n):\n        if sum((my_matrix[row][col] for row in range(n))) != magic_sum:\n            return False\n    if sum((my_matrix[i][i] for i in range(n))) != magic_sum:\n        return False\n    if sum((my_matrix[i][n - 1 - i] for i in range(n))) != magic_sum:\n        return False\n    return True", "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    if not my_matrix or len(my_matrix) != len(my_matrix[0]):\n        return False\n    n = len(my_matrix)\n    target_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        col_sum = sum((my_matrix[row][col] for row in range(n)))\n        if col_sum != target_sum:\n            return False\n    diag_sum = sum((my_matrix[i][i] for i in range(n)))\n    if diag_sum != target_sum:\n        return False\n    sec_diag_sum = sum((my_matrix[i][n - 1 - i] for i in range(n)))\n    if sec_diag_sum != target_sum:\n        return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/138", "requirement": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Write a Python function to check whether the given number can be represented as the sum of powers of two, \n    including \\(2^0\\). The function should return True if the number can be expressed as such a sum, and False otherwise.\n    \n    assert is_Sum_Of_Powers_Of_Two(10) == True\n    \"\"\"", "generated_programs": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') == 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') == 1", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return n & n - 1 == 0", "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    return bin(n).count('1') == 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/160", "requirement": "def find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    \"\"\"Finds and returns a pair of integers (x, y) such that ax + by = n, or None if no such integers exist.\n    \n    The function iterates over possible values of x and checks if there exists a corresponding integer y that satisfies the equation.\n    assert find_solution(2, 3, 7) == (2, 1)\n    \"\"\"", "generated_programs": ["from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        remainder = n - a * x\n        if remainder % b == 0:\n            y = remainder // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n // a + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None", "from typing import Union, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Union[Tuple[int, int], None]:\n    for x in range(n + 1):\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            if y >= 0:\n                return (x, y)\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/235", "requirement": "def even_bit_set_number(n: int) -> int:\n\"\"\"\nWrite a Python function that returns the given number without modifying it.\nThe term \"set all even bits\" in this context means to return the number as is, without changing any of its bits.\nassert even_bit_set_number(10) == 10\n\"\"\"", "generated_programs": ["def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n", "def even_bit_set_number(n: int) -> int:\n    return n"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/239", "requirement": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n,\n    where each element is a positive integer starting from 1 up to m, and each element (except the first) is at least\n    twice the previous element. The function should return the total number of such sequences.\n    \n    assert get_total_number_of_sequences(10, 4) == 4\n    \n    ### Test 1\n    Input: [7, 0]\n    Expected Output: [0]\n    \"\"\"", "generated_programs": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n\n    def count_sequences(current_length, last_element):\n        if current_length == n:\n            return 1\n        total = 0\n        for next_element in range(2 * last_element, m + 1):\n            total += count_sequences(current_length + 1, next_element)\n        return total\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(1, first_element)\n    return total_sequences", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum(dp[n][1:m + 1])", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum(dp[n][1:])", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum(dp[n][1:m + 1])", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum(dp[n][1:])", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    return sum((dp[n][i] for i in range(1, m + 1)))", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "from typing import List\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total", "def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 0\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = 0\n    for j in range(1, m + 1):\n        total += dp[n][j]\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.7}}
{"task_id": "Mbpp/244", "requirement": "def next_Perfect_Square(N: int) -> int:\n    \"\"\"\n    Write a python function to find the smallest perfect square that is not less than a given number.\n    \n    assert next_Perfect_Square(35) == 36\n    \n    ### Test 1\n    Input: [0]\n    Expected Output: [0]\n    \n    ### Test 2\n    Input: [0]\n    Expected Output: [0]\n    \"\"\"", "generated_programs": ["import math\n\ndef next_Perfect_Square(N: int) -> int:\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return N\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return N\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return N\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return N\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return N\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return N\n    else:\n        return (sqrt + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    root = math.isqrt(N)\n    if root * root == N:\n        return N\n    else:\n        return (root + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt_N = math.isqrt(N)\n    if sqrt_N * sqrt_N == N:\n        return N\n    else:\n        return (sqrt_N + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt_N = math.isqrt(N)\n    if sqrt_N * sqrt_N == N:\n        return N\n    else:\n        return (sqrt_N + 1) ** 2", "import math\n\ndef next_Perfect_Square(N: int) -> int:\n    if N < 0:\n        return 0\n    sqrt = math.isqrt(N)\n    if sqrt * sqrt == N:\n        return N\n    else:\n        return (sqrt + 1) ** 2"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/245", "requirement": "from typing import List\n\n\ndef max_sum(arr: List[int]) -> int:\n\"\"\"\nWrite a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.\nassert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    return max_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_val = 0\n    for i in range(n):\n        max_sum_val = max(max_sum_val, inc[i] + dec[i] - arr[i])\n    return max_sum_val", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_val = 0\n    for i in range(n):\n        max_sum_val = max(max_sum_val, inc[i] + dec[i] - arr[i])\n    return max_sum_val", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic = 0\n    for i in range(n):\n        max_bitonic = max(max_bitonic, inc[i] + dec[i] - arr[i])\n    return max_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_total = 0\n    for i in range(n):\n        max_total = max(max_total, inc[i] + dec[i] - arr[i])\n    return max_total", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    inc = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    dec = [0] * n\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    return max_sum", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_bitonic = 0\n    for i in range(n):\n        max_bitonic = max(max_bitonic, inc[i] + dec[i] - arr[i])\n    return max_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_bitonic = 0\n    for i in range(n):\n        if inc[i] + dec[i] - arr[i] > max_sum_bitonic:\n            max_sum_bitonic = inc[i] + dec[i] - arr[i]\n    return max_sum_bitonic", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_val = 0\n    for i in range(n):\n        max_sum_val = max(max_sum_val, inc[i] + dec[i] - arr[i])\n    return max_sum_val", "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    inc = [0] * n\n    dec = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    max_sum_val = 0\n    for i in range(n):\n        max_sum_val = max(max_sum_val, inc[i] + dec[i] - arr[i])\n    return max_sum_val"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/260", "requirement": "def newman_prime(n: int) -> int:\n\"\"\"\nWrite a function to find the nth Newman–Shanks–Williams (NSW) prime number. \nThe NSW numbers are generated using the recursive formula:\nS_i = 2 * S_{i-1}^2 - 1\nwhere S_0 = 1. The function should implement this formula iteratively to avoid recursion depth issues.\nIt should then check each NSW number to determine if it is prime, counting until it finds the nth prime in this sequence.\n\nassert newman_prime(3) == 7\n\"\"\"", "generated_programs": ["import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    count = 0\n    s = 1\n    while True:\n        if is_prime(s):\n            count += 1\n            if count == n:\n                return s\n        s = 2 * s ** 2 - 1", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n <= 0:\n        return 0\n    s = 1\n    count = 0\n    while True:\n        if is_prime(s):\n            count += 1\n            if count == n:\n                return s\n        s = 2 * s ** 2 - 1", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    s = [1, 1]\n    prime_count = 0\n    while prime_count < n:\n        next_s = 2 * s[-1] ** 2 - 1\n        s.append(next_s)\n        if is_prime(next_s):\n            prime_count += 1\n    return s[-1]", "import math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    count = 0\n    S_prev = 1\n    while True:\n        if is_prime(S_prev):\n            count += 1\n            if count == n:\n                return S_prev\n        S_prev = 2 * S_prev ** 2 - 1", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    s = [1]\n    count = 0\n    while True:\n        next_s = 2 * s[-1] ** 2 - 1\n        s.append(next_s)\n        if is_prime(next_s):\n            count += 1\n            if count == n:\n                return next_s", "def is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        return None\n    s0 = 1\n    count = 0\n    while True:\n        if is_prime(s0):\n            count += 1\n            if count == n:\n                return s0\n        s0 = 2 * s0 ** 2 - 1", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    s = [1]\n    count = 0\n    i = 1\n    while True:\n        s_next = 2 * s[i - 1] ** 2 - 1\n        s.append(s_next)\n        if is_prime(s_next):\n            count += 1\n            if count == n:\n                return s_next\n        i += 1", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    s = [1, 1]\n    prime_count = 0\n    while True:\n        next_s = 2 * s[-1] ** 2 - 1\n        s.append(next_s)\n        if is_prime(next_s):\n            prime_count += 1\n        if prime_count == n:\n            return next_s", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    s0 = 1\n    count = 0\n    i = 0\n    while count < n:\n        s_i = s0\n        s0 = 2 * s_i * s_i - 1\n        if is_prime(s0):\n            count += 1\n            if count == n:\n                return s0\n        i += 1\n    return -1", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be at least 1')\n    count = 0\n    S_prev = 1\n    while True:\n        if is_prime(S_prev):\n            count += 1\n            if count == n:\n                return S_prev\n        S_next = 2 * S_prev ** 2 - 1\n        S_prev = S_next"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.5, "original_passk": 0.0}}
{"task_id": "Mbpp/274", "requirement": "def even_binomial_Coeff_Sum(n: int) -> int:\n\"\"\"\nWrite a Python function that takes in a non-negative integer n and returns the sum of binomial coefficients at even indices from 0 to n inclusive.\nFor example, for n = 4, the binomial coefficients are [1, 4, 6, 4, 1], and the sum of coefficients at even indices (0, 2, 4) is 1 + 6 + 1 = 8.\nassert even_binomial_Coeff_Sum(4) == 8\n\"\"\"", "generated_programs": ["from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "import math\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((math.comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, i) for i in range(0, n + 1, 2)))", "from math import comb\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    return sum((comb(n, k) for k in range(0, n + 1, 2)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/290", "requirement": "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    \"\"\"\n    Write a function to find the list of maximum length in a list of lists.\n    The function returns a tuple containing the length of the longest sublist and the sublist itself.\n    \n    assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_sublist = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_sublist = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_list = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_list)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_sublist = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_sublist = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_sublist = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_sublist = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_sublist = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_sublist = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_sublist)", "from typing import List, Tuple\n\ndef max_length(list1: List[List]) -> Tuple[int, List]:\n    max_len = max((len(sublist) for sublist in list1))\n    max_sublist = next((sublist for sublist in list1 if len(sublist) == max_len))\n    return (max_len, max_sublist)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/301", "requirement": "def dict_depth(d: dict) -> int:\n\"\"\"\nWrite a function to find the depth of a dictionary.\nassert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4\n\"\"\"", "generated_programs": ["def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values())) if d else 1", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for v in d.values()))", "def dict_depth(d: dict) -> int:\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(v) for k, v in d.items()))", "def dict_depth(d: dict) -> int:\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "Mbpp/305", "requirement": "from typing import List\nfrom typing import Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return two words from a list of words starting with the letter 'p'.\n    If there are fewer than two such words, return the found words along with empty strings for the missing ones.\n    \n    The function should handle each string in the list by splitting it into individual words and checking\n    if they start with 'p' (case-insensitive). It should return a tuple containing the first two words\n    starting with 'p', or the found word and an empty string if only one word is found, or two empty strings\n    if no words are found.\n    \n    assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    if len(p_words) == 1:\n        return (p_words[0], '')\n    return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    return tuple(p_words) + ('',) * (2 - len(p_words))", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for sentence in words:\n        for word in sentence.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    return tuple(p_words) if p_words else ('', '') if len(p_words) == 1 else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    return tuple(p_words) if len(p_words) >= 1 else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    return tuple(p_words) if len(p_words) >= 1 else ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    while len(p_words) < 2:\n        p_words.append('')\n    return tuple(p_words[:2])", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    if len(p_words) == 1:\n        return (p_words[0], '')\n    elif len(p_words) == 2:\n        return (p_words[0], p_words[1])\n    else:\n        return ('', '')", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    if len(p_words) == 0:\n        return ('', '')\n    elif len(p_words) == 1:\n        return (p_words[0], '')\n    else:\n        return tuple(p_words[:2])", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    if len(p_words) == 1:\n        return (p_words[0], '')\n    elif len(p_words) == 0:\n        return ('', '')\n    else:\n        return tuple(p_words)", "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    if len(p_words) == 0:\n        return ('', '')\n    elif len(p_words) == 1:\n        return (p_words[0], '')\n    else:\n        return (p_words[0], p_words[1])"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/306", "requirement": "from typing import List\n\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n\"\"\"\nWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\nassert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11\n\"\"\"", "generated_programs": ["from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    return max(dp[index], dp[k])", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    if k > index:\n        return dp[index] + a[k]\n    else:\n        return dp[index]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        if i <= index and a[i] <= a[k]:\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] <= a[i] and i <= index:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n    return dp[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = dp[index]\n    for i in range(index + 1, k):\n        if a[i] > a[index]:\n            max_sum += a[i]\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        if i == 0:\n            dp[i] = a[i]\n        else:\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n    result = float('-inf')\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            result = max(result, dp[i] + a[k])\n    return result", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n        if i <= index:\n            for j in range(i):\n                if a[j] < a[i] and j <= index:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = dp[index]\n    for i in range(index + 1, k + 1):\n        if a[i] > a[index]:\n            max_sum += a[i]\n    return max_sum", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(n):\n        if i == 0:\n            dp[i] = a[i]\n        else:\n            dp[i] = a[i]\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = -1\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= n or k >= n or k <= index:\n        return 0\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    return max_sum + a[k]", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index >= n or k >= n or k <= index:\n        return 0\n    dp = [0] * n\n    dp[k] = a[k]\n    for i in range(index, -1, -1):\n        if a[i] < a[k]:\n            max_sum = 0\n            for j in range(i + 1, k):\n                if a[i] < a[j]:\n                    max_sum = max(max_sum, dp[j])\n            dp[i] = a[i] + max_sum\n        else:\n            dp[i] = a[i]\n    return max(dp[:index + 1])", "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    dp = [0] * n\n    for i in range(index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n    max_sum = dp[index]\n    if k > index:\n        for i in range(index + 1, k + 1):\n            dp[i] = a[i]\n            for j in range(i):\n                if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                    dp[i] = dp[j] + a[i]\n            if dp[i] > max_sum:\n                max_sum = dp[i]\n    return max_sum"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.09999999999999998, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/308", "requirement": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    If there are fewer than N unique products, return as many as possible. If N is 0, return an empty list.\n    \n    Parameters:\n    - nums1: List[int] - The first list of integers.\n    - nums2: List[int] - The second list of integers.\n    - N: int - The number of largest products to return.\n    \n    Returns:\n    - List[int] - A list containing the largest products, sorted in descending order.\n    \n    Examples:\n    assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    assert large_product([1, 2, 3], [4, 5, 6], 0) == []\n    \"\"\"", "generated_programs": ["from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    unique_products = sorted(list(set(products)), reverse=True)\n    return unique_products[:min(N, len(unique_products))]", "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            products.add(num1 * num2)\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:min(N, len(sorted_products))]", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    unique_products = list(set(products))\n    heapq.heapify(unique_products)\n    result = []\n    while unique_products and len(result) < N:\n        result.append(-heapq.heappop(unique_products))\n    return sorted(result, reverse=True)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for i in nums1:\n        for j in nums2:\n            products.append(-(i * j))\n    unique_products = list(set(products))\n    if len(unique_products) < N:\n        N = len(unique_products)\n    heapq.heapify(unique_products)\n    largest = []\n    for _ in range(N):\n        largest.append(-heapq.heappop(unique_products))\n    return largest", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-num1 * num2)\n    unique_products = list(set(products))\n    heapq.heapify(unique_products)\n    result = []\n    for _ in range(min(N, len(unique_products))):\n        result.append(-heapq.heappop(unique_products))\n    return sorted(result, reverse=True)", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    heap = []\n    unique_products = set()\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            if product not in unique_products:\n                unique_products.add(product)\n                heapq.heappush(heap, product)\n                if len(heap) > N:\n                    heapq.heappop(heap)\n    heap.sort(reverse=True)\n    return heap", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    heapq.heapify(products)\n    unique_products = set()\n    result = []\n    while products and len(result) < N:\n        product = -heapq.heappop(products)\n        if product not in unique_products:\n            unique_products.add(product)\n            result.append(product)\n    return result", "code\nfrom typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    unique_products = sorted(set(products))\n    heapq.heapify(unique_products)\n    result = []\n    while unique_products and len(result) < N:\n        product = -heapq.heappop(unique_products)\n        result.append(product)\n    return result", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    heapq.heapify(products)\n    unique_products = []\n    prev = None\n    while len(unique_products) < N and products:\n        current = -heapq.heappop(products)\n        if current != prev:\n            unique_products.append(current)\n            prev = current\n    return unique_products", "from typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    if N == 0:\n        return []\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(-(num1 * num2))\n    unique_products = sorted(set(products))\n    if len(unique_products) < N:\n        return sorted([-x for x in unique_products], reverse=True)\n    heapq.heapify(unique_products)\n    largest = []\n    for _ in range(N):\n        largest.append(-heapq.heappop(unique_products))\n    return largest"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/310", "requirement": "def string_to_tuple(str1: str) -> tuple:\n\"\"\"\nWrite a function to convert a given string to a tuple of characters, excluding spaces.\nSpaces in the input string should be ignored during the conversion.\nassert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n\"\"\"", "generated_programs": ["def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))", "def string_to_tuple(str1: str) -> tuple:\n    return tuple((char for char in str1 if char != ' '))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/311", "requirement": "def set_left_most_unset_bit(n: int) -> int:\n\"\"\"\nWrite a python function to set the left most unset bit.\nassert set_left_most_unset_bit(10) == 14\n\"\"\"", "generated_programs": ["def set_left_most_unset_bit(n: int) -> int:\n    unset_bit = ~n & n + 1\n    return n | unset_bit", "def set_left_most_unset_bit(n: int) -> int:\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while n & mask != 0:\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    unset_bit = ~n\n    leftmost_unset = unset_bit & -unset_bit\n    return n | leftmost_unset", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    bit = 1\n    while bit <= n:\n        if n & bit == 0:\n            return n | bit\n        bit <<= 1\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    unset_bit = ~n\n    left_most_unset = unset_bit.bit_length() - 1\n    return n | 1 << left_most_unset", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    mask = 1\n    while mask <= n:\n        if n & mask == 0:\n            return n | mask\n        mask <<= 1\n    return n | mask", "def set_left_most_unset_bit(n: int) -> int:\n    if n == 0:\n        return 1\n    unset_bit = ~n\n    left_most_unset = unset_bit & unset_bit - 1\n    left_most_unset = left_most_unset ^ unset_bit\n    return n | left_most_unset"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/427", "requirement": "def change_date_format(dt: str) -> str:\n\"\"\"\nWrite a function to convert a date from \"yyyy-mm-dd\" format to \"dd-mm-yyyy\" format. \nThe function should validate the input date and raise a ValueError if the date is invalid.\nassert change_date_format(\"2026-01-02\") == '02-01-2026'\n\"\"\"", "generated_programs": ["from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')", "from datetime import datetime\n\ndef change_date_format(dt: str) -> str:\n    try:\n        date_obj = datetime.strptime(dt, '%Y-%m-%d')\n        return date_obj.strftime('%d-%m-%Y')\n    except ValueError:\n        raise ValueError('Invalid date format')"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/430", "requirement": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"Calculate the directrix of a parabola given its coefficients a, b, and c.\n    \n    The directrix is calculated using the formula: c - (b^2 + 1) * 4 * a.\n    \n    assert parabola_directrix(5,3,2)==-198\n    \"\"\"", "generated_programs": ["def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a", "def parabola_directrix(a: int, b: int, c: int) -> int:\n    return c - (b ** 2 + 1) * 4 * a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/448", "requirement": "def cal_sum(n: int) -> int:\n\"\"\"\nWrite a function to calculate the sum of perrin numbers.\nassert cal_sum(9) == 49\n\"\"\"", "generated_programs": ["def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 3, 5]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p)", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [3, 0, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p)", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    p = [2, 3, 2]\n    for i in range(3, n + 1):\n        p.append(p[i - 2] + p[i - 3])\n    return sum(p)", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    p = [0] * (n + 1)\n    p[0], p[1], p[2] = (3, 0, 2)\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n + 1])", "def cal_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    p = [0] * (n + 1)\n    p[0], p[1], p[2] = (3, 0, 2)\n    for i in range(3, n + 1):\n        p[i] = p[i - 2] + p[i - 3]\n    return sum(p[:n])"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.09999999999999998, "original_passk": 0.0}}
{"task_id": "Mbpp/453", "requirement": "def sumofFactors(n: int) -> int:\n    \"\"\"Calculate the sum of all even factors of a given number.\n    \n    The function should return 0 if the number is odd, as it has no even factors.\n    The sum includes only the even factors of the number.\n    \n    assert sumofFactors(18) == 26\n    \"\"\"", "generated_programs": ["def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    sum_even = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even += i\n    return sum_even", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    sum_factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_factors += i\n    return sum_factors", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    sum_even = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even += i\n    return sum_even", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    total = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                total += i\n            if n // i != i and n // i % 2 == 0:\n                total += n // i\n    return total", "def sumofFactors(n: int) -> int:\n    if n % 2 != 0:\n        return 0\n    factors = set()\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                factors.add(i)\n            if n // i % 2 == 0:\n                factors.add(n // i)\n    return sum(factors)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/454", "requirement": "def text_match_wordz(text: str) -> bool:\n\"\"\"\nWrite a function that checks if the letter 'z' is present anywhere in the input string.\nassert text_match_wordz(\"pythonz.\") == True\n\"\"\"", "generated_programs": ["def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text", "def text_match_wordz(text: str) -> bool:\n    return 'z' in text"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "Mbpp/462", "requirement": "from typing import List\n\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"", "generated_programs": ["from itertools import combinations\nfrom typing import List\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            all_combinations.append(list(combo))\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for i in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, i)])\n    return result", "from typing import List\nfrom itertools import combinations as comb\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        for combination in comb(lst, r):\n            result.append(list(combination))\n    return result", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend([list(comb) for comb in combinations(lst, r)])\n    return all_combinations", "from typing import List\nfrom itertools import combinations\n\ndef combinations_list(lst: List[int]) -> List[List[int]]:\n    result = []\n    for r in range(len(lst) + 1):\n        result.extend([list(comb) for comb in combinations(lst, r)])\n    return sorted(result, key=lambda x: (len(x), x))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/468", "requirement": "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product formed by multiplying numbers of a contiguous increasing subsequence of that array.\n    A contiguous increasing subsequence is defined as a sequence where each element is greater than the previous one and they are consecutive in the original array.\n    Single-element subsequences are considered valid and their product is the element itself.\n    \n    assert max_product([3, 100, 4, 5, 150, 6]) == 3000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            current_prod = arr[i]\n        if current_prod > max_prod:\n            max_prod = current_prod\n    return max_prod", "code\nfrom typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            current_prod = arr[i]\n        max_prod = max(max_prod, current_prod)\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            current_prod = arr[i]\n        if current_prod > max_prod:\n            max_prod = current_prod\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            current_prod = arr[i]\n        if current_prod > max_prod:\n            max_prod = current_prod\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            current_prod = arr[i]\n        max_prod = max(max_prod, current_prod)\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            current_prod = arr[i]\n        if current_prod > max_prod:\n            max_prod = current_prod\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            current_prod = arr[i]\n        max_prod = max(max_prod, current_prod)\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            current_prod = arr[i]\n        if current_prod > max_prod:\n            max_prod = current_prod\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            current_prod = arr[i]\n        if current_prod > max_prod:\n            max_prod = current_prod\n    return max_prod", "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    current_prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_prod *= arr[i]\n        else:\n            current_prod = arr[i]\n        if current_prod > max_prod:\n            max_prod = current_prod\n    return max_prod"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/555", "requirement": "def difference(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers. The function assumes that n is a positive integer. For non-positive integers, the function returns 0.\n\n    assert difference(3) == 30\n    \"\"\"", "generated_programs": ["def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_cubes = sum((i ** 3 for i in range(1, n + 1)))\n    sum_natural = sum((i for i in range(1, n + 1)))\n    return sum_cubes - sum_natural", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_n = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_n = n * (n + 1) // 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return sum_of_cubes - sum_of_numbers", "def difference(n: int) -> int:\n    if n <= 0:\n        return 0\n    sum_of_numbers = n * (n + 1) // 2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    return abs(sum_of_cubes - sum_of_numbers)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/564", "requirement": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Write a Python function which takes a list of integers and counts the number of possible unordered pairs \n    (i, j) where i < j and the elements at these positions are not equal.\n    \n    assert count_Pairs([1, 2, 1], 3) == 2\n    \"\"\"", "generated_programs": ["from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for a, b in combinations(arr, 2) if a != b))", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for i, j in combinations(arr, 2) if i != j))", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return len([(i, j) for i, j in combinations(range(n), 2) if arr[i] != arr[j]])", "from typing import List\nfrom itertools import combinations\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    return sum((1 for i, j in combinations(range(n), 2) if arr[i] != arr[j]))", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count", "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/573", "requirement": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Write a Python function to calculate the product of the unique numbers in a given list.\n    The product of an empty list is defined as 1.\n    The presence of zero in the list results in a product of zero.\n    Negative numbers are included in the calculation and handled according to standard multiplication rules.\n    \n    assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = list(set(list_data))\n    if not unique_numbers:\n        return 1\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    if not list_data:\n        return 1\n    if 0 in list_data:\n        return 0\n    unique_numbers = list(set(list_data))\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    if not list_data:\n        return 1\n    unique_numbers = set(list_data)\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    if not list_data:\n        return 1\n    unique_nums = set(list_data)\n    if 0 in unique_nums:\n        return 0\n    product = 1\n    for num in unique_nums:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if not unique_numbers:\n        return 1\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if not unique_numbers:\n        return 1\n    if 0 in unique_numbers:\n        return 0\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "from typing import List\nfrom functools import reduce\nfrom operator import mul\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if not unique_numbers:\n        return 1\n    if 0 in unique_numbers:\n        return 0\n    return reduce(mul, unique_numbers)", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    if not list_data:\n        return 1\n    unique_nums = set(list_data)\n    if 0 in unique_nums:\n        return 0\n    product = 1\n    for num in unique_nums:\n        product *= num\n    return product", "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    unique_numbers = set(list_data)\n    if not unique_numbers:\n        return 1\n    product = 1\n    for num in unique_numbers:\n        if num == 0:\n            return 0\n        product *= num\n    return product"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/580", "requirement": "def extract_even(test_tuple: tuple) -> tuple:\n\"\"\"\nWrite a function to remove uneven elements in the nested mixed tuple.\nassert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n\"\"\"", "generated_programs": ["def extract_even(test_tuple: tuple) -> tuple:\n    if not isinstance(test_tuple, tuple):\n        return test_tuple if test_tuple % 2 == 0 else None\n    result = tuple((item for item in (extract_even(element) for element in test_tuple) if item is not None))\n    return result", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for element in test_tuple:\n        if isinstance(element, tuple):\n            result.append(extract_even(element))\n        elif isinstance(element, int) and element % 2 == 0:\n            result.append(element)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    result = []\n    for element in test_tuple:\n        if isinstance(element, tuple):\n            result.append(extract_even(element))\n        elif isinstance(element, int) and element % 2 == 0:\n            result.append(element)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n    if not isinstance(test_tuple, tuple):\n        return test_tuple if isinstance(test_tuple, int) and test_tuple % 2 == 0 else None\n    result = []\n    for item in test_tuple:\n        extracted = extract_even(item)\n        if extracted is not None:\n            result.append(extracted)\n    return tuple(result)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def even_filter(t):\n        if isinstance(t, tuple):\n            return tuple((even_filter(x) for x in t if isinstance(x, int) and x % 2 == 0 or isinstance(x, tuple)))\n        return t if t % 2 == 0 else None\n    return tuple((x for x in even_filter(test_tuple) if x is not None))", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def is_even(x):\n        return isinstance(x, int) and x % 2 == 0\n\n    def filter_even(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                filtered = filter_even(item)\n                if filtered:\n                    result.append(filtered)\n            elif is_even(item):\n                result.append(item)\n        return tuple(result)\n    return filter_even(test_tuple)", "def extract_even(test_tuple: tuple) -> tuple:\n\n    def _extract_even_helper(t):\n        if isinstance(t, tuple):\n            return tuple((_extract_even_helper(x) for x in t if isinstance(x, int) and x % 2 == 0 or isinstance(x, tuple)))\n        else:\n            return t if t % 2 == 0 else None\n    result = _extract_even_helper(test_tuple)\n    return tuple((x for x in result if x is not None))"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/581", "requirement": "def surface_Area(b: float, s: float) -> float:\n\"\"\"\nWrite a Python function to find the surface area of a square pyramid with a given base edge and slant height.\nThe surface area is calculated using the formula: Surface Area = b^2 + 2bs, where b is the base edge and s is the slant height.\nassert surface_Area(3,4) == 33\n\"\"\"", "generated_programs": ["def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s", "def surface_Area(b: float, s: float) -> float:\n    return b ** 2 + 2 * b * s"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/590", "requirement": "from typing import Tuple\n\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n\"\"\"\nWrite a function to convert polar coordinates to rectangular coordinates.\nassert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n\"\"\"", "generated_programs": ["from typing import Tuple\nimport cmath\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    z = cmath.rect(r, theta)\n    return ((abs(z), cmath.phase(z)), z)", "import math\nimport cmath\nfrom typing import Tuple\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    z = cmath.rect(r, theta)\n    return ((math.hypot(x, y), theta), z)", "import math\nfrom typing import Tuple\nimport cmath\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.hypot(x, y)\n    theta = math.atan2(y, x)\n    rect = cmath.rect(r, theta)\n    return ((r, theta), rect)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(x: float, y: float) -> Tuple[Tuple[float, float], complex]:\n    r = math.hypot(x, y)\n    theta = math.atan2(y, x)\n    rect = cmath.rect(r, theta)\n    return ((r, theta), rect)", "from typing import Tuple\nimport cmath\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * cmath.cos(theta)\n    y = r * cmath.sin(theta)\n    magnitude = abs(complex(x, y))\n    angle = cmath.phase(complex(x, y))\n    return ((magnitude, angle), complex(x, y))", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_coords = (r, theta)\n    complex_num = complex(x, y)\n    return (rect_coords, complex_num)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    z = complex(x, y)\n    polar_form = (math.sqrt(x ** 2 + y ** 2), math.atan2(y, x))\n    return (polar_form, z)", "from typing import Tuple\nimport cmath\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * cmath.cos(theta)\n    y = r * cmath.sin(theta)\n    magnitude = abs(complex(x, y))\n    angle = cmath.phase(complex(x, y))\n    return ((magnitude, angle), x + y * 1j)", "from typing import Tuple\nimport cmath\nimport math\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    complex_num = complex(x, y)\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    angle = math.atan2(y, x)\n    return ((magnitude, angle), complex_num)", "from typing import Tuple\nimport math\nimport cmath\n\ndef polar_rect(r: float, theta: float) -> Tuple[Tuple[float, float], complex]:\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    rect_coords = (math.sqrt(x ** 2 + y ** 2), math.atan2(y, x))\n    complex_num = cmath.rect(r, theta)\n    return (rect_coords, complex_num)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/594", "requirement": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the difference between the first even and the first odd number in a given list.\n    If the list does not contain both an even and an odd number, return 0.\n    \n    assert diff_even_odd([1,3,5,7,4,1,6,8]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        elif odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even - odd if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even - odd if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even - odd if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    if even is not None and odd is not None:\n        return abs(even - odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even - odd if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return abs(even - odd) if even is not None and odd is not None else 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return abs(first_even - first_odd)\n    else:\n        return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return abs(first_even - first_odd)\n    return 0", "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is None or first_odd is None:\n        return 0\n    return abs(first_even - first_odd)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.4, "original_passk": 1.0}}
{"task_id": "Mbpp/597", "requirement": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the kth smallest element from the given two sorted arrays.\n    If the kth element does not exist (e.g., when k is larger than the total number of elements in both arrays),\n    the function should return None.\n    \n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2):\n        return None\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2):\n        return None\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    i, j = (0, 0)\n    merged = []\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    if k > len(merged):\n        return None\n    return merged[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2):\n        return None\n    i, j = (0, 0)\n    result = []\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n    result.extend(arr1[i:])\n    result.extend(arr2[j:])\n    return result[k - 1]", "from typing import List, Optional\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> Optional[int]:\n    if k > len(arr1) + len(arr2):\n        return None\n    i, j = (0, 0)\n    result = []\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        result.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        result.append(arr2[j])\n        j += 1\n    return result[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2):\n        return None\n    i, j = (0, 0)\n    result = []\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        result.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        result.append(arr2[j])\n        j += 1\n    return result[k - 1]", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    i, j, count = (0, 0, 0)\n    result = None\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            result = arr1[i]\n            i += 1\n        else:\n            result = arr2[j]\n            j += 1\n        count += 1\n        if count == k:\n            return result\n    while i < len(arr1):\n        result = arr1[i]\n        i += 1\n        count += 1\n        if count == k:\n            return result\n    while j < len(arr2):\n        result = arr2[j]\n        j += 1\n        count += 1\n        if count == k:\n            return result\n    return None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2):\n        return None\n    i, j = (0, 0)\n    count = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == k:\n                return arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return arr2[j]\n            j += 1\n    while i < len(arr1):\n        count += 1\n        if count == k:\n            return arr1[i]\n        i += 1\n    while j < len(arr2):\n        count += 1\n        if count == k:\n            return arr2[j]\n        j += 1\n    return None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2):\n        return None\n    i, j, count = (0, 0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == k:\n                return arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return arr2[j]\n            j += 1\n    while i < len(arr1):\n        count += 1\n        if count == k:\n            return arr1[i]\n        i += 1\n    while j < len(arr2):\n        count += 1\n        if count == k:\n            return arr2[j]\n        j += 1\n    return None", "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if k > len(arr1) + len(arr2):\n        return None\n    i, j, count = (0, 0, 0)\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == k:\n                return arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return arr2[j]\n            j += 1\n    while i < len(arr1):\n        count += 1\n        if count == k:\n            return arr1[i]\n        i += 1\n    while j < len(arr2):\n        count += 1\n        if count == k:\n            return arr2[j]\n        j += 1\n    return None"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "Mbpp/607", "requirement": "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Write a function to search a string for a regex pattern. The function should return the matching substring, a start index, and an end index.\n    The end index is exclusive, meaning it points to the position immediately after the last character of the match.\n    \n    assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n    \"\"\"", "generated_programs": ["from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None", "from typing import Tuple, Optional\nimport re\n\ndef find_literals(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/610", "requirement": "from typing import List\n\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a Python function which takes a list and an integer k, and returns a list with the same elements except for the first occurrence of the element with the value k removed.\n    \n    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 2, 4, 4, 5, 1]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        index = list1.index(k)\n        return list1[:index] + list1[index + 1:]\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        index = list1.index(k)\n        return list1[:index] + list1[index + 1:]\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        index = list1.index(k)\n        return list1[:index] + list1[index + 1:]\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        index = list1.index(k)\n        return list1[:index] + list1[index + 1:]\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        index = list1.index(k)\n        return list1[:index] + list1[index + 1:]\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        index = list1.index(k)\n        return list1[:index] + list1[index + 1:]\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        index = list1.index(k)\n        return list1[:index] + list1[index + 1:]\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        index = list1.index(k)\n        return list1[:index] + list1[index + 1:]\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    if k in list1:\n        index = list1.index(k)\n        return list1[:index] + list1[index + 1:]\n    return list1", "from typing import List\n\ndef remove_kth_element(list1: List[int], k: int) -> List[int]:\n    try:\n        index = list1.index(k)\n        return list1[:index] + list1[index + 1:]\n    except ValueError:\n        return list1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "Mbpp/612", "requirement": "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a Python function which takes a list of lists and returns a list of lists where each sublist contains elements from the same position in the original sublists. \n    If the sublists are of uneven lengths, the resulting sublists will be truncated to the length of the shortest sublist.\n    \n    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    min_length = min((len(sublist) for sublist in lst))\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    min_length = min((len(sublist) for sublist in lst)) if lst else 0\n    return [list(elements) for elements in zip(*(sublist[:min_length] for sublist in lst))]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    min_length = min((len(sublist) for sublist in lst)) if lst else 0\n    return [list(elements) for elements in zip(*[sublist[:min_length] for sublist in lst])]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    min_length = min((len(sublist) for sublist in lst)) if lst else 0\n    return [list(elements) for elements in zip(*[sublist[:min_length] for sublist in lst])]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    min_length = min((len(sublist) for sublist in lst)) if lst else 0\n    return [list(t) for t in zip(*[sublist[:min_length] for sublist in lst])]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    min_length = min((len(sublist) for sublist in lst)) if lst else 0\n    return [[sublist[i] for sublist in lst] for i in range(min_length)]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    min_length = min((len(sublist) for sublist in lst)) if lst else 0\n    return [list(items) for items in zip(*[sublist[:min_length] for sublist in lst])]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    if not lst:\n        return []\n    min_length = min((len(sublist) for sublist in lst))\n    result = [[] for _ in range(min_length)]\n    for i in range(min_length):\n        for sublist in lst:\n            result[i].append(sublist[i])\n    return result", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    min_length = min((len(sublist) for sublist in lst)) if lst else 0\n    return [list(x) for x in zip(*[sublist[:min_length] for sublist in lst])]", "from typing import List\n\ndef merge(lst: List[List[int]]) -> List[List[int]]:\n    min_length = min((len(sublist) for sublist in lst)) if lst else 0\n    return [list(elements) for elements in zip(*[sublist[:min_length] for sublist in lst])]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/615", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    \"\"\"\n    Write a function which takes a tuple of tuples and returns the average value for each corresponding element across the inner tuples as a list.\n    \n    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(x) / len(x) for x in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(x) / len(x) for x in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(elements) / len(elements) for elements in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(column) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(col) / len(col) for col in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(column) / len(nums) for column in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(x) / len(x) for x in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    return [sum(x) / len(x) for x in zip(*nums)]", "from typing import List, Tuple\n\ndef average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[float]:\n    num_tuples = len(nums)\n    num_elements = len(nums[0]) if num_tuples > 0 else 0\n    averages = [0.0] * num_elements\n    for i in range(num_elements):\n        for j in range(num_tuples):\n            averages[i] += nums[j][i]\n        averages[i] /= num_tuples\n    return averages"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/622", "requirement": "def get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    \"\"\"Find the median of two sorted lists of the same size by merging them and selecting the middle elements.\n    \n    The function should merge the two input lists, sort the merged list, and then calculate the median by averaging the nth and (n-1)th elements of the sorted list.\n    \n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n] + merged[n - 1]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2.0", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n] + merged[n - 1]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n] + merged[n - 1]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n] + merged[n - 1]) / 2", "from typing import List\n\ndef get_median(nums1: List[int], nums2: List[int], n: int) -> float:\n    merged = sorted(nums1 + nums2)\n    return (merged[n - 1] + merged[n]) / 2.0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/626", "requirement": "def triangle_area(radius: float) -> float:\n    \"\"\"\n    Write a Python function to find the area of the largest equilateral triangle that can be inscribed in a semicircle with a given radius.\n    The function should return None if the radius is less than or equal to zero.\n    \n    assert triangle_area(-1) == None\n    \n    ### Test 1\n    Input: [5.0]\n    Expected Output: [10.825317547305483]\n    \n    ### Test 2\n    Input: [5.0]\n    Expected Output: [10.825317547305483]\n    \n    ### Test 3\n    Input: [0.0]\n    Expected Output: [None]\n    \"\"\"", "generated_programs": ["import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side = 2 * radius * math.sin(math.pi / 3)\n    area = math.sqrt(3) / 4 * side ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = 2 * radius * math.sin(math.pi / 3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = 2 * radius * math.sqrt(3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = 2 * radius * math.sin(math.radians(60))\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = 2 * radius * math.sin(math.pi / 3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = 2 * radius * math.sin(math.radians(60))\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = 2 * radius * math.sin(math.radians(60))\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = 2 * radius * math.sin(math.pi / 3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = 2 * radius * math.sin(math.pi / 3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area", "import math\n\ndef triangle_area(radius: float) -> float:\n    if radius <= 0:\n        return None\n    side_length = radius * 2 * math.sin(math.pi / 3)\n    area = math.sqrt(3) / 4 * side_length ** 2\n    return area"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "Mbpp/638", "requirement": "def wind_chill(v: float, t: float) -> int:\n\"\"\"\nWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\nassert wind_chill(120,35)==40\n\"\"\"", "generated_programs": ["import math\n\ndef wind_chill(v: float, t: float) -> int:\n    return math.ceil(13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "code\nimport math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return int(math.ceil(wci))", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wc = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wc)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return math.ceil(wci) if wci % 1 != 0 else int(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci) if wci != int(wci) else int(wci)", "import math\n\ndef wind_chill(v: float, t: float) -> int:\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci) if wci != math.ceil(wci) else math.ceil(wci)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/643", "requirement": "def text_match_wordz_middle(text: str) -> bool:\n\"\"\"\nWrite a function that checks if a string contains 'z', except when 'z' is at the start or end of a word.\nA 'z' is considered to be in the middle of a word if it is not the first or last character of any word in the string.\nWords are defined as sequences of alphanumeric characters.\n\nExamples:\nassert text_match_wordz_middle(\"pythonzabc.\") == True\nassert text_match_wordz_middle(\"zpythonabc.\") == False\nassert text_match_wordz_middle(\"z\") == True\n\"\"\"", "generated_programs": ["import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\w+', text)\n    for word in words:\n        if 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\w+', text)\n    for word in words:\n        for i in range(1, len(word) - 1):\n            if word[i] == 'z':\n                return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if len(word) > 1 and 'z' in word[1:-1]:\n            return True\n    return False", "def text_match_wordz_middle(text: str) -> bool:\n    import re\n    words = re.findall('\\\\w+', text)\n    for word in words:\n        for i in range(1, len(word) - 1):\n            if word[i] == 'z':\n                return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\w+', text)\n    for word in words:\n        if len(word) < 2:\n            continue\n        for i in range(1, len(word) - 1):\n            if word[i] == 'z':\n                return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        if len(word) < 2:\n            continue\n        if 'z' in word[1:-1]:\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\w+', text)\n    for word in words:\n        if len(word) >= 3:\n            if 'z' in word[1:-1]:\n                return True\n        elif len(word) == 1 and word == 'z':\n            return True\n    return False", "import re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        z_indices = [i for i, char in enumerate(word) if char == 'z']\n        for index in z_indices:\n            if index != 0 and index != len(word) - 1:\n                return True\n    return False", "code\nimport re\n\ndef text_match_wordz_middle(text: str) -> bool:\n    words = re.findall('\\\\b\\\\w+\\\\b', text)\n    for word in words:\n        z_indices = [i for i, char in enumerate(word) if char.lower() == 'z']\n        for idx in z_indices:\n            if idx != 0 and idx != len(word) - 1:\n                return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/722", "requirement": "from typing import Dict\nfrom typing import Tuple\n\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    \"\"\"\n    The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight greater than or equal to the minimum values.\n    \n    assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)},6.0,70)=={'Cierra Vega': (6.2, 70)}\n    \"\"\"", "generated_programs": ["from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}", "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, float]], h: float, w: float) -> Dict[str, Tuple[float, float]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.6}}
{"task_id": "Mbpp/734", "requirement": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to find the sum of products of all possible contiguous subarrays of a given list.\n    \n    A contiguous subarray is defined as a sequence of consecutive elements from the array.\n    \n    Parameters:\n    arr (List[int]): The input list of integers.\n    \n    Returns:\n    int: The sum of products of all contiguous subarrays.\n    \n    Example:\n    >>> sum_Of_Subarray_Prod([1,2,3])\n    20\n    \n    For the input [1, 2, 3], the contiguous subarrays are [1], [2], [3], [1, 2], [2, 3], and [1, 2, 3].\n    Their products are 1, 2, 3, 2, 6, and 6 respectively, summing up to 20.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        prod = 1\n        for j in range(i, n):\n            prod *= arr[j]\n            total += prod\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum", "from typing import List\nfrom functools import reduce\nfrom operator import mul\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total += product\n    return total", "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= arr[j]\n            total_sum += current_product\n    return total_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/739", "requirement": "def find_Index(n: int) -> int:\n    \"\"\"\n    Write a Python function to find the index of the first triangular number that has at least n digits.\n    \n    A triangular number is a number that can be arranged in the shape of an equilateral triangle. \n    The nth triangular number is the sum of the first n natural numbers, i.e., T(n) = n * (n + 1) / 2.\n    \n    Parameters:\n    n (int): The minimum number of digits the triangular number should have.\n    \n    Returns:\n    int: The index of the first triangular number that has at least n digits.\n    \n    Examples:\n    assert find_Index(2) == 4\n    assert find_Index(3) == 14\n    assert find_Index(0) == 1\n    \"\"\"", "generated_programs": ["code\nimport math\n\ndef find_Index(n: int) -> int:\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if len(str(triangular_number)) >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_num = index * (index + 1) // 2\n        if len(str(triangular_num)) >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if triangular_number >= 10 ** (n - 1):\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    digits = 0\n    index = 0\n    while digits < n:\n        index += 1\n        triangular = index * (index + 1) // 2\n        digits = len(str(triangular))\n    return index", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_num = index * (index + 1) // 2\n        if math.floor(math.log10(triangular_num)) + 1 >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_num = index * (index + 1) // 2\n        if triangular_num == 0:\n            num_digits = 1\n        else:\n            num_digits = math.floor(math.log10(triangular_num)) + 1\n        if num_digits >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if triangular_number == 0:\n            num_digits = 1\n        else:\n            num_digits = int(math.log10(triangular_number)) + 1\n        if num_digits >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if triangular_number == 0:\n            num_digits = 1\n        else:\n            num_digits = int(math.log10(triangular_number)) + 1\n        if num_digits >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_number = index * (index + 1) // 2\n        if triangular_number == 0:\n            num_digits = 1\n        else:\n            num_digits = int(math.log10(triangular_number)) + 1\n        if num_digits >= n:\n            return index\n        index += 1", "import math\n\ndef find_Index(n: int) -> int:\n    if n == 0:\n        return 1\n    index = 1\n    while True:\n        triangular_num = index * (index + 1) // 2\n        if triangular_num == 0:\n            num_digits = 1\n        else:\n            num_digits = int(math.log10(triangular_num)) + 1\n        if num_digits >= n:\n            return index\n        index += 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "Mbpp/745", "requirement": "from typing import List\n\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Write a function to find numbers within a given range from startnum to endnum (inclusive) \n    where every number is divisible by every non-zero digit it contains. \n    The function should only consider positive integers and raise a ValueError if any negative numbers are encountered.\n    The function should skip any number containing the digit zero.\n    \n    assert divisible_by_digits(1,22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        divisible = True\n        for digit in str(num):\n            if digit != '0' and num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    for num in range(startnum, endnum + 1):\n        if num < 0:\n            raise ValueError('Negative numbers are not allowed.')\n        if '0' in str(num):\n            continue\n        divisible = True\n        for digit_char in str(num):\n            digit = int(digit_char)\n            if digit == 0:\n                continue\n            if num % digit != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        divisible = True\n        for digit in str(num):\n            if digit != '0' and num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Both startnum and endnum must be positive integers.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        valid = True\n        for digit_char in str(num):\n            digit = int(digit_char)\n            if digit == 0:\n                continue\n            if num % digit != 0:\n                valid = False\n                break\n        if valid:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Numbers must be positive.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        divisible = True\n        for digit_char in str(num):\n            digit = int(digit_char)\n            if digit == 0:\n                continue\n            if num % digit != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Numbers must be positive.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        divisible = True\n        for digit in str(num):\n            if digit != '0' and num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        divisible = True\n        for digit in str(num):\n            if digit != '0' and num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        is_divisible = True\n        for digit in str(num):\n            if digit != '0' and num % int(digit) != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Both startnum and endnum must be positive integers.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        divisible = True\n        for digit in str(num):\n            if digit != '0' and num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result", "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    if startnum < 0 or endnum < 0:\n        raise ValueError('Negative numbers are not allowed.')\n    result = []\n    for num in range(startnum, endnum + 1):\n        if '0' in str(num):\n            continue\n        divisible = True\n        for digit in str(num):\n            if digit != '0' and num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "Mbpp/748", "requirement": "def capital_words_spaces(str1: str) -> str:\n\"\"\"\nWrite a function to put spaces between words starting with capital letters in a given string.\nassert capital_words_spaces(\"Python\") == 'Python'\n\"\"\"", "generated_programs": ["import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)", "import re\n\ndef capital_words_spaces(str1: str) -> str:\n    return re.sub('(?<!^)([A-Z])', ' \\\\1', str1)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/759", "requirement": "def is_decimal(num: str) -> bool:\n    \"\"\"\n    Write a function to check whether a given string is a decimal number with exactly two digits after the decimal point.\n    assert is_decimal('123.11') == True\n    \"\"\"", "generated_programs": ["import re\n\ndef is_decimal(num: str) -> bool:\n    return bool(re.match('^\\\\d+\\\\.\\\\d{2}$', num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = re.compile('^\\\\d+\\\\.\\\\d{2}$')\n    return bool(pattern.match(num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "import re\n\ndef is_decimal(num: str) -> bool:\n    pattern = '^\\\\d+\\\\.\\\\d{2}$'\n    return bool(re.match(pattern, num))", "def is_decimal(num: str) -> bool:\n    try:\n        parts = num.split('.')\n        if len(parts) != 2:\n            return False\n        integer_part, decimal_part = parts\n        if not integer_part.isdigit() or not decimal_part.isdigit():\n            return False\n        return len(decimal_part) == 2\n    except:\n        return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/763", "requirement": "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    \"\"\"\n    Write a Python function to find the minimum difference between any two elements in a given array.\n    The function accepts the array as a tuple of integers and its length as an integer.\n    The parameter `n` is provided but not used within the function; it is included for consistency with the problem statement.\n    \n    assert find_min_diff((1, 5, 3, 19, 18, 25), 6) == 1\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(sorted_arr)):\n        min_diff = min(min_diff, sorted_arr[i] - sorted_arr[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(arr_sorted)):\n        min_diff = min(min_diff, arr_sorted[i] - arr_sorted[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    arr_list = sorted(list(arr))\n    min_diff = float('inf')\n    for i in range(1, len(arr_list)):\n        min_diff = min(min_diff, arr_list[i] - arr_list[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(arr_sorted)):\n        min_diff = min(min_diff, arr_sorted[i] - arr_sorted[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(sorted_arr)):\n        min_diff = min(min_diff, sorted_arr[i] - sorted_arr[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(arr_sorted)):\n        min_diff = min(min_diff, arr_sorted[i] - arr_sorted[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    if len(arr) < 2:\n        return 0\n    sorted_arr = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(sorted_arr)):\n        min_diff = min(min_diff, sorted_arr[i] - sorted_arr[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(arr_sorted)):\n        min_diff = min(min_diff, abs(arr_sorted[i] - arr_sorted[i - 1]))\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    arr_sorted = sorted(arr)\n    min_diff = float('inf')\n    for i in range(1, len(arr_sorted)):\n        min_diff = min(min_diff, arr_sorted[i] - arr_sorted[i - 1])\n    return min_diff", "from typing import Tuple\n\ndef find_min_diff(arr: Tuple[int], n: int) -> int:\n    arr_sorted = list(sorted(arr))\n    min_diff = float('inf')\n    for i in range(len(arr_sorted) - 1):\n        current_diff = abs(arr_sorted[i] - arr_sorted[i + 1])\n        if current_diff < min_diff:\n            min_diff = current_diff\n    return min_diff"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "Mbpp/765", "requirement": "def is_polite(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth polite number. A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers. The sequence starts with 1 (which is not considered polite), followed by 3, 5, 6, 7, 9, 10, 11, etc., excluding powers of two.\n    \n    assert is_polite(7) == 11\n    \"\"\"", "generated_programs": ["def is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while count < n:\n        num += 1\n        if num & num - 1 != 0:\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while count < n:\n        num += 1\n        if num & num - 1 != 0:\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while True:\n        num += 1\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num", "def is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while count < n:\n        num += 1\n        if not num & num - 1 == 0:\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n    count = 0\n    num = 2\n    while True:\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num\n        num += 1", "def is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while True:\n        if num & num - 1 != 0:\n            count += 1\n            if count == n:\n                return num\n        num += 1", "def is_polite(n: int) -> int:\n    polite_numbers = []\n    current = 1\n    while len(polite_numbers) < n:\n        current += 1\n        if current & current - 1 != 0:\n            polite_numbers.append(current)\n    return polite_numbers[-1]", "import math\n\ndef is_polite(n: int) -> int:\n    polite_list = []\n    num = 1\n    while len(polite_list) < n:\n        if num & num - 1 != 0:\n            polite_list.append(num)\n        num += 1\n    return polite_list[-1]", "import math\n\ndef is_polite(n: int) -> int:\n    count = 0\n    num = 1\n    while count < n:\n        num += 1\n        if num & num - 1 != 0:\n            count += 1\n    return num", "def is_polite(n: int) -> int:\n    polite_numbers = []\n    i = 1\n    while len(polite_numbers) < n:\n        if not i & i - 1 == 0:\n            polite_numbers.append(i)\n        i += 1\n    return polite_numbers[-1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "Mbpp/769", "requirement": "from typing import List\n\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"", "generated_programs": ["from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]", "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    return [item for item in li1 if item not in li2]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/771", "requirement": "def check_expression(expression: str) -> bool:\n    \"\"\"Check if the given expression containing brackets is balanced.\n    \n    A string expression is considered balanced if each opening bracket (i.e., '(', '{', '[') \n    has a corresponding closing bracket (i.e., ')', '}', ']') of the same type and brackets are properly nested.\n    \n    assert check_expression(\"{()}[{}]\") == True\n    \"\"\"", "generated_programs": ["from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    stack = deque()\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', ']': '[', '}': '{'}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or bracket_pairs[char] != stack.pop():\n                return False\n    return not stack", "from collections import deque\n\ndef check_expression(expression: str) -> bool:\n    stack = deque()\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map:\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            stack.pop()\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    return not stack", "from typing import List\n\ndef check_expression(expression: str) -> bool:\n    stack: List[str] = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in ['(', '{', '[']:\n            stack.append(char)\n        elif char in [')', '}', ']']:\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            stack.pop()\n    return not stack"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/780", "requirement": "def find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"Generate all unique pairs of tuples from the given list and return a list of tuples where each tuple is the element-wise sum of the pairs.\nassert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n\"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            combinations.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_pair = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_pair)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    n = len(test_list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            combinations.append((test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1]))\n    return combinations", "from typing import List, Tuple\nfrom itertools import combinations\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    unique_pairs = list(combinations(test_list, 2))\n    result = []\n    for pair in unique_pairs:\n        sum_tuple = (pair[0][0] + pair[1][0], pair[0][1] + pair[1][1])\n        result.append(sum_tuple)\n    return result", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n            combinations.append(sum_tuple)\n    return combinations", "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    combinations = []\n    unique_pairs = set()\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            pair = (test_list[i], test_list[j])\n            if pair not in unique_pairs and (test_list[j], test_list[i]) not in unique_pairs:\n                unique_pairs.add(pair)\n                sum_tuple = (test_list[i][0] + test_list[j][0], test_list[i][1] + test_list[j][1])\n                combinations.append(sum_tuple)\n    return combinations"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/782", "requirement": "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a Python function to calculate the sum of contributions of each element in the array,\n    where each element's contribution is the element's value multiplied by the number of odd-length\n    subarrays it appears in. \n    \n    assert odd_length_sum([1, 2, 4]) == 14\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        total += arr[i] * ((i + 1) * (n - i) + 1) // 2\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        total += arr[i] * (((i + 1) * (n - i) + 1) // 2)\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        for j in range(i, n, 2):\n            sub_arr = arr[i:j + 1]\n            total += sum(sub_arr)\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        left = i + 1\n        right = n - i\n        total += arr[i] * ((left * right + 1) // 2)\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 == 1:\n                total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        for j in range(i, n):\n            length = j - i + 1\n            if length % 2 == 1:\n                total += sum(arr[i:j + 1])\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1) % 2 == 1:\n                total += arr[i] * (j - i + 1)\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        for j in range(i, n, 2):\n            subarray_length = j - i + 1\n            total += sum(arr[i:j + 1]) * subarray_length\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        left = i + 1\n        right = n - i\n        total += arr[i] * ((left * right + 1) // 2)\n    return total", "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    result = 0\n    n = len(arr)\n    for i in range(n):\n        total_subarrays = (i + 1) * (n - i)\n        odd_subarrays = (total_subarrays + 1) // 2\n        result += arr[i] * odd_subarrays\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 1.0}}
{"task_id": "Mbpp/784", "requirement": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of the first even and the first odd number in a given list.\n    If the list does not contain both an even and an odd number, return 0.\n    \n    assert mul_even_odd([1,3,5,7,4,1,6,8]) == 4\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even * odd if even is not None and odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return first_even * first_odd if first_even is not None and first_odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return first_even * first_odd if first_even is not None and first_odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return first_even * first_odd if first_even is not None and first_odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return first_even * first_odd if first_even is not None and first_odd is not None else 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0", "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "Mbpp/790", "requirement": "from typing import List\n\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a Python function to check whether the number at every even index is even in a given list.\n    \n    assert even_position([3, 2, 1]) == False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    return all((nums[i] % 2 == 0 for i in range(0, len(nums), 2)))", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True", "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/794", "requirement": "def text_starta_endb(text: str) -> re.Match:\n    \"\"\"\n    Write a function that matches a string that starts with 'a', followed by zero or more characters that are not 'a', and ends with 'b'.\n    assert text_starta_endb(\"aabbbb\") == None\n    \"\"\"", "generated_programs": ["code\nimport re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a[^a]*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    return re.match('^a[^a]*b$', text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)", "import re\n\ndef text_starta_endb(text: str) -> re.Match:\n    pattern = '^a[^a]*b$'\n    return re.match(pattern, text)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "Mbpp/797", "requirement": "def sum_in_range(l: int, r: int) -> int:\n\"\"\"\nWrite a Python function to find the sum of all odd natural numbers within the range from max(1, l) to r (inclusive).\nassert sum_in_range(2,5) == 8\n\"\"\"", "generated_programs": ["def sum_in_range(l: int, r: int) -> int:\n    start = max(1, l)\n    return sum((i for i in range(start, r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    start = max(1, l)\n    return sum((i for i in range(start, r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    start = max(1, l)\n    return sum((i for i in range(start, r + 1) if i % 2 != 0))", "def sum_in_range(l: int, r: int) -> int:\n    start = max(1, l)\n    total = 0\n    for num in range(start, r + 1):\n        if num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    start = max(1, l)\n    total = 0\n    for num in range(start, r + 1):\n        if num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    start = max(1, l)\n    total = 0\n    for num in range(start, r + 1):\n        if num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    start = max(1, l)\n    total = 0\n    for num in range(start, r + 1):\n        if num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    start = max(1, l)\n    sum_odd = 0\n    for num in range(start, r + 1):\n        if num % 2 != 0:\n            sum_odd += num\n    return sum_odd", "def sum_in_range(l: int, r: int) -> int:\n    start = max(1, l)\n    total = 0\n    for num in range(start, r + 1):\n        if num % 2 != 0:\n            total += num\n    return total", "def sum_in_range(l: int, r: int) -> int:\n    start = max(1, l)\n    total = 0\n    for num in range(start, r + 1):\n        if num % 2 != 0:\n            total += num\n    return total"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}

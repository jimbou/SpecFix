{"task_id": "HumanEval/1", "requirement": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those groups into separate strings and return the list of those.\n\n    - Separate groups are balanced (each open parenthesis is properly closed) and not nested within each other.\n    - Ignore any spaces in the input string before processing.\n    - If the input contains unmatched or malformed parentheses, process the string character by character.\n      Treat any sequence of characters that achieves a balance of zero (i.e., the number of opening and closing\n      parentheses is equal) as a valid group, even if the sequence starts or ends with unmatched parentheses.\n      Unmatched parentheses that do not form part of such a balanced sequence will not be included in the output.\n\n    Examples:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    >>> separate_paren_groups('() )')\n    ['()']\n    >>> separate_paren_groups(')(')\n    [')(']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            if not stack:\n                result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current_group = ''\n    balance = 0\n    for char in paren_string:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group += char\n        if balance == 0 and current_group:\n            result.append(current_group)\n            current_group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    balance = 0\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and i > start:\n            result.append(paren_string[start:i + 1])\n            start = i + 1\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = 0\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack += 1\n        elif char == ')':\n            stack -= 1\n        if stack == 0 and i > start:\n            result.append(paren_string[start:i + 1])\n            start = i + 1\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            if not stack:\n                result.append(paren_string[start:i + 1])\n                start = i + 1\n    return [group for group in result if group.count('(') == group.count(')')]", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    balance = 0\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and i != start:\n            result.append(paren_string[start:i + 1])\n            start = i + 1\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    current_group = ''\n    balance = 0\n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0:\n            if current_group:\n                groups.append(current_group)\n                current_group = ''\n    return groups", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current_group = []\n    balance = 0\n    for char in paren_string:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        current_group.append(char)\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return [group for group in result if group.count('(') == group.count(')')]", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            if not stack:\n                result.append(paren_string[start:i + 1])\n                start = i + 1\n        elif not stack:\n            start = i + 1\n    return [group for group in result if group.count('(') == group.count(')')]", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                stack.pop()\n                if not stack:\n                    groups.append(paren_string[start:i + 1])\n                    start = i + 1\n            elif start == i:\n                groups.append(paren_string[i:i + 1])\n                start = i + 1\n    return groups"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/4", "requirement": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate the Mean Absolute Deviation (MAD)\n    around the mean of this dataset. Mean Absolute Deviation is the average absolute \n    difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Special Cases:\n    - If the input list is empty, the function will raise a ZeroDivisionError.\n\n    Input Constraints:\n    - The input must be a list of floats. Lists containing integers or mixed types \n      are not supported and may result in undefined behavior.\n\n    Implementation Details:\n    - The function uses basic mathematical operations and does not rely on external \n      libraries like `statistics`.\n\n    Examples:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([])\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError('Cannot calculate MAD of an empty list.')\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    return sum(absolute_differences) / len(numbers)", "code\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError\n    mean = sum(numbers) / len(numbers)\n    mad = sum((abs(x - mean) for x in numbers)) / len(numbers)\n    return mad"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/5", "requirement": "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"Insert the number 'delimiter' between every two consecutive elements of the input list `numbers`.\n    The delimiter is added after each element except the last one.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"", "generated_programs": ["code\nfrom typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that begins with a supplied string.\n\n    The algorithm works as follows:\n    - Check if the entire string is already a palindrome. If so, return it as is.\n    - Otherwise, iterate through the string to find the longest suffix that is a palindrome.\n    - Identify the prefix of the string that comes before this palindromic suffix.\n    - Append the reverse of this prefix to the end of the original string to form the palindrome.\n\n    Examples:\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n    if string == string[::-1]:\n        return string\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            break\n    return string + string[:i][::-1]", "def make_palindrome(string: str) -> str:\n    if string == string[::-1]:\n        return string\n    n = len(string)\n    for i in range(n):\n        if string[i:] == string[i:][::-1]:\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if string == string[::-1]:\n        return string\n    n = len(string)\n    for i in range(n):\n        if string[i:] == string[i:][::-1]:\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if string == string[::-1]:\n        return string\n    n = len(string)\n    for i in range(n):\n        if string[i:] == string[i:][::-1]:\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if string == string[::-1]:\n        return string\n    for i in range(len(string), 0, -1):\n        if string[:i] == string[:i][::-1]:\n            break\n    return string + string[i:][::-1]", "def make_palindrome(string: str) -> str:\n    if string == string[::-1]:\n        return string\n    n = len(string)\n    for i in range(n, 0, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string + string[::-1]", "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef make_palindrome(string: str) -> str:\n    if is_palindrome(string):\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if string == string[::-1]:\n        return string\n    n = len(string)\n    for i in range(n - 1, -1, -1):\n        if string[:i + 1] == string[:i + 1][::-1]:\n            break\n    return string + string[i + 1:][::-1]", "code\n\ndef make_palindrome(string: str) -> str:\n    if string == string[::-1]:\n        return string\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string + string[:-1][::-1]", "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef make_palindrome(string: str) -> str:\n    if is_palindrome(string):\n        return string\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.0}}
{"task_id": "HumanEval/12", "requirement": "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Out of a list of strings, return the longest one. If there are multiple strings of the same maximum length, return the one that appears first in the list. Return None if the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"", "generated_programs": ["from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    max_length = max((len(s) for s in strings))\n    for s in strings:\n        if len(s) == max_length:\n            return s", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    longest_str = strings[0]\n    for s in strings:\n        if len(s) > len(longest_str):\n            longest_str = s\n    return longest_str", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    max_length = len(strings[0])\n    longest_str = strings[0]\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            longest_str = s\n    return longest_str"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/18", "requirement": "```python\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Find how many times a given `substring` can be found in the `string`. \n    Overlapping occurrences of `substring` should be counted.\n    \n    Explicit Definitions:\n    1. Overlapping occurrences:\n       - After finding a match, the search for the next match starts at the next character \n         immediately following the first character of the previous match.\n    \n    2. Special Cases:\n       - If `substring` is empty, the function should return `0` regardless of the content of `string`.\n       - If `string` is empty and `substring` is non-empty, the count should return `0`.\n\n    Examples:\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n```", "generated_programs": ["def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    start = 0\n    while True:\n        start = string.find(substring, start)\n        if start == -1:\n            return count\n        count += 1\n        start += 1", "def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    start = 0\n    while True:\n        start = string.find(substring, start)\n        if start == -1:\n            break\n        count += 1\n        start += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    start = 0\n    while True:\n        idx = string.find(substring, start)\n        if idx == -1:\n            break\n        count += 1\n        start = idx + 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    n = len(substring)\n    for i in range(len(string) - n + 1):\n        if string[i:i + n] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    start = 0\n    while True:\n        index = string.find(substring, start)\n        if index == -1:\n            break\n        count += 1\n        start = index + 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    start = 0\n    while True:\n        idx = string.find(substring, start)\n        if idx == -1:\n            break\n        count += 1\n        start = idx + 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    start = 0\n    while start <= len(string) - len(substring):\n        if string[start:start + len(substring)] == substring:\n            count += 1\n            start += 1\n        else:\n            start += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    start = 0\n    while start < len(string):\n        pos = string.find(substring, start)\n        if pos == -1:\n            break\n        count += 1\n        start = pos + 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    start = 0\n    while True:\n        idx = string.find(substring, start)\n        if idx == -1:\n            break\n        count += 1\n        start = idx + 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    idx = 0\n    while idx <= len(string) - len(substring):\n        if string[idx:idx + len(substring)] == substring:\n            count += 1\n            idx += 1\n        else:\n            idx += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/21", "requirement": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "code\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/24", "requirement": "```python\ndef largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number smaller than n that divides n evenly.\n    \n    - The search starts from n-1 and proceeds downward to 1.\n    - If no valid divisors exist (e.g., for n = 1), the function returns None.\n    \n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    None\n    \"\"\"\n```", "generated_programs": ["def largest_divisor(n: int) -> int:\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n <= 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "def largest_divisor(n: int) -> int:\n    if n <= 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n <= 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/25", "requirement": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"\n    Return a list of prime factors of the given integer `n` in the order from smallest to largest.\n    Each factor should be listed the number of times corresponding to its multiplicity in the factorization.\n    \n    Constraints:\n    - The input `n` must be a non-negative integer (i.e., `n >= 0`).\n    - For `n = 0` or `n = 1`, the function will return an empty list `[]` as these values do not have prime factors.\n    - Negative integers are considered invalid inputs, and the function will return an empty list `[]` for such cases.\n\n    Behavior:\n    - The input number `n` should be equal to the product of all factors in the returned list.\n    - For valid positive integers (`n > 1`), the function will compute the prime factorization.\n    - For invalid or edge-case inputs (`n <= 0`), the function will return an empty list `[]`.\n\n    Examples:\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    >>> factorize(0)\n    []\n    >>> factorize(-12)\n    []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n < 2:\n        return []\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n < 2:\n        return []\n    factors = []\n    divisor = 2\n    while n >= divisor:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    divisor = 2\n    while n >= divisor:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        divisor += 1\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n < 0:\n        return []\n    factors = []\n    if n < 2:\n        return factors\n    divisor = 2\n    while n >= 2:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        divisor += 1\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n < 2:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/32", "requirement": "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    \"\"\"\n    Evaluates a polynomial with coefficients xs at point x.\n    The polynomial is defined as:\n    xs[0] + xs[1] * x + xs[2] * x^2 + ... + xs[n] * x^n\n    where xs[i] represents the coefficient of the x^i term.\n\n    Args:\n        xs (List[float]): List of coefficients of the polynomial.\n        x (float): The point at which the polynomial is evaluated.\n\n    Returns:\n        float: The value of the polynomial at point x.\n    \"\"\"\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\"\n    Finds a zero point (root) of a polynomial defined by its coefficients xs.\n    The function assumes the following constraints:\n    1. The input list xs must have an even number of coefficients. If not, a ValueError is raised.\n    2. If all coefficients are zero, the function immediately returns 0.0 without further evaluation.\n    3. The function attempts to find one root within the interval [-100, 100] using binary search. It does not require a sign change at the endpoints of the interval and assumes that the constraints allow for root discovery within this range.\n    4. If multiple roots exist, the function returns one root based on the binary search process, without prioritizing specific roots.\n\n    Args:\n        xs (List[float]): List of coefficients of the polynomial.\n\n    Returns:\n        float: A root of the polynomial within the interval [-100, 100].\n\n    Raises:\n        ValueError: If the input list xs does not have an even number of coefficients.\n\n    Examples:\n        >>> round(find_zero([1, 2]), 2)  # f(x) = 1 + 2x\n        -0.5\n        >>> round(find_zero([-6, 11, -6, 1]), 2)  # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n        1.0\n        >>> find_zero([0, 0])  # f(x) = 0\n        0.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coef * x ** i for i, coef in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coef * x ** i for i, coef in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coef * x ** i for i, coef in enumerate(xs)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/39", "requirement": "def prime_fib(n: int) -> int:\n    \"\"\"\n    prime_fib returns the n-th number that is both a Fibonacci number and a prime number.\n    \n    Constraints:\n    1. The input `n` must be a positive integer (n >= 1). If `n` is non-positive or invalid, the function raises a ValueError.\n    2. Fibonacci numbers are generated iteratively starting from 0 and 1, and only positive Fibonacci numbers are considered.\n    3. The function filters Fibonacci numbers to include only those that are prime, using a primality check.\n    4. The function halts once exactly `n` prime Fibonacci numbers have been found and returns the last one in the sequence.\n\n    Examples:\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n\n    Edge cases:\n    - For `n = 0` or any non-positive input, the function raises a ValueError.\n    - For valid positive `n`, the function guarantees a valid output.\n    \"\"\"", "generated_programs": ["import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        if a > 1 and is_prime(a):\n            count += 1\n            if count == n:\n                return a\n        a, b = (b, a + b)", "import math\n\ndef prime_fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer.')\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    a, b = (0, 1)\n    count = 0\n    while True:\n        if a > 1 and is_prime(a):\n            count += 1\n            if count == n:\n                return a\n        a, b = (b, a + b)", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        if a > 0 and is_prime(a):\n            count += 1\n            if count == n:\n                return a\n        a, b = (b, a + b)", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        if a > 1 and is_prime(a):\n            count += 1\n            if count == n:\n                return a\n        a, b = (b, a + b)", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a\n        a, b = (b, a + b)", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer.')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        if is_prime(b):\n            count += 1\n            if count == n:\n                return b\n        a, b = (b, a + b)", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        if a > 0 and is_prime(a):\n            count += 1\n            if count == n:\n                return a\n        a, b = (b, a + b)", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer.')\n    fib_prev, fib_curr = (0, 1)\n    count = 0\n    while True:\n        fib_next = fib_prev + fib_curr\n        fib_prev, fib_curr = (fib_curr, fib_next)\n        if is_prime(fib_curr):\n            count += 1\n            if count == n:\n                return fib_curr", "import math\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        if a > 1 and is_prime(a):\n            count += 1\n            if count == n:\n                return a\n        a, b = (b, a + b)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/41", "requirement": "```python\ndef car_race_collision(n: int) -> int:\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    There are two sets of cars:\n    - One set consists of `n` cars driving left to right.\n    - The other set consists of `n` cars driving right to left.\n\n    All cars move at the same speed. Two cars are said to collide when a car \n    from the left-to-right set encounters a car from the right-to-left set. \n    Each car from one set collides with every car from the other set, resulting \n    in `n * n` total collisions.\n\n    This function outputs the total number of such collisions.\n\n    Input:\n    - `n` (int): The number of cars in each set. Must be a positive integer.\n\n    Output:\n    - Returns the total number of collisions, calculated as `n * n`.\n\n    Examples:\n    ### Test 1\n    Input: [2]\n    Expected Output: [4]\n    ### Test 2\n    Input: [3]\n    Expected Output: [9]\n    \"\"\"\n```", "generated_programs": ["def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/44", "requirement": "def change_base(x: int, base: int) -> str:\n    \"\"\"\n    Convert the integer x to its representation in the specified numerical base and return the result as a string.\n    \n    - If x is 0, return an empty string ('') to indicate no meaningful conversion was performed.\n    - The base must be an integer between 2 and 9 (inclusive). If the base is outside this range, raise a ValueError.\n    - The conversion process uses digits less than 10 to represent numbers in the specified base.\n\n    Examples:\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"", "generated_programs": ["def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    if not 2 <= base <= 9:\n        raise ValueError('Base must be between 2 and 9 inclusive.')\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "code\n\ndef change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    if base < 2 or base > 9:\n        raise ValueError('Base must be between 2 and 9 inclusive.')\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if base < 2 or base > 9:\n        raise ValueError('Base must be between 2 and 9 inclusive.')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if base < 2 or base > 9:\n        raise ValueError('Base must be between 2 and 9 inclusive.')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if base < 2 or base > 9:\n        raise ValueError('Base must be between 2 and 9.')\n    if x == 0:\n        return ''\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(reversed(digits))", "def change_base(x: int, base: int) -> str:\n    if base < 2 or base > 9:\n        raise ValueError('Base must be between 2 and 9 inclusive.')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    if base < 2 or base > 9:\n        raise ValueError('Base must be between 2 and 9 inclusive.')\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    if base < 2 or base > 9:\n        raise ValueError('Base must be between 2 and 9 inclusive.')\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if base < 2 or base > 9:\n        raise ValueError('Base must be between 2 and 9 inclusive.')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x //= base\n    return result", "def change_base(x: int, base: int) -> str:\n    if base < 2 or base > 9:\n        raise ValueError('Base must be between 2 and 9 inclusive.')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x //= base\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/46", "requirement": "```python\ndef fib4(n: int) -> int:\n    \"\"\"\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n\n    The function computes the n-th element of the Fib4 number sequence with the following rules:\n    - If n is negative, the function returns 0.\n    - The function assumes n is an integer and does not validate the type of n.\n    - The function does not use recursion and computes the result efficiently using an iterative approach.\n\n    Please write a function to efficiently compute the n-th element of the Fib4 number sequence.\n\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n```", "generated_programs": ["def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < len(fib):\n        return fib[n]\n    for i in range(4, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < 4:\n        return fib[n]\n    for i in range(4, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < 4:\n        return fib[n]\n    for i in range(4, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib_vals = [0, 0, 2, 0]\n    for i in range(4, n + 1):\n        fib_vals.append(fib_vals[i - 1] + fib_vals[i - 2] + fib_vals[i - 3] + fib_vals[i - 4])\n    return fib_vals[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < len(fib):\n        return fib[n]\n    for i in range(4, n + 1):\n        next_fib = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4]\n        fib.append(next_fib)\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < 4:\n        return fib[n]\n    for i in range(4, n + 1):\n        next_val = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4]\n        fib.append(next_val)\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    if n == 2:\n        return 2\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        a, b, c, d = (b, c, d, a + b + c + d)\n    return d", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib_sequence = [0, 0, 2, 0]\n    if n < 4:\n        return fib_sequence[n]\n    for i in range(4, n + 1):\n        next_fib = fib_sequence[i - 1] + fib_sequence[i - 2] + fib_sequence[i - 3] + fib_sequence[i - 4]\n        fib_sequence.append(next_fib)\n    return fib_sequence[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib4_sequence = [0, 0, 2, 0]\n    if n < len(fib4_sequence):\n        return fib4_sequence[n]\n    for i in range(4, n + 1):\n        next_fib4 = fib4_sequence[i - 1] + fib4_sequence[i - 2] + fib4_sequence[i - 3] + fib4_sequence[i - 4]\n        fib4_sequence.append(next_fib4)\n    return fib4_sequence[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 2\n    if n == 3:\n        return 0\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        e = a + b + c + d\n        a, b, c, d = (b, c, d, e)\n    return d"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    s = sorted(l)\n    n = len(s)\n    if n % 2 == 1:\n        return s[n // 2]\n    else:\n        return (s[n // 2 - 1] + s[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return float(sorted_l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 1:\n        return l_sorted[mid]\n    else:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 1:\n        return l_sorted[mid]\n    else:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 1:\n        return l_sorted[mid]\n    else:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2.0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/54", "requirement": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words contain exactly the same set of unique characters, regardless of their frequency or order.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"", "generated_programs": ["def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/55", "requirement": "```python\ndef fib(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number, based on the sequence defined as (1, 1, 2, 3, ...).\n    \n    Valid input constraints:\n    - `n` must be a positive integer (i.e., `n > 0`).\n    - This function does not support zero or negative values for `n`.\n\n    Sequence definition:\n    - The Fibonacci sequence starts with (1, 1), where:\n      - `fib(1) == 1` (first number in the sequence).\n      - `fib(2) == 1` (second number in the sequence).\n    - For `n > 2`, the Fibonacci number is calculated recursively as:\n      `fib(n) == fib(n - 1) + fib(n - 2)`.\n\n    Error handling:\n    - This function will raise a `ValueError` if the input `n` is less than or equal to 0.\n    - Input must be an integer; passing non-integer types will raise a `TypeError`.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n```", "generated_programs": ["def fib(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 0:\n        raise ValueError('n must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/64", "requirement": "def vowels_count(s: str) -> int:\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Additionally, 'y' \n    is considered a vowel only if it is the last character in the string.\n\n    The function should:\n    1. Treat the input string case-insensitively, meaning both uppercase\n       and lowercase letters are considered equivalent.\n    2. Handle edge cases gracefully, such as an empty string input (`s = \"\"`),\n       by returning `0` without raising errors.\n    3. Count 'y' as a vowel only if it is the last character in the string,\n       regardless of whether the string contains non-alphabetic characters.\n       For example, \"abcdy\" would count 'y' as a vowel, but \"abcdyz\" would not.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\")\n    0\n    \"\"\"", "generated_programs": ["def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    if not s:\n        return 0\n    s_lower = s.lower()\n    for char in s_lower[:-1]:\n        if char in vowels:\n            count += 1\n    if s_lower[-1] in vowels or s_lower[-1] == 'y':\n        count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/70", "requirement": "def strange_sort_list(lst: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list sorted in a specific alternating order.\n    The sorting alternates between the smallest and largest remaining values in the list:\n    - Start with the smallest value.\n    - Then take the largest of the remaining values.\n    - Continue alternating between the smallest and largest of the remaining values until the list is exhausted.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    while left <= right:\n        if left == right:\n            result.append(sorted_lst[left])\n        else:\n            result.append(sorted_lst[left])\n            result.append(sorted_lst[right])\n        left += 1\n        right -= 1\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    result = []\n    sorted_lst = sorted(lst)\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    while left <= right:\n        if left == right:\n            result.append(sorted_lst[left])\n        else:\n            result.append(sorted_lst[left])\n            result.append(sorted_lst[right])\n        left += 1\n        right -= 1\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    while left <= right:\n        if left == right:\n            result.append(sorted_lst[left])\n        else:\n            result.append(sorted_lst[left])\n            result.append(sorted_lst[right])\n        left += 1\n        right -= 1\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    result = []\n    lst_sorted = sorted(lst)\n    left, right = (0, len(lst_sorted) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(lst_sorted[left])\n            left += 1\n        else:\n            result.append(lst_sorted[right])\n            right -= 1\n        toggle = not toggle\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/74", "requirement": "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    the total number of characters in all its strings less than or equal to the total \n    number of characters in all strings of the other list.\n\n    If the two lists have the same total number of characters, the function must return \n    the first list (`lst1`).\n\n    Examples:\n    total_match([], [])  []\n    total_match(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5'])  ['4']\n    '''", "generated_programs": ["from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/75", "requirement": "```python\ndef is_multiply_prime(a: int) -> bool:\n    \"\"\"\n    Write a function that returns True if the given number is the product of exactly 3 prime numbers,\n    and False otherwise. The function should adhere to the following constraints:\n    \n    1. The input number `a` must be less than 100. If `a` is 100 or greater, the function should return False.\n    2. The product can include repeated prime factors. For example, `18 = 2 * 3 * 3` is valid.\n    3. The function should return False for numbers that cannot be expressed as the product of exactly 3 primes,\n       including edge cases such as `a = 1` or numbers with fewer than 3 prime factors.\n    4. The prime factors used to form the product must be less than or equal to the input number `a`.\n\n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n```", "generated_programs": ["def is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False", "import math\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False", "def is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    for p1 in primes:\n        for p2 in primes:\n            for p3 in primes:\n                if p1 * p2 * p3 == a:\n                    return True\n    return False", "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n    primes = [x for x in range(2, a + 1) if is_prime(x)]\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False", "def is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    from itertools import combinations_with_replacement\n    for comb in combinations_with_replacement(primes, 3):\n        if comb[0] * comb[1] * comb[2] == a:\n            return True\n    return False", "import math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n    prime_factors = []\n    n = a\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            prime_factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        prime_factors.append(n)\n    return len(prime_factors) == 3", "def is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    for i in range(len(primes)):\n        for j in range(len(primes)):\n            for k in range(len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False", "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n    primes = [x for x in range(2, a + 1) if is_prime(x)]\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False", "from math import isqrt\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, isqrt(n) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef get_prime_factors(n: int) -> list:\n    factors = []\n    i = 2\n    while i <= n:\n        if n % i == 0 and is_prime(i):\n            factors.append(i)\n            n = n // i\n        else:\n            i += 1\n    return factors\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n    factors = get_prime_factors(a)\n    return len(factors) == 3", "def is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def get_prime_factors(n):\n        factors = []\n        i = 2\n        while i * i <= n:\n            while n % i == 0:\n                factors.append(i)\n                n = n // i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n    factors = get_prime_factors(a)\n    if len(factors) != 3:\n        return False\n    for factor in factors:\n        if not is_prime(factor):\n            return False\n    return True"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/76", "requirement": "```python\ndef is_simple_power(x: int, n: int) -> bool:\n    \"\"\"\n    Your task is to write a function that returns True if a number x is a simple\n    power of n and False in all other cases.\n\n    A number x is a simple power of n if there exists a non-negative integer k \n    such that n**k == x. The function should adhere to the following rules:\n    \n    1. Both x and n must be positive integers (x >= 1 and n >= 1). If either x or n \n       is less than 1, the function should return False.\n    2. The number 1 is considered a simple power of any positive integer n, \n       because n**0 == 1 for all n >= 1.\n    3. For all other cases, the function should determine if x can be expressed \n       as n raised to the power of a non-negative integer.\n\n    Examples:\n    is_simple_power(1, 4) => True\n    is_simple_power(2, 2) => True\n    is_simple_power(8, 2) => True\n    is_simple_power(3, 2) => False\n    is_simple_power(3, 1) => False\n    is_simple_power(5, 3) => False\n    \"\"\"\n```", "generated_programs": ["def is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    k = 0\n    current = 1\n    while current < x:\n        current *= n\n        k += 1\n    return current == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    power = 1\n    while power < x:\n        power *= n\n        if power == x:\n            return True\n    return False", "def is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    k = 0\n    while n ** k < x:\n        k += 1\n    return n ** k == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    k = 0\n    while n ** k < x:\n        k += 1\n    return n ** k == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    k = 0\n    while n ** k <= x:\n        if n ** k == x:\n            return True\n        k += 1\n    return False", "def is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    k = 0\n    while n ** k <= x:\n        if n ** k == x:\n            return True\n        k += 1\n    return False", "def is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    k = 0\n    while True:\n        result = n ** k\n        if result == x:\n            return True\n        if result > x:\n            return False\n        k += 1", "import math\n\ndef is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = math.log(x, n)\n    return abs(k - round(k)) < 1e-06 and x == n ** round(k)", "import math\n\ndef is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while n ** k <= x:\n        if n ** k == x:\n            return True\n        k += 1\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    \"\"\"\n    Write a function that takes an integer a and returns True \n    if the absolute value of this integer is a perfect cube of some integer number.\n    A perfect cube is defined as an integer that can be expressed as the cube of another integer.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    \"\"\"", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    x = int(round(abs(a) ** (1 / 3)))\n    return x ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    x = abs(a)\n    cube_root = round(x ** (1 / 3))\n    return cube_root ** 3 == x", "from math import isclose\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = abs_a ** (1 / 3)\n    rounded_cube_root = round(cube_root)\n    return isclose(rounded_cube_root ** 3, abs_a, rel_tol=1e-09)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.8}}
{"task_id": "HumanEval/83", "requirement": "```python\ndef starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n (where n  1), return the count of the n-digit \n    positive integers that either start with 1, end with 1, or both. Numbers \n    that simultaneously start and end with 1 are only counted once.\n\n    The function assumes that n is a single positive integer and handles only \n    valid input values (n  1). For n = 1, the result is 1 because there is \n    only one 1-digit positive integer (1), which both starts and ends with 1.\n\n    Example:\n    - starts_one_ends(1) -> 1\n    - starts_one_ends(2) -> 18\n    - starts_one_ends(3) -> 180\n\n    Explanation of calculations:\n    - For n-digit numbers that start with 1, there are `10 ** (n - 1)` numbers.\n    - For n-digit numbers that end with 1, there are `9 * 10 ** (n - 1)` numbers.\n    - Numbers that both start and end with 1 (overlap) occur in total `10 ** (n - 2)` cases \n      for n  2 (and none if n = 1).\n    - To compute the total, add the count of numbers starting with 1 and ending with 1, \n      then subtract the overlap.\n    \"\"\"\n```", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 1)\n    both = 10 ** (n - 2)\n    return start_with_one + end_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts = 10 ** (n - 1)\n    ends = 9 * 10 ** (n - 1)\n    overlap = 10 ** (n - 2)\n    return starts + ends - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return start_with_one + end_with_one - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 9 * 10 ** (n - 1)\n    overlap = 10 ** (n - 2)\n    return starts_with_one + ends_with_one - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 9 * 10 ** (n - 1)\n    overlap = 10 ** (n - 2)\n    return starts_with_one + ends_with_one - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 9 * 10 ** (n - 1)\n    both = 10 ** (n - 2)\n    return starts_with_one + ends_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 1)\n    both = 10 ** (n - 2)\n    return start_with_one + end_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 1)\n    both = 10 ** (n - 2)\n    return start_with_one + end_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 2)\n    start_and_end_with_one = 10 ** (n - 2)\n    return start_with_one + end_with_one - start_and_end_with_one", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 1)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/86", "requirement": "def anti_shuffle(s: str) -> str:\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    The ordered version of the string is created by replacing each word (separated by spaces) \n    with a new word where all the characters in the word are arranged in ascending order \n    based on their ASCII values. Words are defined as sequences of non-space characters, \n    and spaces between words should be preserved in the output.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"", "generated_programs": ["def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word, key=lambda x: ord(x))) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join([''.join(sorted(word, key=lambda x: ord(x))) for word in s.split(' ')])", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word, key=lambda x: ord(x))) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n    return ' '.join(ordered_words)"], "result": {"repaired_passk": 0.6, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/87", "requirement": "def get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    You are given a 2-dimensional dataset represented as nested lists,\n    where each inner list corresponds to a row. Unlike a traditional matrix,\n    the rows may have varying numbers of columns. \n\n    Given `lst` and an integer `x`, find all occurrences of `x` in the dataset\n    and return a list of tuples representing the coordinates of `x`. Each tuple\n    is in the form `(row_index, column_index)`, where `row_index` is the index\n    of the row and `column_index` is the index of the column, both starting from 0.\n\n    The coordinates must be sorted as follows:\n    1. Primarily by `row_index` in ascending order.\n    2. For coordinates within the same row, by `column_index` in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in reversed(list(enumerate(row))):\n            if value == x:\n                result.append((row_index, col_index))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(reversed(row)):\n            if value == x:\n                result.append((row_index, len(row) - 1 - col_index))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, val in enumerate(row):\n            if val == x:\n                result.append((row_index, col_index))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for i, row in enumerate(lst):\n        for j, val in reversed(list(enumerate(row))):\n            if val == x:\n                result.append((i, j))\n    return sorted(result, key=lambda coord: (coord[0], -coord[1]))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/89", "requirement": "```python\ndef encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a lowercase string as an argument\n    and returns a string encrypted by rotating each lowercase alphabetical\n    character forward by 4 positions in the alphabet. Non-alphabetic characters\n    are left unchanged. Uppercase letters are not considered in this context.\n    \n    The alphabet is considered to wrap around, so after 'z', it continues from 'a'.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n```", "generated_programs": ["def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(new_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(new_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(new_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(new_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted_str = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted_str.append(new_char)\n        else:\n            encrypted_str.append(char)\n    return ''.join(encrypted_str)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    \n    Sentences are defined as substrings of the input string that are separated \n    by any of the delimiters '.', '?' or '!'. All delimiters are treated \n    equivalently and collectively during splitting. Consecutive delimiters or \n    trailing delimiters will result in empty substrings, which are ignored.\n\n    Leading and trailing spaces in each sentence are removed before checking \n    whether the sentence starts with the word \"I\". A sentence is considered to \n    start with the word \"I\" if its first non-whitespace character is 'I', \n    regardless of whether 'I' is followed by a space or punctuation.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    >>> is_bored(\"   I  am here   !   \")\n    1\n    \"\"\"", "generated_programs": ["import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I'):\n            count += 1\n    return count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message and encodes it by performing the following steps:\n\n    1. Swap the case of all letters in the message (uppercase becomes lowercase, and vice versa).\n       For example, 'a' becomes 'A', 'B' becomes 'b', etc.\n    2. After swapping the case, replace all swapped vowels (a, e, i, o, u, A, E, I, O, U) with the letter \n       that appears 2 places ahead of that vowel in the English alphabet, maintaining the case of the swapped vowel:\n       - 'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w'\n       - 'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'\n       - No wraparound logic is applied; vowels are shifted strictly within the alphabet.\n    3. Consonants (non-vowel letters) in the swapped message are not modified further.\n\n    Assume the input message contains only alphabetic characters (no spaces, digits, or special characters).\n\n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in message:\n        swapped_char = char.swapcase()\n        if swapped_char in vowels:\n            shifted_char = chr(ord(swapped_char) + 2)\n            result.append(shifted_char)\n        else:\n            result.append(swapped_char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    swapped_message = message.swapcase()\n    encoded_message = []\n    vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    for char in swapped_message:\n        if char in vowels:\n            encoded_message.append(vowels[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    swapped_message = message.swapcase()\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels:\n            encoded_message.append(vowels[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped = message.swapcase()\n    vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in swapped:\n        if char in vowels:\n            encoded_message.append(vowels[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped_message = message.swapcase()\n    vowels_shift = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels_shift:\n            encoded_message.append(vowels_shift[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in message:\n        swapped_char = char.swapcase()\n        if swapped_char in vowels:\n            if swapped_char.islower():\n                result.append(chr(ord(swapped_char) + 2) if ord(swapped_char) + 2 <= ord('z') else swapped_char)\n            else:\n                result.append(chr(ord(swapped_char) + 2) if ord(swapped_char) + 2 <= ord('Z') else swapped_char)\n        else:\n            result.append(swapped_char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    vowel_shift = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    swapped_case = message.swapcase()\n    encoded_message = []\n    for char in swapped_case:\n        if char in vowels:\n            encoded_message.append(vowel_shift[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped_message = message.swapcase()\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    shift_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels:\n            encoded_message.append(shift_map[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    vowel_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in message:\n        swapped_char = char.swapcase()\n        if swapped_char in vowels:\n            encoded_message.append(vowel_map[swapped_char])\n        else:\n            encoded_message.append(swapped_char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels_lower = {'a', 'e', 'i', 'o', 'u'}\n    vowels_upper = {'A', 'E', 'I', 'O', 'U'}\n    vowel_shift_lower = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    vowel_shift_upper = {'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    swapped_message = message.swapcase()\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels_lower:\n            encoded_message.append(vowel_shift_lower[char])\n        elif char in vowels_upper:\n            encoded_message.append(vowel_shift_upper[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/97", "requirement": "```python\ndef multiply(a: int, b: int) -> int:\n    \"\"\"\n    Complete the function that takes two integers and returns \n    the product of the absolute values of their unit digits. The \n    unit digit of a number is the last digit of its absolute value. \n    In other words, ignore the sign of the numbers entirely while determining \n    the unit digit and computing the product.\n    \n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14, -15) should return 20.\n    \"\"\"\n```", "generated_programs": ["def multiply(a: int, b: int) -> int:\n    return abs(a) % 10 * abs(b) % 10", "def multiply(a: int, b: int) -> int:\n    return abs(a) % 10 * (abs(b) % 10)", "def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b", "def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b", "def multiply(a: int, b: int) -> int:\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "def multiply(a: int, b: int) -> int:\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "def multiply(a: int, b: int) -> int:\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "def multiply(a: int, b: int) -> int:\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "def multiply(a: int, b: int) -> int:\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "def multiply(a: int, b: int) -> int:\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/99", "requirement": "```python\ndef closest_integer(value: str) -> int:\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. The function should handle\n    rounding based on the following rules:\n\n    - Convert the input string to a float.\n    - If the input is exactly an integer (e.g., \"10\" or \"0\"), return it directly.\n      This check should use floating-point equality (`num == int(num)`).\n    - For positive numbers:\n      - Calculate the fractional part as `num - math.floor(num)`.\n      - Round up to the nearest integer if the fractional part is 0.5 or greater.\n      - Otherwise, round down to the nearest integer.\n    - For negative numbers:\n      - Calculate the fractional part as `math.ceil(num) - num`.\n      - Round down to the nearest integer if the fractional part is 0.5 or greater.\n      - Otherwise, round up to the nearest integer.\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example, closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n\n    Examples:\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n    >>> closest_integer(\"-99.999\")\n    -100\n    '''\n```", "generated_programs": ["import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == int(num):\n        return int(num)\n    if num >= 0:\n        fractional = num - math.floor(num)\n        return math.floor(num) if fractional < 0.5 else math.ceil(num)\n    else:\n        fractional = math.ceil(num) - num\n        return math.ceil(num) if fractional < 0.5 else math.floor(num)", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == int(num):\n        return int(num)\n    if num > 0:\n        fractional = num - math.floor(num)\n        return math.floor(num) + 1 if fractional >= 0.5 else math.floor(num)\n    else:\n        fractional = math.ceil(num) - num\n        return math.ceil(num) - 1 if fractional >= 0.5 else math.ceil(num)", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == int(num):\n        return int(num)\n    if num >= 0:\n        fractional = num - math.floor(num)\n        if fractional >= 0.5:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    else:\n        fractional = math.ceil(num) - num\n        if fractional >= 0.5:\n            return math.floor(num)\n        else:\n            return math.ceil(num)", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == int(num):\n        return int(num)\n    if num > 0:\n        fractional = num - math.floor(num)\n        if fractional >= 0.5:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    else:\n        fractional = math.ceil(num) - num\n        if fractional >= 0.5:\n            return math.floor(num)\n        else:\n            return math.ceil(num)", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == int(num):\n        return int(num)\n    if num > 0:\n        fractional = num - math.floor(num)\n        if fractional >= 0.5:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    else:\n        fractional = math.ceil(num) - num\n        if fractional >= 0.5:\n            return math.floor(num)\n        else:\n            return math.ceil(num)", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == int(num):\n        return int(num)\n    if num > 0:\n        fractional = num - math.floor(num)\n        if fractional >= 0.5:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    else:\n        fractional = math.ceil(num) - num\n        if fractional >= 0.5:\n            return math.floor(num)\n        else:\n            return math.ceil(num)", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == int(num):\n        return int(num)\n    if num > 0:\n        fractional = num - math.floor(num)\n        if fractional >= 0.5:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    else:\n        fractional = math.ceil(num) - num\n        if fractional >= 0.5:\n            return math.floor(num)\n        else:\n            return math.ceil(num)", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == int(num):\n        return int(num)\n    if num > 0:\n        fractional = num - math.floor(num)\n        if fractional >= 0.5:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    else:\n        fractional = math.ceil(num) - num\n        if fractional >= 0.5:\n            return math.floor(num)\n        else:\n            return math.ceil(num)", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == int(num):\n        return int(num)\n    if num >= 0:\n        fractional = num - math.floor(num)\n        if fractional >= 0.5:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    else:\n        fractional = math.ceil(num) - num\n        if fractional >= 0.5:\n            return math.floor(num)\n        else:\n            return math.ceil(num)", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == int(num):\n        return int(num)\n    if num > 0:\n        fractional = num - math.floor(num)\n        if fractional >= 0.5:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    else:\n        fractional = math.ceil(num) - num\n        if fractional >= 0.5:\n            return math.floor(num)\n        else:\n            return math.ceil(num)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/100", "requirement": "def make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    Each subsequent level has 2 more stones than the previous level, regardless of whether n is odd or even.\n    Return the number of stones in each level in a list, where the element at index i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        current += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        current += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/101", "requirement": "```python\nfrom typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n\n    The behavior is defined as follows:\n    1. Leading and trailing whitespace in the input string should be ignored.\n    2. Consecutive delimiters (commas or whitespace) should be treated as a single delimiter.\n    3. Empty input strings or strings containing only delimiters should produce an empty list.\n    4. Only spaces and commas are considered delimiters; other whitespace characters are ignored.\n\n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    words_string(\"   \") == []\n    words_string(\"\") == []\n    \"\"\"\n```", "generated_programs": ["from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[ ,]+', s)\n    return [word for word in words if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[,\\\\s]+', s)\n    return [word for word in words if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[,\\\\s]+', s)\n    return [word for word in words if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[,\\\\s]+', s)\n    return [word for word in words if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[,\\\\s]+', s)\n    return [word for word in words if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[,\\\\s]+', s)\n    return [word for word in words if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[,\\\\s]+', s)\n    return [word for word in words if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return [word for word in re.split('[,\\\\s]+', s) if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[,\\\\s]+', s)\n    return [word for word in words if word]"], "result": {"repaired_passk": 0.19999999999999996, "cross_model_passk": 0.8, "original_passk": 0.0}}
{"task_id": "HumanEval/102", "requirement": "def choose_num(x: int, y: int) -> int:\n    \"\"\"This function takes two positive integers x and y and returns the \n    largest even integer within the range [x, y] inclusive. If x is greater \n    than y, or if there are no even numbers in the range, the function \n    should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"", "generated_programs": ["def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    even_num = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            even_num = num\n            break\n    return even_num", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    if x == y:\n        return x if x % 2 == 0 else -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.4}}
{"task_id": "HumanEval/104", "requirement": "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    \"\"\"Given a list of integers x, return a sorted list of all positive \n    integers from x that do not contain any even digit.\n\n    Notes:\n    - A positive integer is defined as any integer greater than 0.\n    - A digit is considered even if it is one of {0, 2, 4, 6, 8}.\n    - The function should exclude any number that contains at least one even digit.\n    - The returned list should be sorted in increasing order.\n    - If no valid numbers exist in the input, the function should return an empty list.\n\n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if num > 0 and (not contains_even_digit(num))]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if num > 0 and (not contains_even_digit(num))]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if num > 0 and (not contains_even_digit(num))]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if num > 0 and (not contains_even_digit(num))]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = []\n    for num in x:\n        if num > 0 and (not contains_even_digit(num)):\n            result.append(num)\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    result = []\n    for num in x:\n        if num > 0:\n            has_even_digit = False\n            for digit in str(num):\n                if int(digit) % 2 == 0:\n                    has_even_digit = True\n                    break\n            if not has_even_digit:\n                result.append(num)\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit in {0, 2, 4, 6, 8}:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if num > 0 and (not contains_even_digit(num))]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit in {0, 2, 4, 6, 8}:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if num > 0 and (not has_even_digit(num))]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit in {0, 2, 4, 6, 8}:\n                return True\n            n //= 10\n        return False\n    result = [num for num in x if num > 0 and (not contains_even_digit(num))]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit in {0, 2, 4, 6, 8}:\n                return True\n            n = n // 10\n        return False\n    result = [n for n in x if n > 0 and (not contains_even_digit(n))]\n    return sorted(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/107", "requirement": "def even_odd_palindrome(n: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a positive integer n, return a tuple containing the count of even and odd \n    integer palindromes within the range [1, n], inclusive.\n\n    An integer palindrome is a number that reads the same forward and backward.\n\n    The first element of the tuple represents the count of even integer palindromes, \n    and the second element represents the count of odd integer palindromes.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindromes are 1, 2, 3. One of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindromes are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Four of them are even, and six of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. The returned tuple contains the count of even and odd integer palindromes, respectively.\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "def count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements in the array for which the sum of their signed digits is greater than 0.\n    Signed digits are determined as follows:\n    - If a number is negative, its first signed digit is negative, followed by the absolute values of its remaining digits.\n      For example, -123 has signed digits [-1, 2, 3].\n    - If a number is positive, all its digits are treated as positive.\n      For example, 123 has signed digits [1, 2, 3].\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        if num < 0:\n            digits = [-int(str(num)[1])] + [int(d) for d in str(num)[2:]]\n        else:\n            digits = [int(d) for d in str(num)]\n        if sum(digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        signed_digits = []\n        s = str(abs(num))\n        for i, digit in enumerate(s):\n            if i == 0 and num < 0:\n                signed_digits.append(-int(digit))\n            else:\n                signed_digits.append(int(digit))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        signed_digits = []\n        for i, char in enumerate(s):\n            if i == 0 and char == '-':\n                signed_digits.append(-int(s[1]))\n            else:\n                signed_digits.append(int(char))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        signed_digits = []\n        s = str(num)\n        for i, char in enumerate(s):\n            if char == '-':\n                continue\n            if i == 0 and s[0] == '-':\n                signed_digits.append(-int(char))\n            else:\n                signed_digits.append(int(char))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        signed_digits = []\n        s = str(num)\n        if s[0] == '-':\n            signed_digits.append(-int(s[1]))\n            for c in s[2:]:\n                signed_digits.append(int(c))\n        else:\n            for c in s:\n                signed_digits.append(int(c))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        signed_digits = []\n        s = str(num)\n        if s[0] == '-':\n            signed_digits.append(-int(s[1]))\n            for c in s[2:]:\n                signed_digits.append(int(c))\n        else:\n            for c in s:\n                signed_digits.append(int(c))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        signed_digits = []\n        num_str = str(num)\n        if num_str[0] == '-':\n            signed_digits.append(-int(num_str[1]))\n            for digit in num_str[2:]:\n                signed_digits.append(int(digit))\n        else:\n            for digit in num_str:\n                signed_digits.append(int(digit))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        signed_digits = []\n        num_str = str(num)\n        if num_str[0] == '-':\n            signed_digits.append(-int(num_str[1]))\n            for digit in num_str[2:]:\n                signed_digits.append(int(digit))\n        else:\n            for digit in num_str:\n                signed_digits.append(int(digit))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        signed_digits = []\n        for i, ch in enumerate(s):\n            if ch == '-':\n                continue\n            if i == 0 and s[0] == '-':\n                signed_digits.append(-int(ch))\n            else:\n                signed_digits.append(int(ch))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        signed_digits = []\n        num_str = str(num)\n        if num < 0:\n            signed_digits.append(int(num_str[0] + num_str[1]))\n            for i in range(2, len(num_str)):\n                signed_digits.append(int(num_str[i]))\n        else:\n            for digit in num_str:\n                signed_digits.append(int(digit))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.7, "original_passk": 0.9}}
{"task_id": "HumanEval/109", "requirement": "```python\nfrom typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    \"\"\"\n    We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The numbers \n    in the array will be randomly ordered. Your task is to determine if it is \n    possible to get an array sorted in non-decreasing order by performing the \n    following operation on the given array:\n    \n        You are allowed to perform right shift operation any number of times.\n\n    One right shift operation means shifting all elements of the array by one \n    position in the right direction. The last element of the array will be moved \n    to the starting position in the array i.e., 0th index.\n\n    To determine if the array can be sorted in non-decreasing order:\n    - The array is considered sorted in non-decreasing order if every subsequent \n      element is greater than or equal to its predecessor, and this order wraps \n      around from the last element to the first element after performing the \n      necessary right shifts.\n    - Specifically, the array can be sorted if there is at most one \"break point\" \n      where the order of elements transitions from decreasing to increasing, and \n      the first element after wrapping is greater than or equal to the last element.\n\n    If the given array is empty, return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2]) ==> True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n                 \n    move_one_ball([3, 5, 4, 1, 2]) ==> False\n    Explanation: It is not possible to get non-decreasing order for the given\n                 array by performing any number of right shift operations.\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    break_points = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            break_points += 1\n    return break_points <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    break_points = 0\n    for i in range(n):\n        if arr[(i + 1) % n] < arr[i]:\n            break_points += 1\n    return break_points <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    break_points = 0\n    n = len(arr)\n    for i in range(n):\n        next_index = (i + 1) % n\n        if arr[i] > arr[next_index]:\n            break_points += 1\n    return break_points <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    break_points = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            break_points += 1\n            if break_points > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    break_points = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            break_points += 1\n    return break_points <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    breaks = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            breaks += 1\n            if breaks > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    breaks = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            breaks += 1\n        if breaks > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    breaks = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            breaks += 1\n            if breaks > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    break_p = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            break_p += 1\n    return break_p <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    breaks = 0\n    for i in range(n):\n        current = arr[i]\n        next_val = arr[(i + 1) % n]\n        if current > next_val:\n            breaks += 1\n            if breaks > 1:\n                return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/110", "requirement": "def exchange(lst1: List[int], lst2: List[int]) -> str:\n    \"\"\"Implement a function that takes two lists of integers, lst1 and lst2, \n    and determines whether it is possible to exchange elements between them \n    to make all elements in lst1 even. \n\n    The function checks if the number of odd elements in lst1 can be replaced \n    by an equal or greater number of even elements from lst2. If this condition \n    is met, return \"YES\". Otherwise, return \"NO\".\n\n    Examples:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n\n    Assumptions:\n    - Both input lists are non-empty.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_in_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_in_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    count_odd_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    count_even_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if count_even_lst2 >= count_odd_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/111", "requirement": "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    \"\"\"Given a string representing space-separated lowercase words, return a dictionary\n    of the word(s) with the most repetition and the corresponding count. The input string \n    will be processed as follows:\n    \n    1. Trim leading and trailing whitespace before processing.\n    2. Words are defined as sequences of one or more lowercase English letters. Ignore all\n       non-alphabetic characters (e.g., numbers, punctuation, mixed-case strings).\n    3. If the input string is empty or contains no valid words, return an empty dictionary.\n    4. In cases where multiple words have the same maximum frequency, include all such words \n       in the output dictionary. \n\n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n    \"\"\"", "generated_programs": ["from typing import Dict\nimport re\n\ndef histogram(test: str) -> Dict[str, int]:\n    test = test.strip()\n    words = re.findall('\\\\b[a-z]+\\\\b', test)\n    if not words:\n        return {}\n    freq = {}\n    for word in words:\n        freq[word] = freq.get(word, 0) + 1\n    max_count = max(freq.values(), default=0)\n    result = {word: count for word, count in freq.items() if count == max_count}\n    return result", "from typing import Dict\nimport re\n\ndef histogram(test: str) -> Dict[str, int]:\n    test = test.strip()\n    words = re.findall('\\\\b[a-z]+\\\\b', test)\n    if not words:\n        return {}\n    word_counts = {}\n    for word in words:\n        word_counts[word] = word_counts.get(word, 0) + 1\n    max_count = max(word_counts.values(), default=0)\n    return {word: count for word, count in word_counts.items() if count == max_count}", "from typing import Dict\nimport re\n\ndef histogram(test: str) -> Dict[str, int]:\n    test = test.strip()\n    words = re.findall('\\\\b[a-z]+\\\\b', test)\n    if not words:\n        return {}\n    word_counts = {}\n    for word in words:\n        if word in word_counts:\n            word_counts[word] += 1\n        else:\n            word_counts[word] = 1\n    max_count = max(word_counts.values(), default=0)\n    return {word: count for word, count in word_counts.items() if count == max_count}", "from typing import Dict\nimport re\n\ndef histogram(test: str) -> Dict[str, int]:\n    test = test.strip()\n    words = re.findall('\\\\b[a-z]+\\\\b', test)\n    if not words:\n        return {}\n    word_counts = {}\n    for word in words:\n        if word in word_counts:\n            word_counts[word] += 1\n        else:\n            word_counts[word] = 1\n    max_count = max(word_counts.values(), default=0)\n    result = {word: count for word, count in word_counts.items() if count == max_count}\n    return result", "from typing import Dict\nimport re\n\ndef histogram(test: str) -> Dict[str, int]:\n    test = test.strip()\n    words = re.findall('\\\\b[a-z]+\\\\b', test)\n    if not words:\n        return {}\n    word_counts = {}\n    for word in words:\n        if word in word_counts:\n            word_counts[word] += 1\n        else:\n            word_counts[word] = 1\n    max_count = max(word_counts.values(), default=0)\n    result = {word: count for word, count in word_counts.items() if count == max_count}\n    return result", "from typing import Dict\nimport re\n\ndef histogram(test: str) -> Dict[str, int]:\n    test = test.strip()\n    if not test:\n        return {}\n    words = re.findall('\\\\b[a-z]+\\\\b', test)\n    if not words:\n        return {}\n    word_counts = {}\n    for word in words:\n        if word in word_counts:\n            word_counts[word] += 1\n        else:\n            word_counts[word] = 1\n    max_count = max(word_counts.values(), default=0)\n    result = {word: count for word, count in word_counts.items() if count == max_count}\n    return result", "from typing import Dict\nimport re\n\ndef histogram(test: str) -> Dict[str, int]:\n    test = test.strip()\n    if not test:\n        return {}\n    words = re.findall('\\\\b[a-z]+\\\\b', test)\n    if not words:\n        return {}\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    max_count = max(word_count.values(), default=0)\n    result = {word: count for word, count in word_count.items() if count == max_count}\n    return result", "from typing import Dict\nimport re\n\ndef histogram(test: str) -> Dict[str, int]:\n    test = test.strip()\n    words = re.findall('\\\\b[a-z]+\\\\b', test)\n    if not words:\n        return {}\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    max_count = max(word_count.values()) if word_count else 0\n    result = {word: cnt for word, cnt in word_count.items() if cnt == max_count}\n    return result", "from typing import Dict\nimport re\n\ndef histogram(test: str) -> Dict[str, int]:\n    test = test.strip()\n    if not test:\n        return {}\n    words = re.findall('\\\\b[a-z]+\\\\b', test)\n    if not words:\n        return {}\n    word_counts = {}\n    for word in words:\n        if word in word_counts:\n            word_counts[word] += 1\n        else:\n            word_counts[word] = 1\n    max_count = max(word_counts.values())\n    result = {word: count for word, count in word_counts.items() if count == max_count}\n    return result", "from typing import Dict\nimport re\n\ndef histogram(test: str) -> Dict[str, int]:\n    test = test.strip()\n    if not test:\n        return {}\n    words = re.findall('\\\\b[a-z]+\\\\b', test)\n    if not words:\n        return {}\n    word_counts = {}\n    for word in words:\n        if word in word_counts:\n            word_counts[word] += 1\n        else:\n            word_counts[word] = 1\n    max_count = max(word_counts.values()) if word_counts else 0\n    result = {word: count for word, count in word_counts.items() if count == max_count}\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/113", "requirement": "```python\nfrom typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output corresponds to the i-th string in the input and is formatted as:\n    \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n    where {count} is the number of odd digits in the i-th input string.\n\n    Behavior details:\n    1. The function processes each input string, counting the number of odd digits ('1', '3', '5', '7', '9') it contains.\n    2. For every input string, an output string is generated using the specified format, substituting {count} with the count of odd digits.\n    3. If a string contains zero odd digits, {count} is replaced with 0, and the string is still included in the output list.\n    4. The output list maintains a one-to-one correspondence with the input list, preserving the order of input strings.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    >>> odd_count(['24680'])\n    [\"the number of odd elements 0n the str0ng 0 of the 0nput.\"]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count = sum((1 for char in s if char in '13579'))\n        output = f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.'\n        result.append(output)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count = sum((1 for c in s if c in {'1', '3', '5', '7', '9'}))\n        result.append(f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.')\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count = sum((1 for char in s if char in '13579'))\n        formatted_str = f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.'\n        result.append(formatted_str)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count = sum((1 for c in s if c in {'1', '3', '5', '7', '9'}))\n        output = f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.'\n        result.append(output)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count = sum((1 for c in s if c in '13579'))\n        formatted_str = f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.'\n        result.append(formatted_str)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count = sum((1 for c in s if c in {'1', '3', '5', '7', '9'}))\n        result.append(f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.')\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count = sum((1 for char in s if char in '13579'))\n        output = f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.'\n        result.append(output)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count = sum((1 for char in s if char in '13579'))\n        formatted_str = f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.'\n        result.append(formatted_str)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count = sum((1 for char in s if char in {'1', '3', '5', '7', '9'}))\n        result.append(f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.')\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        count = sum((1 for char in s if char in {'1', '3', '5', '7', '9'}))\n        output = f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.'\n        result.append(output)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/114", "requirement": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums. A sub-array is a contiguous portion of the array. The function should \n    return the smallest possible sum of such sub-arrays. If the input array is empty, \n    the function should return float('inf').\n\n    Example:\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    minSubArraySum([]) == float('inf')\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        current_sum = min(current_sum, 0)\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/115", "requirement": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each cell in the grid represents a single unit of water, \n    where 1 indicates a unit of water and 0 indicates an empty cell. Your task is to use buckets to \n    extract all the water from the grid. All buckets have the same capacity.\n\n    The number of times you need to lower the buckets is calculated globally across the entire grid, \n    by summing all the water units in the grid and dividing the total by the bucket capacity, rounding up.\n\n    Output the total number of times the buckets need to be lowered to empty all the wells.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * The grid is rectangular, and all rows have the same length.\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[0].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if total_water > 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    if total_water == 0:\n        return 0\n    return math.ceil(total_water / capacity)", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    if capacity == 0:\n        return 0\n    return math.ceil(total_water / capacity)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(abs(x)).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(abs(x)).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x & 4294967295).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x if x >= 0 else -x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x if x >= 0 else -x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x if x >= 0 else (1 << 32) + x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x if x >= 0 else -x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x if x >= 0 else (1 << 32) + x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x if x >= 0 else (1 << 32) + x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(n & 4294967295).count('1') if n < 0 else bin(n).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.5, "original_passk": 1.0}}
{"task_id": "HumanEval/118", "requirement": "def get_closest_vowel(word: str) -> str:\n    \"\"\"You are given a word. Your task is to find the closest vowel that is surrounded \n    by consonants on both sides (case sensitive) when traversing the word from right to left.\n\n    Specifically:\n    - A vowel is considered valid if it is preceded by a consonant and followed by another consonant.\n    - Vowels at the beginning or end of the word are not considered.\n    - If no such vowel is found, return an empty string.\n\n    You may assume that the given string contains English letters only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"", "generated_programs": ["def get_closest_vowel(word: str) -> str:\n    vowels = 'AEIOUaeiou'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = 'AEIOUaeiou'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = 'AEIOUaeiou'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = 'AEIOUaeiou'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = set('AEIOUaeiou')\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = 'AEIOUaeiou'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "code\n\ndef get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/122", "requirement": "def add_elements(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements from the first k elements of arr that have at most two digits \n    (i.e., values between -99 and 99 inclusive).\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((x for x in arr[:k] if -99 <= x <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((x for x in arr[:k] if -99 <= x <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    sum_result = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99 and count < k:\n            sum_result += num\n            count += 1\n    return sum_result", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    result = 0\n    count = 0\n    for num in arr:\n        if count >= k:\n            break\n        if -99 <= num <= 99:\n            result += num\n            count += 1\n    return result", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    result = 0\n    count = 0\n    for num in arr:\n        if count >= k:\n            break\n        if -99 <= num <= 99:\n            result += num\n            count += 1\n    return result", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    count = 0\n    total = 0\n    for num in arr:\n        if count >= k:\n            break\n        if -99 <= num <= 99:\n            total += num\n            count += 1\n    return total", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    sum_elements = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99 and count < k:\n            sum_elements += num\n            count += 1\n    return sum_elements", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    total = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99:\n            total += num\n            count += 1\n        if count == k:\n            break\n    return total", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    sum_elements = 0\n    count = 0\n    for num in arr:\n        if count >= k:\n            break\n        if -99 <= num <= 99:\n            sum_elements += num\n            count += 1\n    return sum_elements", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    sum_elements = 0\n    count = 0\n    for num in arr:\n        if count >= k:\n            break\n        if -99 <= num <= 99:\n            sum_elements += num\n            count += 1\n    return sum_elements"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.19999999999999996, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/124", "requirement": "```python\ndef valid_date(date: str) -> bool:\n    \"\"\"\n    You have to write a function which validates a given date string and\n    returns True if the date is valid, otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    \n    1. The date string is not empty.\n    2. The date string must strictly follow the format: mm-dd-yyyy.\n       - The month (mm) must be a two-digit number between 01 and 12.\n       - The day (dd) must be a two-digit number:\n         - Between 01 and 31 for months 01, 03, 05, 07, 08, 10, 12.\n         - Between 01 and 30 for months 04, 06, 09, 11.\n         - Between 01 and 29 for month 02 (February).\n       - The year (yyyy) must be a four-digit number.\n    3. The function does not need to account for leap years. February 29 is always considered valid regardless of the year.\n    4. The function must reject malformed input strings, such as those with incorrect delimiters (e.g., '06/04/2020') or missing components (e.g., '06-2020').\n    5. The function must reject invalid values such as '00' for the day or month. Specifically:\n       - '00' is not a valid value for the month (mm).\n       - '00' is not a valid value for the day (dd).\n    6. The function must perform strict manual validation and must not rely on external libraries like `datetime`.\n\n    Examples:\n    valid_date('03-11-2000') => True\n    valid_date('15-01-2012') => False\n    valid_date('04-0-2040') => False\n    valid_date('06-04-2020') => True\n    valid_date('06/04/2020') => False\n    \"\"\"\n```", "generated_programs": ["def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    try:\n        mm = int(date[:2])\n        dd = int(date[3:5])\n        yyyy = int(date[6:])\n    except ValueError:\n        return False\n    if mm < 1 or mm > 12 or dd < 1 or (dd > 31) or (yyyy < 1000) or (yyyy > 9999):\n        return False\n    if mm in {4, 6, 9, 11} and dd > 30:\n        return False\n    if mm == 2 and dd > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    month, day, year = date.split('-')\n    if not (month.isdigit() and day.isdigit() and year.isdigit()):\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if day < 1 or day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    try:\n        mm = int(date[0:2])\n        dd = int(date[3:5])\n        yyyy = int(date[6:10])\n    except ValueError:\n        return False\n    if mm < 1 or mm > 12 or dd < 1 or (dd > 31) or (yyyy < 1000) or (yyyy > 9999):\n        return False\n    if mm in {4, 6, 9, 11} and dd > 30:\n        return False\n    if mm == 2 and dd > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if not (mm.isdigit() and dd.isdigit() and yyyy.isdigit()):\n        return False\n    mm = int(mm)\n    dd = int(dd)\n    yyyy = int(yyyy)\n    if mm < 1 or mm > 12:\n        return False\n    if dd < 1 or dd > 31:\n        return False\n    if mm in {4, 6, 9, 11} and dd > 30:\n        return False\n    if mm == 2 and dd > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if not (mm.isdigit() and dd.isdigit() and yyyy.isdigit()):\n        return False\n    if len(yyyy) != 4:\n        return False\n    mm = int(mm)\n    dd = int(dd)\n    if mm < 1 or mm > 12:\n        return False\n    if dd < 1 or dd > 31:\n        return False\n    if mm in {4, 6, 9, 11} and dd > 30:\n        return False\n    if mm == 2 and dd > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if not (mm.isdigit() and dd.isdigit() and yyyy.isdigit()):\n        return False\n    mm = int(mm)\n    dd = int(dd)\n    yyyy = int(yyyy)\n    if mm < 1 or mm > 12:\n        return False\n    if dd < 1 or dd > 31:\n        return False\n    if mm in {4, 6, 9, 11} and dd > 30:\n        return False\n    if mm == 2 and dd > 29:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if not (mm.isdigit() and dd.isdigit() and yyyy.isdigit()):\n        return False\n    mm = int(mm)\n    dd = int(dd)\n    yyyy = int(yyyy)\n    if mm < 1 or mm > 12:\n        return False\n    if dd < 1 or dd > 31:\n        return False\n    if mm in {4, 6, 9, 11} and dd > 30:\n        return False\n    if mm == 2 and dd > 29:\n        return False\n    if len(str(yyyy)) != 4:\n        return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    try:\n        mm, dd, yyyy = date.split('-')\n        if len(mm) != 2 or len(dd) != 2 or len(yyyy) != 4:\n            return False\n        mm = int(mm)\n        dd = int(dd)\n        yyyy = int(yyyy)\n        if mm < 1 or mm > 12 or dd < 1 or (dd > 31):\n            return False\n        if mm in {1, 3, 5, 7, 8, 10, 12} and dd > 31:\n            return False\n        if mm in {4, 6, 9, 11} and dd > 30:\n            return False\n        if mm == 2 and dd > 29:\n            return False\n        return True\n    except ValueError:\n        return False", "def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    try:\n        mm, dd, yyyy = date.split('-')\n        if len(mm) != 2 or len(dd) != 2 or len(yyyy) != 4:\n            return False\n        mm = int(mm)\n        dd = int(dd)\n        yyyy = int(yyyy)\n        if mm < 1 or mm > 12 or dd < 1:\n            return False\n        if mm in {1, 3, 5, 7, 8, 10, 12}:\n            if dd > 31:\n                return False\n        elif mm in {4, 6, 9, 11}:\n            if dd > 30:\n                return False\n        elif dd > 29:\n            return False\n        return True\n    except ValueError:\n        return False", "def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if not (mm.isdigit() and dd.isdigit() and yyyy.isdigit()):\n        return False\n    if len(mm) != 2 or len(dd) != 2 or len(yyyy) != 4:\n        return False\n    mm = int(mm)\n    dd = int(dd)\n    yyyy = int(yyyy)\n    if mm < 1 or mm > 12 or dd < 1:\n        return False\n    if mm in {1, 3, 5, 7, 8, 10, 12}:\n        if dd > 31:\n            return False\n    elif mm in {4, 6, 9, 11}:\n        if dd > 30:\n            return False\n    elif mm == 2:\n        if dd > 29:\n            return False\n    return True"], "result": {"repaired_passk": 0.875, "cross_model_passk": 0.4, "original_passk": 0.0}}
{"task_id": "HumanEval/126", "requirement": "def is_sorted(lst: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return whether or not they are sorted in ascending order.\n    Additionally, if any number appears more than twice in the list, return False.\n    Assume the list contains only non-negative integers.\n\n    Examples:\n    is_sorted([5])  True\n    is_sorted([1, 2, 3, 4, 5])  True\n    is_sorted([1, 3, 2, 4, 5])  False\n    is_sorted([1, 2, 3, 4, 5, 6])  True\n    is_sorted([1, 2, 3, 4, 5, 6, 7])  True\n    is_sorted([1, 3, 2, 4, 5, 6, 7])  False\n    is_sorted([1, 2, 2, 3, 3, 4])  True\n    is_sorted([1, 2, 2, 2, 3, 4])  False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if any((lst.count(x) > 2 for x in lst)):\n        return False\n    return all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1)))", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if lst != sorted(lst):\n        return False\n    count = Counter(lst)\n    for num in count:\n        if count[num] > 2:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not lst:\n        return True\n    if max(Counter(lst).values()) > 2:\n        return False\n    return all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1)))", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if lst != sorted(lst):\n        return False\n    from collections import defaultdict\n    freq = defaultdict(int)\n    for num in lst:\n        freq[num] += 1\n        if freq[num] > 2:\n            return False\n    return True", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if lst != sorted(lst):\n        return False\n    from collections import Counter\n    counts = Counter(lst)\n    if any((count > 2 for count in counts.values())):\n        return False\n    return True", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1))):\n        return False\n    count = {}\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > 2:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    counts = Counter(lst)\n    if any((v > 2 for v in counts.values())):\n        return False\n    return all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1)))", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if len(lst) == 0:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    from collections import Counter\n    counts = Counter(lst)\n    for num, count in counts.items():\n        if count > 2:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not lst:\n        return True\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n    counts = Counter(lst)\n    for num, cnt in counts.items():\n        if cnt > 2:\n            return False\n    return True", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if len(lst) == 0:\n        return True\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n        if counts[num] > 2:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/127", "requirement": "from typing import Tuple\n\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\nimport math\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(math.sqrt(length)) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    a1, a2 = interval1\n    b1, b2 = interval2\n    start = max(a1, b1)\n    end = min(a2, b2)\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    lower_bound = max(start1, start2)\n    upper_bound = min(end1, end2)\n    if lower_bound > upper_bound:\n        return 'NO'\n    length = upper_bound - lower_bound\n    if is_prime(length + 1):\n        return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start + 1\n    if length < 0:\n        return 'NO'\n    return 'YES' if is_prime(length) else 'NO'"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/129", "requirement": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the lexicographically smallest path of length k in the grid. \n    A path of length k means visiting exactly k cells (not necessarily distinct). \n    You can start from any cell, and in each step, you can move to any of the \n    neighbor cells, i.e., cells that share an edge with your current cell. \n    You CANNOT go off the grid.\n\n    A path A (of length k) is considered less than a path B (of length k) if, \n    after making the ordered lists of the values on the cells that A and B go \n    through (let's call them lst_A and lst_B), lst_A is lexicographically less \n    than lst_B. In other words, there exists an integer index i (1 <= i <= k) \n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i), we have \n    lst_A[j] = lst_B[j].\n\n    Additional clarifications:\n    1. The lexicographical comparison is applied to the **cell values** on the \n       path, not the sum or any other metric.\n    2. Paths may revisit the same cell multiple times, as long as the total \n       number of visited cells is exactly k.\n    3. The search for the lexicographically smallest path considers all possible \n       starting cells in the grid equally. The starting cell does not influence \n       the comparison of paths beyond its inclusion in the path values.\n    4. The lexicographically smallest path is determined by exhaustively exploring \n       all valid paths of length k from every possible starting cell in the grid. \n       Neighboring cells are explored recursively without any implicit priority \n       mechanism, and revisiting cells is allowed.\n    5. If multiple paths have the same lexicographical values, the guarantee of \n       uniqueness ensures that only one valid path exists as the answer.\n\n    It is guaranteed that the answer is unique.\n\n    Return an ordered list of the values on the cells that the lexicographically \n    smallest path of length k goes through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    all_paths = []\n\n    def dfs(row, col, path, remaining_steps):\n        if remaining_steps == 0:\n            all_paths.append(path)\n            return\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = (row + dr, col + dc)\n            if 0 <= nr < N and 0 <= nc < N:\n                dfs(nr, nc, path + [grid[nr][nc]], remaining_steps - 1)\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]], k - 1)\n    all_paths.sort()\n    return all_paths[0]", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    min_path = None\n\n    def dfs(x, y, path, remaining):\n        nonlocal min_path\n        if remaining == 0:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]], remaining - 1)\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]], k - 1)\n    return min_path", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_path = None\n\n    def dfs(i, j, path):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            x, y = (i + dx, j + dy)\n            if 0 <= x < n and 0 <= y < n:\n                dfs(x, y, path + [grid[x][y]])\n    for i, j in product(range(n), range(n)):\n        dfs(i, j, [grid[i][j]])\n    return min_path", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_path = [float('inf')] * k\n\n    def dfs(i, j, path):\n        nonlocal min_path\n        if len(path) == k:\n            if path < min_path:\n                min_path = path.copy()\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            x, y = (i + dx, j + dy)\n            if 0 <= x < n and 0 <= y < n:\n                dfs(x, y, path + [grid[x][y]])\n    for i, j in product(range(n), range(n)):\n        dfs(i, j, [grid[i][j]])\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def dfs(x, y, path, visited):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path.copy()\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                dfs(nx, ny, path + [grid[nx][ny]], visited | {(nx, ny)})\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, [grid[i][j]], set())\n    return min_path", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(i, j, path):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            x, y = (i + dx, j + dy)\n            if 0 <= x < n and 0 <= y < n:\n                new_path = path + [grid[x][y]]\n                candidate = dfs(x, y, new_path)\n                if candidate is not None:\n                    if min_path is None or candidate < min_path:\n                        min_path = candidate\n        return min_path\n    min_result = None\n    for i, j in product(range(n), range(n)):\n        path = [grid[i][j]]\n        candidate = dfs(i, j, path)\n        if candidate is not None:\n            if min_result is None or candidate < min_result:\n                min_result = candidate\n    return min_result", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path\n        res = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [grid[nx][ny]]\n                candidate = dfs(nx, ny, new_path)\n                if candidate is not None:\n                    if res is None or candidate < res:\n                        res = candidate\n        return res\n    min_path = None\n    for i in range(n):\n        for j in range(n):\n            candidate = dfs(i, j, [grid[i][j]])\n            if candidate is not None:\n                if min_path is None or candidate < min_path:\n                    min_path = candidate\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def dfs(x, y, path, visited, remaining):\n        if remaining == 0:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [grid[nx][ny]]\n                if min_path is None or new_path < min_path:\n                    result = dfs(nx, ny, new_path, visited, remaining - 1)\n                    if result is not None:\n                        if min_path is None or result < min_path:\n                            min_path = result\n        return min_path\n    overall_min = None\n    for i in range(n):\n        for j in range(n):\n            initial_path = [grid[i][j]]\n            result = dfs(i, j, initial_path, set(), k - 1)\n            if result is not None:\n                if overall_min is None or result < overall_min:\n                    overall_min = result\n    return overall_min", "from typing import List\nimport sys\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, path, visited):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [grid[nx][ny]]\n                if min_path is None or new_path < min_path:\n                    new_visited = visited.copy()\n                    if (nx, ny) in new_visited:\n                        continue\n                    new_visited.add((nx, ny))\n                    candidate = dfs(nx, ny, new_path, new_visited)\n                    if candidate is not None and (min_path is None or candidate < min_path):\n                        min_path = candidate\n        return min_path\n    result = None\n    for i in range(N):\n        for j in range(N):\n            path = dfs(i, j, [grid[i][j]], set([(i, j)]))\n            if path is not None and (result is None or path < result):\n                result = path\n    return result", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n\n\n    def dfs(x, y, path, visited_cells):\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if is_valid(nx, ny):\n                new_path = path + [grid[nx][ny]]\n                new_visited = visited_cells.copy()\n                new_visited.add((nx, ny))\n                result = dfs(nx, ny, new_path, new_visited)\n                if result:\n                    return result\n        return None\n    min_path = None\n    for i, j in product(range(n), range(n)):\n        current_path = [grid[i][j]]\n        visited = set()\n        visited.add((i, j))\n        result = dfs(i, j, current_path, visited)\n        if result:\n            if min_path is None or result < min_path:\n                min_path = result\n    return min_path"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.8, "original_passk": 0.5}}
{"task_id": "HumanEval/130", "requirement": "def tri(n: int) -> List[float]:\n    \"\"\"\n    The Tribonacci sequence is a variation of the Fibonacci sequence, defined as follows:\n    - tri(0) = 1.0\n    - tri(1) = 3.0\n    - For n > 1:\n      - If n is even: tri(n) = 1 + n / 2\n      - If n is odd: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)\n\n    The sequence is computed recursively, and for odd values of n, the term tri(n + 1) is calculated \n    using the same recurrence rules, even if n + 1 exceeds the input value n. This ensures that \n    all terms referenced in the formula are consistently defined.\n\n    The function returns a list of the first n + 1 numbers of the Tribonacci sequence, where each \n    term is computed recursively and memoized to avoid redundant calculations. All values in the \n    sequence are returned as floating-point numbers for consistency.\n\n    Examples:\n    tri(3) = [1.0, 3.0, 2.0, 8.0]\n    tri(4) = [1.0, 3.0, 2.0, 8.0, 3.0]\n    \"\"\"", "generated_programs": ["from typing import List\nfrom functools import lru_cache\n\ndef _tri(n: int) -> float:\n    if n == 0:\n        return 1.0\n    elif n == 1:\n        return 3.0\n    elif n % 2 == 0:\n        return 1 + n / 2\n    else:\n        return _tri(n - 1) + _tri(n - 2) + _tri(n + 1)\n\ndef tri(n: int) -> List[float]:\n    return [_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {0: 1.0, 1: 3.0}\n\n    def compute(k):\n        if k in memo:\n            return memo[k]\n        if k % 2 == 0:\n            memo[k] = 1 + k / 2\n        else:\n            memo[k] = compute(k - 1) + compute(k - 2) + compute(k + 1)\n        return memo[k]\n    for i in range(n + 1):\n        compute(i)\n    return [memo[i] for i in range(n + 1)]", "from typing import List\nfrom functools import lru_cache\n\ndef trib(n: int) -> float:\n    if n == 0:\n        return 1.0\n    elif n == 1:\n        return 3.0\n    elif n % 2 == 0:\n        return 1 + n / 2\n    else:\n        return trib(n - 1) + trib(n - 2) + trib(n + 1)\n\ndef tri(n: int) -> List[float]:\n    return [trib(i) for i in range(n + 1)]", "from typing import List\nfrom functools import lru_cache\n\ndef tri_recursive(n: int) -> float:\n    if n == 0:\n        return 1.0\n    elif n == 1:\n        return 3.0\n    elif n % 2 == 0:\n        return 1 + n / 2\n    else:\n        return tri_recursive(n - 1) + tri_recursive(n - 2) + tri_recursive(n + 1)\n\ndef tri(n: int) -> List[float]:\n    return [tri_recursive(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {}\n\n    def compute(k):\n        if k in memo:\n            return memo[k]\n        if k == 0:\n            memo[k] = 1.0\n        elif k == 1:\n            memo[k] = 3.0\n        elif k % 2 == 0:\n            memo[k] = 1 + k / 2\n        else:\n            memo[k] = compute(k - 1) + compute(k - 2) + compute(k + 1)\n        return memo[k]\n    result = []\n    for i in range(n + 1):\n        result.append(compute(i))\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {}\n\n    def tribonacci(k: int) -> float:\n        if k in memo:\n            return memo[k]\n        if k == 0:\n            memo[k] = 1.0\n        elif k == 1:\n            memo[k] = 3.0\n        elif k % 2 == 0:\n            memo[k] = 1 + k / 2\n        else:\n            memo[k] = tribonacci(k - 1) + tribonacci(k - 2) + tribonacci(k + 1)\n        return memo[k]\n    return [tribonacci(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {}\n\n    def compute_tri(n):\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            memo[0] = 1.0\n        elif n == 1:\n            memo[1] = 3.0\n        elif n % 2 == 0:\n            memo[n] = 1 + n / 2\n        else:\n            memo[n] = compute_tri(n - 1) + compute_tri(n - 2) + compute_tri(n + 1)\n        return memo[n]\n    compute_tri(n)\n    return [compute_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {}\n\n    def calculate_tri(k):\n        if k in memo:\n            return memo[k]\n        if k == 0:\n            memo[k] = 1.0\n        elif k == 1:\n            memo[k] = 3.0\n        elif k % 2 == 0:\n            memo[k] = 1 + k / 2\n        else:\n            memo[k] = calculate_tri(k - 1) + calculate_tri(k - 2) + calculate_tri(k + 1)\n        return memo[k]\n    result = []\n    for i in range(n + 1):\n        result.append(calculate_tri(i))\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {}\n\n    def compute_tri(k):\n        if k in memo:\n            return memo[k]\n        if k == 0:\n            memo[k] = 1.0\n        elif k == 1:\n            memo[k] = 3.0\n        elif k % 2 == 0:\n            memo[k] = 1 + k / 2\n        else:\n            memo[k] = compute_tri(k - 1) + compute_tri(k - 2) + compute_tri(k + 1)\n        return memo[k]\n    return [compute_tri(i) for i in range(n + 1)]", "code\nfrom typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {}\n\n    def calculate_tri(k: int) -> float:\n        if k in memo:\n            return memo[k]\n        if k == 0:\n            memo[k] = 1.0\n        elif k == 1:\n            memo[k] = 3.0\n        elif k % 2 == 0:\n            memo[k] = 1 + k / 2\n        else:\n            memo[k] = calculate_tri(k - 1) + calculate_tri(k - 2) + calculate_tri(k + 1)\n        return memo[k]\n    return [calculate_tri(i) for i in range(n + 1)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    \"\"\"\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if the string contains a valid subsequence of brackets\n    where at least one pair of brackets is properly nested within another pair.\n\n    Definitions:\n    1. \"Nested\": A pair of brackets is considered nested if it is enclosed within another \n       valid pair of brackets. For example, in the sequence \"[[]]\", the inner \"[]\" is nested \n       within the outer \"[]\". Single-level pairs like \"[]\" or \"[][]\" are not considered nested.\n    2. \"Valid subsequence\": A valid subsequence is a contiguous portion of the string where \n       all brackets are properly balanced (i.e., every opening bracket '[' has a corresponding \n       closing bracket ']'). The function should only consider valid subsequences when \n       determining if nesting exists.\n    3. \"Imbalanced brackets\": If the input string contains unmatched or improperly ordered \n       brackets (e.g., \"[]]]]]]][[[[[]\"), the function should immediately return False.\n\n    The function should return True if there is at least one point in the string where a \n    closing bracket ']' is encountered and there is still at least one unmatched opening \n    bracket '[' remaining in the stack, indicating a nested structure.\n\n    Examples:\n    is_nested('[[]]')  True\n    is_nested('[]]]]]]][[[[[]')  False\n    is_nested('[][]')  False\n    is_nested('[]')  False\n    is_nested('[[][]]')  True\n    is_nested('[[]][[')  True\n    \"\"\"", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            if len(stack) > 1:\n                return True\n            stack.pop()\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n            if stack:\n                return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n            else:\n                return False\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n            if stack:\n                return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            if len(stack) > 1:\n                nested = True\n            stack.pop()\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n            if stack:\n                has_nested = True\n    return has_nested and (not stack)", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n            else:\n                return False\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n            else:\n                return False\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n            if stack:\n                has_nested = True\n    return has_nested and (not stack)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/134", "requirement": "```python\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    \"\"\"\n    Create a function that returns True if the last non-space character \n    of a given string is an alphabetical character and is the only \n    character in the last word. A word is defined as a group of \n    non-space characters separated by spaces. Trailing spaces are ignored \n    when determining the last word. If the string is empty or contains \n    only spaces, return False.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\")  False\n    check_if_last_char_is_a_letter(\"apple pi e\")  True\n    check_if_last_char_is_a_letter(\"apple pi e \")  False\n    check_if_last_char_is_a_letter(\"\")  False\n    \"\"\"\n```", "generated_programs": ["def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word[-1].isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word[-1].isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = re.split('\\\\s+', txt)[-1]\n    return len(last_word) == 1 and last_word[-1].isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped = txt.rstrip()\n    if not stripped:\n        return False\n    last_word = stripped.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    cleaned_txt = txt.rstrip()\n    if not cleaned_txt:\n        return False\n    last_word = re.split('\\\\s+', cleaned_txt)[-1]\n    return len(last_word) == 1 and last_word.isalpha()"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/137", "requirement": "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its original type.\n    The comparison is based on the numerical value of the inputs, after converting\n    strings to numbers where applicable. Return None if the values are numerically equal\n    or if either input is an invalid string that cannot be converted to a number.\n\n    Rules:\n    1. Strings representing real numbers may use either '.' or ',' as the decimal separator.\n       - Strings with ',' as the decimal separator will be converted to use '.' for parsing.\n       - If a string cannot be converted to a valid number (e.g., \"abc\"), it is treated as invalid,\n         and the function will return None.\n    2. The comparison is performed numerically:\n       - If one value is numerically greater, the function returns the original input\n         (retaining its type) that corresponds to the larger value.\n       - If the two values are numerically equal, the function returns None.\n    3. If either input is invalid (e.g., a string that cannot be converted to a number),\n       the function returns None immediately.\n\n    Examples:\n    compare_one(1, 2.5)  2.5\n    compare_one(1, \"2,3\")  \"2,3\"\n    compare_one(\"5,1\", \"6\")  \"6\"\n    compare_one(\"1\", 1)  None\n    \"\"\"", "generated_programs": ["from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert(x):\n        if isinstance(x, str):\n            x = x.replace(',', '.')\n            try:\n                return float(x)\n            except ValueError:\n                return None\n        return float(x)\n    a_num = convert(a)\n    b_num = convert(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    return a if a_num > b_num else b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_value(value):\n        if isinstance(value, str):\n            try:\n                value = value.replace(',', '.')\n                return float(value)\n            except ValueError:\n                return None\n        return float(value)\n    a_num = convert_value(a)\n    b_num = convert_value(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    return a if a_num > b_num else b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def parse_value(value):\n        if isinstance(value, (int, float)):\n            return value\n        if isinstance(value, str):\n            try:\n                value = value.replace(',', '.')\n                return float(value)\n            except ValueError:\n                return None\n        return None\n    parsed_a = parse_value(a)\n    parsed_b = parse_value(b)\n    if parsed_a is None or parsed_b is None or parsed_a == parsed_b:\n        return None\n    return a if parsed_a > parsed_b else b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def parse_value(value):\n        if isinstance(value, (int, float)):\n            return value\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        return None\n    val_a = parse_value(a)\n    val_b = parse_value(b)\n    if val_a is None or val_b is None:\n        return None\n    if val_a == val_b:\n        return None\n    return a if val_a > val_b else b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value):\n        if isinstance(value, str):\n            try:\n                value = value.replace(',', '.')\n                return float(value)\n            except ValueError:\n                return None\n        return float(value)\n    a_num = convert_to_float(a)\n    b_num = convert_to_float(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    return a if a_num > b_num else b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_number(s):\n        if isinstance(s, str):\n            s = s.replace(',', '.')\n            try:\n                return float(s)\n            except ValueError:\n                return None\n        return float(s)\n    a_num = convert_to_number(a)\n    b_num = convert_to_number(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    elif a_num > b_num:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value: Union[int, float, str]) -> Union[float, None]:\n        if isinstance(value, (int, float)):\n            return float(value)\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        return None\n    a_num = convert_to_float(a)\n    b_num = convert_to_float(b)\n    if a_num is None or b_num is None or a_num == b_num:\n        return None\n    return a if a_num > b_num else b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        elif isinstance(value, (int, float)):\n            return float(value)\n        else:\n            return None\n    a_float = to_float(a)\n    b_float = to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float == b_float:\n        return None\n    return a if a_float > b_float else b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_number(s):\n        if isinstance(s, str):\n            s = s.replace(',', '.')\n            try:\n                return float(s) if '.' in s else int(s)\n            except ValueError:\n                return None\n        elif isinstance(s, (int, float)):\n            return s\n        else:\n            return None\n    a_num = convert_to_number(a)\n    b_num = convert_to_number(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    return a if a_num > b_num else b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        elif isinstance(value, (int, float)):\n            return float(value)\n        else:\n            return None\n    a_num = to_float(a)\n    b_num = to_float(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    if a_num > b_num:\n        return a\n    else:\n        return b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/139", "requirement": "def special_factorial(n: int) -> int:\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n >= 0.\n\n    The function will receive a non-negative integer as input and should return \n    the special factorial of this integer. If n = 0, the result is defined as 1.\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    Input and expected output examples:\n    ### Test 1\n    Input: [0]\n    Expected Output: [1]\n    \"\"\"", "generated_programs": ["import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/140", "requirement": "```python\ndef fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, transform spaces according to the following rules:\n    1. Replace all single spaces with underscores (\"_\").\n    2. If there are more than 2 consecutive spaces in the original input, replace the entire group of consecutive spaces with a single hyphen (\"-\").\n    3. Transformations are applied sequentially in this order:\n       - First, replace single spaces with underscores, focusing solely on isolated spaces that are not part of larger consecutive groups.\n       - Next, replace groups of more than 2 consecutive spaces (from the original input text before the first transformation) with a hyphen.\n\n    Note: The second transformation disregards the changes made by the first transformation and operates directly on groups of consecutive spaces in the original input.\n\n    Examples:\n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('\\\\s', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('\\\\s', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    modified_text = re.sub('(?<!\\\\s)\\\\s(?!\\\\s)', '_', text)\n    result = re.sub('\\\\s{3,}', '-', modified_text)\n    return result", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('(?<!\\\\s)\\\\s(?!\\\\s)', '_', text)\n    text = re.sub('\\\\s{3,}', '-', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('\\\\s', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('(?<!\\\\s)\\\\s(?!\\\\s)', '_', text)\n    return text"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.4, "original_passk": 0.5}}
{"task_id": "HumanEval/141", "requirement": "```python\ndef file_name_check(file_name: str) -> str:\n    \"\"\"\n    Create a function which takes a string representing a file's name, and returns\n    'Yes' if the file's name is valid, and returns 'No' otherwise.\n    \n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the entire file's name.\n    - The file's name contains exactly one dot '.' in the entire string.\n    - The substring before the single dot should not be empty, and it must start with a \n      letter from the Latin alphabet ('a'-'z' and 'A'-'Z').\n    - The substring after the single dot must exactly match one of these extensions: \n      ['txt', 'exe', 'dll'] (case-sensitive).\n    \n    Additional clarifications:\n    - If the file name contains multiple dots, it is considered invalid.\n    - The function does not enforce any minimum or maximum length for the file name.\n    - Non-alphanumeric characters are allowed in the file name, except for the conditions \n      specified above.\n    - Empty strings are considered invalid.\n    \n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a Latin alphabet letter)\n    file_name_check(\"hello.world.txt\") # => 'No' (multiple dots are not allowed)\n    \"\"\"\n```", "generated_programs": ["def file_name_check(file_name: str) -> str:\n    extensions = {'txt', 'exe', 'dll'}\n    if not file_name or file_name.count('.') != 1:\n        return 'No'\n    name_part, extension = file_name.split('.')\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    if extension not in extensions:\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if not file_name:\n        return 'No'\n    if file_name.count('.') != 1:\n        return 'No'\n    name_part, extension = file_name.split('.')\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    if len(re.findall('\\\\d', file_name)) > 3:\n        return 'No'\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if not file_name:\n        return 'No'\n    if file_name.count('.') != 1:\n        return 'No'\n    name_part, ext_part = file_name.split('.')\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    if ext_part not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if not file_name:\n        return 'No'\n    if file_name.count('.') != 1:\n        return 'No'\n    name_part, extension = file_name.split('.')\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if not file_name:\n        return 'No'\n    if file_name.count('.') != 1:\n        return 'No'\n    name, extension = file_name.split('.')\n    if not name or not name[0].isalpha():\n        return 'No'\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    digit_count = sum((1 for char in file_name if char.isdigit()))\n    if digit_count > 3:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if not file_name:\n        return 'No'\n    digits = sum((c.isdigit() for c in file_name))\n    if digits > 3:\n        return 'No'\n    if file_name.count('.') != 1:\n        return 'No'\n    name, extension = file_name.split('.')\n    if not name or not name[0].isalpha():\n        return 'No'\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if not file_name:\n        return 'No'\n    if file_name.count('.') != 1:\n        return 'No'\n    name_part, extension = file_name.split('.')\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    digit_count = sum((c.isdigit() for c in file_name))\n    if digit_count > 3:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if not file_name:\n        return 'No'\n    if file_name.count('.') != 1:\n        return 'No'\n    name, ext = file_name.split('.')\n    if not name:\n        return 'No'\n    if not name[0].isalpha():\n        return 'No'\n    if ext not in ['txt', 'exe', 'dll']:\n        return 'No'\n    digit_count = sum((1 for char in file_name if char.isdigit()))\n    if digit_count > 3:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if not file_name:\n        return 'No'\n    dot_count = file_name.count('.')\n    if dot_count != 1:\n        return 'No'\n    name_part, extension = file_name.split('.')\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    valid_extensions = {'txt', 'exe', 'dll'}\n    if extension not in valid_extensions:\n        return 'No'\n    digit_count = sum((c.isdigit() for c in file_name))\n    if digit_count > 3:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if not file_name:\n        return 'No'\n    dot_count = file_name.count('.')\n    if dot_count != 1:\n        return 'No'\n    name_part, extension = file_name.split('.')\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    digit_count = sum((c.isdigit() for c in file_name))\n    if digit_count > 3:\n        return 'No'\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_digits(n):\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(num):\n        return sum((int(d) for d in str(abs(num))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "code\nfrom typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/146", "requirement": "def specialFilter(nums: List[int]) -> int:\n    \"\"\"Write a function that takes a list of integers as input and returns \n    the count of numbers in the list that satisfy the following conditions:\n    1. The number is strictly greater than 10 (not considering its absolute value).\n    2. Both the first and last digits of the absolute value of the number are odd \n       (odd digits are 1, 3, 5, 7, 9).\n\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 == 1 and last_digit % 2 == 1:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num <= 10:\n            continue\n        abs_num = abs(num)\n        first_digit = int(str(abs_num)[0])\n        last_digit = abs_num % 10\n        if first_digit % 2 != 0 and last_digit % 2 != 0:\n            count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = int(str(abs_num)[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/147", "requirement": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1  i  n), the value of a[i] is calculated as i * i - i + 1.\n    Return the number of triples (a[i], a[j], a[k]) such that i < j < k, and the sum \n    of the elements in the triple (a[i] + a[j] + a[k]) is divisible by 3.\n\n    Example:\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"", "generated_programs": ["from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for comb in combinations(a, 3):\n        if sum(comb) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "code\nfrom itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    mod_counts = [0, 0, 0]\n    for num in a:\n        mod_counts[num % 3] += 1\n    count = 0\n    count += mod_counts[0] * (mod_counts[0] - 1) * (mod_counts[0] - 2) // 6\n    count += mod_counts[1] * (mod_counts[1] - 1) * (mod_counts[1] - 2) // 6\n    count += mod_counts[2] * (mod_counts[2] - 1) * (mod_counts[2] - 2) // 6\n    count += mod_counts[0] * mod_counts[1] * mod_counts[2]\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    remainder_counts = {0: 0, 1: 0, 2: 0}\n    for num in a:\n        remainder = num % 3\n        remainder_counts[remainder] += 1\n    count += remainder_counts[0] * remainder_counts[1] * remainder_counts[2]\n    count += remainder_counts[0] * (remainder_counts[0] - 1) * (remainder_counts[0] - 2) // 6\n    count += remainder_counts[1] * (remainder_counts[1] - 1) * (remainder_counts[1] - 2) // 6\n    count += remainder_counts[2] * (remainder_counts[2] - 1) * (remainder_counts[2] - 2) // 6\n    return count"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/153", "requirement": "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    \"\"\"\n    You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n\n    If the `extensions` list is empty, the function must raise a `ValueError` \n    with an appropriate error message indicating that the list of extensions \n    cannot be empty.\n\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\n    Input and expected output examples:\n    ### Test 1\n    Input: ['EmptyClass', []]\n    Expected Output: ['ValueError']\n    ### Test 2\n    Input: ['EmptyClass', []]\n    Expected Output: ['ValueError']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    max_strength = float('-inf')\n    strongest_extension = ''\n    for ext in extensions:\n        strength = calculate_strength(ext)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = ext\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            max_strength = current_strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        CAP = sum((1 for char in extension if char.isupper()))\n        SM = sum((1 for char in extension if char.islower()))\n        return CAP - SM\n    max_strength = -float('inf')\n    strongest_extension = ''\n    for extension in extensions:\n        strength = calculate_strength(extension)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            max_strength = current_strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        strength = calculate_strength(extension)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            strongest_extension = extension\n            max_strength = current_strength\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            max_strength = current_strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            max_strength = current_strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for ext in extensions[1:]:\n        current_strength = calculate_strength(ext)\n        if current_strength > max_strength:\n            strongest_extension = ext\n            max_strength = current_strength\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        CAP = sum((1 for char in extension if char.isupper()))\n        SM = sum((1 for char in extension if char.islower()))\n        return CAP - SM\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            max_strength = current_strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"\n    You are given two words, `a` and `b`. The function returns True if the second word `b` or any of its rotations \n    is a substring of the first word `a`. Otherwise, it returns False.\n\n    Additional rules to clarify edge cases:\n    - If either `a` or `b` is an empty string, the function will return False.\n    - Rotations of `b` include the original string `b` itself.\n\n    Examples:\n    cycpattern_check(\"abcd\", \"abd\") => False\n    cycpattern_check(\"hello\", \"ell\") => True\n    cycpattern_check(\"whassup\", \"psus\") => False\n    cycpattern_check(\"abab\", \"baa\") => True\n    cycpattern_check(\"efef\", \"eeff\") => False\n    cycpattern_check(\"himenss\", \"simen\") => True\n    cycpattern_check(\"\", \"\") => False\n    cycpattern_check(\"abc\", \"\") => False\n    cycpattern_check(\"\", \"abc\") => False\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "HumanEval/158", "requirement": "def find_max(words: List[str]) -> str:\n    \"\"\"\n    Write a function that accepts a list of strings (`words`).\n    The list contains words, where each word is a non-empty string, and may include characters from the full ASCII set.\n    Return the word with the maximum number of unique characters.\n\n    If multiple strings have the same maximum number of unique characters, return the one that is lexicographically smallest. \n    Lexicographical order is determined using Python's string comparison and is case-sensitive (e.g., 'A' comes before 'a').\n\n    If the input list is empty, return an empty string (`\"\"`).\n\n    Duplicate strings in the input list are allowed and treated independently.\n    Non-alphabetic characters are counted as unique characters if they are present in a string.\n\n    Additional clarification:\n    - The function first sorts the input list in lexicographical order. This ensures that if multiple words have the same number of unique characters, the lexicographically smallest word is selected.\n    - The word with the maximum number of unique characters is determined using the `max` function with a key that counts the number of unique characters in each word.\n\n    Examples:\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\n    find_max([]) == \"\"\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    words_sorted = sorted(words)\n    return max(words_sorted, key=lambda x: len(set(x)))", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    words_sorted = sorted(words)\n    return max(words_sorted, key=lambda x: len(set(x)))", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    words_sorted = sorted(words)\n    return max(words_sorted, key=lambda x: len(set(x)))", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    words_sorted = sorted(words)\n    return max(words_sorted, key=lambda x: len(set(x)))", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    words_sorted = sorted(words)\n    return max(words_sorted, key=lambda x: len(set(x)))", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    sorted_words = sorted(words)\n    return max(sorted_words, key=lambda word: len(set(word)))", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    words_sorted = sorted(words)\n    return max(words_sorted, key=lambda x: len(set(x)))", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    sorted_words = sorted(words)\n    return max(sorted_words, key=lambda word: len(set(word)))", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    words_sorted = sorted(words)\n    return max(words_sorted, key=lambda word: len(set(word)))", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    sorted_words = sorted(words)\n    return max(sorted_words, key=lambda word: len(set(word)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/160", "requirement": "def do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists, `operator` and `operand`, construct an algebraic expression by \n    combining the elements of `operand` with the corresponding elements of `operator` \n    in sequence, and return the evaluated result of this expression.\n\n    The construction of the expression follows these rules:\n    1. Start with the first element of `operand` as the initial value of the expression.\n    2. For each operator in `operator`, append it to the expression, followed by the \n       next element of `operand` in order.\n    3. Evaluate the resulting expression using Python's standard operator precedence.\n\n    The basic algebra operations supported in `operator` are:\n    - Addition ( + ) \n    - Subtraction ( - ) \n    - Multiplication ( * ) \n    - Floor division ( // ) \n    - Exponentiation ( ** ) \n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    The constructed expression is: 2 + 3 * 4 - 5\n    The evaluated result is: 9\n\n    Note:\n        - The length of the `operator` list is equal to the length of the `operand` list minus one.\n        - The `operand` list contains non-negative integers.\n        - The `operator` list contains at least one operator, and the `operand` list contains at least two operands.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "from typing import List\n\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    return sorted([x for x in range(start, end + 1) if x % 2 == 0])", "code\nfrom typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    return [num for num in range(start, end + 1) if num % 2 == 0]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = [num for num in range(start, end + 1) if num % 2 == 0]\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    result = [num for num in range(start, end + 1) if num % 2 == 0]\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if num % 2 == 0:\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if num % 2 == 0:\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_digits = [0, 2, 4, 6, 8]\n    result = [num for num in range(start, end + 1) if num in even_digits]\n    return sorted(result)", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if num % 2 == 0 and all((int(digit) % 2 == 0 for digit in str(num))):\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    even_digits = {0, 2, 4, 6, 8}\n    result = [num for num in range(start, end + 1) if num % 10 in even_digits and num // 10 in even_digits or (num < 10 and num in even_digits)]\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/1", "requirement": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        else:\n            stack.pop()\n        if not stack:\n            result.append(char)\n    return [s for s in paren_string.split(')') if s]", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    start = 0\n    cleaned_string = paren_string.replace(' ', '')\n    for i, char in enumerate(cleaned_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(cleaned_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    start_index = 0\n    paren_string = paren_string.replace(' ', '')\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start = stack.pop()\n                if not stack:\n                    result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if len(stack) == 1:\n                result.append(paren_string[start:i + 1])\n            stack.pop()\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    current_group = ''\n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            if stack:\n                current_group += char\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            current_group += char\n            if not stack:\n                result.append(current_group)\n                current_group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    current_group = ''\n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            if not stack:\n                current_group = ''\n            stack.append(char)\n            current_group += char\n        elif char == ')':\n            stack.pop()\n            current_group += char\n            if not stack:\n                result.append(current_group)\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    current_group = []\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            if stack:\n                current_group.append(char)\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if stack:\n                current_group.append(char)\n            else:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    start_index = 0\n    cleaned_string = paren_string.replace(' ', '')\n    for i, char in enumerate(cleaned_string):\n        if char == '(':\n            if not stack:\n                start_index = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(cleaned_string[start_index:i + 1])\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.6, "original_passk": 1.0}}
{"task_id": "HumanEval/4", "requirement": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate the Mean Absolute Deviation\n    around the mean of this dataset. Mean Absolute Deviation is the average \n    absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Edge case handling:\n    - If the input list is empty, the function will raise a ZeroDivisionError, \n      consistent with the behavior of the reference implementation.\n\n    Example:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([])\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: division by zero\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    x_mean = sum(numbers) / len(numbers)\n    return sum((abs(x - x_mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError('division by zero')\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    return sum(absolute_differences) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    return sum(absolute_differences) / len(numbers)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/5", "requirement": "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"Insert the number 'delimiter' between every two consecutive elements of the input list `numbers`.\n    The delimiter is added after each element except the last one.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "code\nfrom typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that begins with a supplied string.\n\n    The algorithm works as follows:\n    - Iterate through the string to find the longest suffix that is a palindrome.\n    - Append the reverse of the prefix (the part of the string before the palindromic suffix) to the end of the original string.\n\n    Examples:\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    for i in range(len(string), -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string", "code\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string + string[::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string + string[::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    for i in range(len(string), -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[:i - 1:-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n, -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n, -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    longest_palindromic_suffix = 0\n    for i in range(len(string)):\n        if string[i:] == string[i:][::-1]:\n            longest_palindromic_suffix = i\n            break\n    return string + string[:longest_palindromic_suffix][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    longest_palindrome_suffix = n\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            longest_palindrome_suffix = i\n            break\n    prefix_to_add = string[:longest_palindrome_suffix][::-1]\n    return string + prefix_to_add", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    longest_palindrome_suffix = 0\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            longest_palindrome_suffix = n - i\n            break\n    prefix = string[:n - longest_palindrome_suffix]\n    return string + prefix[::-1]"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.30000000000000004, "original_passk": 0.0}}
{"task_id": "HumanEval/12", "requirement": "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Out of a list of strings, return the longest one. If there are multiple strings of the same maximum length, return the first one that appears in the list. Return None if the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"", "generated_programs": ["from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "code\nfrom typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len, default=None)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    longest_str = strings[0]\n    for s in strings:\n        if len(s) > len(longest_str):\n            longest_str = s\n    return longest_str", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    max_length = max((len(s) for s in strings))\n    for s in strings:\n        if len(s) == max_length:\n            return s"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/18", "requirement": "```python\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Count how many times a given substring can be found in the original string, including overlapping occurrences. \n    Each occurrence is counted even if it starts within another occurrence of the substring.\n\n    The counting mechanism moves forward by one character after locating each match, ensuring all potential overlaps are considered.\n\n    Edge Cases:\n    - If the original string is empty, the function returns 0 regardless of the substring.\n    - If the substring is empty, it is treated as trivial, and the function returns 0.\n\n    Examples:\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n```", "generated_programs": ["def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    n = len(substring)\n    for i in range(len(string) - n + 1):\n        if string[i:i + n] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    sub_len = len(substring)\n    for i in range(len(string) - sub_len + 1):\n        if string[i:i + sub_len] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    n = len(substring)\n    for i in range(len(string) - n + 1):\n        if string[i:i + n] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    n = len(string)\n    m = len(substring)\n    for i in range(n - m + 1):\n        if string[i:i + m] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    count = 0\n    if not string or not substring:\n        return count\n    sub_len = len(substring)\n    for i in range(len(string) - sub_len + 1):\n        if string[i:i + sub_len] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    len_sub = len(substring)\n    for i in range(len(string) - len_sub + 1):\n        if string[i:i + len_sub] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    n = len(string)\n    m = len(substring)\n    for i in range(n - m + 1):\n        if string[i:i + m] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    n = len(string)\n    m = len(substring)\n    for i in range(n - m + 1):\n        if string[i:i + m] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    n = len(string)\n    m = len(substring)\n    for i in range(n - m + 1):\n        if string[i:i + m] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    start = 0\n    while True:\n        start = string.find(substring, start)\n        if start == -1:\n            break\n        count += 1\n        start += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/21", "requirement": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.\n\n    Preconditions:\n    - The input list must contain at least two elements.\n    - The input list must contain at least two distinct values (i.e., the smallest and largest numbers must differ).\n\n    Behavior:\n    - If the precondition `max(numbers) != min(numbers)` is violated (e.g., all numbers are identical), the function will raise a `ZeroDivisionError` due to division by zero, as per Python's default behavior.\n    - The function does not perform input validation to enforce the preconditions; it assumes valid input.\n\n    Example:\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/24", "requirement": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given positive integer n, find the largest positive integer smaller than n that divides n evenly.\n    \n    - If n = 1, return None, as there are no divisors smaller than 1.\n    - The function assumes n is a positive integer greater than zero.\n    - The function checks all integers from n-1 down to 1 to find the largest divisor.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    None\n    \"\"\"", "generated_programs": ["def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/25", "requirement": "```python\nfrom typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of a given integer n in the order from smallest to largest.\n    Each of the factors should be listed the number of times corresponding to how many times it appears in the factorization.\n    The input number should be equal to the product of all factors.\n    \n    - If n is less than or equal to 1, return an empty list, as prime factorization is undefined for these values.\n    - Negative integers should be treated as invalid for factorization, and the function should return an empty list.\n    - The function assumes n is a non-negative integer greater than 1 for meaningful factorization.\n    \n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        divisor += 1\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n <= 1:\n        return []\n    factors = []\n    divisor = 2\n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/32", "requirement": "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns the value of the polynomial:\n    xs[0] + xs[1] * x + xs[2] * x^2 + ... + xs[n] * x^n\n    \"\"\"\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\"\n    Finds a root x such that poly(xs, x) = 0 for a given polynomial with coefficients xs.\n\n    Requirements:\n    1. The input list `xs` must have an even number of coefficients. If the number of coefficients is odd, the function raises a `ValueError`.\n    2. The function assumes that the input polynomial has at least one root within the range [-100, 100]. The function validates this assumption by checking for a sign change in the polynomial values at the endpoints of the range. If no sign change is detected, the function raises a `ValueError`.\n    3. The function returns only one root, even if there are multiple roots. The returned root is determined using the bisection method, which guarantees a deterministic result. The root returned is the one found first by the bisection method starting from the range [-100, 100].\n    4. The function finds an approximate root within a numerical tolerance of `1e-07`.\n    5. Special cases:\n       - If `xs = [0, 0]`, the function returns `0.0` because the polynomial is identically zero for all x.\n       - Polynomials that are not identically zero (e.g., `[0, 5]`) are not treated as special cases and are processed normally.\n       - If the input does not satisfy the even-number-of-coefficients requirement (e.g., `xs = [1, -4, 4]`), the function raises a `ValueError`.\n\n    Examples:\n    >>> round(find_zero([1, 2]), 2)  # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2)  # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    >>> find_zero([1, -4, 4])  # Odd number of coefficients\n    ValueError\n    >>> find_zero([0, 0])  # Polynomial is identically zero\n    0.0\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coef * x ** idx for idx, coef in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coef * x ** i for i, coef in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** idx for idx, coeff in enumerate(xs)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/39", "requirement": "```python\ndef prime_fib(n: int) -> int:\n    \"\"\"\n    prime_fib returns the n-th number in the sequence of Fibonacci numbers that are also prime.\n\n    The function generates Fibonacci numbers starting from 0 and 1, checks each number for primality, \n    and collects only those that are prime. It stops once exactly n prime Fibonacci numbers are found \n    and returns the n-th prime Fibonacci number. The sequence of prime Fibonacci numbers starts with 2, \n    as 0 and 1 are not prime.\n\n    Constraints:\n    - `n` must be a positive integer (n > 0).\n    - If `n` is non-positive or invalid, the function will implicitly raise an `IndexError` due to list operations \n      when attempting to access an element from an empty list. No explicit input validation or error handling is implemented.\n\n    Examples:\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n```", "generated_programs": ["import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    fibs = [0, 1]\n    primes = []\n    while len(primes) < n:\n        next_fib = fibs[-1] + fibs[-2]\n        fibs.append(next_fib)\n        if is_prime(next_fib):\n            primes.append(next_fib)\n    return primes[n - 1]", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    prime_fibs = []\n    a, b = (0, 1)\n    while len(prime_fibs) < n:\n        if is_prime(a):\n            prime_fibs.append(a)\n        a, b = (b, a + b)\n    return prime_fibs[-1]", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    prime_fibs = []\n    a, b = (0, 1)\n    while len(prime_fibs) < n:\n        if is_prime(b):\n            prime_fibs.append(b)\n        a, b = (b, a + b)\n    return prime_fibs[-1]", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    prime_fibs = []\n    a, b = (0, 1)\n    while len(prime_fibs) < n:\n        if is_prime(a):\n            prime_fibs.append(a)\n        a, b = (b, a + b)\n    return prime_fibs[-1]", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    fib_primes = []\n    a, b = (0, 1)\n    while len(fib_primes) < n:\n        if is_prime(a):\n            fib_primes.append(a)\n        a, b = (b, a + b)\n    return fib_primes[-1]", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    prime_fib_numbers = []\n    a, b = (0, 1)\n    while len(prime_fib_numbers) < n:\n        if is_prime(a):\n            prime_fib_numbers.append(a)\n        a, b = (b, a + b)\n    return prime_fib_numbers[-1]", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    prime_fib_numbers = []\n    a, b = (0, 1)\n    while len(prime_fib_numbers) < n:\n        if is_prime(a):\n            prime_fib_numbers.append(a)\n        a, b = (b, a + b)\n    return prime_fib_numbers[-1]", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    fib_seq = [0, 1]\n    prime_fib_seq = []\n    while len(prime_fib_seq) < n:\n        next_fib = fib_seq[-1] + fib_seq[-2]\n        fib_seq.append(next_fib)\n        if is_prime(next_fib):\n            prime_fib_seq.append(next_fib)\n    return prime_fib_seq[-1]", "import math\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    primes_found = 0\n    a, b = (0, 1)\n    while True:\n        if is_prime(b):\n            primes_found += 1\n            if primes_found == n:\n                return b\n        a, b = (b, a + b)", "import math\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_fib(n: int) -> int:\n    fib_primes = []\n    a, b = (0, 1)\n    while len(fib_primes) < n:\n        if a > 1 and is_prime(a):\n            fib_primes.append(a)\n        a, b = (b, a + b)\n    return fib_primes[-1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/41", "requirement": "```python\ndef car_race_collision(n: int) -> int:\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    There are two sets of cars:\n    - The first set consists of n cars driving left to right.\n    - The second set consists of n cars driving right to left.\n\n    All cars move at the same constant speed, and their trajectories are such that every car in the first set will encounter every car in the second set. A collision is defined as the theoretical encounter between a car from the first set and a car from the second set, regardless of physical proximity or sturdiness. The cars are infinitely sturdy and strong, meaning they continue moving in their trajectories without any change in behavior after a collision.\n\n    This function outputs the total number of such theoretical collisions, which is equal to the product of the number of cars in the two sets: n * n.\n\n    Examples:\n    - car_race_collision(3) -> 9\n    - car_race_collision(5) -> 25\n    \"\"\"\n```", "generated_programs": ["def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/44", "requirement": "def change_base(x: int, base: int) -> str:\n    \"\"\"\n    Convert the integer x into its representation in the specified numerical base and return the result as a string.\n    \n    Requirements:\n    1. The input number x must be a non-negative integer.\n    2. The base must be an integer in the range [2, 9]. If the base is outside this range, the function will raise a ValueError.\n    3. If x is 0, the function will return an empty string ('') as the representation.\n    4. For all other values of x, the function will compute the base conversion and return the result as a string.\n    \n    Examples:\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"", "generated_programs": ["def change_base(x: int, base: int) -> str:\n    if not 2 <= base <= 9:\n        raise ValueError('Base must be in the range [2, 9]')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if not 2 <= base <= 9:\n        raise ValueError('Base must be between 2 and 9.')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x < 0:\n        raise ValueError('x must be a non-negative integer.')\n    if base < 2 or base > 9:\n        raise ValueError('base must be in the range [2, 9].')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x < 0:\n        raise ValueError('Input number x must be a non-negative integer.')\n    if base < 2 or base > 9:\n        raise ValueError('Base must be an integer in the range [2, 9].')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if not isinstance(x, int) or x < 0:\n        raise ValueError('x must be a non-negative integer')\n    if not isinstance(base, int) or base < 2 or base > 9:\n        raise ValueError('base must be an integer in the range [2, 9]')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if not isinstance(x, int) or x < 0:\n        raise ValueError('x must be a non-negative integer')\n    if not isinstance(base, int) or base < 2 or base > 9:\n        raise ValueError('base must be an integer in the range [2, 9]')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if not isinstance(x, int) or x < 0:\n        raise ValueError('x must be a non-negative integer.')\n    if not isinstance(base, int) or base < 2 or base > 9:\n        raise ValueError('base must be an integer in the range [2, 9].')\n    if x == 0:\n        return ''\n    res = ''\n    while x > 0:\n        res = str(x % base) + res\n        x = x // base\n    return res", "def change_base(x: int, base: int) -> str:\n    if not isinstance(x, int) or x < 0:\n        raise ValueError('x must be a non-negative integer')\n    if not isinstance(base, int) or base < 2 or base > 9:\n        raise ValueError('base must be an integer in the range [2, 9]')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if not isinstance(x, int) or x < 0:\n        raise ValueError('x must be a non-negative integer')\n    if not isinstance(base, int) or base < 2 or base > 9:\n        raise ValueError('base must be an integer in the range [2, 9]')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "code\n\ndef change_base(x: int, base: int) -> str:\n    if not isinstance(x, int) or x < 0:\n        raise ValueError('x must be a non-negative integer')\n    if not isinstance(base, int) or base < 2 or base > 9:\n        raise ValueError('base must be an integer in the range [2, 9]')\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x = x // base\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/46", "requirement": "def fib4(n: int) -> int:\n    \"\"\"\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4.\n\n    The function computes the n-th element of the Fib4 number sequence efficiently without using recursion. \n    For invalid inputs where n < 0, the function will return 0 as a default value.\n\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"", "generated_programs": ["def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < 4:\n        return fib[n]\n    for i in range(4, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < 4:\n        return fib[n]\n    for i in range(4, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < 4:\n        return fib[n]\n    for i in range(4, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    if n == 2:\n        return 2\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        a, b, c, d = (b, c, d, a + b + c + d)\n    return d", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib4_seq = [0, 0, 2, 0]\n    if n < len(fib4_seq):\n        return fib4_seq[n]\n    for i in range(4, n + 1):\n        next_val = fib4_seq[i - 1] + fib4_seq[i - 2] + fib4_seq[i - 3] + fib4_seq[i - 4]\n        fib4_seq.append(next_val)\n    return fib4_seq[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < 4:\n        return fib[n]\n    for i in range(4, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    if n == 2:\n        return 2\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        next_val = a + b + c + d\n        a, b, c, d = (b, c, d, next_val)\n    return d", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        e = a + b + c + d\n        a, b, c, d = (b, c, d, e)\n    return d", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib4_sequence = [0, 0, 2, 0]\n    if n < len(fib4_sequence):\n        return fib4_sequence[n]\n    for i in range(4, n + 1):\n        next_value = fib4_sequence[i - 1] + fib4_sequence[i - 2] + fib4_sequence[i - 3] + fib4_sequence[i - 4]\n        fib4_sequence.append(next_value)\n    return fib4_sequence[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 2\n    if n == 3:\n        return 0\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        a, b, c, d = (b, c, d, a + b + c + d)\n    return d"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\ndef median(l: List[int]) -> float:\n    \"\"\"\n    Return the median of elements in the list `l`.\n\n    The median is calculated as follows:\n    - If the list has an odd number of elements, the median is the middle element of the sorted list.\n    - If the list has an even number of elements, the median is the average of the two middle elements of the sorted list.\n\n    Additional details:\n    - The input list `l` will be sorted internally before calculating the median.\n    - The input list must contain integers only.\n    - If the list is empty, the function will raise a `ValueError`.\n    - If the list contains a single element, that element itself is returned as the median.\n\n    Examples:\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    if not l:\n        raise ValueError('The list is empty.')\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    if not l:\n        raise ValueError('List must not be empty')\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    if not l:\n        raise ValueError('List cannot be empty.')\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 1:\n        return l_sorted[mid]\n    else:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    if not l:\n        raise ValueError('The input list is empty.')\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    if n % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        return (l_sorted[n // 2 - 1] + l_sorted[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    if not l:\n        raise ValueError('List cannot be empty.')\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    if not l:\n        raise ValueError('List cannot be empty.')\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    if not l:\n        raise ValueError('List cannot be empty.')\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 1:\n        return l_sorted[mid]\n    else:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    if not l:\n        raise ValueError('List is empty')\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 1:\n        return l_sorted[mid]\n    else:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    if not l:\n        raise ValueError('The list is empty.')\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 1:\n        return float(sorted_l[mid])\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2.0", "from typing import List\n\ndef median(l: List[int]) -> float:\n    if not l:\n        raise ValueError('The input list cannot be empty.')\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 1:\n        return l_sorted[mid]\n    else:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/54", "requirement": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words contain exactly the same set of unique characters, regardless of their frequency or order.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"", "generated_programs": ["def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/55", "requirement": "def fib(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number in a one-based indexing system.\n    \n    The Fibonacci sequence starts with:\n    - fib(1) = 1 (the first Fibonacci number),\n    - fib(2) = 1 (the second Fibonacci number),\n    and follows the recursive property:\n    fib(i) = fib(i-1) + fib(i-2) for all i > 2.\n\n    Input constraints:\n    - n must be a positive integer (n > 0).\n    - If n <= 0, a ValueError should be raised.\n\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"", "generated_programs": ["def fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "code\n\ndef fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/64", "requirement": "def vowels_count(s: str) -> int:\n    \"\"\"\n    Write a function vowels_count which takes a string as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Additionally, 'y' is treated as a vowel only when it is the last alphabetic character in the string.\n\n    The function should:\n    1. Be case-insensitive, treating uppercase and lowercase letters equivalently.\n    2. Handle an empty string as valid input, returning 0 in such cases.\n    3. Ignore non-alphabetic characters, counting only valid vowels.\n    4. Treat 'y' as a vowel strictly when it is the last alphabetic character in the string, regardless of whether the string contains non-alphabetic characters.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\")\n    0\n    \"\"\"", "generated_programs": ["def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    last_alpha_char = None\n    for char in s_lower:\n        if char.isalpha():\n            last_alpha_char = char\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    if last_alpha_char == 'y':\n        count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    last_char = None\n    for char in s_lower:\n        if char.isalpha():\n            last_char = char\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    if last_char and last_char == 'y':\n        count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    last_char = ''\n    for char in s_lower:\n        if char.isalpha():\n            last_char = char\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    if last_char == 'y':\n        count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    last_alpha_char = None\n    for char in s_lower:\n        if char.isalpha():\n            last_alpha_char = char\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    if last_alpha_char == 'y':\n        count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    last_alpha_char = None\n    for char in s_lower:\n        if char.isalpha():\n            last_alpha_char = char\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    if last_alpha_char == 'y':\n        count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    last_alpha_char = None\n    for char in s_lower:\n        if char.isalpha():\n            last_alpha_char = char\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    if last_alpha_char == 'y':\n        count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    alphabetic_chars = [char for char in s_lower if char.isalpha()]\n    for i, char in enumerate(alphabetic_chars):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(alphabetic_chars) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    last_alpha_char = None\n    for char in s_lower:\n        if char.isalpha():\n            last_alpha_char = char\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n        if char == 'y' and char == last_alpha_char:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    last_alpha_char = None\n    for char in s_lower:\n        if char.isalpha():\n            last_alpha_char = char\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s_lower) - 1 and (last_alpha_char == 'y'):\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    last_alpha_char = None\n    for char in s_lower:\n        if char.isalpha():\n            last_alpha_char = char\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            if i == len(s_lower) - 1 or not s_lower[i + 1:].isalpha():\n                count += 1\n        elif char == 'y' and i == len(s_lower) - 1 and (last_alpha_char == 'y'):\n            count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "HumanEval/70", "requirement": "def strange_sort_list(lst: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list sorted in a specific alternating order.\n    The sorting alternates between the smallest and largest remaining values in the list:\n    - Start with the smallest value.\n    - Then take the largest of the remaining values.\n    - Continue alternating between the smallest and largest of the remaining values until the list is exhausted.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    while left <= right:\n        result.append(sorted_lst[left])\n        left += 1\n        if left <= right:\n            result.append(sorted_lst[right])\n            right -= 1\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    result = []\n    lst_sorted = sorted(lst)\n    left, right = (0, len(lst_sorted) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(lst_sorted[left])\n            left += 1\n        else:\n            result.append(lst_sorted[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    while left <= right:\n        if left == right:\n            result.append(sorted_lst[left])\n        else:\n            result.append(sorted_lst[left])\n            result.append(sorted_lst[right])\n        left += 1\n        right -= 1\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "code\nfrom typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    result = []\n    lst_sorted = sorted(lst)\n    left, right = (0, len(lst_sorted) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(lst_sorted[left])\n            left += 1\n        else:\n            result.append(lst_sorted[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    lst_sorted = sorted(lst)\n    result = []\n    left = 0\n    right = len(lst_sorted) - 1\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(lst_sorted[left])\n            left += 1\n        else:\n            result.append(lst_sorted[right])\n            right -= 1\n        toggle = not toggle\n    return result", "code\nfrom typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    result = []\n    lst_sorted = sorted(lst)\n    left, right = (0, len(lst_sorted) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(lst_sorted[left])\n            left += 1\n        else:\n            result.append(lst_sorted[right])\n            right -= 1\n        toggle = not toggle\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "HumanEval/74", "requirement": "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    the total number of characters across all strings in the list less than or equal to the other list.\n\n    If the two lists have the same total number of characters, the function will return the first list.\n\n    Examples:\n    total_match([], [])  []\n    total_match(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5'])  ['4']\n    '''", "generated_programs": ["from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    sum1 = sum((len(s) for s in lst1))\n    sum2 = sum((len(s) for s in lst2))\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/75", "requirement": "def is_multiply_prime(a: int) -> bool:\n    \"\"\"\n    Write a function that returns True if the given number is the product of exactly three prime numbers,\n    and False otherwise. The following rules apply:\n    \n    1. The three prime numbers can be repeated (e.g., 2 * 3 * 3 = 18 is valid).\n    2. The input number (a) must be less than 100. If a is 100 or greater, the function should return False.\n    3. Numbers less than 2, such as 0 or 1, are valid inputs but cannot be expressed as the product of three primes, so the function should return False for them.\n    4. The function should consider all combinations of prime factors, including repeated selections, to determine if the input number can be expressed as the product of three primes.\n\n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"", "generated_programs": ["def is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [x for x in range(2, 100) if is_prime(x)]\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False", "def is_multiply_prime(a: int) -> bool:\n    if a >= 100 or a < 2:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, 100) if is_prime(i)]\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False", "import itertools\nimport math\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100 or a < 2:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, a) if is_prime(i)]\n    for p1, p2, p3 in itertools.product(primes, repeat=3):\n        if p1 * p2 * p3 == a:\n            return True\n    return False", "from itertools import combinations_with_replacement\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n    if a < 2:\n        return False\n    primes = [x for x in range(2, a) if is_prime(x)]\n    for combo in combinations_with_replacement(primes, 3):\n        if combo[0] * combo[1] * combo[2] == a:\n            return True\n    return False", "import itertools\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n    if a < 2:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, 100) if is_prime(i)]\n    for triplet in itertools.combinations_with_replacement(primes, 3):\n        if triplet[0] * triplet[1] * triplet[2] == a:\n            return True\n    return False", "import math\nfrom itertools import combinations_with_replacement\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    return [x for x in range(2, limit) if is_prime(x)]\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100 or a < 2:\n        return False\n    primes = generate_primes(a)\n    for comb in combinations_with_replacement(primes, 3):\n        if comb[0] * comb[1] * comb[2] == a:\n            return True\n    return False", "def is_multiply_prime(a: int) -> bool:\n    if a >= 100:\n        return False\n    if a < 2:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, 100) if is_prime(i)]\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False", "import itertools\nimport math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    primes = []\n    for n in range(2, limit):\n        if is_prime(n):\n            primes.append(n)\n    return primes\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100 or a < 2:\n        return False\n    primes = generate_primes(100)\n    for combo in itertools.product(primes, repeat=3):\n        if combo[0] * combo[1] * combo[2] == a:\n            return True\n    return False", "import math\nfrom itertools import combinations_with_replacement\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef get_primes_less_than(limit: int):\n    return [i for i in range(2, limit) if is_prime(i)]\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100 or a < 2:\n        return False\n    primes = get_primes_less_than(a)\n    for combo in combinations_with_replacement(primes, 3):\n        if combo[0] * combo[1] * combo[2] == a:\n            return True\n    return False", "import math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef get_prime_factors(n: int) -> list:\n    factors = set()\n    for i in range(2, n + 1):\n        while n % i == 0 and is_prime(i):\n            factors.add(i)\n            n = n // i\n    return sorted(factors)\n\ndef is_multiply_prime(a: int) -> bool:\n    if a >= 100 or a < 2:\n        return False\n    primes = [i for i in range(2, 100) if is_prime(i)]\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/76", "requirement": "```python\ndef is_simple_power(x: int, n: int) -> bool:\n    \"\"\"\n    Your task is to write a function that returns True if a number x is a simple\n    power of n and False in other cases.\n\n    A number x is a simple power of n if there exists a non-negative integer k \n    such that n**k = x, subject to the following constraints:\n    - Both x and n must be positive integers (x  1, n  1).\n    - Special case: If x = 1, the function returns True for any positive integer n, \n      because n**0 = 1 for all n  1.\n    - Special case: If n = 1, the function returns True only if x = 1, because 1**k = 1 \n      for all non-negative integers k.\n\n    The function iteratively calculates powers of n (n**k) starting from k = 0 \n    until the calculated power equals x or exceeds x. If the calculated power equals x, \n    the function returns True; otherwise, it returns False.\n\n    Examples:\n    is_simple_power(1, 4) => True\n    is_simple_power(2, 2) => True\n    is_simple_power(8, 2) => True\n    is_simple_power(3, 2) => False\n    is_simple_power(3, 1) => False\n    is_simple_power(5, 3) => False\n    \"\"\"\n```", "generated_programs": ["def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while n ** k <= x:\n        if n ** k == x:\n            return True\n        k += 1\n    return False", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while n ** k <= x:\n        if n ** k == x:\n            return True\n        k += 1\n    return False", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x < 1 or n < 1:\n        return False\n    if x == 1:\n        return True\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    \"\"\"\n    Write a function that takes an integer a and returns True \n    if the absolute value of this integer is a perfect cube of some integer number.\n    A perfect cube is defined as an integer that can be expressed as the cube of another integer.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    \"\"\"", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    x = round(abs(a) ** (1 / 3))\n    return x ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "def iscube(a: int) -> bool:\n    a = abs(a)\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    c = round(abs(a) ** (1 / 3))\n    return c ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    value = abs(a)\n    cube_root = round(value ** (1 / 3))\n    return cube_root ** 3 == value", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    absolute_a = abs(a)\n    cube_root = abs(math.pow(absolute_a, 1 / 3))\n    rounded_cube_root = round(cube_root)\n    if abs(rounded_cube_root ** 3 - absolute_a) < 1e-06:\n        return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "HumanEval/83", "requirement": "```python\ndef starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the n-digit positive integers \n    that either start with the digit 1, end with the digit 1, or both, without \n    double-counting any integers. If n < 1, return 0 as there are no valid n-digit \n    integers. Overlap, where numbers start and end with 1, must be subtracted \n    appropriately to avoid duplication in the count.\n    \"\"\"\n```", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    total = 9 * 10 ** (n - 1)\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 10 ** (n - 1)\n    both = 10 ** (n - 2)\n    return starts_with_one + ends_with_one - both", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    total = 0\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 10 ** (n - 1)\n    starts_and_ends_with_one = 10 ** (n - 2)\n    total = starts_with_one + ends_with_one - starts_and_ends_with_one\n    return total", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    total_numbers = 9 * 10 ** (n - 1)\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 9 * 10 ** (n - 2)\n    both_start_and_end_with_one = 10 ** (n - 2)\n    return starts_with_one + ends_with_one - both_start_and_end_with_one", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    total_numbers = 9 * 10 ** (n - 1)\n    starts_with_one = 1 * 10 ** (n - 1)\n    ends_with_one = 9 * 10 ** (n - 2)\n    both_start_and_end_with_one = 1 * 10 ** (n - 2)\n    return starts_with_one + ends_with_one - both_start_and_end_with_one", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    total_numbers = 9 * 10 ** (n - 1)\n    start_with_one = 1 * 10 ** (n - 1)\n    end_with_one = 9 * 10 ** (n - 2)\n    both_start_and_end = 1 * 10 ** (n - 2)\n    return start_with_one + end_with_one - both_start_and_end", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    total_numbers = 9 * 10 ** (n - 1)\n    starts_with_one = 1 * 10 ** (n - 1)\n    ends_with_one = 9 * 10 ** (n - 2) * 1\n    both_start_and_end_with_one = 1 * 10 ** (n - 2) * 1\n    return starts_with_one + ends_with_one - both_start_and_end_with_one", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    total = 0\n    start_one = 10 ** (n - 1)\n    end_one = 10 ** (n - 1)\n    both_one = 10 ** (n - 2)\n    total = start_one + end_one - both_one\n    return total", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    total = 0\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    both_start_and_end = 10 ** (n - 2)\n    total = start_with_one + end_with_one - both_start_and_end\n    return total", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    total = 0\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    start_and_end_with_one = 10 ** (n - 2) if n > 1 else 1\n    total = start_with_one + end_with_one - start_and_end_with_one\n    return total", "import math\n\ndef starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    total = 0\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 10 ** (n - 1)\n    starts_and_ends_with_one = 10 ** (n - 2)\n    total = starts_with_one + ends_with_one - starts_and_ends_with_one\n    return total"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/86", "requirement": "def anti_shuffle(s: str) -> str:\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    The ordered version of the string is created by replacing each word (separated by spaces)\n    with a new word where all the characters in the word are arranged in ascending order \n    based on their ASCII values. Words are defined as sequences of non-space characters, \n    and spaces between words should be preserved in the output.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"", "generated_programs": ["def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "def anti_shuffle(s: str) -> str:\n\n    def sort_word(word):\n        return ''.join(sorted(word, key=lambda x: ord(x)))\n    words = []\n    for word in s.split(' '):\n        words.append(sort_word(word))\n    return ' '.join(words)", "def anti_shuffle(s: str) -> str:\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, key=lambda x: ord(x)))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/87", "requirement": "def get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    You are given a 2-dimensional data structure represented as nested lists,\n    where each inner list corresponds to a row and may contain a different number of columns.\n    The task is to find all occurrences of the integer `x` in the data structure and return\n    a list of tuples representing the coordinates of these occurrences. Each tuple is in the format\n    (row_index, column_index), where both indices start from 0.\n\n    The coordinates should be sorted as follows:\n    1. First, sort by row indices in ascending order.\n    2. For coordinates within the same row, sort by column indices in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"", "generated_programs": ["from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, val in enumerate(row):\n            if val == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, val in enumerate(row):\n            if val == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, val in enumerate(row):\n            if val == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, val in enumerate(row):\n            if val == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/89", "requirement": "```python\ndef encrypt(s: str) -> str:\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and returns an encrypted string.\n    The encryption should involve rotating the lowercase alphabetic characters by 4 positions forward \n    (i.e., shift each letter to the 4th succeeding letter in the alphabet cyclically).\n    For example, 'a' becomes 'e', 'z' becomes 'd'. Non-lowercase alphabetic characters (e.g., digits, \n    punctuation, or uppercase letters) should remain unchanged in the output string.\n    \n    Examples:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n```", "generated_programs": ["def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join([shift_char(c) for c in s])", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(chr((ord(char) - ord('a') + 4) % 26 + ord('a')))\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr(ord('a') + (ord(char) - ord('a') + 4) % 26)\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            rotated_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(rotated_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(shifted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr(ord('a') + (ord(char) - ord('a') + 4) % 26)\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(ord('a') + (ord(char) - ord('a') + 4) % 26)\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/91", "requirement": "```python\ndef is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    \n    Sentences are defined as substrings separated by any of the delimiters '.', '?' or '!', \n    regardless of whether the delimiters are followed by spaces or appear consecutively. \n    Empty substrings resulting from consecutive delimiters are ignored.\n\n    Leading and trailing whitespaces in sentences are stripped before checking if they \n    start with the word \"I\". A sentence is considered to start with \"I\" if the first \n    non-whitespace character is an uppercase 'I', followed by either a space, punctuation, \n    or the end of the sentence. Variations such as lowercase 'i' or words like \"Ice\" or \"I'm\" \n    do not count as starting with \"I\".\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I ') or sentence == 'I':\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I ') or sentence == 'I':\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I ') or sentence == 'I':\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I ') or sentence == 'I':\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I ') or sentence == 'I':\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I ') or sentence == 'I':\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I ') or sentence == 'I':\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I ') or sentence == 'I':\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    count = 0\n    sentences = re.split('[.!?]+\\\\s*', S)\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I '):\n            count += 1\n        elif sentence == 'I':\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]', S)\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I ') or sentence == 'I':\n            if len(sentence) == 1 or sentence[1] == ' ' or sentence[1] in ['.', '?', '!']:\n                count += 1\n    return count"], "result": {"repaired_passk": 0.09999999999999998, "cross_model_passk": 0.0, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message and encodes it by performing the following transformations:\n    1. Swap the case of all letters in the message. For example, 'T' becomes 't' and 'e' becomes 'E'.\n       - The swapped-case message is used directly for subsequent transformations.\n    2. Replace all vowels (both lowercase and uppercase) in the swapped-case message with the letter that appears 2 places ahead of that vowel in the English alphabet. For example:\n       - 'a' becomes 'c', 'e' becomes 'g', 'i' becomes 'k', 'o' becomes 'q', and 'u' becomes 'w'.\n       - 'A' becomes 'C', 'E' becomes 'G', 'I' becomes 'K', 'O' becomes 'Q', and 'U' becomes 'W'.\n       - Wrapping behavior is handled naturally using ASCII values, so 'u' shifts to 'w' without special handling.\n       - The replacement is applied directly to the swapped-case vowels without introducing additional case changes or mappings.\n    3. The transformations are applied sequentially: first swap the case of each letter, then replace vowels in the swapped-case message.\n\n    Assume the input string consists only of alphabetic characters, and apply the transformations uniformly across the entire input string.\n\n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n    swapped_message = message.swapcase()\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels:\n            new_char = chr(ord(char) + 2)\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped_message = message.swapcase()\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels:\n            encoded_char = chr(ord(char) + 2)\n            encoded_message.append(encoded_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped = message.swapcase()\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n    for char in swapped:\n        if char in vowels:\n            new_char = chr(ord(char) + 2)\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped_message = message.swapcase()\n    encoded_message = []\n    for char in swapped_message:\n        if char.lower() in {'a', 'e', 'i', 'o', 'u'}:\n            encoded_char = chr(ord(char) + 2)\n            encoded_message.append(encoded_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped_message = message.swapcase()\n    encoded_message = []\n    vowels = 'aeiouAEIOU'\n    for char in swapped_message:\n        if char in vowels:\n            new_char = chr(ord(char) + 2)\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    swapped_message = message.swapcase()\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels:\n            encoded_char = chr(ord(char) + 2)\n            encoded_message.append(encoded_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    swapped_message = message.swapcase()\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels:\n            encoded_char = chr(ord(char) + 2)\n            encoded_message.append(encoded_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped_message = message.swapcase()\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels:\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + 2) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(char) - ord('A') + 2) % 26 + ord('A'))\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped_message = message.swapcase()\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels:\n            if char.islower():\n                encoded_char = chr(ord(char) + 2) if ord(char) + 2 <= ord('z') else chr(ord(char) - 24)\n            else:\n                encoded_char = chr(ord(char) + 2) if ord(char) + 2 <= ord('Z') else chr(ord(char) - 24)\n            encoded_message.append(encoded_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped_case = message.swapcase()\n    vowel_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    encoded_message = []\n    for char in swapped_case:\n        if char in vowel_map:\n            encoded_message.append(vowel_map[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/97", "requirement": "def multiply(a: int, b: int) -> int:\n    \"\"\"\n    Complete the function that takes two integers and returns \n    the product of the absolute values of their unit digits.\n    The unit digit is the digit in the ones place of a number, determined \n    by first taking the absolute value of the number and then extracting the remainder\n    when divided by 10. Negative numbers are handled by converting them to positive numbers \n    first, effectively ignoring their sign for unit digit extraction.\n\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14, -15) should return 20.\n    \"\"\"", "generated_programs": ["def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b", "def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b", "def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b", "def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b", "def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b", "def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b", "code\n\ndef multiply(a: int, b: int) -> int:\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "def multiply(a: int, b: int) -> int:\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "def multiply(a: int, b: int) -> int:\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "def multiply(a: int, b: int) -> int:\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/99", "requirement": "```python\ndef closest_integer(value: str) -> int:\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. The rounding behavior is as follows:\n    - Convert the input string to a floating-point number.\n    - Determine the fractional part of the number as the absolute difference \n      between the number and its integer part.\n    - If the fractional part is less than 0.5, round towards zero by truncating \n      the fractional part (using the integer part of the number).\n    - If the fractional part is exactly 0.5 or greater, round away from zero:\n      - For positive numbers, rounding away from zero means rounding up (towards +).\n      - For negative numbers, rounding away from zero means rounding down (towards ).\n    - If the input is 0, return 0 as it is its own closest integer.\n\n    Note:\n    - The fractional part is always treated as an absolute value, ignoring the sign of the number.\n    - Rounding away from zero means that if the given number is equidistant from two integers, \n      the one you should return is the one that is the farthest from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n    >>> closest_integer(\"-99.999\")\n    -100\n    >>> closest_integer(\"14.5\")\n    15\n    >>> closest_integer(\"-14.5\")\n    -15\n    '''\n```", "generated_programs": ["def closest_integer(value: str) -> int:\n    num = float(value)\n    fractional = abs(num - int(num))\n    if fractional < 0.5:\n        return int(num)\n    elif num > 0:\n        return int(num) + 1\n    else:\n        return int(num) - 1", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == 0:\n        return 0\n    fractional = abs(num - int(num))\n    if fractional < 0.5:\n        return int(num)\n    else:\n        return math.ceil(num) if num > 0 else math.floor(num)", "def closest_integer(value: str) -> int:\n    num = float(value)\n    if num == 0:\n        return 0\n    fractional = abs(num - int(num))\n    if fractional < 0.5:\n        return int(num)\n    elif num > 0:\n        return int(num) + 1\n    else:\n        return int(num) - 1", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == 0:\n        return 0\n    fractional = abs(num - int(num))\n    if fractional < 0.5:\n        return int(num)\n    elif num > 0:\n        return math.ceil(num)\n    else:\n        return math.floor(num)", "def closest_integer(value: str) -> int:\n    num = float(value)\n    if num == 0:\n        return 0\n    fractional = abs(num - int(num))\n    if fractional < 0.5:\n        return int(num)\n    elif num > 0:\n        return int(num) + 1\n    else:\n        return int(num) - 1", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == 0:\n        return 0\n    integer_part = int(num)\n    fractional_part = abs(num) - abs(integer_part)\n    if fractional_part < 0.5:\n        return integer_part\n    elif num > 0:\n        return integer_part + 1\n    else:\n        return integer_part - 1", "def closest_integer(value: str) -> int:\n    num = float(value)\n    if num == 0:\n        return 0\n    integer_part = int(num)\n    fractional_part = abs(num - integer_part)\n    if fractional_part < 0.5:\n        return integer_part\n    elif num > 0:\n        return integer_part + 1\n    else:\n        return integer_part - 1", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == 0:\n        return 0\n    integer_part = int(num)\n    fractional_part = abs(num - integer_part)\n    if fractional_part < 0.5:\n        return integer_part\n    elif num > 0:\n        return integer_part + 1\n    else:\n        return integer_part - 1", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == 0:\n        return 0\n    int_part = int(num)\n    fractional_part = abs(num - int_part)\n    if fractional_part < 0.5:\n        return int_part\n    elif num > 0:\n        return int_part + 1\n    else:\n        return int_part - 1", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == 0:\n        return 0\n    integer_part = int(num)\n    fractional_part = abs(num - integer_part) if num >= 0 else abs(num - (integer_part - 1))\n    if fractional_part < 0.5:\n        return integer_part\n    elif num > 0:\n        return integer_part + 1\n    else:\n        return integer_part - 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/100", "requirement": "def make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, create a pile of n levels of stones.\n    The first level contains n stones.\n    Each subsequent level contains 2 more stones than the previous level, \n    regardless of whether n is odd or even.\n    Return the number of stones in each level in a list, where the element at \n    index i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    for i in range(n):\n        pile.append(n + 2 * i)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    for i in range(n):\n        pile.append(n + 2 * i)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    result = []\n    current = n\n    for _ in range(n):\n        result.append(current)\n        current += 2\n    return result", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    result = []\n    current = n\n    for _ in range(n):\n        result.append(current)\n        current += 2\n    return result", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    stones = n\n    for _ in range(n):\n        pile.append(stones)\n        stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/101", "requirement": "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n\n    The function should handle the following cases:\n    - If the input string is empty or contains only separators (spaces or commas), return an empty list.\n    - Words are extracted irrespective of separator types (spaces, commas, or a mixture of both).\n    - Leading and trailing spaces in the input string should be removed before processing.\n    - Consecutive separators should not produce empty strings in the output.\n\n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"", "generated_programs": ["from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return [word for word in s.replace(',', ' ').split() if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[,\\\\s]+', s)\n    return [word for word in words if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[ ,]+', s)\n    return [word for word in words if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    separators = [' ', ',']\n    for sep in separators:\n        s = s.replace(sep, ' ')\n    return [word for word in s.split() if word]", "code\nfrom typing import List\n\ndef words_string(s: str) -> List[str]:\n    import re\n    s = s.strip()\n    if not s:\n        return []\n    words = re.split('[,\\\\s]+', s)\n    return [word for word in words if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    separators = [',', ' ']\n    for sep in separators:\n        s = s.replace(sep, ' ')\n    return [word for word in s.split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    if not s:\n        return []\n    s = s.strip()\n    if not s:\n        return []\n    separators = [' ', ',']\n    for sep in separators:\n        s = s.replace(sep, ' ')\n    return [word for word in s.split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    separators = [',', ' ']\n    for sep in separators:\n        s = s.replace(sep, ' ')\n    return [word for word in s.split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    separators = [' ', ',']\n    for sep in separators:\n        s = s.replace(sep, ' ')\n    return [word for word in s.split() if word]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 0.0}}
{"task_id": "HumanEval/102", "requirement": "def choose_num(x: int, y: int) -> int:\n    \"\"\"This function takes two positive integers x and y and returns the \n    largest even integer within the range [x, y] inclusive. The range is \n    considered in descending order, starting from y down to x. If x is \n    greater than y or there are no even numbers in the range, the function \n    returns -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"", "generated_programs": ["def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "code\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.4}}
{"task_id": "HumanEval/104", "requirement": "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers x, return a sorted list of all elements that do not contain any even digit.\n    \n    - An even digit is defined as any digit in the set {'0', '2', '4', '6', '8'}.\n    - The input list may contain positive, zero, or negative integers, but only integers without even digits will be included in the output.\n    - Numbers containing even digits, including zero, are excluded from the output.\n    - The returned list will always be sorted in increasing order. If no numbers qualify, an empty list is returned.\n\n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"", "generated_programs": ["code\nfrom typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    even_digits = {'0', '2', '4', '6', '8'}\n    result = []\n    for num in x:\n        num_str = str(abs(num))\n        if not any((digit in even_digits for digit in num_str)):\n            result.append(num)\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        n = abs(n)\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if not has_even_digit(num)]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        n = abs(n)\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    return sorted([num for num in x if not has_even_digit(num)])", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        n = abs(n)\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if not contains_even_digit(num)]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        n = abs(n)\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if not has_even_digit(num)]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        n = abs(n)\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    filtered_numbers = [num for num in x if not contains_even_digit(num)]\n    return sorted(filtered_numbers)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        n = abs(n)\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if not has_even_digit(num) and num != 0]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        if n == 0:\n            return True\n        n = abs(n)\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if not contains_even_digit(num)]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        if n == 0:\n            return True\n        n = abs(n)\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if not has_even_digit(num)]\n    return sorted(result)", "from typing import List\n\ndef contains_even_digit(n: int) -> bool:\n    if n == 0:\n        return True\n    n = abs(n)\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 0:\n            return True\n        n = n // 10\n    return False\n\ndef unique_digits(x: List[int]) -> List[int]:\n    result = [num for num in x if not contains_even_digit(num)]\n    return sorted(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/107", "requirement": "def even_odd_palindrome(n: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a positive integer n, return a tuple containing the count of even and odd \n    integer palindromes within the range [1, n], inclusive.\n\n    An integer palindrome is a number that reads the same backward as forward.\n\n    The first element of the tuple represents the count of even integer palindromes, \n    and the second element represents the count of odd integer palindromes.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindromes are 1, 2, 3. One of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindromes are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Four of them are even, and six of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. The returned tuple contains the count of even and odd integer palindromes, respectively.\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for number in range(1, n + 1):\n        if str(number) == str(number)[::-1]:\n            if number % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "def count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements in the array for which the sum of their signed digits is greater than 0.\n\n    Signed digits are determined as follows:\n    - If a number is negative, its signed digits consist of the negative value of its first digit \n      (the most significant digit) followed by the absolute values of its remaining digits.\n      For example, -123 has signed digits -1, 2, and 3.\n    - If a number is positive, all its digits are treated as positive.\n      For example, 123 has signed digits 1, 2, and 3.\n\n    The sum of signed digits is calculated by summing these values. A number is included in the count\n    if the sum of its signed digits is strictly greater than 0.\n\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            signed_sum = -int(s[1]) + sum((int(d) for d in s[2:]))\n        else:\n            signed_sum = sum((int(d) for d in s))\n        if signed_sum > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        if num < 0:\n            digits = list(map(int, str(abs(num))))\n            signed_sum = -digits[0] + sum(digits[1:])\n        else:\n            signed_sum = sum(map(int, str(num)))\n        if signed_sum > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        if num < 0:\n            s = str(num)\n            signed_digits = [-int(s[1])] + [int(d) for d in s[2:]]\n        else:\n            signed_digits = [int(d) for d in str(num)]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            signed_digits = [-int(s[1])] + [int(d) for d in s[2:]]\n        else:\n            signed_digits = [int(d) for d in s]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            signed_digits = [-int(s[1])] + [int(d) for d in s[2:]]\n        else:\n            signed_digits = [int(d) for d in s]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        if num < 0:\n            digits = [int(str(abs(num))[0]) * -1] + [int(d) for d in str(abs(num))[1:]]\n        else:\n            digits = [int(d) for d in str(num)]\n        if sum(digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        digits = list(str(abs(num)))\n        if num < 0:\n            signed_digits = [-int(digits[0])] + [int(d) for d in digits[1:]]\n        else:\n            signed_digits = [int(d) for d in digits]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        digits = list(str(num))\n        if num < 0:\n            signed_digits = [-int(digits[0])] + [int(d) for d in digits[1:]]\n        else:\n            signed_digits = [int(d) for d in digits]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        signed_digits = []\n        if s[0] == '-':\n            signed_digits.append(-int(s[1]))\n            for c in s[2:]:\n                signed_digits.append(int(c))\n        else:\n            for c in s:\n                signed_digits.append(int(c))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if not s:\n            continue\n        if s[0] == '-':\n            signed_digits = [int(s[1]) * -1] + [int(c) for c in s[2:]]\n        else:\n            signed_digits = [int(c) for c in s]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 0.8, "cross_model_passk": 0.9, "original_passk": 0.9}}
{"task_id": "HumanEval/109", "requirement": "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    \"\"\"\n    We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The numbers \n    in the array will be randomly ordered. Your task is to determine if it is \n    possible to get an array sorted in non-decreasing order by performing the \n    following operation on the given array:\n        You are allowed to perform right shift operations any number of times.\n\n    One right shift operation means shifting all elements of the array by one \n    position in the right direction. The last element of the array will be moved \n    to the starting position in the array i.e., 0th index.\n\n    To determine if the array can be sorted in non-decreasing order:\n    - A \"break\" is defined as a point where arr[i - 1] > arr[i] for 1 <= i < N. \n      This comparison is performed sequentially for indices 1 through N-1 only \n      and does not wrap around to compare the last element with the first element.\n    - Count the number of \"breaks\" in the array:\n        - If there are no \"breaks,\" the array is already sorted in non-decreasing \n          order and should return True.\n        - If there is exactly one \"break,\" check if the last element of the array \n          (arr[N-1]) is less than or equal to the first element (arr[0]). If this \n          condition is satisfied, return True; otherwise, return False.\n        - If there are more than one \"breaks,\" return False.\n    - Special cases:\n        - If the given array is empty, return True. This is because an empty array \n          requires no operations to be considered sorted.\n        - If the array has only one element, return True. A single-element array \n          is considered sorted by default.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2]) ==> True\n    Explanation: By performing 2 right shift operations, non-decreasing order can \n                 be achieved for the given array.\n                 \n    move_one_ball([3, 5, 4, 1, 2]) ==> False\n    Explanation: It is not possible to get non-decreasing order for the given \n                 array by performing any number of right shift operations.\n                 \n    move_one_ball([1, 2, 3, 4, 5]) ==> True\n    Explanation: The array is already sorted in non-decreasing order, so no \n                 right shift operations are needed.\n                 \n    move_one_ball([]) ==> True\n    Explanation: An empty array is considered sorted by default.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr or len(arr) == 1:\n        return True\n    breaks = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            breaks += 1\n            if breaks > 1:\n                return False\n    if breaks == 0:\n        return True\n    return arr[-1] <= arr[0]", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr or len(arr) == 1:\n        return True\n    breaks = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            breaks += 1\n    if breaks == 0:\n        return True\n    elif breaks == 1:\n        return arr[-1] <= arr[0]\n    else:\n        return False", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr or len(arr) == 1:\n        return True\n    breaks = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            breaks += 1\n    if breaks == 0:\n        return True\n    elif breaks == 1:\n        return arr[-1] <= arr[0]\n    else:\n        return False", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr or len(arr) == 1:\n        return True\n    breaks = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            breaks += 1\n    if breaks == 0:\n        return True\n    elif breaks == 1:\n        return arr[-1] <= arr[0]\n    else:\n        return False", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr or len(arr) == 1:\n        return True\n    breaks = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            breaks += 1\n    if breaks == 0:\n        return True\n    elif breaks == 1:\n        return arr[-1] <= arr[0]\n    else:\n        return False", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr or len(arr) == 1:\n        return True\n    breaks = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            breaks += 1\n            if breaks > 1:\n                return False\n    if breaks == 0:\n        return True\n    return arr[-1] <= arr[0]", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr or len(arr) == 1:\n        return True\n    breaks = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            breaks += 1\n    if breaks == 0:\n        return True\n    elif breaks == 1:\n        return arr[-1] <= arr[0]\n    else:\n        return False", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr or len(arr) == 1:\n        return True\n    breaks = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            breaks += 1\n    if breaks == 0:\n        return True\n    elif breaks == 1:\n        return arr[-1] <= arr[0]\n    else:\n        return False", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr or len(arr) == 1:\n        return True\n    breaks = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            breaks += 1\n    if breaks == 0:\n        return True\n    elif breaks == 1:\n        return arr[-1] <= arr[0]\n    else:\n        return False", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr or len(arr) == 1:\n        return True\n    breaks = 0\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            breaks += 1\n    if breaks == 0:\n        return True\n    elif breaks == 1:\n        return arr[-1] <= arr[0]\n    else:\n        return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/110", "requirement": "def exchange(lst1: List[int], lst2: List[int]) -> str:\n    \"\"\"\n    Implement a function that takes two lists of integers, lst1 and lst2, and determines \n    whether it is possible to exchange elements between them to make all elements in lst1 even. \n    The exchange allows moving any number of elements from lst2 to lst1, but only even numbers \n    from lst2 can replace odd numbers in lst1.\n\n    Specifically:\n    - Count the number of odd numbers in lst1.\n    - Count the number of even numbers in lst2.\n    - If the number of even numbers in lst2 is greater than or equal to the number of odd numbers in lst1, \n      return \"YES\".\n    - Otherwise, return \"NO\".\n\n    Examples:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n\n    Assumptions:\n    - Both input lists are non-empty.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for num in lst1 if num % 2 != 0))\n    even_count = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for num in lst1 if num % 2 != 0))\n    even_count = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for num in lst1 if num % 2 != 0))\n    even_count = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for num in lst1 if num % 2 != 0))\n    even_count = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for num in lst1 if num % 2 != 0))\n    even_count = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for num in lst1 if num % 2 != 0))\n    even_count = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for num in lst1 if num % 2 != 0))\n    even_count = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_in_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for x in lst1 if x % 2 != 0))\n    even_count = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_in_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/111", "requirement": "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    \"\"\"\n    Given a string of space-separated lowercase letters, return a dictionary containing the letter(s) \n    with the highest count of occurrences and their corresponding counts.\n\n    The function has the following behavior:\n    - If multiple letters have the same maximum frequency, all such letters must be returned in the dictionary.\n    - If the input string is empty or contains only spaces, the function should return an empty dictionary.\n    - The input is expected to consist only of lowercase letters separated by spaces. Non-conforming inputs \n      (e.g., words with digits, uppercase characters, special symbols, mixed-case, or any others) will never be encountered \n      and do not require validation.\n    - The input may contain extra spaces between words or around the string, but these spaces should be ignored during processing.\n\n    Examples:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n    \"\"\"", "generated_programs": ["from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.strip().split()\n    counts = {}\n    for letter in letters:\n        counts[letter] = counts.get(letter, 0) + 1\n    max_count = max(counts.values(), default=0)\n    return {k: v for k, v in counts.items() if v == max_count}", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    frequency = {}\n    for letter in letters:\n        frequency[letter] = frequency.get(letter, 0) + 1\n    max_count = max(frequency.values(), default=0)\n    result = {k: v for k, v in frequency.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    counts = {}\n    for letter in letters:\n        if letter in counts:\n            counts[letter] += 1\n        else:\n            counts[letter] = 1\n    max_count = max(counts.values(), default=0)\n    result = {k: v for k, v in counts.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    freq = {}\n    for letter in letters:\n        if letter in freq:\n            freq[letter] += 1\n        else:\n            freq[letter] = 1\n    max_count = max(freq.values()) if freq else 0\n    result = {k: v for k, v in freq.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    count_dict = {}\n    for letter in letters:\n        if letter in count_dict:\n            count_dict[letter] += 1\n        else:\n            count_dict[letter] = 1\n    max_count = max(count_dict.values(), default=0)\n    result = {k: v for k, v in count_dict.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    count_dict = {}\n    for letter in letters:\n        if letter in count_dict:\n            count_dict[letter] += 1\n        else:\n            count_dict[letter] = 1\n    max_count = max(count_dict.values(), default=0)\n    return {k: v for k, v in count_dict.items() if v == max_count}", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    frequency = {}\n    for letter in letters:\n        if letter in frequency:\n            frequency[letter] += 1\n        else:\n            frequency[letter] = 1\n    max_count = max(frequency.values(), default=0)\n    result = {k: v for k, v in frequency.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    frequency = {}\n    for letter in letters:\n        if letter in frequency:\n            frequency[letter] += 1\n        else:\n            frequency[letter] = 1\n    max_count = max(frequency.values(), default=0)\n    result = {k: v for k, v in frequency.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    counts = {}\n    for letter in letters:\n        if letter in counts:\n            counts[letter] += 1\n        else:\n            counts[letter] = 1\n    max_count = max(counts.values(), default=0)\n    result = {k: v for k, v in counts.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test or test.isspace():\n        return {}\n    letters = test.split()\n    freq = {}\n    for letter in letters:\n        if letter in freq:\n            freq[letter] += 1\n        else:\n            freq[letter] = 1\n    if not freq:\n        return {}\n    max_count = max(freq.values())\n    return {k: v for k, v in freq.items() if v == max_count}"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/113", "requirement": "def odd_count(lst: List[str]) -> List[str]:\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be a string formatted as:\n    \"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n    where {odd_digits} is the count of odd digits ('1', '3', '5', '7', '9') in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if char in '13579'))\n        result.append(f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.')\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if char in '13579'))\n        result.append(f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.')\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if char in '13579'))\n        formatted_string = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_string)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for c in s if c in '13579'))\n        formatted_str = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_str)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for c in s if c in {'1', '3', '5', '7', '9'}))\n        result.append(f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.')\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for c in s if c in '13579'))\n        formatted_string = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_string)\n    return result", "code\nfrom typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if char in {'1', '3', '5', '7', '9'}))\n        formatted_string = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_string)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for c in s if c in {'1', '3', '5', '7', '9'}))\n        formatted_string = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_string)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if char in {'1', '3', '5', '7', '9'}))\n        formatted_str = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_str)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if char in {'1', '3', '5', '7', '9'}))\n        formatted_str = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_str)\n    return result"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/114", "requirement": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums. A sub-array is defined as a contiguous portion of the array containing \n    at least one element. If the input array nums is empty, the function will return \n    float('inf') to indicate that no sub-arrays exist.\n\n    Example:\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    minSubArraySum([]) == float('inf')\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/115", "requirement": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n\n    The number of times you need to lower the buckets is calculated globally for the entire grid. \n    Specifically, the total number of water units across all rows in the grid is summed, \n    and the total is divided by the bucket capacity to determine the minimum number of bucket-lowering actions required. \n    If there is a remainder, an additional bucket-lowering action is needed.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    if total_water == 0:\n        return 0\n    return (total_water + capacity - 1) // capacity", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    if total_water == 0:\n        return 0\n    return (total_water + capacity - 1) // capacity", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return (total_water + capacity - 1) // capacity if total_water > 0 else 0", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return (total_water + capacity - 1) // capacity if total_water > 0 else 0", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    if total_water == 0:\n        return 0\n    return (total_water + capacity - 1) // capacity", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    if total_water % capacity == 0:\n        return total_water // capacity\n    else:\n        return total_water // capacity + 1", "code\nfrom typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    if total_water == 0:\n        return 0\n    return total_water // capacity + (1 if total_water % capacity != 0 else 0)", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    if total_water == 0:\n        return 0\n    return (total_water + capacity - 1) // capacity", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    if total_water == 0:\n        return 0\n    return (total_water + capacity - 1) // capacity", "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    if capacity == 0:\n        return 0\n    if total_water % capacity == 0:\n        return total_water // capacity\n    else:\n        return total_water // capacity + 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort an array of integers based on the following criteria:\n    1. Sort in ascending order by the number of ones in their binary representation.\n       - For negative numbers, the binary representation is determined using Python's `bin()` function, which includes a leading '-' (e.g., `bin(-5) == '-0b101'`).\n       - The count of ones is calculated by ignoring the leading '-' and considering only the binary digits.\n    2. For integers with the same count of ones in their binary representation, sort them in ascending order of their decimal value.\n\n    The function supports both positive and negative integers, as demonstrated in the examples.\n\n    Examples:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        return bin(abs(n)).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        binary = bin(n)\n        return binary.count('1') if n >= 0 else binary.count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        binary = bin(n)\n        return binary.count('1') if n >= 0 else binary.count('1') - 1\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        binary = bin(n)\n        if n < 0:\n            binary = binary[3:]\n        else:\n            binary = binary[2:]\n        return binary.count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n):\n        binary = bin(n)\n        if n < 0:\n            binary = binary[3:]\n        else:\n            binary = binary[2:]\n        return binary.count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        binary = bin(n)\n        if n < 0:\n            binary = binary[3:]\n        else:\n            binary = binary[2:]\n        return binary.count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        binary = bin(n)\n        if binary[0] == '-':\n            binary = binary[3:]\n        else:\n            binary = binary[2:]\n        return binary.count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "code\nfrom typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        binary = bin(n)\n        if n < 0:\n            binary = binary[3:]\n        else:\n            binary = binary[2:]\n        return binary.count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        binary = bin(n)\n        if n < 0:\n            binary = binary[3:]\n        else:\n            binary = binary[2:]\n        return binary.count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        binary = bin(n)\n        if n < 0:\n            binary = binary.lstrip('-0b')\n        else:\n            binary = binary.lstrip('0b')\n        return binary.count('1')\n    sorted_arr = sorted(arr, key=lambda x: (count_ones(x), x))\n    return sorted_arr"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/118", "requirement": "def get_closest_vowel(word: str) -> str:\n    \"\"\"You are given a word. Your task is to find the closest vowel that is positioned \n    between two consonants when traversing the word from right to left (case sensitive).\n\n    Vowels at the beginning or end of the word do not count. Return an empty string if \n    no vowel meets the above condition.\n\n    You may assume that the given string contains English letters only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"", "generated_programs": ["def get_closest_vowel(word: str) -> str:\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    n = len(word)\n    for i in range(n - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i - 1] in consonants and (word[i + 1] in consonants):\n            return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set((chr(i) for i in range(ord('a'), ord('z') + 1))).union(set((chr(i) for i in range(ord('A'), ord('Z') + 1)))) - vowels\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] in consonants and word[i + 1] in consonants:\n                return word[i]\n    return ''"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/122", "requirement": "def add_elements(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements from the first k elements of arr that have at most two digits \n    (i.e., values between -99 and 99, inclusive).\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((num for num in arr[:k] if -99 <= num <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((x for x in arr[:k] if -99 <= x <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((x for x in arr[:k] if -99 <= x <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((x for x in arr[:k] if -99 <= x <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((x for x in arr[:k] if -99 <= x <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    total = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99:\n            total += num\n            count += 1\n        if count == k:\n            break\n    return total", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    result = 0\n    count = 0\n    for num in arr:\n        if count >= k:\n            break\n        if -99 <= num <= 99:\n            result += num\n            count += 1\n    return result", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    total = 0\n    count = 0\n    for num in arr:\n        if count >= k:\n            break\n        if -99 <= num <= 99:\n            total += num\n            count += 1\n    return total", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    result = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99:\n            result += num\n            count += 1\n        if count == k:\n            break\n    return result", "code\nfrom typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    sum_elements = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99:\n            sum_elements += num\n            count += 1\n            if count == k:\n                break\n    return sum_elements"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/124", "requirement": "```python\ndef valid_date(date: str) -> bool:\n    \"\"\"\n    You have to write a function which validates a given date string and\n    returns True if the date is valid, otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The date string must strictly follow the format: mm-dd-yyyy, where:\n       - 'mm' represents a zero-padded month (01 to 12).\n       - 'dd' represents a zero-padded day (01 to 31).\n       - 'yyyy' represents a four-digit year.\n       - Any deviation from this format, such as using slashes ('/') or non-zero-padded values, makes the date invalid.\n    3. The month value must be between 1 and 12 inclusive.\n    4. The day value must satisfy the following conditions based on the month:\n       - For months 1, 3, 5, 7, 8, 10, 12: the day must be between 1 and 31 inclusive.\n       - For months 4, 6, 9, 11: the day must be between 1 and 30 inclusive.\n       - For month 2 (February): the day must be between 1 and 29 inclusive, regardless of whether the year is a leap year or not.\n    5. The function does not validate leap years or century rules for February 29. It assumes February can have up to 29 days in any year.\n\n    Examples:\n    valid_date('03-11-2000') => True\n    valid_date('15-01-2012') => False\n    valid_date('04-0-2040') => False\n    valid_date('06-04-2020') => True\n    valid_date('06/04/2020') => False\n\n    Input and expected output examples:\n    ### Test 1\n    Input: ['02-29-1900']\n    Expected Output: [True]\n    ### Test 2\n    Input: ['08-00-2019']\n    Expected Output: [False]\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^\\\\d{2}-\\\\d{2}-\\\\d{4}$'\n    if not re.match(pattern, date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = re.compile('^\\\\d{2}-\\\\d{2}-\\\\d{4}$')\n    if not pattern.match(date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    month = int(mm)\n    day = int(dd)\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    month = int(mm)\n    day = int(dd)\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = re.compile('^\\\\d{2}-\\\\d{2}-\\\\d{4}$')\n    if not pattern.match(date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    month = int(mm)\n    if month < 1 or month > 12:\n        return False\n    day = int(dd)\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^\\\\d{2}-\\\\d{2}-\\\\d{4}$'\n    if not re.match(pattern, date):\n        return False\n    month, day, year = date.split('-')\n    if not 1 <= int(month) <= 12:\n        return False\n    if int(month) in {1, 3, 5, 7, 8, 10, 12}:\n        if not 1 <= int(day) <= 31:\n            return False\n    elif int(month) in {4, 6, 9, 11}:\n        if not 1 <= int(day) <= 30:\n            return False\n    elif int(month) == 2:\n        if not 1 <= int(day) <= 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^\\\\d{2}-\\\\d{2}-\\\\d{4}$'\n    if not re.match(pattern, date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if not 1 <= int(mm) <= 12:\n        return False\n    if int(mm) in {1, 3, 5, 7, 8, 10, 12}:\n        if not 1 <= int(dd) <= 31:\n            return False\n    elif int(mm) in {4, 6, 9, 11}:\n        if not 1 <= int(dd) <= 30:\n            return False\n    elif int(mm) == 2:\n        if not 1 <= int(dd) <= 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = re.compile('^\\\\d{2}-\\\\d{2}-\\\\d{4}$')\n    if not pattern.match(date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if len(mm) != 2 or len(dd) != 2 or len(yyyy) != 4:\n        return False\n    month = int(mm)\n    day = int(dd)\n    year = int(yyyy)\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        return 1 <= day <= 31\n    if month in {4, 6, 9, 11}:\n        return 1 <= day <= 30\n    if month == 2:\n        return 1 <= day <= 29\n    return False", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = re.compile('^\\\\d{2}-\\\\d{2}-\\\\d{4}$')\n    if not pattern.match(date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    month = int(mm)\n    day = int(dd)\n    year = int(yyyy)\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True", "def valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    try:\n        mm, dd, yyyy = date.split('-')\n        if len(mm) != 2 or len(dd) != 2 or len(yyyy) != 4:\n            return False\n        month = int(mm)\n        day = int(dd)\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            if day < 1 or day > 31:\n                return False\n        elif month in {4, 6, 9, 11}:\n            if day < 1 or day > 30:\n                return False\n        elif month == 2:\n            if day < 1 or day > 29:\n                return False\n        return True\n    except ValueError:\n        return False", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date or not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if not (mm.isdigit() and dd.isdigit() and yyyy.isdigit()):\n        return False\n    mm = int(mm)\n    dd = int(dd)\n    yyyy = int(yyyy)\n    if mm < 1 or mm > 12:\n        return False\n    if mm in {1, 3, 5, 7, 8, 10, 12}:\n        if dd < 1 or dd > 31:\n            return False\n    elif mm in {4, 6, 9, 11}:\n        if dd < 1 or dd > 30:\n            return False\n    elif mm == 2:\n        if dd < 1 or dd > 29:\n            return False\n    return True"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.30000000000000004, "original_passk": 0.0}}
{"task_id": "HumanEval/126", "requirement": "def is_sorted(lst: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return whether or not they are sorted in ascending order.\n    Additionally, if any number appears more than twice in the list, return False.\n    Assume the list contains only non-negative integers.\n\n    Examples:\n    is_sorted([5])  True\n    is_sorted([1, 2, 3, 4, 5])  True\n    is_sorted([1, 3, 2, 4, 5])  False\n    is_sorted([1, 2, 3, 4, 5, 6])  True\n    is_sorted([1, 2, 3, 4, 5, 6, 7])  True\n    is_sorted([1, 3, 2, 4, 5, 6, 7])  False\n    is_sorted([1, 2, 2, 3, 3, 4])  True\n    is_sorted([1, 2, 2, 2, 3, 4])  False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if lst != sorted(lst):\n        return False\n    for num in set(lst):\n        if lst.count(num) > 2:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if lst != sorted(lst):\n        return False\n    cnt = Counter(lst)\n    for num in cnt:\n        if cnt[num] > 2:\n            return False\n    return True", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1))):\n        return False\n    from collections import Counter\n    counts = Counter(lst)\n    return all((count <= 2 for count in counts.values()))", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if lst != sorted(lst):\n        return False\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n        if counts[num] > 2:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not lst:\n        return True\n    if any((count > 2 for count in Counter(lst).values())):\n        return False\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not lst:\n        return True\n    cnt = Counter(lst)\n    for num, freq in cnt.items():\n        if freq > 2:\n            return False\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not lst:\n        return True\n    if any((v > 2 for v in Counter(lst).values())):\n        return False\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not lst:\n        return True\n    count = Counter(lst)\n    if any((v > 2 for v in count.values())):\n        return False\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if len(lst) == 0:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    from collections import defaultdict\n    count = defaultdict(int)\n    for num in lst:\n        count[num] += 1\n        if count[num] > 2:\n            return False\n    return True", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if len(lst) == 0:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    from collections import Counter\n    count = Counter(lst)\n    for num in count:\n        if count[num] > 2:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/127", "requirement": "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"\n    You are given two intervals, where each interval is a pair of integers. \n    For example, interval = (start, end) = (1, 2). The given intervals are closed, \n    which means that the interval (start, end) includes both start and end points.\n\n    For each given interval, it is guaranteed that its start is less than or equal to its end. \n    Your task is to determine whether the length of the intersection of these two intervals \n    is a prime number.\n\n    The intersection of two intervals is defined as the range that is common to both intervals. \n    Specifically:\n        - The start of the intersection is the maximum of the start points of the two intervals.\n        - The end of the intersection is the minimum of the end points of the two intervals.\n    If the start of the intersection is greater than the end of the intersection, \n    the intervals do not overlap, and the intersection is considered empty.\n\n    The length of the intersection is calculated as `end - start + 1`, \n    which accounts for the closed nature of the intervals. \n\n    A prime number is defined as a positive integer greater than 1 that has no divisors \n    other than 1 and itself. If the length of the intersection is a prime number, \n    return \"YES\". Otherwise, return \"NO\". If the two intervals do not intersect, return \"NO\".\n\n    Examples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    if is_prime(length):\n        return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a unique value in the range [1, N * N] inclusive. \n    You need to find the lexicographically smallest path of length k in the grid. \n\n    A path of length k means visiting exactly k cells (not necessarily distinct). \n    You can start from any cell, and in each step, you can move to any of the \n    neighboring cells that share an edge with your current cell. You cannot move \n    outside the grid boundaries.\n\n    The lexicographically smallest path is determined as follows:\n    - For any two paths A and B of length k, construct ordered lists of the values \n      on the cells that A and B traverse (lst_A and lst_B).\n    - Path A is considered smaller than path B if lst_A is lexicographically less \n      than lst_B. This means there exists an integer index i (1 <= i <= k) such that \n      lst_A[i] < lst_B[i], and for any j (1 <= j < i), lst_A[j] = lst_B[j].\n\n    The comparison is applied globally across all valid paths of length k starting \n    from any cell in the grid. The answer is guaranteed to be unique, meaning there \n    is exactly one lexicographically smallest path.\n\n    Implementation details:\n    - The function explores all possible paths of length k starting from every cell \n      in the grid using depth-first search (DFS).\n    - It uses a min-heap to efficiently track the lexicographically smallest path \n      among all valid paths. The heap stores paths as lists of integers, and paths \n      are compared lexicographically.\n\n    Return an ordered list of the values on the cells that the lexicographically \n    smallest path goes through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                heapq.heappush(heap, (path + [grid[nx][ny]], nx, ny))\n    return []", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                heapq.heappush(heap, (path + [grid[nx][ny]], nx, ny))\n    return []", "import heapq\nfrom typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(heap, (new_path, nx, ny))\n    return []", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    heap = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(heap, (new_path, nx, ny))\n    return []", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path.copy()\n                new_path.append(grid[nx][ny])\n                heapq.heappush(heap, (new_path, nx, ny))\n    return []", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(min_heap, ([grid[i][j]], (i, j, 1)))\n    while min_heap:\n        path, (i, j, length) = heapq.heappop(min_heap)\n        if length == k:\n            return path\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < n and 0 <= y < n:\n                heapq.heappush(min_heap, (path + [grid[x][y]], (x, y, length + 1)))\n    return []", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(min_heap, ([grid[i][j]], i, j))\n    while min_heap:\n        path, x, y = heapq.heappop(min_heap)\n        if len(path) == k:\n            return path\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(min_heap, (new_path, nx, ny))\n    return []", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(heap, (new_path, nx, ny))\n    return []", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(min_heap, ([grid[i][j]], i, j))\n    while min_heap:\n        path, x, y = heapq.heappop(min_heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(min_heap, (new_path, nx, ny))\n    return []", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    visited = set()\n    heap = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        if (x, y, tuple(path)) in visited:\n            continue\n        visited.add((x, y, tuple(path)))\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(heap, (new_path, nx, ny))\n    return []"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "HumanEval/130", "requirement": "from typing import List\n\ndef tri(n: int) -> List[float]:\n    \"\"\"\n    The Tribonacci sequence is a variation of the Fibonacci sequence, defined by the following rules:\n    - tri(0) = 1.0\n    - tri(1) = 3.0\n    - tri(n) = 1 + n / 2, if n is even and n > 1.\n    - tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd and n > 1.\n\n    The sequence is computed recursively, with no bounds restrictions on recursive calls. For example:\n    - tri(2) = 1 + (2 / 2) = 2.0\n    - tri(4) = 1 + (4 / 2) = 3.0\n    - tri(3) = tri(2) + tri(1) + tri(4)\n             = 2.0 + 3.0 + 3.0 = 8.0\n\n    You are given a non-negative integer `n`, and the function returns a list of the first `n + 1` numbers \n    of the Tribonacci sequence, starting explicitly at `tri(0)`.\n\n    Examples:\n    tri(3) = [1.0, 3.0, 2.0, 8.0]\n    tri(4) = [1.0, 3.0, 2.0, 8.0, 3.0]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(k: int) -> float:\n        if k == 0:\n            return 1.0\n        elif k == 1:\n            return 3.0\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return compute_tri(k - 1) + compute_tri(k - 2) + compute_tri(k + 1)\n    return [compute_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(k: int) -> float:\n        if k == 0:\n            return 1.0\n        elif k == 1:\n            return 3.0\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return compute_tri(k - 1) + compute_tri(k - 2) + compute_tri(k + 1)\n    return [compute_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(k: int) -> float:\n        if k == 0:\n            return 1.0\n        elif k == 1:\n            return 3.0\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return compute_tri(k - 1) + compute_tri(k - 2) + compute_tri(k + 1)\n    return [compute_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(k: int) -> float:\n        if k == 0:\n            return 1.0\n        elif k == 1:\n            return 3.0\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return compute_tri(k - 1) + compute_tri(k - 2) + compute_tri(k + 1)\n    return [compute_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def calculate_tri(k: int) -> float:\n        if k == 0:\n            return 1.0\n        elif k == 1:\n            return 3.0\n        elif k % 2 == 0 and k > 1:\n            return 1 + k / 2\n        else:\n            return calculate_tri(k - 1) + calculate_tri(k - 2) + calculate_tri(k + 1)\n    return [calculate_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(k: int) -> float:\n        if k == 0:\n            return 1.0\n        elif k == 1:\n            return 3.0\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return compute_tri(k - 1) + compute_tri(k - 2) + compute_tri(k + 1)\n    return [compute_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(k: int) -> float:\n        if k == 0:\n            return 1.0\n        elif k == 1:\n            return 3.0\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return compute_tri(k - 1) + compute_tri(k - 2) + compute_tri(k + 1)\n    return [compute_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    if n == 1:\n        return [1.0, 3.0]\n    res = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            res.append(1 + i / 2)\n        else:\n            res.append(res[i - 1] + res[i - 2] + (1 + (i + 1) / 2 if i + 1 <= n else 0))\n    return res", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {}\n\n    def tribonacci(k: int) -> float:\n        if k in memo:\n            return memo[k]\n        if k == 0:\n            return 1.0\n        if k == 1:\n            return 3.0\n        if k > 1 and k % 2 == 0:\n            memo[k] = 1 + k / 2\n            return memo[k]\n        if k > 1 and k % 2 == 1:\n            memo[k] = tribonacci(k - 1) + tribonacci(k - 2) + tribonacci(k + 1)\n            return memo[k]\n    return [tribonacci(i) for i in range(n + 1)]", "code\nfrom typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {}\n\n    def compute_tri(k: int) -> float:\n        if k in memo:\n            return memo[k]\n        if k == 0:\n            memo[k] = 1.0\n        elif k == 1:\n            memo[k] = 3.0\n        elif k > 1 and k % 2 == 0:\n            memo[k] = 1 + k / 2\n        elif k > 1 and k % 2 != 0:\n            memo[k] = compute_tri(k - 1) + compute_tri(k - 2) + compute_tri(k + 1)\n        return memo[k]\n    for i in range(n + 1):\n        compute_tri(i)\n    return [compute_tri(i) for i in range(n + 1)]"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.09999999999999998, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')  True\n    is_nested('[]]]]]]][[[[[]')  False\n    is_nested('[][]')  False\n    is_nested('[]')  False\n    is_nested('[[][]]')  True\n    is_nested('[[]][[')  True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            if stack:\n                nested = True\n            stack.append(char)\n        elif stack:\n            stack.pop()\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    has_nested = True\n    return has_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n            else:\n                stack.append(char)\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n            else:\n                stack.append(char)\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n            else:\n                stack.append(char)\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    nested = True\n            else:\n                stack.append(char)\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                if stack[-1] == '[':\n                    stack.pop()\n                    if stack:\n                        nested = True\n                else:\n                    stack.append(char)\n            else:\n                stack.append(char)\n    return nested"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/134", "requirement": "```python\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    \"\"\"\n    Create a function that returns True if the last meaningful word in a given \n    string consists of only one character, and that character is an alphabetical \n    letter. Return False otherwise.\n\n    The function should adhere to the following rules:\n    1. If the input string is empty or contains only spaces, return False.\n    2. Leading and trailing spaces are removed before processing the string.\n    3. The last meaningful word is defined as the last group of non-space \n       characters separated by spaces, and it must appear at the end of the \n       original string after stripping.\n    4. The function checks the last meaningful word and validates:\n       - The word consists of only one character.\n       - That character is an alphabetical letter.\n    5. If there are trailing spaces after the last meaningful word in the \n       original string, they invalidate the identification of the last word, \n       and the function returns False.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\")  False\n    check_if_last_char_is_a_letter(\"apple pi e\")  True\n    check_if_last_char_is_a_letter(\"apple pi e \")  False\n    check_if_last_char_is_a_letter(\"\")  False \n    \"\"\"\n```", "generated_programs": ["def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    if stripped_txt != txt.rstrip():\n        return False\n    last_word = stripped_txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    if stripped_txt[-1] == ' ':\n        return False\n    last_word = stripped_txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    last_part = stripped_txt.split()[-1]\n    if len(last_part) == 1 and last_part.isalpha():\n        return not txt.rstrip().endswith(' ')\n    return False", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    if stripped_txt[-1] == ' ':\n        return False\n    last_word = stripped_txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped = txt.strip()\n    if not stripped:\n        return False\n    if stripped[-1] == ' ':\n        return False\n    words = stripped.split()\n    last_word = words[-1] if words else ''\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    if stripped_txt[-1].isspace():\n        return False\n    last_word = stripped_txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    last_word = stripped_txt.split()[-1]\n    if len(last_word) != 1:\n        return False\n    if not last_word[-1].isalpha():\n        return False\n    if txt.rstrip() != stripped_txt:\n        return False\n    return True", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    if stripped_txt != txt:\n        return False\n    words = stripped_txt.split()\n    if not words:\n        return False\n    last_word = words[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    if stripped_txt[-1].isspace():\n        return False\n    words = stripped_txt.split()\n    if not words:\n        return False\n    last_word = words[-1]\n    if len(last_word) != 1:\n        return False\n    return last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.strip()\n    if not stripped_txt:\n        return False\n    words = stripped_txt.split()\n    if not words:\n        return False\n    last_word = words[-1]\n    if len(last_word) != 1:\n        return False\n    if not last_word[-1].isalpha():\n        return False\n    if txt.strip() != txt.rstrip():\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/137", "requirement": "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing real numbers, and returns the larger variable \n    in its given variable type. The comparison prioritizes numeric interpretation of values wherever possible. \n\n    - If both inputs are strings, they are first converted to numeric values by replacing commas (`,`) with decimals (`.`) \n      and then parsed as floats. If the conversion fails for either string, the function returns None.\n    - For mixed types (e.g., an integer vs a string or a float vs a string), the string input is converted to a numeric \n      value using the same method. If the conversion fails, the function returns None.\n    - If both inputs are successfully converted to numeric values, the comparison is performed based on their numeric \n      values. The function returns the original input corresponding to the larger numeric value.\n    - If the numeric values are equal, the function returns None.\n    - If neither input can be converted to a numeric value, the function returns None.\n\n    Note: If a real number is represented as a string, the floating point might be `.` or `,`.\n\n    Examples:\n    compare_one(1, 2.5)  2.5\n    compare_one(1, \"2,3\")  \"2,3\"\n    compare_one(\"5,1\", \"6\")  \"6\"\n    compare_one(\"1\", 1)  None\n    \"\"\"", "generated_programs": ["from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_num(value):\n        if isinstance(value, str):\n            try:\n                value = value.replace(',', '.')\n                return float(value)\n            except ValueError:\n                return None\n        return float(value)\n    a_num = to_num(a)\n    b_num = to_num(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    return a if a_num > b_num else b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_numeric(value):\n        if isinstance(value, str):\n            try:\n                return float(value.replace(',', '.'))\n            except ValueError:\n                return None\n        return float(value) if isinstance(value, (int, float)) else None\n    a_num = to_numeric(a)\n    b_num = to_numeric(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    return a if a_num > b_num else b", "code\nfrom typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(x):\n        if isinstance(x, str):\n            try:\n                return float(x.replace(',', '.'))\n            except ValueError:\n                return None\n        return float(x)\n    a_num = convert_to_float(a)\n    b_num = convert_to_float(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    if a_num > b_num:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        return float(value)\n    a_num = to_float(a)\n    b_num = to_float(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    if a_num > b_num:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        return float(value)\n    a_num = to_float(a)\n    b_num = to_float(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    if a_num > b_num:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_float(value):\n        if isinstance(value, str):\n            try:\n                return float(value.replace(',', '.'))\n            except ValueError:\n                return None\n        return float(value)\n    a_float = to_float(a)\n    b_float = to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float == b_float:\n        return None\n    if a_float > b_float:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value):\n        if isinstance(value, str):\n            try:\n                return float(value.replace(',', '.'))\n            except ValueError:\n                return None\n        return float(value)\n    a_float = convert_to_float(a)\n    b_float = convert_to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float == b_float:\n        return None\n    if a_float > b_float:\n        return a\n    else:\n        return b", "code\nfrom typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_numeric(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        return float(value) if not isinstance(value, (int, float)) else float(value)\n    a_numeric = to_numeric(a)\n    b_numeric = to_numeric(b)\n    if a_numeric is None or b_numeric is None:\n        return None\n    if a_numeric == b_numeric:\n        return None\n    if a_numeric > b_numeric:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_float(value):\n        if isinstance(value, str):\n            try:\n                return float(value.replace(',', '.'))\n            except ValueError:\n                return None\n        elif isinstance(value, (int, float)):\n            return float(value)\n        return None\n    a_float = to_float(a)\n    b_float = to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float == b_float:\n        return None\n    if a_float > b_float:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_float(value: Union[int, float, str]) -> Union[float, None]:\n        if isinstance(value, (int, float)):\n            return float(value)\n        if isinstance(value, str):\n            try:\n                return float(value.replace(',', '.'))\n            except ValueError:\n                return None\n        return None\n    a_float = to_float(a)\n    b_float = to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float == b_float:\n        return None\n    if a_float > b_float:\n        return a\n    else:\n        return b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "HumanEval/139", "requirement": "def special_factorial(n: int) -> int:\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n >= 0.\n\n    The function will receive a non-negative integer as input and should return \n    the special factorial of this integer. If n = 0, the result is defined as 1 \n    by convention.\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    >>> special_factorial(0)\n    1\n    \"\"\"", "generated_programs": ["from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/140", "requirement": "```python\ndef fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, replace spaces according to the following rules:\n    1. Replace every single space with an underscore ('_').\n    2. Replace groups of 3 or more consecutive spaces with a single hyphen ('-').\n    3. Double spaces (exactly two consecutive spaces) are treated as two individual spaces, \n       each replaced with an underscore ('_').\n    4. The transformations are applied globally across the input string in the following order:\n       - First, replace groups of 3 or more consecutive spaces with a single hyphen ('-').\n       - Second, replace all remaining single spaces with underscores ('_').\n    5. Only actual spaces (' ') are considered for replacement. Other whitespace characters \n       (e.g., tabs, newlines) are ignored.\n\n    Examples:\n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "HumanEval/141", "requirement": "```python\ndef file_name_check(file_name: str) -> str:\n    \"\"\"\n    Create a function which takes a string representing a file's name, and returns\n    'Yes' if the file's name is valid, and returns 'No' otherwise.\n    \n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - The file's name contains exactly one dot '.', which separates the prefix (substring \n      before the dot) and the suffix (substring after the dot). Trailing dots or multiple \n      dots are not allowed.\n    - The prefix must not be empty, and it must start with a letter from the Latin alphabet \n      ('a'-'z' and 'A'-'Z'). The rest of the prefix can contain any combination of letters, \n      digits, or other characters.\n    - The total number of digits ('0'-'9') in the entire file name (both prefix and suffix) \n      must not exceed three.\n    - The suffix must be one of these: ['txt', 'exe', 'dll'].\n    \n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a Latin alphabet letter)\n    \"\"\"\n```", "generated_programs": ["def file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if len(re.findall('\\\\d', file_name)) > 3:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if not file_name.count('.') == 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if not re.match('^[a-zA-Z][a-zA-Z0-9_]*$', prefix):\n        return 'No'\n    if len(re.findall('\\\\d', file_name)) > 3:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'"], "result": {"repaired_passk": 0.4, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers in ascending order \n    based on the sum of the absolute values of their digits. \n\n    Sorting rules:\n    1. The sum of the absolute values of the digits of each integer is used as the primary sorting key.\n       For example, for -11, the sum of absolute digits is 1 + 1 = 2.\n    2. If two integers have the same digit sum, their order in the original list is used as a tie-breaker.\n       For example, if two integers have a digit sum of 2, the one that appears earlier in the original list \n       will precede the other in the sorted output.\n\n    Additional notes:\n    - Negative numbers are treated based on the absolute values of their digits, and their sign does not affect sorting.\n    - The function handles edge cases such as empty lists, single-element lists, and lists containing only negative numbers.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_digits(num):\n        return sum((int(digit) for digit in str(abs(num))))\n    return sorted(nums, key=lambda x: (sum_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n: int) -> int:\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n)) if d.isdigit()))\n\n    def sort_key(index):\n        return (sum_of_digits(nums[index]), index)\n    sorted_indices = sorted(range(len(nums)), key=sort_key)\n    return [nums[i] for i in sorted_indices]", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(digit) for digit in str(abs(n))))\n\n    def custom_sort_key(index):\n        return (sum_of_digits(nums[index]), index)\n    sorted_indices = sorted(range(len(nums)), key=custom_sort_key)\n    return [nums[i] for i in sorted_indices]", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/146", "requirement": "def specialFilter(nums: List[int]) -> int:\n    \"\"\"\n    Write a function that takes a list of integers as input and returns the count of numbers \n    in the list that satisfy the following conditions:\n    1. The number is strictly greater than 10 (positive numbers only).\n    2. Both the first and last digits of the absolute value of the number are odd digits \n       (odd digits are 1, 3, 5, 7, 9).\n\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            absolute_num = abs(num)\n            first_digit = int(str(absolute_num)[0])\n            last_digit = absolute_num % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            num_abs = abs(num)\n            first_digit = int(str(num_abs)[0])\n            last_digit = num_abs % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if first_digit % 2 == 1 and last_digit % 2 == 1:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            num_abs = abs(num)\n            digits = str(num_abs)\n            first_digit = int(digits[0])\n            last_digit = int(digits[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n\n    def is_first_and_last_odd(n: int) -> bool:\n        n = abs(n)\n        digits = str(n)\n        first = int(digits[0])\n        last = int(digits[-1])\n        return first % 2 == 1 and last % 2 == 1\n    count = 0\n    for num in nums:\n        if num > 10 and is_first_and_last_odd(num):\n            count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n\n    def is_odd_digit(n: int) -> bool:\n        return n % 2 != 0\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if is_odd_digit(first_digit) and is_odd_digit(last_digit):\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n\n    def is_odd_digit(digit: int) -> bool:\n        return digit in {1, 3, 5, 7, 9}\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = int(str(abs_num)[0])\n            last_digit = abs_num % 10\n            if is_odd_digit(first_digit) and is_odd_digit(last_digit):\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n\n    def is_odd_digit(d):\n        return d in {1, 3, 5, 7, 9}\n    count = 0\n    for num in nums:\n        if num > 10:\n            abs_num = abs(num)\n            first_digit = abs_num\n            while first_digit >= 10:\n                first_digit //= 10\n            last_digit = abs_num % 10\n            if is_odd_digit(first_digit) and is_odd_digit(last_digit):\n                count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/147", "requirement": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1  i  n), the value of a[i] is calculated as i * i - i + 1.\n    Return the number of triples (a[i], a[j], a[k]) such that i < j < k, and the sum \n    of the elements in the triple (a[i] + a[j] + a[k]) is divisible by 3.\n\n    Example:\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"", "generated_programs": ["from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from typing import List\nfrom itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    remainder_count = {0: 0, 1: 0, 2: 0}\n    for num in a:\n        remainder = num % 3\n        remainder_count[remainder] += 1\n    count += remainder_count[0] * remainder_count[1] * remainder_count[2]\n    count += remainder_count[0] * (remainder_count[0] - 1) * (remainder_count[0] - 2) // 6\n    count += remainder_count[1] * (remainder_count[1] - 1) * (remainder_count[1] - 2) // 6\n    count += remainder_count[2] * (remainder_count[2] - 1) * (remainder_count[2] - 2) // 6\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/153", "requirement": "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    \"\"\"\n    You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n\n    If the list of extensions is empty, the function must raise a `ValueError`.\n\n    Negative values for strength are valid and should be considered when determining\n    the strongest extension.\n\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\n    Input and expected output examples:\n    ### Test 1\n    Input: ['EmptyClass', []]\n    Expected Output: ['ValueError']\n    ### Test 2\n    Input: ['EmptyClass', []]\n    Expected Output: ['ValueError']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError\n\n    def calculate_strength(extension):\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = max(extensions, key=lambda x: calculate_strength(x))\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions is empty.')\n    max_strength = -float('inf')\n    strongest_extension = ''\n    for ext in extensions:\n        cap = sum((1 for char in ext if char.isupper()))\n        sm = sum((1 for char in ext if char.islower()))\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = ext\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions is empty.')\n    strongest_extension = None\n    max_strength = -float('inf')\n    for extension in extensions:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "code\nfrom typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n    strongest_extension = None\n    max_strength = -float('inf')\n    for extension in extensions:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions is empty.')\n\n    def calculate_strength(extension: str) -> int:\n        CAP = sum((1 for char in extension if char.isupper()))\n        SM = sum((1 for char in extension if char.islower()))\n        return CAP - SM\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        strength = calculate_strength(extension)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = None\n    max_strength = -float('inf')\n    for extension in extensions:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            max_strength = current_strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions is empty.')\n\n    def calculate_strength(extension: str) -> int:\n        CAP = sum((1 for char in extension if char.isupper()))\n        SM = sum((1 for char in extension if char.islower()))\n        return CAP - SM\n    strongest = extensions[0]\n    max_strength = calculate_strength(strongest)\n    for ext in extensions[1:]:\n        current_strength = calculate_strength(ext)\n        if current_strength > max_strength:\n            strongest = ext\n            max_strength = current_strength\n    return f'{class_name}.{strongest}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('Extensions list cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        strength = calculate_strength(extension)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('The list of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            max_strength = current_strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('List of extensions cannot be empty.')\n\n    def calculate_strength(extension: str) -> int:\n        CAP = sum((1 for char in extension if char.isupper()))\n        SM = sum((1 for char in extension if char.islower()))\n        return CAP - SM\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            strongest_extension = extension\n            max_strength = current_strength\n    return f'{class_name}.{strongest_extension}'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"\n    You are given two words, `a` and `b`. The function returns `True` if the second word (`b`) or any of its cyclic rotations \n    is a substring of the first word (`a`). Otherwise, it returns `False`.\n\n    The behavior is defined as follows:\n    1. **Rotations of `b`**: Cyclic rotations of `b` are generated using the formula `s[i:] + s[:i]` for `i` from 0 to the length of `s`.\n       For example, the rotations of `\"abc\"` are `[\"abc\", \"bca\", \"cab\"]`.\n    2. **Substring Check**: Each rotation of `b` is checked to see if it exists as a substring in `a`. If any rotation matches, the function returns `True`.\n       Otherwise, it returns `False`.\n    3. **Empty Strings Handling**:\n       - If `b` is an empty string, its rotations list is empty (`[]`), and no substring matches occur, resulting in a return value of `False`.\n       - If `a` is an empty string, no substring matches can occur regardless of `b`'s rotations, and the function returns `False`.\n\n    Examples:\n    cycpattern_check(\"abcd\", \"abd\") => False\n    cycpattern_check(\"hello\", \"ell\") => True\n    cycpattern_check(\"whassup\", \"psus\") => False\n    cycpattern_check(\"abab\", \"baa\") => True\n    cycpattern_check(\"efef\", \"eeff\") => False\n    cycpattern_check(\"himenss\", \"simen\") => True\n    cycpattern_check(\"\", \"\") => False\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    n = len(b)\n    for i in range(n):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b or not a:\n        return False\n    n = len(b)\n    for i in range(n):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return False\n    n = len(b)\n    for i in range(n):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b or not a:\n        return False\n    n = len(b)\n    for i in range(n):\n        rotation = b[i:] + b[:i]\n        if rotation in a:\n            return True\n    return False", "code\n\ndef cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return False\n    for i in range(len(b)):\n        rotation = b[i:] + b[:i]\n        if rotation in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b or not a:\n        return False\n    n = len(b)\n    for i in range(n):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return False\n    n = len(b)\n    for i in range(n):\n        rotation = b[i:] + b[:i]\n        if rotation in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    n = len(b)\n    for i in range(n):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b or not a:\n        return False\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "HumanEval/158", "requirement": "def find_max(words: List[str]) -> str:\n    \"\"\"\n    Write a function that accepts a list of strings.\n    The list contains different words. Return the word with the maximum number\n    of unique characters. If multiple strings have the maximum number of unique\n    characters, return the lexicographically smallest one (case-sensitive).\n\n    Clarifications:\n    - A \"unique character\" considers all characters in the string, including letters,\n      digits, and special characters. Each character is treated individually, and \n      duplicates within the same word do not count as unique.\n    - If the input list is empty, return an empty string.\n    - Duplicate words in the list are treated as separate valid entries, and their \n      uniqueness is calculated independently.\n    - Lexicographical comparison is case-sensitive (e.g., \"Apple\" < \"apple\").\n    - The function iterates through the list and compares words based on their \n      unique character count first, and lexicographical order second, to determine \n      the result.\n\n    Examples:\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique or (unique_count == max_unique and word < result):\n            max_unique = unique_count\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    candidates = []\n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique:\n            max_unique = unique_count\n            candidates = [word]\n        elif unique_count == max_unique:\n            candidates.append(word)\n    return min(candidates) if candidates else ''", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique or (unique_chars == max_unique and word < result):\n            max_unique = unique_chars\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n\n    def unique_count(word):\n        return len(set(word))\n    max_unique = max(words, key=unique_count)\n    candidates = [word for word in words if unique_count(word) == unique_count(max_unique)]\n    return min(candidates) if candidates else ''", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique or (unique_chars == max_unique and word < result):\n            max_unique = unique_chars\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    candidates = []\n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique:\n            max_unique = unique_count\n            candidates = [word]\n        elif unique_count == max_unique:\n            candidates.append(word)\n    return min(candidates)", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n\n    def unique_char_count(word):\n        return len(set(word))\n    max_word = ''\n    max_unique = -1\n    for word in words:\n        current_unique = unique_char_count(word)\n        if current_unique > max_unique or (current_unique == max_unique and word < max_word):\n            max_word = word\n            max_unique = current_unique\n    return max_word", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result_word = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique or (unique_chars == max_unique and word < result_word):\n            max_unique = unique_chars\n            result_word = word\n    return result_word", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique_chars = -1\n    result_word = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique_chars or (unique_chars == max_unique_chars and word < result_word):\n            max_unique_chars = unique_chars\n            result_word = word\n    return result_word", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n\n    def count_unique_chars(word: str) -> int:\n        return len(set(word))\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_count = count_unique_chars(word)\n        if unique_count > max_unique or (unique_count == max_unique and word < result):\n            max_unique = unique_count\n            result = word\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/160", "requirement": "def do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists: `operator` and `operand`. The first list contains basic algebra operations \n    as strings, and the second list contains integers. Use the two lists to construct an algebraic \n    expression by sequentially combining the operands and operators in the order they appear, \n    and return the evaluation of this expression.\n\n    The basic algebra operations are:\n    - Addition ( + ) \n    - Subtraction ( - ) \n    - Multiplication ( * ) \n    - Floor division ( // ) \n    - Exponentiation ( ** ) \n\n    Construction of the expression:\n    - Start with the first element of the `operand` list.\n    - Sequentially append each operator from the `operator` list followed by the next operand \n      from the `operand` list.\n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    Expression: 2 + 3 * 4 - 5\n    Result: 9\n\n    Note:\n        - The length of the `operator` list is equal to the length of the `operand` list minus one.\n        - The `operand` list contains non-negative integers.\n        - The `operator` list contains at least one operator, and the `operand` list contains at least two operands.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "code\nfrom typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    if not operator or not operand:\n        return 0\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i + 1]\n        elif operator[i] == '-':\n            result -= operand[i + 1]\n        elif operator[i] == '*':\n            result *= operand[i + 1]\n        elif operator[i] == '//':\n            result //= operand[i + 1]\n        elif operator[i] == '**':\n            result **= operand[i + 1]\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return the single-digit even numbers \n    between a and b (inclusive), in ascending order. Single-digit even numbers \n    are defined as {0, 2, 4, 6, 8}.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    return [num for num in range(start, end + 1) if num in {0, 2, 4, 6, 8}]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    return [x for x in range(start, end + 1) if x in {0, 2, 4, 6, 8}]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    return [num for num in range(start, end + 1) if num in {0, 2, 4, 6, 8}]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start, end = (min(a, b), max(a, b))\n    return [i for i in range(start, end + 1) if i in {0, 2, 4, 6, 8}]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_digits = {0, 2, 4, 6, 8}\n    return sorted([x for x in range(start, end + 1) if x in even_digits])", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = [num for num in range(start, end + 1) if num in {0, 2, 4, 6, 8}]\n    return sorted(result)", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = [num for num in range(start, end + 1) if num in {0, 2, 4, 6, 8}]\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if num in {0, 2, 4, 6, 8}:\n            result.append(num)\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    single_digit_evens = {0, 2, 4, 6, 8}\n    start = min(a, b)\n    end = max(a, b)\n    result = [num for num in range(start, end + 1) if num in single_digit_evens]\n    return sorted(result)", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    single_digit_evens = {0, 2, 4, 6, 8}\n    start = min(a, b)\n    end = max(a, b)\n    result = [num for num in range(start, end + 1) if num in single_digit_evens]\n    return sorted(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/1", "requirement": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    stack = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start = stack.pop()\n                if not stack:\n                    groups.append(paren_string[start:i + 1])\n    return groups", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    start = 0\n    paren_string = paren_string.replace(' ', '')\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start = stack.pop()\n                if not stack:\n                    result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    start = 0\n    paren_string = paren_string.replace(' ', '')\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == ' ':\n            continue\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    start_index = 0\n    paren_string = paren_string.replace(' ', '')\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if len(stack) == 1:\n                result.append(paren_string[stack[0]:i + 1])\n            stack.pop()\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    start = 0\n    paren_string = paren_string.replace(' ', '')\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start = stack.pop()\n                if not stack:\n                    result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    start = 0\n    paren_string = paren_string.replace(' ', '')\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    start = 0\n    paren_string = paren_string.replace(' ', '')\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(paren_string[start:i + 1])\n    return result", "code\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if not stack:\n                start = i\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(paren_string[start:i + 1])\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    current_group = ''\n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            if not stack:\n                if current_group:\n                    result.append(current_group)\n                current_group = ''\n            stack.append(char)\n            current_group += char\n        elif char == ')':\n            if stack:\n                stack.pop()\n                current_group += char\n                if not stack:\n                    result.append(current_group)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 1.0}}
{"task_id": "HumanEval/4", "requirement": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate the Mean Absolute Deviation (MAD)\n    around the mean of this dataset. The MAD is defined as the average absolute \n    difference between each element and the mean of the dataset:\n    MAD = average | x - x_mean |\n\n    Preconditions:\n    - The input list `numbers` must be non-empty. If the list is empty, the function \n      will raise a ZeroDivisionError because the mean cannot be computed.\n\n    Edge Cases:\n    - If the input list is empty, the function will raise a ZeroDivisionError.\n    - The function assumes all elements in the list are valid floating-point numbers.\n\n    Example:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    return sum(absolute_differences) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError('Cannot compute mean of an empty list.')\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError('The input list is empty, cannot compute mean.')\n    mean = sum(numbers) / len(numbers)\n    mad = sum((abs(x - mean) for x in numbers)) / len(numbers)\n    return mad", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError('Cannot compute mean of an empty list.')\n    mean = sum(numbers) / len(numbers)\n    return sum((abs(x - mean) for x in numbers)) / len(numbers)", "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError('The input list cannot be empty.')\n    mean = sum(numbers) / len(numbers)\n    mad = sum((abs(x - mean) for x in numbers)) / len(numbers)\n    return mad", "code\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ZeroDivisionError('The input list must be non-empty.')\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    return sum(absolute_differences) / len(numbers)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/5", "requirement": "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"Insert the number 'delimiter' between every two consecutive elements of the input list `numbers`.\n    The delimiter is added after each element except the last one.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that begins with a supplied string.\n    \n    The algorithm works as follows:\n    - Identify the longest suffix of the supplied string that is a palindrome.\n    - Append the reverse of the prefix (the part of the string before this palindromic suffix) to the end of the string.\n    \n    Examples:\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n):\n        if string[i:] == string[i:][::-1]:\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    n = len(string)\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n, -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n, -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[i:][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    for i in range(n - 1, -1, -1):\n        if string[:i + 1] == string[:i + 1][::-1]:\n            return string + string[i + 1:][::-1]\n    return string + string[::-1][1:]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n, -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[i:][::-1]\n    return string", "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    longest_palindrome_suffix = 0\n    for i in range(n, -1, -1):\n        if string[:i] == string[:i][::-1]:\n            longest_palindrome_suffix = i\n            break\n    return string + string[longest_palindrome_suffix:][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n, 0, -1):\n        if is_palindrome(string[:i]):\n            return string + string[i:][::-1]\n    return string + string[1:][::-1]", "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    n = len(string)\n    longest_pal_suffix = 0\n    for i in range(n):\n        if string[i:] == string[i:][::-1]:\n            longest_pal_suffix = n - i\n            break\n    prefix = string[:n - longest_pal_suffix]\n    return string + prefix[::-1]"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.30000000000000004, "original_passk": 0.0}}
{"task_id": "HumanEval/12", "requirement": "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Out of a list of strings, return the longest one. If there are multiple strings of the same maximum length, return the one that appears first in the list. Return None if the input list is empty.\n    >>> longest([])\n    \n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"", "generated_programs": ["from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    max_length = max((len(s) for s in strings))\n    for s in strings:\n        if len(s) == max_length:\n            return s", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    max_length = max((len(s) for s in strings))\n    for s in strings:\n        if len(s) == max_length:\n            return s", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    longest_str = strings[0]\n    for s in strings:\n        if len(s) > len(longest_str):\n            longest_str = s\n    return longest_str", "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    max_length = -1\n    longest_str = None\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            longest_str = s\n    return longest_str"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/18", "requirement": "```python\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"Finds how many times a given `substring` can be found in the `string`, \n    allowing overlapping matches. \n    \n    Overlapping matches are defined such that the search for the next occurrence \n    starts from the character immediately after the starting character of the \n    current match. For example:\n    - For `string='aaaa'` and `substring='aa'`, the first match is `string[0:2]` \n      and the next search starts from `string[1]`.\n\n    Specific behaviors:\n    1. If the `substring` is empty, the function will return `0`. \n       An empty `substring` is considered to have no valid occurrences.\n    2. If the `string` is empty, the function will return `0`. \n       An empty `string` cannot contain any non-empty `substring`. \n    3. The function will handle overlapping cases correctly by searching each \n       possible starting position in the `string`.\n    4. Counts are calculated based on the behavior demonstrated in the examples.\n\n    Examples:\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n```", "generated_programs": ["def how_many_times(string: str, substring: str) -> int:\n    if not substring or not string:\n        return 0\n    count = 0\n    n = len(substring)\n    for i in range(len(string) - n + 1):\n        if string[i:i + n] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i + len(substring)] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring or not string:\n        return 0\n    count = 0\n    n = len(substring)\n    for i in range(len(string) - n + 1):\n        if string[i:i + n] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    n = len(substring)\n    for i in range(len(string) - n + 1):\n        if string[i:i + n] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    count = 0\n    if not substring:\n        return 0\n    n = len(substring)\n    for i in range(len(string) - n + 1):\n        if string[i:i + n] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    count = 0\n    n = len(string)\n    m = len(substring)\n    if m == 0:\n        return 0\n    for i in range(n - m + 1):\n        if string[i:i + m] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring or not string:\n        return 0\n    count = 0\n    n = len(substring)\n    for i in range(len(string) - n + 1):\n        if string[i:i + n] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    n = len(string)\n    m = len(substring)\n    for i in range(n - m + 1):\n        if string[i:i + m] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not string or not substring:\n        return 0\n    count = 0\n    n = len(substring)\n    for i in range(len(string) - n + 1):\n        if string[i:i + n] == substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    if not substring or not string:\n        return 0\n    count = 0\n    n = len(string)\n    m = len(substring)\n    for i in range(n - m + 1):\n        if string[i:i + m] == substring:\n            count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/21", "requirement": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]", "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/24", "requirement": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given positive integer n, find the largest number smaller than n that divides n evenly.\n    - The function iterates through all integers from n-1 down to 1 to find the largest divisor.\n    - If no divisors are found (e.g., when n = 1), the function returns None.\n\n    Edge cases:\n    - For n = 1, there are no divisors smaller than n, so the function returns None.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    None\n    \"\"\"", "generated_programs": ["def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n <= 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "def largest_divisor(n: int) -> int:\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/25", "requirement": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return a list of prime factors of the given integer in the order from smallest to largest.\n    Each of the factors should be listed the number of times corresponding to how many times it appears in the factorization.\n    The input number should be equal to the product of all factors.\n\n    Constraints:\n    - If the input `n` is a negative integer, the function will return an empty list `[]`.\n    - If the input `n` is `0` or `1`, the function will return an empty list `[]` as these values do not have a prime factorization.\n    - The function assumes the input is an integer. If a non-integer value is passed, it will raise a `TypeError` or `ValueError` as per Python's type hinting.\n\n    Examples:\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    if not isinstance(n, int) or n < 2:\n        return factors\n    divisor = 2\n    while n >= divisor:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        divisor += 1\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if not isinstance(n, int) or n < 2:\n        return []\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if not isinstance(n, int) or n < 0:\n        return []\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if not isinstance(n, int) or n < 2:\n        return []\n    factors = []\n    divisor = 2\n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if not isinstance(n, int) or n < 0 or n in {0, 1}:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 1:\n        return []\n    factors = []\n    divisor = 2\n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if not isinstance(n, int) or n < 0 or n == 0 or (n == 1):\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0 or n == 0 or n == 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "from typing import List\n\ndef factorize(n: int) -> List[int]:\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n <= 1:\n        return []\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/32", "requirement": "from typing import List\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["import math\n\ndef poly(xs: list, x: float):\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "import math\n\ndef poly(xs: list, x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\n\ndef poly(xs: list, x: float):\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "import math\n\ndef poly(xs: list, x: float):\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "import math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: List[float]) -> float:\n    from scipy.optimize import fsolve\n    return fsolve(lambda x: poly(xs, x), 0)[0]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/39", "requirement": "def prime_fib(n: int) -> int:\n    \"\"\"\n    prime_fib returns the n-th number that is both a Fibonacci number and a prime number.\n    \n    Requirements:\n    1. The input `n` must be a positive integer (`n > 0`). \n       - If `n <= 0`, the function will raise a `ValueError` with the message \"Input must be a positive integer.\"\n    2. The function starts counting Fibonacci-prime numbers from the first Fibonacci-prime (2) for `n = 1`.\n    3. The function will compute Fibonacci numbers iteratively and check each for primality until the n-th Fibonacci-prime is found.\n    \n    Examples:\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \n    Input and expected output examples:\n    ### Test 1\n    Input: [0]\n    Expected Output: ['ValueError: Input must be a positive integer']\n    \"\"\"", "generated_programs": ["import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (0, 1)\n    while count < n:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n    return a", "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "import math\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    count = 0\n    a, b = (1, 1)\n    while True:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (1, 1)\n    while True:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (1, 1)\n    while True:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (0, 1)\n    while True:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    count = 0\n    a, b = (1, 1)\n    while True:\n        a, b = (b, a + b)\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/41", "requirement": "```python\ndef car_race_collision(n: int) -> int:\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    There are two sets of cars:\n    - The first set consists of n cars driving left to right.\n    - The second set consists of n cars driving right to left.\n    All cars move at the same speed, and the two sets of cars start out being very far from each other.\n\n    A collision is defined as a pairwise interaction between one car from the left-to-right set \n    and one car from the right-to-left set. Since all cars are infinitely sturdy and continue \n    moving in their trajectories, every car in the left-to-right set interacts with every car \n    in the right-to-left set, resulting in n * n collisions.\n\n    This function outputs the total number of such pairwise collisions.\n\n    Input:\n    - n (int): The number of cars in each set. n is a non-negative integer.\n\n    Output:\n    - int: The total number of pairwise collisions, calculated as n * n.\n\n    Examples:\n    ### Test 1\n    Input: [2]\n    Expected Output: [4]\n    ### Test 2\n    Input: [3]\n    Expected Output: [9]\n    \"\"\"\n```", "generated_programs": ["def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n", "def car_race_collision(n: int) -> int:\n    return n * n"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/44", "requirement": "```python\ndef change_base(x: int, base: int) -> str:\n    \"\"\"\n    Change the numerical base of input number x to the specified base and return \n    its string representation after the conversion. If the input number x is zero (0), \n    the function returns an empty string (''). The base must be between 2 and 9 (inclusive).\n\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n\n    Edge case:\n    If x is 0, the function returns an empty string ('').\n    \"\"\"\n```", "generated_programs": ["def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(reversed(digits))", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result", "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return ''\n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/46", "requirement": "```python\ndef fib4(n: int) -> int:\n    \"\"\"\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) for n >= 4.\n\n    Please write a function to efficiently compute the n-th element of the Fib4 number sequence. \n    The function must adhere to the following rules:\n    1. The input `n` will always be an integer.\n    2. If `n` is negative, the function should return 0.\n    3. The function must not use recursion.\n    4. The function should compute the result efficiently using an iterative approach.\n\n    Examples:\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    >>> fib4(-1)\n    0\n    \"\"\"\n```", "generated_programs": ["def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib_values = [0, 0, 2, 0]\n    if n < 4:\n        return fib_values[n]\n    for i in range(4, n + 1):\n        next_fib = sum(fib_values[-4:])\n        fib_values.append(next_fib)\n    return fib_values[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < 4:\n        return fib[n]\n    for i in range(4, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib_values = [0, 0, 2, 0]\n    if n < 4:\n        return fib_values[n]\n    for i in range(4, n + 1):\n        next_value = sum(fib_values[-4:])\n        fib_values.append(next_value)\n    return fib_values[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    fib = [0, 0, 2, 0]\n    if n < 4:\n        return fib[n]\n    for i in range(4, n + 1):\n        next_fib = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4]\n        fib.append(next_fib)\n    return fib[n]", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    if n == 2:\n        return 2\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        a, b, c, d = (b, c, d, a + b + c + d)\n    return d", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    if n == 2:\n        return 2\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        a, b, c, d = (b, c, d, a + b + c + d)\n    return d", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    if n == 2:\n        return 2\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        e = a + b + c + d\n        a, b, c, d = (b, c, d, e)\n    return d", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        e = a + b + c + d\n        a, b, c, d = (b, c, d, e)\n    return d", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 2\n    if n == 3:\n        return 0\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        e = a + b + c + d\n        a, b, c, d = (b, c, d, e)\n    return d", "def fib4(n: int) -> int:\n    if n < 0:\n        return 0\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 2\n    if n == 3:\n        return 0\n    a, b, c, d = (0, 0, 2, 0)\n    for _ in range(4, n + 1):\n        e = a + b + c + d\n        a, b, c, d = (b, c, d, e)\n    return d"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_list[mid - 1] + sorted_list[mid]) / 2\n    else:\n        return sorted_list[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2.0", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 1:\n        return l_sorted[mid]\n    else:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        return (sorted_l[n // 2 - 1] + sorted_l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2\n    else:\n        return l_sorted[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/54", "requirement": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words contain exactly the same set of unique characters, \n    regardless of their order or frequency. The function returns True if \n    the sets of unique characters in both strings are identical, and False otherwise.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"", "generated_programs": ["def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/55", "requirement": "```python\ndef fib(n: int) -> int:\n    \"\"\"\n    Return the n-th Fibonacci number, using a 1-based indexing convention.\n\n    Valid input:\n    - `n` must be a positive integer (1 <= n).\n    \n    Definition and behavior:\n    - The Fibonacci sequence starts at `fib(1)` = 1 and `fib(2)` = 1.\n    - For n > 2, the n-th Fibonacci number is computed as:\n      fib(n) = fib(n-1) + fib(n-2)\n    \n    Error handling:\n    - If `n` is not a positive integer, raise a `ValueError`.\n    \n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n```", "generated_programs": ["def fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    a, b = (1, 1)\n    for _ in range(2, n):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('Input must be a positive integer.')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b", "def fib(n: int) -> int:\n    if not isinstance(n, int) or n < 1:\n        raise ValueError('n must be a positive integer')\n    if n == 1 or n == 2:\n        return 1\n    a, b = (1, 1)\n    for _ in range(3, n + 1):\n        a, b = (b, a + b)\n    return b"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/64", "requirement": "```python\ndef vowels_count(s: str) -> int:\n    \"\"\"\n    Write a function vowels_count which takes a string as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Additionally, 'y' is considered a vowel only when it is the \n    last character of the string. The function is case-insensitive.\n\n    The input string may be empty. If the input string is empty, the function should immediately return 0 without \n    performing any further operations.\n\n    The input string may also contain non-alphabetic characters, which should be ignored when counting vowels. \n    Only alphabetic characters should be considered when determining if a character is a vowel.\n\n    The function should treat 'y' as a vowel only if it is the last character of the string, and this check should \n    only be performed if the string is non-empty.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n```", "generated_programs": ["def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    vowels = set('aeiou')\n    count = 0\n    for i, char in enumerate(s.lower()):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == length - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    for i, char in enumerate(s.lower()):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    last_char = s_lower[-1]\n    if last_char == 'y':\n        count += 1\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    for i, char in enumerate(s_lower):\n        if char in vowels or (char == 'y' and i == len(s) - 1):\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    for i, char in enumerate(s.lower()):\n        if char in vowels:\n            count += 1\n        if i == len(s) - 1 and char == 'y':\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if i == len(s_lower) - 1 and char == 'y':\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        if char == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count", "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i, char in enumerate(s_lower):\n        if char in vowels and char.isalpha():\n            count += 1\n    if s_lower[-1] == 'y' and s_lower[-1].isalpha():\n        count += 1\n    return count"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/70", "requirement": "def strange_sort_list(lst: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list sorted in a specific \"strange\" order.\n    The \"strange\" sorting order alternates between the smallest and largest remaining \n    integers in the list. Specifically:\n    - Start with the smallest integer in the list.\n    - Then take the largest of the remaining integers.\n    - Continue alternating between the smallest and largest of the remaining integers \n      until all integers are used.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    result = []\n    lst_sorted = sorted(lst)\n    left, right = (0, len(lst_sorted) - 1)\n    while left <= right:\n        result.append(lst_sorted[left])\n        if left != right:\n            result.append(lst_sorted[right])\n        left += 1\n        right -= 1\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    while left <= right:\n        if left == right:\n            result.append(sorted_lst[left])\n        else:\n            result.append(sorted_lst[left])\n            result.append(sorted_lst[right])\n        left += 1\n        right -= 1\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    result = []\n    lst_sorted = sorted(lst)\n    left, right = (0, len(lst_sorted) - 1)\n    while left <= right:\n        if left == right:\n            result.append(lst_sorted[left])\n        else:\n            result.append(lst_sorted[left])\n            result.append(lst_sorted[right])\n        left += 1\n        right -= 1\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    lst_sorted = sorted(lst)\n    result = []\n    left, right = (0, len(lst_sorted) - 1)\n    alternate = True\n    while left <= right:\n        if alternate:\n            result.append(lst_sorted[left])\n            left += 1\n        else:\n            result.append(lst_sorted[right])\n            right -= 1\n        alternate = not alternate\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = (0, len(sorted_lst) - 1)\n    alternate = True\n    while left <= right:\n        if alternate:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        alternate = not alternate\n    return result", "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    lst_sorted = sorted(lst)\n    result = []\n    left, right = (0, len(lst_sorted) - 1)\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(lst_sorted[left])\n            left += 1\n        else:\n            result.append(lst_sorted[right])\n            right -= 1\n        toggle = not toggle\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/74", "requirement": "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    '''\n    Write a function that accepts two lists of strings and returns the list whose total number of characters across all strings is less than or equal to the other list.\n\n    If the two lists have the same total number of characters, the function will return the first list.\n\n    Examples:\n    total_match([], [])  []\n    total_match(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5'])  ['4']\n    '''", "generated_programs": ["from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    return lst1 if total1 <= total2 else lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/75", "requirement": "```python\ndef is_multiply_prime(a: int) -> bool:\n    \"\"\"\n    Write a function that returns True if the given number is the product of exactly three prime numbers \n    (primes can be repeated) and False otherwise. \n\n    Constraints:\n    1. The input number `a` is guaranteed to be an integer.\n    2. The function should handle any integer input, but:\n       - If `a` is less than 2, return False (as it cannot be the product of three primes).\n       - If `a` is 100 or greater, return False (as only numbers less than 100 are considered valid for factorization).\n    3. The three prime numbers used in the product can be the same or different (e.g., 18 = 2 * 3 * 3 is valid).\n    4. Only primes less than or equal to `a` are considered for factorization.\n\n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n```", "generated_programs": ["import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False", "def is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, a) if is_prime(i)]\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False", "def is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False", "import math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    for p1 in primes:\n        for p2 in primes:\n            for p3 in primes:\n                if p1 * p2 * p3 == a:\n                    return True\n    return False", "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n    primes = [x for x in range(2, a + 1) if is_prime(x)]\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False", "import math\nfrom itertools import combinations_with_replacement\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n    primes = [p for p in range(2, a + 1) if is_prime(p)]\n    for triplet in combinations_with_replacement(primes, 3):\n        if triplet[0] * triplet[1] * triplet[2] == a:\n            return True\n    return False", "import itertools\nimport math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    for triplet in itertools.combinations_with_replacement(primes, 3):\n        if triplet[0] * triplet[1] * triplet[2] == a:\n            return True\n    return False", "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False", "def is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [x for x in range(2, a + 1) if is_prime(x)]\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False", "import math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n    primes = [x for x in range(2, a + 1) if is_prime(x)]\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/76", "requirement": "```python\ndef is_simple_power(x: int, n: int) -> bool:\n    \"\"\"\n    Your task is to write a function that returns True if a number x is a simple\n    power of n and False in other cases.\n\n    A number x is a simple power of n if there exists a non-negative integer k \n    such that n**k = x. The function must adhere to the following rules:\n    \n    1. Both x and n must be positive integers (x > 0 and n > 0). If either x or n \n       is less than or equal to 0, the function must return False.\n    2. If n = 1, the function returns True if and only if x = 1, since 1**k = 1 \n       for all non-negative integers k.\n    3. For all other cases, the function iteratively calculates powers of n \n       (i.e., n**k for k = 0, 1, 2, ...) until the power equals x or exceeds x. \n       If a match is found (n**k = x), the function returns True. Otherwise, it \n       returns False.\n\n    Examples:\n    is_simple_power(1, 4) => True\n    is_simple_power(2, 2) => True\n    is_simple_power(8, 2) => True\n    is_simple_power(3, 2) => False\n    is_simple_power(3, 1) => False\n    is_simple_power(5, 3) => False\n    \"\"\"\n```", "generated_programs": ["def is_simple_power(x: int, n: int) -> bool:\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power <= x:\n        if power == x:\n            return True\n        power *= n\n    return False", "def is_simple_power(x: int, n: int) -> bool:\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1", "def is_simple_power(x: int, n: int) -> bool:\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1\n    k = 0\n    while True:\n        power = n ** k\n        if power == x:\n            return True\n        if power > x:\n            return False\n        k += 1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    \"\"\"\n    Write a function that takes an integer a and returns True \n    if the absolute value of this integer is a perfect cube of some integer number.\n    A perfect cube is defined as an integer that can be expressed as the cube of another integer.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    \"\"\"", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    cuberoot = int(round(abs(a) ** (1 / 3)))\n    return cuberoot ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    a = abs(a)\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1 / 3))\n    return cube_root ** 3 == abs_a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "HumanEval/83", "requirement": "```python\ndef starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the n-digit positive integers \n    that either start with the digit 1 or end with the digit 1, without double-counting \n    numbers that both start and end with the digit 1.\n\n    Edge Cases and Clarifications:\n    1. If n = 1, treat it as a special case since all 1-digit numbers (1 to 9) \n       start and end with the same digit. In this case, the function must return 1 \n       (only the integer 1 satisfies the condition).\n    2. If n < 1, this is considered invalid input, and the function must return 0.\n    3. For n >= 2:\n       - Numbers that \"start with 1\": `10^(n-1)`\n       - Numbers that \"end with 1\": `9 * 10^(n-2)`\n       - Overlap (numbers that \"start and end with 1\"): `10^(n-2)`\n       - Total count of numbers is computed as:\n         `count = starts_with_1 + ends_with_1 - overlap`\n\n    \"\"\"\n```", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap", "import math\n\ndef starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap", "import math\n\ndef starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap", "import math\n\ndef starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/86", "requirement": "def anti_shuffle(s: str) -> str:\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    An ordered version of a string is a string where each word (separated by spaces)\n    is replaced by a new word with all its characters arranged in ascending order \n    based on their ASCII values. Words are defined as sequences of non-space characters, \n    and spaces between words should be preserved in the output.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"", "generated_programs": ["def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join([''.join(sorted(word)) for word in s.split(' ')])", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    return ' '.join((''.join(sorted(word)) for word in s.split(' ')))", "def anti_shuffle(s: str) -> str:\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "def anti_shuffle(s: str) -> str:\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word, key=lambda x: ord(x))) for word in words]\n    return ' '.join(ordered_words)", "def anti_shuffle(s: str) -> str:\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, key=lambda x: ord(x)))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "def anti_shuffle(s: str) -> str:\n\n    def sort_word(word):\n        return ''.join(sorted(word, key=lambda x: ord(x)))\n    return ' '.join((sort_word(word) for word in s.split(' ')))"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/87", "requirement": "def get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    You are given a 2-dimensional dataset represented as nested lists,\n    where each inner list corresponds to a row. Unlike a matrix, the rows\n    may have different lengths. Given `lst` and an integer `x`, find all\n    occurrences of `x` in the dataset and return a list of tuples, where\n    each tuple represents the coordinates of `x` in the format (row_index, col_index).\n    \n    The coordinates must be sorted as follows:\n    1. Primarily by row index in ascending order.\n    2. For entries within the same row, by column index in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"", "generated_programs": ["code\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for i, row in enumerate(lst):\n        for j in reversed(range(len(row))):\n            if row[j] == x:\n                result.append((i, j))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, val in enumerate(reversed(row)):\n            if val == x:\n                result.append((row_idx, len(row) - 1 - col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx in range(len(row) - 1, -1, -1):\n            if row[col_idx] == x:\n                result.append((row_idx, col_idx))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for i, row in enumerate(lst):\n        for j in range(len(row) - 1, -1, -1):\n            if row[j] == x:\n                result.append((i, j))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index in range(len(row) - 1, -1, -1):\n            if row[col_index] == x:\n                result.append((row_index, col_index))\n    return result", "code\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(reversed(row)):\n            if value == x:\n                result.append((row_idx, len(row) - 1 - col_idx))\n    return sorted(result, key=lambda coord: (coord[0], -coord[1]))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "HumanEval/89", "requirement": "```python\ndef encrypt(s: str) -> str:\n    \"\"\"\n    Create a function encrypt that takes a string `s` as an argument and returns \n    a string encrypted by shifting each lowercase letter in `s` forward in the \n    alphabet by 4 positions. The shift wraps around the alphabet if it goes past 'z'. \n    Non-alphabetic characters are preserved and remain unchanged in the output.\n\n    Rules:\n    - Only lowercase English letters ('a''z') are shifted.\n    - Non-alphabetic characters (e.g., spaces, numbers, punctuation) are not modified.\n    - If a letter exceeds 'z' after the shift, it wraps back to the beginning of the \n      alphabet (e.g., 'z' shifted by 4 becomes 'd').\n\n    Examples:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n```", "generated_programs": ["def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(shifted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(shifted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(shifted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(ord('a') + (ord(char) - ord('a') + 4) % 26)\n            encrypted.append(shifted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr(ord('a') + (ord(char) - ord('a') + 4) % 26)\n            encrypted.append(new_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "def encrypt(s: str) -> str:\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted.append(shifted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is defined as a sentence that starts with the word \"I\"\n    (case-sensitive) after stripping leading and trailing whitespaces from the sentence.\n    \n    Sentences are delimited by '.', '?' or '!', and splitting should handle:\n    - Delimiters appearing without spaces (e.g., \"I am happy!\")\n    - Consecutive delimiters (e.g., \"Hello!! How are you?\")\n    - Extra whitespaces between delimiters, at the beginning, or at the end of the input string.\n\n    The function should not normalize the case of the input string, and sentences split via delimiters are not required to be unique.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    >>> is_bored(\"   I  am here   !   \")\n    1\n    \"\"\"", "generated_programs": ["import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for s in sentences:\n        stripped = s.strip()\n        if stripped.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]\\\\s*', S.strip())\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredoms = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I'):\n            boredoms += 1\n    return boredoms", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I '):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I'):\n            count += 1\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = 0\n    for sentence in sentences:\n        stripped_sentence = sentence.strip()\n        if stripped_sentence.startswith('I'):\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped.startswith('I'):\n            count += 1\n    return count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.4, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message and encodes it by performing the following steps:\n    1. Swap the case of all letters in the message.\n       - Convert uppercase letters to lowercase and lowercase letters to uppercase.\n    2. Replace all vowels in the case-swapped message with the letter that appears 2 places ahead \n       of that vowel in the English alphabet.\n       - Vowels are defined as 'a', 'e', 'i', 'o', 'u' (and their uppercase counterparts 'A', 'E', 'I', 'O', 'U').\n       - The replacement does not wrap around the alphabet. For example, 'u' is replaced with 'w', and 'U' is replaced with 'W'.\n       - The case of the replacement letter matches the case of the original vowel after case-swapping.\n       - Non-vowel characters remain unchanged after case-swapping.\n\n    Assume the input message contains only alphabetic characters (no spaces, digits, or special characters).\n\n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result = []\n    for char in message:\n        swapped_char = char.swapcase()\n        if swapped_char in vowels:\n            new_char = chr(ord(swapped_char) + 2)\n            result.append(new_char)\n        else:\n            result.append(swapped_char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    swapped = message.swapcase()\n    encoded_message = []\n    for char in swapped:\n        if char in vowels:\n            if char.islower():\n                new_char = chr(ord(char) + 2)\n            else:\n                new_char = chr(ord(char) + 2)\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    swapped = message.swapcase()\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n    for char in swapped:\n        if char in vowels:\n            if char.islower():\n                encoded_char = chr(ord(char) + 2) if ord(char) + 2 <= ord('z') else char\n            else:\n                encoded_char = chr(ord(char) + 2) if ord(char) + 2 <= ord('Z') else char\n            encoded_message.append(encoded_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in message:\n        swapped_char = char.swapcase()\n        if swapped_char in vowels:\n            original_case = swapped_char.isupper()\n            shifted_char = chr(ord(swapped_char) + 2)\n            if not shifted_char.isalpha() or shifted_char.lower() not in 'aeiou':\n                shifted_char = swapped_char\n            if original_case:\n                shifted_char = shifted_char.upper()\n            else:\n                shifted_char = shifted_char.lower()\n            result.append(shifted_char)\n        else:\n            result.append(swapped_char)\n    return ''.join(result)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    vowel_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    swapped_message = message.swapcase()\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels:\n            encoded_message.append(vowel_map[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    vowel_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    message_swapped = message.swapcase()\n    encoded_message = []\n    for char in message_swapped:\n        if char in vowels:\n            encoded_message.append(vowel_map[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    swapped_message = message.swapcase()\n    encoded_message = []\n    for char in swapped_message:\n        if char in vowels:\n            if char.islower():\n                replacement = chr(ord(char) + 2) if ord(char) + 2 <= ord('z') else char\n            else:\n                replacement = chr(ord(char) + 2) if ord(char) + 2 <= ord('Z') else char\n            encoded_message.append(replacement)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    case_swapped = message.swapcase()\n    encoded_message = []\n    for char in case_swapped:\n        if char in vowels:\n            if char.islower():\n                new_char = chr(ord(char) + 2) if ord(char) + 2 <= ord('z') else char\n            else:\n                new_char = chr(ord(char) + 2) if ord(char) + 2 <= ord('Z') else char\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    vowel_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    swapped_case = message.swapcase()\n    encoded_message = []\n    for char in swapped_case:\n        if char in vowels:\n            encoded_message.append(vowel_map[char])\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    encoded_message = []\n    for char in message:\n        swapped_char = char.swapcase()\n        if swapped_char in vowels:\n            if swapped_char.islower():\n                new_char = chr(ord(swapped_char) + 2) if ord(swapped_char) + 2 <= ord('z') else swapped_char\n            else:\n                new_char = chr(ord(swapped_char) + 2) if ord(swapped_char) + 2 <= ord('Z') else swapped_char\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(swapped_char)\n    return ''.join(encoded_message)"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "HumanEval/97", "requirement": "```python\ndef multiply(a: int, b: int) -> int:\n    \"\"\"Complete the function that takes two integers and returns \n    the product of the unit digits of their absolute values.\n    The unit digit of a number is computed by taking the absolute value \n    of the number and then applying the modulo operation (% 10).\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14, -15) should return 20.\n    \"\"\"\n```", "generated_programs": ["def multiply(a: int, b: int) -> int:\n    return abs(a) % 10 * (abs(b) % 10)", "def multiply(a: int, b: int) -> int:\n    return abs(a) % 10 * (abs(b) % 10)", "def multiply(a: int, b: int) -> int:\n    return abs(a) % 10 * (abs(b) % 10)", "def multiply(a: int, b: int) -> int:\n    return abs(a) % 10 * (abs(b) % 10)", "def multiply(a: int, b: int) -> int:\n    return abs(a) % 10 * (abs(b) % 10)", "def multiply(a: int, b: int) -> int:\n    return abs(a) % 10 * (abs(b) % 10)", "def multiply(a: int, b: int) -> int:\n    return abs(a) % 10 * (abs(b) % 10)", "def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b", "def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b", "def multiply(a: int, b: int) -> int:\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/99", "requirement": "```python\ndef closest_integer(value: str) -> int:\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. The rounding behavior is as follows:\n\n    1. The fractional part of the number is defined as the absolute difference\n       between the number and its integer part: `fractional_part = abs(number - int(number))`.\n\n    2. If the number is equidistant from two integers (i.e., its fractional part is exactly 0.5),\n       round it away from zero:\n       - For positive numbers, rounding away from zero means rounding up to the next integer.\n       - For negative numbers, rounding away from zero means rounding down to the next integer farther from zero.\n\n    3. If the number is not equidistant (i.e., its fractional part is not exactly 0.5):\n       - For positive numbers, round down to the nearest integer if the fractional part is less than 0.5;\n         otherwise, round up to the nearest integer.\n       - For negative numbers, round up to the nearest integer if the fractional part is less than 0.5;\n         otherwise, round down to the nearest integer.\n\n    4. If the input is exactly 0.0, return 0.\n\n    The input value will always be a valid numerical string that can be\n    converted to a floating-point number.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers (e.g., 14.5 or -14.5), the one you should return is\n    the one that is the farthest from zero. For example, closest_integer(\"14.5\")\n    should return 15, and closest_integer(\"-14.5\") should return -15.\n    '''\n```", "generated_programs": ["def closest_integer(value: str) -> int:\n    number = float(value)\n    integer_part = int(number)\n    fractional_part = abs(number - integer_part)\n    if fractional_part == 0.5:\n        if number >= 0:\n            return integer_part + 1\n        else:\n            return integer_part - 1\n    elif fractional_part < 0.5:\n        return integer_part\n    elif number >= 0:\n        return integer_part + 1\n    else:\n        return integer_part - 1", "def closest_integer(value: str) -> int:\n    num = float(value)\n    fractional_part = abs(num - int(num))\n    if fractional_part == 0.5:\n        if num > 0:\n            return int(num) + 1\n        else:\n            return int(num) - 1\n    elif num > 0:\n        return int(num) if fractional_part < 0.5 else int(num) + 1\n    else:\n        return int(num) if fractional_part < 0.5 else int(num) - 1", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    fractional_part = abs(num - int(num))\n    if fractional_part == 0.5:\n        if num > 0:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    elif num > 0:\n        if fractional_part < 0.5:\n            return math.floor(num)\n        else:\n            return math.ceil(num)\n    elif fractional_part < 0.5:\n        return math.ceil(num)\n    else:\n        return math.floor(num)", "def closest_integer(value: str) -> int:\n    num = float(value)\n    fractional_part = abs(num - int(num))\n    if fractional_part == 0.5:\n        if num > 0:\n            return int(num) + 1\n        else:\n            return int(num) - 1\n    elif num > 0:\n        if fractional_part < 0.5:\n            return int(num)\n        else:\n            return int(num) + 1\n    elif fractional_part < 0.5:\n        return int(num)\n    else:\n        return int(num) - 1", "def closest_integer(value: str) -> int:\n    number = float(value)\n    fractional_part = abs(number - int(number))\n    if fractional_part == 0.5:\n        if number >= 0:\n            return int(number + 0.5)\n        else:\n            return int(number - 0.5)\n    elif number >= 0:\n        if fractional_part < 0.5:\n            return int(number)\n        else:\n            return int(number + 0.5)\n    elif fractional_part < 0.5:\n        return int(number)\n    else:\n        return int(number - 0.5)", "def closest_integer(value: str) -> int:\n    num = float(value)\n    int_part = int(num)\n    fractional_part = abs(num - int_part)\n    if fractional_part == 0.5:\n        if num > 0:\n            return int_part + 1\n        else:\n            return int_part - 1\n    elif abs(num - int_part) < 0.5:\n        if num > 0:\n            return int_part\n        else:\n            return int_part\n    elif num > 0:\n        return int_part + 1\n    else:\n        return int_part - 1", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    fractional_part = abs(num - int(num))\n    if fractional_part == 0.5:\n        if num >= 0:\n            return int(math.ceil(num))\n        else:\n            return int(math.floor(num))\n    elif num >= 0:\n        if fractional_part < 0.5:\n            return int(math.floor(num))\n        else:\n            return int(math.ceil(num))\n    elif fractional_part < 0.5:\n        return int(math.ceil(num))\n    else:\n        return int(math.floor(num))", "import math\n\ndef closest_integer(value: str) -> int:\n    number = float(value)\n    if number == 0.0:\n        return 0\n    integer_part = int(number)\n    fractional_part = abs(number - integer_part)\n    if fractional_part == 0.5:\n        if number > 0:\n            return integer_part + 1\n        else:\n            return integer_part - 1\n    elif fractional_part < 0.5:\n        if number > 0:\n            return integer_part\n        else:\n            return integer_part\n    elif number > 0:\n        return integer_part + 1\n    else:\n        return integer_part - 1", "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num == 0.0:\n        return 0\n    fractional_part = abs(num - int(num))\n    if fractional_part == 0.5:\n        if num > 0:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    elif num > 0:\n        if fractional_part < 0.5:\n            return math.floor(num)\n        else:\n            return math.ceil(num)\n    elif fractional_part < 0.5:\n        return math.ceil(num)\n    else:\n        return math.floor(num)", "def closest_integer(value: str) -> int:\n    number = float(value)\n    if number == 0.0:\n        return 0\n    fractional_part = abs(number - int(number))\n    if fractional_part == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    elif number > 0:\n        if fractional_part < 0.5:\n            return int(number)\n        else:\n            return int(number) + 1\n    elif fractional_part < 0.5:\n        return int(number)\n    else:\n        return int(number) - 1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/100", "requirement": "def make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    Each subsequent level has 2 more stones than the previous level.\n    Return the number of stones in each level in a list, where the element at \n    index i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/101", "requirement": "```python\nfrom typing import List\n\ndef words_string(s: str) -> List[str]:\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words. The function\n    must adhere to the following rules:\n    \n    1. The input string may contain words separated by commas (`,`), spaces (` `), \n       or a combination of both. Multiple consecutive separators (e.g., `,,`, `  `, \n       or `, `) must be treated as a single delimiter.\n    2. Leading and trailing whitespace or separators in the input string must be ignored.\n    3. The output must only include non-empty words. Empty strings caused by \n       consecutive separators or leading/trailing separators must not appear in \n       the output.\n    4. If the input string is empty, contains only whitespace, or contains only \n       separators (e.g., `\",,, ,\"`), the function must return an empty list `[]`.\n    5. Words are defined as any sequence of characters that are not separators \n       (commas or spaces). A word cannot be an empty string.\n\n    Implementation details:\n    - The function must normalize all separators by treating commas as equivalent \n      to spaces before splitting the string.\n    - The splitting process must ensure that consecutive separators are treated \n      as a single delimiter, and no empty strings are included in the output.\n\n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n```", "generated_programs": ["from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    if not s:\n        return []\n    normalized = re.sub('[,\\\\s]+', ' ', s.strip())\n    return [word for word in normalized.split(' ') if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    normalized = re.sub('[,\\\\s]+', ' ', s.strip())\n    return [word for word in normalized.split() if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    if not s:\n        return []\n    s = re.sub('[, ]+', ' ', s.strip())\n    return [word for word in s.split(' ') if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    normalized = re.sub('[,\\\\s]+', ' ', s.strip())\n    return [word for word in normalized.split(' ') if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = re.sub('[,\\\\s]+', ' ', s.strip())\n    return [word for word in s.split(' ') if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    s = re.sub('[,\\\\s]+', ' ', s)\n    return [word for word in s.split(' ') if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    if not s or s.isspace() or all((c in ', ' for c in s)):\n        return []\n    normalized = re.sub('[,\\\\s]+', ' ', s.strip())\n    return [word for word in normalized.split(' ') if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    normalized = re.sub('[,\\\\s]+', ' ', s.strip())\n    if not normalized:\n        return []\n    words = normalized.split(' ')\n    return [word for word in words if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    if not s:\n        return []\n    s = s.strip()\n    if not s:\n        return []\n    s = re.sub('[,\\\\s]+', ' ', s)\n    words = s.split(' ')\n    return [word for word in words if word]", "code\nimport re\nfrom typing import List\n\ndef words_string(s: str) -> List[str]:\n    if not s:\n        return []\n    normalized = re.sub('[\\\\s,]+', ' ', s.strip())\n    if not normalized:\n        return []\n    return [word for word in normalized.split(' ') if word]"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.8, "original_passk": 0.0}}
{"task_id": "HumanEval/102", "requirement": "def choose_num(x: int, y: int) -> int:\n    \"\"\"This function takes two positive integers x and y and returns the \n    largest even integer within the range [x, y] inclusive. If x is greater \n    than y, or if there are no even numbers in the range, the function \n    should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"", "generated_programs": ["def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    even_numbers = [num for num in range(y, x - 1, -1) if num % 2 == 0]\n    return even_numbers[0] if even_numbers else -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    even_num = [num for num in range(y, x - 1, -1) if num % 2 == 0]\n    return even_num[0] if even_num else -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    max_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            max_even = num\n            break\n    return max_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    even_nums = [num for num in range(x, y + 1) if num % 2 == 0]\n    if not even_nums:\n        return -1\n    return max(even_nums)", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    max_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            max_even = num\n            break\n    return max_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    max_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            max_even = num\n            break\n    return max_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.4}}
{"task_id": "HumanEval/104", "requirement": "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    elements that do not contain any even digit (0, 2, 4, 6, 8).\n\n    Clarifications:\n    1. The input list x will only contain positive integers (greater than 0). \n       Any input containing non-positive integers (e.g., 0 or negative numbers) is invalid.\n    2. A digit is considered even if it is one of the following: 0, 2, 4, 6, 8.\n    3. The returned list must be sorted in increasing order.\n\n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    return sorted([num for num in x if all((int(digit) % 2 != 0 for digit in str(num)))])", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        return any((int(digit) % 2 == 0 for digit in str(n)))\n    result = [num for num in x if not contains_even_digit(num)]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    even_digits = {'0', '2', '4', '6', '8'}\n    result = []\n    for num in x:\n        if not any((digit in even_digits for digit in str(num))):\n            result.append(num)\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    even_digits = {'0', '2', '4', '6', '8'}\n    result = []\n    for num in x:\n        if all((digit not in even_digits for digit in str(num))):\n            result.append(num)\n    result.sort()\n    return result", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit in {0, 2, 4, 6, 8}:\n                return True\n            n //= 10\n        return False\n    return sorted([num for num in x if not has_even_digit(num)])", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n //= 10\n        return False\n    result = [num for num in x if not has_even_digit(num)]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n //= 10\n        return False\n    result = [num for num in x if not has_even_digit(num)]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def contains_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if not contains_even_digit(num)]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit in {0, 2, 4, 6, 8}:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if not has_even_digit(num)]\n    return sorted(result)", "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\n    def has_even_digit(n: int) -> bool:\n        while n > 0:\n            digit = n % 10\n            if digit in {0, 2, 4, 6, 8}:\n                return True\n            n = n // 10\n        return False\n    result = [num for num in x if not has_even_digit(num)]\n    return sorted(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/107", "requirement": "def even_odd_palindrome(n: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a positive integer n, return a tuple containing the count of even and odd \n    integer palindromes within the range [1, n], inclusive.\n\n    An integer palindrome is a number that reads the same backward as forward. \n    For example, 121 and 7 are palindromes, but 123 is not.\n\n    The first element of the tuple represents the count of even integer palindromes, \n    and the second element represents the count of odd integer palindromes.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindromes are 1, 2, 3. One of them (2) is even, and two of them (1, 3) are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindromes are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Four of them (2, 4, 6, 8) are even, \n        and six of them (1, 3, 5, 7, 9, 11) are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. The returned tuple contains the count of even and odd integer palindromes, respectively.\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef is_palindrome(number: int) -> bool:\n    return str(number) == str(number)[::-1]\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n\n    def is_palindrome(x: int) -> bool:\n        return str(x) == str(x)[::-1]\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef is_palindrome(x: int) -> bool:\n    return str(x) == str(x)[::-1]\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "from typing import Tuple\n\ndef is_palindrome(x: int) -> bool:\n    return str(x) == str(x)[::-1]\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "def count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the count of numbers in the array for which the sum of their signed digits is strictly greater than 0.\n\n    Signed digits are determined as follows:\n    - If the number is negative, its first digit is treated as negative, and the rest of the digits are treated as positive.\n      For example, -123 has signed digits [-1, 2, 3].\n    - If the number is positive, all digits are treated as positive.\n      For example, 123 has signed digits [1, 2, 3].\n\n    A number is counted if the sum of its signed digits is strictly greater than 0.\n\n    Examples:\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        digits = list(map(int, list(str(abs(num)))))\n        if num < 0:\n            digits[0] = -digits[0]\n        if sum(digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        digits = list(map(int, list(str(abs(num)))))\n        if num < 0:\n            digits[0] *= -1\n        if sum(digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        digits = list(map(int, list(str(abs(num)))))\n        if num < 0:\n            digits[0] = -digits[0]\n        if sum(digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        if num < 0:\n            digits = [int(d) for d in str(abs(num))]\n            digits[0] = -digits[0]\n        else:\n            digits = [int(d) for d in str(num)]\n        if sum(digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        if num < 0:\n            digits = [int(d) for d in str(abs(num))]\n            signed_digits = [-digits[0]] + digits[1:]\n        else:\n            signed_digits = [int(d) for d in str(num)]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        digits = list(str(abs(num)))\n        if num < 0:\n            signed_digits = [-int(digits[0])] + [int(d) for d in digits[1:]]\n        else:\n            signed_digits = [int(d) for d in digits]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            signed_digits = [-int(s[1])] + [int(d) for d in s[2:]]\n        else:\n            signed_digits = [int(d) for d in s]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            signed_digits = [-int(s[1])] + [int(d) for d in s[2:]]\n        else:\n            signed_digits = [int(d) for d in s]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        signed_digits = []\n        s = str(num)\n        if s[0] == '-':\n            signed_digits.append(-int(s[1]))\n            for c in s[2:]:\n                signed_digits.append(int(c))\n        else:\n            for c in s:\n                signed_digits.append(int(c))\n        if sum(signed_digits) > 0:\n            count += 1\n    return count", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        num_str = str(num)\n        if num < 0:\n            signed_digits = [-int(num_str[1])] + [int(d) for d in num_str[2:]]\n        else:\n            signed_digits = [int(d) for d in num_str]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 0.9}}
{"task_id": "HumanEval/109", "requirement": "```python\nfrom typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    \"\"\"\n    We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The numbers \n    in the array will be randomly ordered. Your task is to determine if it is \n    possible to get an array sorted in non-decreasing order by performing the \n    following operation on the given array:\n        You are allowed to perform right shift operations any number of times.\n\n    One right shift operation means shifting all elements of the array by one \n    position in the right direction. The last element of the array will be moved \n    to the starting position in the array, i.e., the 0th index.\n\n    The array is considered sorted in non-decreasing order if, for all indices i \n    (0 <= i < N-1), arr[i] <= arr[i+1]. Additionally, the comparison between the \n    last element and the first element is included as part of the circular \n    indexing logic to determine if the array can be sorted circularly.\n\n    If it is possible to obtain the sorted array by performing the above operation, \n    then return True; otherwise, return False. If the given array is empty, return True.\n\n    Note:\n    - The given list is guaranteed to have unique elements.\n    - Arrays that are already sorted in non-decreasing order should return True \n      without requiring any rotations.\n    - The function will count the number of descending pairs in the array, where \n      a descending pair is defined as arr[i] > arr[(i + 1) % N]. If more than one \n      descending pair exists, return False. Otherwise, return True.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2]) ==> True\n    Explanation: By performing 2 right shift operations, non-decreasing order can \n                 be achieved for the given array.\n                 \n    move_one_ball([3, 5, 4, 1, 2]) ==> False\n    Explanation: It is not possible to get non-decreasing order for the given \n                 array by performing any number of right shift operations.\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    desc_pairs = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            desc_pairs += 1\n    return desc_pairs <= 1", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n            if count > 1:\n                return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            count += 1\n        if count > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    descending_pairs = 0\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            descending_pairs += 1\n        if descending_pairs > 1:\n            return False\n    return True", "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if not arr:\n        return True\n    n = len(arr)\n    desc_count = 0\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            desc_count += 1\n            if desc_count > 1:\n                return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/110", "requirement": "def exchange(lst1: List[int], lst2: List[int]) -> str:\n    \"\"\"Implement a function that determines whether it is possible to exchange \n    elements between two lists, lst1 and lst2, such that all elements in lst1 \n    become even numbers. \n\n    Specifically:\n    - You can exchange any number of elements between lst1 and lst2.\n    - An exchange is considered successful if the number of odd elements in lst1 \n      can be replaced by at least an equal number of even elements from lst2.\n\n    If it is possible to make all elements of lst1 even through such exchanges, \n    return \"YES\". Otherwise, return \"NO\".\n\n    Examples:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n\n    It is assumed that the input lists will be non-empty.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for num in lst1 if num % 2 != 0))\n    even_count = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for x in lst1 if x % 2 != 0))\n    even_count = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count2 >= odd_count1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum((1 for num in lst1 if num % 2 != 0))\n    even_count = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    count_odd_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    count_even_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if count_even_lst2 >= count_odd_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_in_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for num in lst1 if num % 2 != 0))\n    even_count_lst2 = sum((1 for num in lst2 if num % 2 == 0))\n    return 'YES' if even_count_lst2 >= odd_count_lst1 else 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_count_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    if odd_count_lst1 <= even_count_lst2:\n        return 'YES'\n    else:\n        return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    if odd_lst1 <= even_lst2:\n        return 'YES'\n    else:\n        return 'NO'", "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_in_lst1 = sum((1 for x in lst1 if x % 2 != 0))\n    even_in_lst2 = sum((1 for x in lst2 if x % 2 == 0))\n    return 'YES' if even_in_lst2 >= odd_in_lst1 else 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/111", "requirement": "```python\nfrom typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    \"\"\"\n    Given a string `test` representing space-separated lowercase single-character letters,\n    return a dictionary containing the letters with the highest occurrence and their corresponding counts.\n    If several letters have the same occurrence, include all of them in the output dictionary.\n    \n    Input Handling:\n    - The input string `test` is expected to contain only space-separated lowercase single-character letters ('a' to 'z').\n    - Leading, trailing, and duplicate spaces in the input string should be ignored.\n    - The function does not handle invalid inputs such as uppercase letters, non-alphabetic characters, or empty spaces between letters \n      beyond what is described (e.g., invalid input will result in undefined behavior).\n    \n    Output Requirements:\n    - The output dictionary should have as keys the letters with the highest count and as values their corresponding counts.\n    - All letters tied for the highest count are included in the dictionary.\n    - The order of keys in the output dictionary does not matter.\n    - If the input string is empty or contains only spaces, an empty dictionary should be returned.\n    \n    Examples:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n    \"\"\"\n```", "generated_programs": ["from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    from collections import Counter\n    letters = test.split()\n    if not letters:\n        return {}\n    count = Counter(letters)\n    max_count = max(count.values())\n    return {letter: cnt for letter, cnt in count.items() if cnt == max_count}", "from typing import Dict\nfrom collections import Counter\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test or test.isspace():\n        return {}\n    letters = test.split()\n    counts = Counter(letters)\n    max_count = max(counts.values())\n    return {letter: count for letter, count in counts.items() if count == max_count}", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    from collections import defaultdict\n    if not test or test.isspace():\n        return {}\n    letters = test.split()\n    count_dict = defaultdict(int)\n    for letter in letters:\n        count_dict[letter] += 1\n    max_count = max(count_dict.values())\n    result = {k: v for k, v in count_dict.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    counts = {}\n    for letter in letters:\n        if letter in counts:\n            counts[letter] += 1\n        else:\n            counts[letter] = 1\n    max_count = max(counts.values(), default=0)\n    result = {k: v for k, v in counts.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    count_dict = {}\n    for letter in letters:\n        if letter in count_dict:\n            count_dict[letter] += 1\n        else:\n            count_dict[letter] = 1\n    max_count = max(count_dict.values(), default=0)\n    result = {k: v for k, v in count_dict.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    count_dict = {}\n    for letter in letters:\n        if letter in count_dict:\n            count_dict[letter] += 1\n        else:\n            count_dict[letter] = 1\n    max_count = max(count_dict.values(), default=0)\n    result = {k: v for k, v in count_dict.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    test_str = test.strip()\n    if not test_str:\n        return {}\n    letters = test_str.split()\n    counts = {}\n    for letter in letters:\n        counts[letter] = counts.get(letter, 0) + 1\n    max_count = max(counts.values()) if counts else 0\n    result = {letter: cnt for letter, cnt in counts.items() if cnt == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.split()\n    count_dict = {}\n    for letter in letters:\n        if letter in count_dict:\n            count_dict[letter] += 1\n        else:\n            count_dict[letter] = 1\n    max_count = max(count_dict.values(), default=0)\n    result = {k: v for k, v in count_dict.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.strip().split()\n    counts = {}\n    for letter in letters:\n        if letter in counts:\n            counts[letter] += 1\n        else:\n            counts[letter] = 1\n    max_count = max(counts.values(), default=0)\n    result = {k: v for k, v in counts.items() if v == max_count}\n    return result", "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    if not test.strip():\n        return {}\n    letters = test.strip().split()\n    count_dict = {}\n    for letter in letters:\n        if letter in count_dict:\n            count_dict[letter] += 1\n        else:\n            count_dict[letter] = 1\n    max_count = max(count_dict.values())\n    result = {k: v for k, v in count_dict.items() if v == max_count}\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/113", "requirement": "def odd_count(lst: List[str]) -> List[str]:\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be a string in the format:\n    \"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n    Here, {odd_digits} is replaced by the count of odd digits in the i'th string of the input list.\n\n    For example:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if int(char) % 2 != 0))\n        result.append(f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.')\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for c in s if int(c) % 2 != 0))\n        result.append(f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.')\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for c in s if int(c) % 2 != 0))\n        formatted_str = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_str)\n    return result", "code\nfrom typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if int(char) % 2 != 0))\n        result.append(f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.')\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if int(char) % 2 != 0))\n        formatted_string = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_string)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for c in s if int(c) % 2 != 0))\n        formatted_string = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_string)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if int(char) % 2 != 0))\n        formatted_str = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_str)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if int(char) % 2 != 0))\n        formatted_string = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_string)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if int(char) % 2 != 0))\n        formatted_string = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_string)\n    return result", "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_digits = sum((1 for char in s if int(char) % 2 != 0))\n        formatted_string = f'the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.'\n        result.append(formatted_string)\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/114", "requirement": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums. A sub-array is defined as a contiguous portion of the array. If the input\n    array nums is empty, the function will return positive infinity (`float('inf')`).\n\n    The function adheres to the following rules:\n    1. If nums is non-empty, it calculates the minimum sum of any contiguous sub-array.\n    2. If nums is empty, it returns `float('inf')` to indicate no sub-array exists.\n\n    Example:\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    minSubArraySum([]) == float('inf')\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return float('inf')\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/115", "requirement": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n\n    The number of times you need to lower the buckets is calculated globally across the entire grid:\n    - First, sum the total number of water units across all rows in the grid.\n    - Then, divide the total number of water units by the bucket capacity, rounding up to account for incomplete bucket loads.\n    - Output the total number of buckets needed globally to empty all wells.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity)", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if total_water > 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if total_water > 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if capacity != 0 else 0", "from typing import List\nimport math\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_water = sum((sum(row) for row in grid))\n    return math.ceil(total_water / capacity) if total_water > 0 else 0"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort an array of integers as follows:\n    1. Separate the array into two groups: non-negative integers (>= 0) and negative integers (< 0).\n    2. Sort the negative integers in ascending order based on their decimal value.\n    3. Sort the non-negative integers in ascending order based on:\n       - First, the number of ones in their binary representation.\n       - If two numbers have the same number of ones, sort them by their decimal value.\n    4. Concatenate the sorted negative integers and the sorted non-negative integers, \n       with the negative integers appearing first in the result.\n\n    Examples:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative = sorted([x for x in arr if x < 0])\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negatives = sorted([x for x in arr if x < 0])\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative = sorted([x for x in arr if x < 0])\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    neg = sorted([x for x in arr if x < 0])\n    non_neg = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return neg + non_neg", "code\nfrom typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative = sorted([x for x in arr if x < 0], key=lambda x: x)\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negative = sorted([x for x in arr if x < 0])\n    non_negative = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negative + non_negative", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negatives = sorted([x for x in arr if x < 0], key=lambda x: x)\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negatives = [x for x in arr if x < 0]\n    non_negatives = [x for x in arr if x >= 0]\n    negatives.sort()\n    non_negatives.sort(key=lambda x: (bin(x).count('1'), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negatives = sorted([x for x in arr if x < 0], key=lambda x: x)\n    non_negatives = sorted([x for x in arr if x >= 0], key=lambda x: (bin(x).count('1'), x))\n    return negatives + non_negatives", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    negatives = [x for x in arr if x < 0]\n    non_negatives = [x for x in arr if x >= 0]\n    negatives_sorted = sorted(negatives)\n    non_negatives_sorted = sorted(non_negatives, key=lambda x: (bin(x).count('1'), x))\n    return negatives_sorted + non_negatives_sorted"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/118", "requirement": "def get_closest_vowel(word: str) -> str:\n    \"\"\"\n    You are given a word. Your task is to find the closest vowel that is surrounded \n    by two consonants (one before and one after) when traversing the word from the \n    right side, excluding the first and last characters of the word (case sensitive).\n\n    Vowels at the beginning or end of the word do not count. Return an empty string \n    if no vowel meets the above condition.\n\n    You may assume that the given string contains English letters only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"", "generated_programs": ["def get_closest_vowel(word: str) -> str:\n    vowels = set('aeiouAEIOU')\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = set('aeiouAEIOU')\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = set('aeiouAEIOU')\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "code\n\ndef get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    length = len(word)\n    for i in range(length - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''", "def get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            return word[i]\n    return ''", "code\n\ndef get_closest_vowel(word: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    n = len(word)\n    for i in range(n - 2, 0, -1):\n        if word[i] in vowels:\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    return ''"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "HumanEval/122", "requirement": "def add_elements(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements from the first k elements of arr that have at most two digits \n    (i.e., values between -99 and 99, inclusive).\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((x for x in arr[:k] if -99 <= x <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((num for num in arr[:k] if -99 <= num <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((x for x in arr[:k] if -99 <= x <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum((num for num in arr[:k] if -99 <= num <= 99))", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    sum_elements = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99:\n            sum_elements += num\n            count += 1\n            if count == k:\n                break\n    return sum_elements", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    total = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99:\n            total += num\n            count += 1\n            if count == k:\n                break\n    return total", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    result = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99:\n            result += num\n            count += 1\n        if count == k:\n            break\n    return result", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    total = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99:\n            total += num\n            count += 1\n            if count == k:\n                break\n    return total", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    sum_result = 0\n    count = 0\n    for num in arr:\n        if count >= k:\n            break\n        if -99 <= num <= 99:\n            sum_result += num\n            count += 1\n    return sum_result", "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    sum_elements = 0\n    count = 0\n    for num in arr:\n        if -99 <= num <= 99:\n            sum_elements += num\n            count += 1\n            if count == k:\n                break\n    return sum_elements"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.4, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/124", "requirement": "```python\ndef valid_date(date: str) -> bool:\n    \"\"\"\n    You have to write a function which validates a given date string and\n    returns True if the date is valid, otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    \n    1. The date string is not empty.\n    2. The date string must strictly follow the format: mm-dd-yyyy, where:\n       - `mm` is a two-digit month (01 to 12).\n       - `dd` is a two-digit day (01 to 31, depending on the month).\n       - `yyyy` is a four-digit year.\n    3. The day (`dd`) must be valid for the given month (`mm`):\n       - For months 1, 3, 5, 7, 8, 10, 12, the day must be between 01 and 31.\n       - For months 4, 6, 9, 11, the day must be between 01 and 30.\n       - For month 2 (February), the day must be between 01 and 29. Leap year validation is NOT applied, so February is always considered to have up to 29 days.\n    4. The function does not impose any restrictions on the year (`yyyy`) beyond requiring it to be a valid four-digit number.\n    5. The function strictly enforces the validity of the date components. For example:\n       - Days like `00` are invalid.\n       - Months like `00` or `13` are invalid.\n       - Dates with incorrect separators (e.g., `06/04/2020`) are invalid.\n\n    For example:\n    valid_date('03-11-2000') => True\n    valid_date('15-01-2012') => False\n    valid_date('04-0-2040') => False\n    valid_date('06-04-2020') => True\n    valid_date('06/04/2020') => False\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = re.compile('^\\\\d{2}-\\\\d{2}-\\\\d{4}$')\n    if not pattern.match(date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    month = int(mm)\n    day = int(dd)\n    if month < 1 or month > 12:\n        return False\n    if day < 1 or day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date or not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    month, day, year = date.split('-')\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if day < 1 or day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date or not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    mm = int(mm)\n    dd = int(dd)\n    yyyy = int(yyyy)\n    if mm < 1 or mm > 12:\n        return False\n    if dd < 1 or dd > 31:\n        return False\n    if mm in {4, 6, 9, 11} and dd > 30:\n        return False\n    if mm == 2 and dd > 29:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date or not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if not 1 <= int(mm) <= 12:\n        return False\n    if int(mm) in {1, 3, 5, 7, 8, 10, 12}:\n        return 1 <= int(dd) <= 31\n    elif int(mm) in {4, 6, 9, 11}:\n        return 1 <= int(dd) <= 30\n    elif int(mm) == 2:\n        return 1 <= int(dd) <= 29\n    return False", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if not mm.isdigit() or not dd.isdigit() or (not yyyy.isdigit()):\n        return False\n    mm = int(mm)\n    dd = int(dd)\n    yyyy = int(yyyy)\n    if mm < 1 or mm > 12:\n        return False\n    if dd < 1:\n        return False\n    if mm in {4, 6, 9, 11}:\n        if dd > 30:\n            return False\n    elif mm == 2:\n        if dd > 29:\n            return False\n    elif dd > 31:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = re.compile('^\\\\d{2}-\\\\d{2}-\\\\d{4}$')\n    if not pattern.match(date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    mm = int(mm)\n    dd = int(dd)\n    yyyy = int(yyyy)\n    if mm < 1 or mm > 12:\n        return False\n    if dd < 1:\n        return False\n    if mm in [1, 3, 5, 7, 8, 10, 12]:\n        if dd > 31:\n            return False\n    elif mm in [4, 6, 9, 11]:\n        if dd > 30:\n            return False\n    elif mm == 2:\n        if dd > 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n        return False\n    try:\n        mm, dd, yyyy = date.split('-')\n        if not mm.isdigit() or not dd.isdigit() or (not yyyy.isdigit()) or (len(yyyy) != 4):\n            return False\n        mm = int(mm)\n        dd = int(dd)\n        yyyy = int(yyyy)\n        if mm < 1 or mm > 12:\n            return False\n        if dd < 1 or dd > 31:\n            return False\n        if mm in {4, 6, 9, 11}:\n            if dd > 30:\n                return False\n        elif mm == 2:\n            if dd > 29:\n                return False\n        return True\n    except ValueError:\n        return False", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    mm, dd, yyyy = date.split('-')\n    if not 1 <= int(mm) <= 12:\n        return False\n    if int(mm) in {1, 3, 5, 7, 8, 10, 12}:\n        if not 1 <= int(dd) <= 31:\n            return False\n    elif int(mm) in {4, 6, 9, 11}:\n        if not 1 <= int(dd) <= 30:\n            return False\n    elif int(mm) == 2:\n        if not 1 <= int(dd) <= 29:\n            return False\n    else:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = re.compile('^(\\\\d{2})-(\\\\d{2})-(\\\\d{4})$')\n    match = pattern.match(date)\n    if not match:\n        return False\n    mm, dd, yyyy = match.groups()\n    month = int(mm)\n    day = int(dd)\n    year = int(yyyy)\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = re.compile('^(\\\\d{2})-(\\\\d{2})-(\\\\d{4})$')\n    match = pattern.match(date)\n    if not match:\n        return False\n    month, day, year = match.groups()\n    if not month.isdigit() or not day.isdigit() or (not year.isdigit()):\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if day < 1 or day > 31:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day > 30:\n            return False\n    elif month == 2:\n        if day > 29:\n            return False\n    return True"], "result": {"repaired_passk": 0.2222222222222222, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "HumanEval/126", "requirement": "def is_sorted(lst: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return whether or not they are sorted in ascending order.\n    Additionally, if any number appears more than twice in the list, return False.\n    Assume the list contains only non-negative integers.\n\n    Examples:\n    is_sorted([5])  True\n    is_sorted([1, 2, 3, 4, 5])  True\n    is_sorted([1, 3, 2, 4, 5])  False\n    is_sorted([1, 2, 3, 4, 5, 6])  True\n    is_sorted([1, 2, 3, 4, 5, 6, 7])  True\n    is_sorted([1, 3, 2, 4, 5, 6, 7])  False\n    is_sorted([1, 2, 2, 3, 3, 4])  True\n    is_sorted([1, 2, 2, 2, 3, 4])  False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if lst != sorted(lst):\n        return False\n    from collections import Counter\n    count = Counter(lst)\n    return all((v <= 2 for v in count.values()))", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if lst != sorted(lst):\n        return False\n    from collections import Counter\n    count = Counter(lst)\n    for num, cnt in count.items():\n        if cnt > 2:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if any((count > 2 for count in Counter(lst).values())):\n        return False\n    return all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1)))", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if lst != sorted(lst):\n        return False\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n        if counts[num] > 2:\n            return False\n    return True", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if lst != sorted(lst):\n        return False\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n        if counts[num] > 2:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not lst:\n        return True\n    if any((count > 2 for count in Counter(lst).values())):\n        return False\n    return all((lst[i] <= lst[i + 1] for i in range(len(lst) - 1)))", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not lst:\n        return True\n    counts = Counter(lst)\n    if any((count > 2 for count in counts.values())):\n        return False\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True", "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if len(lst) == 0:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n        if counts[num] > 2:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n    count = Counter(lst)\n    for num in count:\n        if count[num] > 2:\n            return False\n    return True", "from typing import List\nfrom collections import Counter\n\ndef is_sorted(lst: List[int]) -> bool:\n    if not lst:\n        return True\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n    count = Counter(lst)\n    for num in count:\n        if count[num] > 2:\n            return False\n    return True"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/127", "requirement": "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"\n    You are given two intervals, where each interval is a pair of integers. \n    For example, interval = (start, end) = (1, 2). The given intervals are closed, \n    which means that the interval (start, end) includes both start and end. \n    For each given interval, it is assumed that its start is less than or equal to its end.\n\n    Your task is to determine whether the length of the intersection of these two intervals \n    is a prime number. The length of the intersection is defined as the difference \n    between the end and start of the intersection interval, i.e., `end - start`. \n    If the two intervals do not overlap, the length of the intersection is 0.\n\n    Note:\n    - The length of the intersection does not include an additional \"+1\" for inclusivity.\n    - A prime number is a positive integer greater than 1 that has no divisors other than 1 and itself.\n    - If the length of the intersection is a prime number, return \"YES\".\n    - Otherwise, return \"NO\".\n    - If the two intervals do not intersect, return \"NO\".\n\n    Example:\n    The intersection of the intervals (1, 3) and (2, 4) is (2, 3), \n    and its length is `3 - 2 = 1`, which is not a prime number. \n    Therefore, the result is \"NO\".\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start\n    if length < 2:\n        return 'NO'\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return 'NO'\n    return 'YES'", "from typing import Tuple\nimport math\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    overlap_start = max(start1, start2)\n    overlap_end = min(end1, end2)\n    if overlap_start > overlap_end:\n        return 'NO'\n    length = overlap_end - overlap_start\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    length = max(0, intersect_end - intersect_start)\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    length = intersect_end - intersect_start\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start\n    if length == 0:\n        return 'NO'\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    length = max(0, intersection_end - intersection_start)\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    length = max(0, intersection_end - intersection_start)\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    length = max(0, intersect_end - intersect_start)\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    length = max(0, end - start)\n    if is_prime(length):\n        return 'YES'\n    else:\n        return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    length = max(0, intersection_end - intersection_start)\n    return 'YES' if is_prime(length) else 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/129", "requirement": "```python\nfrom typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) where each cell contains a \n    unique value in the range [1, N * N] inclusive, you must find the lexicographically \n    smallest path of length k, starting from any cell. \n\n    A path of length k consists of visiting exactly k cells in the grid, and revisiting \n    cells is allowed. You cannot move outside the grid, and valid moves are restricted \n    to the four neighboring cells that share an edge (up, down, left, right). Diagonal \n    moves are not allowed.\n\n    The lexicographically smallest path is determined by comparing the ordered list \n    of values of the cells visited along each path. Specifically:\n    \n        - For two paths A and B of length k, the corresponding lists of values \n          (lst_A and lst_B) are compared lexicographically:\n          lst_A is lexicographically smaller than lst_B if there exists \n          an index i (0 <= i < k) such that lst_A[i] < lst_B[i], and for all \n          earlier indices j (0 <= j < i), lst_A[j] == lst_B[j].\n\n    The path search must consider all possible paths of length k starting from \n    any cell in the grid and return the list of cell values corresponding to \n    the lexicographically smallest path. Backtracking should be used to enumerate \n    all valid paths of length k and determine the smallest lexicographical ordering \n    globally. Intermediate comparisons of incomplete paths are insufficient.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n```", "generated_programs": ["from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path, visited):\n        if len(path) == k:\n            nonlocal min_path\n            if path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]], visited)\n    N = len(grid)\n    min_path = None\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]], set())\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    min_path = None\n\n    def backtrack(i, j, path, visited):\n        nonlocal min_path\n        if len(path) == k:\n            if not min_path or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            x, y = (i + dx, j + dy)\n            if 0 <= x < n and 0 <= y < n:\n                backtrack(x, y, path + [grid[x][y]], visited)\n    for i in range(n):\n        for j in range(n):\n            backtrack(i, j, [grid[i][j]], set())\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from itertools import product\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    min_path = [float('inf')] * k\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            nonlocal min_path\n            if path < min_path:\n                min_path = path.copy()\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    for i, j in product(range(N), range(N)):\n        dfs(i, j, [grid[i][j]])\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    visited = [[False] * n for _ in range(n)]\n    result = [float('inf')] * k\n\n    def backtrack(row, col, path):\n        nonlocal result\n        if len(path) == k:\n            if path < result:\n                result = path.copy()\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            x, y = (row + dx, col + dy)\n            if 0 <= x < n and 0 <= y < n:\n                backtrack(x, y, path + [grid[x][y]])\n    for i in range(n):\n        for j in range(n):\n            backtrack(i, j, [grid[i][j]])\n    return result", "from typing import List\nfrom sys import maxsize\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    min_path = [maxsize] * k\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y, path, visited):\n        nonlocal min_path\n        if len(path) == k:\n            if path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                dfs(nx, ny, path + [grid[nx][ny]], visited | {(nx, ny)})\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, [grid[i][j]], {(i, j)})\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(i, j, path, visited, count):\n        if count == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            x, y = (i + dx, j + dy)\n            if 0 <= x < n and 0 <= y < n:\n                new_path = path.copy()\n                new_path.append(grid[x][y])\n                result = dfs(x, y, new_path, visited, count + 1)\n                if min_path is None or (result is not None and result < min_path):\n                    min_path = result\n        return min_path\n    global_min = None\n    for i in range(n):\n        for j in range(n):\n            path = [grid[i][j]]\n            result = dfs(i, j, path, set(), 1)\n            if global_min is None or (result is not None and result < global_min):\n                global_min = result\n    return global_min", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_path = None\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n\n\n    def backtrack(x, y, path, visited):\n        nonlocal min_path\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if is_valid(nx, ny):\n                visited.add((nx, ny))\n                backtrack(nx, ny, path + [grid[nx][ny]], visited)\n                visited.remove((nx, ny))\n    for i in range(n):\n        for j in range(n):\n            visited = set()\n            visited.add((i, j))\n            backtrack(i, j, [grid[i][j]], visited)\n    return min_path", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n\n\n    def dfs(x, y, path, visited):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if is_valid(nx, ny):\n                new_path = path + [grid[nx][ny]]\n                if not min_path or new_path < min_path:\n                    result = dfs(nx, ny, new_path, visited)\n                    if result is not None:\n                        if not min_path or result < min_path:\n                            min_path = result\n        return min_path\n    min_path = None\n    for i, j in product(range(n), range(n)):\n        path = [grid[i][j]]\n        result = dfs(i, j, path, set())\n        if result is not None:\n            if not min_path or result < min_path:\n                min_path = result\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def get_neighbors(i, j):\n        neighbors = []\n        if i > 0:\n            neighbors.append((i - 1, j))\n        if j > 0:\n            neighbors.append((i, j - 1))\n        if i < len(grid) - 1:\n            neighbors.append((i + 1, j))\n        if j < len(grid[0]) - 1:\n            neighbors.append((i, j + 1))\n        return neighbors\n\n    def backtrack(path, i, j):\n        if len(path) == k:\n            return path\n        min_path = None\n        for ni, nj in get_neighbors(i, j):\n            new_path = path.copy()\n            new_path.append(grid[ni][nj])\n            candidate = backtrack(new_path, ni, nj)\n            if candidate is not None and (min_path is None or candidate < min_path):\n                min_path = candidate\n        return min_path\n    min_global = None\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            candidate = backtrack([grid[i][j]], i, j)\n            if candidate is not None and (min_global is None or candidate < min_global):\n                min_global = candidate\n    return min_global", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n\n\n    def dfs(x, y, path, visited):\n        if len(path) == k:\n            return path\n        min_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if is_valid(nx, ny):\n                new_path = path.copy()\n                new_path.append(grid[nx][ny])\n                new_visited = visited.copy()\n                new_visited.add((nx, ny))\n                candidate = dfs(nx, ny, new_path, new_visited)\n                if candidate is not None and (min_path is None or candidate < min_path):\n                    min_path = candidate\n        return min_path\n    min_result = None\n    for i, j in product(range(n), range(n)):\n        start_path = [grid[i][j]]\n        visited = set([(i, j)])\n        candidate = dfs(i, j, start_path, visited)\n        if candidate is not None and (min_result is None or candidate < min_result):\n            min_result = candidate\n    return min_result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.5}}
{"task_id": "HumanEval/130", "requirement": "from typing import List\n\ndef tri(n: int) -> List[float]:\n    \"\"\"\n    Everyone knows the Fibonacci sequence, which has been studied deeply by mathematicians \n    over the last couple of centuries. However, what people don't know is the Tribonacci sequence.\n    The Tribonacci sequence is defined by the following rules:\n\n    1. The sequence starts with predefined values:\n       - `tri(0) = 1.0`\n       - `tri(1) = 3.0`\n    2. For even `n >= 2`, the value is calculated as `tri(n) = 1 + n / 2`. This result is always a float.\n    3. For odd `n >= 3`, the value is calculated recursively as:\n       `tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)`.\n       - When calculating `tri(n + 1)` in this formula, it is computed recursively, even if `n + 1` exceeds the input range. \n       - Any intermediate values computed for indices beyond `n` are used solely for resolving recursion and are not included in the final output.\n\n    You are given a non-negative integer `n`, and you must return a list of the first `n + 1` numbers \n    of the Tribonacci sequence, starting from `tri(0)` and ending at `tri(n)`.\n\n    Examples:\n    tri(3) = [1.0, 3.0, 2.0, 8.0]\n    tri(4) = [1.0, 3.0, 2.0, 8.0, 3.0]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def calculate_tri(x: int) -> float:\n        if x == 0:\n            return 1.0\n        elif x == 1:\n            return 3.0\n        elif x % 2 == 0:\n            return 1 + x / 2\n        else:\n            return calculate_tri(x - 1) + calculate_tri(x - 2) + calculate_tri(x + 1)\n    return [calculate_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def calculate_tri(k: int) -> float:\n        if k == 0:\n            return 1.0\n        elif k == 1:\n            return 3.0\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return calculate_tri(k - 1) + calculate_tri(k - 2) + calculate_tri(k + 1)\n    return [calculate_tri(i) for i in range(n + 1)]", "from typing import List\nfrom functools import lru_cache\n\ndef _tri(n: int) -> float:\n    if n == 0:\n        return 1.0\n    elif n == 1:\n        return 3.0\n    elif n % 2 == 0:\n        return 1 + n / 2\n    else:\n        return _tri(n - 1) + _tri(n - 2) + _tri(n + 1)\n\ndef tri(n: int) -> List[float]:\n    return [_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {0: 1.0, 1: 3.0}\n\n    def compute(k):\n        if k in memo:\n            return memo[k]\n        if k % 2 == 0:\n            memo[k] = 1 + k / 2\n        else:\n            memo[k] = compute(k - 1) + compute(k - 2) + compute(k + 1)\n        return memo[k]\n    for i in range(n + 1):\n        compute(i)\n    return [memo[i] for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {}\n\n    def calculate_tri(k: int) -> float:\n        if k in memo:\n            return memo[k]\n        if k == 0:\n            memo[k] = 1.0\n        elif k == 1:\n            memo[k] = 3.0\n        elif k >= 2 and k % 2 == 0:\n            memo[k] = 1 + k / 2\n        else:\n            memo[k] = calculate_tri(k - 1) + calculate_tri(k - 2) + calculate_tri(k + 1)\n        return memo[k]\n    result = []\n    for i in range(n + 1):\n        result.append(calculate_tri(i))\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    memo = {}\n\n    def calculate_tri(k: int) -> float:\n        if k in memo:\n            return memo[k]\n        if k == 0:\n            memo[k] = 1.0\n        elif k == 1:\n            memo[k] = 3.0\n        elif k % 2 == 0:\n            memo[k] = 1 + k / 2\n        else:\n            memo[k] = calculate_tri(k - 1) + calculate_tri(k - 2) + calculate_tri(k + 1)\n        return memo[k]\n    result = []\n    for i in range(n + 1):\n        result.append(calculate_tri(i))\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    if n == 1:\n        return [1.0, 3.0]\n    memo = {0: 1.0, 1: 3.0}\n\n    def calculate(k: int) -> float:\n        if k in memo:\n            return memo[k]\n        if k % 2 == 0:\n            memo[k] = 1.0 + k / 2\n        else:\n            memo[k] = calculate(k - 1) + calculate(k - 2) + calculate(k + 1)\n        return memo[k]\n    calculate(n)\n    return [memo[i] for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    if n == 1:\n        return [1.0, 3.0]\n    sequence = [1.0, 3.0]\n\n    def calc_tri(k: int) -> float:\n        if k == 0:\n            return 1.0\n        if k == 1:\n            return 3.0\n        if k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return calc_tri(k - 1) + calc_tri(k - 2) + calc_tri(k + 1)\n    for i in range(2, n + 1):\n        sequence.append(calc_tri(i))\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    if n == 1:\n        return [1.0, 3.0]\n    result = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result.append(1 + i / 2)\n        else:\n            tri_n_minus_1 = result[i - 1]\n            tri_n_minus_2 = result[i - 2]\n            if i + 1 <= n:\n                tri_n_plus_1 = tri(i + 1)[-1]\n            else:\n                tri_n_plus_1 = tri(i + 1)[-1]\n            result.append(tri_n_minus_1 + tri_n_minus_2 + tri_n_plus_1)\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n == 0:\n        return [1.0]\n    if n == 1:\n        return [1.0, 3.0]\n    sequence = [1.0, 3.0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n\n            def get_tri(k: int) -> float:\n                if k == 0:\n                    return 1.0\n                if k == 1:\n                    return 3.0\n                if k % 2 == 0:\n                    return 1 + k / 2\n                else:\n                    return get_tri(k - 1) + get_tri(k - 2) + get_tri(k + 1)\n            sequence.append(get_tri(i))\n    return sequence"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.30000000000000004, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/132", "requirement": "```python\ndef is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if the string contains a valid sequence of brackets \n    where at least one pair of brackets is nested.\n\n    A \"valid sequence of brackets\" is defined as a sequence where:\n    1. Every opening bracket '[' has a corresponding closing bracket ']', and\n    2. Brackets are properly matched in a left-to-right order (e.g., \"[[]]\" is valid, but \"][\" is not).\n\n    A \"nested pair of brackets\" exists if, at any point in the sequence, there is at least one unmatched \n    opening bracket '[' before a closing bracket ']' is encountered, such that the unmatched opening \n    bracket remains unmatched at the time the closing bracket is processed.\n\n    The function should return:\n    - True if the string contains a valid sequence of brackets with at least one nested pair.\n    - False if the string is invalid (e.g., contains unmatched brackets) or does not contain any nested pairs.\n\n    Notes:\n    - The function should prioritize detecting valid nesting over ensuring that the entire string is globally valid.\n    - If valid nesting is detected at any point, the function should return True, even if unmatched opening brackets \n      remain at the end of the string.\n\n    Examples:\n    is_nested('[[]]')  True\n    is_nested('[]]]]]]][[[[[]')  False\n    is_nested('[][]')  False\n    is_nested('[]')  False\n    is_nested('[[][]]')  True\n    is_nested('[[]][[')  True\n    '''\n```", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif stack:\n            stack.pop()\n            if stack:\n                nested = True\n        else:\n            return False\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n            else:\n                return False\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    has_nested = True\n            else:\n                return False\n    return has_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n            else:\n                return False\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    has_nested = True\n            else:\n                return False\n    return has_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            if stack:\n                nested = True\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    has_nested = True\n            else:\n                return False\n    return has_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            if len(stack) > 1:\n                has_nested = True\n            stack.pop()\n    return has_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                if stack[-1] == '[':\n                    stack.pop()\n                    if stack:\n                        has_nested = True\n            else:\n                return False\n    return has_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif stack:\n            if len(stack) > 1:\n                has_nested = True\n            stack.pop()\n        else:\n            return False\n    return has_nested"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/134", "requirement": "```python\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    \"\"\"\n    Create a function that returns True if the last non-space character \n    of a given string is an alphabetical character and is the only \n    character in the last word. A word is defined as a group of \n    non-space characters separated by spaces. The function should \n    ignore trailing spaces and evaluate the last word after removing \n    them. If the string is empty or the last word does not meet the \n    criteria, return False.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\")  False\n    check_if_last_char_is_a_letter(\"apple pi e\")  True\n    check_if_last_char_is_a_letter(\"apple pi e \")  False\n    check_if_last_char_is_a_letter(\"\")  False\n    \"\"\"\n```", "generated_programs": ["def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    if len(last_word) == 1 and last_word.isalpha():\n        return True\n    return False", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.rstrip()\n    if not stripped_txt:\n        return False\n    last_word = stripped_txt.split()[-1]\n    return len(last_word) == 1 and last_word.isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1 and last_word[-1].isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1]\n    if len(last_word) != 1:\n        return False\n    return last_word[-1].isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_word = txt.split()[-1] if txt.split() else ''\n    return len(last_word) == 1 and last_word[0].isalpha()", "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    last_word = txt.split()[-1]\n    return len(last_word) == 1", "import re\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n    stripped_txt = txt.rstrip()\n    if not stripped_txt:\n        return False\n    words = stripped_txt.split(' ')\n    last_word = words[-1]\n    return len(last_word) == 1 and last_word.isalpha()"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 1.0}}
{"task_id": "HumanEval/137", "requirement": "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n\n    Comparison rules:\n    - If both inputs are numeric types (int or float), compare them directly.\n    - If one or both inputs are strings representing real numbers, convert the strings to numeric format for comparison. Strings with ',' as the decimal separator should be treated as if ',' is replaced with '.'.\n    - After determining the larger value, return the original input format of the larger value (e.g., if the larger value was a string input, return the string as it was provided).\n    - If the numeric conversion fails for either input, return None.\n    - If the values are equal after numeric comparison, return None.\n\n    Note: The integrity of the original input format is preserved in the output.\n\n    Examples:\n    compare_one(1, 2.5)  2.5\n    compare_one(1, \"2,3\")  \"2,3\"\n    compare_one(\"5,1\", \"6\")  \"6\"\n    compare_one(\"1\", 1)  None\n    \"\"\"", "generated_programs": ["from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def to_numeric(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value) if '.' in value else int(value)\n            except ValueError:\n                return None\n        return value\n    num_a = to_numeric(a)\n    num_b = to_numeric(b)\n    if num_a is None or num_b is None:\n        return None\n    if num_a == num_b:\n        return None\n    return a if num_a > num_b else b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        return float(value)\n    a_num = convert_to_float(a)\n    b_num = convert_to_float(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    if a_num > b_num:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n        try:\n            return float(value)\n        except (ValueError, TypeError):\n            return None\n    a_num = convert_to_float(a)\n    b_num = convert_to_float(b)\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    if a_num > b_num:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        return float(value)\n    a_float = convert_to_float(a)\n    b_float = convert_to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float == b_float:\n        return None\n    if a_float > b_float:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value):\n        if isinstance(value, str):\n            try:\n                return float(value.replace(',', '.'))\n            except ValueError:\n                return None\n        elif isinstance(value, (int, float)):\n            return float(value)\n        else:\n            return None\n    a_float = convert_to_float(a)\n    b_float = convert_to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float == b_float:\n        return None\n    if a_float > b_float:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value):\n        if isinstance(value, str):\n            try:\n                return float(value.replace(',', '.'))\n            except ValueError:\n                return None\n        elif isinstance(value, (int, float)):\n            return float(value)\n        else:\n            return None\n    a_float = convert_to_float(a)\n    b_float = convert_to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float == b_float:\n        return None\n    elif a_float > b_float:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        elif isinstance(value, (int, float)):\n            return float(value)\n        return None\n    a_float = convert_to_float(a)\n    b_float = convert_to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float > b_float:\n        return a\n    elif b_float > a_float:\n        return b\n    else:\n        return None", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_numeric(x):\n        if isinstance(x, str):\n            x = x.replace(',', '.')\n            try:\n                return float(x)\n            except ValueError:\n                return None\n        return float(x) if isinstance(x, (int, float)) else None\n    a_numeric = convert_to_numeric(a)\n    b_numeric = convert_to_numeric(b)\n    if a_numeric is None or b_numeric is None:\n        return None\n    if a_numeric == b_numeric:\n        return None\n    if a_numeric > b_numeric:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value):\n        if isinstance(value, str):\n            try:\n                return float(value.replace(',', '.'))\n            except ValueError:\n                return None\n        elif isinstance(value, (int, float)):\n            return float(value)\n        else:\n            return None\n    a_float = convert_to_float(a)\n    b_float = convert_to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float == b_float:\n        return None\n    if a_float > b_float:\n        return a\n    else:\n        return b", "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n\n    def convert_to_float(value: Union[int, float, str]) -> Union[float, None]:\n        if isinstance(value, (int, float)):\n            return float(value)\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        return None\n    a_float = convert_to_float(a)\n    b_float = convert_to_float(b)\n    if a_float is None or b_float is None:\n        return None\n    if a_float == b_float:\n        return None\n    if a_float > b_float:\n        return a\n    else:\n        return b"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/139", "requirement": "```python\ndef special_factorial(n: int) -> int:\n    \"\"\"\n    The special factorial is defined as:\n    special_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n is a non-negative integer (n >= 0).\n\n    If n = 0, the result is defined as 1, consistent with the mathematical convention that 0! = 1.\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n```", "generated_programs": ["import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result", "import math\n\ndef special_factorial(n: int) -> int:\n    if n < 0:\n        raise ValueError('n must be a non-negative integer')\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/140", "requirement": "```python\ndef fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, replace all spaces based on the following rules, applied sequentially:\n    1. Replace all occurrences of 3 or more consecutive spaces with a single `-`.\n    2. Replace all remaining spaces (including single spaces and consecutive spaces up to 2) with underscores `_`.\n\n    Notes:\n    - The first rule is applied before the second rule.\n    - The second rule only processes spaces that remain after the first rule has been applied.\n    - The `-` introduced by the first rule is not affected by the second rule.\n\n    Examples:\n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n```", "generated_programs": ["import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('\\\\s', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('\\\\s', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('\\\\s', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('\\\\s', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\ {3,}', '-', text)\n    text = re.sub('\\\\ ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.6, "original_passk": 0.5}}
{"task_id": "HumanEval/141", "requirement": "```python\ndef file_name_check(file_name: str) -> str:\n    \"\"\"\n    Create a function which takes a string representing a file's name, and returns\n    'Yes' if the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - The file's name must contain exactly one dot '.' separating the prefix and suffix.\n    - The substring before the dot (prefix) must:\n        - Not be empty.\n        - Start with a letter from the Latin alphabet ('a'-'z' or 'A'-'Z').\n    - The substring after the dot (suffix) must be one of these: ['txt', 'exe', 'dll'].\n    - The file's name must not contain more than three digits ('0'-'9') in total, \n      including both the prefix and suffix.\n    - No additional dots or characters are allowed beyond the single dot separating \n      the prefix and suffix.\n\n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a Latin alphabet letter)\n    \"\"\"\n```", "generated_programs": ["def file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if sum((c.isdigit() for c in file_name)) > 3:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if len(re.findall('\\\\d', file_name)) > 3:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    digits = sum((c.isdigit() for c in file_name))\n    if digits > 3:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    digit_count = sum((c.isdigit() for c in file_name))\n    if digit_count > 3:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if len(re.findall('\\\\d', file_name)) > 3:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    digit_count = sum((c.isdigit() for c in file_name))\n    if digit_count > 3:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if len(re.findall('\\\\d', file_name)) > 3:\n        return 'No'\n    return 'Yes'", "def file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    digit_count = sum((c.isdigit() for c in file_name))\n    if digit_count > 3:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if not re.match('^[a-zA-Z][^.]*\\\\.[a-zA-Z0-9]+$', file_name):\n        return 'No'\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    prefix, suffix = parts\n    if not prefix:\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if len(re.findall('\\\\d', prefix + suffix)) > 3:\n        return 'No'\n    return 'Yes'", "import re\n\ndef file_name_check(file_name: str) -> str:\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if len(re.findall('\\\\d', file_name)) > 3:\n        return 'No'\n    if len(re.findall('[^a-zA-Z0-9.]', file_name)) > 0:\n        return 'No'\n    return 'Yes'"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.8, "original_passk": 1.0}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_digits(n: int) -> int:\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(num):\n        return sum((int(digit) for digit in str(abs(num))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "code\nfrom typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n):\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(d) for d in str(abs(n))))\n    return [num for _, num in sorted(zip([digit_sum(num) for num in nums], range(len(nums))), key=lambda x: (x[0], x[1]))]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/146", "requirement": "from typing import List\n\n\ndef specialFilter(nums: List[int]) -> int:\n    \"\"\"Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    return sum((1 for num in nums if num > 10 and int(str(abs(num))[0]) % 2 != 0 and (int(str(abs(num))[-1]) % 2 != 0)))", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            str_num = str(abs(num))\n            first_digit = int(str_num[0])\n            last_digit = int(str_num[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if num_str:\n                first_digit = int(num_str[0])\n                last_digit = int(num_str[-1])\n                if first_digit % 2 != 0 and last_digit % 2 != 0:\n                    count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if len(num_str) > 0:\n                first_digit = int(num_str[0])\n                last_digit = int(num_str[-1])\n                if first_digit % 2 != 0 and last_digit % 2 != 0:\n                    count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n\n    def is_first_and_last_odd(n):\n        if n == 0:\n            return False\n        n = abs(n)\n        last_digit = n % 10\n        first_digit = int(str(n)[0])\n        return first_digit % 2 == 1 and last_digit % 2 == 1\n    return sum((1 for num in nums if num > 10 and is_first_and_last_odd(num)))", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n\n    def is_odd_digit(n):\n        return n % 2 != 0\n    count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if is_odd_digit(first_digit) and is_odd_digit(last_digit):\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n\n    def is_odd_digit(n):\n        return n in {1, 3, 5, 7, 9}\n    count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if is_odd_digit(first_digit) and is_odd_digit(last_digit):\n                count += 1\n    return count", "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n\n    def is_odd_digit(digit: int) -> bool:\n        return digit % 2 != 0\n    count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if is_odd_digit(first_digit) and is_odd_digit(last_digit):\n                count += 1\n    return count"], "result": {"repaired_passk": 0.8, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/147", "requirement": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1  i  n), the value of a[i] is calculated as i * i - i + 1.\n    Return the number of triples (a[i], a[j], a[k]) such that i < j < k, and the sum \n    of the elements in the triple (a[i] + a[j] + a[k]) is divisible by 3.\n\n    Example:\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"", "generated_programs": ["from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "import itertools\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in itertools.combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triplet in combinations(a, 3):\n        if sum(triplet) % 3 == 0:\n            count += 1\n    return count", "from itertools import combinations\n\ndef get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for triple in combinations(a, 3):\n        if sum(triple) % 3 == 0:\n            count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    rem_counts = [0, 0, 0]\n    for num in a:\n        rem_counts[num % 3] += 1\n    count += rem_counts[0] * (rem_counts[0] - 1) * (rem_counts[0] - 2) // 6\n    count += rem_counts[1] * (rem_counts[1] - 1) * (rem_counts[1] - 2) // 6\n    count += rem_counts[2] * (rem_counts[2] - 1) * (rem_counts[2] - 2) // 6\n    count += rem_counts[0] * rem_counts[1] * rem_counts[2]\n    return count"], "result": {"repaired_passk": 0.8888888888888888, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/153", "requirement": "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    \"\"\"\n    You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\n    Requirements:\n    1. If the `extensions` list is empty, the function must raise a `ValueError` \n       indicating that no extensions are available to evaluate.\n    2. If there are two or more extensions with the same strength, you should\n       choose the one that comes first in the list.\n    3. Non-alphabetic characters in the extension names should be ignored when \n       calculating the strength. Only uppercase and lowercase alphabetic characters \n       contribute to the strength calculation.\n    4. The returned string must always be in the format: ClassName.StrongestExtensionName.\n\n    Examples:\n    - For Strongest_Extension('Slices', ['SErviNGSliCes', 'Cheese', 'StuFfed']), \n      the function should return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the \n      strongest extension (its strength is -1).\n    - For Strongest_Extension('my_class', ['AA', 'Be', 'CC']), the function should \n      return 'my_class.AA'.\n    - For Strongest_Extension('EmptyClass', []), the function should raise a `ValueError`.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('No extensions are available to evaluate.')\n\n    def calculate_strength(extension):\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    max_strength = None\n    strongest_ext = None\n    for ext in extensions:\n        strength = calculate_strength(ext)\n        if max_strength is None or strength > max_strength:\n            max_strength = strength\n            strongest_ext = ext\n    return f'{class_name}.{strongest_ext}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('No extensions are available to evaluate.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    strongest_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > strongest_strength:\n            strongest_extension = extension\n            strongest_strength = current_strength\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('No extensions are available to evaluate.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        strength = calculate_strength(extension)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('No extensions are available to evaluate.')\n\n    def calculate_strength(extension):\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for ext in extensions[1:]:\n        current_strength = calculate_strength(ext)\n        if current_strength > max_strength:\n            max_strength = current_strength\n            strongest_extension = ext\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('No extensions are available to evaluate.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    max_strength = calculate_strength(extensions[0])\n    strongest = extensions[0]\n    for ext in extensions[1:]:\n        strength = calculate_strength(ext)\n        if strength > max_strength:\n            max_strength = strength\n            strongest = ext\n    return f'{class_name}.{strongest}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('No extensions are available to evaluate.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest = extensions[0]\n    max_strength = calculate_strength(strongest)\n    for ext in extensions[1:]:\n        current_strength = calculate_strength(ext)\n        if current_strength > max_strength:\n            max_strength = current_strength\n            strongest = ext\n    return f'{class_name}.{strongest}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('No extensions are available to evaluate.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            strongest_extension = extension\n            max_strength = current_strength\n    return f'{class_name}.{strongest_extension}'", "code\nfrom typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('No extensions are available to evaluate.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    max_strength = calculate_strength(extensions[0])\n    strongest_extension = extensions[0]\n    for ext in extensions[1:]:\n        strength = calculate_strength(ext)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = ext\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('No extensions are available to evaluate.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper() and char.isalpha()))\n        sm = sum((1 for char in extension if char.islower() and char.isalpha()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        strength = calculate_strength(extension)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        raise ValueError('No extensions are available to evaluate.')\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        current_strength = calculate_strength(extension)\n        if current_strength > max_strength:\n            max_strength = current_strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "```python\ndef cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"\n    You are given two words, `a` and `b`. The function returns True if the second word (`b`) \n    or any of its rotations (including the original word itself) is a substring of the first word (`a`).\n    Otherwise, it returns False.\n\n    Additional details:\n    1. If either `a` or `b` is an empty string, the function returns False.\n    2. A \"rotation\" of a string `b` is defined as any string that can be obtained by shifting \n       characters of `b` circularly, including the original string itself.\n    3. The function assumes `a` and `b` are strings containing any characters, with no constraints \n       on length or content.\n\n    Examples:\n    cycpattern_check(\"abcd\", \"abd\") => False\n    cycpattern_check(\"hello\", \"ell\") => True\n    cycpattern_check(\"whassup\", \"psus\") => False\n    cycpattern_check(\"abab\", \"baa\") => True\n    cycpattern_check(\"efef\", \"eeff\") => False\n    cycpattern_check(\"himenss\", \"simen\") => True\n    cycpattern_check(\"\", \"\") => False\n    \"\"\"\n```", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    n = len(b)\n    for i in range(n):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not a or not b:\n        return False\n    n = len(b)\n    for i in range(n):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "HumanEval/158", "requirement": "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    \"\"\"\n    Write a function that accepts a list of strings.\n    The list contains different words. Return the word with the maximum number\n    of unique characters. Unique characters are determined in a case-sensitive manner \n    (e.g., 'A' and 'a' are considered different).\n\n    If multiple strings have the same maximum number of unique characters, return the one \n    which comes first in lexicographical order. Lexicographical comparisons are case-sensitive \n    (e.g., 'Apple' comes before 'apple').\n\n    If the input list is empty, return an empty string.\n\n    Examples:\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique or (unique_count == max_unique and word < result):\n            max_unique = unique_count\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique or (unique_chars == max_unique and word < result):\n            max_unique = unique_chars\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique or (unique_chars == max_unique and word < result):\n            max_unique = unique_chars\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique or (unique_count == max_unique and word < result):\n            max_unique = unique_count\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique or (unique_chars == max_unique and word < result):\n            max_unique = unique_chars\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique or (unique_chars == max_unique and word < result):\n            max_unique = unique_chars\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    candidate = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique or (unique_chars == max_unique and word < candidate):\n            max_unique = unique_chars\n            candidate = word\n    return candidate", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n\n    def count_unique_chars(word):\n        return len(set(word))\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_count = count_unique_chars(word)\n        if unique_count > max_unique or (unique_count == max_unique and word < result):\n            max_unique = unique_count\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique or (unique_count == max_unique and word < result):\n            max_unique = unique_count\n            result = word\n    return result", "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    if not words:\n        return ''\n    max_unique = -1\n    result = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique or (unique_chars == max_unique and word < result):\n            max_unique = unique_chars\n            result = word\n    return result"], "result": {"repaired_passk": 0.9, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/160", "requirement": "def do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists, `operator` and `operand`, construct an algebraic expression by \n    combining the elements of `operand` with the corresponding elements of `operator` \n    in sequence, and return the evaluated result of this expression.\n\n    The construction of the expression follows these rules:\n    1. Start with the first element of `operand` as the initial value of the expression.\n    2. For each operator in `operator`, append it to the expression, followed by the \n       next element of `operand` in order.\n    3. Evaluate the resulting expression using Python's standard arithmetic rules.\n\n    The basic algebra operations allowed in `operator` are:\n    - Addition ( + ) \n    - Subtraction ( - ) \n    - Multiplication ( * ) \n    - Floor division ( // ) \n    - Exponentiation ( ** ) \n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    The constructed expression is: 2 + 3 * 4 - 5\n    The evaluated result is: 9\n\n    Note:\n        - The length of the `operator` list is equal to the length of the `operand` list minus one.\n        - The `operand` list contains non-negative integers.\n        - The `operator` list contains at least one operator, and the `operand` list contains at least two operands.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n    return eval(expression)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return a list of all single-digit \n    even numbers (0, 2, 4, 6, 8) that lie within the inclusive range defined \n    by the smaller and larger of a and b, in ascending order.\n\n    Notes:\n    - The range is determined as [min(a, b), max(a, b)].\n    - Only single-digit even numbers are considered, regardless of the values of a and b.\n    - If no single-digit even numbers fall within the range, return an empty list.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    return [num for num in range(start, end + 1) if num in {0, 2, 4, 6, 8}]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    lower = min(a, b)\n    upper = max(a, b)\n    result = [num for num in range(lower, upper + 1) if num in {0, 2, 4, 6, 8}]\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_numbers = [num for num in range(start, end + 1) if num % 2 == 0 and 0 <= num <= 8]\n    return even_numbers", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_digits = [0, 2, 4, 6, 8]\n    return sorted([x for x in even_digits if start <= x <= end])", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    return [x for x in range(start, end + 1) if x in {0, 2, 4, 6, 8}]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_digits = [i for i in range(start, end + 1) if i in {0, 2, 4, 6, 8}]\n    return even_digits", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_digits = [0, 2, 4, 6, 8]\n    return [num for num in even_digits if start <= num <= end]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_numbers = [num for num in range(start, end + 1) if num in {0, 2, 4, 6, 8}]\n    return even_numbers", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    result = [num for num in range(start, end + 1) if num in {0, 2, 4, 6, 8}]\n    return result", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    start = min(a, b)\n    end = max(a, b)\n    even_single_digit = [num for num in range(start, end + 1) if num in {0, 2, 4, 6, 8}]\n    return even_single_digit"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}

{"task_id": "HumanEval/1", "requirement": "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \n    Input to this function is a string containing multiple groups of nested parentheses. \n    The function separates these groups into individual balanced parentheses strings and returns them as a list. \n    Each group is balanced (each opening parenthesis is properly closed) and not nested within another group. \n    Spaces in the input string are ignored and should not be included in the output. \n    The function processes the string sequentially, identifying groups by tracking the depth of nesting using a stack.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string:\n        if char == ' ':\n            continue\n        current_group.append(char)\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string:\n        if char == ' ':\n            continue\n        current_group.append(char)\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n        elif char.strip() == '':\n            continue\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n        if depth == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            if depth == 0:\n                current_group = []\n            current_group.append(char)\n            depth += 1\n        elif char == ')':\n            current_group.append(char)\n            depth -= 1\n            if depth == 0:\n                result.append(''.join(current_group))\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            depth += 1\n            current_group.append(char)\n        elif char == ')':\n            depth -= 1\n            current_group.append(char)\n            if depth == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    group = ''\n    depth = 0\n    for char in paren_string.replace(' ', ''):\n        if char == '(':\n            depth += 1\n            group += char\n        elif char == ')':\n            depth -= 1\n            group += char\n        if depth == 0 and group:\n            result.append(group)\n            group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    depth = 0\n    for char in paren_string:\n        if char == '(':\n            if depth == 0:\n                current_group = []\n            current_group.append(char)\n            depth += 1\n        elif char == ')':\n            current_group.append(char)\n            depth -= 1\n            if depth == 0:\n                result.append(''.join(current_group))\n        elif char == ' ':\n            continue\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/10", "requirement": "def is_palindrome(string: str) -> bool:\n    \"\"\"Test if the given string is a palindrome.\"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that begins with the supplied string by appending the reverse of the prefix before the longest palindromic suffix.\n    \n    The algorithm works as follows:\n    1. Identify the longest palindromic suffix in the supplied string.\n    2. Append the reverse of the prefix that comes before this palindromic suffix to the original string.\n    3. Return the resulting string, which is the shortest palindrome starting with the supplied string.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["from typing import Optional\n\ndef is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    length = len(string)\n    for i in range(length):\n        if is_palindrome(string[i:]):\n            return string[:i][::-1] + string\n    return string", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string[:i][::-1] + string\n    return string", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "from typing import List\n\ndef is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    n = len(string)\n    for i in range(n):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix = string[:i][::-1]\n            return string + prefix\n    return ''", "from typing import List\n\ndef is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string[:i][::-1] + string\n    return ''", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "from typing import List\n\ndef is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            prefix_to_add = string[:i][::-1]\n            return string + prefix_to_add\n    return string"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/11", "requirement": "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s. The function performs a binary XOR operation on the corresponding characters of the two strings. If the strings are of different lengths, the operation is performed only on the overlapping parts, and the extra characters in the longer string are ignored. The result is returned as a string.\n    >>> string_xor('010', '110')\n    '100'\n    >>> string_xor('101', '11')\n    '01'\n    \"\"\"", "generated_programs": ["def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(char_a) ^ int(char_b)) for char_a, char_b in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if char_a != char_b else '0' for char_a, char_b in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/13", "requirement": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b as a non-negative integer.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(6, -4)\n    2\n    \"\"\"", "generated_programs": ["from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))", "import math\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return math.gcd(a, b)", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(abs(a), abs(b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))", "from typing import Tuple\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    import math\n    return abs(math.gcd(a, b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/32", "requirement": "from typing import List\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/43", "requirement": "from typing import List\n\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, where distinct elements are defined as having different values.\n    The pair (0, 0) is considered a valid pair that sums to zero.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen or (num == 0 and l.count(0) > 1):\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen or (num == 0 and l.count(0) > 1):\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen or (num == 0 and l.count(0) > 1):\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen_numbers = set()\n    for num in l:\n        if -num in seen_numbers or num == 0:\n            return True\n        seen_numbers.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen_numbers = set()\n    for num in l:\n        if -num in seen_numbers:\n            return True\n        seen_numbers.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen or (num == 0 and l.count(0) > 1):\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for number in l:\n        if -number in seen or (number == 0 and l.count(0) > 1):\n            return True\n        seen.add(number)\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 1:\n        return float(l[mid])\n    else:\n        return (l[mid - 1] + l[mid]) / 2.0", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_list[mid - 1] + sorted_list[mid]) / 2\n    else:\n        return float(sorted_list[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 1:\n        return float(l[mid])\n    else:\n        return (l[mid - 1] + l[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l = sorted(l)\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 1:\n        return float(l[mid])\n    else:\n        return (l[mid - 1] + l[mid]) / 2.0", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 1:\n        return float(l[mid])\n    else:\n        return (l[mid - 1] + l[mid]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    mid = n // 2\n    if n % 2 == 1:\n        return float(sorted_list[mid])\n    else:\n        return (sorted_list[mid - 1] + sorted_list[mid]) / 2.0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/54", "requirement": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same set of unique characters, regardless of the frequency of each character.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"", "generated_programs": ["def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "from typing import Set\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "from typing import Set\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "from typing import Set\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/67", "requirement": "def fruit_distribution(s: str, n: int) -> int:\n    \"\"\"\n    Given a string `s` that describes the number of apples and oranges in a basket, and an integer `n` \n    representing the total number of fruits in the basket, return the number of mango fruits in the basket.\n    \n    The string `s` will contain the number of apples and oranges in the format \"X apples and Y oranges\", \n    where X and Y are non-negative integers. If either \"apples\" or \"oranges\" is missing from the string, \n    the corresponding count is assumed to be 0.\n    \n    The number of mango fruits is calculated by subtracting the number of apples and oranges from the total \n    number of fruits `n`.\n    \n    Examples:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) -> 8\n    fruit_distribution(\"0 apples and 1 oranges\", 3) -> 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 95\n    fruit_distribution(\"100 apples and 1 oranges\", 120) -> 19\n    \"\"\"", "generated_programs": ["import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples = oranges = 0\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    if apples_match:\n        apples = int(apples_match.group(1))\n    if oranges_match:\n        oranges = int(oranges_match.group(1))\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    match_apples = re.search('(\\\\d+)\\\\s+apples', s)\n    match_oranges = re.search('(\\\\d+)\\\\s+oranges', s)\n    apples = int(match_apples.group(1)) if match_apples else 0\n    oranges = int(match_oranges.group(1)) if match_oranges else 0\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+) apples', s)\n    oranges_match = re.search('(\\\\d+) oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - apples - oranges", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples_count = int(apples_match.group(1)) if apples_match else 0\n    oranges_count = int(oranges_match.group(1)) if oranges_match else 0\n    return n - (apples_count + oranges_count)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+) apples', s)\n    oranges_match = re.search('(\\\\d+) oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - apples - oranges", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+) apples', s)\n    oranges_match = re.search('(\\\\d+) oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    mangoes = n - (apples + oranges)\n    return mangoes", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s+apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s+oranges', s)\n    apples_count = int(apples_match.group(1)) if apples_match else 0\n    oranges_count = int(oranges_match.group(1)) if oranges_match else 0\n    return n - (apples_count + oranges_count)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apple_match = re.search('(\\\\d+)\\\\s*apples', s)\n    orange_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(apple_match.group(1)) if apple_match else 0\n    oranges = int(orange_match.group(1)) if orange_match else 0\n    return n - apples - oranges", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    match_apples = re.search('(\\\\d+)\\\\s*apples', s)\n    match_oranges = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(match_apples.group(1)) if match_apples else 0\n    oranges = int(match_oranges.group(1)) if match_oranges else 0\n    return n - (apples + oranges)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/76", "requirement": "def is_simple_power(x: int, n: int) -> bool:\n    \"\"\"Your task is to write a function that returns true if a number x is a simple power of n and false in other cases.\n    x is a simple power of n if there exists a non-negative integer k such that n^k = x.\n    Specifically:\n    - If n == 1, x must also be 1 to return True.\n    - For other values of n, the function iteratively calculates n^k until n^k >= x. If n^k == x, it returns True; otherwise, False.\n    - The function assumes x and n are non-negative integers.\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"", "generated_programs": ["def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    k = 0\n    value = 1\n    while value < x:\n        k += 1\n        value = n ** k\n    return value == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    k = 0\n    while n ** k <= x:\n        if n ** k == x:\n            return True\n        k += 1\n    return False", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    k = 0\n    power = 1\n    while power < x:\n        k += 1\n        power = n ** k\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    k = 0\n    power = 1\n    while power < x:\n        k += 1\n        power = n ** k\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    k = 0\n    power = 1\n    while power < x:\n        k += 1\n        power = n ** k\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    k = 0\n    power = 1\n    while power < x:\n        k += 1\n        power = n ** k\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    k = 0\n    power = 1\n    while power < x:\n        k += 1\n        power = n ** k\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    k = 0\n    power = 1\n    while power < x:\n        k += 1\n        power *= n\n    return power == x"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    '''\n    Write a function that takes an integer a and returns True \n    if this integer is a perfect cube of some integer number. \n    A perfect cube is an integer that can be expressed as the cube of another integer, \n    including negative integers and zero. The function should compute the cube root of the input, \n    round it to the nearest integer, and then check if cubing this rounded integer equals the original input.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    rounded_cube_root = round(a ** (1 / 3))\n    return rounded_cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    rounded_cuberoot = round(a ** (1 / 3))\n    return rounded_cuberoot ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    rounded_cube_root = round(math.pow(a, 1 / 3))\n    return rounded_cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    rounded_cube_root = round(a ** (1 / 3))\n    return rounded_cube_root ** 3 == a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.6}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start with 1, end with 1, or both. \n    The count should include numbers that start with 1, end with 1, and those that both start and end with 1, \n    but the overlap (numbers that both start and end with 1) should be counted only once.\n    For n=1, the number 1 should be counted once since it both starts and ends with 1.\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    numbers_start_with_1 = 10 ** (n - 1)\n    numbers_end_with_1 = 10 ** (n - 1)\n    numbers_start_and_end_with_1 = 10 ** (n - 2)\n    return numbers_start_with_1 + numbers_end_with_1 - numbers_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 10 ** (n - 1)\n    starts_and_ends_with_1 = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - starts_and_ends_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_start_with_1 = 10 ** (n - 1)\n    total_end_with_1 = 10 ** (n - 1)\n    overlap = 10 ** (n - 2)\n    return total_start_with_1 + total_end_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1) // 9\n    both_start_and_end_with_1 = 1\n    return start_with_1 + end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_n_digit_numbers = 9 * 10 ** (n - 1)\n    numbers_start_with_1 = 10 ** (n - 1)\n    numbers_end_with_1 = total_n_digit_numbers // 10\n    numbers_start_and_end_with_1 = 10 ** (n - 2)\n    return numbers_start_with_1 + numbers_end_with_1 - numbers_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 10 ** (n - 1)\n    both_start_and_end_with_1 = 10 ** (n - 2)\n    return start_with_1 + end_with_1 - both_start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = (10 ** n - 1) // 10\n    start_and_end_with_1 = 10 ** (n - 1)\n    return start_with_1 + end_with_1 - start_and_end_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    count_start_with_1 = 10 ** (n - 1)\n    count_end_with_1 = 10 ** (n - 1)\n    count_start_and_end_with_1 = 10 ** (n - 2)\n    return count_start_with_1 + count_end_with_1 - count_start_and_end_with_1"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string where each lowercase letter is shifted by 4 positions \n    in the alphabet, wrapping around if necessary. Uppercase letters and \n    other characters remain unchanged.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    encrypt('z') returns 'd'\n    encrypt('ABCDEF') returns 'ABCDEF'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(char):\n        if 'a' <= char <= 'z':\n            return chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        return char\n    return ''.join((shift_char(char) for char in s))", "def encrypt(s: str) -> str:\n    from string import ascii_lowercase\n\n    def shift_letter(letter):\n        if letter in ascii_lowercase:\n            return ascii_lowercase[(ascii_lowercase.index(letter) + 4) % 26]\n        return letter\n    return ''.join((shift_letter(ch) for ch in s))", "from string import ascii_lowercase\n\ndef encrypt(s: str) -> str:\n\n    def shift(char):\n        if char in ascii_lowercase:\n            return ascii_lowercase[(ascii_lowercase.index(char) + 4) % 26]\n        return char\n    return ''.join((shift(char) for char in s))", "import string\n\ndef encrypt(s: str) -> str:\n\n    def shift_char(c):\n        if c in string.ascii_lowercase:\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_letter(ch: str) -> str:\n        if 'a' <= ch <= 'z':\n            return chr((ord(ch) - ord('a') + 4) % 26 + ord('a'))\n        return ch\n    return ''.join((shift_letter(ch) for ch in s))", "def encrypt(s: str) -> str:\n\n    def shift_character(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((shift_character(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((shift_char(c) for c in s))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\", where\n    \"I\" is considered a word if it is followed by a space or is the end of the sentence.\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    >>> is_bored(\"I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.\")\n    20\n    \"\"\"", "generated_programs": ["import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I')))\n    return boredom_count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I')))\n    return boredom_count", "def is_bored(S: str) -> int:\n    import re\n    pattern = '\\\\bI\\\\b(?=(?:\\\\.|\\\\?|!|$))'\n    sentences = re.split('[.!?]', S)\n    count = sum((1 for sentence in sentences if re.match(pattern, sentence.strip())))\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((sentence.strip().startswith('I') for sentence in sentences if sentence.strip()))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == 'I':\n            boredom_count += 1\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))", "import re\n\ndef is_bored(S: str) -> int:\n    pattern = '\\\\bI\\\\b(?:[.!?]|$)'\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if re.match(pattern, sentence.strip())))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I') and (len(sentence.strip()) == 1 or sentence.strip()[1] == ' ')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I ')))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.30000000000000004, "original_passk": 0.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message, and encodes it by swapping the case of all letters. \n    Additionally, replace all vowels in the message with the letter that appears 2 places ahead \n    of that vowel in the English alphabet. If the replacement character goes beyond 'z' or 'Z', \n    it wraps around to the beginning of the alphabet. The case of the replacement character should \n    be swapped as well. Assume the input contains only letters.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n\n    def is_vowel(letter: str) -> bool:\n        return letter.lower() in 'aeiou'\n\n    def replace_vowel(vowel: str) -> str:\n        next_vowel = chr((ord(vowel.lower()) - ord('a') + 2) % 26 + ord('a'))\n        return next_vowel.upper() if vowel.islower() else next_vowel.lower()\n\n    def swap_case_and_replace(letter: str) -> str:\n        if is_vowel(letter):\n            return replace_vowel(letter)\n        else:\n            return letter.upper() if letter.islower() else letter.lower()\n    return ''.join((swap_case_and_replace(char) for char in message))", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        if vowel.lower() in 'aeiou':\n            shifted = chr((ord(vowel.lower()) - ord('a') + 2) % 26 + ord('a'))\n            return shifted.upper() if vowel.islower() else shifted.lower()\n        return vowel\n    return ''.join((shift_vowel(char.swapcase()) if char.lower() in 'aeiou' else char.swapcase() for char in message))", "def encode(message: str) -> str:\n\n    def swap_case_and_encode(char: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if char.lower() in vowels:\n            is_upper = char.isupper()\n            replacement_char = chr((ord(char.lower()) - ord('a') + 2) % 26 + ord('a'))\n            if is_upper:\n                return replacement_char.upper()\n            return replacement_char.lower()\n        else:\n            return char.swapcase()\n    return ''.join((swap_case_and_encode(c) for c in message))", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        vowels = 'aeiouAEIOU'\n        shift_mapping = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return shift_mapping[vowel]\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            swapped_case = char.swapcase()\n            if swapped_case.lower() in 'aeiou':\n                shifted = shift_vowel(swapped_case)\n                encoded_message.append(shifted.swapcase())\n            else:\n                encoded_message.append(swapped_case)\n        else:\n            encoded_message.append(char)\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n\n    def swap_case_and_encode(character):\n        vowels = 'aeiouAEIOU'\n        if character.isalpha():\n            swapped_case = character.lower() if character.isupper() else character.upper()\n            if swapped_case in vowels:\n                is_upper = character.isupper()\n                encoded_character = chr((ord(swapped_case) + 2 - ord('a')) % 26 + ord('a')) if swapped_case.islower() else chr((ord(swapped_case) + 2 - ord('A')) % 26 + ord('A'))\n                return encoded_character.lower() if is_upper else encoded_character.upper()\n            else:\n                return swapped_case\n        return character\n    return ''.join((swap_case_and_encode(char) for char in message))", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        vowels = 'aeiou'\n        is_upper = vowel.isupper()\n        lower_vowel = vowel.lower()\n        if lower_vowel in vowels:\n            index = vowels.index(lower_vowel)\n            shifted = chr((ord(vowels[index]) + 2 - ord('a')) % 26 + ord('a'))\n            return shifted.upper() if is_upper else shifted.lower()\n        return vowel\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            swapped_case = char.swapcase()\n            encoded_message += shift_vowel(swapped_case)\n        else:\n            encoded_message += char\n    return encoded_message", "def encode(message: str) -> str:\n\n    def shift_vowel(char: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if char in vowels:\n            is_upper = char.isupper()\n            shifted = chr((ord(char.lower()) - ord('a') + 2) % 26 + ord('a'))\n            return shifted.upper() if not is_upper else shifted.lower()\n        return char\n\n    def swap_case(char: str) -> str:\n        return char.lower() if char.isupper() else char.upper()\n    encoded_message = ''.join((swap_case(shift_vowel(char)) for char in message))\n    return encoded_message", "def encode(message: str) -> str:\n\n    def swap_case_and_transform(char):\n        vowels = 'aeiouAEIOU'\n        swapped_char = char.lower() if char.isupper() else char.upper()\n        if swapped_char in vowels:\n            new_char = chr((ord(swapped_char) - ord('a' if swapped_char.islower() else 'A') + 2) % 26 + ord('a' if swapped_char.islower() else 'A'))\n            return new_char.lower() if swapped_char.isupper() else new_char.upper()\n        else:\n            return swapped_char\n    return ''.join((swap_case_and_transform(char) for char in message))", "def encode(message: str) -> str:\n\n    def swap_case_and_replace_vowel(char: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if char in vowels:\n            offset = 2\n            if char.islower():\n                asc = ord(char) + offset\n                if asc > ord('z'):\n                    asc -= 26\n                return chr(asc).upper()\n            else:\n                asc = ord(char) + offset\n                if asc > ord('Z'):\n                    asc -= 26\n                return chr(asc).lower()\n        else:\n            return char.swapcase()\n    return ''.join((swap_case_and_replace_vowel(c) for c in message))", "def encode(message: str) -> str:\n\n    def shift_vowel(char: str) -> str:\n        vowels = 'aeiouAEIOU'\n        replacement = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w', 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return replacement[char] if char in vowels else char\n    encoded_message = ''\n    for char in message:\n        swapped_case = char.lower() if char.isupper() else char.upper()\n        encoded_message += shift_vowel(swapped_case)\n    return encoded_message"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.4}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    Each subsequent level has 2 more stones than the previous level, ensuring that all levels maintain the same parity (odd or even) as the starting number n.\n    Return the number of stones in each level in a list, where the element at index i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(4)\n    [4, 6, 8, 10]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    result = [n + 2 * i for i in range(n)]\n    return result", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + i * 2 for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/101", "requirement": "from typing import List\n\n\ndef words_string(s: str) -> List[str]:\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    - Leading and trailing spaces or commas should be stripped before processing.\n    - If the string is empty or consists only of spaces or commas, return an empty list.\n    - Multiple consecutive delimiters (commas or spaces) should be treated as a single delimiter.\n    - Empty strings resulting from splitting at the boundaries or multiple consecutive delimiters should be excluded from the final list.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.replace(',', ' ').split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.strip(' ,').replace(',', ' ').split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.replace(',', ' ').split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.strip(', ').replace(',', ' ').split(' ') if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    words = [word for word in s.replace(',', ' ').split(' ') if word.strip()]\n    return words", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.strip(' ,').replace(',', ' ').split() if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    return list(filter(None, re.split('[,\\\\s]+', s.strip())))", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.strip(' ,').replace(',', ' ').split() if word]", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in re.split('[,\\\\s]+', s.strip()) if word]"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.7, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/102", "requirement": "def choose_num(x: int, y: int) -> int:\n    \"\"\"This function takes two positive integers x and y and returns the largest even integer within the range [x, y] inclusive. If x is greater than y, or if there are no even numbers in the range, the function returns -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"", "generated_programs": ["from typing import Optional\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "from typing import Optional\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "from typing import Optional\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    even_numbers = [num for num in range(x, y + 1) if num % 2 == 0]\n    return max(even_numbers) if even_numbers else -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    For negative numbers, only the first digit of the absolute value is negated, \n    and the rest of the digits remain positive. For example, -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        abs_num = abs(num)\n        sign = -1 if num < 0 else 1\n        digits = [sign * int(str(abs_num)[0])] + [int(d) for d in str(abs_num)[1:]]\n        return sum(digits)\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        str_num = str(abs(n))\n        if n < 0:\n            return int('-' + str_num[0]) + sum((int(digit) for digit in str_num[1:]))\n        return sum((int(digit) for digit in str_num))\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_signed_digits(n: int) -> int:\n        if n < 0:\n            digits = [int(d) for d in str(-n)]\n            digits[0] = -digits[0]\n        else:\n            digits = [int(d) for d in str(n)]\n        return sum(digits)\n    return sum((1 for num in arr if sum_signed_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(num: int) -> int:\n        abs_num = abs(num)\n        digits = [int(str(abs_num)[0]) * (-1 if num < 0 else 1)] + [int(d) for d in str(abs_num)[1:]]\n        return sum(digits)\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(num: int) -> int:\n        digits = list(str(abs(num)))\n        if num < 0:\n            digits[0] = f'-{digits[0]}'\n        return sum((int(d) for d in digits))\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_signed_digits(num: int) -> int:\n        abs_num_str = str(abs(num))\n        signed_digit_values = [-int(abs_num_str[0])] + [int(d) for d in abs_num_str[1:]]\n        return sum(signed_digit_values)\n    return sum((1 for num in arr if sum_of_signed_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def get_signed_sum(n: int) -> int:\n        if n < 0:\n            digits = list(str(abs(n)))\n            signed_digits = [-int(digits[0])] + [int(d) for d in digits[1:]]\n        else:\n            signed_digits = [int(d) for d in str(n)]\n        return sum(signed_digits)\n    return sum((1 for num in arr if get_signed_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_signed_digits(num: int) -> int:\n        if num == 0:\n            return 0\n        num_str = str(num)\n        if num_str[0] == '-':\n            return -int(num_str[1]) + sum((int(digit) for digit in num_str[2:]))\n        else:\n            return sum((int(digit) for digit in num_str))\n    return sum((1 for num in arr if sum_of_signed_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_signed_digits(num: int) -> int:\n        abs_num = abs(num)\n        sum_digits = 0\n        first_digit = True\n        while abs_num > 0:\n            digit = abs_num % 10\n            if first_digit and num < 0:\n                digit = -digit\n                first_digit = False\n            sum_digits += digit\n            abs_num //= 10\n        return sum_digits\n    return sum((1 for num in arr if sum_of_signed_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_signed_digits(num: int) -> int:\n        str_num = str(abs(num))\n        signed_digits = [-int(str_num[0])] + [int(d) for d in str_num[1:]]\n        return sum(signed_digits)\n    return sum((1 for num in arr if sum_of_signed_digits(num) > 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 0.5}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of integers according to the number of ones in their binary representation in ascending order. \n    For non-negative integers, the number of ones is counted directly in their binary representation. \n    For negative integers, the number of ones is counted in their 32-bit binary representation (using a bitwise AND operation with 4294967295).\n    For integers with the same number of ones, sort based on their decimal value in ascending order.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(num):\n        if num >= 0:\n            return bin(num).count('1')\n        else:\n            return bin(num & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_binary_ones(num: int) -> int:\n        if num < 0:\n            return bin(num & 4294967295).count('1')\n        return bin(num).count('1')\n    return sorted(arr, key=lambda x: (count_binary_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        if n >= 0:\n            return bin(n).count('1')\n        else:\n            return bin(n & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def binary_ones_count(x: int) -> int:\n        if x >= 0:\n            return bin(x).count('1')\n        return bin(x & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (binary_ones_count(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(num: int) -> int:\n        if num >= 0:\n            return bin(num).count('1')\n        else:\n            return bin(num & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones_in_binary(num: int) -> int:\n        if num < 0:\n            num = num & 4294967295\n        return bin(num).count('1')\n    return sorted(arr, key=lambda x: (count_ones_in_binary(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(num: int) -> int:\n        if num >= 0:\n            return bin(num).count('1')\n        else:\n            return bin(num & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x & 4294967295).count('1') if x < 0 else bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(num):\n        if num < 0:\n            return bin(num & 4294967295).count('1')\n        return bin(num).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        if x >= 0:\n            return bin(x).count('1')\n        else:\n            return bin(x & 4294967295).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "HumanEval/120", "requirement": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array arr of integers and a non-negative integer k, return a sorted list \n    of length k containing the maximum k numbers from arr. The list should be sorted \n    in ascending order. If k is 0, return an empty list.\n\n    The function first selects the maximum k numbers from arr, then sorts these selected \n    numbers in ascending order to produce the final result.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2, regardless of whether the year is a leap year.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef valid_date(date: str) -> bool:\n    import re\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-([0-9]{4})$'\n    match = re.match(pattern, date)\n    if not match:\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month in {4, 6, 9, 11}:\n        return 1 <= day <= 30\n    elif month == 2:\n        return 1 <= day <= 29\n    else:\n        return 1 <= day <= 31", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date or not isinstance(date, str):\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and (not 1 <= day <= 31):\n        return False\n    elif month in {4, 6, 9, 11} and (not 1 <= day <= 30):\n        return False\n    elif month == 2 and (not 1 <= day <= 29):\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\\d{4}$'\n    if not re.match(pattern, date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month in [4, 6, 9, 11] and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "from typing import Tuple\n\ndef valid_date(date: str) -> bool:\n    import re\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and (day < 1 or day > 31):\n        return False\n    elif month in {4, 6, 9, 11} and (day < 1 or day > 30):\n        return False\n    elif month == 2 and (day < 1 or day > 29):\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    date_pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\\\\d{4}$'\n    if not re.match(date_pattern, date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month == 2 and (day < 1 or day > 29):\n        return False\n    elif month in {4, 6, 9, 11} and (day < 1 or day > 30):\n        return False\n    elif month in {1, 3, 5, 7, 8, 10, 12} and (day < 1 or day > 31):\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-(\\\\d{4})$'\n    match = re.match(pattern, date)\n    if not match:\n        return False\n    month, day, year = map(int, match.groups())\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    elif month == 2 and day > 29:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[12]\\\\d|3[01])-\\\\d{4}$'\n    match = re.match(pattern, date)\n    if not match:\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month in [4, 6, 9, 11] and day > 30:\n        return False\n    elif month == 2 and day > 29:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-[0-9]{4}$'\n    match = re.match(pattern, date)\n    if not match:\n        return False\n    month, day, _ = map(int, date.split('-'))\n    if month == 2:\n        return 1 <= day <= 29\n    elif month in {4, 6, 9, 11}:\n        return 1 <= day <= 30\n    else:\n        return 1 <= day <= 31", "import re\n\ndef valid_date(date: str) -> bool:\n    pattern = re.compile('^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\\\\d{4}$')\n    if not date or not pattern.match(date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month == 2 and (day < 1 or day > 29):\n        return False\n    if month in [4, 6, 9, 11] and (day < 1 or day > 30):\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12] and (day < 1 or day > 31):\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/125", "requirement": "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on any whitespace (including spaces, tabs, and newlines).\n    If no whitespaces exist in the text, split on commas ','. If no commas exist, return the number of lowercase letters\n    whose position in the alphabet is odd, where 'a' is position 0, 'b' is position 1, ..., 'z' is position 25.\n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_positions = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24}\n        return sum((1 for char in txt if char.islower() and ord(char) - ord('a') in odd_positions))", "from typing import List, Union\nimport string\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_positions = [i for i, ch in enumerate(string.ascii_lowercase) if i % 2 == 0]\n        return sum((1 for ch in txt if ch in string.ascii_lowercase and string.ascii_lowercase.index(ch) in odd_positions))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    import string\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    if ',' in txt:\n        return txt.split(',')\n    odd_position_count = sum((1 for char in txt if char in string.ascii_lowercase and (ord(char) - ord('a')) % 2 != 0))\n    return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 == 1))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 0))\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 == 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_positions = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]\n        return sum((1 for c in txt if c.islower() and ord(c) - ord('a') in odd_positions))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.30000000000000004, "original_passk": 0.8}}
{"task_id": "HumanEval/127", "requirement": "def intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two closed intervals, where each interval is a pair of integers (start, end) with start <= end.\n    The intersection of the two intervals is the set of all integers that are common to both intervals.\n    If the intervals do not intersect, return \"NO\".\n    If they intersect, calculate the length of the intersection as (intersection_end - intersection_start).\n    If the length is a prime number, return \"YES\"; otherwise, return \"NO\".\n    \n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start\n    if is_prime(length):\n        return 'YES'\n    return 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start + 1\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    intersection_start = max(interval1[0], interval2[0])\n    intersection_end = min(interval1[1], interval2[1])\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    length = intersection_end - intersection_start\n    return 'YES' if is_prime(length) else 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a unique value in the range [1, N * N].\n\n    Find the lexicographically smallest path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighboring cells\n    that share an edge with the current cell. The path must consist of exactly k cells,\n    and cells can be revisited. The path must stay within the grid boundaries.\n\n    A path A is considered lexicographically smaller than path B if there exists an index i\n    such that A[i] < B[i] and for all j < i, A[j] = B[j]. It is guaranteed that the answer is unique.\n\n    Return an ordered list of the values on the cells that the lexicographically smallest path visits.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(path, x, y):\n        if len(path) == k:\n            return path\n        lex_min = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = dfs(path + [grid[nx][ny]], nx, ny)\n                if lex_min is None or new_path < lex_min:\n                    lex_min = new_path\n        return lex_min\n    min_path = None\n    for i, j in product(range(N), repeat=2):\n        start_path = dfs([grid[i][j]], i, j)\n        if min_path is None or start_path < min_path:\n            min_path = start_path\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    heap = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(heap, (grid[i][j], [grid[i][j]], i, j))\n    while heap:\n        value, path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(heap, (new_path, new_path, nx, ny))", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, current_path):\n        if len(current_path) == k:\n            paths.append(current_path[:])\n            return\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                dfs(nx, ny, current_path + [grid[nx][ny]])\n    n = len(grid)\n    paths = []\n    for i, j in product(range(n), repeat=2):\n        dfs(i, j, [grid[i][j]])\n    return min(paths)", "from typing import List\nimport itertools\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(list(path))\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    paths = []\n    for i, j in itertools.product(range(N), repeat=2):\n        dfs(i, j, [grid[i][j]])\n    paths.sort()\n    return paths[0]", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            candidate_paths.append(path)\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    N = len(grid)\n    candidate_paths = []\n    for start_x, start_y in product(range(N), repeat=2):\n        dfs(start_x, start_y, [grid[start_x][start_y]])\n    return min(candidate_paths)", "from typing import List\nimport itertools\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]):\n                yield (x + dx, y + dy)\n\n    def dfs(path, x, y):\n        if len(path) == k:\n            heapq.heappush(res, path[:])\n            return\n        for nx, ny in sorted(neighbors(x, y), key=lambda p: grid[p[0]][p[1]]):\n            dfs(path + [grid[nx][ny]], nx, ny)\n    res = []\n    positions = sorted(itertools.product(range(len(grid)), range(len(grid[0]))), key=lambda p: grid[p[0]][p[1]])\n    for x, y in positions:\n        dfs([grid[x][y]], x, y)\n        if res:\n            break\n    return heapq.nsmallest(1, res)[0]", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                yield (nx, ny)\n    n = len(grid)\n    pq = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(pq, (grid[i][j], i, j, [grid[i][j]]))\n    while pq:\n        value, x, y, path = heapq.heappop(pq)\n        if len(path) == k:\n            return path\n        for nx, ny in neighbors(x, y):\n            heapq.heappush(pq, (grid[nx][ny], nx, ny, path + [grid[nx][ny]]))", "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n\n    def dfs(path, x, y):\n        if len(path) == k:\n            return path\n        next_cells = []\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if is_valid(nx, ny):\n                next_cells.append((grid[nx][ny], nx, ny))\n        next_cells.sort()\n        for value, nx, ny in next_cells:\n            result = dfs(path + [value], nx, ny)\n            if result:\n                return result\n        return None\n    smallest_path = None\n    for i, j in product(range(N), range(N)):\n        current_path = dfs([grid[i][j]], i, j)\n        if smallest_path is None or current_path < smallest_path:\n            smallest_path = current_path\n    return smallest_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from heapq import heappush, heappop\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heappush(heap, (grid[i][j], [(i, j)]))\n    while heap:\n        _, path = heappop(heap)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        last_x, last_y = path[-1]\n        for dx, dy in directions:\n            nx, ny = (last_x + dx, last_y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                heappush(heap, (grid[nx][ny], path + [(nx, ny)]))", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from itertools import product\n    from heapq import heappush, heappop\n\n    def neighbors(r, c):\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = (r + dr, c + dc)\n            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):\n                yield (nr, nc)\n\n    def dfs(path, r, c):\n        if len(path) == k:\n            heappush(valid_paths, tuple(path))\n            return\n        for nr, nc in neighbors(r, c):\n            dfs(path + [grid[nr][nc]], nr, nc)\n    valid_paths = []\n    for r, c in product(range(len(grid)), range(len(grid[0]))):\n        dfs([grid[r][c]], r, c)\n    return list(heappop(valid_paths))"], "result": {"repaired_passk": 0.5, "cross_model_passk": 0.7, "original_passk": 0.0}}
{"task_id": "HumanEval/130", "requirement": "def tri(n: int) -> List[float]:\n    \"\"\"Generate the first n + 1 numbers of a custom sequence defined as follows:\n    - tri(0) = 1\n    - tri(1) = 3\n    - For even n > 1, tri(n) = 1 + n / 2\n    - For odd n > 1, tri(n) = tri(n - 1) + tri(n - 2) + (1 + (n + 1) / 2 if (n + 1) is even else tri(n + 1))\n    \n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(x: int) -> float:\n        if x == 0:\n            return 1\n        elif x == 1:\n            return 3\n        elif x % 2 == 0:\n            return 1 + x / 2\n        else:\n            return compute_tri(x - 1) + compute_tri(x - 2) + (1 + (x + 1) / 2 if (x + 1) % 2 == 0 else compute_tri(x + 1))\n    return [compute_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tri_value(i: int) -> float:\n        if i == 0:\n            return 1\n        elif i == 1:\n            return 3\n        elif i % 2 == 0:\n            return 1 + i / 2\n        else:\n            next_value = 1 + (i + 1) / 2 if (i + 1) % 2 == 0 else tri_value(i + 1)\n            return tri_value(i - 1) + tri_value(i - 2) + next_value\n    return [tri_value(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = []\n    for i in range(n + 1):\n        if i == 0:\n            sequence.append(1)\n        elif i == 1:\n            sequence.append(3)\n        elif i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_val = sequence[-1] + sequence[-2]\n            term = 1 + (i + 1) / 2 if (i + 1) % 2 == 0 else sequence[-1]\n            sequence.append(next_val + term)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_value(m: int) -> float:\n        if m == 0:\n            return 1\n        if m == 1:\n            return 3\n        if m > 1 and m % 2 == 0:\n            return 1 + m / 2\n        if m > 1 and m % 2 != 0:\n            next_term = 1 + (m + 1) / 2 if (m + 1) % 2 == 0 else compute_value(m + 1)\n            return compute_value(m - 1) + compute_value(m - 2) + next_term\n    return [compute_value(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_sequence(k: int) -> float:\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k % 2 == 0:\n            return 1 + k / 2\n        elif (k + 1) % 2 == 0:\n            even_term = 1 + (k + 1) / 2\n            return compute_sequence(k - 1) + compute_sequence(k - 2) + even_term\n        else:\n            next_term = compute_sequence(k + 1)\n            return compute_sequence(k - 1) + compute_sequence(k - 2) + next_term\n    return [compute_sequence(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def custom_sequence(num: int) -> float:\n        if num == 0:\n            return 1\n        elif num == 1:\n            return 3\n        elif num % 2 == 0:\n            return 1 + num / 2\n        else:\n            next_term = 1 + (num + 1) / 2 if (num + 1) % 2 == 0 else custom_sequence(num + 1)\n            return custom_sequence(num - 1) + custom_sequence(num - 2) + next_term\n    return [custom_sequence(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(k: int) -> float:\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return compute_tri(k - 1) + compute_tri(k - 2) + (1 + (k + 1) / 2 if (k + 1) % 2 == 0 else compute_tri(k + 1))\n    return [compute_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(value: int):\n        if value == 0:\n            return 1\n        elif value == 1:\n            return 3\n        elif value % 2 == 0:\n            return 1 + value / 2\n        else:\n            next_value = compute_tri(value + 1) if (value + 1) % 2 != 0 else 1 + (value + 1) / 2\n            return compute_tri(value - 1) + compute_tri(value - 2) + next_value\n    sequence = [compute_tri(i) for i in range(n + 1)]\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2] + (1 + (i + 1) / 2 if (i + 1) % 2 == 0 else sequence[i + 1])\n            sequence.append(next_value)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(k: int) -> float:\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            next_term = 1 + (k + 1) / 2 if (k + 1) % 2 == 0 else compute_tri(k + 1)\n            return compute_tri(k - 1) + compute_tri(k - 2) + next_term\n    return [compute_tri(i) for i in range(n + 1)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.11111111111111116}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is at least one pair of square brackets \n    that is nested within another pair of square brackets. A pair of brackets is considered nested \n    if there is at least one '[' that is closed by a ']' and there is another '[' in between them.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if '[' in stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if len(stack) > 1:\n                return True\n            elif stack:\n                stack.pop()\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append('[')\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_flag = False\n    for char in string:\n        if char == '[':\n            stack.append('[')\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_flag = True\n    return nested_flag", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_found = True\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack and '[' in stack:\n                    return True\n            else:\n                return False\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append('[')\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append('[')\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if len(stack) > 0:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n            if stack:\n                return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/140", "requirement": "def fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, replace all single spaces with underscores, \n    and replace sequences of three or more consecutive spaces with a single '-'.\n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"", "generated_programs": ["import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('\\\\s', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    return re.sub(' {3,}', '-', re.sub('(?<! ) ', '_', text))", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.6, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(num: int) -> int:\n        return sum((abs(int(d)) for d in str(num) if d.isdigit()))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n):\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/153", "requirement": "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is calculated as the difference between the number\n    of uppercase letters (CAP) and the number of lowercase letters (SM) in the\n    extension's name, i.e., strength = CAP - SM. You should find the strongest\n    extension and return a string in this format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that appears first in the list.\n    The function assumes that the list of extensions is non-empty. If an empty list\n    is provided, the function will raise an IndexError.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for c in extension if c.isupper()))\n        sm = sum((1 for c in extension if c.islower()))\n        return cap - sm\n    strongest_extension = extensions[0]\n    max_strength = calculate_strength(strongest_extension)\n    for extension in extensions[1:]:\n        strength = calculate_strength(extension)\n        if strength > max_strength:\n            strongest_extension = extension\n            max_strength = strength\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        upper_count = sum((1 for char in extension if char.isupper()))\n        lower_count = sum((1 for char in extension if char.islower()))\n        return upper_count - lower_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    strongest_extension = extensions[0]\n    max_strength = sum((1 for char in strongest_extension if char.isupper())) - sum((1 for char in strongest_extension if char.islower()))\n    for extension in extensions[1:]:\n        strength = sum((1 for char in extension if char.isupper())) - sum((1 for char in extension if char.islower()))\n        if strength > max_strength:\n            strongest_extension = extension\n            max_strength = strength\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        return sum((1 for c in extension if c.isupper())) - sum((1 for c in extension if c.islower()))\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        upper_count = sum((1 for char in extension if char.isupper()))\n        lower_count = sum((1 for char in extension if char.islower()))\n        return upper_count - lower_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def extension_strength(extension: str) -> int:\n        cap_count = sum((1 for char in extension if char.isupper()))\n        sm_count = sum((1 for char in extension if char.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=extension_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    strongest_extension = extensions[0]\n    max_strength = sum((1 for c in extensions[0] if c.isupper())) - sum((1 for c in extensions[0] if c.islower()))\n    for extension in extensions[1:]:\n        strength = sum((1 for c in extension if c.isupper())) - sum((1 for c in extension if c.islower()))\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def compute_strength(extension: str) -> int:\n        uppercase_count = sum((1 for char in extension if char.isupper()))\n        lowercase_count = sum((1 for char in extension if char.islower()))\n        return uppercase_count - lowercase_count\n    strongest_extension = max(extensions, key=compute_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def extension_strength(extension: str) -> int:\n        return sum((1 for c in extension if c.isupper())) - sum((1 for c in extension if c.islower()))\n    strongest_extension = max(extensions, key=extension_strength)\n    return f'{class_name}.{strongest_extension}'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if the second word is empty or if any of its rotations is a substring in the first word.\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotated_strings = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotated_strings))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    for i in range(len(b)):\n        rotated_b = b[i:] + b[:i]\n        if rotated_b in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    for i in range(len(b)):\n        rotated_b = b[i:] + b[:i]\n        if rotated_b in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    for i in range(len(b)):\n        rotated_b = b[i:] + b[:i]\n        if rotated_b in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    for i in range(len(b)):\n        rotated_b = b[i:] + b[:i]\n        if rotated_b in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rot in a for rot in rotations))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/160", "requirement": "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists operator, and operand. The first list contains basic algebra operations, and \n    the second list is a list of integers. Construct the algebraic expression by combining the \n    operators and operands in the order they appear, and evaluate the expression respecting the \n    standard order of operations (PEMDAS/BODMAS). Return the result of the evaluation.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i in range(len(operator)):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''.join((str(operand[i]) + operator[i] if i < len(operator) else str(operand[i]) for i in range(len(operand))))\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i in range(len(operator)):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i in range(len(operator)):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i in range(len(operator)):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    return eval(expression)", "from typing import List\nimport operator\nimport ast\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expr = str(operands[0])\n    for op, num in zip(operators, operands[1:]):\n        expr += f' {op} {num}'\n    return eval(expr)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i in range(len(operand)):\n        expression += str(operand[i])\n        if i < len(operator):\n            expression += operator[i]\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''.join((str(operand[i]) + operator[i] for i in range(len(operator)))) + str(operand[-1])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i in range(len(operator)):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    return eval(expression)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "def generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return a list of integers between the smaller and larger of a and b (inclusive) \n    where all digits of the integer are even. The list should be in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start = min(a, b)\n    end = max(a, b)\n    return [n for n in range(start, end + 1) if all_digits_even(n)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if is_all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start = min(a, b)\n    end = max(a, b)\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    lower, upper = (min(a, b), max(a, b))\n    return [num for num in range(lower, upper + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(number: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(number)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/1", "requirement": "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \n    Input to this function is a string containing multiple groups of nested parentheses. \n    The function separates these groups into individual balanced parentheses strings and returns them as a list. \n    Each group is balanced (each opening parenthesis is properly closed) and not nested within any other group. \n    Spaces in the input string are ignored and should not be included in the output.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    group = ''\n    balance = 0\n    for char in paren_string:\n        group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and group:\n            groups.append(group)\n            group = ''\n    return groups", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    group = ''\n    balance = 0\n    for char in paren_string:\n        group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and group:\n            result.append(group)\n            group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    balance = 0\n    current_group = ''\n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and current_group:\n            groups.append(current_group)\n            current_group = ''\n    return groups", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    group = ''\n    balance = 0\n    for char in paren_string.replace(' ', ''):\n        group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and group:\n            result.append(group)\n            group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    current_group = ''\n    balance = 0\n    for char in paren_string:\n        if char == '(':\n            balance += 1\n            current_group += char\n        elif char == ')':\n            balance -= 1\n            current_group += char\n        if balance == 0 and current_group:\n            result.append(current_group)\n            current_group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    current_group = ''\n    stack = 0\n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            stack += 1\n        elif char == ')':\n            stack -= 1\n            if stack == 0:\n                groups.append(current_group)\n                current_group = ''\n    return groups", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    balance = 0\n    current_group = []\n    for char in paren_string:\n        current_group.append(char)\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and current_group:\n            groups.append(''.join(current_group))\n            current_group = []\n    return groups", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    group = ''\n    balance = 0\n    for char in paren_string:\n        group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0:\n            result.append(group)\n            group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    group = ''\n    balance = 0\n    for char in paren_string:\n        group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and group:\n            result.append(group)\n            group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    balance = 0\n    current_group = []\n    for char in paren_string:\n        current_group.append(char)\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0:\n            groups.append(''.join(current_group))\n            current_group = []\n    return groups"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/10", "requirement": "def make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that begins with the supplied string by appending the reverse of the prefix before the longest palindromic suffix.\n    \n    The function works as follows:\n    - It iterates through the string to find the longest palindromic suffix starting at each index.\n    - Once the longest palindromic suffix is found, it appends the reverse of the prefix that precedes this suffix to the end of the string.\n    - This ensures the resulting string is the shortest possible palindrome that begins with the supplied string.\n    \n    Examples:\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    n = len(string)\n    if n == 0 or is_palindrome(string):\n        return string\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            prefix = string[:i]\n            return prefix[::-1] + string\n    return string[::-1] + string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[::-1]", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string[::-1]", "def make_palindrome(string: str) -> str:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            prefix = string[:i][::-1]\n            return string + prefix\n    return string"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8888888888888888, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/11", "requirement": "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s. The strings can be of different lengths.\n    Perform binary XOR on the corresponding characters of these inputs and return the result as a string.\n    If the strings are of different lengths, only the overlapping part is considered, and the rest is ignored.\n    >>> string_xor('010', '110')\n    '100'\n    >>> string_xor('101', '11')\n    '01'\n    \"\"\"", "generated_programs": ["def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(a[i]) ^ int(b[i])) for i in range(min(len(a), len(b)))))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(a[i]) ^ int(b[i])) for i in range(min(len(a), len(b)))))", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join(('1' if x != y else '0' for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/13", "requirement": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b. The result is always non-negative, regardless of the signs of the inputs.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(6, -4)\n    2\n    \"\"\"", "generated_programs": ["import math\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return math.gcd(a, b)", "import math\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(math.gcd(a, b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))", "import math\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return math.gcd(a, b)", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))", "import math\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return math.gcd(abs(a), abs(b))", "import math\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return math.gcd(abs(a), abs(b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(abs(a), abs(b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(abs(a), abs(b))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/32", "requirement": "from typing import List\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))"], "result": {"repaired_passk": 0.30000000000000004, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/43", "requirement": "from typing import List\n\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list (at different positions) that\n    sum to zero, and False otherwise. This includes the case where both elements are zero.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    s = set()\n    for num in l:\n        if -num in s:\n            return True\n        s.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2.0\n    else:\n        return float(l_sorted[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    if n % 2 == 1:\n        return sorted_list[n // 2]\n    else:\n        return (sorted_list[n // 2 - 1] + sorted_list[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_list[mid - 1] + sorted_list[mid]) / 2\n    else:\n        return float(sorted_list[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l = sorted(l)\n    n = len(l)\n    if n % 2 == 1:\n        return float(l[n // 2])\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/54", "requirement": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words contain exactly the same set of characters, regardless of the frequency or order of the characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"", "generated_programs": ["def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "from typing import Set\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "from typing import Set\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    from collections import Counter\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "from typing import Set\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/67", "requirement": "def fruit_distribution(s: str, n: int) -> int:\n    \"\"\"\n    Given a string `s` that describes the number of apples and oranges in a basket, and an integer `n` \n    representing the total number of fruits in the basket, return the number of mango fruits in the basket.\n    \n    The string `s` will contain the number of apples and oranges in the format \"X apples and Y oranges\", \n    where X and Y are non-negative integers. If either \"apples\" or \"oranges\" is missing from the string, \n    the corresponding count is assumed to be 0.\n    \n    The number of mango fruits is calculated by subtracting the number of apples and oranges from the total \n    number of fruits `n`.\n    \n    Examples:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) -> 8\n    fruit_distribution(\"0 apples and 1 oranges\", 3) -> 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 95\n    fruit_distribution(\"100 apples and 1 oranges\", 120) -> 19\n    \"\"\"", "generated_programs": ["import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - (apples + oranges)", "def fruit_distribution(s: str, n: int) -> int:\n    import re\n    apple_match = re.search('(\\\\d+)\\\\s*apples', s)\n    orange_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(apple_match.group(1)) if apple_match else 0\n    oranges = int(orange_match.group(1)) if orange_match else 0\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples_count = int(apples_match.group(1)) if apples_match else 0\n    oranges_count = int(oranges_match.group(1)) if oranges_match else 0\n    return n - apples_count - oranges_count", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples_count = int(apples_match.group(1)) if apples_match else 0\n    oranges_count = int(oranges_match.group(1)) if oranges_match else 0\n    mango_count = n - (apples_count + oranges_count)\n    return mango_count", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s+apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s+oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - apples - oranges", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples = oranges = 0\n    match_apples = re.search('(\\\\d+)\\\\s*apples', s)\n    if match_apples:\n        apples = int(match_apples.group(1))\n    match_oranges = re.search('(\\\\d+)\\\\s*oranges', s)\n    if match_oranges:\n        oranges = int(match_oranges.group(1))\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s+apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s+oranges', s)\n    apples_count = int(apples_match.group(1)) if apples_match else 0\n    oranges_count = int(oranges_match.group(1)) if oranges_match else 0\n    mangoes_count = n - (apples_count + oranges_count)\n    return mangoes_count", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s+apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s+oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples = oranges = 0\n    apple_match = re.search('(\\\\d+)\\\\s*apples', s)\n    orange_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    if apple_match:\n        apples = int(apple_match.group(1))\n    if orange_match:\n        oranges = int(orange_match.group(1))\n    return n - (apples + oranges)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/76", "requirement": "def is_simple_power(x: int, n: int) -> bool:\n    \"\"\"Your task is to write a function that returns true if a number x is a simple power of n and false in other cases.\n    x is a simple power of n if there exists a non-negative integer k such that n^k = x.\n    The function assumes that x and n are positive integers.\n    Special cases:\n    - If n is 1, the function returns true only if x is also 1.\n    - If x is 0, the function returns false.\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"", "generated_programs": ["def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    k = 0\n    current_power = 1\n    while current_power < x:\n        current_power *= n\n        k += 1\n    return current_power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    while x > 1:\n        if x % n != 0:\n            return False\n        x //= n\n    return x == 1", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x < 1:\n        return False\n    while x % n == 0:\n        x //= n\n    return x == 1", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    k = 0\n    power = 1\n    while power < x:\n        k += 1\n        power = n ** k\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    k = 0\n    power = 1\n    while power < x:\n        power = n ** k\n        if power == x:\n            return True\n        k += 1\n    return False", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    k = 0\n    power = 1\n    while power < x:\n        power *= n\n        k += 1\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    k = 0\n    current_power = 1\n    while current_power < x:\n        current_power = n ** k\n        k += 1\n    return current_power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0:\n        return False\n    current = 1\n    while current <= x:\n        if current == x:\n            return True\n        current *= n\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    '''\n    Write a function that takes an integer a and returns True \n    if this integer is a perfect cube of some integer number, \n    considering both positive and negative inputs. \n    The function should correctly handle edge cases such as zero and negative numbers.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    root = round(abs(a) ** (1 / 3))\n    return root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    root = round(abs(a) ** (1 / 3))\n    return root ** 3 == abs(a)", "def iscube(a: int) -> bool:\n    import math\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    root = round(abs(a) ** (1 / 3))\n    return root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(abs(a) ** (1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        cube_root = round(-math.pow(-a, 1 / 3))\n    else:\n        cube_root = round(math.pow(a, 1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cubic_root = round(a ** (1 / 3))\n    return cubic_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    return round(abs(a) ** (1 / 3)) ** 3 == abs(a)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.6}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start with 1, end with 1, or both. \n    Specifically, for n = 1, the count should be 1 since the only 1-digit number is 1 itself.\n    \n    The count is calculated by adding the numbers that start with 1 and the numbers that end with 1,\n    then subtracting the overlap (numbers that both start and end with 1) to avoid double-counting.\n    For n > 1, the formula used is: 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2).\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function `encrypt` that takes a string as an argument and returns a new string where each lowercase letter is shifted by 4 positions in the alphabet. The shift wraps around the alphabet, so 'z' becomes 'd'. Non-lowercase characters, including uppercase letters, remain unchanged.\n\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    encrypt('z') returns 'd'\n    encrypt('ABCDEF') returns 'ABCDEF'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_letter(letter: str) -> str:\n        if 'a' <= letter <= 'z':\n            return chr((ord(letter) - ord('a') + 4) % 26 + ord('a'))\n        return letter\n    return ''.join((shift_letter(char) for char in s))", "def encrypt(s: str) -> str:\n    from string import ascii_lowercase\n\n    def shift_char(c: str) -> str:\n        if c in ascii_lowercase:\n            new_index = (ascii_lowercase.index(c) + 4) % 26\n            return ascii_lowercase[new_index]\n        return c\n    return ''.join((shift_char(c) for c in s))", "def encrypt(s: str) -> str:\n    return ''.join((chr((ord(c) - ord('a') + 4) % 26 + ord('a')) if 'a' <= c <= 'z' else c for c in s))", "def encrypt(s: str) -> str:\n\n    def shift_character(ch):\n        if 'a' <= ch <= 'z':\n            return chr((ord(ch) - ord('a') + 4) % 26 + ord('a'))\n        return ch\n    return ''.join((shift_character(ch) for ch in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((shift_char(char) for char in s))", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n    shifted = ''\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted += chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        else:\n            shifted += char\n    return shifted", "def encrypt(s: str) -> str:\n\n    def shift_letter(letter: str) -> str:\n        if 'a' <= letter <= 'z':\n            return chr((ord(letter) - ord('a') + 4) % 26 + ord('a'))\n        return letter\n    return ''.join((shift_letter(char) for char in s))", "def encrypt(s: str) -> str:\n\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((shift_char(c) for c in s))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\" as the first word, \n    where words are separated by spaces. Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"", "generated_programs": ["import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I ')))\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I')))\n    return boredom_count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.?!]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I')))\n    return boredom_count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.!?]', S)\n    boredom_count = sum((1 for sentence in sentences if sentence.strip().startswith('I')))\n    return boredom_count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    boredoms_count = sum((sentence.strip().startswith('I') for sentence in sentences))\n    return boredoms_count", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.?!]', S)\n    sentences = [sentence.strip() for sentence in sentences]\n    boredom_count = sum((1 for sentence in sentences if sentence.startswith('I ')))\n    return boredom_count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message, and encodes it by swapping the case of all letters. \n    For vowels (both lowercase and uppercase), replace each vowel with the letter that appears \n    2 places ahead of that vowel in the English alphabet. If the replacement character goes \n    beyond 'z' or 'Z', wrap around to the beginning of the alphabet. The case of the replacement \n    character should be the opposite of the original vowel. Non-vowel characters should only \n    have their case swapped. Assume the input contains only letters.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["import string\n\ndef encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        vowels_lower = 'aeiou'\n        vowels_upper = 'AEIOU'\n        if vowel in vowels_lower:\n            index = vowels_lower.index(vowel)\n            shifted = vowels_lower[(index + 2) % len(vowels_lower)]\n            return shifted.upper()\n        elif vowel in vowels_upper:\n            index = vowels_upper.index(vowel)\n            shifted = vowels_upper[(index + 2) % len(vowels_upper)]\n            return shifted.lower()\n        return vowel\n\n    def swap_case_and_vowel(char: str) -> str:\n        if char.lower() in 'aeiou':\n            return shift_vowel(char)\n        else:\n            return char.swapcase()\n    return ''.join((swap_case_and_vowel(char) for char in message))", "def encode(message: str) -> str:\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n    for char in message:\n        if char in vowels:\n            if char.islower():\n                mapped_char = chr((ord(char) - ord('a') + 2) % 26 + ord('a'))\n                encoded_message.append(mapped_char.upper())\n            else:\n                mapped_char = chr((ord(char) - ord('A') + 2) % 26 + ord('A'))\n                encoded_message.append(mapped_char.lower())\n        elif char.islower():\n            encoded_message.append(char.upper())\n        else:\n            encoded_message.append(char.lower())\n    return ''.join(encoded_message)", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        vowels = 'aeiou'\n        upper_vowels = 'AEIOU'\n        if vowel in vowels:\n            shifted = chr((ord(vowel) - ord('a') + 2) % 26 + ord('a'))\n            return shifted.upper()\n        elif vowel in upper_vowels:\n            shifted = chr((ord(vowel) - ord('A') + 2) % 26 + ord('A'))\n            return shifted.lower()\n        return vowel\n    result = []\n    for char in message:\n        if char.lower() in 'aeiou':\n            result.append(shift_vowel(char))\n        else:\n            result.append(char.upper() if char.islower() else char.lower())\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def get_replacement(char: str, is_upper: bool) -> str:\n        vowels = 'aeiou'\n        vowels_upper = vowels.upper()\n        if char.lower() in vowels:\n            index = vowels.index(char.lower())\n            new_char = vowels[(index + 2) % len(vowels)]\n            return new_char.upper() if not is_upper else new_char.lower()\n        return char\n    result = []\n    for char in message:\n        if char.isalpha():\n            is_upper = char.isupper()\n            swapped_case = char.lower() if is_upper else char.upper()\n            if char.lower() in 'aeiou':\n                result.append(get_replacement(char, is_upper))\n            else:\n                result.append(swapped_case)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def replace_vowel(char: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if char in vowels:\n            offset = 2\n            if char.islower():\n                replacement = chr((ord(char) - ord('a') + offset) % 26 + ord('a'))\n                return replacement.upper()\n            else:\n                replacement = chr((ord(char) - ord('A') + offset) % 26 + ord('A'))\n                return replacement.lower()\n        else:\n            return char.swapcase()\n    return ''.join((replace_vowel(char) for char in message))", "def encode(message: str) -> str:\n\n    def swap_case_and_transform_vowel(ch: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if ch in vowels:\n            base = 'a' if ch.islower() else 'A'\n            shift = 2\n            transformed = chr((ord(ch.lower()) - ord(base) + shift) % 26 + ord(base))\n            return transformed.upper() if ch.islower() else transformed.lower()\n        else:\n            return ch.swapcase()\n    return ''.join((swap_case_and_transform_vowel(ch) for ch in message))", "def encode(message: str) -> str:\n\n    def is_vowel(ch):\n        return ch.lower() in 'aeiou'\n\n    def shift_vowel(vowel):\n        shift = 2\n        if vowel.islower():\n            new_char = chr((ord(vowel) - ord('a') + shift) % 26 + ord('a'))\n            return new_char.upper()\n        else:\n            new_char = chr((ord(vowel) - ord('A') + shift) % 26 + ord('A'))\n            return new_char.lower()\n\n    def swap_case(ch):\n        return ch.lower() if ch.isupper() else ch.upper()\n    encoded_message = ''\n    for char in message:\n        if is_vowel(char):\n            encoded_message += shift_vowel(char)\n        else:\n            encoded_message += swap_case(char)\n    return encoded_message", "def encode(message: str) -> str:\n\n    def swap_case(char):\n        return char.lower() if char.isupper() else char.upper()\n\n    def shift_vowel(vowel):\n        shift = 2\n        if vowel in 'aeiou':\n            shifted = chr((ord(vowel) - ord('a') + shift) % 26 + ord('a'))\n            return shifted.upper()\n        elif vowel in 'AEIOU':\n            shifted = chr((ord(vowel) - ord('A') + shift) % 26 + ord('A'))\n            return shifted.lower()\n        return vowel\n    result = []\n    for char in message:\n        if char.lower() in 'aeiou':\n            result.append(shift_vowel(char))\n        else:\n            result.append(swap_case(char))\n    return ''.join(result)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.625, "original_passk": 0.4}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a non-negative integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is determined by adding 2 to the current number of stones,\n    regardless of whether the current number is odd or even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n    If n is 0, return an empty list.\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(0)\n    []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    if n == 0:\n        return []\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/101", "requirement": "from typing import List\n\n\ndef words_string(s: str) -> List[str]:\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words. Leading and trailing\n    whitespace should be stripped before processing, and multiple consecutive commas or spaces\n    should be treated as a single delimiter. If the stripped string is empty, return an empty list.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"", "generated_programs": ["from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    stripped_string = s.strip()\n    if not stripped_string:\n        return []\n    return re.split('[,\\\\s]+', stripped_string)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if s == '':\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[ ,]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    words = re.split('[,\\\\s]+', s)\n    return words if words != [''] else []", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)", "from typing import List\nimport re\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return re.split('[,\\\\s]+', s)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/102", "requirement": "def choose_num(x: int, y: int) -> int:\n    \"\"\"This function takes two positive integers x and y and returns the largest even integer within the range [x, y] inclusive. If x is greater than y, or if there are no even numbers in the range, the function returns -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"", "generated_programs": ["def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "from typing import Optional\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = None\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even if largest_even is not None else -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = max(largest_even, num)\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    even_numbers = [n for n in range(x, y + 1) if n % 2 == 0]\n    return max(even_numbers) if even_numbers else -1"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    For negative numbers, only the first digit is considered negative when summing the digits.\n    For example, -123 has signed digits -1, 2, and 3, and their sum is -1 + 2 + 3 = 4.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        if n < 0:\n            str_n = str(n)\n            return sum((int(c) for c in str_n[1:])) - int(str_n[0])\n        return sum((int(c) for c in str(n)))\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        if n == 0:\n            return 0\n        if n < 0:\n            n = abs(n)\n            first_digit = -int(str(n)[0])\n            remaining_digits_sum = sum((int(d) for d in str(n)[1:]))\n            return first_digit + remaining_digits_sum\n        return sum((int(d) for d in str(n)))\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        sum_digits = 0\n        first_digit_negative = True if n < 0 else False\n        n = abs(n)\n        while n > 0:\n            sum_digits += n % 10\n            n //= 10\n        if first_digit_negative:\n            sum_digits -= 2 * (sum_digits % 10)\n        return sum_digits\n    return sum((1 for x in arr if digit_sum(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(num: int) -> int:\n        digits = str(abs(num))\n        sum_of_digits = sum((int(digit) for digit in digits))\n        return sum_of_digits + (-1 if num < 0 else 0)\n    return sum((1 for number in arr if digit_sum(number) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        sum = 0\n        is_negative = num < 0\n        num = abs(num)\n        while num > 0:\n            sum += num % 10\n            num //= 10\n        return -sum if is_negative else sum\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef sum_of_digits(n: int) -> int:\n    n_str = str(n)\n    if n_str[0] == '-':\n        return -int(n_str[1]) + sum((int(digit) for digit in n_str[2:]))\n    else:\n        return sum((int(digit) for digit in n_str))\n\ndef count_nums(arr: List[int]) -> int:\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        if n < 0:\n            n = -n\n            return -int(str(n)[0]) + sum((int(d) for d in str(n)[1:]))\n        else:\n            return sum((int(d) for d in str(n)))\n    return sum((1 for x in arr if digit_sum(x) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(n: int) -> int:\n        n_str = str(n)\n        if n_str[0] == '-':\n            return int(n_str[0] + n_str[1]) + sum((int(d) for d in n_str[2:]))\n        else:\n            return sum((int(d) for d in n_str))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(num: int) -> int:\n        s = 0\n        if num < 0:\n            s += int(str(num)[0])\n            num = str(num)[1:]\n        for digit in str(num):\n            s += int(digit)\n        return s\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(n: int) -> int:\n        if n == 0:\n            return 0\n        n_str = str(n)\n        if n_str[0] == '-':\n            return -int(n_str[0]) + sum((int(d) for d in n_str[1:]))\n        else:\n            return sum((int(d) for d in n_str))\n    return sum((1 for num in arr if digit_sum(num) > 0))"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.4, "original_passk": 0.5}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sorts an array of integers based on the number of ones in their binary representation in ascending order.\n    For negative numbers, the bitwise NOT of the number is used to count the number of ones.\n    For similar number of ones, the elements are sorted based on their decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(~x if x < 0 else x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def bit_count(num: int) -> int:\n        if num < 0:\n            return bin(~num).count('1')\n        return bin(num).count('1')\n    return sorted(arr, key=lambda x: (bit_count(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        if x < 0:\n            return bin(~x & (1 << x.bit_length()) - 1).count('1')\n        else:\n            return bin(x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def ones_count(n: int) -> int:\n        if n >= 0:\n            return bin(n).count('1')\n        else:\n            return bin(~n).count('1')\n    return sorted(arr, key=lambda x: (ones_count(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def number_of_ones(n: int) -> int:\n        if n >= 0:\n            return bin(n).count('1')\n        else:\n            return bin(~n).count('1')\n    return sorted(arr, key=lambda x: (number_of_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        if n < 0:\n            return bin(~n).count('1')\n        return bin(n).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x & 4294967295).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(n: int) -> int:\n        if n >= 0:\n            return bin(n).count('1')\n        else:\n            return bin(~n).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n\n    def count_ones(x: int) -> int:\n        if x < 0:\n            x = ~x\n        return bin(x).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.7}}
{"task_id": "HumanEval/120", "requirement": "from typing import List\n\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array arr of integers and a non-negative integer k, return a sorted list \n    of length k containing the maximum k numbers from arr in ascending order. \n    If k is 0, return an empty list.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2, regardless of whether the year is a leap year.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["import re\n\ndef valid_date(date: str) -> bool:\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\\\\d{4}$'\n    if not date or not re.match(pattern, date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    elif month == 2 and day > 29:\n        return False\n    elif day > 31:\n        return False\n    return True", "from typing import Optional\n\ndef valid_date(date: str) -> bool:\n    from datetime import datetime\n    if not date:\n        return False\n    try:\n        date_obj = datetime.strptime(date, '%m-%d-%Y')\n    except ValueError:\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and (not 1 <= day <= 31):\n        return False\n    elif month in {4, 6, 9, 11} and (not 1 <= day <= 30):\n        return False\n    elif month == 2 and (not 1 <= day <= 29):\n        return False\n    return True", "from datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    try:\n        parts = date.split('-')\n        if len(parts) != 3:\n            return False\n        month, day, year = map(int, parts)\n        if month < 1 or month > 12:\n            return False\n        if day < 1 or day > 31:\n            return False\n        if month in {4, 6, 9, 11} and day > 30:\n            return False\n        if month == 2 and day > 29:\n            return False\n        datetime(year, month, day)\n        return True\n    except ValueError:\n        return False", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    date_pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-([0-9]{4})$'\n    match = re.match(date_pattern, date)\n    if not match:\n        return False\n    month, day, year = map(int, match.groups())\n    if month in [4, 6, 9, 11] and day > 30:\n        return False\n    elif month == 2 and day > 29:\n        return False\n    elif month in [1, 3, 5, 7, 8, 10, 12] and day > 31:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    match = re.match('^(\\\\d{2})-(\\\\d{2})-(\\\\d{4})$', date)\n    if not match:\n        return False\n    month, day, year = map(int, match.groups())\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    match = re.match('^(\\\\d{2})-(\\\\d{2})-(\\\\d{4})$', date)\n    if not match:\n        return False\n    month, day, year = map(int, match.groups())\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and (day < 1 or day > 31):\n        return False\n    elif month in {4, 6, 9, 11} and (day < 1 or day > 30):\n        return False\n    elif month == 2 and (day < 1 or day > 29):\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-(\\\\d{4})$'\n    match = re.match(pattern, date)\n    if not match:\n        return False\n    month, day, year = (int(match.group(1)), int(match.group(2)), int(match.group(3)))\n    if month in [4, 6, 9, 11]:\n        return day <= 30\n    elif month == 2:\n        return day <= 29\n    else:\n        return day <= 31", "from typing import Tuple\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12} and day > 31:\n        return False\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    if month == 2 and day > 29:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    date_pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\\d{4}$'\n    if not re.match(date_pattern, date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month in {4, 6, 9, 11}:\n        if day > 30:\n            return False\n    elif month == 2:\n        if day > 29:\n            return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date or not isinstance(date, str):\n        return False\n    match = re.match('^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$', date)\n    if not match:\n        return False\n    month, day, year = map(int, match.groups())\n    max_days = {1: 31, 3: 31, 5: 31, 7: 31, 8: 31, 10: 31, 12: 31, 4: 30, 6: 30, 9: 30, 11: 30, 2: 29}\n    if day < 1 or day > max_days.get(month, 0):\n        return False\n    return True"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/125", "requirement": "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on spaces (' '), if no spaces exist in the text you\n    should split on commas (','). If neither spaces nor commas exist, return the number of lowercase letters with odd positions in the alphabet, where 'a' is position 0, 'b' is position 1, ..., 'z' is position 25. The position of a character is determined by its relative position in the alphabet, calculated as `ord(char) - ord('a')`, and oddness is checked on this relative position. Only lowercase letters are considered; uppercase letters and non-alphabetic characters are ignored.\n\n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_pos_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_pos_count += 1\n        return odd_pos_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_count += 1\n        return odd_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = 0\n        for char in txt:\n            if 'a' <= char <= 'z':\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_position_count += 1\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if 'a' <= char <= 'z':\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    count += 1\n        return count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_count = 0\n        for char in txt:\n            if char.islower():\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_count += 1\n        return odd_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_count = sum(((ord(char) - ord('a')) % 2 == 1 for char in txt if char.islower()))\n        return odd_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_count = 0\n        for char in txt:\n            if 'a' <= char <= 'z':\n                position = ord(char) - ord('a')\n                if position % 2 == 1:\n                    odd_count += 1\n        return odd_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 1))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_position_count = sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 1))\n        return odd_position_count", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_count = 0\n        for char in txt:\n            if char.islower():\n                pos = ord(char) - ord('a')\n                if pos % 2 == 1:\n                    odd_count += 1\n        return odd_count"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.8}}
{"task_id": "HumanEval/127", "requirement": "def intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"You are given two closed intervals, where each interval is a pair of integers (start, end) with start <= end.\n    The intersection of the two intervals is the range [max(start1, start2), min(end1, end2)].\n    If the intervals do not overlap (i.e., max(start1, start2) > min(end1, end2)), return \"NO\".\n    Otherwise, calculate the length of the intersection as (min(end1, end2) - max(start1, start2)).\n    If the length is a prime number, return \"YES\"; otherwise, return \"NO\".\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_max = max(start1, start2)\n    end_min = min(end1, end2)\n    if start_max > end_min:\n        return 'NO'\n    intersection_length = end_min - start_max\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start\n    if is_prime(intersection_length):\n        return 'YES'\n    else:\n        return 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    max_start = max(start1, start2)\n    min_end = min(end1, end2)\n    if max_start > min_end:\n        return 'NO'\n    intersection_length = min_end - max_start\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersection = max(start1, start2)\n    end_intersection = min(end1, end2)\n    if start_intersection > end_intersection:\n        return 'NO'\n    length = end_intersection - start_intersection\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    if intersect_start > intersect_end:\n        return 'NO'\n    intersection_length = intersect_end - intersect_start\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_max = max(start1, start2)\n    end_min = min(end1, end2)\n    if start_max > end_min:\n        return 'NO'\n    length = end_min - start_max\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    max_start = max(start1, start2)\n    min_end = min(end1, end2)\n    if max_start > min_end:\n        return 'NO'\n    intersection_length = min_end - max_start\n    if is_prime(intersection_length):\n        return 'YES'\n    else:\n        return 'NO'", "from typing import Tuple\n\ndef is_prime(number: int) -> bool:\n    if number <= 1:\n        return False\n    if number <= 3:\n        return True\n    if number % 2 == 0 or number % 3 == 0:\n        return False\n    i = 5\n    while i * i <= number:\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    max_start = max(start1, start2)\n    min_end = min(end1, end2)\n    if max_start > min_end:\n        return 'NO'\n    intersection_length = min_end - max_start\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start_intersection = max(start1, start2)\n    end_intersection = min(end1, end2)\n    if start_intersection > end_intersection:\n        return 'NO'\n    length = end_intersection - start_intersection\n    return 'YES' if is_prime(length) else 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.0}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given an N x N grid (N >= 2) where each cell contains a unique integer in the range [1, N * N], \n    find the lexicographically smallest path of length k. A path is a sequence of cells where each \n    consecutive cell is a neighbor (sharing an edge) of the previous cell. The path can start at any \n    cell and may revisit cells. The path's value is the ordered list of values from the cells it visits.\n\n    The path is considered lexicographically smaller if, when comparing the sequences of values, \n    the first differing value is smaller. It is guaranteed that the answer is unique.\n\n    The function uses a depth-first search (DFS) approach to explore all possible paths of length k, \n    starting from each cell in the grid. The DFS ensures that the lexicographically smallest path \n    is found by always choosing the smallest possible next step at each point in the path.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(path: List[Tuple[int, int]]):\n        if len(path) == k:\n            candidate = [grid[x][y] for x, y in path]\n            nonlocal smallest_path\n            if smallest_path is None or candidate < smallest_path:\n                smallest_path = candidate\n            return\n        x, y = path[-1]\n        current_value = grid[x][y]\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                path.append((nx, ny))\n                dfs(path)\n                path.pop()\n    smallest_path = None\n    for i in range(n):\n        for j in range(n):\n            dfs([(i, j)])\n    return smallest_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(list(path))\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    paths = []\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            dfs(i, j, [grid[i][j]])\n    return min(paths)", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            return path[:]\n        neighbors = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):\n                neighbors.append((grid[nx][ny], nx, ny))\n        neighbors.sort()\n        for val, nx, ny in neighbors:\n            result = dfs(nx, ny, path + [val])\n            if result:\n                return result\n        return None\n    n = len(grid)\n    min_path = None\n    for i in range(n):\n        for j in range(n):\n            start_value = grid[i][j]\n            path = dfs(i, j, [start_value])\n            if path:\n                if not min_path or path < min_path:\n                    min_path = path\n    return min_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    from functools import lru_cache\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x: int, y: int, steps: int) -> List[int]:\n        if steps == k:\n            return [grid[x][y]]\n        smallest_path = None\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path = dfs(nx, ny, steps + 1)\n                if path is not None:\n                    current_path = [grid[x][y]] + path\n                    if smallest_path is None or current_path < smallest_path:\n                        smallest_path = current_path\n        return smallest_path\n    result = None\n    for i in range(N):\n        for j in range(N):\n            current_path = dfs(i, j, 1)\n            if result is None or current_path < result:\n                result = current_path\n    return result", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(r, c, path):\n        if len(path) == k:\n            return\n        path.append(grid[r][c])\n        if len(path) == k:\n            paths.append(path[:])\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N:\n                dfs(nr, nc, path)\n        path.pop()\n    N = len(grid)\n    paths = []\n    for r in range(N):\n        for c in range(N):\n            dfs(r, c, [])\n    paths.sort()\n    return paths[0]", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(path, r, c):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for dr, dc in directions:\n            nr, nc = (r + dr, c + dc)\n            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):\n                path.append(grid[nr][nc])\n                dfs(path, nr, nc)\n                path.pop()\n    n = len(grid)\n    min_lex_path = None\n    paths = []\n    for r in range(n):\n        for c in range(n):\n            dfs([grid[r][c]], r, c)\n    min_lex_path = paths[0]\n    for path in paths[1:]:\n        if path < min_lex_path:\n            min_lex_path = path\n    return min_lex_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(path)\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid):\n                dfs(nx, ny, path + [grid[nx][ny]])\n    N = len(grid)\n    paths = []\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    return min(paths)", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n    N = len(grid)\n    paths = []\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    return min(paths)", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    smallest_path = [float('inf')] * k\n\n    def dfs(x, y, path):\n        if len(path) == k:\n            nonlocal smallest_path\n            if path < smallest_path:\n                smallest_path = path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    return smallest_path", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    path = []\n    visited = [[False] * N for _ in range(N)]\n\n    def dfs(x, y, current_path):\n        nonlocal path\n        if len(current_path) == k:\n            if not path or current_path < path:\n                path = current_path[:]\n            return\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                current_path.append(grid[nx][ny])\n                dfs(nx, ny, current_path)\n                current_path.pop()\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    return path"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.0}}
{"task_id": "HumanEval/130", "requirement": "def tri(n: int) -> List[float]:\n    \"\"\"Generate the first n + 1 numbers of a custom Tribonacci sequence.\n    \n    The sequence is defined as follows:\n    - tri(0) = 1\n    - tri(1) = 3\n    - For even n > 1, tri(n) = 1 + n / 2\n    - For odd n > 1, tri(n) = tri(n - 1) + tri(n - 2) + (1 + (n + 1) / 2 if (n + 1) is even else tri(n + 1))\n    \n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n    seq = []\n    for i in range(n + 1):\n        if i == 0:\n            seq.append(1)\n        elif i == 1:\n            seq.append(3)\n        elif i % 2 == 0:\n            seq.append(1 + i / 2)\n        else:\n            tri_n_1 = seq[i - 1]\n            tri_n_2 = seq[i - 2]\n            tri_n_plus_1_term = 1 + (i + 1) / 2 if (i + 1) % 2 == 0 else seq[i - 1] + seq[i - 2] + seq[i - 3]\n            seq.append(tri_n_1 + tri_n_2 + tri_n_plus_1_term)\n    return seq", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def helper(n):\n        if n == 0:\n            return 1\n        elif n == 1:\n            return 3\n        elif n % 2 == 0:\n            return 1 + n / 2\n        else:\n            tri_n1 = helper(n - 1)\n            tri_n2 = helper(n - 2)\n            if (n + 1) % 2 == 0:\n                return tri_n1 + tri_n2 + (1 + (n + 1) / 2)\n            else:\n                return tri_n1 + tri_n2 + helper(n + 1)\n    sequence = [helper(i) for i in range(n + 1)]\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [0] * (n + 1)\n    if n >= 0:\n        sequence[0] = 1\n    if n >= 1:\n        sequence[1] = 3\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence[i] = 1 + i / 2\n        else:\n            sequence[i] = sequence[i - 1] + sequence[i - 2]\n            next_val = 1 + (i + 1) / 2 if (i + 1) % 2 == 0 else 0\n            if next_val:\n                sequence[i] += next_val\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    result = []\n    for i in range(n + 1):\n        if i == 0:\n            result.append(1.0)\n        elif i == 1:\n            result.append(3.0)\n        elif i % 2 == 0:\n            result.append(1 + i / 2)\n        else:\n            next_term = result[i - 1] + result[i - 2]\n            if (i + 1) % 2 == 0:\n                additional_term = 1 + (i + 1) / 2\n            else:\n                additional_term = result[i + 1 - 1]\n            result.append(next_term + additional_term)\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n < 0:\n        return []\n    sequence = [1]\n    if n == 0:\n        return sequence\n    sequence.append(3)\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            term = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                term += 1 + (i + 1) / 2\n            else:\n                term += sequence[-2] + sequence[-1]\n            sequence.append(term)\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    if n < 0:\n        return []\n    seq = [0] * (n + 1)\n    if n >= 0:\n        seq[0] = 1\n    if n >= 1:\n        seq[1] = 3\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            seq[i] = 1 + i / 2\n        else:\n            seq[i] = seq[i - 1] + seq[i - 2] + (1 + (i + 1) / 2 if (i + 1) % 2 == 0 else seq[i + 1])\n    return seq", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    result = [0] * (n + 1)\n    if n >= 0:\n        result[0] = 1\n    if n >= 1:\n        result[1] = 3\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result[i] = 1 + i / 2\n        else:\n            result[i] = result[i - 1] + result[i - 2] + (1 + (i + 1) / 2) if (i + 1) % 2 == 0 else result[i + 1]\n    return result", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i / 2)\n        else:\n            next_value = sequence[i - 1] + sequence[i - 2]\n            if (i + 1) % 2 == 0:\n                next_value += 1 + (i + 1) / 2\n            elif i + 1 <= n:\n                next_value += sequence[i + 1]\n            sequence.append(next_value)\n    return sequence[:n + 1]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tri_value(n: int, cache: List[float]) -> float:\n        if n == 0:\n            return 1\n        elif n == 1:\n            return 3\n        elif n % 2 == 0:\n            return 1 + n / 2\n        else:\n            if len(cache) > n and cache[n] is not None:\n                return cache[n]\n            next_val = 1 + (n + 1) / 2 if (n + 1) % 2 == 0 else tri_value(n + 1, cache)\n            result = tri_value(n - 1, cache) + tri_value(n - 2, cache) + next_val\n            if len(cache) <= n:\n                cache.append(result)\n            else:\n                cache[n] = result\n            return result\n    cache = [None] * (n + 2)\n    sequence = []\n    for i in range(n + 1):\n        sequence.append(tri_value(i, cache))\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            value = 1 + i / 2\n        else:\n            if (i + 1) % 2 == 0:\n                next_value = 1 + (i + 1) / 2\n            else:\n                next_value = sequence[-1] + sequence[-2] + tri(i + 1)[-1]\n            value = sequence[-1] + sequence[-2] + next_value\n        sequence.append(value)\n    return sequence[:n + 1]"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 0.11111111111111116}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if the string contains at least one pair of square brackets that are nested within another pair of square brackets. \n    A pair of brackets is considered nested if there is at least one '[' that is closed by a ']' and is contained within another pair of '[' and ']'.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    open_brackets = 0\n    nested = False\n    for char in string:\n        if char == '[':\n            open_brackets += 1\n        elif char == ']':\n            if open_brackets > 1:\n                nested = True\n            if open_brackets > 0:\n                open_brackets -= 1\n    return nested", "def is_nested(string: str) -> bool:\n    depth = 0\n    max_depth = 0\n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n        if depth < 0:\n            return False\n    return max_depth > 1 and depth == 0", "def is_nested(string: str) -> bool:\n    open_brackets = 0\n    max_open_brackets = 0\n    for char in string:\n        if char == '[':\n            open_brackets += 1\n            max_open_brackets = max(max_open_brackets, open_brackets)\n        elif char == ']':\n            if open_brackets > 0:\n                open_brackets -= 1\n    return max_open_brackets > 1", "def is_nested(string: str) -> bool:\n    stack = 0\n    nested = False\n    for char in string:\n        if char == '[':\n            if stack > 0:\n                nested = True\n            stack += 1\n        elif char == ']':\n            stack -= 1\n        if stack < 0:\n            break\n    return nested and stack >= 0", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    has_nested = True\n    return has_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_found = True\n    return nested_found", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n            else:\n                return False\n    return False", "def is_nested(string: str) -> bool:\n    open_brackets = 0\n    for char in string:\n        if char == '[':\n            open_brackets += 1\n        elif char == ']':\n            open_brackets -= 1\n        if open_brackets > 1:\n            return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/140", "requirement": "def fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, replace all sequences of three or more consecutive spaces with a single dash '-'.\n    Then, replace all remaining single spaces with underscores '_'.\n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"", "generated_programs": ["import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    return re.sub(' ', '_', text)", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text"], "result": {"repaired_passk": 0.7, "cross_model_passk": 0.6, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(char) for char in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def digit_sum(n: int) -> int:\n        return sum((int(d) for d in str(abs(n))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n\n    def sum_of_digits(n: int) -> int:\n        return sum((int(digit) for digit in str(abs(n))))\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/153", "requirement": "from typing import List\n\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    \"\"\"Given the name of a class (a string) and a list of extensions, return the class name concatenated with the strongest extension.\n    \n    The strength of an extension is calculated as the difference between the number of uppercase letters (CAP) and the number of lowercase letters (SM) in the extension's name, i.e., strength = CAP - SM.\n    The strongest extension is the one with the highest strength value. If there are multiple extensions with the same strength, the first one in the list is chosen.\n    \n    If the list of extensions is empty, return the class name concatenated with an empty string (i.e., 'ClassName.').\n    \n    Example:\n    >>> Strongest_Extension('Slices', ['SErviNGSliCes', 'Cheese', 'StuFfed'])\n    'Slices.SErviNGSliCes'\n    >>> Strongest_Extension('my_class', ['AA', 'Be', 'CC'])\n    'my_class.AA'\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return f'{class_name}.'\n\n    def strength(extension: str) -> int:\n        CAP = sum((1 for ch in extension if ch.isupper()))\n        SM = sum((1 for ch in extension if ch.islower()))\n        return CAP - SM\n    strongest_extension = max(extensions, key=strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap = sum((1 for ch in extension if ch.isupper()))\n        sm = sum((1 for ch in extension if ch.islower()))\n        return cap - sm\n    if not extensions:\n        return f'{class_name}.'\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return f'{class_name}.'\n\n    def strength(extension: str) -> int:\n        cap = sum((1 for c in extension if c.isupper()))\n        sm = sum((1 for c in extension if c.islower()))\n        return cap - sm\n    strongest_extension = max(extensions, key=strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        return sum((1 for c in extension if c.isupper())) - sum((1 for c in extension if c.islower()))\n    if not extensions:\n        return f'{class_name}.'\n    strongest_extension = max(extensions, key=lambda ext: (calculate_strength(ext), -extensions.index(ext)))\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for c in extension if c.isupper()))\n        sm_count = sum((1 for c in extension if c.islower()))\n        return cap_count - sm_count\n    if not extensions:\n        return f'{class_name}.'\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        return sum((1 for ch in extension if ch.isupper())) - sum((1 for ch in extension if ch.islower()))\n    if not extensions:\n        return f'{class_name}.'\n    strongest = max(extensions, key=lambda ext: calculate_strength(ext))\n    return f'{class_name}.{strongest}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return f'{class_name}.'\n\n    def calculate_strength(extension: str) -> int:\n        caps = sum((1 for char in extension if char.isupper()))\n        lowers = sum((1 for char in extension if char.islower()))\n        return caps - lowers\n    strongest = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return f'{class_name}.'\n\n    def calculate_strength(extension: str) -> int:\n        cap_count = sum((1 for char in extension if char.isupper()))\n        sm_count = sum((1 for char in extension if char.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        CAP = sum((1 for char in extension if char.isupper()))\n        SM = sum((1 for char in extension if char.islower()))\n        return CAP - SM\n    if not extensions:\n        return f'{class_name}.'\n    strongest_extension = max(extensions, key=lambda ext: calculate_strength(ext))\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        return sum((1 for c in extension if c.isupper())) - sum((1 for c in extension if c.islower()))\n    if not extensions:\n        return f'{class_name}.'\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word. If the second word is an empty string, the function should return True.\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    b_rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in b_rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rot in a for rot in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotated_versions = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotated_versions))", "def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rot in a for rot in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    for i in range(len(b)):\n        rotated_b = b[i:] + b[:i]\n        if rotated_b in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/160", "requirement": "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebraic \n    expression and return the evaluation of this expression. The expression should be evaluated \n    using standard operator precedence rules, where multiplication and division have higher \n    precedence than addition and subtraction.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = []\n    for i, op in enumerate(operator):\n        expression.append(str(operand[i]))\n        expression.append(op)\n    expression.append(str(operand[-1]))\n    return eval(''.join(expression))", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expr = ''\n    for i in range(len(operator)):\n        expr += str(operand[i]) + operator[i]\n    expr += str(operand[-1])\n    result = eval(expr)\n    return result", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = []\n    num_operands = len(operand)\n    num_operators = len(operator)\n    for i in range(num_operands):\n        expression.append(str(operand[i]))\n        if i < num_operators:\n            expression.append(operator[i])\n    return eval(' '.join(expression))", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i, op in enumerate(operator):\n        expression += f' {op} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    length = len(operator)\n    for i in range(length):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[length])\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for op, num in zip(operator, operand[1:]):\n        expression += f' {op} {num}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = []\n    for i in range(len(operator)):\n        expression.append(str(operand[i]))\n        expression.append(operator[i])\n    expression.append(str(operand[-1]))\n    return eval(''.join(expression))", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = []\n    for i in range(len(operator)):\n        expression.append(str(operand[i]))\n        expression.append(operator[i])\n    expression.append(str(operand[-1]))\n    return eval(''.join(expression))", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = []\n    expression.append(str(operand[0]))\n    for i in range(len(operator)):\n        expression.append(operator[i])\n        expression.append(str(operand[i + 1]))\n    return eval(''.join(expression))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "def generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return all integers between the smaller and larger of the two numbers (inclusive) \n    that are even and consist solely of even digits, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    lower, upper = (min(a, b), max(a, b))\n    return [num for num in range(lower, upper + 1) if num % 2 == 0 and is_all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_even_and_all_even_digits(num: int) -> bool:\n        return num % 2 == 0 and all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if is_even_and_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_digits_even(n: int) -> bool:\n        return all((int(d) % 2 == 0 for d in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [x for x in range(start, end + 1) if x % 2 == 0 and is_all_digits_even(x)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(ch) % 2 == 0 for ch in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_even_with_even_digits(n: int) -> bool:\n        return n % 2 == 0 and all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if is_even_with_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_digits_even(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [x for x in range(start, end + 1) if x % 2 == 0 and is_all_digits_even(x)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def has_only_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and has_only_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    smaller, larger = (min(a, b), max(a, b))\n    return [num for num in range(smaller, larger + 1) if num % 2 == 0 and is_all_even_digits(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [x for x in range(start, end + 1) if x % 2 == 0 and is_all_digits_even(x)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_even_digits(num: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if num % 2 == 0 and is_all_even_digits(num)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/1", "requirement": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    group = ''\n    balance = 0\n    for char in paren_string:\n        if char == ' ':\n            continue\n        group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and group:\n            result.append(group)\n            group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    stack = []\n    result = []\n    current_group = ''\n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(current_group)\n                current_group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = ''\n    balance = 0\n    for char in paren_string:\n        if char == ' ':\n            continue\n        current_group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and current_group:\n            result.append(current_group)\n            current_group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    group = ''\n    stack = 0\n    for char in paren_string.replace(' ', ''):\n        group += char\n        if char == '(':\n            stack += 1\n        elif char == ')':\n            stack -= 1\n        if stack == 0 and group:\n            result.append(group)\n            group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    stack = []\n    current_group = ''\n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(current_group)\n                current_group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = ''\n    balance = 0\n    for char in paren_string:\n        if char == ' ':\n            continue\n        current_group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and current_group:\n            result.append(current_group)\n            current_group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    paren_string = paren_string.replace(' ', '')\n    current_group = ''\n    balance = 0\n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0:\n            result.append(current_group)\n            current_group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    stack = []\n    current_group = ''\n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                groups.append(current_group)\n                current_group = ''\n    return groups", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = ''\n    balance = 0\n    paren_string = paren_string.replace(' ', '')\n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance == 0 and current_group:\n            result.append(current_group)\n            current_group = ''\n    return result", "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    stack = []\n    groups = []\n    current_group = ''\n    paren_string = paren_string.replace(' ', '')\n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                groups.append(current_group)\n                current_group = ''\n    return groups"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/10", "requirement": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"", "generated_programs": ["def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    for i in range(len(string), -1, -1):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/11", "requirement": "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs up to the length of the shorter string and return the result as a string.\n    If the input strings are of unequal length, the function will only perform XOR on the characters up to the length of the shorter string, ignoring any extra characters in the longer string.\n    >>> string_xor('010', '110')\n    '100'\n    >>> string_xor('101', '11')\n    '01'\n    \"\"\"", "generated_programs": ["def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(c1) ^ int(c2)) for c1, c2 in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))", "def string_xor(a: str, b: str) -> str:\n    return ''.join((str(int(x) ^ int(y)) for x, y in zip(a, b)))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/13", "requirement": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b. The GCD is always a non-negative integer, regardless of the signs of the inputs.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(6, -4)\n    2\n    \"\"\"", "generated_programs": ["from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(abs(a), abs(b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(abs(a), abs(b))", "import math\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return math.gcd(a, b)", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(abs(a), abs(b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(abs(a), abs(b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(abs(a), abs(b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(abs(a), abs(b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return abs(gcd(a, b))", "from math import gcd\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(abs(a), abs(b))", "import math\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return math.gcd(a, b)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/32", "requirement": "from typing import List\nimport math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... + xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\"\n    Finds a zero point of the polynomial with coefficients xs using Newton's method.\n    The function returns the first zero point found within 100 iterations or when the difference between successive approximations is less than 1e-06.\n    If the derivative of the polynomial at any point is zero, a ZeroDivisionError is raised.\n    The function does not explicitly check for the number of coefficients or the largest non-zero coefficient, and it assumes that the polynomial has at least one zero point.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"", "generated_programs": ["from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * math.pow(x, i) for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))", "from typing import List\nimport math\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum((coeff * x ** i for i, coeff in enumerate(xs)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/43", "requirement": "from typing import List\n\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two distinct elements in the list (i.e., elements at different positions)\n    that sum to zero, and False otherwise. This includes the case where both elements are zero (0, 0).\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/47", "requirement": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"Return the median of elements in the list l. \n    For a list with an odd number of elements, the median is the middle element when the list is sorted. \n    For a list with an even number of elements, the median is the average of the two middle elements.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return l[mid]", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2.0", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_list[mid - 1] + sorted_list[mid]) / 2\n    else:\n        return float(sorted_list[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    if n % 2 == 1:\n        return sorted_list[n // 2]\n    else:\n        mid1 = sorted_list[n // 2 - 1]\n        mid2 = sorted_list[n // 2]\n        return (mid1 + mid2) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    mid = n // 2\n    if n % 2 == 0:\n        return (l[mid - 1] + l[mid]) / 2.0\n    else:\n        return float(l[mid])", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return float(l[n // 2])\n    else:\n        mid1, mid2 = (l[n // 2 - 1], l[n // 2])\n        return (mid1 + mid2) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return float(l[n // 2])\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2", "from typing import List\n\ndef median(l: List[int]) -> float:\n    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return float(l[n // 2])\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2.0"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/54", "requirement": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the exact same set of characters, regardless of the frequency or order of those characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"", "generated_programs": ["from typing import Set\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "from typing import Set\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "from typing import Set\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/67", "requirement": "def fruit_distribution(s: str, n: int) -> int:\n    \"\"\"\n    Given a string `s` that describes the number of apples and oranges in a basket, and an integer `n` \n    representing the total number of fruits in the basket, return the number of mango fruits in the basket.\n    \n    The string `s` will contain the number of apples and oranges in the format \"X apples and Y oranges\", \n    where X and Y are non-negative integers. If either \"apples\" or \"oranges\" is missing from the string, \n    the corresponding count is assumed to be 0.\n    \n    The number of mango fruits is calculated by subtracting the number of apples and oranges from the total \n    number of fruits `n`.\n    \n    Examples:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) -> 8\n    fruit_distribution(\"0 apples and 1 oranges\", 3) -> 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 95\n    fruit_distribution(\"100 apples and 1 oranges\", 120) -> 19\n    \"\"\"", "generated_programs": ["import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    match_apples = re.search('(\\\\d+)\\\\s*apples', s)\n    match_oranges = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(match_apples.group(1)) if match_apples else 0\n    oranges = int(match_oranges.group(1)) if match_oranges else 0\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    match = re.search('(\\\\d+)\\\\s*apples', s)\n    apples = int(match.group(1)) if match else 0\n    match = re.search('(\\\\d+)\\\\s*oranges', s)\n    oranges = int(match.group(1)) if match else 0\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    match_apples = re.search('(\\\\d+)\\\\s+apples', s)\n    match_oranges = re.search('(\\\\d+)\\\\s+oranges', s)\n    apples = int(match_apples.group(1)) if match_apples else 0\n    oranges = int(match_oranges.group(1)) if match_oranges else 0\n    mangoes = n - (apples + oranges)\n    return mangoes", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s+apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s+oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples_count = int(apples_match.group(1)) if apples_match else 0\n    oranges_count = int(oranges_match.group(1)) if oranges_match else 0\n    return n - apples_count - oranges_count", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    match_apples = re.search('(\\\\d+)\\\\s*apples', s)\n    match_oranges = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(match_apples.group(1)) if match_apples else 0\n    oranges = int(match_oranges.group(1)) if match_oranges else 0\n    return n - apples - oranges", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - (apples + oranges)", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples_count = int(apples_match.group(1)) if apples_match else 0\n    oranges_count = int(oranges_match.group(1)) if oranges_match else 0\n    return n - apples_count - oranges_count", "import re\n\ndef fruit_distribution(s: str, n: int) -> int:\n    apples_match = re.search('(\\\\d+)\\\\s*apples', s)\n    oranges_match = re.search('(\\\\d+)\\\\s*oranges', s)\n    apples = int(apples_match.group(1)) if apples_match else 0\n    oranges = int(oranges_match.group(1)) if oranges_match else 0\n    return n - apples - oranges"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/76", "requirement": "def is_simple_power(x: int, n: int) -> bool:\n    \"\"\"Your task is to write a function that returns true if a number x is a simple power of n and false in other cases.\n    x is a simple power of n if there exists an integer k such that n^k = x. The function should handle edge cases as follows:\n    - If n is 1, the function should return true only if x is also 1.\n    - If x is 0, the function should return false, as 0 is not a power of any positive integer n.\n    - If n is 0, the function should return false, as no positive integer x can be a power of 0.\n    The function should iteratively multiply n by itself until the product equals x or exceeds it, and then check if the product equals x.\n\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"", "generated_programs": ["def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0 or n == 0:\n        return False\n    product = 1\n    while product < x:\n        product *= n\n    return product == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 0 or x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    product = 1\n    while product < x:\n        product *= n\n    return product == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 0 or x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0 or n == 0:\n        return False\n    product = 1\n    while product < x:\n        product *= n\n    return product == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 0 or x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 1:\n        return x == 1\n    if x == 0 or n == 0:\n        return False\n    current_power = 1\n    while current_power < x:\n        current_power *= n\n    return current_power == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 0 or x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    result = 1\n    while result < x:\n        result *= n\n    return result == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 0 or x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    product = 1\n    while product < x:\n        product *= n\n    return product == x", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 0 or x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    product = 1\n    while product < x:\n        product *= n\n        if product == x:\n            return True\n    return False", "def is_simple_power(x: int, n: int) -> bool:\n    if n == 0 or x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    current_power = 1\n    while current_power < x:\n        current_power *= n\n    return current_power == x"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/77", "requirement": "def iscube(a: int) -> bool:\n    '''\n    Write a function that takes an integer a and returns True \n    if this integer is a perfect cube of some integer number, \n    including negative integers and zero. The function should \n    correctly handle both positive and negative inputs.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "generated_programs": ["import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "def iscube(a: int) -> bool:\n    return round(abs(a) ** (1 / 3)) ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    root = round(a ** (1 / 3))\n    return root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    cube_root = round(a ** (1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(pow(a, 1 / 3))\n    return cube_root ** 3 == a", "import math\n\ndef iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    cube_root = round(pow(abs(a), 1 / 3))\n    return cube_root ** 3 == abs(a)", "import math\n\ndef iscube(a: int) -> bool:\n    root = round(a ** (1 / 3))\n    return root ** 3 == a"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.19999999999999996, "original_passk": 0.6}}
{"task_id": "HumanEval/83", "requirement": "def starts_one_ends(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"", "generated_programs": ["def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_numbers = 9 * 10 ** (n - 1)\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 9 * 10 ** (n - 1) // 10\n    overlap = 10 ** (n - 2) if n > 1 else 0\n    return start_with_1 + end_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_one = 10 ** (n - 1)\n    ends_with_one = 9 * 10 ** (n - 1)\n    overlap = 10 ** (n - 2) if n > 1 else 0\n    return starts_with_one + ends_with_one - overlap", "def starts_one_ends(n: int) -> int:\n    if n <= 0:\n        return 0\n    total_numbers = 9 * 10 ** (n - 1)\n    start_with_one = 10 ** (n - 1)\n    end_with_one = 10 ** (n - 1)\n    double_counted = 1 if n == 1 else 10 ** (n - 2)\n    result = start_with_one + end_with_one - double_counted\n    return result", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_n_digit_numbers = 9 * 10 ** (n - 1)\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 2)\n    return starts_with_1 + ends_with_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    count_start_1 = 10 ** (n - 1)\n    count_end_1 = 10 ** (n - 1)\n    overlap = 10 ** (n - 2)\n    return count_start_1 + count_end_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    total_start_or_end_1 = 10 ** (n - 1) + 10 ** (n - 1) - 10 ** (n - 2)\n    return total_start_or_end_1", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    start_with_1 = 10 ** (n - 1)\n    end_with_1 = 9 * 10 ** (n - 1)\n    overlap = 1\n    return start_with_1 + end_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 10 ** (n - 1)\n    overlap = 1\n    return starts_with_1 + ends_with_1 - overlap", "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    starts_with_1 = 10 ** (n - 1)\n    ends_with_1 = 9 * 10 ** (n - 1)\n    overlap = 10 ** (n - 2)\n    return starts_with_1 + ends_with_1 - overlap"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/89", "requirement": "def encrypt(s: str) -> str:\n    \"\"\"Create a function `encrypt` that takes a string as an argument and returns a new string where each lowercase letter is rotated by 4 positions in the alphabet, wrapping around if necessary. Uppercase letters and other characters should remain unchanged.\n\n    The rotation should wrap around the alphabet, meaning 'z' should map to 'd'. The function should only modify lowercase letters and leave all other characters, including uppercase letters, unchanged.\n\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"", "generated_programs": ["def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            rotated_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(rotated_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((rotate_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def rotate_lowercase(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((rotate_lowercase(c) for c in s))", "def encrypt(s: str) -> str:\n    return ''.join((chr((ord(char) - ord('a') + 4) % 26 + ord('a')) if 'a' <= char <= 'z' else char for char in s))", "def encrypt(s: str) -> str:\n\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((rotate_char(char) for char in s))", "def encrypt(s: str) -> str:\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            rotated_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(rotated_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encrypt(s: str) -> str:\n\n    def rotate_char(ch):\n        if 'a' <= ch <= 'z':\n            return chr((ord(ch) - ord('a') + 4) % 26 + ord('a'))\n        return ch\n    return ''.join((rotate_char(ch) for ch in s))", "def encrypt(s: str) -> str:\n    return ''.join((chr((ord(char) - ord('a') + 4) % 26 + ord('a')) if 'a' <= char <= 'z' else char for char in s))", "def encrypt(s: str) -> str:\n\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((rotate_char(c) for c in s))", "def encrypt(s: str) -> str:\n\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        return c\n    return ''.join((rotate_char(c) for c in s))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.5}}
{"task_id": "HumanEval/91", "requirement": "def is_bored(S: str) -> int:\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\", \n    regardless of what follows it (e.g., \"I.\", \"I!\", \"I?\"). \n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"", "generated_programs": ["import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))", "def is_bored(S: str) -> int:\n    import re\n    return sum((1 for sentence in re.split('[.!?]', S) if sentence.strip().startswith('I')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((sentence.strip().startswith('I') for sentence in sentences))", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    count = sum((1 for sentence in sentences if sentence.strip().startswith('I')))\n    return count", "import re\n\ndef is_bored(S: str) -> int:\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))", "def is_bored(S: str) -> int:\n    import re\n    sentences = re.split('[.!?]', S)\n    return sum((1 for sentence in sentences if sentence.strip().startswith('I')))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/93", "requirement": "def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message, and encodes it by swapping the case of all letters. \n    Additionally, replace all vowels in the message with the letter that appears 2 places ahead \n    of that vowel in the English alphabet. If the replacement character goes beyond 'z' or 'Z', \n    it wraps around to the beginning of the alphabet. The function should handle only letters, \n    and non-letter characters should remain unchanged. After replacing the vowels, the case of \n    the resulting character should be swapped as well.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"", "generated_programs": ["def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        lower_vowels = 'aeiou'\n        upper_vowels = 'AEIOU'\n        if vowel in lower_vowels:\n            new_char = chr((ord(vowel) - ord('a') + 2) % 26 + ord('a'))\n        elif vowel in upper_vowels:\n            new_char = chr((ord(vowel) - ord('A') + 2) % 26 + ord('A'))\n        else:\n            return vowel\n        return new_char.swapcase()\n    result = []\n    for char in message:\n        if char.isalpha():\n            if char.lower() in 'aeiou':\n                result.append(shift_vowel(char))\n            else:\n                result.append(char.swapcase())\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def swap_case_and_replace_vowel(char):\n        if char.lower() in 'aeiou':\n            next_char = chr((ord(char.lower()) - ord('a') + 2) % 26 + ord('a'))\n            if char.isupper():\n                return next_char.upper()\n            else:\n                return next_char.lower()\n        elif char.isalpha():\n            return char.swapcase()\n        else:\n            return char\n    return ''.join((swap_case_and_replace_vowel(char) for char in message))", "def encode(message: str) -> str:\n\n    def swap_case_and_shift_vowel(char: str) -> str:\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        if char in vowels:\n            shift = 2\n            if char.islower():\n                shifted = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                shifted = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            return shifted.swapcase()\n        else:\n            return char.swapcase()\n    return ''.join((swap_case_and_shift_vowel(char) if char.isalpha() else char for char in message))", "def encode(message: str) -> str:\n\n    def shift_vowel(char: str) -> str:\n        vowels = 'AEIOUaeiou'\n        if char not in vowels:\n            return char\n        if char.islower():\n            replacement = chr((ord(char) - ord('a') + 2) % 26 + ord('a'))\n        else:\n            replacement = chr((ord(char) - ord('A') + 2) % 26 + ord('A'))\n        return replacement.swapcase()\n    result = []\n    for char in message:\n        if char.isalpha():\n            char = shift_vowel(char) if char.lower() in 'aeiou' else char.swapcase()\n        result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        if vowel.islower():\n            shifted = chr((ord(vowel) - ord('a') + 2) % 26 + ord('a'))\n        else:\n            shifted = chr((ord(vowel) - ord('A') + 2) % 26 + ord('A'))\n        return shifted\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in message:\n        if char.isalpha():\n            if char in vowels:\n                updated_char = shift_vowel(char)\n            else:\n                updated_char = char\n            result.append(updated_char.swapcase())\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        shift = 2\n        if vowel.islower():\n            new_char = chr((ord(vowel) - ord('a') + shift) % 26 + ord('a'))\n        else:\n            new_char = chr((ord(vowel) - ord('A') + shift) % 26 + ord('A'))\n        return new_char\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in message:\n        if char.isalpha():\n            if char in vowels:\n                shifted = shift_vowel(char)\n                result.append(shifted.swapcase())\n            else:\n                result.append(char.swapcase())\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def swap_case_and_replace_vowel(char: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if char in vowels:\n            step = 2\n            is_upper = char.isupper()\n            new_char = chr((ord(char.lower()) - ord('a') + step) % 26 + ord('a'))\n            return new_char.upper() if not is_upper else new_char.lower()\n        elif char.isalpha():\n            return char.swapcase()\n        else:\n            return char\n    return ''.join((swap_case_and_replace_vowel(char) for char in message))", "import string\n\ndef encode(message: str) -> str:\n\n    def swap_case(char: str) -> str:\n        return char.lower() if char.isupper() else char.upper()\n\n    def replace_vowel(char: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if char in vowels:\n            shift = 2\n            if char.isupper():\n                new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            else:\n                new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            return swap_case(new_char)\n        return swap_case(char)\n    result = ''\n    for char in message:\n        if char.isalpha():\n            result += replace_vowel(char)\n        else:\n            result += char\n    return result", "def encode(message: str) -> str:\n\n    def transform_vowel(char: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if char in vowels:\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + 2) % 26 + ord('a'))\n                return new_char.upper()\n            else:\n                new_char = chr((ord(char) - ord('A') + 2) % 26 + ord('A'))\n                return new_char.lower()\n        return char\n\n    def swap_case(char: str) -> str:\n        return char.lower() if char.isupper() else char.upper()\n    result = []\n    for char in message:\n        if char.isalpha():\n            transformed = transform_vowel(char)\n            final_char = swap_case(transformed)\n            result.append(final_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "def encode(message: str) -> str:\n\n    def shift_vowel(vowel: str) -> str:\n        vowels = 'aeiouAEIOU'\n        shift = 2\n        if vowel in 'aeiou':\n            shifted = chr((ord(vowel) - ord('a') + shift) % 26 + ord('a'))\n        elif vowel in 'AEIOU':\n            shifted = chr((ord(vowel) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            shifted = vowel\n        return shifted\n    result = ''\n    for char in message:\n        if char.isalpha():\n            encoded_char = shift_vowel(char)\n            result += encoded_char.swapcase()\n        else:\n            result += char\n    return result"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.8, "original_passk": 0.4}}
{"task_id": "HumanEval/100", "requirement": "from typing import List\n\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Given a non-negative integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is determined by adding 2 to the current number of stones,\n    ensuring that the parity (odd or even) of the number of stones remains the same as the current level.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(0)\n    [0]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    while len(pile) < n:\n        pile.append(n)\n        n += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    current_stones = n\n    for _ in range(n - 1):\n        current_stones += 2\n        pile.append(current_stones)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    current = n\n    for i in range(n - 1):\n        current += 2\n        pile.append(current)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_level = n\n    for _ in range(n):\n        pile.append(current_level)\n        current_level += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = [n]\n    while len(pile) < n:\n        next_level = pile[-1] + 2\n        pile.append(next_level)\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + i * 2 for i in range(n + 1)]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    return pile if n > 0 else [0]", "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    pile = []\n    current_level = n\n    for _ in range(n):\n        pile.append(current_level)\n        current_level += 2\n    return pile"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/101", "requirement": "from typing import List\n\n\ndef words_string(s: str) -> List[str]:\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return a list of the words. The string may contain\n    leading or trailing whitespace, which should be ignored. If the string is empty or\n    contains only whitespace and/or commas, return an empty list.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.replace(',', ' ').split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.replace(',', ' ').split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.replace(',', ' ').split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.replace(',', ' ').strip().split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.replace(',', ' ').split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.replace(',', ' ').split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.replace(',', ' ').strip().split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    s = s.strip()\n    if not s:\n        return []\n    return [word for word in s.replace(',', ' ').split() if word]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word.strip() for word in s.replace(',', ' ').split() if word.strip()]", "from typing import List\n\ndef words_string(s: str) -> List[str]:\n    return [word for word in s.replace(',', ' ').split() if word]"], "result": {"repaired_passk": 0.5, "cross_model_passk": 1.0, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/102", "requirement": "def choose_num(x: int, y: int) -> int:\n    \"\"\"This function takes two positive integers x and y and returns the largest even integer within the range [x, y] inclusive. If x is greater than y, or if there are no even numbers in the range, the function returns -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"", "generated_programs": ["def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0 and num > largest_even:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    return largest_even", "from typing import Optional\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for i in range(x, y + 1):\n        if i % 2 == 0:\n            largest_even = i\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for number in range(x, y + 1):\n        if number % 2 == 0:\n            largest_even = number\n    return largest_even", "from typing import List\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for i in range(x, y + 1):\n        if i % 2 == 0:\n            largest_even = i\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0 and num > largest_even:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "def choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "from typing import Optional\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/108", "requirement": "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements whose sum of digits is greater than 0.\n    For positive numbers, the sum of digits is calculated as usual.\n    For negative numbers, only the first digit is treated as negative, and the remaining digits are treated as positive.\n    For example, -123 has signed digits -1, 2, and 3, and their sum is 4.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num < 0:\n            digits = [int(d) for d in str(abs(num))]\n            digits[0] = -digits[0]\n        else:\n            digits = [int(d) for d in str(num)]\n        return sum(digits)\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num < 0:\n            num_str = str(num)[1:]\n            return -int(str(num)[0]) + sum((int(digit) for digit in num_str))\n        else:\n            return sum((int(digit) for digit in str(num)))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num < 0:\n            digits = [int(d) for d in str(-num)]\n            return -digits[0] + sum(digits[1:])\n        return sum((int(d) for d in str(num)))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(num: int) -> int:\n        digits = list(map(int, str(abs(num))))\n        if num < 0:\n            digits[0] *= -1\n        return sum(digits)\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num < 0:\n            num_str = str(num)\n            return int(num_str[0]) + sum((int(d) for d in num_str[1:]))\n        else:\n            return sum((int(d) for d in str(num)))\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def digit_sum(num: int) -> int:\n        if num < 0:\n            abs_digits = list(map(int, str(abs(num))))\n            return -abs_digits[0] + sum(abs_digits[1:])\n        else:\n            return sum(map(int, str(num)))\n    return sum((1 for num in arr if digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_digits(num: int) -> int:\n        if num < 0:\n            digits = [-int(str(num)[1])] + [int(d) for d in str(num)[2:]]\n        else:\n            digits = [int(d) for d in str(num)]\n        return sum(digits)\n    return sum((1 for num in arr if sum_of_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def signed_digit_sum(num: int) -> int:\n        if num < 0:\n            num_str = str(abs(num))\n            return -int(num_str[0]) + sum((int(digit) for digit in num_str[1:]))\n        else:\n            return sum((int(digit) for digit in str(num)))\n    return sum((1 for num in arr if signed_digit_sum(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_signed_digits(num: int) -> int:\n        if num >= 0:\n            return sum((int(d) for d in str(num)))\n        else:\n            digits = str(num)[1:]\n            return -int(str(num)[0]) + sum((int(d) for d in digits))\n    return sum((1 for num in arr if sum_of_signed_digits(num) > 0))", "from typing import List\n\ndef count_nums(arr: List[int]) -> int:\n\n    def sum_of_signed_digits(num: int) -> int:\n        if num < 0:\n            num = abs(num)\n            digits = list(map(int, str(num)))\n            return -digits[0] + sum(digits[1:])\n        return sum(map(int, str(num)))\n    return sum((1 for num in arr if sum_of_signed_digits(num) > 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.7, "original_passk": 0.5}}
{"task_id": "HumanEval/116", "requirement": "from typing import List\n\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x & 4294967295).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x & 4294967295).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x & 4294967295).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x & 4294967295).count('1'), x))", "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.6, "original_passk": 0.7}}
{"task_id": "HumanEval/120", "requirement": "from typing import List\n\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array arr of integers and a non-negative integer k, return a sorted list \n    of length k containing the k largest numbers from arr, sorted in ascending order. \n    If k is 0, return an empty list. If k is greater than or equal to the length of arr, \n    return the entire sorted array.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr)[-k:])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])", "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    return sorted(sorted(arr, reverse=True)[:k])"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.9, "original_passk": 1.0}}
{"task_id": "HumanEval/124", "requirement": "def valid_date(date: str) -> bool:\n    \"\"\"Validates a given date string and returns True if the date is valid, otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1, 3, 5, 7, 8, 10, 12. \n       The number of days is not less than 1 or higher than 30 days for months 4, 6, 9, 11. \n       The number of days is not less than 1 or higher than 29 days for the month 2, regardless of whether the year is a leap year or not.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    Examples:\n    valid_date('03-11-2000') => True\n    valid_date('15-01-2012') => False\n    valid_date('04-0-2040') => False\n    valid_date('06-04-2020') => True\n    valid_date('06/04/2020') => False\n    \"\"\"", "generated_programs": ["import re\n\ndef valid_date(date: str) -> bool:\n    if not date or not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            return 1 <= day <= 31\n        elif month in {4, 6, 9, 11}:\n            return 1 <= day <= 30\n        elif month == 2:\n            return 1 <= day <= 29\n    except ValueError:\n        return False\n    return False", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    match = re.match('^(\\\\d{2})-(\\\\d{2})-(\\\\d{4})$', date)\n    if not match:\n        return False\n    month, day, year = map(int, match.groups())\n    if month < 1 or month > 12:\n        return False\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True", "from typing import Tuple\n\ndef valid_date(date: str) -> bool:\n    try:\n        parts = date.split('-')\n        if len(parts) != 3 or not all((part.isdigit() for part in parts)):\n            return False\n        month, day, year = map(int, parts)\n        if month < 1 or month > 12:\n            return False\n        if month in {1, 3, 5, 7, 8, 10, 12} and (not 1 <= day <= 31):\n            return False\n        elif month in {4, 6, 9, 11} and (not 1 <= day <= 30):\n            return False\n        elif month == 2 and (not 1 <= day <= 29):\n            return False\n        return True\n    except ValueError:\n        return False", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\\\\d{4}$'\n    if not re.match(pattern, date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month in [4, 6, 9, 11] and day > 30 or (month == 2 and day > 29):\n        return False\n    return True", "from typing import Tuple\n\ndef valid_date(date: str) -> bool:\n    try:\n        if not date or len(date) != 10 or date[2] != '-' or (date[5] != '-'):\n            return False\n        month, day, year = map(int, date.split('-'))\n        if month < 1 or month > 12:\n            return False\n        if day < 1 or (month in {1, 3, 5, 7, 8, 10, 12} and day > 31):\n            return False\n        elif month in {4, 6, 9, 11} and day > 30:\n            return False\n        elif month == 2 and day > 29:\n            return False\n        return True\n    except ValueError:\n        return False", "import re\n\ndef valid_date(date: str) -> bool:\n    date_regex = '^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\\d{4}$'\n    if not re.match(date_regex, date):\n        return False\n    month, day, _ = map(int, date.split('-'))\n    if month in [4, 6, 9, 11] and day > 30:\n        return False\n    elif month == 2 and day > 29:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0?[1-9]|1[0-2])-(0?[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$'\n    match = re.match(pattern, date)\n    if not match:\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month in {4, 6, 9, 11} and day > 30:\n        return False\n    elif month == 2 and day > 29:\n        return False\n    elif day > 31:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    pattern = '^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\\d{4}$'\n    if not date or not re.match(pattern, date):\n        return False\n    month, day, _ = map(int, date.split('-'))\n    if month == 2 and day > 29 or (month in [4, 6, 9, 11] and day > 30):\n        return False\n    return True", "from typing import List\n\ndef valid_date(date: str) -> bool:\n    import re\n    date_pattern = re.compile('^(0[1-9]|1[0-2])-(0[1-9]|[1-2]\\\\d|3[0-1])-\\\\d{4}$')\n    if not date_pattern.match(date):\n        return False\n    parts = date.split('-')\n    month = int(parts[0])\n    day = int(parts[1])\n    year = int(parts[2])\n    if month == 2:\n        if day > 29:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day > 30:\n            return False\n    elif day > 31:\n        return False\n    return True", "import re\n\ndef valid_date(date: str) -> bool:\n    if not date:\n        return False\n    pattern = '^(0[1-9]|1[0-2])-([0-2][0-9]|3[01])-([0-9]{4})$'\n    match = re.match(pattern, date)\n    if not match:\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        return 1 <= day <= 31\n    elif month in {4, 6, 9, 11}:\n        return 1 <= day <= 30\n    elif month == 2:\n        return 1 <= day <= 29\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.09999999999999998}}
{"task_id": "HumanEval/125", "requirement": "from typing import List\nfrom typing import Union\n\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    '''\n    Given a string of words, return a list of words split on any whitespace (including spaces, tabs, and newlines). \n    If no whitespaces exist in the text, split on commas ','. \n    If no commas exist, return the number of lowercase letters where (ord(char) - ord('a')) % 2 != 0, \n    with ord('a') = 0, ord('b') = 1, ... ord('z') = 25.\n    \n    Examples\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''", "generated_programs": ["from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 != 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(((ord(char) - ord('a')) % 2 != 0 for char in txt if char.islower()))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((c.isspace() for c in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(((ord(char) - ord('a')) % 2 != 0 for char in txt if char.islower()))", "from typing import List, Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if any((char.isspace() for char in txt)):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 != 0))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.8}}
{"task_id": "HumanEval/127", "requirement": "def intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"Given two closed intervals, determine if the length of their intersection is a prime number.\n    \n    A closed interval includes both its start and end points. The intersection of two intervals is the set of all points that are common to both intervals. If the intervals do not intersect, return \"NO\". If they do intersect, calculate the length of the intersection (i.e., the difference between the end and start of the intersection). If this length is a prime number, return \"YES\"; otherwise, return \"NO\".\n    \n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"", "generated_programs": ["from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start >= end:\n        return 'NO'\n    length = end - start\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    intersection_length = end - start\n    return 'YES' if is_prime(intersection_length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    start_intersection = max(interval1[0], interval2[0])\n    end_intersection = min(interval1[1], interval2[1])\n    if start_intersection > end_intersection:\n        return 'NO'\n    length = end_intersection - start_intersection + 1\n    return 'YES' if is_prime(length) else 'NO'", "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return 'NO'\n    length = end - start + 1\n    return 'YES' if is_prime(length) else 'NO'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.5, "original_passk": 0.0}}
{"task_id": "HumanEval/129", "requirement": "def minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given an N x N grid (N >= 2) where each cell contains a unique integer in the range [1, N * N], \n    and a positive integer k, find the lexicographically smallest path of length k. \n    A path is a sequence of cells where each consecutive cell is a neighbor (sharing an edge) of the previous cell. \n    The path can start at any cell and may revisit cells. \n    The lexicographical order is determined by the sequence of cell values in the path, and the path is constructed by always choosing the smallest available next cell value at each step. \n    It is guaranteed that the answer is unique.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"", "generated_programs": ["from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def neighbors(x, y):\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                yield (nx, ny)\n    min_heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(min_heap, (grid[i][j], i, j, [grid[i][j]]))\n    while min_heap:\n        value, x, y, path = heapq.heappop(min_heap)\n        if len(path) == k:\n            return path\n        for nx, ny in neighbors(x, y):\n            new_path = path + [grid[nx][ny]]\n            heapq.heappush(min_heap, (grid[nx][ny], nx, ny, new_path))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def neighbors(x, y):\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                yield (nx, ny)\n\n    def dfs(curr_path, x, y):\n        if len(curr_path) == k:\n            return curr_path\n        next_cells = []\n        for nx, ny in neighbors(x, y):\n            heapq.heappush(next_cells, (grid[nx][ny], nx, ny))\n        while next_cells:\n            value, nx, ny = heapq.heappop(next_cells)\n            new_path = dfs(curr_path + [value], nx, ny)\n            if new_path:\n                return new_path\n        return None\n    candidates = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(candidates, (grid[i][j], i, j))\n    while candidates:\n        starting_value, sx, sy = heapq.heappop(candidates)\n        path = dfs([starting_value], sx, sy)\n        if path:\n            return path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    min_heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(min_heap, (grid[i][j], i, j, [grid[i][j]]))\n    while min_heap:\n        value, x, y, path = heapq.heappop(min_heap)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                heapq.heappush(min_heap, (grid[nx][ny], nx, ny, path + [grid[nx][ny]]))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n\n    def neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                yield (nx, ny)\n    min_heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(min_heap, (grid[i][j], i, j, [grid[i][j]]))\n    while min_heap:\n        value, x, y, path = heapq.heappop(min_heap)\n        if len(path) == k:\n            return path\n        for nx, ny in neighbors(x, y):\n            heapq.heappush(min_heap, (grid[nx][ny], nx, ny, path + [grid[nx][ny]]))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):\n                yield (nx, ny)\n    N = len(grid)\n    heap = [(grid[i][j], i, j, [grid[i][j]]) for i in range(N) for j in range(N)]\n    heapq.heapify(heap)\n    while heap:\n        val, x, y, path = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for nx, ny in neighbors(x, y):\n            new_path = path + [grid[nx][ny]]\n            heapq.heappush(heap, (grid[nx][ny], nx, ny, new_path))\n    return []", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                yield (nx, ny)\n    n = len(grid)\n    min_heap = [(grid[i][j], i, j, [grid[i][j]]) for i in range(n) for j in range(n)]\n    heapq.heapify(min_heap)\n    while min_heap:\n        value, x, y, path = heapq.heappop(min_heap)\n        if len(path) == k:\n            return path\n        for nx, ny in neighbors(x, y):\n            heapq.heappush(min_heap, (grid[nx][ny], nx, ny, path + [grid[nx][ny]]))", "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n\n    def neighbors(x, y, n):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                yield (nx, ny)\n    n = len(grid)\n    min_path = []\n    heap = [(grid[i][j], i, j, [grid[i][j]]) for i in range(n) for j in range(n)]\n    heap.sort()\n    while heap:\n        value, x, y, path = heap.pop(0)\n        if len(path) == k:\n            if not min_path or path < min_path:\n                min_path = path\n        elif len(path) < k:\n            for nx, ny in neighbors(x, y, n):\n                heap.append((grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            heap.sort()\n    return min_path", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    pq = []\n    result = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], i, j))\n    while pq and len(result) < k:\n        value, x, y = heapq.heappop(pq)\n        result.append(value)\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < N and 0 <= ny < N:\n                heapq.heappush(pq, (grid[nx][ny], nx, ny))\n    return result[:k]", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(heap, (grid[i][j], [(i, j)]))\n    while heap:\n        current_value, path = heapq.heappop(heap)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        x, y = path[-1]\n        for dx, dy in directions:\n            nx, ny = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n:\n                new_path = path + [(nx, ny)]\n                heapq.heappush(heap, (grid[nx][ny], new_path))", "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], [(i, j)]))\n    while pq:\n        path_val, path_cells = heapq.heappop(pq)\n        if len(path_cells) == k:\n            return [grid[x][y] for x, y in path_cells]\n        last_cell = path_cells[-1]\n        for dx, dy in directions:\n            nx, ny = (last_cell[0] + dx, last_cell[1] + dy)\n            if is_valid(nx, ny):\n                new_path = path_cells + [(nx, ny)]\n                next_val = path_val + grid[nx][ny]\n                heapq.heappush(pq, (next_val, new_path))"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.19999999999999996, "original_passk": 0.0}}
{"task_id": "HumanEval/130", "requirement": "def tri(n: int) -> List[float]:\n    \"\"\"Generates a list of the first n + 1 numbers of a custom sequence similar to the Tribonacci sequence.\n    The sequence is defined as follows:\n    - tri(0) = 1\n    - tri(1) = 3\n    - For even n > 1, tri(n) = 1 + n / 2\n    - For odd n > 1, tri(n) = tri(n - 1) + tri(n - 2) + (1 + (n + 1) / 2 if (n + 1) is even else tri(n + 1))\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def custom_sequence(num: int) -> float:\n        if num == 0:\n            return 1\n        elif num == 1:\n            return 3\n        elif num % 2 == 0:\n            return 1 + num / 2\n        else:\n            next_even_value = 1 + (num + 1) / 2 if (num + 1) % 2 == 0 else custom_sequence(num + 1)\n            return custom_sequence(num - 1) + custom_sequence(num - 2) + next_even_value\n    return [custom_sequence(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def helper(k: int) -> float:\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k > 1:\n            if k % 2 == 0:\n                return 1 + k / 2\n            else:\n                next_term = 1 + (k + 1) / 2 if (k + 1) % 2 == 0 else helper(k + 1)\n                return helper(k - 1) + helper(k - 2) + next_term\n    sequence = [helper(i) for i in range(n + 1)]\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def helper(k: int) -> float:\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            next_value = 1 + (k + 1) / 2 if (k + 1) % 2 == 0 else helper(k + 1)\n            return helper(k - 1) + helper(k - 2) + next_value\n    return [helper(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def calculate_tri(k: int) -> float:\n        if k == 0:\n            return 1\n        if k == 1:\n            return 3\n        if k % 2 == 0:\n            return 1 + k / 2\n        else:\n            next_term = 1 + (k + 1) / 2 if (k + 1) % 2 == 0 else calculate_tri(k + 1)\n            return calculate_tri(k - 1) + calculate_tri(k - 2) + next_term\n    return [calculate_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def helper(x: int) -> float:\n        if x == 0:\n            return 1\n        elif x == 1:\n            return 3\n        elif x % 2 == 0:\n            return 1 + x / 2\n        else:\n            return helper(x - 1) + helper(x - 2) + (1 + (x + 1) / 2 if (x + 1) % 2 == 0 else helper(x + 1))\n    return [helper(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tri_sequence(k: int, sequence: List[float]) -> float:\n        if k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return sequence[k - 1] + sequence[k - 2] + (1 + (k + 1) / 2 if (k + 1) % 2 == 0 else tri_sequence(k + 1, sequence))\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        sequence.append(tri_sequence(i, sequence))\n    return sequence", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def seq_value(m: int) -> float:\n        if m == 0:\n            return 1.0\n        elif m == 1:\n            return 3.0\n        elif m % 2 == 0:\n            return 1 + m / 2\n        else:\n            return seq_value(m - 1) + seq_value(m - 2) + (1 + (m + 1) / 2 if (m + 1) % 2 == 0 else seq_value(m + 1))\n    return [seq_value(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(k):\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return compute_tri(k - 1) + compute_tri(k - 2) + (1 + (k + 1) / 2 if (k + 1) % 2 == 0 else compute_tri(k + 1))\n    return [compute_tri(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def tri_value(k: int) -> float:\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return tri_value(k - 1) + tri_value(k - 2) + (1 + (k + 1) / 2 if (k + 1) % 2 == 0 else tri_value(k + 1))\n    return [tri_value(i) for i in range(n + 1)]", "from typing import List\n\ndef tri(n: int) -> List[float]:\n\n    def compute_tri(k: int) -> float:\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 3\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return sequence[k - 1] + sequence[k - 2] + (1 + (k + 1) / 2 if (k + 1) % 2 == 0 else compute_tri(k + 1))\n    sequence = []\n    for i in range(n + 1):\n        sequence.append(compute_tri(i))\n    return sequence"], "result": {"repaired_passk": 1.0, "cross_model_passk": 0.09999999999999998, "original_passk": 0.11111111111111116}}
{"task_id": "HumanEval/132", "requirement": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''", "generated_programs": ["def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    has_nested = True\n    return has_nested", "def is_nested(string: str) -> bool:\n    stack = []\n    has_nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    has_nested = True\n    return has_nested and (not stack)", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_found = True\n            else:\n                return False\n    return nested_found and (not stack)", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n            else:\n                stack.append(char)\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    nested_found = False\n    for char in string:\n        if char == '[':\n            stack.append('[')\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested_found = True\n            else:\n                return False\n    return nested_found and (not stack)", "def is_nested(string: str) -> bool:\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n    return nested", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n            else:\n                return False\n    return False", "def is_nested(string: str) -> bool:\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                if stack:\n                    return True\n    return False"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/140", "requirement": "def fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, first replace all sequences of three or more consecutive spaces with '-'.\n    Then, replace each remaining single space with '_'.\n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"", "generated_programs": ["import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('\\\\s', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub(' {3,}', '-', text)\n    text = re.sub(' ', '_', text)\n    return text", "import re\n\ndef fix_spaces(text: str) -> str:\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = re.sub('\\\\s', '_', text)\n    return text", "def fix_spaces(text: str) -> str:\n    import re\n    text = re.sub('\\\\s{3,}', '-', text)\n    text = text.replace(' ', '_')\n    return text"], "result": {"repaired_passk": 0.9, "cross_model_passk": 0.5, "original_passk": 0.30000000000000004}}
{"task_id": "HumanEval/145", "requirement": "from typing import List\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    If two numbers have the same sum of digits, their order should be determined\n    by their original index in the list, preserving the relative order from the input.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(c) for c in str(abs(x)))), nums.index(x)))", "from typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum((int(d) for d in str(abs(x)))), nums.index(x)))"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/153", "requirement": "from typing import List\n\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    \"\"\"Given the name of a class and a list of extensions, determine the strongest extension based on the difference between the number of uppercase and lowercase letters in the extension's name. Return the class name concatenated with the strongest extension in the format 'ClassName.StrongestExtensionName'. If the list of extensions is empty, return the class name alone. If multiple extensions have the same strength, choose the one that comes first in the list.\n\n    The strength of an extension is calculated as the difference between the number of uppercase letters (CAP) and the number of lowercase letters (SM) in the extension's name, i.e., strength = CAP - SM. The extension with the highest strength is considered the strongest. Strength can be positive, negative, or zero.\n\n    Example:\n    >>> Strongest_Extension('Slices', ['SErviNGSliCes', 'Cheese', 'StuFfed'])\n    'Slices.SErviNGSliCes'\n    >>> Strongest_Extension('my_class', ['AA', 'Be', 'CC'])\n    'my_class.AA'\n    >>> Strongest_Extension('EmptyClass', [])\n    'EmptyClass'\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def strength(extension: str) -> int:\n        cap_count = sum((1 for char in extension if char.isupper()))\n        sm_count = sum((1 for char in extension if char.islower()))\n        return cap_count - sm_count\n    strongest_extension = max(extensions, key=strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def strength(extension: str) -> int:\n        uppercase_count = sum((1 for ch in extension if ch.isupper()))\n        lowercase_count = sum((1 for ch in extension if ch.islower()))\n        return uppercase_count - lowercase_count\n    strongest_extension = max(extensions, key=strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n    strongest_extension = extensions[0]\n    max_strength = sum((1 for c in strongest_extension if c.isupper())) - sum((1 for c in strongest_extension if c.islower()))\n    for extension in extensions[1:]:\n        current_strength = sum((1 for c in extension if c.isupper())) - sum((1 for c in extension if c.islower()))\n        if current_strength > max_strength:\n            strongest_extension = extension\n            max_strength = current_strength\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def calculate_strength(extension: str) -> int:\n        uppercase_count = sum((1 for char in extension if char.isupper()))\n        lowercase_count = sum((1 for char in extension if char.islower()))\n        return uppercase_count - lowercase_count\n    if not extensions:\n        return class_name\n    max_strength_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{max_strength_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        return sum((1 for char in extension if char.isupper())) - sum((1 for char in extension if char.islower()))\n    strongest_extension = max(extensions, key=lambda ext: (calculate_strength(ext), -extensions.index(ext)))\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def extension_strength(extension: str) -> int:\n        uppercase_count = sum((1 for char in extension if char.isupper()))\n        lowercase_count = sum((1 for char in extension if char.islower()))\n        return uppercase_count - lowercase_count\n    if not extensions:\n        return class_name\n    strongest_extension = max(extensions, key=extension_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        uppercase_count = sum((1 for char in extension if char.isupper()))\n        lowercase_count = sum((1 for char in extension if char.islower()))\n        return uppercase_count - lowercase_count\n    strongest_extension = max(extensions, key=lambda ext: calculate_strength(ext))\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def extension_strength(extension: str) -> int:\n        cap = sum((1 for char in extension if char.isupper()))\n        sm = sum((1 for char in extension if char.islower()))\n        return cap - sm\n    strongest_extension = max(extensions, key=lambda ext: extension_strength(ext))\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    if not extensions:\n        return class_name\n\n    def calculate_strength(extension: str) -> int:\n        return sum((1 for c in extension if c.isupper())) - sum((1 for c in extension if c.islower()))\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f'{class_name}.{strongest_extension}'", "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n\n    def extension_strength(extension: str) -> int:\n        uppercase_count = sum((1 for char in extension if char.isupper()))\n        lowercase_count = sum((1 for char in extension if char.islower()))\n        return uppercase_count - lowercase_count\n    if not extensions:\n        return class_name\n    strongest_extension = max(extensions, key=extension_strength)\n    return f'{class_name}.{strongest_extension}'"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 1.0}}
{"task_id": "HumanEval/154", "requirement": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word. \n    If the second word is an empty string, the function should return True, as an empty string is considered a valid substring of any string.\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"", "generated_programs": ["def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    for i in range(len(b)):\n        rotated_b = b[i:] + b[:i]\n        if rotated_b in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    for i in range(len(b)):\n        rotated_b = b[i:] + b[:i]\n        if rotated_b in a:\n            return True\n    return False", "def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "from typing import List\n\ndef cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if not b:\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rotation in a for rotation in rotations))", "def cycpattern_check(a: str, b: str) -> bool:\n    if b == '':\n        return True\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    return any((rot in a for rot in rotations))"], "result": {"repaired_passk": 1.0, "cross_model_passk": 1.0, "original_passk": 0.19999999999999996}}
{"task_id": "HumanEval/160", "requirement": "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists `operator` and `operand`, construct an algebraic expression using the operators and operands, \n    and return the evaluation of this expression. The expression should be evaluated according to standard mathematical \n    operator precedence, where multiplication and division take precedence over addition and subtraction.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of the `operator` list must be one less than the length of the `operand` list.\n        The `operand` list contains non-negative integers.\n        The `operator` list must contain at least one operator, and the `operand` list must contain at least two operands.\n    \"\"\"", "generated_programs": ["from typing import List\nimport operator as op\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    precedence = {'**': 3, '*': 2, '//': 2, '+': 1, '-': 1}\n    operators = {'+': op.add, '-': op.sub, '*': op.mul, '//': op.floordiv, '**': op.pow}\n\n    def evaluate(operands, operators_stack):\n        right = operands.pop()\n        left = operands.pop()\n        operation = operators[operators_stack.pop()]\n        operands.append(operation(left, right))\n    values = []\n    ops = []\n    values.append(operand[0])\n    index = 1\n    for token in operator:\n        values.append(operand[index])\n        index += 1\n        while ops and precedence[token] <= precedence[ops[-1]]:\n            evaluate(values, ops)\n        ops.append(token)\n    while ops:\n        evaluate(values, ops)\n    return values[0]", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression_parts = []\n    for i in range(len(operator)):\n        expression_parts.append(str(operand[i]))\n        expression_parts.append(operator[i])\n    expression_parts.append(str(operand[-1]))\n    expression = ''.join(expression_parts)\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = []\n    for i in range(len(operator)):\n        expression.append(str(operand[i]))\n        expression.append(operator[i])\n    expression.append(str(operand[-1]))\n    eval_expression = ''.join(expression)\n    return eval(eval_expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = []\n    for i in range(len(operator)):\n        expression.append(str(operand[i]))\n        expression.append(operator[i])\n    expression.append(str(operand[-1]))\n    return eval(' '.join(expression))", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    from operator import add, sub, mul, floordiv, pow\n    import re\n    expression = ''\n    for i in range(len(operator)):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    valid_operators = {'+', '-', '*', '//', '**'}\n    if all((op in valid_operators for op in operator)) and all((isinstance(num, int) and num >= 0 for num in operand)):\n        return eval(expression)\n    return 0", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = ''\n    for i in range(len(operator)):\n        expression += f'{operand[i]} {operator[i]} '\n    expression += f'{operand[-1]}'\n    return eval(expression)", "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += f' {operator[i]} {operand[i + 1]}'\n    return eval(expression)"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
{"task_id": "HumanEval/163", "requirement": "def generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return all integers between the smaller and larger of the two numbers (inclusive) \n    where every digit in the integer is even. The result should be in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"", "generated_programs": ["from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(d) % 2 == 0 for d in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [x for x in range(start, end + 1) if all_digits_even(x)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def is_all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    lower, upper = (min(a, b), max(a, b))\n    return [num for num in range(lower, upper + 1) if is_all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(d) % 2 == 0 for d in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [i for i in range(start, end + 1) if all_digits_even(i)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(d) % 2 == 0 for d in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(n: int) -> bool:\n        return all((int(digit) % 2 == 0 for digit in str(n)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]", "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n\n    def all_digits_even(num: int) -> bool:\n        return all((int(d) % 2 == 0 for d in str(num)))\n    start, end = (min(a, b), max(a, b))\n    return [num for num in range(start, end + 1) if all_digits_even(num)]"], "result": {"repaired_passk": 0.0, "cross_model_passk": 0.0, "original_passk": 0.0}}
